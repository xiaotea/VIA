import os
import re
import json
import time
import copy
from openai import OpenAI


# Setup OpenAI client
base_url = "https://api.deepseek.com/v1"
api_key = ""  #  API_KEY
model = "deepseek-reasoner"
client = OpenAI(
    api_key=api_key,
    base_url=base_url,
    timeout=180
)

# Main function to analyze a CVE case using LLM
def llm_answer_for_cve(input_file):
    item = input_file.split(os.sep)[-1]
    # Markers used to separate sections in the input file
    markers = ["漏洞描述：", "补丁代码：", "待检测代码："]
    pattern = r'(?:' + '|'.join(markers) + r')'

    com_name = "@".join(item.split("@")[2:])
    cve_name = item.split("@")[0]
    commmitid = item.split("@")[1]

    # Read and parse input file content
    with open(input_file, "r", encoding="utf-8") as f:
        segments = re.split(pattern, f.read())

    # Prepare three user inputs for step-wise reasoning
    user_input = "***漏洞描述***：" + segments[1]
    user_input2 = "***补丁代码***：" + segments[2]
    user_input3 = (
            "需要根据历史对话中的补丁代码和漏洞描述，以及分析原理。判断\"待检测代码\"是否存在和漏洞描述和补丁相关的漏洞。\"待检测代码\"若存在补丁中删除的代码逻辑则*有漏洞*，若存在新增的代码逻辑则*没漏洞*\n，若不存在新增或删除的代码需要根据漏洞描述和补丁的原理分析待检测代码的组件中是否有相关的漏洞。"
            "***待检测代码：***" + segments[3])
    str_empty = "空\n"

    result = {
        "item": item,
        "response": "不存在",
    }

    # If there's meaningful code to check
    if segments[3].strip() != "空":
        print(f"正在处理文件: {input_file}")

        sys_promot = r'''  
                你是一名专业的漏洞代码分析专家，专注于通过代码比对和漏洞原理分析来判断代码漏洞的存在性。你的任务是根据提供的漏洞描述、补丁代码和待检测代码，进行系统性的漏洞分析。请按照以下步骤执行：
                理解漏洞原理：
                        仔细阅读漏洞描述，明确漏洞的类型、触发条件和潜在影响。
                        分析补丁代码，理解修复的逻辑和关键修改点。
                代码比对与分析：
                    在待检测代码中查找与补丁代码中修改部分相似或一致的代码逻辑,只能依靠给你的代码片段推理分析。
                    重点关注以下方面：
                        代码结构（如函数、循环、条件判断等）。
                        关键变量或函数的调用方式。
                        可能触发漏洞的边界条件或输入处理逻辑。
                漏洞存在性判断：
                    如果待检测代码中存在与补丁代码相似的漏洞逻辑，则判定为存在漏洞。
                    如果待检测代码中不存在相似逻辑，或已包含补丁的修复内容，则判定为不存在漏洞。
                    如果和补丁代码不一致，则判定为不存在漏洞。
                    如果无法确定，请明确说明需要进一步的信息或分析。
                输出结果：
                    清晰说明分析结论（存在/不存在漏洞）。
                    简要解释判断依据，包括代码相似点和漏洞原理的关联。
                请在我分三次提供“漏洞描述”、“补丁代码”和“待检测代码”后，按照上述步骤进行分析并输出结果。
        '''
        messages = [
            {"role": "system", "content": sys_promot},  # 系统消息保持在最前面
        ]

        # 第一次交互
        messages.append({"role": "user", "content": user_input})
        completion = client.chat.completions.create(
            model=model,
            messages=messages,
            max_tokens=1000
        )
        first_answer = completion.choices[0].message.content
        messages.append({"role": "assistant", "content": first_answer})  # 改为assistant

        # 第二次交互
        messages.append({"role": "user", "content": user_input2})
        completion = client.chat.completions.create(
            model=model,
            messages=messages,
            max_tokens=1000
        )
        second_answer = completion.choices[0].message.content
        messages.append({"role": "assistant", "content": second_answer})  # 改为assistant



        messages.append({"role": "user", "content": user_input3})
        completion = client.chat.completions.create(
            model=model,
            messages=messages
        )
        third_response = completion.choices[0].message.content  # 更清晰的变量命名

        # 构建最终判断指令（保持系统消息稳定）
        system_prompt = """您需要根据检测结果回答以下两种情况之一：
        1. 待检测代码发现漏洞 -> "有漏洞"
        2. 待检测代码未发现漏洞 -> "没漏洞"
        请直接给出指定回答，不要添加任何解释。"""

        # 保持完整的对话上下文（不重置messages）
        messages = [
            {"role": "system", "content": system_prompt},  # 确保系统提示作为第一条
            {"role": "user", "content": f"漏洞检测结果如下：{third_response}"}
        ]

        # 最终判定请求
        completion = client.chat.completions.create(
            model=model,
            messages=messages
        )
        final_judgment = completion.choices[0].message.content.strip()

        print("判断结果:", final_judgment)
        result = {
            "item": item,
            "response": final_judgment,
            "reason": third_response
        }

        result = {"item": item, "response": final_judgment, "reason": third_response}
    return result


def run_parallel_cve_analysis(analyze_file_path):
    analyze_res = llm_answer_for_cve(analyze_file_path)
    print(analyze_res)

    """
    output:demo
    {'item': './test_data/CVE-2009-2959@a08ee48e796ae66c54fca6a087b4adce7d1d6c06@buildbot@0.7.11p3', 'response': '没漏洞', 'reason': '根据提供的漏洞描述、补丁代码和待检测代码，进行如下分析：\n\n1. **漏洞原理分析**：\n   - 漏洞类型：跨站脚本(XSS)漏洞\n   - 位置：waterfall.py中的HTML表格生成部分\n   - 触发条件：未过滤的value和name参数直接插入HTML\n   - 修复方式：使用html.escape()对value和name进行HTML实体编码\n\n2. **代码比对分析**：\n   - 补丁代码修改点：在字符串格式化前添加了html.escape()对value和name的转义\n   - 待检测代码检查：\n     - 在WaterfallHelp类的body方法中，找到了与补丁对应的代码段\n     - 关键代码位置：生成show_reload_input表格的部分\n     - 当前实现：已经使用了html.escape(value)和html.escape(name)\n\n3. **关键发现**：\n   - 待检测代码中已经包含了补丁的修复内容\n   - 所有用户输入的value和name变量都已正确使用html.escape()进行转义\n   - 其他类似位置(如show_branches_input)也正确使用了html.escape()\n\n4. **漏洞存在性判断**：\n   - **结论**：不存在漏洞\n   - **判断依据**：\n     1. 待检测代码已经实现了补丁中的修复措施\n     2. 所有用户可控输入都经过了正确的HTML实体编码\n     3. 没有发现补丁中删除的漏洞代码逻辑\n     4. 代码版本(0.7.11p3)高于漏洞影响的最高版本(0.7.11p1)\n\n5. **其他观察**：\n   - 代码中其他可能产生XSS的位置(如BuildBox、StepBox等)也都正确使用了html.escape()\n   - 项目整体对XSS防护有较好的意识，关键输出点都进行了编码处理\n\n该版本代码已经包含了修复XSS漏洞的所有必要措施，因此不存在漏洞描述中的安全问题。'}
    
    """

# Entry point
if __name__ == "__main__":
    run_parallel_cve_analysis(r"./test_data/CVE-2009-2959@a08ee48e796ae66c54fca6a087b4adce7d1d6c06@buildbot@0.7.11p3")
