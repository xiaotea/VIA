import json
import os
from extract_functions import extract_code_entities_with_ctags, readFile
import uuid
from threading import get_ident
import tempfile
# def process_patch_file(patch_file_content):
#     temp_file_path = "temp_code.py"
#     with open(temp_file_path, 'w', encoding='utf-8') as temp_file:
#         temp_file.write("\n".join(patch_file_content))
#
#     functions = extract_code_entities_with_ctags(temp_file_path)
#     os.remove(temp_file_path)
#
#     return functions


def process_patch_file(patch_file_content):
    # 方法1：使用线程ID+随机UUID生成唯一文件名
    temp_file_path = f"temp_code_{get_ident()}_{uuid.uuid4().hex}.py"

    # 方法2：使用系统安全临时文件（推荐）
    with tempfile.NamedTemporaryFile(
            mode='w+',
            suffix='.py',
            encoding='utf-8',
            delete=True
    ) as temp_file:
        temp_file.write("\n".join(patch_file_content))
        temp_file.flush()  # 确保写入磁盘

        # 处理文件内容
        functions = extract_code_entities_with_ctags(temp_file.name)

        # 文件自动删除（with语句保证）
    return functions

def function_in_range(func, ranges):
    func_start = func['start_line']
    func_end = func['end_line'] if func['end_line'] is not None else func_start
    for start, end in ranges:
        # 如果两个区间有交集，则返回 True，交集判断条件：func_start<=range_end and func_end>=range_start
        if func_start <= end and func_end >= start:
            return True
    return False


def filter_nested_functions(functions):
    filtered_functions = []
    for f in functions:
        is_nested = False
        # 如果 f 的 end_line 为 None 则按照 start_line 判断
        f_start = f["start_line"]
        f_end = f["end_line"] if f["end_line"] is not None else f_start
        for p in functions:
            if p is f:
                continue
            # 这里只考虑类型为 "class" 的父级，可以根据需要扩展到其他容器
            if p["type"] == "class":
                p_start = p["start_line"]
                # 如果父类没有 end_line，则认为 p 不能作为容器
                if p["end_line"] is None:
                    continue
                p_end = p["end_line"]
                if p_start <= f_start and f_end <= p_end:
                    is_nested = True
                    break
        if not is_nested:
            filtered_functions.append(f)
    return filtered_functions


def reconstruct_code(json_data):
    output_data = {}  # 用于保存最终的输出数据
    for file_path, file_info in json_data.items():
        patch = file_info.get("Patch", {})
        actions = file_info.get("action", [])

        before_lines = {}
        after_lines = {}

        # 按照 patch 字典的 key 顺序处理
        sorted_patch_keys = sorted(patch.keys(), key=lambda x: int(x))

        for key in sorted_patch_keys:
            patch_data = patch[key]
            code_line = patch_data.get("PatchRowcode", "")

            # 取得 before & after 行号 (可能为空字符串)
            before_line_num = patch_data.get("beforePatchRowNumber", "")
            before_line_num = str(before_line_num)
            after_line_num = patch_data.get("afterPatchRowNumber", "")
            after_line_num = str(after_line_num)

            # 检查数字有效性
            if (before_line_num).isdigit():
                before_lines[int(before_line_num)] = code_line

            if after_line_num.isdigit():
                after_lines[int(after_line_num)] = code_line

        def get_ranges(line_numbers):
            if not line_numbers:
                return []
            sorted_lines = sorted(line_numbers)
            ranges = []
            start = sorted_lines[0]
            end = sorted_lines[0]
            for i in range(1, len(sorted_lines)):
                if sorted_lines[i] == end + 1:  # 连续行
                    end = sorted_lines[i]
                else:  # 不连续，保存当前范围
                    ranges.append((start, end))
                    start = sorted_lines[i]
                    end = sorted_lines[i]
            ranges.append((start, end))
            return ranges

        before_ranges = get_ranges(before_lines.keys())

        # 处理 frontPatchFile 和 afterPatchFile
        front_patch_file = file_info.get("frontPatchFile", [])

        front_functions = process_patch_file(front_patch_file) if front_patch_file else []

        # 保存函数信息到输出数据
        output_data[file_path] = {
            "code": [],
            # "after_functions": []
        }

        # 处理修改前的函数信息：判断函数区域与补丁范围是否有交集
        if before_ranges:
            before_ranges_str = ', '.join([f"{start} - {end}" for start, end in before_ranges])

            # 过滤掉嵌套的成员函数，只保留顶层函数或者类
            # 可以调用 filter_nested_functions，如果需要全部则直接使用 front_functions
            filtered_front_functions = front_functions
            for func in filtered_front_functions:
                if function_in_range(func, before_ranges):
                    # 如果实体类型为class，则检测行数是否小于200
                    if func['type'] == 'class':
                        line_count = (func['end_line'] - func['start_line'] + 1) if func['end_line'] is not None else 1
                        if line_count >= 200:
                            # 如果class行数大于或等于200，不保存，跳过该实体
                            continue

                    # 保存满足条件的实体信息
                    output_data[file_path]["code"].append({
                        "name": func['name'],
                        "code": func['code'],
                        # "start_line": func['start_line'],
                        # "end_line": func['end_line'],
                        # "type": func['type']
                    })

    output_json_file = "output_functions.json"
    with open(output_json_file, 'w', encoding='utf-8') as f:
        json.dump(output_data, f, indent=4, ensure_ascii=False)

    return output_data


if __name__ == "__main__":
    json_file = r"D:\D\个人文件\开源软件供应链安全\python漏洞影响性分析实验\知识图谱创建\整理好的\patchDictNew\f77cbc607d6e2a62e63287d37ad320109a2cc78a"  # 替换为实际的 JSON 文件路径
    with open(json_file, "r", encoding="utf-8") as f:
        data = json.load(f)

    print(reconstruct_code(data))