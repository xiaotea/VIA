import json
import requests
import os
import zipfile
import tarfile
import concurrent.futures
import shutil
def to_long_path(path):
    """将路径转换为 UNC 长路径格式（仅在 Windows 下有效）"""
    absolute_path = os.path.abspath(path)
    if not absolute_path.startswith('\\\\?\\'):
        return '\\\\?\\' + absolute_path
    return absolute_path

def remove_top_level_folder(extract_path):
    """
    如果解压目录下只有一个文件夹，则把此文件夹内的所有文件移动到解压目录中，再删除该文件夹。
    """
    items = os.listdir(extract_path)
    if len(items) == 1:
        only_item = os.path.join(extract_path, items[0])
        if os.path.isdir(only_item):
            # 将 only_item 内的所有内容上移到 extract_path 中
            for item in os.listdir(only_item):
                s = os.path.join(only_item, item)
                d = os.path.join(extract_path, item)
                shutil.move(s, d)
            # 删除空目录
            os.rmdir(only_item)
            print(f"已删除解压后最外层目录：{only_item}")

def process_release_file(file_url, full_download_path):
    """
    下载单个文件并解压，如果是 whl 文件则重命名为 zip 后解压。
    解压后删除最外层文件夹（如果存在）。
    使用 UNC 前缀处理长路径问题（仅 Windows 下有效）。
    """
    print(f"正在下载: {file_url}")
    file_name = file_url.split("/")[-1]
    file_path_local = os.path.join(full_download_path, file_name)
    # 转换为 UNC 格式
    file_path_local = to_long_path(file_path_local)
    try:
        # 下载文件，使用 stream 方式分块写入本地
        with requests.get(file_url, stream=True) as r:
            r.raise_for_status()
            with open(file_path_local, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
        print(f"下载完成，文件保存到: {file_path_local}")

        # 如果文件后缀为 .whl，则重命名为 .zip 以便后续解压
        if file_name.endswith('.whl'):
            new_file_path = file_path_local[:-4] + ".zip"
            os.rename(file_path_local, new_file_path)
            file_path_local = new_file_path
            file_name = os.path.basename(new_file_path)
            print(f"文件扩展名从 .whl 修改为 .zip: {file_path_local}")

        # 解压文件到一个以文件名加 _extracted 后缀命名的目录中，
        # 同样转换为 UNC 路径
        extract_path = os.path.join(full_download_path, file_name + "_extracted")
        extract_path = to_long_path(extract_path)
        if not os.path.exists(extract_path):
            os.makedirs(extract_path)
        if file_name.endswith('.zip'):
            with zipfile.ZipFile(file_path_local, 'r') as zip_ref:
                zip_ref.extractall(extract_path)
            print(f"解压 .zip 文件到: {extract_path}")
        elif file_name.endswith((".tar.gz", ".tgz", ".tar")):
            with tarfile.open(file_path_local, 'r:*') as tar_ref:
                tar_ref.extractall(extract_path)
            print(f"解压归档文件到: {extract_path}")
        else:
            print(f"文件 {file_name} 不是支持的压缩格式，不进行解压。")
            return

        # 解压完成后删除最外层文件夹（若存在）
        remove_top_level_folder(extract_path)
        if os.path.exists(file_path_local):
            os.remove(file_path_local)
            print(f"压缩包 {file_name} 已删除。")

    except Exception as e:
        print(f"下载或解压 {file_url} 失败: {e}")

def extract_googleaffected(file_path, cveid):
    """
    从 JSON 文件中提取指定 CVE 的 googleaffected 信息。
    返回字典，包含 package_name 与 versions（如果有）。
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            data = json.load(file)
            results = {}
            for cve_id, cve_info in data.items():
                if cve_id == cveid:
                    if "googleaffected" in cve_info and cve_info["googleaffected"]:
                        for affected in cve_info["googleaffected"]:
                            if "package" in affected and "purl" in affected["package"]:
                                package_url = affected["package"]["purl"]
                                package_name = package_url.split('/')[-1]
                                if "versions" in affected:
                                    results["versions"] = affected["versions"]
                                    results["package_name"] = package_name
                    else:
                        print(f"CVE ID: {cve_id} 没有 googleaffected 数据。")
            return results
    except FileNotFoundError:
        print(f"文件 {file_path} 未找到。")
    except json.JSONDecodeError:
        print(f"文件 {file_path} 不是有效的 JSON 格式。")
    except Exception as e:
        print(f"发生错误: {e}")

def download_and_extract(package, versions, base_folder, cve_id, download_folder):
    """
    根据给定包名下载所有对应版本的源码包并解压，
    解压目录为 base_folder/download_folder/<CVE编号> 目录下。
    """
    # 建议将基础目录设置较短以减少总体路径长度
    full_download_path = os.path.join(base_folder, download_folder, cve_id)
    full_download_path = to_long_path(full_download_path)
    if not os.path.exists(full_download_path):
        os.makedirs(full_download_path)
        print(f"创建下载目录: {full_download_path}")

    response = requests.get(f"https://pypi.org/pypi/{package}/json")
    if response.status_code == 200:
        data = response.json()
        tasks = []
        releases = data.get("releases", {})
        for version in releases.keys():
            # 判断版本是否在需要处理的版本列表中
            if version in versions:
                for inf in data["releases"][version]:
                    if "url" in inf and "source" in inf.get("python_version", ""):
                        file_url = inf["url"]
                        print(f"版本 {version} 的文件：{file_url}")
                        tasks.append(file_url)
        if tasks:
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future_to_url = {executor.submit(process_release_file, url, full_download_path): url for url in tasks}
                for future in concurrent.futures.as_completed(future_to_url):
                    url = future_to_url[future]
                    try:
                        future.result()
                    except Exception as e:
                        print(f"处理 {url} 时出现异常: {e}")
    else:
        print(f"无法获取包 {package} 的信息，状态码：{response.status_code}")

if __name__ == "__main__":
    json_file_path = 'data/allvul3.json'
    cve_list = [
        "CVE-2022-4728", "CVE-2020-10691", "CVE-2023-46121", "CVE-2022-4510",
        "CVE-2016-9014", "CVE-2023-4570", "CVE-2022-3371", "CVE-2015-7529",
        "CVE-2023-31146", "CVE-2020-28724"
    ]
    # 建议将基础目录设为较短路径，例如 "E:\cmp"
    base_folder = r'F:\python_project\data'
    download_folder = "downloaded_packages"

    for cve_id in cve_list:
        print(f"正在处理 {cve_id}")
        result = extract_googleaffected(json_file_path, cve_id)
        if result:
            package = result.get("package_name")
            versions = result.get("versions", [])
            if package and versions:
                print(f"处理 {cve_id} 的包 {package} 版本: {versions}")
                download_and_extract(package, versions, base_folder, cve_id, download_folder)
            else:
                print(f"{cve_id} 没有获得完整的包信息或版本信息。")
        else:
            print(f"未在 JSON 文件中找到 {cve_id} 的数据。")