{
    "src/websockets/legacy/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import functools"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+import hmac"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import http"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     if credentials is not None:"
            },
            "9": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         if is_credentials(credentials):"
            },
            "10": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            async def check_credentials(username: str, password: str) -> bool:"
            },
            "12": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return (username, password) == credentials"
            },
            "13": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            credentials_list = [cast(Credentials, credentials)]"
            },
            "15": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         elif isinstance(credentials, Iterable):"
            },
            "16": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             credentials_list = list(credentials)"
            },
            "17": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if all(is_credentials(item) for item in credentials_list):"
            },
            "18": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                credentials_dict = dict(credentials_list)"
            },
            "19": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "20": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                async def check_credentials(username: str, password: str) -> bool:"
            },
            "21": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return credentials_dict.get(username) == password"
            },
            "22": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "23": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            if not all(is_credentials(item) for item in credentials_list):"
            },
            "25": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "                 raise TypeError(f\"invalid credentials argument: {credentials}\")"
            },
            "26": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "27": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         else:"
            },
            "28": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             raise TypeError(f\"invalid credentials argument: {credentials}\")"
            },
            "29": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        credentials_dict = dict(credentials_list)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        async def check_credentials(username: str, password: str) -> bool:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            try:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                expected_password = credentials_dict[username]"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            except KeyError:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                return False"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            return hmac.compare_digest(expected_password, password)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     if create_protocol is None:"
            },
            "40": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         # Not sure why mypy cannot figure this out."
            },
            "41": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         create_protocol = cast("
            },
            "42": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         )"
            },
            "43": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     return functools.partial("
            },
            "45": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        create_protocol, realm=realm, check_credentials=check_credentials"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        create_protocol,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        realm=realm,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        check_credentials=check_credentials,"
            },
            "49": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     )"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ":mod:`websockets.legacy.auth` provides HTTP Basic Authentication according to",
            ":rfc:`7235` and :rfc:`7617`.",
            "",
            "\"\"\"",
            "",
            "",
            "import functools",
            "import http",
            "from typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast",
            "",
            "from ..datastructures import Headers",
            "from ..exceptions import InvalidHeader",
            "from ..headers import build_www_authenticate_basic, parse_authorization_basic",
            "from .server import HTTPResponse, WebSocketServerProtocol",
            "",
            "",
            "__all__ = [\"BasicAuthWebSocketServerProtocol\", \"basic_auth_protocol_factory\"]",
            "",
            "Credentials = Tuple[str, str]",
            "",
            "",
            "def is_credentials(value: Any) -> bool:",
            "    try:",
            "        username, password = value",
            "    except (TypeError, ValueError):",
            "        return False",
            "    else:",
            "        return isinstance(username, str) and isinstance(password, str)",
            "",
            "",
            "class BasicAuthWebSocketServerProtocol(WebSocketServerProtocol):",
            "    \"\"\"",
            "    WebSocket server protocol that enforces HTTP Basic Auth.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args: Any,",
            "        realm: str,",
            "        check_credentials: Callable[[str, str], Awaitable[bool]],",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.realm = realm",
            "        self.check_credentials = check_credentials",
            "        super().__init__(*args, **kwargs)",
            "",
            "    async def process_request(",
            "        self, path: str, request_headers: Headers",
            "    ) -> Optional[HTTPResponse]:",
            "        \"\"\"",
            "        Check HTTP Basic Auth and return a HTTP 401 or 403 response if needed.",
            "",
            "        \"\"\"",
            "        try:",
            "            authorization = request_headers[\"Authorization\"]",
            "        except KeyError:",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Missing credentials\\n\",",
            "            )",
            "",
            "        try:",
            "            username, password = parse_authorization_basic(authorization)",
            "        except InvalidHeader:",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Unsupported credentials\\n\",",
            "            )",
            "",
            "        if not await self.check_credentials(username, password):",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Invalid credentials\\n\",",
            "            )",
            "",
            "        self.username = username",
            "",
            "        return await super().process_request(path, request_headers)",
            "",
            "",
            "def basic_auth_protocol_factory(",
            "    realm: str,",
            "    credentials: Optional[Union[Credentials, Iterable[Credentials]]] = None,",
            "    check_credentials: Optional[Callable[[str, str], Awaitable[bool]]] = None,",
            "    create_protocol: Optional[Callable[[Any], BasicAuthWebSocketServerProtocol]] = None,",
            ") -> Callable[[Any], BasicAuthWebSocketServerProtocol]:",
            "    \"\"\"",
            "    Protocol factory that enforces HTTP Basic Auth.",
            "",
            "    ``basic_auth_protocol_factory`` is designed to integrate with",
            "    :func:`~websockets.legacy.server.serve` like this::",
            "",
            "        websockets.serve(",
            "            ...,",
            "            create_protocol=websockets.basic_auth_protocol_factory(",
            "                realm=\"my dev server\",",
            "                credentials=(\"hello\", \"iloveyou\"),",
            "            )",
            "        )",
            "",
            "    ``realm`` indicates the scope of protection. It should contain only ASCII",
            "    characters because the encoding of non-ASCII characters is undefined.",
            "    Refer to section 2.2 of :rfc:`7235` for details.",
            "",
            "    ``credentials`` defines hard coded authorized credentials. It can be a",
            "    ``(username, password)`` pair or a list of such pairs.",
            "",
            "    ``check_credentials`` defines a coroutine that checks whether credentials",
            "    are authorized. This coroutine receives ``username`` and ``password``",
            "    arguments and returns a :class:`bool`.",
            "",
            "    One of ``credentials`` or ``check_credentials`` must be provided but not",
            "    both.",
            "",
            "    By default, ``basic_auth_protocol_factory`` creates a factory for building",
            "    :class:`BasicAuthWebSocketServerProtocol` instances. You can override this",
            "    with the ``create_protocol`` parameter.",
            "",
            "    :param realm: scope of protection",
            "    :param credentials: hard coded credentials",
            "    :param check_credentials: coroutine that verifies credentials",
            "    :raises TypeError: if the credentials argument has the wrong type",
            "",
            "    \"\"\"",
            "    if (credentials is None) == (check_credentials is None):",
            "        raise TypeError(\"provide either credentials or check_credentials\")",
            "",
            "    if credentials is not None:",
            "        if is_credentials(credentials):",
            "",
            "            async def check_credentials(username: str, password: str) -> bool:",
            "                return (username, password) == credentials",
            "",
            "        elif isinstance(credentials, Iterable):",
            "            credentials_list = list(credentials)",
            "            if all(is_credentials(item) for item in credentials_list):",
            "                credentials_dict = dict(credentials_list)",
            "",
            "                async def check_credentials(username: str, password: str) -> bool:",
            "                    return credentials_dict.get(username) == password",
            "",
            "            else:",
            "                raise TypeError(f\"invalid credentials argument: {credentials}\")",
            "",
            "        else:",
            "            raise TypeError(f\"invalid credentials argument: {credentials}\")",
            "",
            "    if create_protocol is None:",
            "        # Not sure why mypy cannot figure this out.",
            "        create_protocol = cast(",
            "            Callable[[Any], BasicAuthWebSocketServerProtocol],",
            "            BasicAuthWebSocketServerProtocol,",
            "        )",
            "",
            "    return functools.partial(",
            "        create_protocol, realm=realm, check_credentials=check_credentials",
            "    )"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ":mod:`websockets.legacy.auth` provides HTTP Basic Authentication according to",
            ":rfc:`7235` and :rfc:`7617`.",
            "",
            "\"\"\"",
            "",
            "",
            "import functools",
            "import hmac",
            "import http",
            "from typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast",
            "",
            "from ..datastructures import Headers",
            "from ..exceptions import InvalidHeader",
            "from ..headers import build_www_authenticate_basic, parse_authorization_basic",
            "from .server import HTTPResponse, WebSocketServerProtocol",
            "",
            "",
            "__all__ = [\"BasicAuthWebSocketServerProtocol\", \"basic_auth_protocol_factory\"]",
            "",
            "Credentials = Tuple[str, str]",
            "",
            "",
            "def is_credentials(value: Any) -> bool:",
            "    try:",
            "        username, password = value",
            "    except (TypeError, ValueError):",
            "        return False",
            "    else:",
            "        return isinstance(username, str) and isinstance(password, str)",
            "",
            "",
            "class BasicAuthWebSocketServerProtocol(WebSocketServerProtocol):",
            "    \"\"\"",
            "    WebSocket server protocol that enforces HTTP Basic Auth.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args: Any,",
            "        realm: str,",
            "        check_credentials: Callable[[str, str], Awaitable[bool]],",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.realm = realm",
            "        self.check_credentials = check_credentials",
            "        super().__init__(*args, **kwargs)",
            "",
            "    async def process_request(",
            "        self, path: str, request_headers: Headers",
            "    ) -> Optional[HTTPResponse]:",
            "        \"\"\"",
            "        Check HTTP Basic Auth and return a HTTP 401 or 403 response if needed.",
            "",
            "        \"\"\"",
            "        try:",
            "            authorization = request_headers[\"Authorization\"]",
            "        except KeyError:",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Missing credentials\\n\",",
            "            )",
            "",
            "        try:",
            "            username, password = parse_authorization_basic(authorization)",
            "        except InvalidHeader:",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Unsupported credentials\\n\",",
            "            )",
            "",
            "        if not await self.check_credentials(username, password):",
            "            return (",
            "                http.HTTPStatus.UNAUTHORIZED,",
            "                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],",
            "                b\"Invalid credentials\\n\",",
            "            )",
            "",
            "        self.username = username",
            "",
            "        return await super().process_request(path, request_headers)",
            "",
            "",
            "def basic_auth_protocol_factory(",
            "    realm: str,",
            "    credentials: Optional[Union[Credentials, Iterable[Credentials]]] = None,",
            "    check_credentials: Optional[Callable[[str, str], Awaitable[bool]]] = None,",
            "    create_protocol: Optional[Callable[[Any], BasicAuthWebSocketServerProtocol]] = None,",
            ") -> Callable[[Any], BasicAuthWebSocketServerProtocol]:",
            "    \"\"\"",
            "    Protocol factory that enforces HTTP Basic Auth.",
            "",
            "    ``basic_auth_protocol_factory`` is designed to integrate with",
            "    :func:`~websockets.legacy.server.serve` like this::",
            "",
            "        websockets.serve(",
            "            ...,",
            "            create_protocol=websockets.basic_auth_protocol_factory(",
            "                realm=\"my dev server\",",
            "                credentials=(\"hello\", \"iloveyou\"),",
            "            )",
            "        )",
            "",
            "    ``realm`` indicates the scope of protection. It should contain only ASCII",
            "    characters because the encoding of non-ASCII characters is undefined.",
            "    Refer to section 2.2 of :rfc:`7235` for details.",
            "",
            "    ``credentials`` defines hard coded authorized credentials. It can be a",
            "    ``(username, password)`` pair or a list of such pairs.",
            "",
            "    ``check_credentials`` defines a coroutine that checks whether credentials",
            "    are authorized. This coroutine receives ``username`` and ``password``",
            "    arguments and returns a :class:`bool`.",
            "",
            "    One of ``credentials`` or ``check_credentials`` must be provided but not",
            "    both.",
            "",
            "    By default, ``basic_auth_protocol_factory`` creates a factory for building",
            "    :class:`BasicAuthWebSocketServerProtocol` instances. You can override this",
            "    with the ``create_protocol`` parameter.",
            "",
            "    :param realm: scope of protection",
            "    :param credentials: hard coded credentials",
            "    :param check_credentials: coroutine that verifies credentials",
            "    :raises TypeError: if the credentials argument has the wrong type",
            "",
            "    \"\"\"",
            "    if (credentials is None) == (check_credentials is None):",
            "        raise TypeError(\"provide either credentials or check_credentials\")",
            "",
            "    if credentials is not None:",
            "        if is_credentials(credentials):",
            "            credentials_list = [cast(Credentials, credentials)]",
            "        elif isinstance(credentials, Iterable):",
            "            credentials_list = list(credentials)",
            "            if not all(is_credentials(item) for item in credentials_list):",
            "                raise TypeError(f\"invalid credentials argument: {credentials}\")",
            "        else:",
            "            raise TypeError(f\"invalid credentials argument: {credentials}\")",
            "",
            "        credentials_dict = dict(credentials_list)",
            "",
            "        async def check_credentials(username: str, password: str) -> bool:",
            "            try:",
            "                expected_password = credentials_dict[username]",
            "            except KeyError:",
            "                return False",
            "            return hmac.compare_digest(expected_password, password)",
            "",
            "    if create_protocol is None:",
            "        # Not sure why mypy cannot figure this out.",
            "        create_protocol = cast(",
            "            Callable[[Any], BasicAuthWebSocketServerProtocol],",
            "            BasicAuthWebSocketServerProtocol,",
            "        )",
            "",
            "    return functools.partial(",
            "        create_protocol,",
            "        realm=realm,",
            "        check_credentials=check_credentials,",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "135": [
                "basic_auth_protocol_factory"
            ],
            "136": [
                "basic_auth_protocol_factory"
            ],
            "137": [
                "basic_auth_protocol_factory"
            ],
            "138": [
                "basic_auth_protocol_factory"
            ],
            "141": [
                "basic_auth_protocol_factory"
            ],
            "142": [
                "basic_auth_protocol_factory"
            ],
            "143": [
                "basic_auth_protocol_factory"
            ],
            "144": [
                "basic_auth_protocol_factory"
            ],
            "145": [
                "basic_auth_protocol_factory"
            ],
            "146": [
                "basic_auth_protocol_factory"
            ],
            "147": [
                "basic_auth_protocol_factory"
            ],
            "149": [
                "basic_auth_protocol_factory"
            ],
            "161": [
                "basic_auth_protocol_factory"
            ]
        },
        "addLocation": []
    }
}