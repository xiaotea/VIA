{
    "libs/langchain/langchain/storage/file_system.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import os"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import re"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from pathlib import Path"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from typing import Iterator, List, Optional, Sequence, Tuple, Union"
            },
            "4": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "             root_path (Union[str, Path]): The root path of the file store. All keys are"
            },
            "5": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "                 interpreted as paths relative to this root."
            },
            "6": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.root_path = Path(root_path)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        self.root_path = Path(root_path).absolute()"
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     def _get_full_path(self, key: str) -> Path:"
            },
            "11": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         \"\"\"Get the full path for a given key relative to the root path."
            },
            "12": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         if not re.match(r\"^[a-zA-Z0-9_.\\-/]+$\", key):"
            },
            "14": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             raise InvalidKeyException(f\"Invalid characters in key: {key}\")"
            },
            "15": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.root_path / key"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        full_path = os.path.abspath(self.root_path / key)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        common_path = os.path.commonpath([str(self.root_path), full_path])"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        if common_path != str(self.root_path):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            raise InvalidKeyException("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                f\"Invalid key: {key}. Key should be relative to the full path.\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                f\"{self.root_path} vs. {common_path} and full path of {full_path}\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            )"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        return Path(full_path)"
            },
            "25": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def mget(self, keys: Sequence[str]) -> List[Optional[bytes]]:"
            },
            "27": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         \"\"\"Get the values associated with the given keys."
            }
        },
        "frontPatchFile": [
            "import re",
            "from pathlib import Path",
            "from typing import Iterator, List, Optional, Sequence, Tuple, Union",
            "",
            "from langchain_core.stores import ByteStore",
            "",
            "from langchain.storage.exceptions import InvalidKeyException",
            "",
            "",
            "class LocalFileStore(ByteStore):",
            "    \"\"\"BaseStore interface that works on the local file system.",
            "",
            "    Examples:",
            "        Create a LocalFileStore instance and perform operations on it:",
            "",
            "        .. code-block:: python",
            "",
            "            from langchain.storage import LocalFileStore",
            "",
            "            # Instantiate the LocalFileStore with the root path",
            "            file_store = LocalFileStore(\"/path/to/root\")",
            "",
            "            # Set values for keys",
            "            file_store.mset([(\"key1\", b\"value1\"), (\"key2\", b\"value2\")])",
            "",
            "            # Get values for keys",
            "            values = file_store.mget([\"key1\", \"key2\"])  # Returns [b\"value1\", b\"value2\"]",
            "",
            "            # Delete keys",
            "            file_store.mdelete([\"key1\"])",
            "",
            "            # Iterate over keys",
            "            for key in file_store.yield_keys():",
            "                print(key)",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, root_path: Union[str, Path]) -> None:",
            "        \"\"\"Implement the BaseStore interface for the local file system.",
            "",
            "        Args:",
            "            root_path (Union[str, Path]): The root path of the file store. All keys are",
            "                interpreted as paths relative to this root.",
            "        \"\"\"",
            "        self.root_path = Path(root_path)",
            "",
            "    def _get_full_path(self, key: str) -> Path:",
            "        \"\"\"Get the full path for a given key relative to the root path.",
            "",
            "        Args:",
            "            key (str): The key relative to the root path.",
            "",
            "        Returns:",
            "            Path: The full path for the given key.",
            "        \"\"\"",
            "        if not re.match(r\"^[a-zA-Z0-9_.\\-/]+$\", key):",
            "            raise InvalidKeyException(f\"Invalid characters in key: {key}\")",
            "        return self.root_path / key",
            "",
            "    def mget(self, keys: Sequence[str]) -> List[Optional[bytes]]:",
            "        \"\"\"Get the values associated with the given keys.",
            "",
            "        Args:",
            "            keys: A sequence of keys.",
            "",
            "        Returns:",
            "            A sequence of optional values associated with the keys.",
            "            If a key is not found, the corresponding value will be None.",
            "        \"\"\"",
            "        values: List[Optional[bytes]] = []",
            "        for key in keys:",
            "            full_path = self._get_full_path(key)",
            "            if full_path.exists():",
            "                value = full_path.read_bytes()",
            "                values.append(value)",
            "            else:",
            "                values.append(None)",
            "        return values",
            "",
            "    def mset(self, key_value_pairs: Sequence[Tuple[str, bytes]]) -> None:",
            "        \"\"\"Set the values for the given keys.",
            "",
            "        Args:",
            "            key_value_pairs: A sequence of key-value pairs.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        for key, value in key_value_pairs:",
            "            full_path = self._get_full_path(key)",
            "            full_path.parent.mkdir(parents=True, exist_ok=True)",
            "            full_path.write_bytes(value)",
            "",
            "    def mdelete(self, keys: Sequence[str]) -> None:",
            "        \"\"\"Delete the given keys and their associated values.",
            "",
            "        Args:",
            "            keys (Sequence[str]): A sequence of keys to delete.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        for key in keys:",
            "            full_path = self._get_full_path(key)",
            "            if full_path.exists():",
            "                full_path.unlink()",
            "",
            "    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:",
            "        \"\"\"Get an iterator over keys that match the given prefix.",
            "",
            "        Args:",
            "            prefix (Optional[str]): The prefix to match.",
            "",
            "        Returns:",
            "            Iterator[str]: An iterator over keys that match the given prefix.",
            "        \"\"\"",
            "        prefix_path = self._get_full_path(prefix) if prefix else self.root_path",
            "        for file in prefix_path.rglob(\"*\"):",
            "            if file.is_file():",
            "                relative_path = file.relative_to(self.root_path)",
            "                yield str(relative_path)"
        ],
        "afterPatchFile": [
            "import os",
            "import re",
            "from pathlib import Path",
            "from typing import Iterator, List, Optional, Sequence, Tuple, Union",
            "",
            "from langchain_core.stores import ByteStore",
            "",
            "from langchain.storage.exceptions import InvalidKeyException",
            "",
            "",
            "class LocalFileStore(ByteStore):",
            "    \"\"\"BaseStore interface that works on the local file system.",
            "",
            "    Examples:",
            "        Create a LocalFileStore instance and perform operations on it:",
            "",
            "        .. code-block:: python",
            "",
            "            from langchain.storage import LocalFileStore",
            "",
            "            # Instantiate the LocalFileStore with the root path",
            "            file_store = LocalFileStore(\"/path/to/root\")",
            "",
            "            # Set values for keys",
            "            file_store.mset([(\"key1\", b\"value1\"), (\"key2\", b\"value2\")])",
            "",
            "            # Get values for keys",
            "            values = file_store.mget([\"key1\", \"key2\"])  # Returns [b\"value1\", b\"value2\"]",
            "",
            "            # Delete keys",
            "            file_store.mdelete([\"key1\"])",
            "",
            "            # Iterate over keys",
            "            for key in file_store.yield_keys():",
            "                print(key)",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, root_path: Union[str, Path]) -> None:",
            "        \"\"\"Implement the BaseStore interface for the local file system.",
            "",
            "        Args:",
            "            root_path (Union[str, Path]): The root path of the file store. All keys are",
            "                interpreted as paths relative to this root.",
            "        \"\"\"",
            "        self.root_path = Path(root_path).absolute()",
            "",
            "    def _get_full_path(self, key: str) -> Path:",
            "        \"\"\"Get the full path for a given key relative to the root path.",
            "",
            "        Args:",
            "            key (str): The key relative to the root path.",
            "",
            "        Returns:",
            "            Path: The full path for the given key.",
            "        \"\"\"",
            "        if not re.match(r\"^[a-zA-Z0-9_.\\-/]+$\", key):",
            "            raise InvalidKeyException(f\"Invalid characters in key: {key}\")",
            "        full_path = os.path.abspath(self.root_path / key)",
            "        common_path = os.path.commonpath([str(self.root_path), full_path])",
            "        if common_path != str(self.root_path):",
            "            raise InvalidKeyException(",
            "                f\"Invalid key: {key}. Key should be relative to the full path.\"",
            "                f\"{self.root_path} vs. {common_path} and full path of {full_path}\"",
            "            )",
            "",
            "        return Path(full_path)",
            "",
            "    def mget(self, keys: Sequence[str]) -> List[Optional[bytes]]:",
            "        \"\"\"Get the values associated with the given keys.",
            "",
            "        Args:",
            "            keys: A sequence of keys.",
            "",
            "        Returns:",
            "            A sequence of optional values associated with the keys.",
            "            If a key is not found, the corresponding value will be None.",
            "        \"\"\"",
            "        values: List[Optional[bytes]] = []",
            "        for key in keys:",
            "            full_path = self._get_full_path(key)",
            "            if full_path.exists():",
            "                value = full_path.read_bytes()",
            "                values.append(value)",
            "            else:",
            "                values.append(None)",
            "        return values",
            "",
            "    def mset(self, key_value_pairs: Sequence[Tuple[str, bytes]]) -> None:",
            "        \"\"\"Set the values for the given keys.",
            "",
            "        Args:",
            "            key_value_pairs: A sequence of key-value pairs.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        for key, value in key_value_pairs:",
            "            full_path = self._get_full_path(key)",
            "            full_path.parent.mkdir(parents=True, exist_ok=True)",
            "            full_path.write_bytes(value)",
            "",
            "    def mdelete(self, keys: Sequence[str]) -> None:",
            "        \"\"\"Delete the given keys and their associated values.",
            "",
            "        Args:",
            "            keys (Sequence[str]): A sequence of keys to delete.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        for key in keys:",
            "            full_path = self._get_full_path(key)",
            "            if full_path.exists():",
            "                full_path.unlink()",
            "",
            "    def yield_keys(self, prefix: Optional[str] = None) -> Iterator[str]:",
            "        \"\"\"Get an iterator over keys that match the given prefix.",
            "",
            "        Args:",
            "            prefix (Optional[str]): The prefix to match.",
            "",
            "        Returns:",
            "            Iterator[str]: An iterator over keys that match the given prefix.",
            "        \"\"\"",
            "        prefix_path = self._get_full_path(prefix) if prefix else self.root_path",
            "        for file in prefix_path.rglob(\"*\"):",
            "            if file.is_file():",
            "                relative_path = file.relative_to(self.root_path)",
            "                yield str(relative_path)"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "45": [
                "LocalFileStore",
                "__init__"
            ],
            "58": [
                "LocalFileStore",
                "_get_full_path"
            ]
        },
        "addLocation": []
    },
    "libs/langchain/tests/unit_tests/storage/test_filesystem.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     # Assert that the yielded keys match the expected keys"
            },
            "1": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     expected_keys = [\"key1\", os.path.join(\"subdir\", \"key2\")]"
            },
            "2": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     assert keys == expected_keys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+def test_catches_forbidden_keys(file_store: LocalFileStore) -> None:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    \"\"\"Make sure we raise exception on keys that are not allowed; e.g., absolute path\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        file_store.mset([(\"/etc\", b\"value1\")])"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        list(file_store.yield_keys(\"/etc/passwd\"))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        file_store.mget([\"/etc/passwd\"])"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    # check relative paths"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        list(file_store.yield_keys(\"..\"))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        file_store.mget([\"../etc/passwd\"])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        file_store.mset([(\"../etc\", b\"value1\")])"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    with pytest.raises(InvalidKeyException):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        list(file_store.yield_keys(\"../etc/passwd\"))"
            }
        },
        "frontPatchFile": [
            "import os",
            "import tempfile",
            "from typing import Generator",
            "",
            "import pytest",
            "",
            "from langchain.storage.exceptions import InvalidKeyException",
            "from langchain.storage.file_system import LocalFileStore",
            "",
            "",
            "@pytest.fixture",
            "def file_store() -> Generator[LocalFileStore, None, None]:",
            "    # Create a temporary directory for testing",
            "    with tempfile.TemporaryDirectory() as temp_dir:",
            "        # Instantiate the LocalFileStore with the temporary directory as the root path",
            "        store = LocalFileStore(temp_dir)",
            "        yield store",
            "",
            "",
            "def test_mset_and_mget(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Get values for keys",
            "    values = file_store.mget([\"key1\", \"key2\"])",
            "",
            "    # Assert that the retrieved values match the original values",
            "    assert values == [b\"value1\", b\"value2\"]",
            "",
            "",
            "def test_mdelete(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Delete keys",
            "    file_store.mdelete([\"key1\"])",
            "",
            "    # Check if the deleted key is present",
            "    values = file_store.mget([\"key1\"])",
            "",
            "    # Assert that the value is None after deletion",
            "    assert values == [None]",
            "",
            "",
            "def test_set_invalid_key(file_store: LocalFileStore) -> None:",
            "    \"\"\"Test that an exception is raised when an invalid key is set.\"\"\"",
            "    # Set a key-value pair",
            "    key = \"crying-cat/\ud83d\ude3f\"",
            "    value = b\"This is a test value\"",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mset([(key, value)])",
            "",
            "",
            "def test_set_key_and_verify_content(file_store: LocalFileStore) -> None:",
            "    \"\"\"Test that the content of the file is the same as the value set.\"\"\"",
            "    # Set a key-value pair",
            "    key = \"test_key\"",
            "    value = b\"This is a test value\"",
            "    file_store.mset([(key, value)])",
            "",
            "    # Verify the content of the actual file",
            "    full_path = file_store._get_full_path(key)",
            "    assert full_path.exists()",
            "    assert full_path.read_bytes() == b\"This is a test value\"",
            "",
            "",
            "def test_yield_keys(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"subdir/key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Iterate over keys",
            "    keys = list(file_store.yield_keys())",
            "",
            "    # Assert that the yielded keys match the expected keys",
            "    expected_keys = [\"key1\", os.path.join(\"subdir\", \"key2\")]",
            "    assert keys == expected_keys"
        ],
        "afterPatchFile": [
            "import os",
            "import tempfile",
            "from typing import Generator",
            "",
            "import pytest",
            "",
            "from langchain.storage.exceptions import InvalidKeyException",
            "from langchain.storage.file_system import LocalFileStore",
            "",
            "",
            "@pytest.fixture",
            "def file_store() -> Generator[LocalFileStore, None, None]:",
            "    # Create a temporary directory for testing",
            "    with tempfile.TemporaryDirectory() as temp_dir:",
            "        # Instantiate the LocalFileStore with the temporary directory as the root path",
            "        store = LocalFileStore(temp_dir)",
            "        yield store",
            "",
            "",
            "def test_mset_and_mget(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Get values for keys",
            "    values = file_store.mget([\"key1\", \"key2\"])",
            "",
            "    # Assert that the retrieved values match the original values",
            "    assert values == [b\"value1\", b\"value2\"]",
            "",
            "",
            "def test_mdelete(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Delete keys",
            "    file_store.mdelete([\"key1\"])",
            "",
            "    # Check if the deleted key is present",
            "    values = file_store.mget([\"key1\"])",
            "",
            "    # Assert that the value is None after deletion",
            "    assert values == [None]",
            "",
            "",
            "def test_set_invalid_key(file_store: LocalFileStore) -> None:",
            "    \"\"\"Test that an exception is raised when an invalid key is set.\"\"\"",
            "    # Set a key-value pair",
            "    key = \"crying-cat/\ud83d\ude3f\"",
            "    value = b\"This is a test value\"",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mset([(key, value)])",
            "",
            "",
            "def test_set_key_and_verify_content(file_store: LocalFileStore) -> None:",
            "    \"\"\"Test that the content of the file is the same as the value set.\"\"\"",
            "    # Set a key-value pair",
            "    key = \"test_key\"",
            "    value = b\"This is a test value\"",
            "    file_store.mset([(key, value)])",
            "",
            "    # Verify the content of the actual file",
            "    full_path = file_store._get_full_path(key)",
            "    assert full_path.exists()",
            "    assert full_path.read_bytes() == b\"This is a test value\"",
            "",
            "",
            "def test_yield_keys(file_store: LocalFileStore) -> None:",
            "    # Set values for keys",
            "    key_value_pairs = [(\"key1\", b\"value1\"), (\"subdir/key2\", b\"value2\")]",
            "    file_store.mset(key_value_pairs)",
            "",
            "    # Iterate over keys",
            "    keys = list(file_store.yield_keys())",
            "",
            "    # Assert that the yielded keys match the expected keys",
            "    expected_keys = [\"key1\", os.path.join(\"subdir\", \"key2\")]",
            "    assert keys == expected_keys",
            "",
            "",
            "def test_catches_forbidden_keys(file_store: LocalFileStore) -> None:",
            "    \"\"\"Make sure we raise exception on keys that are not allowed; e.g., absolute path\"\"\"",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mset([(\"/etc\", b\"value1\")])",
            "    with pytest.raises(InvalidKeyException):",
            "        list(file_store.yield_keys(\"/etc/passwd\"))",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mget([\"/etc/passwd\"])",
            "",
            "    # check relative paths",
            "    with pytest.raises(InvalidKeyException):",
            "        list(file_store.yield_keys(\"..\"))",
            "",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mget([\"../etc/passwd\"])",
            "",
            "    with pytest.raises(InvalidKeyException):",
            "        file_store.mset([(\"../etc\", b\"value1\")])",
            "",
            "    with pytest.raises(InvalidKeyException):",
            "        list(file_store.yield_keys(\"../etc/passwd\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "saleor.graphql.checkout.mutations"
        ]
    }
}