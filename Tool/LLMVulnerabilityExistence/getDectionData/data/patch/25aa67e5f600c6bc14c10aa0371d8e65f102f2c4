{
    "vyper/semantics/validation/data_positions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # TODO this doesn't really belong in \"validation\""
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import math"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from typing import Dict"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from vyper import ast as vy_ast"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from vyper.semantics.types.bases import StorageSlot"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     # note storage is word-addressable, not byte-addressable"
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     storage_slot = 0"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ret = {}"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    ret: Dict[str, Dict] = {}"
            },
            "11": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     for node in vyper_module.get_children(vy_ast.FunctionDef):"
            },
            "13": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         type_ = node._metadata[\"type\"]"
            },
            "14": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         variable_name = f\"nonreentrant.{type_.nonreentrant}\""
            },
            "15": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         # a nonreentrant key can appear many times in a module but it"
            },
            "17": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # only takes one slot. ignore it after the first time we see it."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        # only takes one slot. after the first time we see it, do not"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        # increment the storage slot."
            },
            "20": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         if variable_name in ret:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            _slot = ret[variable_name][\"slot\"]"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            type_.set_reentrancy_key_position(StorageSlot(_slot))"
            },
            "23": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             continue"
            },
            "24": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         type_.set_reentrancy_key_position(StorageSlot(storage_slot))"
            }
        },
        "frontPatchFile": [
            "# TODO this doesn't really belong in \"validation\"",
            "import math",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.semantics.types.bases import StorageSlot",
            "from vyper.typing import StorageLayout",
            "",
            "",
            "def set_data_positions(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse the annotated Vyper AST, determine data positions for all variables,",
            "    and annotate the AST nodes with the position data.",
            "",
            "    Arguments",
            "    ---------",
            "    vyper_module : vy_ast.Module",
            "        Top-level Vyper AST node that has already been annotated with type data.",
            "    \"\"\"",
            "    return set_storage_slots(vyper_module)",
            "",
            "",
            "def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "    # Allocate storage slots from 0",
            "    # note storage is word-addressable, not byte-addressable",
            "    storage_slot = 0",
            "",
            "    ret = {}",
            "",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # a nonreentrant key can appear many times in a module but it",
            "        # only takes one slot. ignore it after the first time we see it.",
            "        if variable_name in ret:",
            "            continue",
            "",
            "        type_.set_reentrancy_key_position(StorageSlot(storage_slot))",
            "",
            "        # TODO this could have better typing but leave it untyped until",
            "        # we nail down the format better",
            "        ret[variable_name] = {",
            "            \"type\": \"nonreentrant lock\",",
            "            \"location\": \"storage\",",
            "            \"slot\": storage_slot,",
            "        }",
            "",
            "        # TODO use one byte - or bit - per reentrancy key",
            "        # requires either an extra SLOAD or caching the value of the",
            "        # location in memory at entrance",
            "        storage_slot += 1",
            "",
            "    for node in vyper_module.get_children(vy_ast.AnnAssign):",
            "        type_ = node.target._metadata[\"type\"]",
            "        type_.set_position(StorageSlot(storage_slot))",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"location\": \"storage\", \"slot\": storage_slot}",
            "",
            "        # CMC 2021-07-23 note that HashMaps get assigned a slot here.",
            "        # I'm not sure if it's safe to avoid allocating that slot",
            "        # for HashMaps because downstream code might use the slot",
            "        # ID as a salt.",
            "        storage_slot += math.ceil(type_.size_in_bytes / 32)",
            "",
            "    return ret",
            "",
            "",
            "def set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass"
        ],
        "afterPatchFile": [
            "# TODO this doesn't really belong in \"validation\"",
            "import math",
            "from typing import Dict",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.semantics.types.bases import StorageSlot",
            "from vyper.typing import StorageLayout",
            "",
            "",
            "def set_data_positions(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse the annotated Vyper AST, determine data positions for all variables,",
            "    and annotate the AST nodes with the position data.",
            "",
            "    Arguments",
            "    ---------",
            "    vyper_module : vy_ast.Module",
            "        Top-level Vyper AST node that has already been annotated with type data.",
            "    \"\"\"",
            "    return set_storage_slots(vyper_module)",
            "",
            "",
            "def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "    # Allocate storage slots from 0",
            "    # note storage is word-addressable, not byte-addressable",
            "    storage_slot = 0",
            "",
            "    ret: Dict[str, Dict] = {}",
            "",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # a nonreentrant key can appear many times in a module but it",
            "        # only takes one slot. after the first time we see it, do not",
            "        # increment the storage slot.",
            "        if variable_name in ret:",
            "            _slot = ret[variable_name][\"slot\"]",
            "            type_.set_reentrancy_key_position(StorageSlot(_slot))",
            "            continue",
            "",
            "        type_.set_reentrancy_key_position(StorageSlot(storage_slot))",
            "",
            "        # TODO this could have better typing but leave it untyped until",
            "        # we nail down the format better",
            "        ret[variable_name] = {",
            "            \"type\": \"nonreentrant lock\",",
            "            \"location\": \"storage\",",
            "            \"slot\": storage_slot,",
            "        }",
            "",
            "        # TODO use one byte - or bit - per reentrancy key",
            "        # requires either an extra SLOAD or caching the value of the",
            "        # location in memory at entrance",
            "        storage_slot += 1",
            "",
            "    for node in vyper_module.get_children(vy_ast.AnnAssign):",
            "        type_ = node.target._metadata[\"type\"]",
            "        type_.set_position(StorageSlot(storage_slot))",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"location\": \"storage\", \"slot\": storage_slot}",
            "",
            "        # CMC 2021-07-23 note that HashMaps get assigned a slot here.",
            "        # I'm not sure if it's safe to avoid allocating that slot",
            "        # for HashMaps because downstream code might use the slot",
            "        # ID as a salt.",
            "        storage_slot += math.ceil(type_.size_in_bytes / 32)",
            "",
            "    return ret",
            "",
            "",
            "def set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [
                "set_storage_slots"
            ],
            "41": [
                "set_storage_slots"
            ]
        },
        "addLocation": []
    }
}