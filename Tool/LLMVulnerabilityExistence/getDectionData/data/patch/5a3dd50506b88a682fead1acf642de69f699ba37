{
    "lib/ansible/executor/powershell/module_manifest.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         exec_manifest['csharp_utils'][name] = b64_data"
            },
            "1": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     exec_manifest['csharp_utils_module'] = list(finder.cs_utils_module.keys())"
            },
            "2": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # FUTURE: smuggle this back as a dict instead of serializing here;"
            },
            "4": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # the connection plugin may need to modify it"
            },
            "5": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "     b_json = to_bytes(json.dumps(exec_manifest))"
            },
            "6": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    b_data = exec_wrapper.replace(b\"$json_raw = ''\","
            },
            "7": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                  b\"$json_raw = @'\\r\\n%s\\r\\n'@\" % b_json)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    # delimit the payload JSON from the wrapper to keep sensitive contents out of scriptblocks (which can be logged)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    b_data = exec_wrapper + b'\\0\\0\\0\\0' + b_json"
            },
            "10": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "     return b_data"
            }
        },
        "frontPatchFile": [
            "# (c) 2018 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import base64",
            "import json",
            "import os",
            "import pkgutil",
            "import random",
            "import re",
            "",
            "from distutils.version import LooseVersion",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.plugins.loader import ps_module_utils_loader",
            "",
            "",
            "class PSModuleDepFinder(object):",
            "",
            "    def __init__(self):",
            "        self.ps_modules = dict()",
            "        self.exec_scripts = dict()",
            "",
            "        # by defining an explicit dict of cs utils and where they are used, we",
            "        # can potentially save time by not adding the type multiple times if it",
            "        # isn't needed",
            "        self.cs_utils_wrapper = dict()",
            "        self.cs_utils_module = dict()",
            "",
            "        self.ps_version = None",
            "        self.os_version = None",
            "        self.become = False",
            "",
            "        self._re_cs_module = re.compile(to_bytes(r'(?i)^using\\s(Ansible\\..+);$'))",
            "        self._re_cs_in_ps_module = re.compile(to_bytes(r'(?i)^#\\s*ansiblerequires\\s+-csharputil\\s+(Ansible\\..+)'))",
            "        self._re_module = re.compile(to_bytes(r'(?i)^#\\s*requires\\s+\\-module(?:s?)\\s*(Ansible\\.ModuleUtils\\..+)'))",
            "        self._re_wrapper = re.compile(to_bytes(r'(?i)^#\\s*ansiblerequires\\s+-wrapper\\s+(\\w*)'))",
            "        self._re_ps_version = re.compile(to_bytes(r'(?i)^#requires\\s+\\-version\\s+([0-9]+(\\.[0-9]+){0,3})$'))",
            "        self._re_os_version = re.compile(to_bytes(r'(?i)^#ansiblerequires\\s+\\-osversion\\s+([0-9]+(\\.[0-9]+){0,3})$'))",
            "        self._re_become = re.compile(to_bytes(r'(?i)^#ansiblerequires\\s+\\-become$'))",
            "",
            "    def scan_module(self, module_data, wrapper=False, powershell=True):",
            "        lines = module_data.split(b'\\n')",
            "        module_utils = set()",
            "        if wrapper:",
            "            cs_utils = self.cs_utils_wrapper",
            "        else:",
            "            cs_utils = self.cs_utils_module",
            "",
            "        if powershell:",
            "            checks = [",
            "                # PS module contains '#Requires -Module Ansible.ModuleUtils.*'",
            "                (self._re_module, self.ps_modules, \".psm1\"),",
            "                # PS module contains '#AnsibleRequires -CSharpUtil Ansible.*'",
            "                (self._re_cs_in_ps_module, cs_utils, \".cs\"),",
            "            ]",
            "        else:",
            "            checks = [",
            "                # CS module contains 'using Ansible.*;'",
            "                (self._re_cs_module, cs_utils, \".cs\"),",
            "            ]",
            "",
            "        for line in lines:",
            "            for check in checks:",
            "                match = check[0].match(line)",
            "                if match:",
            "                    # tolerate windows line endings by stripping any remaining",
            "                    # newline chars",
            "                    module_util_name = to_text(match.group(1).rstrip())",
            "                    if module_util_name not in check[1].keys():",
            "                        module_utils.add((module_util_name, check[2]))",
            "",
            "            if powershell:",
            "                ps_version_match = self._re_ps_version.match(line)",
            "                if ps_version_match:",
            "                    self._parse_version_match(ps_version_match, \"ps_version\")",
            "",
            "                os_version_match = self._re_os_version.match(line)",
            "                if os_version_match:",
            "                    self._parse_version_match(os_version_match, \"os_version\")",
            "",
            "                # once become is set, no need to keep on checking recursively",
            "                if not self.become:",
            "                    become_match = self._re_become.match(line)",
            "                    if become_match:",
            "                        self.become = True",
            "",
            "            if wrapper:",
            "                wrapper_match = self._re_wrapper.match(line)",
            "                if wrapper_match:",
            "                    self.scan_exec_script(wrapper_match.group(1).rstrip())",
            "",
            "        # recursively drill into each Requires to see if there are any more",
            "        # requirements",
            "        for m in set(module_utils):",
            "            self._add_module(m, wrapper=wrapper)",
            "",
            "    def scan_exec_script(self, name):",
            "        # scans lib/ansible/executor/powershell for scripts used in the module",
            "        # exec side. It also scans these scripts for any dependencies",
            "        name = to_text(name)",
            "        if name in self.exec_scripts.keys():",
            "            return",
            "",
            "        data = pkgutil.get_data(\"ansible.executor.powershell\", name + \".ps1\")",
            "        if data is None:",
            "            raise AnsibleError(\"Could not find executor powershell script \"",
            "                               \"for '%s'\" % name)",
            "",
            "        b_data = to_bytes(data)",
            "",
            "        # remove comments to reduce the payload size in the exec wrappers",
            "        if C.DEFAULT_DEBUG:",
            "            exec_script = b_data",
            "        else:",
            "            exec_script = _strip_comments(b_data)",
            "        self.exec_scripts[name] = to_bytes(exec_script)",
            "        self.scan_module(b_data, wrapper=True, powershell=True)",
            "",
            "    def _add_module(self, name, wrapper=False):",
            "        m, ext = name",
            "        m = to_text(m)",
            "        mu_path = ps_module_utils_loader.find_plugin(m, ext)",
            "        if not mu_path:",
            "            raise AnsibleError('Could not find imported module support code '",
            "                               'for \\'%s\\'' % m)",
            "",
            "        module_util_data = to_bytes(_slurp(mu_path))",
            "        if ext == \".psm1\":",
            "            self.ps_modules[m] = module_util_data",
            "        else:",
            "            if wrapper:",
            "                self.cs_utils_wrapper[m] = module_util_data",
            "            else:",
            "                self.cs_utils_module[m] = module_util_data",
            "        self.scan_module(module_util_data, wrapper=wrapper,",
            "                         powershell=(ext == \".psm1\"))",
            "",
            "    def _parse_version_match(self, match, attribute):",
            "        new_version = to_text(match.group(1)).rstrip()",
            "",
            "        # PowerShell cannot cast a string of \"1\" to Version, it must have at",
            "        # least the major.minor for it to be valid so we append 0",
            "        if match.group(2) is None:",
            "            new_version = \"%s.0\" % new_version",
            "",
            "        existing_version = getattr(self, attribute, None)",
            "        if existing_version is None:",
            "            setattr(self, attribute, new_version)",
            "        else:",
            "            # determine which is the latest version and set that",
            "            if LooseVersion(new_version) > LooseVersion(existing_version):",
            "                setattr(self, attribute, new_version)",
            "",
            "",
            "def _slurp(path):",
            "    if not os.path.exists(path):",
            "        raise AnsibleError(\"imported module support code does not exist at %s\"",
            "                           % os.path.abspath(path))",
            "    fd = open(path, 'rb')",
            "    data = fd.read()",
            "    fd.close()",
            "    return data",
            "",
            "",
            "def _strip_comments(source):",
            "    # Strip comments and blank lines from the wrapper",
            "    buf = []",
            "    start_block = False",
            "    for line in source.splitlines():",
            "        l = line.strip()",
            "",
            "        if start_block and l.endswith(b'#>'):",
            "            start_block = False",
            "            continue",
            "        elif start_block:",
            "            continue",
            "        elif l.startswith(b'<#'):",
            "            start_block = True",
            "            continue",
            "        elif not l or l.startswith(b'#'):",
            "            continue",
            "",
            "        buf.append(line)",
            "    return b'\\n'.join(buf)",
            "",
            "",
            "def _create_powershell_wrapper(b_module_data, module_args, environment,",
            "                               async_timeout, become, become_method,",
            "                               become_user, become_password, become_flags,",
            "                               substyle):",
            "    # creates the manifest/wrapper used in PowerShell/C# modules to enable",
            "    # things like become and async - this is also called in action/script.py",
            "",
            "    # FUTURE: add process_wrapper.ps1 to run module_wrapper in a new process",
            "    # if running under a persistent connection and substyle is C# so we",
            "    # don't have type conflicts",
            "    finder = PSModuleDepFinder()",
            "    if substyle != 'script':",
            "        # don't scan the module for util dependencies and other Ansible related",
            "        # flags if the substyle is 'script' which is set by action/script",
            "        finder.scan_module(b_module_data, powershell=(substyle == \"powershell\"))",
            "",
            "    module_wrapper = \"module_%s_wrapper\" % substyle",
            "    exec_manifest = dict(",
            "        module_entry=to_text(base64.b64encode(b_module_data)),",
            "        powershell_modules=dict(),",
            "        csharp_utils=dict(),",
            "        csharp_utils_module=list(),  # csharp_utils only required by a module",
            "        module_args=module_args,",
            "        actions=[module_wrapper],",
            "        environment=environment,",
            "        encoded_output=False",
            "    )",
            "    finder.scan_exec_script(module_wrapper)",
            "",
            "    if async_timeout > 0:",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('async_watchdog')",
            "        finder.scan_exec_script('async_wrapper')",
            "",
            "        exec_manifest[\"actions\"].insert(0, 'async_watchdog')",
            "        exec_manifest[\"actions\"].insert(0, 'async_wrapper')",
            "        exec_manifest[\"async_jid\"] = str(random.randint(0, 999999999999))",
            "        exec_manifest[\"async_timeout_sec\"] = async_timeout",
            "",
            "    if become and become_method == 'runas':",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('become_wrapper')",
            "",
            "        exec_manifest[\"actions\"].insert(0, 'become_wrapper')",
            "        exec_manifest[\"become_user\"] = become_user",
            "        exec_manifest[\"become_password\"] = become_password",
            "        exec_manifest['become_flags'] = become_flags",
            "",
            "    exec_manifest['min_ps_version'] = finder.ps_version",
            "    exec_manifest['min_os_version'] = finder.os_version",
            "    if finder.become and 'become_wrapper' not in exec_manifest['actions']:",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('become_wrapper')",
            "",
            "        exec_manifest['actions'].insert(0, 'become_wrapper')",
            "        exec_manifest['become_user'] = 'SYSTEM'",
            "        exec_manifest['become_password'] = None",
            "        exec_manifest['become_flags'] = None",
            "",
            "    # make sure Ansible.ModuleUtils.AddType is added if any C# utils are used",
            "    if len(finder.cs_utils_wrapper) > 0 or len(finder.cs_utils_module) > 0:",
            "        finder._add_module((b\"Ansible.ModuleUtils.AddType\", \".psm1\"),",
            "                           wrapper=False)",
            "",
            "    # exec_wrapper is only required to be part of the payload if using",
            "    # become or async, to save on payload space we check if exec_wrapper has",
            "    # already been added, and remove it manually if it hasn't later",
            "    exec_required = \"exec_wrapper\" in finder.exec_scripts.keys()",
            "    finder.scan_exec_script(\"exec_wrapper\")",
            "    # must contain an empty newline so it runs the begin/process/end block",
            "    finder.exec_scripts[\"exec_wrapper\"] += b\"\\n\\n\"",
            "",
            "    exec_wrapper = finder.exec_scripts[\"exec_wrapper\"]",
            "    if not exec_required:",
            "        finder.exec_scripts.pop(\"exec_wrapper\")",
            "",
            "    for name, data in finder.exec_scripts.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest[name] = b64_data",
            "",
            "    for name, data in finder.ps_modules.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest['powershell_modules'][name] = b64_data",
            "",
            "    cs_utils = finder.cs_utils_wrapper",
            "    cs_utils.update(finder.cs_utils_module)",
            "    for name, data in cs_utils.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest['csharp_utils'][name] = b64_data",
            "    exec_manifest['csharp_utils_module'] = list(finder.cs_utils_module.keys())",
            "",
            "    # FUTURE: smuggle this back as a dict instead of serializing here;",
            "    # the connection plugin may need to modify it",
            "    b_json = to_bytes(json.dumps(exec_manifest))",
            "    b_data = exec_wrapper.replace(b\"$json_raw = ''\",",
            "                                  b\"$json_raw = @'\\r\\n%s\\r\\n'@\" % b_json)",
            "    return b_data"
        ],
        "afterPatchFile": [
            "# (c) 2018 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import base64",
            "import json",
            "import os",
            "import pkgutil",
            "import random",
            "import re",
            "",
            "from distutils.version import LooseVersion",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.plugins.loader import ps_module_utils_loader",
            "",
            "",
            "class PSModuleDepFinder(object):",
            "",
            "    def __init__(self):",
            "        self.ps_modules = dict()",
            "        self.exec_scripts = dict()",
            "",
            "        # by defining an explicit dict of cs utils and where they are used, we",
            "        # can potentially save time by not adding the type multiple times if it",
            "        # isn't needed",
            "        self.cs_utils_wrapper = dict()",
            "        self.cs_utils_module = dict()",
            "",
            "        self.ps_version = None",
            "        self.os_version = None",
            "        self.become = False",
            "",
            "        self._re_cs_module = re.compile(to_bytes(r'(?i)^using\\s(Ansible\\..+);$'))",
            "        self._re_cs_in_ps_module = re.compile(to_bytes(r'(?i)^#\\s*ansiblerequires\\s+-csharputil\\s+(Ansible\\..+)'))",
            "        self._re_module = re.compile(to_bytes(r'(?i)^#\\s*requires\\s+\\-module(?:s?)\\s*(Ansible\\.ModuleUtils\\..+)'))",
            "        self._re_wrapper = re.compile(to_bytes(r'(?i)^#\\s*ansiblerequires\\s+-wrapper\\s+(\\w*)'))",
            "        self._re_ps_version = re.compile(to_bytes(r'(?i)^#requires\\s+\\-version\\s+([0-9]+(\\.[0-9]+){0,3})$'))",
            "        self._re_os_version = re.compile(to_bytes(r'(?i)^#ansiblerequires\\s+\\-osversion\\s+([0-9]+(\\.[0-9]+){0,3})$'))",
            "        self._re_become = re.compile(to_bytes(r'(?i)^#ansiblerequires\\s+\\-become$'))",
            "",
            "    def scan_module(self, module_data, wrapper=False, powershell=True):",
            "        lines = module_data.split(b'\\n')",
            "        module_utils = set()",
            "        if wrapper:",
            "            cs_utils = self.cs_utils_wrapper",
            "        else:",
            "            cs_utils = self.cs_utils_module",
            "",
            "        if powershell:",
            "            checks = [",
            "                # PS module contains '#Requires -Module Ansible.ModuleUtils.*'",
            "                (self._re_module, self.ps_modules, \".psm1\"),",
            "                # PS module contains '#AnsibleRequires -CSharpUtil Ansible.*'",
            "                (self._re_cs_in_ps_module, cs_utils, \".cs\"),",
            "            ]",
            "        else:",
            "            checks = [",
            "                # CS module contains 'using Ansible.*;'",
            "                (self._re_cs_module, cs_utils, \".cs\"),",
            "            ]",
            "",
            "        for line in lines:",
            "            for check in checks:",
            "                match = check[0].match(line)",
            "                if match:",
            "                    # tolerate windows line endings by stripping any remaining",
            "                    # newline chars",
            "                    module_util_name = to_text(match.group(1).rstrip())",
            "                    if module_util_name not in check[1].keys():",
            "                        module_utils.add((module_util_name, check[2]))",
            "",
            "            if powershell:",
            "                ps_version_match = self._re_ps_version.match(line)",
            "                if ps_version_match:",
            "                    self._parse_version_match(ps_version_match, \"ps_version\")",
            "",
            "                os_version_match = self._re_os_version.match(line)",
            "                if os_version_match:",
            "                    self._parse_version_match(os_version_match, \"os_version\")",
            "",
            "                # once become is set, no need to keep on checking recursively",
            "                if not self.become:",
            "                    become_match = self._re_become.match(line)",
            "                    if become_match:",
            "                        self.become = True",
            "",
            "            if wrapper:",
            "                wrapper_match = self._re_wrapper.match(line)",
            "                if wrapper_match:",
            "                    self.scan_exec_script(wrapper_match.group(1).rstrip())",
            "",
            "        # recursively drill into each Requires to see if there are any more",
            "        # requirements",
            "        for m in set(module_utils):",
            "            self._add_module(m, wrapper=wrapper)",
            "",
            "    def scan_exec_script(self, name):",
            "        # scans lib/ansible/executor/powershell for scripts used in the module",
            "        # exec side. It also scans these scripts for any dependencies",
            "        name = to_text(name)",
            "        if name in self.exec_scripts.keys():",
            "            return",
            "",
            "        data = pkgutil.get_data(\"ansible.executor.powershell\", name + \".ps1\")",
            "        if data is None:",
            "            raise AnsibleError(\"Could not find executor powershell script \"",
            "                               \"for '%s'\" % name)",
            "",
            "        b_data = to_bytes(data)",
            "",
            "        # remove comments to reduce the payload size in the exec wrappers",
            "        if C.DEFAULT_DEBUG:",
            "            exec_script = b_data",
            "        else:",
            "            exec_script = _strip_comments(b_data)",
            "        self.exec_scripts[name] = to_bytes(exec_script)",
            "        self.scan_module(b_data, wrapper=True, powershell=True)",
            "",
            "    def _add_module(self, name, wrapper=False):",
            "        m, ext = name",
            "        m = to_text(m)",
            "        mu_path = ps_module_utils_loader.find_plugin(m, ext)",
            "        if not mu_path:",
            "            raise AnsibleError('Could not find imported module support code '",
            "                               'for \\'%s\\'' % m)",
            "",
            "        module_util_data = to_bytes(_slurp(mu_path))",
            "        if ext == \".psm1\":",
            "            self.ps_modules[m] = module_util_data",
            "        else:",
            "            if wrapper:",
            "                self.cs_utils_wrapper[m] = module_util_data",
            "            else:",
            "                self.cs_utils_module[m] = module_util_data",
            "        self.scan_module(module_util_data, wrapper=wrapper,",
            "                         powershell=(ext == \".psm1\"))",
            "",
            "    def _parse_version_match(self, match, attribute):",
            "        new_version = to_text(match.group(1)).rstrip()",
            "",
            "        # PowerShell cannot cast a string of \"1\" to Version, it must have at",
            "        # least the major.minor for it to be valid so we append 0",
            "        if match.group(2) is None:",
            "            new_version = \"%s.0\" % new_version",
            "",
            "        existing_version = getattr(self, attribute, None)",
            "        if existing_version is None:",
            "            setattr(self, attribute, new_version)",
            "        else:",
            "            # determine which is the latest version and set that",
            "            if LooseVersion(new_version) > LooseVersion(existing_version):",
            "                setattr(self, attribute, new_version)",
            "",
            "",
            "def _slurp(path):",
            "    if not os.path.exists(path):",
            "        raise AnsibleError(\"imported module support code does not exist at %s\"",
            "                           % os.path.abspath(path))",
            "    fd = open(path, 'rb')",
            "    data = fd.read()",
            "    fd.close()",
            "    return data",
            "",
            "",
            "def _strip_comments(source):",
            "    # Strip comments and blank lines from the wrapper",
            "    buf = []",
            "    start_block = False",
            "    for line in source.splitlines():",
            "        l = line.strip()",
            "",
            "        if start_block and l.endswith(b'#>'):",
            "            start_block = False",
            "            continue",
            "        elif start_block:",
            "            continue",
            "        elif l.startswith(b'<#'):",
            "            start_block = True",
            "            continue",
            "        elif not l or l.startswith(b'#'):",
            "            continue",
            "",
            "        buf.append(line)",
            "    return b'\\n'.join(buf)",
            "",
            "",
            "def _create_powershell_wrapper(b_module_data, module_args, environment,",
            "                               async_timeout, become, become_method,",
            "                               become_user, become_password, become_flags,",
            "                               substyle):",
            "    # creates the manifest/wrapper used in PowerShell/C# modules to enable",
            "    # things like become and async - this is also called in action/script.py",
            "",
            "    # FUTURE: add process_wrapper.ps1 to run module_wrapper in a new process",
            "    # if running under a persistent connection and substyle is C# so we",
            "    # don't have type conflicts",
            "    finder = PSModuleDepFinder()",
            "    if substyle != 'script':",
            "        # don't scan the module for util dependencies and other Ansible related",
            "        # flags if the substyle is 'script' which is set by action/script",
            "        finder.scan_module(b_module_data, powershell=(substyle == \"powershell\"))",
            "",
            "    module_wrapper = \"module_%s_wrapper\" % substyle",
            "    exec_manifest = dict(",
            "        module_entry=to_text(base64.b64encode(b_module_data)),",
            "        powershell_modules=dict(),",
            "        csharp_utils=dict(),",
            "        csharp_utils_module=list(),  # csharp_utils only required by a module",
            "        module_args=module_args,",
            "        actions=[module_wrapper],",
            "        environment=environment,",
            "        encoded_output=False",
            "    )",
            "    finder.scan_exec_script(module_wrapper)",
            "",
            "    if async_timeout > 0:",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('async_watchdog')",
            "        finder.scan_exec_script('async_wrapper')",
            "",
            "        exec_manifest[\"actions\"].insert(0, 'async_watchdog')",
            "        exec_manifest[\"actions\"].insert(0, 'async_wrapper')",
            "        exec_manifest[\"async_jid\"] = str(random.randint(0, 999999999999))",
            "        exec_manifest[\"async_timeout_sec\"] = async_timeout",
            "",
            "    if become and become_method == 'runas':",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('become_wrapper')",
            "",
            "        exec_manifest[\"actions\"].insert(0, 'become_wrapper')",
            "        exec_manifest[\"become_user\"] = become_user",
            "        exec_manifest[\"become_password\"] = become_password",
            "        exec_manifest['become_flags'] = become_flags",
            "",
            "    exec_manifest['min_ps_version'] = finder.ps_version",
            "    exec_manifest['min_os_version'] = finder.os_version",
            "    if finder.become and 'become_wrapper' not in exec_manifest['actions']:",
            "        finder.scan_exec_script('exec_wrapper')",
            "        finder.scan_exec_script('become_wrapper')",
            "",
            "        exec_manifest['actions'].insert(0, 'become_wrapper')",
            "        exec_manifest['become_user'] = 'SYSTEM'",
            "        exec_manifest['become_password'] = None",
            "        exec_manifest['become_flags'] = None",
            "",
            "    # make sure Ansible.ModuleUtils.AddType is added if any C# utils are used",
            "    if len(finder.cs_utils_wrapper) > 0 or len(finder.cs_utils_module) > 0:",
            "        finder._add_module((b\"Ansible.ModuleUtils.AddType\", \".psm1\"),",
            "                           wrapper=False)",
            "",
            "    # exec_wrapper is only required to be part of the payload if using",
            "    # become or async, to save on payload space we check if exec_wrapper has",
            "    # already been added, and remove it manually if it hasn't later",
            "    exec_required = \"exec_wrapper\" in finder.exec_scripts.keys()",
            "    finder.scan_exec_script(\"exec_wrapper\")",
            "    # must contain an empty newline so it runs the begin/process/end block",
            "    finder.exec_scripts[\"exec_wrapper\"] += b\"\\n\\n\"",
            "",
            "    exec_wrapper = finder.exec_scripts[\"exec_wrapper\"]",
            "    if not exec_required:",
            "        finder.exec_scripts.pop(\"exec_wrapper\")",
            "",
            "    for name, data in finder.exec_scripts.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest[name] = b64_data",
            "",
            "    for name, data in finder.ps_modules.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest['powershell_modules'][name] = b64_data",
            "",
            "    cs_utils = finder.cs_utils_wrapper",
            "    cs_utils.update(finder.cs_utils_module)",
            "    for name, data in cs_utils.items():",
            "        b64_data = to_text(base64.b64encode(data))",
            "        exec_manifest['csharp_utils'][name] = b64_data",
            "    exec_manifest['csharp_utils_module'] = list(finder.cs_utils_module.keys())",
            "",
            "    b_json = to_bytes(json.dumps(exec_manifest))",
            "    # delimit the payload JSON from the wrapper to keep sensitive contents out of scriptblocks (which can be logged)",
            "    b_data = exec_wrapper + b'\\0\\0\\0\\0' + b_json",
            "    return b_data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "283": [
                "_create_powershell_wrapper"
            ],
            "284": [
                "_create_powershell_wrapper"
            ],
            "286": [
                "_create_powershell_wrapper"
            ],
            "287": [
                "_create_powershell_wrapper"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/action/script.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             # PowerShell runs the script in a special wrapper to enable things"
            },
            "1": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "             # like become and environment args"
            },
            "2": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             if self._connection._shell.SHELL_FAMILY == \"powershell\":"
            },
            "3": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # FIXME: use a more public method to get the exec payload"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+                # FUTURE: use a more public method to get the exec payload"
            },
            "5": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                 pc = self._play_context"
            },
            "6": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 exec_data = ps_manifest._create_powershell_wrapper("
            },
            "7": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                     to_bytes(script_cmd), {}, env_dict, self._task.async_val,"
            },
            "8": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                     pc.become, pc.become_method, pc.become_user,"
            },
            "9": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                     pc.become_pass, pc.become_flags, substyle=\"script\""
            },
            "10": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                 )"
            },
            "11": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                script_cmd = \"-\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+                # build the necessary exec wrapper command"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+                # FUTURE: this still doesn't let script work on Windows with non-pipelined connections or"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                # full manual exec of KEEP_REMOTE_FILES"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                script_cmd = self._connection._shell.build_module_command(env_string='', shebang='#!powershell', cmd='')"
            },
            "16": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             result.update(self._low_level_execute_command(cmd=script_cmd, in_data=exec_data, sudoable=True, chdir=chdir))"
            },
            "18": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import re",
            "import shlex",
            "",
            "from ansible.errors import AnsibleError, AnsibleAction, _AnsibleActionDone, AnsibleActionFail, AnsibleActionSkip",
            "from ansible.executor.powershell import module_manifest as ps_manifest",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.action import ActionBase",
            "",
            "",
            "class ActionModule(ActionBase):",
            "",
            "    TRANSFERS_FILES = True",
            "",
            "    # On Windows platform, absolute paths begin with a (back)slash",
            "    # after chopping off a potential drive letter.",
            "    windows_absolute_path_detection = re.compile(r'^(?:[a-zA-Z]\\:)?(\\\\|\\/)')",
            "",
            "    def run(self, tmp=None, task_vars=None):",
            "        ''' handler for file transfer operations '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        result = super(ActionModule, self).run(tmp, task_vars)",
            "        del tmp  # tmp no longer has any effect",
            "",
            "        try:",
            "            creates = self._task.args.get('creates')",
            "            if creates:",
            "                # do not run the command if the line contains creates=filename",
            "                # and the filename already exists. This allows idempotence",
            "                # of command executions.",
            "                if self._remote_file_exists(creates):",
            "                    raise AnsibleActionSkip(\"%s exists, matching creates option\" % creates)",
            "",
            "            removes = self._task.args.get('removes')",
            "            if removes:",
            "                # do not run the command if the line contains removes=filename",
            "                # and the filename does not exist. This allows idempotence",
            "                # of command executions.",
            "                if not self._remote_file_exists(removes):",
            "                    raise AnsibleActionSkip(\"%s does not exist, matching removes option\" % removes)",
            "",
            "            # The chdir must be absolute, because a relative path would rely on",
            "            # remote node behaviour & user config.",
            "            chdir = self._task.args.get('chdir')",
            "            if chdir:",
            "                # Powershell is the only Windows-path aware shell",
            "                if self._connection._shell.SHELL_FAMILY == 'powershell' and \\",
            "                        not self.windows_absolute_path_detection.matches(chdir):",
            "                    raise AnsibleActionFail('chdir %s must be an absolute path for a Windows remote node' % chdir)",
            "                # Every other shell is unix-path-aware.",
            "                if self._connection._shell.SHELL_FAMILY != 'powershell' and not chdir.startswith('/'):",
            "                    raise AnsibleActionFail('chdir %s must be an absolute path for a Unix-aware remote node' % chdir)",
            "",
            "            # Split out the script as the first item in raw_params using",
            "            # shlex.split() in order to support paths and files with spaces in the name.",
            "            # Any arguments passed to the script will be added back later.",
            "            raw_params = to_native(self._task.args.get('_raw_params', ''), errors='surrogate_or_strict')",
            "            parts = [to_text(s, errors='surrogate_or_strict') for s in shlex.split(raw_params.strip())]",
            "            source = parts[0]",
            "",
            "            # Support executable paths and files with spaces in the name.",
            "            executable = to_native(self._task.args.get('executable', ''), errors='surrogate_or_strict')",
            "",
            "            try:",
            "                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=self._task.args.get('decrypt', True))",
            "            except AnsibleError as e:",
            "                raise AnsibleActionFail(to_native(e))",
            "",
            "            # now we execute script, always assume changed.",
            "            result['changed'] = True",
            "",
            "            if not self._play_context.check_mode:",
            "                # transfer the file to a remote tmp location",
            "                tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir,",
            "                                                            os.path.basename(source))",
            "",
            "                # Convert raw_params to text for the purpose of replacing the script since",
            "                # parts and tmp_src are both unicode strings and raw_params will be different",
            "                # depending on Python version.",
            "                #",
            "                # Once everything is encoded consistently, replace the script path on the remote",
            "                # system with the remainder of the raw_params. This preserves quoting in parameters",
            "                # that would have been removed by shlex.split().",
            "                target_command = to_text(raw_params).strip().replace(parts[0], tmp_src)",
            "",
            "                self._transfer_file(source, tmp_src)",
            "",
            "                # set file permissions, more permissive when the copy is done as a different user",
            "                self._fixup_perms2((self._connection._shell.tmpdir, tmp_src), execute=True)",
            "",
            "                # add preparation steps to one ssh roundtrip executing the script",
            "                env_dict = dict()",
            "                env_string = self._compute_environment_string(env_dict)",
            "",
            "                if executable:",
            "                    script_cmd = ' '.join([env_string, executable, target_command])",
            "                else:",
            "                    script_cmd = ' '.join([env_string, target_command])",
            "",
            "            if self._play_context.check_mode:",
            "                raise _AnsibleActionDone()",
            "",
            "            script_cmd = self._connection._shell.wrap_for_exec(script_cmd)",
            "",
            "            exec_data = None",
            "            # PowerShell runs the script in a special wrapper to enable things",
            "            # like become and environment args",
            "            if self._connection._shell.SHELL_FAMILY == \"powershell\":",
            "                # FIXME: use a more public method to get the exec payload",
            "                pc = self._play_context",
            "                exec_data = ps_manifest._create_powershell_wrapper(",
            "                    to_bytes(script_cmd), {}, env_dict, self._task.async_val,",
            "                    pc.become, pc.become_method, pc.become_user,",
            "                    pc.become_pass, pc.become_flags, substyle=\"script\"",
            "                )",
            "                script_cmd = \"-\"",
            "",
            "            result.update(self._low_level_execute_command(cmd=script_cmd, in_data=exec_data, sudoable=True, chdir=chdir))",
            "",
            "            if 'rc' in result and result['rc'] != 0:",
            "                raise AnsibleActionFail('non-zero return code')",
            "",
            "        except AnsibleAction as e:",
            "            result.update(e.result)",
            "        finally:",
            "            self._remove_tmp_path(self._connection._shell.tmpdir)",
            "",
            "        return result"
        ],
        "afterPatchFile": [
            "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import re",
            "import shlex",
            "",
            "from ansible.errors import AnsibleError, AnsibleAction, _AnsibleActionDone, AnsibleActionFail, AnsibleActionSkip",
            "from ansible.executor.powershell import module_manifest as ps_manifest",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.action import ActionBase",
            "",
            "",
            "class ActionModule(ActionBase):",
            "",
            "    TRANSFERS_FILES = True",
            "",
            "    # On Windows platform, absolute paths begin with a (back)slash",
            "    # after chopping off a potential drive letter.",
            "    windows_absolute_path_detection = re.compile(r'^(?:[a-zA-Z]\\:)?(\\\\|\\/)')",
            "",
            "    def run(self, tmp=None, task_vars=None):",
            "        ''' handler for file transfer operations '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        result = super(ActionModule, self).run(tmp, task_vars)",
            "        del tmp  # tmp no longer has any effect",
            "",
            "        try:",
            "            creates = self._task.args.get('creates')",
            "            if creates:",
            "                # do not run the command if the line contains creates=filename",
            "                # and the filename already exists. This allows idempotence",
            "                # of command executions.",
            "                if self._remote_file_exists(creates):",
            "                    raise AnsibleActionSkip(\"%s exists, matching creates option\" % creates)",
            "",
            "            removes = self._task.args.get('removes')",
            "            if removes:",
            "                # do not run the command if the line contains removes=filename",
            "                # and the filename does not exist. This allows idempotence",
            "                # of command executions.",
            "                if not self._remote_file_exists(removes):",
            "                    raise AnsibleActionSkip(\"%s does not exist, matching removes option\" % removes)",
            "",
            "            # The chdir must be absolute, because a relative path would rely on",
            "            # remote node behaviour & user config.",
            "            chdir = self._task.args.get('chdir')",
            "            if chdir:",
            "                # Powershell is the only Windows-path aware shell",
            "                if self._connection._shell.SHELL_FAMILY == 'powershell' and \\",
            "                        not self.windows_absolute_path_detection.matches(chdir):",
            "                    raise AnsibleActionFail('chdir %s must be an absolute path for a Windows remote node' % chdir)",
            "                # Every other shell is unix-path-aware.",
            "                if self._connection._shell.SHELL_FAMILY != 'powershell' and not chdir.startswith('/'):",
            "                    raise AnsibleActionFail('chdir %s must be an absolute path for a Unix-aware remote node' % chdir)",
            "",
            "            # Split out the script as the first item in raw_params using",
            "            # shlex.split() in order to support paths and files with spaces in the name.",
            "            # Any arguments passed to the script will be added back later.",
            "            raw_params = to_native(self._task.args.get('_raw_params', ''), errors='surrogate_or_strict')",
            "            parts = [to_text(s, errors='surrogate_or_strict') for s in shlex.split(raw_params.strip())]",
            "            source = parts[0]",
            "",
            "            # Support executable paths and files with spaces in the name.",
            "            executable = to_native(self._task.args.get('executable', ''), errors='surrogate_or_strict')",
            "",
            "            try:",
            "                source = self._loader.get_real_file(self._find_needle('files', source), decrypt=self._task.args.get('decrypt', True))",
            "            except AnsibleError as e:",
            "                raise AnsibleActionFail(to_native(e))",
            "",
            "            # now we execute script, always assume changed.",
            "            result['changed'] = True",
            "",
            "            if not self._play_context.check_mode:",
            "                # transfer the file to a remote tmp location",
            "                tmp_src = self._connection._shell.join_path(self._connection._shell.tmpdir,",
            "                                                            os.path.basename(source))",
            "",
            "                # Convert raw_params to text for the purpose of replacing the script since",
            "                # parts and tmp_src are both unicode strings and raw_params will be different",
            "                # depending on Python version.",
            "                #",
            "                # Once everything is encoded consistently, replace the script path on the remote",
            "                # system with the remainder of the raw_params. This preserves quoting in parameters",
            "                # that would have been removed by shlex.split().",
            "                target_command = to_text(raw_params).strip().replace(parts[0], tmp_src)",
            "",
            "                self._transfer_file(source, tmp_src)",
            "",
            "                # set file permissions, more permissive when the copy is done as a different user",
            "                self._fixup_perms2((self._connection._shell.tmpdir, tmp_src), execute=True)",
            "",
            "                # add preparation steps to one ssh roundtrip executing the script",
            "                env_dict = dict()",
            "                env_string = self._compute_environment_string(env_dict)",
            "",
            "                if executable:",
            "                    script_cmd = ' '.join([env_string, executable, target_command])",
            "                else:",
            "                    script_cmd = ' '.join([env_string, target_command])",
            "",
            "            if self._play_context.check_mode:",
            "                raise _AnsibleActionDone()",
            "",
            "            script_cmd = self._connection._shell.wrap_for_exec(script_cmd)",
            "",
            "            exec_data = None",
            "            # PowerShell runs the script in a special wrapper to enable things",
            "            # like become and environment args",
            "            if self._connection._shell.SHELL_FAMILY == \"powershell\":",
            "                # FUTURE: use a more public method to get the exec payload",
            "                pc = self._play_context",
            "                exec_data = ps_manifest._create_powershell_wrapper(",
            "                    to_bytes(script_cmd), {}, env_dict, self._task.async_val,",
            "                    pc.become, pc.become_method, pc.become_user,",
            "                    pc.become_pass, pc.become_flags, substyle=\"script\"",
            "                )",
            "                # build the necessary exec wrapper command",
            "                # FUTURE: this still doesn't let script work on Windows with non-pipelined connections or",
            "                # full manual exec of KEEP_REMOTE_FILES",
            "                script_cmd = self._connection._shell.build_module_command(env_string='', shebang='#!powershell', cmd='')",
            "",
            "            result.update(self._low_level_execute_command(cmd=script_cmd, in_data=exec_data, sudoable=True, chdir=chdir))",
            "",
            "            if 'rc' in result and result['rc'] != 0:",
            "                raise AnsibleActionFail('non-zero return code')",
            "",
            "        except AnsibleAction as e:",
            "            result.update(e.result)",
            "        finally:",
            "            self._remove_tmp_path(self._connection._shell.tmpdir)",
            "",
            "        return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "130": [
                "ActionModule",
                "run"
            ],
            "137": [
                "ActionModule",
                "run"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/connection/psrp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             # starting a new interpreter to save on time"
            },
            "1": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             b_command = base64.b64decode(cmd.split(\" \")[-1])"
            },
            "2": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "             script = to_text(b_command, 'utf-16-le')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+            in_data = to_text(in_data, errors=\"surrogate_or_strict\", nonstring=\"passthru\")"
            },
            "4": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "             display.vvv(\"PSRP: EXEC %s\" % script, host=self._psrp_host)"
            },
            "5": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         else:"
            },
            "6": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "             # in other cases we want to execute the cmd as the script"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2018 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = \"\"\"",
            "author: Ansible Core Team",
            "connection: psrp",
            "short_description: Run tasks over Microsoft PowerShell Remoting Protocol",
            "description:",
            "- Run commands or put/fetch on a target via PSRP (WinRM plugin)",
            "- This is similar to the I(winrm) connection plugin which uses the same",
            "  underlying transport but instead runs in a PowerShell interpreter.",
            "version_added: \"2.7\"",
            "requirements:",
            "- pypsrp (Python library)",
            "options:",
            "  # transport options",
            "  remote_addr:",
            "    description:",
            "    - The hostname or IP address of the remote host.",
            "    default: inventory_hostname",
            "    vars:",
            "    - name: ansible_host",
            "    - name: ansible_psrp_host",
            "  remote_user:",
            "    description:",
            "    - The user to log in as.",
            "    vars:",
            "    - name: ansible_user",
            "    - name: ansible_psrp_user",
            "  port:",
            "    description:",
            "    - The port for PSRP to connect on the remote target.",
            "    - Default is C(5986) if I(protocol) is not defined or is C(https),",
            "      otherwise the port is C(5985).",
            "    vars:",
            "    - name: ansible_port",
            "    - name: ansible_psrp_port",
            "  protocol:",
            "    description:",
            "    - Set the protocol to use for the connection.",
            "    - Default is C(https) if I(port) is not defined or I(port) is not C(5985).",
            "    choices:",
            "    - http",
            "    - https",
            "    vars:",
            "    - name: ansible_psrp_protocol",
            "  path:",
            "    description:",
            "    - The URI path to connect to.",
            "    vars:",
            "    - name: ansible_psrp_path",
            "    default: 'wsman'",
            "  auth:",
            "    description:",
            "    - The authentication protocol to use when authenticating the remote user.",
            "    - The default, C(negotiate), will attempt to use C(Kerberos) if it is",
            "      available and fall back to C(NTLM) if it isn't.",
            "    vars:",
            "    - name: ansible_psrp_auth",
            "    choices:",
            "    - basic",
            "    - certificate",
            "    - negotiate",
            "    - kerberos",
            "    - ntlm",
            "    - credssp",
            "    default: negotiate",
            "  cert_validation:",
            "    description:",
            "    - Whether to validate the remote server's certificate or not.",
            "    - Set to C(ignore) to not validate any certificates.",
            "    - I(cert_trust_path) can be set to the path of a PEM certificate chain to",
            "      use in the validation.",
            "    choices:",
            "    - validate",
            "    - ignore",
            "    default: validate",
            "    vars:",
            "    - name: ansible_psrp_cert_validation",
            "  cert_trust_path:",
            "    description:",
            "    - The path to a PEM certificate chain to use when validating the server's",
            "      certificate.",
            "    - This value is ignored if I(cert_validation) is set to C(ignore).",
            "    vars:",
            "    - name: ansible_psrp_cert_trust_path",
            "  connection_timeout:",
            "    description:",
            "    - The connection timeout for making the request to the remote host.",
            "    - This is measured in seconds.",
            "    vars:",
            "    - name: ansible_psrp_connection_timeout",
            "    default: 30",
            "  message_encryption:",
            "    description:",
            "    - Controls the message encryption settings, this is different from TLS",
            "      encryption when I(ansible_psrp_protocol) is C(https).",
            "    - Only the auth protocols C(negotiate), C(kerberos), C(ntlm), and",
            "      C(credssp) can do message encryption. The other authentication protocols",
            "      only support encryption when C(protocol) is set to C(https).",
            "    - C(auto) means means message encryption is only used when not using",
            "      TLS/HTTPS.",
            "    - C(always) is the same as C(auto) but message encryption is always used",
            "      even when running over TLS/HTTPS.",
            "    - C(never) disables any encryption checks that are in place when running",
            "      over HTTP and disables any authentication encryption processes.",
            "    vars:",
            "    - name: ansible_psrp_message_encryption",
            "    choices:",
            "    - auto",
            "    - always",
            "    - never",
            "    default: auto",
            "  proxy:",
            "    description:",
            "    - Set the proxy URL to use when connecting to the remote host.",
            "    vars:",
            "    - name: ansible_psrp_proxy",
            "  ignore_proxy:",
            "    description:",
            "    - Will disable any environment proxy settings and connect directly to the",
            "      remote host.",
            "    - This option is ignored if C(proxy) is set.",
            "    vars:",
            "    - name: ansible_psrp_ignore_proxy",
            "    type: bool",
            "    default: 'no'",
            "",
            "  # protocol options",
            "  operation_timeout:",
            "    description:",
            "    - Sets the WSMan timeout for each operation.",
            "    - This is measured in seconds.",
            "    - This should not exceed the value for C(connection_timeout).",
            "    vars:",
            "    - name: ansible_psrp_operation_timeout",
            "    default: 20",
            "  max_envelope_size:",
            "    description:",
            "    - Sets the maximum size of each WSMan message sent to the remote host.",
            "    - This is measured in bytes.",
            "    - Defaults to C(150KiB) for compatibility with older hosts.",
            "    vars:",
            "    - name: ansible_psrp_max_envelope_size",
            "    default: 153600",
            "  configuration_name:",
            "    description:",
            "    - The name of the PowerShell configuration endpoint to connect to.",
            "    vars:",
            "    - name: ansible_psrp_configuration_name",
            "    default: Microsoft.PowerShell",
            "\"\"\"",
            "",
            "import base64",
            "import json",
            "import os",
            "",
            "from ansible.errors import AnsibleConnectionFailure, AnsibleError",
            "from ansible.errors import AnsibleFileNotFound",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.plugins.shell.powershell import _common_args",
            "from ansible.utils.display import Display",
            "from ansible.utils.hashing import secure_hash",
            "from ansible.utils.path import makedirs_safe",
            "",
            "HAS_PYPSRP = True",
            "PYPSRP_IMP_ERR = None",
            "try:",
            "    from pypsrp.complex_objects import GenericComplexObject, RunspacePoolState",
            "    from pypsrp.exceptions import AuthenticationError, WinRMError",
            "    from pypsrp.host import PSHost, PSHostUserInterface",
            "    from pypsrp.powershell import PowerShell, RunspacePool",
            "    from pypsrp.shell import Process, SignalCode, WinRS",
            "    from pypsrp.wsman import WSMan, AUTH_KWARGS",
            "    from requests.exceptions import ConnectionError, ConnectTimeout",
            "except ImportError as err:",
            "    HAS_PYPSRP = False",
            "    PYPSRP_IMP_ERR = err",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "",
            "    transport = 'psrp'",
            "    module_implementation_preferences = ('.ps1', '.exe', '')",
            "    become_methods = ['runas']",
            "    allow_executable = False",
            "    has_pipelining = True",
            "    allow_extras = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.always_pipeline_modules = True",
            "        self.has_native_async = True",
            "",
            "        self.runspace = None",
            "        self.host = None",
            "",
            "        self._shell_type = 'powershell'",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "",
            "    def _connect(self):",
            "        if not HAS_PYPSRP:",
            "            raise AnsibleError(\"pypsrp or dependencies are not installed: %s\"",
            "                               % to_native(PYPSRP_IMP_ERR))",
            "        super(Connection, self)._connect()",
            "        self._build_kwargs()",
            "        display.vvv(\"ESTABLISH PSRP CONNECTION FOR USER: %s ON PORT %s TO %s\" %",
            "                    (self._psrp_user, self._psrp_port, self._psrp_host),",
            "                    host=self._psrp_host)",
            "",
            "        if not self.runspace:",
            "            connection = WSMan(**self._psrp_conn_kwargs)",
            "",
            "            # create our psuedo host to capture the exit code and host output",
            "            host_ui = PSHostUserInterface()",
            "            self.host = PSHost(None, None, False, \"Ansible PSRP Host\", None,",
            "                               host_ui, None)",
            "",
            "            self.runspace = RunspacePool(",
            "                connection, host=self.host,",
            "                configuration_name=self._psrp_configuration_name",
            "            )",
            "            display.vvvvv(",
            "                \"PSRP OPEN RUNSPACE: auth=%s configuration=%s endpoint=%s\" %",
            "                (self._psrp_auth, self._psrp_configuration_name,",
            "                 connection.transport.endpoint), host=self._psrp_host",
            "            )",
            "            try:",
            "                self.runspace.open()",
            "            except AuthenticationError as e:",
            "                raise AnsibleConnectionFailure(\"failed to authenticate with \"",
            "                                               \"the server: %s\" % to_native(e))",
            "            except WinRMError as e:",
            "                raise AnsibleConnectionFailure(",
            "                    \"psrp connection failure during runspace open: %s\"",
            "                    % to_native(e)",
            "                )",
            "            except (ConnectionError, ConnectTimeout) as e:",
            "                raise AnsibleConnectionFailure(",
            "                    \"Failed to connect to the host via PSRP: %s\"",
            "                    % to_native(e)",
            "                )",
            "",
            "            self._connected = True",
            "        return self",
            "",
            "    def reset(self):",
            "        display.vvvvv(\"PSRP: Reset Connection\", host=self._psrp_host)",
            "        self.runspace = None",
            "        self._connect()",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        super(Connection, self).exec_command(cmd, in_data=in_data,",
            "                                             sudoable=sudoable)",
            "",
            "        if cmd == \"-\" and not in_data.startswith(b\"#!\"):",
            "            # The powershell plugin sets cmd to '-' when we are executing a",
            "            # PowerShell script with in_data being the script to execute.",
            "            script = in_data",
            "            in_data = None",
            "            display.vvv(\"PSRP: EXEC (via pipeline wrapper)\",",
            "                        host=self._psrp_host)",
            "        elif cmd == \"-\":",
            "            # ANSIBALLZ wrapper, we need to get the interpreter and execute",
            "            # that as the script - note this won't work as basic.py relies",
            "            # on packages not available on Windows, once fixed we can enable",
            "            # this path",
            "            interpreter = to_native(in_data.splitlines()[0][2:])",
            "            # script = \"$input | &'%s' -\" % interpreter",
            "            # in_data = to_text(in_data)",
            "            raise AnsibleError(\"cannot run the interpreter '%s' on the psrp \"",
            "                               \"connection plugin\" % interpreter)",
            "        elif cmd.startswith(\" \".join(_common_args) + \" -EncodedCommand\"):",
            "            # This is a PowerShell script encoded by the shell plugin, we will",
            "            # decode the script and execute it in the runspace instead of",
            "            # starting a new interpreter to save on time",
            "            b_command = base64.b64decode(cmd.split(\" \")[-1])",
            "            script = to_text(b_command, 'utf-16-le')",
            "            display.vvv(\"PSRP: EXEC %s\" % script, host=self._psrp_host)",
            "        else:",
            "            # in other cases we want to execute the cmd as the script",
            "            script = cmd",
            "            display.vvv(\"PSRP: EXEC %s\" % script, host=self._psrp_host)",
            "",
            "        rc, stdout, stderr = self._exec_psrp_script(script, in_data)",
            "        return rc, stdout, stderr",
            "",
            "    def put_file(self, in_path, out_path):",
            "        super(Connection, self).put_file(in_path, out_path)",
            "        display.vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self._psrp_host)",
            "",
            "        out_path = self._shell._unquote(out_path)",
            "        script = u'''begin {",
            "    $ErrorActionPreference = \"Stop\"",
            "",
            "    $path = '%s'",
            "    $fd = [System.IO.File]::Create($path)",
            "    $algo = [System.Security.Cryptography.SHA1CryptoServiceProvider]::Create()",
            "    $bytes = @()",
            "} process {",
            "    $bytes = [System.Convert]::FromBase64String($input)",
            "    $algo.TransformBlock($bytes, 0, $bytes.Length, $bytes, 0) > $null",
            "    $fd.Write($bytes, 0, $bytes.Length)",
            "} end {",
            "    $fd.Close()",
            "    $algo.TransformFinalBlock($bytes, 0, 0) > $null",
            "    $hash = [System.BitConverter]::ToString($algo.Hash)",
            "    $hash = $hash.Replace(\"-\", \"\").ToLowerInvariant()",
            "",
            "    Write-Output -InputObject \"{`\"sha1`\":`\"$hash`\"}\"",
            "}''' % self._shell._escape(out_path)",
            "",
            "        cmd_parts = self._shell._encode_script(script, as_list=True,",
            "                                               strict_mode=False,",
            "                                               preserve_rc=False)",
            "        b_in_path = to_bytes(in_path, errors='surrogate_or_strict')",
            "        if not os.path.exists(b_in_path):",
            "            raise AnsibleFileNotFound('file or module does not exist: \"%s\"'",
            "                                      % to_native(in_path))",
            "",
            "        in_size = os.path.getsize(b_in_path)",
            "        buffer_size = int(self.runspace.connection.max_payload_size / 4 * 3)",
            "",
            "        # copying files is faster when using the raw WinRM shell and not PSRP",
            "        # we will create a WinRS shell just for this process",
            "        # TODO: speed this up as there is overhead creating a shell for this",
            "        with WinRS(self.runspace.connection, codepage=65001) as shell:",
            "            process = Process(shell, cmd_parts[0], cmd_parts[1:])",
            "            process.begin_invoke()",
            "",
            "            offset = 0",
            "            with open(b_in_path, 'rb') as src_file:",
            "                for data in iter((lambda: src_file.read(buffer_size)), b\"\"):",
            "                    offset += len(data)",
            "                    display.vvvvv(\"PSRP PUT %s to %s (offset=%d, size=%d\" %",
            "                                  (in_path, out_path, offset, len(data)),",
            "                                  host=self._psrp_host)",
            "                    b64_data = base64.b64encode(data) + b\"\\r\\n\"",
            "                    process.send(b64_data, end=(src_file.tell() == in_size))",
            "",
            "                # the file was empty, return empty buffer",
            "                if offset == 0:",
            "                    process.send(b\"\", end=True)",
            "",
            "            process.end_invoke()",
            "            process.signal(SignalCode.CTRL_C)",
            "",
            "        if process.rc != 0:",
            "            raise AnsibleError(to_native(process.stderr))",
            "",
            "        put_output = json.loads(process.stdout)",
            "        remote_sha1 = put_output.get(\"sha1\")",
            "",
            "        if not remote_sha1:",
            "            raise AnsibleError(\"Remote sha1 was not returned, stdout: '%s', \"",
            "                               \"stderr: '%s'\" % (to_native(process.stdout),",
            "                                                 to_native(process.stderr)))",
            "",
            "        local_sha1 = secure_hash(in_path)",
            "        if not remote_sha1 == local_sha1:",
            "            raise AnsibleError(\"Remote sha1 hash %s does not match local hash \"",
            "                               \"%s\" % (to_native(remote_sha1),",
            "                                       to_native(local_sha1)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "        display.vvv(\"FETCH %s TO %s\" % (in_path, out_path),",
            "                    host=self._psrp_host)",
            "",
            "        in_path = self._shell._unquote(in_path)",
            "        out_path = out_path.replace('\\\\', '/')",
            "",
            "        # because we are dealing with base64 data we need to get the max size",
            "        # of the bytes that the base64 size would equal",
            "        max_b64_size = int(self.runspace.connection.max_payload_size -",
            "                           (self.runspace.connection.max_payload_size / 4 * 3))",
            "        buffer_size = max_b64_size - (max_b64_size % 1024)",
            "",
            "        # setup the file stream with read only mode",
            "        setup_script = '''$ErrorActionPreference = \"Stop\"",
            "$path = \"%s\"",
            "",
            "if (Test-Path -Path $path -PathType Leaf) {",
            "    $fs = New-Object -TypeName System.IO.FileStream -ArgumentList @(",
            "        $path,",
            "        [System.IO.FileMode]::Open,",
            "        [System.IO.FileAccess]::Read,",
            "        [System.IO.FileShare]::Read",
            "    )",
            "    $buffer_size = %d",
            "} elseif (Test-Path -Path $path -PathType Container) {",
            "    Write-Output -InputObject \"[DIR]\"",
            "} else {",
            "    Write-Error -Message \"$path does not exist\"",
            "    $host.SetShouldExit(1)",
            "}''' % (self._shell._escape(in_path), buffer_size)",
            "",
            "        # read the file stream at the offset and return the b64 string",
            "        read_script = '''$ErrorActionPreference = \"Stop\"",
            "$fs.Seek(%d, [System.IO.SeekOrigin]::Begin) > $null",
            "$buffer = New-Object -TypeName byte[] -ArgumentList $buffer_size",
            "$bytes_read = $fs.Read($buffer, 0, $buffer_size)",
            "",
            "if ($bytes_read -gt 0) {",
            "    $bytes = $buffer[0..($bytes_read - 1)]",
            "    Write-Output -InputObject ([System.Convert]::ToBase64String($bytes))",
            "}'''",
            "",
            "        # need to run the setup script outside of the local scope so the",
            "        # file stream stays active between fetch operations",
            "        rc, stdout, stderr = self._exec_psrp_script(setup_script,",
            "                                                    use_local_scope=False)",
            "        if rc != 0:",
            "            raise AnsibleError(\"failed to setup file stream for fetch '%s': %s\"",
            "                               % (out_path, to_native(stderr)))",
            "        elif stdout.strip() == '[DIR]':",
            "            # in_path was a dir so we need to create the dir locally",
            "            makedirs_safe(out_path)",
            "            return",
            "",
            "        b_out_path = to_bytes(out_path, errors='surrogate_or_strict')",
            "        makedirs_safe(os.path.dirname(b_out_path))",
            "        offset = 0",
            "        with open(b_out_path, 'wb') as out_file:",
            "            while True:",
            "                display.vvvvv(\"PSRP FETCH %s to %s (offset=%d\" %",
            "                              (in_path, out_path, offset), host=self._psrp_host)",
            "                rc, stdout, stderr = \\",
            "                    self._exec_psrp_script(read_script % offset)",
            "                if rc != 0:",
            "                    raise AnsibleError(\"failed to transfer file to '%s': %s\"",
            "                                       % (out_path, to_native(stderr)))",
            "",
            "                data = base64.b64decode(stdout.strip())",
            "                out_file.write(data)",
            "                if len(data) < buffer_size:",
            "                    break",
            "",
            "            rc, stdout, stderr = self._exec_psrp_script(\"$fs.Close()\")",
            "            if rc != 0:",
            "                display.warning(\"failed to close remote file stream of file \"",
            "                                \"'%s': %s\" % (in_path, to_native(stderr)))",
            "",
            "    def close(self):",
            "        if self.runspace and self.runspace.state == RunspacePoolState.OPENED:",
            "            display.vvvvv(\"PSRP CLOSE RUNSPACE: %s\" % (self.runspace.id),",
            "                          host=self._psrp_host)",
            "            self.runspace.close()",
            "        self.runspace = None",
            "        self._connected = False",
            "",
            "    def _build_kwargs(self):",
            "        self._become_method = self._play_context.become_method",
            "        self._become_user = self._play_context.become_user",
            "        self._become_pass = self._play_context.become_pass",
            "",
            "        self._psrp_host = self.get_option('remote_addr')",
            "        self._psrp_user = self.get_option('remote_user')",
            "        self._psrp_pass = self._play_context.password",
            "",
            "        protocol = self.get_option('protocol')",
            "        port = self.get_option('port')",
            "        if protocol is None and port is None:",
            "            protocol = 'https'",
            "            port = 5986",
            "        elif protocol is None:",
            "            protocol = 'https' if int(port) != 5985 else 'http'",
            "        elif port is None:",
            "            port = 5986 if protocol == 'https' else 5985",
            "",
            "        self._psrp_protocol = protocol",
            "        self._psrp_port = int(port)",
            "",
            "        self._psrp_path = self.get_option('path')",
            "        self._psrp_auth = self.get_option('auth')",
            "        # cert validation can either be a bool or a path to the cert",
            "        cert_validation = self.get_option('cert_validation')",
            "        cert_trust_path = self.get_option('cert_trust_path')",
            "        if cert_validation == 'ignore':",
            "            self._psrp_cert_validation = False",
            "        elif cert_trust_path is not None:",
            "            self._psrp_cert_validation = cert_trust_path",
            "        else:",
            "            self._psrp_cert_validation = True",
            "",
            "        self._psrp_connection_timeout = int(self.get_option('connection_timeout'))",
            "        self._psrp_message_encryption = self.get_option('message_encryption')",
            "        self._psrp_proxy = self.get_option('proxy')",
            "        self._psrp_ignore_proxy = boolean(self.get_option('ignore_proxy'))",
            "        self._psrp_operation_timeout = int(self.get_option('operation_timeout'))",
            "        self._psrp_max_envelope_size = int(self.get_option('max_envelope_size'))",
            "        self._psrp_configuration_name = self.get_option('configuration_name')",
            "",
            "        supported_args = []",
            "        for auth_kwarg in AUTH_KWARGS.values():",
            "            supported_args.extend(auth_kwarg)",
            "        extra_args = set([v.replace('ansible_psrp_', '') for v in",
            "                          self.get_option('_extras')])",
            "        unsupported_args = extra_args.difference(supported_args)",
            "",
            "        for arg in unsupported_args:",
            "            display.warning(\"ansible_psrp_%s is unsupported by the current \"",
            "                            \"psrp version installed\" % arg)",
            "",
            "        self._psrp_conn_kwargs = dict(",
            "            server=self._psrp_host, port=self._psrp_port,",
            "            username=self._psrp_user, password=self._psrp_pass,",
            "            ssl=self._psrp_protocol == 'https', path=self._psrp_path,",
            "            auth=self._psrp_auth, cert_validation=self._psrp_cert_validation,",
            "            connection_timeout=self._psrp_connection_timeout,",
            "            encryption=self._psrp_message_encryption, proxy=self._psrp_proxy,",
            "            no_proxy=self._psrp_ignore_proxy,",
            "            max_envelope_size=self._psrp_max_envelope_size,",
            "            operation_timeout=self._psrp_operation_timeout,",
            "        )",
            "        # add in the extra args that were set",
            "        for arg in extra_args.intersection(supported_args):",
            "            option = self.get_option('_extras')['ansible_psrp_%s' % arg]",
            "            self._psrp_conn_kwargs[arg] = option",
            "",
            "    def _exec_psrp_script(self, script, input_data=None, use_local_scope=True):",
            "        ps = PowerShell(self.runspace)",
            "        ps.add_script(script, use_local_scope=use_local_scope)",
            "        ps.invoke(input=input_data)",
            "",
            "        rc, stdout, stderr = self._parse_pipeline_result(ps)",
            "        return rc, stdout, stderr",
            "",
            "    def _parse_pipeline_result(self, pipeline):",
            "        \"\"\"",
            "        PSRP doesn't have the same concept as other protocols with its output.",
            "        We need some extra logic to convert the pipeline streams and host",
            "        output into the format that Ansible understands.",
            "",
            "        :param pipeline: The finished PowerShell pipeline that invoked our",
            "            commands",
            "        :return: rc, stdout, stderr based on the pipeline output",
            "        \"\"\"",
            "        # we try and get the rc from our host implementation, this is set if",
            "        # exit or $host.SetShouldExit() is called in our pipeline, if not we",
            "        # set to 0 if the pipeline had not errors and 1 if it did",
            "        rc = self.host.rc or (1 if pipeline.had_errors else 0)",
            "",
            "        # TODO: figure out a better way of merging this with the host output",
            "        stdout_list = []",
            "        for output in pipeline.output:",
            "            # Not all pipeline outputs are a string or contain a __str__ value,",
            "            # we will create our own output based on the properties of the",
            "            # complex object if that is the case.",
            "            if isinstance(output, GenericComplexObject) and output.to_string is None:",
            "                obj_lines = output.property_sets",
            "                for key, value in output.adapted_properties.items():",
            "                    obj_lines.append(u\"%s: %s\" % (key, value))",
            "                for key, value in output.extended_properties.items():",
            "                    obj_lines.append(u\"%s: %s\" % (key, value))",
            "                output_msg = u\"\\n\".join(obj_lines)",
            "            else:",
            "                output_msg = to_text(output, nonstring='simplerepr')",
            "",
            "            stdout_list.append(output_msg)",
            "",
            "        stdout = u\"\\r\\n\".join(stdout_list)",
            "        if len(self.host.ui.stdout) > 0:",
            "            stdout += u\"\\r\\n\" + u\"\".join(self.host.ui.stdout)",
            "",
            "        stderr_list = []",
            "        for error in pipeline.streams.error:",
            "            # the error record is not as fully fleshed out like we usually get",
            "            # in PS, we will manually create it here",
            "            error_msg = \"%s : %s\\r\\n\" \\",
            "                        \"%s\\r\\n\" \\",
            "                        \"    + CategoryInfo          : %s\\r\\n\" \\",
            "                        \"    + FullyQualifiedErrorId : %s\" \\",
            "                        % (error.command_name, str(error),",
            "                           error.invocation_position_message, error.message,",
            "                           error.fq_error)",
            "            stacktrace = error.script_stacktrace",
            "            if self._play_context.verbosity >= 3 and stacktrace is not None:",
            "                error_msg += \"\\r\\nStackTrace:\\r\\n%s\" % stacktrace",
            "            stderr_list.append(error_msg)",
            "",
            "        stderr = \"\\r\\n\".join(stderr_list)",
            "        if len(self.host.ui.stderr) > 0:",
            "            stderr += \"\\r\\n\" + \"\".join(self.host.ui.stderr)",
            "",
            "        display.vvvvv(\"PSRP RC: %d\" % rc, host=self._psrp_host)",
            "        display.vvvvv(\"PSRP STDOUT: %s\" % stdout, host=self._psrp_host)",
            "        display.vvvvv(\"PSRP STDERR: %s\" % stderr, host=self._psrp_host)",
            "",
            "        # reset the host back output back to defaults, needed if running",
            "        # multiple pipelines on the same RunspacePool",
            "        self.host.rc = 0",
            "        self.host.ui.stdout = []",
            "        self.host.ui.stderr = []",
            "",
            "        return rc, to_bytes(stdout, encoding='utf-8'), to_bytes(stderr, encoding='utf-8')"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2018 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = \"\"\"",
            "author: Ansible Core Team",
            "connection: psrp",
            "short_description: Run tasks over Microsoft PowerShell Remoting Protocol",
            "description:",
            "- Run commands or put/fetch on a target via PSRP (WinRM plugin)",
            "- This is similar to the I(winrm) connection plugin which uses the same",
            "  underlying transport but instead runs in a PowerShell interpreter.",
            "version_added: \"2.7\"",
            "requirements:",
            "- pypsrp (Python library)",
            "options:",
            "  # transport options",
            "  remote_addr:",
            "    description:",
            "    - The hostname or IP address of the remote host.",
            "    default: inventory_hostname",
            "    vars:",
            "    - name: ansible_host",
            "    - name: ansible_psrp_host",
            "  remote_user:",
            "    description:",
            "    - The user to log in as.",
            "    vars:",
            "    - name: ansible_user",
            "    - name: ansible_psrp_user",
            "  port:",
            "    description:",
            "    - The port for PSRP to connect on the remote target.",
            "    - Default is C(5986) if I(protocol) is not defined or is C(https),",
            "      otherwise the port is C(5985).",
            "    vars:",
            "    - name: ansible_port",
            "    - name: ansible_psrp_port",
            "  protocol:",
            "    description:",
            "    - Set the protocol to use for the connection.",
            "    - Default is C(https) if I(port) is not defined or I(port) is not C(5985).",
            "    choices:",
            "    - http",
            "    - https",
            "    vars:",
            "    - name: ansible_psrp_protocol",
            "  path:",
            "    description:",
            "    - The URI path to connect to.",
            "    vars:",
            "    - name: ansible_psrp_path",
            "    default: 'wsman'",
            "  auth:",
            "    description:",
            "    - The authentication protocol to use when authenticating the remote user.",
            "    - The default, C(negotiate), will attempt to use C(Kerberos) if it is",
            "      available and fall back to C(NTLM) if it isn't.",
            "    vars:",
            "    - name: ansible_psrp_auth",
            "    choices:",
            "    - basic",
            "    - certificate",
            "    - negotiate",
            "    - kerberos",
            "    - ntlm",
            "    - credssp",
            "    default: negotiate",
            "  cert_validation:",
            "    description:",
            "    - Whether to validate the remote server's certificate or not.",
            "    - Set to C(ignore) to not validate any certificates.",
            "    - I(cert_trust_path) can be set to the path of a PEM certificate chain to",
            "      use in the validation.",
            "    choices:",
            "    - validate",
            "    - ignore",
            "    default: validate",
            "    vars:",
            "    - name: ansible_psrp_cert_validation",
            "  cert_trust_path:",
            "    description:",
            "    - The path to a PEM certificate chain to use when validating the server's",
            "      certificate.",
            "    - This value is ignored if I(cert_validation) is set to C(ignore).",
            "    vars:",
            "    - name: ansible_psrp_cert_trust_path",
            "  connection_timeout:",
            "    description:",
            "    - The connection timeout for making the request to the remote host.",
            "    - This is measured in seconds.",
            "    vars:",
            "    - name: ansible_psrp_connection_timeout",
            "    default: 30",
            "  message_encryption:",
            "    description:",
            "    - Controls the message encryption settings, this is different from TLS",
            "      encryption when I(ansible_psrp_protocol) is C(https).",
            "    - Only the auth protocols C(negotiate), C(kerberos), C(ntlm), and",
            "      C(credssp) can do message encryption. The other authentication protocols",
            "      only support encryption when C(protocol) is set to C(https).",
            "    - C(auto) means means message encryption is only used when not using",
            "      TLS/HTTPS.",
            "    - C(always) is the same as C(auto) but message encryption is always used",
            "      even when running over TLS/HTTPS.",
            "    - C(never) disables any encryption checks that are in place when running",
            "      over HTTP and disables any authentication encryption processes.",
            "    vars:",
            "    - name: ansible_psrp_message_encryption",
            "    choices:",
            "    - auto",
            "    - always",
            "    - never",
            "    default: auto",
            "  proxy:",
            "    description:",
            "    - Set the proxy URL to use when connecting to the remote host.",
            "    vars:",
            "    - name: ansible_psrp_proxy",
            "  ignore_proxy:",
            "    description:",
            "    - Will disable any environment proxy settings and connect directly to the",
            "      remote host.",
            "    - This option is ignored if C(proxy) is set.",
            "    vars:",
            "    - name: ansible_psrp_ignore_proxy",
            "    type: bool",
            "    default: 'no'",
            "",
            "  # protocol options",
            "  operation_timeout:",
            "    description:",
            "    - Sets the WSMan timeout for each operation.",
            "    - This is measured in seconds.",
            "    - This should not exceed the value for C(connection_timeout).",
            "    vars:",
            "    - name: ansible_psrp_operation_timeout",
            "    default: 20",
            "  max_envelope_size:",
            "    description:",
            "    - Sets the maximum size of each WSMan message sent to the remote host.",
            "    - This is measured in bytes.",
            "    - Defaults to C(150KiB) for compatibility with older hosts.",
            "    vars:",
            "    - name: ansible_psrp_max_envelope_size",
            "    default: 153600",
            "  configuration_name:",
            "    description:",
            "    - The name of the PowerShell configuration endpoint to connect to.",
            "    vars:",
            "    - name: ansible_psrp_configuration_name",
            "    default: Microsoft.PowerShell",
            "\"\"\"",
            "",
            "import base64",
            "import json",
            "import os",
            "",
            "from ansible.errors import AnsibleConnectionFailure, AnsibleError",
            "from ansible.errors import AnsibleFileNotFound",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.plugins.shell.powershell import _common_args",
            "from ansible.utils.display import Display",
            "from ansible.utils.hashing import secure_hash",
            "from ansible.utils.path import makedirs_safe",
            "",
            "HAS_PYPSRP = True",
            "PYPSRP_IMP_ERR = None",
            "try:",
            "    from pypsrp.complex_objects import GenericComplexObject, RunspacePoolState",
            "    from pypsrp.exceptions import AuthenticationError, WinRMError",
            "    from pypsrp.host import PSHost, PSHostUserInterface",
            "    from pypsrp.powershell import PowerShell, RunspacePool",
            "    from pypsrp.shell import Process, SignalCode, WinRS",
            "    from pypsrp.wsman import WSMan, AUTH_KWARGS",
            "    from requests.exceptions import ConnectionError, ConnectTimeout",
            "except ImportError as err:",
            "    HAS_PYPSRP = False",
            "    PYPSRP_IMP_ERR = err",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "",
            "    transport = 'psrp'",
            "    module_implementation_preferences = ('.ps1', '.exe', '')",
            "    become_methods = ['runas']",
            "    allow_executable = False",
            "    has_pipelining = True",
            "    allow_extras = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.always_pipeline_modules = True",
            "        self.has_native_async = True",
            "",
            "        self.runspace = None",
            "        self.host = None",
            "",
            "        self._shell_type = 'powershell'",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "",
            "    def _connect(self):",
            "        if not HAS_PYPSRP:",
            "            raise AnsibleError(\"pypsrp or dependencies are not installed: %s\"",
            "                               % to_native(PYPSRP_IMP_ERR))",
            "        super(Connection, self)._connect()",
            "        self._build_kwargs()",
            "        display.vvv(\"ESTABLISH PSRP CONNECTION FOR USER: %s ON PORT %s TO %s\" %",
            "                    (self._psrp_user, self._psrp_port, self._psrp_host),",
            "                    host=self._psrp_host)",
            "",
            "        if not self.runspace:",
            "            connection = WSMan(**self._psrp_conn_kwargs)",
            "",
            "            # create our psuedo host to capture the exit code and host output",
            "            host_ui = PSHostUserInterface()",
            "            self.host = PSHost(None, None, False, \"Ansible PSRP Host\", None,",
            "                               host_ui, None)",
            "",
            "            self.runspace = RunspacePool(",
            "                connection, host=self.host,",
            "                configuration_name=self._psrp_configuration_name",
            "            )",
            "            display.vvvvv(",
            "                \"PSRP OPEN RUNSPACE: auth=%s configuration=%s endpoint=%s\" %",
            "                (self._psrp_auth, self._psrp_configuration_name,",
            "                 connection.transport.endpoint), host=self._psrp_host",
            "            )",
            "            try:",
            "                self.runspace.open()",
            "            except AuthenticationError as e:",
            "                raise AnsibleConnectionFailure(\"failed to authenticate with \"",
            "                                               \"the server: %s\" % to_native(e))",
            "            except WinRMError as e:",
            "                raise AnsibleConnectionFailure(",
            "                    \"psrp connection failure during runspace open: %s\"",
            "                    % to_native(e)",
            "                )",
            "            except (ConnectionError, ConnectTimeout) as e:",
            "                raise AnsibleConnectionFailure(",
            "                    \"Failed to connect to the host via PSRP: %s\"",
            "                    % to_native(e)",
            "                )",
            "",
            "            self._connected = True",
            "        return self",
            "",
            "    def reset(self):",
            "        display.vvvvv(\"PSRP: Reset Connection\", host=self._psrp_host)",
            "        self.runspace = None",
            "        self._connect()",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        super(Connection, self).exec_command(cmd, in_data=in_data,",
            "                                             sudoable=sudoable)",
            "",
            "        if cmd == \"-\" and not in_data.startswith(b\"#!\"):",
            "            # The powershell plugin sets cmd to '-' when we are executing a",
            "            # PowerShell script with in_data being the script to execute.",
            "            script = in_data",
            "            in_data = None",
            "            display.vvv(\"PSRP: EXEC (via pipeline wrapper)\",",
            "                        host=self._psrp_host)",
            "        elif cmd == \"-\":",
            "            # ANSIBALLZ wrapper, we need to get the interpreter and execute",
            "            # that as the script - note this won't work as basic.py relies",
            "            # on packages not available on Windows, once fixed we can enable",
            "            # this path",
            "            interpreter = to_native(in_data.splitlines()[0][2:])",
            "            # script = \"$input | &'%s' -\" % interpreter",
            "            # in_data = to_text(in_data)",
            "            raise AnsibleError(\"cannot run the interpreter '%s' on the psrp \"",
            "                               \"connection plugin\" % interpreter)",
            "        elif cmd.startswith(\" \".join(_common_args) + \" -EncodedCommand\"):",
            "            # This is a PowerShell script encoded by the shell plugin, we will",
            "            # decode the script and execute it in the runspace instead of",
            "            # starting a new interpreter to save on time",
            "            b_command = base64.b64decode(cmd.split(\" \")[-1])",
            "            script = to_text(b_command, 'utf-16-le')",
            "            in_data = to_text(in_data, errors=\"surrogate_or_strict\", nonstring=\"passthru\")",
            "            display.vvv(\"PSRP: EXEC %s\" % script, host=self._psrp_host)",
            "        else:",
            "            # in other cases we want to execute the cmd as the script",
            "            script = cmd",
            "            display.vvv(\"PSRP: EXEC %s\" % script, host=self._psrp_host)",
            "",
            "        rc, stdout, stderr = self._exec_psrp_script(script, in_data)",
            "        return rc, stdout, stderr",
            "",
            "    def put_file(self, in_path, out_path):",
            "        super(Connection, self).put_file(in_path, out_path)",
            "        display.vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self._psrp_host)",
            "",
            "        out_path = self._shell._unquote(out_path)",
            "        script = u'''begin {",
            "    $ErrorActionPreference = \"Stop\"",
            "",
            "    $path = '%s'",
            "    $fd = [System.IO.File]::Create($path)",
            "    $algo = [System.Security.Cryptography.SHA1CryptoServiceProvider]::Create()",
            "    $bytes = @()",
            "} process {",
            "    $bytes = [System.Convert]::FromBase64String($input)",
            "    $algo.TransformBlock($bytes, 0, $bytes.Length, $bytes, 0) > $null",
            "    $fd.Write($bytes, 0, $bytes.Length)",
            "} end {",
            "    $fd.Close()",
            "    $algo.TransformFinalBlock($bytes, 0, 0) > $null",
            "    $hash = [System.BitConverter]::ToString($algo.Hash)",
            "    $hash = $hash.Replace(\"-\", \"\").ToLowerInvariant()",
            "",
            "    Write-Output -InputObject \"{`\"sha1`\":`\"$hash`\"}\"",
            "}''' % self._shell._escape(out_path)",
            "",
            "        cmd_parts = self._shell._encode_script(script, as_list=True,",
            "                                               strict_mode=False,",
            "                                               preserve_rc=False)",
            "        b_in_path = to_bytes(in_path, errors='surrogate_or_strict')",
            "        if not os.path.exists(b_in_path):",
            "            raise AnsibleFileNotFound('file or module does not exist: \"%s\"'",
            "                                      % to_native(in_path))",
            "",
            "        in_size = os.path.getsize(b_in_path)",
            "        buffer_size = int(self.runspace.connection.max_payload_size / 4 * 3)",
            "",
            "        # copying files is faster when using the raw WinRM shell and not PSRP",
            "        # we will create a WinRS shell just for this process",
            "        # TODO: speed this up as there is overhead creating a shell for this",
            "        with WinRS(self.runspace.connection, codepage=65001) as shell:",
            "            process = Process(shell, cmd_parts[0], cmd_parts[1:])",
            "            process.begin_invoke()",
            "",
            "            offset = 0",
            "            with open(b_in_path, 'rb') as src_file:",
            "                for data in iter((lambda: src_file.read(buffer_size)), b\"\"):",
            "                    offset += len(data)",
            "                    display.vvvvv(\"PSRP PUT %s to %s (offset=%d, size=%d\" %",
            "                                  (in_path, out_path, offset, len(data)),",
            "                                  host=self._psrp_host)",
            "                    b64_data = base64.b64encode(data) + b\"\\r\\n\"",
            "                    process.send(b64_data, end=(src_file.tell() == in_size))",
            "",
            "                # the file was empty, return empty buffer",
            "                if offset == 0:",
            "                    process.send(b\"\", end=True)",
            "",
            "            process.end_invoke()",
            "            process.signal(SignalCode.CTRL_C)",
            "",
            "        if process.rc != 0:",
            "            raise AnsibleError(to_native(process.stderr))",
            "",
            "        put_output = json.loads(process.stdout)",
            "        remote_sha1 = put_output.get(\"sha1\")",
            "",
            "        if not remote_sha1:",
            "            raise AnsibleError(\"Remote sha1 was not returned, stdout: '%s', \"",
            "                               \"stderr: '%s'\" % (to_native(process.stdout),",
            "                                                 to_native(process.stderr)))",
            "",
            "        local_sha1 = secure_hash(in_path)",
            "        if not remote_sha1 == local_sha1:",
            "            raise AnsibleError(\"Remote sha1 hash %s does not match local hash \"",
            "                               \"%s\" % (to_native(remote_sha1),",
            "                                       to_native(local_sha1)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "        display.vvv(\"FETCH %s TO %s\" % (in_path, out_path),",
            "                    host=self._psrp_host)",
            "",
            "        in_path = self._shell._unquote(in_path)",
            "        out_path = out_path.replace('\\\\', '/')",
            "",
            "        # because we are dealing with base64 data we need to get the max size",
            "        # of the bytes that the base64 size would equal",
            "        max_b64_size = int(self.runspace.connection.max_payload_size -",
            "                           (self.runspace.connection.max_payload_size / 4 * 3))",
            "        buffer_size = max_b64_size - (max_b64_size % 1024)",
            "",
            "        # setup the file stream with read only mode",
            "        setup_script = '''$ErrorActionPreference = \"Stop\"",
            "$path = \"%s\"",
            "",
            "if (Test-Path -Path $path -PathType Leaf) {",
            "    $fs = New-Object -TypeName System.IO.FileStream -ArgumentList @(",
            "        $path,",
            "        [System.IO.FileMode]::Open,",
            "        [System.IO.FileAccess]::Read,",
            "        [System.IO.FileShare]::Read",
            "    )",
            "    $buffer_size = %d",
            "} elseif (Test-Path -Path $path -PathType Container) {",
            "    Write-Output -InputObject \"[DIR]\"",
            "} else {",
            "    Write-Error -Message \"$path does not exist\"",
            "    $host.SetShouldExit(1)",
            "}''' % (self._shell._escape(in_path), buffer_size)",
            "",
            "        # read the file stream at the offset and return the b64 string",
            "        read_script = '''$ErrorActionPreference = \"Stop\"",
            "$fs.Seek(%d, [System.IO.SeekOrigin]::Begin) > $null",
            "$buffer = New-Object -TypeName byte[] -ArgumentList $buffer_size",
            "$bytes_read = $fs.Read($buffer, 0, $buffer_size)",
            "",
            "if ($bytes_read -gt 0) {",
            "    $bytes = $buffer[0..($bytes_read - 1)]",
            "    Write-Output -InputObject ([System.Convert]::ToBase64String($bytes))",
            "}'''",
            "",
            "        # need to run the setup script outside of the local scope so the",
            "        # file stream stays active between fetch operations",
            "        rc, stdout, stderr = self._exec_psrp_script(setup_script,",
            "                                                    use_local_scope=False)",
            "        if rc != 0:",
            "            raise AnsibleError(\"failed to setup file stream for fetch '%s': %s\"",
            "                               % (out_path, to_native(stderr)))",
            "        elif stdout.strip() == '[DIR]':",
            "            # in_path was a dir so we need to create the dir locally",
            "            makedirs_safe(out_path)",
            "            return",
            "",
            "        b_out_path = to_bytes(out_path, errors='surrogate_or_strict')",
            "        makedirs_safe(os.path.dirname(b_out_path))",
            "        offset = 0",
            "        with open(b_out_path, 'wb') as out_file:",
            "            while True:",
            "                display.vvvvv(\"PSRP FETCH %s to %s (offset=%d\" %",
            "                              (in_path, out_path, offset), host=self._psrp_host)",
            "                rc, stdout, stderr = \\",
            "                    self._exec_psrp_script(read_script % offset)",
            "                if rc != 0:",
            "                    raise AnsibleError(\"failed to transfer file to '%s': %s\"",
            "                                       % (out_path, to_native(stderr)))",
            "",
            "                data = base64.b64decode(stdout.strip())",
            "                out_file.write(data)",
            "                if len(data) < buffer_size:",
            "                    break",
            "",
            "            rc, stdout, stderr = self._exec_psrp_script(\"$fs.Close()\")",
            "            if rc != 0:",
            "                display.warning(\"failed to close remote file stream of file \"",
            "                                \"'%s': %s\" % (in_path, to_native(stderr)))",
            "",
            "    def close(self):",
            "        if self.runspace and self.runspace.state == RunspacePoolState.OPENED:",
            "            display.vvvvv(\"PSRP CLOSE RUNSPACE: %s\" % (self.runspace.id),",
            "                          host=self._psrp_host)",
            "            self.runspace.close()",
            "        self.runspace = None",
            "        self._connected = False",
            "",
            "    def _build_kwargs(self):",
            "        self._become_method = self._play_context.become_method",
            "        self._become_user = self._play_context.become_user",
            "        self._become_pass = self._play_context.become_pass",
            "",
            "        self._psrp_host = self.get_option('remote_addr')",
            "        self._psrp_user = self.get_option('remote_user')",
            "        self._psrp_pass = self._play_context.password",
            "",
            "        protocol = self.get_option('protocol')",
            "        port = self.get_option('port')",
            "        if protocol is None and port is None:",
            "            protocol = 'https'",
            "            port = 5986",
            "        elif protocol is None:",
            "            protocol = 'https' if int(port) != 5985 else 'http'",
            "        elif port is None:",
            "            port = 5986 if protocol == 'https' else 5985",
            "",
            "        self._psrp_protocol = protocol",
            "        self._psrp_port = int(port)",
            "",
            "        self._psrp_path = self.get_option('path')",
            "        self._psrp_auth = self.get_option('auth')",
            "        # cert validation can either be a bool or a path to the cert",
            "        cert_validation = self.get_option('cert_validation')",
            "        cert_trust_path = self.get_option('cert_trust_path')",
            "        if cert_validation == 'ignore':",
            "            self._psrp_cert_validation = False",
            "        elif cert_trust_path is not None:",
            "            self._psrp_cert_validation = cert_trust_path",
            "        else:",
            "            self._psrp_cert_validation = True",
            "",
            "        self._psrp_connection_timeout = int(self.get_option('connection_timeout'))",
            "        self._psrp_message_encryption = self.get_option('message_encryption')",
            "        self._psrp_proxy = self.get_option('proxy')",
            "        self._psrp_ignore_proxy = boolean(self.get_option('ignore_proxy'))",
            "        self._psrp_operation_timeout = int(self.get_option('operation_timeout'))",
            "        self._psrp_max_envelope_size = int(self.get_option('max_envelope_size'))",
            "        self._psrp_configuration_name = self.get_option('configuration_name')",
            "",
            "        supported_args = []",
            "        for auth_kwarg in AUTH_KWARGS.values():",
            "            supported_args.extend(auth_kwarg)",
            "        extra_args = set([v.replace('ansible_psrp_', '') for v in",
            "                          self.get_option('_extras')])",
            "        unsupported_args = extra_args.difference(supported_args)",
            "",
            "        for arg in unsupported_args:",
            "            display.warning(\"ansible_psrp_%s is unsupported by the current \"",
            "                            \"psrp version installed\" % arg)",
            "",
            "        self._psrp_conn_kwargs = dict(",
            "            server=self._psrp_host, port=self._psrp_port,",
            "            username=self._psrp_user, password=self._psrp_pass,",
            "            ssl=self._psrp_protocol == 'https', path=self._psrp_path,",
            "            auth=self._psrp_auth, cert_validation=self._psrp_cert_validation,",
            "            connection_timeout=self._psrp_connection_timeout,",
            "            encryption=self._psrp_message_encryption, proxy=self._psrp_proxy,",
            "            no_proxy=self._psrp_ignore_proxy,",
            "            max_envelope_size=self._psrp_max_envelope_size,",
            "            operation_timeout=self._psrp_operation_timeout,",
            "        )",
            "        # add in the extra args that were set",
            "        for arg in extra_args.intersection(supported_args):",
            "            option = self.get_option('_extras')['ansible_psrp_%s' % arg]",
            "            self._psrp_conn_kwargs[arg] = option",
            "",
            "    def _exec_psrp_script(self, script, input_data=None, use_local_scope=True):",
            "        ps = PowerShell(self.runspace)",
            "        ps.add_script(script, use_local_scope=use_local_scope)",
            "        ps.invoke(input=input_data)",
            "",
            "        rc, stdout, stderr = self._parse_pipeline_result(ps)",
            "        return rc, stdout, stderr",
            "",
            "    def _parse_pipeline_result(self, pipeline):",
            "        \"\"\"",
            "        PSRP doesn't have the same concept as other protocols with its output.",
            "        We need some extra logic to convert the pipeline streams and host",
            "        output into the format that Ansible understands.",
            "",
            "        :param pipeline: The finished PowerShell pipeline that invoked our",
            "            commands",
            "        :return: rc, stdout, stderr based on the pipeline output",
            "        \"\"\"",
            "        # we try and get the rc from our host implementation, this is set if",
            "        # exit or $host.SetShouldExit() is called in our pipeline, if not we",
            "        # set to 0 if the pipeline had not errors and 1 if it did",
            "        rc = self.host.rc or (1 if pipeline.had_errors else 0)",
            "",
            "        # TODO: figure out a better way of merging this with the host output",
            "        stdout_list = []",
            "        for output in pipeline.output:",
            "            # Not all pipeline outputs are a string or contain a __str__ value,",
            "            # we will create our own output based on the properties of the",
            "            # complex object if that is the case.",
            "            if isinstance(output, GenericComplexObject) and output.to_string is None:",
            "                obj_lines = output.property_sets",
            "                for key, value in output.adapted_properties.items():",
            "                    obj_lines.append(u\"%s: %s\" % (key, value))",
            "                for key, value in output.extended_properties.items():",
            "                    obj_lines.append(u\"%s: %s\" % (key, value))",
            "                output_msg = u\"\\n\".join(obj_lines)",
            "            else:",
            "                output_msg = to_text(output, nonstring='simplerepr')",
            "",
            "            stdout_list.append(output_msg)",
            "",
            "        stdout = u\"\\r\\n\".join(stdout_list)",
            "        if len(self.host.ui.stdout) > 0:",
            "            stdout += u\"\\r\\n\" + u\"\".join(self.host.ui.stdout)",
            "",
            "        stderr_list = []",
            "        for error in pipeline.streams.error:",
            "            # the error record is not as fully fleshed out like we usually get",
            "            # in PS, we will manually create it here",
            "            error_msg = \"%s : %s\\r\\n\" \\",
            "                        \"%s\\r\\n\" \\",
            "                        \"    + CategoryInfo          : %s\\r\\n\" \\",
            "                        \"    + FullyQualifiedErrorId : %s\" \\",
            "                        % (error.command_name, str(error),",
            "                           error.invocation_position_message, error.message,",
            "                           error.fq_error)",
            "            stacktrace = error.script_stacktrace",
            "            if self._play_context.verbosity >= 3 and stacktrace is not None:",
            "                error_msg += \"\\r\\nStackTrace:\\r\\n%s\" % stacktrace",
            "            stderr_list.append(error_msg)",
            "",
            "        stderr = \"\\r\\n\".join(stderr_list)",
            "        if len(self.host.ui.stderr) > 0:",
            "            stderr += \"\\r\\n\" + \"\".join(self.host.ui.stderr)",
            "",
            "        display.vvvvv(\"PSRP RC: %d\" % rc, host=self._psrp_host)",
            "        display.vvvvv(\"PSRP STDOUT: %s\" % stdout, host=self._psrp_host)",
            "        display.vvvvv(\"PSRP STDERR: %s\" % stderr, host=self._psrp_host)",
            "",
            "        # reset the host back output back to defaults, needed if running",
            "        # multiple pipelines on the same RunspacePool",
            "        self.host.rc = 0",
            "        self.host.ui.stdout = []",
            "        self.host.ui.stderr = []",
            "",
            "        return rc, to_bytes(stdout, encoding='utf-8'), to_bytes(stderr, encoding='utf-8')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "lib/ansible/plugins/connection/winrm.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " import tempfile"
            },
            "2": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " import subprocess"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+import xml.etree.ElementTree as ET"
            },
            "4": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " HAVE_KERBEROS = False"
            },
            "6": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 532,
                "PatchRowcode": "         return (result.status_code, result.std_out, result.std_err)"
            },
            "8": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 533,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": 534,
                "PatchRowcode": "     def is_clixml(self, value):"
            },
            "10": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return value.startswith(b\"#< CLIXML\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+        return value.startswith(b\"#< CLIXML\\r\\n\")"
            },
            "12": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": 536,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": 537,
                "PatchRowcode": "     # hacky way to get just stdout- not always sure of doc framing here, so use with care"
            },
            "14": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "     def parse_clixml_stream(self, clixml_doc, stream_name='Error'):"
            },
            "15": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        clear_xml = clixml_doc.replace(b'#< CLIXML\\r\\n', b'')"
            },
            "16": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        doc = xmltodict.parse(clear_xml)"
            },
            "17": {
                "beforePatchRowNumber": 540,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lines = [l.get('#text', '').replace('_x000D__x000A_', '') for l in doc.get('Objs', {}).get('S', {}) if l.get('@S') == stream_name]"
            },
            "18": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return '\\r\\n'.join(lines)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+        clixml = ET.fromstring(clixml_doc.split(b\"\\r\\n\", 1)[-1])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 540,
                "PatchRowcode": "+        namespace_match = re.match(r'{(.*)}', clixml.tag)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+        namespace = \"{%s}\" % namespace_match.group(1) if namespace_match else \"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 542,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+        strings = clixml.findall(\"./%sS\" % namespace)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 544,
                "PatchRowcode": "+        lines = [e.text.replace('_x000D__x000A_', '') for e in strings if e.attrib.get('S') == stream_name]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 545,
                "PatchRowcode": "+        return to_bytes('\\r\\n'.join(lines))"
            },
            "26": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 546,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "     # FUTURE: determine buffer size at runtime via remote winrm config?"
            },
            "28": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "     def _put_file_stdin_iterator(self, in_path, out_path, buffer_size=250000):"
            }
        },
        "frontPatchFile": [
            "# (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = \"\"\"",
            "    author: Ansible Core Team",
            "    connection: winrm",
            "    short_description: Run tasks over Microsoft's WinRM",
            "    description:",
            "        - Run commands or put/fetch on a target via WinRM",
            "        - This plugin allows extra arguments to be passed that are supported by the protocol but not explicitly defined here.",
            "          They should take the form of variables declared with the following pattern `ansible_winrm_<option>`.",
            "    version_added: \"2.0\"",
            "    requirements:",
            "        - pywinrm (python library)",
            "    options:",
            "      # figure out more elegant 'delegation'",
            "      remote_addr:",
            "        description:",
            "            - Address of the windows machine",
            "        default: inventory_hostname",
            "        vars:",
            "            - name: ansible_host",
            "            - name: ansible_winrm_host",
            "      remote_user:",
            "        keywords:",
            "          - name: user",
            "          - name: remote_user",
            "        description:",
            "            - The user to log in as to the Windows machine",
            "        vars:",
            "            - name: ansible_user",
            "            - name: ansible_winrm_user",
            "      port:",
            "        description:",
            "            - port for winrm to connect on remote target",
            "            - The default is the https (5986) port, if using http it should be 5985",
            "        vars:",
            "          - name: ansible_port",
            "          - name: ansible_winrm_port",
            "        default: 5986",
            "        keywords:",
            "          - name: port",
            "        type: integer",
            "      scheme:",
            "        description:",
            "            - URI scheme to use",
            "            - If not set, then will default to C(https) or C(http) if I(port) is",
            "              C(5985).",
            "        choices: [http, https]",
            "        vars:",
            "          - name: ansible_winrm_scheme",
            "      path:",
            "        description: URI path to connect to",
            "        default: '/wsman'",
            "        vars:",
            "          - name: ansible_winrm_path",
            "      transport:",
            "        description:",
            "           - List of winrm transports to attempt to to use (ssl, plaintext, kerberos, etc)",
            "           - If None (the default) the plugin will try to automatically guess the correct list",
            "           - The choices avialable depend on your version of pywinrm",
            "        type: list",
            "        vars:",
            "          - name: ansible_winrm_transport",
            "      kerberos_command:",
            "        description: kerberos command to use to request a authentication ticket",
            "        default: kinit",
            "        vars:",
            "          - name: ansible_winrm_kinit_cmd",
            "      kerberos_mode:",
            "        description:",
            "            - kerberos usage mode.",
            "            - The managed option means Ansible will obtain kerberos ticket.",
            "            - While the manual one means a ticket must already have been obtained by the user.",
            "            - If having issues with Ansible freezing when trying to obtain the",
            "              Kerberos ticket, you can either set this to C(manual) and obtain",
            "              it outside Ansible or install C(pexpect) through pip and try",
            "              again.",
            "        choices: [managed, manual]",
            "        vars:",
            "          - name: ansible_winrm_kinit_mode",
            "      connection_timeout:",
            "        description:",
            "            - Sets the operation and read timeout settings for the WinRM",
            "              connection.",
            "            - Corresponds to the C(operation_timeout_sec) and",
            "              C(read_timeout_sec) args in pywinrm so avoid setting these vars",
            "              with this one.",
            "            - The default value is whatever is set in the installed version of",
            "              pywinrm.",
            "        vars:",
            "          - name: ansible_winrm_connection_timeout",
            "\"\"\"",
            "",
            "import base64",
            "import os",
            "import re",
            "import traceback",
            "import json",
            "import tempfile",
            "import subprocess",
            "",
            "HAVE_KERBEROS = False",
            "try:",
            "    import kerberos",
            "    HAVE_KERBEROS = True",
            "except ImportError:",
            "    pass",
            "",
            "from ansible.errors import AnsibleError, AnsibleConnectionFailure",
            "from ansible.errors import AnsibleFileNotFound",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.module_utils.six.moves.urllib.parse import urlunsplit",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.module_utils.six import binary_type, PY3",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.utils.hashing import secure_hash",
            "from ansible.utils.path import makedirs_safe",
            "from ansible.utils.display import Display",
            "",
            "# getargspec is deprecated in favour of getfullargspec in Python 3 but",
            "# getfullargspec is not available in Python 2",
            "if PY3:",
            "    from inspect import getfullargspec as getargspec",
            "else:",
            "    from inspect import getargspec",
            "",
            "try:",
            "    import winrm",
            "    from winrm import Response",
            "    from winrm.protocol import Protocol",
            "    HAS_WINRM = True",
            "except ImportError as e:",
            "    HAS_WINRM = False",
            "    WINRM_IMPORT_ERR = e",
            "",
            "try:",
            "    import xmltodict",
            "    HAS_XMLTODICT = True",
            "except ImportError as e:",
            "    HAS_XMLTODICT = False",
            "    XMLTODICT_IMPORT_ERR = e",
            "",
            "HAS_PEXPECT = False",
            "try:",
            "    import pexpect",
            "    # echo was added in pexpect 3.3+ which is newer than the RHEL package",
            "    # we can only use pexpect for kerb auth if echo is a valid kwarg",
            "    # https://github.com/ansible/ansible/issues/43462",
            "    if hasattr(pexpect, 'spawn'):",
            "        argspec = getargspec(pexpect.spawn.__init__)",
            "        if 'echo' in argspec.args:",
            "            HAS_PEXPECT = True",
            "except ImportError as e:",
            "    pass",
            "",
            "# used to try and parse the hostname and detect if IPv6 is being used",
            "try:",
            "    import ipaddress",
            "    HAS_IPADDRESS = True",
            "except ImportError:",
            "    HAS_IPADDRESS = False",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "    '''WinRM connections over HTTP/HTTPS.'''",
            "",
            "    transport = 'winrm'",
            "    module_implementation_preferences = ('.ps1', '.exe', '')",
            "    become_methods = ['runas']",
            "    allow_executable = False",
            "    has_pipelining = True",
            "    allow_extras = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "",
            "        self.always_pipeline_modules = True",
            "        self.has_native_async = True",
            "",
            "        self.protocol = None",
            "        self.shell_id = None",
            "        self.delegate = None",
            "        self._shell_type = 'powershell'",
            "",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "",
            "    def _build_winrm_kwargs(self):",
            "        # this used to be in set_options, as win_reboot needs to be able to",
            "        # override the conn timeout, we need to be able to build the args",
            "        # after setting individual options. This is called by _connect before",
            "        # starting the WinRM connection",
            "        self._winrm_host = self.get_option('remote_addr')",
            "        self._winrm_user = self.get_option('remote_user')",
            "        self._winrm_pass = self._play_context.password",
            "",
            "        self._become_method = self._play_context.become_method",
            "        self._become_user = self._play_context.become_user",
            "        self._become_pass = self._play_context.become_pass",
            "",
            "        self._winrm_port = self.get_option('port')",
            "",
            "        self._winrm_scheme = self.get_option('scheme')",
            "        # old behaviour, scheme should default to http if not set and the port",
            "        # is 5985 otherwise https",
            "        if self._winrm_scheme is None:",
            "            self._winrm_scheme = 'http' if self._winrm_port == 5985 else 'https'",
            "",
            "        self._winrm_path = self.get_option('path')",
            "        self._kinit_cmd = self.get_option('kerberos_command')",
            "        self._winrm_transport = self.get_option('transport')",
            "        self._winrm_connection_timeout = self.get_option('connection_timeout')",
            "",
            "        if hasattr(winrm, 'FEATURE_SUPPORTED_AUTHTYPES'):",
            "            self._winrm_supported_authtypes = set(winrm.FEATURE_SUPPORTED_AUTHTYPES)",
            "        else:",
            "            # for legacy versions of pywinrm, use the values we know are supported",
            "            self._winrm_supported_authtypes = set(['plaintext', 'ssl', 'kerberos'])",
            "",
            "        # calculate transport if needed",
            "        if self._winrm_transport is None or self._winrm_transport[0] is None:",
            "            # TODO: figure out what we want to do with auto-transport selection in the face of NTLM/Kerb/CredSSP/Cert/Basic",
            "            transport_selector = ['ssl'] if self._winrm_scheme == 'https' else ['plaintext']",
            "",
            "            if HAVE_KERBEROS and ((self._winrm_user and '@' in self._winrm_user)):",
            "                self._winrm_transport = ['kerberos'] + transport_selector",
            "            else:",
            "                self._winrm_transport = transport_selector",
            "",
            "        unsupported_transports = set(self._winrm_transport).difference(self._winrm_supported_authtypes)",
            "",
            "        if unsupported_transports:",
            "            raise AnsibleError('The installed version of WinRM does not support transport(s) %s' %",
            "                               to_native(list(unsupported_transports), nonstring='simplerepr'))",
            "",
            "        # if kerberos is among our transports and there's a password specified, we're managing the tickets",
            "        kinit_mode = self.get_option('kerberos_mode')",
            "        if kinit_mode is None:",
            "            # HACK: ideally, remove multi-transport stuff",
            "            self._kerb_managed = \"kerberos\" in self._winrm_transport and (self._winrm_pass is not None and self._winrm_pass != \"\")",
            "        elif kinit_mode == \"managed\":",
            "            self._kerb_managed = True",
            "        elif kinit_mode == \"manual\":",
            "            self._kerb_managed = False",
            "",
            "        # arg names we're going passing directly",
            "        internal_kwarg_mask = set(['self', 'endpoint', 'transport', 'username', 'password', 'scheme', 'path', 'kinit_mode', 'kinit_cmd'])",
            "",
            "        self._winrm_kwargs = dict(username=self._winrm_user, password=self._winrm_pass)",
            "        argspec = getargspec(Protocol.__init__)",
            "        supported_winrm_args = set(argspec.args)",
            "        supported_winrm_args.update(internal_kwarg_mask)",
            "        passed_winrm_args = set([v.replace('ansible_winrm_', '') for v in self.get_option('_extras')])",
            "        unsupported_args = passed_winrm_args.difference(supported_winrm_args)",
            "",
            "        # warn for kwargs unsupported by the installed version of pywinrm",
            "        for arg in unsupported_args:",
            "            display.warning(\"ansible_winrm_{0} unsupported by pywinrm (is an up-to-date version of pywinrm installed?)\".format(arg))",
            "",
            "        # pass through matching extras, excluding the list we want to treat specially",
            "        for arg in passed_winrm_args.difference(internal_kwarg_mask).intersection(supported_winrm_args):",
            "            self._winrm_kwargs[arg] = self.get_option('_extras')['ansible_winrm_%s' % arg]",
            "",
            "    # Until pykerberos has enough goodies to implement a rudimentary kinit/klist, simplest way is to let each connection",
            "    # auth itself with a private CCACHE.",
            "    def _kerb_auth(self, principal, password):",
            "        if password is None:",
            "            password = \"\"",
            "",
            "        self._kerb_ccache = tempfile.NamedTemporaryFile()",
            "        display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)",
            "        krb5ccname = \"FILE:%s\" % self._kerb_ccache.name",
            "        os.environ[\"KRB5CCNAME\"] = krb5ccname",
            "        krb5env = dict(KRB5CCNAME=krb5ccname)",
            "",
            "        # stores various flags to call with kinit, we currently only use this",
            "        # to set -f so we can get a forward-able ticket (cred delegation)",
            "        kinit_flags = []",
            "        if boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):",
            "            kinit_flags.append('-f')",
            "",
            "        kinit_cmdline = [self._kinit_cmd]",
            "        kinit_cmdline.extend(kinit_flags)",
            "        kinit_cmdline.append(principal)",
            "",
            "        # pexpect runs the process in its own pty so it can correctly send",
            "        # the password as input even on MacOS which blocks subprocess from",
            "        # doing so. Unfortunately it is not available on the built in Python",
            "        # so we can only use it if someone has installed it",
            "        if HAS_PEXPECT:",
            "            proc_mechanism = \"pexpect\"",
            "            command = kinit_cmdline.pop(0)",
            "            password = to_text(password, encoding='utf-8',",
            "                               errors='surrogate_or_strict')",
            "",
            "            display.vvvv(\"calling kinit with pexpect for principal %s\"",
            "                         % principal)",
            "            try:",
            "                child = pexpect.spawn(command, kinit_cmdline, timeout=60,",
            "                                      env=krb5env, echo=False)",
            "            except pexpect.ExceptionPexpect as err:",
            "                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\",
            "                          \"'%s': %s\" % (command, to_native(err))",
            "                raise AnsibleConnectionFailure(err_msg)",
            "",
            "            try:",
            "                child.expect(\".*:\")",
            "                child.sendline(password)",
            "            except OSError as err:",
            "                # child exited before the pass was sent, Ansible will raise",
            "                # error based on the rc below, just display the error here",
            "                display.vvvv(\"kinit with pexpect raised OSError: %s\"",
            "                             % to_native(err))",
            "",
            "            # technically this is the stdout + stderr but to match the",
            "            # subprocess error checking behaviour, we will call it stderr",
            "            stderr = child.read()",
            "            child.wait()",
            "            rc = child.exitstatus",
            "        else:",
            "            proc_mechanism = \"subprocess\"",
            "            password = to_bytes(password, encoding='utf-8',",
            "                                errors='surrogate_or_strict')",
            "",
            "            display.vvvv(\"calling kinit with subprocess for principal %s\"",
            "                         % principal)",
            "            try:",
            "                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,",
            "                                     stdout=subprocess.PIPE,",
            "                                     stderr=subprocess.PIPE,",
            "                                     env=krb5env)",
            "",
            "            except OSError as err:",
            "                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\",
            "                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))",
            "                raise AnsibleConnectionFailure(err_msg)",
            "",
            "            stdout, stderr = p.communicate(password + b'\\n')",
            "            rc = p.returncode != 0",
            "",
            "        if rc != 0:",
            "            # one last attempt at making sure the password does not exist",
            "            # in the output",
            "            exp_msg = to_native(stderr.strip())",
            "            exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")",
            "",
            "            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\",
            "                      % (principal, proc_mechanism, exp_msg)",
            "            raise AnsibleConnectionFailure(err_msg)",
            "",
            "        display.vvvvv(\"kinit succeeded for principal %s\" % principal)",
            "",
            "    def _winrm_connect(self):",
            "        '''",
            "        Establish a WinRM connection over HTTP/HTTPS.",
            "        '''",
            "        display.vvv(\"ESTABLISH WINRM CONNECTION FOR USER: %s on PORT %s TO %s\" %",
            "                    (self._winrm_user, self._winrm_port, self._winrm_host), host=self._winrm_host)",
            "",
            "        winrm_host = self._winrm_host",
            "        if HAS_IPADDRESS:",
            "            display.vvvv(\"checking if winrm_host %s is an IPv6 address\" % winrm_host)",
            "            try:",
            "                ipaddress.IPv6Address(winrm_host)",
            "            except ipaddress.AddressValueError:",
            "                pass",
            "            else:",
            "                winrm_host = \"[%s]\" % winrm_host",
            "",
            "        netloc = '%s:%d' % (winrm_host, self._winrm_port)",
            "        endpoint = urlunsplit((self._winrm_scheme, netloc, self._winrm_path, '', ''))",
            "        errors = []",
            "        for transport in self._winrm_transport:",
            "            if transport == 'kerberos':",
            "                if not HAVE_KERBEROS:",
            "                    errors.append('kerberos: the python kerberos library is not installed')",
            "                    continue",
            "                if self._kerb_managed:",
            "                    self._kerb_auth(self._winrm_user, self._winrm_pass)",
            "            display.vvvvv('WINRM CONNECT: transport=%s endpoint=%s' % (transport, endpoint), host=self._winrm_host)",
            "            try:",
            "                winrm_kwargs = self._winrm_kwargs.copy()",
            "                if self._winrm_connection_timeout:",
            "                    winrm_kwargs['operation_timeout_sec'] = self._winrm_connection_timeout",
            "                    winrm_kwargs['read_timeout_sec'] = self._winrm_connection_timeout + 1",
            "                protocol = Protocol(endpoint, transport=transport, **winrm_kwargs)",
            "",
            "                # open the shell from connect so we know we're able to talk to the server",
            "                if not self.shell_id:",
            "                    self.shell_id = protocol.open_shell(codepage=65001)  # UTF-8",
            "                    display.vvvvv('WINRM OPEN SHELL: %s' % self.shell_id, host=self._winrm_host)",
            "",
            "                return protocol",
            "            except Exception as e:",
            "                err_msg = to_text(e).strip()",
            "                if re.search(to_text(r'Operation\\s+?timed\\s+?out'), err_msg, re.I):",
            "                    raise AnsibleError('the connection attempt timed out')",
            "                m = re.search(to_text(r'Code\\s+?(\\d{3})'), err_msg)",
            "                if m:",
            "                    code = int(m.groups()[0])",
            "                    if code == 401:",
            "                        err_msg = 'the specified credentials were rejected by the server'",
            "                    elif code == 411:",
            "                        return protocol",
            "                errors.append(u'%s: %s' % (transport, err_msg))",
            "                display.vvvvv(u'WINRM CONNECTION ERROR: %s\\n%s' % (err_msg, to_text(traceback.format_exc())), host=self._winrm_host)",
            "        if errors:",
            "            raise AnsibleConnectionFailure(', '.join(map(to_native, errors)))",
            "        else:",
            "            raise AnsibleError('No transport found for WinRM connection')",
            "",
            "    def _winrm_send_input(self, protocol, shell_id, command_id, stdin, eof=False):",
            "        rq = {'env:Envelope': protocol._get_soap_header(",
            "            resource_uri='http://schemas.microsoft.com/wbem/wsman/1/windows/shell/cmd',",
            "            action='http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Send',",
            "            shell_id=shell_id)}",
            "        stream = rq['env:Envelope'].setdefault('env:Body', {}).setdefault('rsp:Send', {})\\",
            "            .setdefault('rsp:Stream', {})",
            "        stream['@Name'] = 'stdin'",
            "        stream['@CommandId'] = command_id",
            "        stream['#text'] = base64.b64encode(to_bytes(stdin))",
            "        if eof:",
            "            stream['@End'] = 'true'",
            "        protocol.send_message(xmltodict.unparse(rq))",
            "",
            "    def _winrm_exec(self, command, args=(), from_exec=False, stdin_iterator=None):",
            "        if not self.protocol:",
            "            self.protocol = self._winrm_connect()",
            "            self._connected = True",
            "        if from_exec:",
            "            display.vvvvv(\"WINRM EXEC %r %r\" % (command, args), host=self._winrm_host)",
            "        else:",
            "            display.vvvvvv(\"WINRM EXEC %r %r\" % (command, args), host=self._winrm_host)",
            "        command_id = None",
            "        try:",
            "            stdin_push_failed = False",
            "            command_id = self.protocol.run_command(self.shell_id, to_bytes(command), map(to_bytes, args), console_mode_stdin=(stdin_iterator is None))",
            "",
            "            try:",
            "                if stdin_iterator:",
            "                    for (data, is_last) in stdin_iterator:",
            "                        self._winrm_send_input(self.protocol, self.shell_id, command_id, data, eof=is_last)",
            "",
            "            except Exception as ex:",
            "                display.warning(\"FATAL ERROR DURING FILE TRANSFER: %s\" % to_text(ex))",
            "                stdin_push_failed = True",
            "",
            "            # NB: this can hang if the receiver is still running (eg, network failed a Send request but the server's still happy).",
            "            # FUTURE: Consider adding pywinrm status check/abort operations to see if the target is still running after a failure.",
            "            resptuple = self.protocol.get_command_output(self.shell_id, command_id)",
            "            # ensure stdout/stderr are text for py3",
            "            # FUTURE: this should probably be done internally by pywinrm",
            "            response = Response(tuple(to_text(v) if isinstance(v, binary_type) else v for v in resptuple))",
            "",
            "            # TODO: check result from response and set stdin_push_failed if we have nonzero",
            "            if from_exec:",
            "                display.vvvvv('WINRM RESULT %r' % to_text(response), host=self._winrm_host)",
            "            else:",
            "                display.vvvvvv('WINRM RESULT %r' % to_text(response), host=self._winrm_host)",
            "",
            "            display.vvvvvv('WINRM STDOUT %s' % to_text(response.std_out), host=self._winrm_host)",
            "            display.vvvvvv('WINRM STDERR %s' % to_text(response.std_err), host=self._winrm_host)",
            "",
            "            if stdin_push_failed:",
            "                stderr = to_bytes(response.std_err, encoding='utf-8')",
            "                if self.is_clixml(stderr):",
            "                    stderr = self.parse_clixml_stream(stderr)",
            "",
            "                raise AnsibleError('winrm send_input failed; \\nstdout: %s\\nstderr %s' % (to_native(response.std_out), to_native(stderr)))",
            "",
            "            return response",
            "        finally:",
            "            if command_id:",
            "                self.protocol.cleanup_command(self.shell_id, command_id)",
            "",
            "    def _connect(self):",
            "",
            "        if not HAS_WINRM:",
            "            raise AnsibleError(\"winrm or requests is not installed: %s\" % to_native(WINRM_IMPORT_ERR))",
            "        elif not HAS_XMLTODICT:",
            "            raise AnsibleError(\"xmltodict is not installed: %s\" % to_native(XMLTODICT_IMPORT_ERR))",
            "",
            "        super(Connection, self)._connect()",
            "        if not self.protocol:",
            "            self._build_winrm_kwargs()  # build the kwargs from the options set",
            "            self.protocol = self._winrm_connect()",
            "            self._connected = True",
            "        return self",
            "",
            "    def reset(self):",
            "        self.protocol = None",
            "        self.shell_id = None",
            "        self._connect()",
            "",
            "    def _wrapper_payload_stream(self, payload, buffer_size=200000):",
            "        payload_bytes = to_bytes(payload)",
            "        byte_count = len(payload_bytes)",
            "        for i in range(0, byte_count, buffer_size):",
            "            yield payload_bytes[i:i + buffer_size], i + buffer_size >= byte_count",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        super(Connection, self).exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "        cmd_parts = self._shell._encode_script(cmd, as_list=True, strict_mode=False, preserve_rc=False)",
            "",
            "        # TODO: display something meaningful here",
            "        display.vvv(\"EXEC (via pipeline wrapper)\")",
            "",
            "        stdin_iterator = None",
            "",
            "        if in_data:",
            "            stdin_iterator = self._wrapper_payload_stream(in_data)",
            "",
            "        result = self._winrm_exec(cmd_parts[0], cmd_parts[1:], from_exec=True, stdin_iterator=stdin_iterator)",
            "",
            "        result.std_out = to_bytes(result.std_out)",
            "        result.std_err = to_bytes(result.std_err)",
            "",
            "        # parse just stderr from CLIXML output",
            "        if self.is_clixml(result.std_err):",
            "            try:",
            "                result.std_err = self.parse_clixml_stream(result.std_err)",
            "            except Exception:",
            "                # unsure if we're guaranteed a valid xml doc- use raw output in case of error",
            "                pass",
            "",
            "        return (result.status_code, result.std_out, result.std_err)",
            "",
            "    def is_clixml(self, value):",
            "        return value.startswith(b\"#< CLIXML\")",
            "",
            "    # hacky way to get just stdout- not always sure of doc framing here, so use with care",
            "    def parse_clixml_stream(self, clixml_doc, stream_name='Error'):",
            "        clear_xml = clixml_doc.replace(b'#< CLIXML\\r\\n', b'')",
            "        doc = xmltodict.parse(clear_xml)",
            "        lines = [l.get('#text', '').replace('_x000D__x000A_', '') for l in doc.get('Objs', {}).get('S', {}) if l.get('@S') == stream_name]",
            "        return '\\r\\n'.join(lines)",
            "",
            "    # FUTURE: determine buffer size at runtime via remote winrm config?",
            "    def _put_file_stdin_iterator(self, in_path, out_path, buffer_size=250000):",
            "        in_size = os.path.getsize(to_bytes(in_path, errors='surrogate_or_strict'))",
            "        offset = 0",
            "        with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file:",
            "            for out_data in iter((lambda: in_file.read(buffer_size)), b''):",
            "                offset += len(out_data)",
            "                self._display.vvvvv('WINRM PUT \"%s\" to \"%s\" (offset=%d size=%d)' % (in_path, out_path, offset, len(out_data)), host=self._winrm_host)",
            "                # yes, we're double-encoding over the wire in this case- we want to ensure that the data shipped to the end PS pipeline is still b64-encoded",
            "                b64_data = base64.b64encode(out_data) + b'\\r\\n'",
            "                # cough up the data, as well as an indicator if this is the last chunk so winrm_send knows to set the End signal",
            "                yield b64_data, (in_file.tell() == in_size)",
            "",
            "            if offset == 0:  # empty file, return an empty buffer + eof to close it",
            "                yield \"\", True",
            "",
            "    def put_file(self, in_path, out_path):",
            "        super(Connection, self).put_file(in_path, out_path)",
            "        out_path = self._shell._unquote(out_path)",
            "        display.vvv('PUT \"%s\" TO \"%s\"' % (in_path, out_path), host=self._winrm_host)",
            "        if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):",
            "            raise AnsibleFileNotFound('file or module does not exist: \"%s\"' % to_native(in_path))",
            "",
            "        script_template = u'''",
            "            begin {{",
            "                $path = '{0}'",
            "",
            "                $DebugPreference = \"Continue\"",
            "                $ErrorActionPreference = \"Stop\"",
            "                Set-StrictMode -Version 2",
            "",
            "                $fd = [System.IO.File]::Create($path)",
            "",
            "                $sha1 = [System.Security.Cryptography.SHA1CryptoServiceProvider]::Create()",
            "",
            "                $bytes = @() #initialize for empty file case",
            "            }}",
            "            process {{",
            "               $bytes = [System.Convert]::FromBase64String($input)",
            "               $sha1.TransformBlock($bytes, 0, $bytes.Length, $bytes, 0) | Out-Null",
            "               $fd.Write($bytes, 0, $bytes.Length)",
            "            }}",
            "            end {{",
            "                $sha1.TransformFinalBlock($bytes, 0, 0) | Out-Null",
            "",
            "                $hash = [System.BitConverter]::ToString($sha1.Hash).Replace(\"-\", \"\").ToLowerInvariant()",
            "",
            "                $fd.Close()",
            "",
            "                Write-Output \"{{\"\"sha1\"\":\"\"$hash\"\"}}\"",
            "            }}",
            "        '''",
            "",
            "        script = script_template.format(self._shell._escape(out_path))",
            "        cmd_parts = self._shell._encode_script(script, as_list=True, strict_mode=False, preserve_rc=False)",
            "",
            "        result = self._winrm_exec(cmd_parts[0], cmd_parts[1:], stdin_iterator=self._put_file_stdin_iterator(in_path, out_path))",
            "        # TODO: improve error handling",
            "        if result.status_code != 0:",
            "            raise AnsibleError(to_native(result.std_err))",
            "",
            "        put_output = json.loads(result.std_out)",
            "        remote_sha1 = put_output.get(\"sha1\")",
            "",
            "        if not remote_sha1:",
            "            raise AnsibleError(\"Remote sha1 was not returned\")",
            "",
            "        local_sha1 = secure_hash(in_path)",
            "",
            "        if not remote_sha1 == local_sha1:",
            "            raise AnsibleError(\"Remote sha1 hash {0} does not match local hash {1}\".format(to_native(remote_sha1), to_native(local_sha1)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "        in_path = self._shell._unquote(in_path)",
            "        out_path = out_path.replace('\\\\', '/')",
            "        display.vvv('FETCH \"%s\" TO \"%s\"' % (in_path, out_path), host=self._winrm_host)",
            "        buffer_size = 2**19  # 0.5MB chunks",
            "        makedirs_safe(os.path.dirname(out_path))",
            "        out_file = None",
            "        try:",
            "            offset = 0",
            "            while True:",
            "                try:",
            "                    script = '''",
            "                        $path = \"%(path)s\"",
            "                        If (Test-Path -Path $path -PathType Leaf)",
            "                        {",
            "                            $buffer_size = %(buffer_size)d",
            "                            $offset = %(offset)d",
            "",
            "                            $stream = New-Object -TypeName IO.FileStream($path, [IO.FileMode]::Open, [IO.FileAccess]::Read, [IO.FileShare]::ReadWrite)",
            "                            $stream.Seek($offset, [System.IO.SeekOrigin]::Begin) > $null",
            "                            $buffer = New-Object -TypeName byte[] $buffer_size",
            "                            $bytes_read = $stream.Read($buffer, 0, $buffer_size)",
            "                            if ($bytes_read -gt 0) {",
            "                                $bytes = $buffer[0..($bytes_read - 1)]",
            "                                [System.Convert]::ToBase64String($bytes)",
            "                            }",
            "                            $stream.Close() > $null",
            "                        }",
            "                        ElseIf (Test-Path -Path $path -PathType Container)",
            "                        {",
            "                            Write-Host \"[DIR]\";",
            "                        }",
            "                        Else",
            "                        {",
            "                            Write-Error \"$path does not exist\";",
            "                            Exit 1;",
            "                        }",
            "                    ''' % dict(buffer_size=buffer_size, path=self._shell._escape(in_path), offset=offset)",
            "                    display.vvvvv('WINRM FETCH \"%s\" to \"%s\" (offset=%d)' % (in_path, out_path, offset), host=self._winrm_host)",
            "                    cmd_parts = self._shell._encode_script(script, as_list=True, preserve_rc=False)",
            "                    result = self._winrm_exec(cmd_parts[0], cmd_parts[1:])",
            "                    if result.status_code != 0:",
            "                        raise IOError(to_native(result.std_err))",
            "                    if result.std_out.strip() == '[DIR]':",
            "                        data = None",
            "                    else:",
            "                        data = base64.b64decode(result.std_out.strip())",
            "                    if data is None:",
            "                        makedirs_safe(out_path)",
            "                        break",
            "                    else:",
            "                        if not out_file:",
            "                            # If out_path is a directory and we're expecting a file, bail out now.",
            "                            if os.path.isdir(to_bytes(out_path, errors='surrogate_or_strict')):",
            "                                break",
            "                            out_file = open(to_bytes(out_path, errors='surrogate_or_strict'), 'wb')",
            "                        out_file.write(data)",
            "                        if len(data) < buffer_size:",
            "                            break",
            "                        offset += len(data)",
            "                except Exception:",
            "                    traceback.print_exc()",
            "                    raise AnsibleError('failed to transfer file to \"%s\"' % to_native(out_path))",
            "        finally:",
            "            if out_file:",
            "                out_file.close()",
            "",
            "    def close(self):",
            "        if self.protocol and self.shell_id:",
            "            display.vvvvv('WINRM CLOSE SHELL: %s' % self.shell_id, host=self._winrm_host)",
            "            self.protocol.close_shell(self.shell_id)",
            "        self.shell_id = None",
            "        self.protocol = None",
            "        self._connected = False"
        ],
        "afterPatchFile": [
            "# (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = \"\"\"",
            "    author: Ansible Core Team",
            "    connection: winrm",
            "    short_description: Run tasks over Microsoft's WinRM",
            "    description:",
            "        - Run commands or put/fetch on a target via WinRM",
            "        - This plugin allows extra arguments to be passed that are supported by the protocol but not explicitly defined here.",
            "          They should take the form of variables declared with the following pattern `ansible_winrm_<option>`.",
            "    version_added: \"2.0\"",
            "    requirements:",
            "        - pywinrm (python library)",
            "    options:",
            "      # figure out more elegant 'delegation'",
            "      remote_addr:",
            "        description:",
            "            - Address of the windows machine",
            "        default: inventory_hostname",
            "        vars:",
            "            - name: ansible_host",
            "            - name: ansible_winrm_host",
            "      remote_user:",
            "        keywords:",
            "          - name: user",
            "          - name: remote_user",
            "        description:",
            "            - The user to log in as to the Windows machine",
            "        vars:",
            "            - name: ansible_user",
            "            - name: ansible_winrm_user",
            "      port:",
            "        description:",
            "            - port for winrm to connect on remote target",
            "            - The default is the https (5986) port, if using http it should be 5985",
            "        vars:",
            "          - name: ansible_port",
            "          - name: ansible_winrm_port",
            "        default: 5986",
            "        keywords:",
            "          - name: port",
            "        type: integer",
            "      scheme:",
            "        description:",
            "            - URI scheme to use",
            "            - If not set, then will default to C(https) or C(http) if I(port) is",
            "              C(5985).",
            "        choices: [http, https]",
            "        vars:",
            "          - name: ansible_winrm_scheme",
            "      path:",
            "        description: URI path to connect to",
            "        default: '/wsman'",
            "        vars:",
            "          - name: ansible_winrm_path",
            "      transport:",
            "        description:",
            "           - List of winrm transports to attempt to to use (ssl, plaintext, kerberos, etc)",
            "           - If None (the default) the plugin will try to automatically guess the correct list",
            "           - The choices avialable depend on your version of pywinrm",
            "        type: list",
            "        vars:",
            "          - name: ansible_winrm_transport",
            "      kerberos_command:",
            "        description: kerberos command to use to request a authentication ticket",
            "        default: kinit",
            "        vars:",
            "          - name: ansible_winrm_kinit_cmd",
            "      kerberos_mode:",
            "        description:",
            "            - kerberos usage mode.",
            "            - The managed option means Ansible will obtain kerberos ticket.",
            "            - While the manual one means a ticket must already have been obtained by the user.",
            "            - If having issues with Ansible freezing when trying to obtain the",
            "              Kerberos ticket, you can either set this to C(manual) and obtain",
            "              it outside Ansible or install C(pexpect) through pip and try",
            "              again.",
            "        choices: [managed, manual]",
            "        vars:",
            "          - name: ansible_winrm_kinit_mode",
            "      connection_timeout:",
            "        description:",
            "            - Sets the operation and read timeout settings for the WinRM",
            "              connection.",
            "            - Corresponds to the C(operation_timeout_sec) and",
            "              C(read_timeout_sec) args in pywinrm so avoid setting these vars",
            "              with this one.",
            "            - The default value is whatever is set in the installed version of",
            "              pywinrm.",
            "        vars:",
            "          - name: ansible_winrm_connection_timeout",
            "\"\"\"",
            "",
            "import base64",
            "import os",
            "import re",
            "import traceback",
            "import json",
            "import tempfile",
            "import subprocess",
            "import xml.etree.ElementTree as ET",
            "",
            "HAVE_KERBEROS = False",
            "try:",
            "    import kerberos",
            "    HAVE_KERBEROS = True",
            "except ImportError:",
            "    pass",
            "",
            "from ansible.errors import AnsibleError, AnsibleConnectionFailure",
            "from ansible.errors import AnsibleFileNotFound",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.module_utils.six.moves.urllib.parse import urlunsplit",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.module_utils.six import binary_type, PY3",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.utils.hashing import secure_hash",
            "from ansible.utils.path import makedirs_safe",
            "from ansible.utils.display import Display",
            "",
            "# getargspec is deprecated in favour of getfullargspec in Python 3 but",
            "# getfullargspec is not available in Python 2",
            "if PY3:",
            "    from inspect import getfullargspec as getargspec",
            "else:",
            "    from inspect import getargspec",
            "",
            "try:",
            "    import winrm",
            "    from winrm import Response",
            "    from winrm.protocol import Protocol",
            "    HAS_WINRM = True",
            "except ImportError as e:",
            "    HAS_WINRM = False",
            "    WINRM_IMPORT_ERR = e",
            "",
            "try:",
            "    import xmltodict",
            "    HAS_XMLTODICT = True",
            "except ImportError as e:",
            "    HAS_XMLTODICT = False",
            "    XMLTODICT_IMPORT_ERR = e",
            "",
            "HAS_PEXPECT = False",
            "try:",
            "    import pexpect",
            "    # echo was added in pexpect 3.3+ which is newer than the RHEL package",
            "    # we can only use pexpect for kerb auth if echo is a valid kwarg",
            "    # https://github.com/ansible/ansible/issues/43462",
            "    if hasattr(pexpect, 'spawn'):",
            "        argspec = getargspec(pexpect.spawn.__init__)",
            "        if 'echo' in argspec.args:",
            "            HAS_PEXPECT = True",
            "except ImportError as e:",
            "    pass",
            "",
            "# used to try and parse the hostname and detect if IPv6 is being used",
            "try:",
            "    import ipaddress",
            "    HAS_IPADDRESS = True",
            "except ImportError:",
            "    HAS_IPADDRESS = False",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "    '''WinRM connections over HTTP/HTTPS.'''",
            "",
            "    transport = 'winrm'",
            "    module_implementation_preferences = ('.ps1', '.exe', '')",
            "    become_methods = ['runas']",
            "    allow_executable = False",
            "    has_pipelining = True",
            "    allow_extras = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "",
            "        self.always_pipeline_modules = True",
            "        self.has_native_async = True",
            "",
            "        self.protocol = None",
            "        self.shell_id = None",
            "        self.delegate = None",
            "        self._shell_type = 'powershell'",
            "",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "",
            "    def _build_winrm_kwargs(self):",
            "        # this used to be in set_options, as win_reboot needs to be able to",
            "        # override the conn timeout, we need to be able to build the args",
            "        # after setting individual options. This is called by _connect before",
            "        # starting the WinRM connection",
            "        self._winrm_host = self.get_option('remote_addr')",
            "        self._winrm_user = self.get_option('remote_user')",
            "        self._winrm_pass = self._play_context.password",
            "",
            "        self._become_method = self._play_context.become_method",
            "        self._become_user = self._play_context.become_user",
            "        self._become_pass = self._play_context.become_pass",
            "",
            "        self._winrm_port = self.get_option('port')",
            "",
            "        self._winrm_scheme = self.get_option('scheme')",
            "        # old behaviour, scheme should default to http if not set and the port",
            "        # is 5985 otherwise https",
            "        if self._winrm_scheme is None:",
            "            self._winrm_scheme = 'http' if self._winrm_port == 5985 else 'https'",
            "",
            "        self._winrm_path = self.get_option('path')",
            "        self._kinit_cmd = self.get_option('kerberos_command')",
            "        self._winrm_transport = self.get_option('transport')",
            "        self._winrm_connection_timeout = self.get_option('connection_timeout')",
            "",
            "        if hasattr(winrm, 'FEATURE_SUPPORTED_AUTHTYPES'):",
            "            self._winrm_supported_authtypes = set(winrm.FEATURE_SUPPORTED_AUTHTYPES)",
            "        else:",
            "            # for legacy versions of pywinrm, use the values we know are supported",
            "            self._winrm_supported_authtypes = set(['plaintext', 'ssl', 'kerberos'])",
            "",
            "        # calculate transport if needed",
            "        if self._winrm_transport is None or self._winrm_transport[0] is None:",
            "            # TODO: figure out what we want to do with auto-transport selection in the face of NTLM/Kerb/CredSSP/Cert/Basic",
            "            transport_selector = ['ssl'] if self._winrm_scheme == 'https' else ['plaintext']",
            "",
            "            if HAVE_KERBEROS and ((self._winrm_user and '@' in self._winrm_user)):",
            "                self._winrm_transport = ['kerberos'] + transport_selector",
            "            else:",
            "                self._winrm_transport = transport_selector",
            "",
            "        unsupported_transports = set(self._winrm_transport).difference(self._winrm_supported_authtypes)",
            "",
            "        if unsupported_transports:",
            "            raise AnsibleError('The installed version of WinRM does not support transport(s) %s' %",
            "                               to_native(list(unsupported_transports), nonstring='simplerepr'))",
            "",
            "        # if kerberos is among our transports and there's a password specified, we're managing the tickets",
            "        kinit_mode = self.get_option('kerberos_mode')",
            "        if kinit_mode is None:",
            "            # HACK: ideally, remove multi-transport stuff",
            "            self._kerb_managed = \"kerberos\" in self._winrm_transport and (self._winrm_pass is not None and self._winrm_pass != \"\")",
            "        elif kinit_mode == \"managed\":",
            "            self._kerb_managed = True",
            "        elif kinit_mode == \"manual\":",
            "            self._kerb_managed = False",
            "",
            "        # arg names we're going passing directly",
            "        internal_kwarg_mask = set(['self', 'endpoint', 'transport', 'username', 'password', 'scheme', 'path', 'kinit_mode', 'kinit_cmd'])",
            "",
            "        self._winrm_kwargs = dict(username=self._winrm_user, password=self._winrm_pass)",
            "        argspec = getargspec(Protocol.__init__)",
            "        supported_winrm_args = set(argspec.args)",
            "        supported_winrm_args.update(internal_kwarg_mask)",
            "        passed_winrm_args = set([v.replace('ansible_winrm_', '') for v in self.get_option('_extras')])",
            "        unsupported_args = passed_winrm_args.difference(supported_winrm_args)",
            "",
            "        # warn for kwargs unsupported by the installed version of pywinrm",
            "        for arg in unsupported_args:",
            "            display.warning(\"ansible_winrm_{0} unsupported by pywinrm (is an up-to-date version of pywinrm installed?)\".format(arg))",
            "",
            "        # pass through matching extras, excluding the list we want to treat specially",
            "        for arg in passed_winrm_args.difference(internal_kwarg_mask).intersection(supported_winrm_args):",
            "            self._winrm_kwargs[arg] = self.get_option('_extras')['ansible_winrm_%s' % arg]",
            "",
            "    # Until pykerberos has enough goodies to implement a rudimentary kinit/klist, simplest way is to let each connection",
            "    # auth itself with a private CCACHE.",
            "    def _kerb_auth(self, principal, password):",
            "        if password is None:",
            "            password = \"\"",
            "",
            "        self._kerb_ccache = tempfile.NamedTemporaryFile()",
            "        display.vvvvv(\"creating Kerberos CC at %s\" % self._kerb_ccache.name)",
            "        krb5ccname = \"FILE:%s\" % self._kerb_ccache.name",
            "        os.environ[\"KRB5CCNAME\"] = krb5ccname",
            "        krb5env = dict(KRB5CCNAME=krb5ccname)",
            "",
            "        # stores various flags to call with kinit, we currently only use this",
            "        # to set -f so we can get a forward-able ticket (cred delegation)",
            "        kinit_flags = []",
            "        if boolean(self.get_option('_extras').get('ansible_winrm_kerberos_delegation', False)):",
            "            kinit_flags.append('-f')",
            "",
            "        kinit_cmdline = [self._kinit_cmd]",
            "        kinit_cmdline.extend(kinit_flags)",
            "        kinit_cmdline.append(principal)",
            "",
            "        # pexpect runs the process in its own pty so it can correctly send",
            "        # the password as input even on MacOS which blocks subprocess from",
            "        # doing so. Unfortunately it is not available on the built in Python",
            "        # so we can only use it if someone has installed it",
            "        if HAS_PEXPECT:",
            "            proc_mechanism = \"pexpect\"",
            "            command = kinit_cmdline.pop(0)",
            "            password = to_text(password, encoding='utf-8',",
            "                               errors='surrogate_or_strict')",
            "",
            "            display.vvvv(\"calling kinit with pexpect for principal %s\"",
            "                         % principal)",
            "            try:",
            "                child = pexpect.spawn(command, kinit_cmdline, timeout=60,",
            "                                      env=krb5env, echo=False)",
            "            except pexpect.ExceptionPexpect as err:",
            "                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\",
            "                          \"'%s': %s\" % (command, to_native(err))",
            "                raise AnsibleConnectionFailure(err_msg)",
            "",
            "            try:",
            "                child.expect(\".*:\")",
            "                child.sendline(password)",
            "            except OSError as err:",
            "                # child exited before the pass was sent, Ansible will raise",
            "                # error based on the rc below, just display the error here",
            "                display.vvvv(\"kinit with pexpect raised OSError: %s\"",
            "                             % to_native(err))",
            "",
            "            # technically this is the stdout + stderr but to match the",
            "            # subprocess error checking behaviour, we will call it stderr",
            "            stderr = child.read()",
            "            child.wait()",
            "            rc = child.exitstatus",
            "        else:",
            "            proc_mechanism = \"subprocess\"",
            "            password = to_bytes(password, encoding='utf-8',",
            "                                errors='surrogate_or_strict')",
            "",
            "            display.vvvv(\"calling kinit with subprocess for principal %s\"",
            "                         % principal)",
            "            try:",
            "                p = subprocess.Popen(kinit_cmdline, stdin=subprocess.PIPE,",
            "                                     stdout=subprocess.PIPE,",
            "                                     stderr=subprocess.PIPE,",
            "                                     env=krb5env)",
            "",
            "            except OSError as err:",
            "                err_msg = \"Kerberos auth failure when calling kinit cmd \" \\",
            "                          \"'%s': %s\" % (self._kinit_cmd, to_native(err))",
            "                raise AnsibleConnectionFailure(err_msg)",
            "",
            "            stdout, stderr = p.communicate(password + b'\\n')",
            "            rc = p.returncode != 0",
            "",
            "        if rc != 0:",
            "            # one last attempt at making sure the password does not exist",
            "            # in the output",
            "            exp_msg = to_native(stderr.strip())",
            "            exp_msg = exp_msg.replace(to_native(password), \"<redacted>\")",
            "",
            "            err_msg = \"Kerberos auth failure for principal %s with %s: %s\" \\",
            "                      % (principal, proc_mechanism, exp_msg)",
            "            raise AnsibleConnectionFailure(err_msg)",
            "",
            "        display.vvvvv(\"kinit succeeded for principal %s\" % principal)",
            "",
            "    def _winrm_connect(self):",
            "        '''",
            "        Establish a WinRM connection over HTTP/HTTPS.",
            "        '''",
            "        display.vvv(\"ESTABLISH WINRM CONNECTION FOR USER: %s on PORT %s TO %s\" %",
            "                    (self._winrm_user, self._winrm_port, self._winrm_host), host=self._winrm_host)",
            "",
            "        winrm_host = self._winrm_host",
            "        if HAS_IPADDRESS:",
            "            display.vvvv(\"checking if winrm_host %s is an IPv6 address\" % winrm_host)",
            "            try:",
            "                ipaddress.IPv6Address(winrm_host)",
            "            except ipaddress.AddressValueError:",
            "                pass",
            "            else:",
            "                winrm_host = \"[%s]\" % winrm_host",
            "",
            "        netloc = '%s:%d' % (winrm_host, self._winrm_port)",
            "        endpoint = urlunsplit((self._winrm_scheme, netloc, self._winrm_path, '', ''))",
            "        errors = []",
            "        for transport in self._winrm_transport:",
            "            if transport == 'kerberos':",
            "                if not HAVE_KERBEROS:",
            "                    errors.append('kerberos: the python kerberos library is not installed')",
            "                    continue",
            "                if self._kerb_managed:",
            "                    self._kerb_auth(self._winrm_user, self._winrm_pass)",
            "            display.vvvvv('WINRM CONNECT: transport=%s endpoint=%s' % (transport, endpoint), host=self._winrm_host)",
            "            try:",
            "                winrm_kwargs = self._winrm_kwargs.copy()",
            "                if self._winrm_connection_timeout:",
            "                    winrm_kwargs['operation_timeout_sec'] = self._winrm_connection_timeout",
            "                    winrm_kwargs['read_timeout_sec'] = self._winrm_connection_timeout + 1",
            "                protocol = Protocol(endpoint, transport=transport, **winrm_kwargs)",
            "",
            "                # open the shell from connect so we know we're able to talk to the server",
            "                if not self.shell_id:",
            "                    self.shell_id = protocol.open_shell(codepage=65001)  # UTF-8",
            "                    display.vvvvv('WINRM OPEN SHELL: %s' % self.shell_id, host=self._winrm_host)",
            "",
            "                return protocol",
            "            except Exception as e:",
            "                err_msg = to_text(e).strip()",
            "                if re.search(to_text(r'Operation\\s+?timed\\s+?out'), err_msg, re.I):",
            "                    raise AnsibleError('the connection attempt timed out')",
            "                m = re.search(to_text(r'Code\\s+?(\\d{3})'), err_msg)",
            "                if m:",
            "                    code = int(m.groups()[0])",
            "                    if code == 401:",
            "                        err_msg = 'the specified credentials were rejected by the server'",
            "                    elif code == 411:",
            "                        return protocol",
            "                errors.append(u'%s: %s' % (transport, err_msg))",
            "                display.vvvvv(u'WINRM CONNECTION ERROR: %s\\n%s' % (err_msg, to_text(traceback.format_exc())), host=self._winrm_host)",
            "        if errors:",
            "            raise AnsibleConnectionFailure(', '.join(map(to_native, errors)))",
            "        else:",
            "            raise AnsibleError('No transport found for WinRM connection')",
            "",
            "    def _winrm_send_input(self, protocol, shell_id, command_id, stdin, eof=False):",
            "        rq = {'env:Envelope': protocol._get_soap_header(",
            "            resource_uri='http://schemas.microsoft.com/wbem/wsman/1/windows/shell/cmd',",
            "            action='http://schemas.microsoft.com/wbem/wsman/1/windows/shell/Send',",
            "            shell_id=shell_id)}",
            "        stream = rq['env:Envelope'].setdefault('env:Body', {}).setdefault('rsp:Send', {})\\",
            "            .setdefault('rsp:Stream', {})",
            "        stream['@Name'] = 'stdin'",
            "        stream['@CommandId'] = command_id",
            "        stream['#text'] = base64.b64encode(to_bytes(stdin))",
            "        if eof:",
            "            stream['@End'] = 'true'",
            "        protocol.send_message(xmltodict.unparse(rq))",
            "",
            "    def _winrm_exec(self, command, args=(), from_exec=False, stdin_iterator=None):",
            "        if not self.protocol:",
            "            self.protocol = self._winrm_connect()",
            "            self._connected = True",
            "        if from_exec:",
            "            display.vvvvv(\"WINRM EXEC %r %r\" % (command, args), host=self._winrm_host)",
            "        else:",
            "            display.vvvvvv(\"WINRM EXEC %r %r\" % (command, args), host=self._winrm_host)",
            "        command_id = None",
            "        try:",
            "            stdin_push_failed = False",
            "            command_id = self.protocol.run_command(self.shell_id, to_bytes(command), map(to_bytes, args), console_mode_stdin=(stdin_iterator is None))",
            "",
            "            try:",
            "                if stdin_iterator:",
            "                    for (data, is_last) in stdin_iterator:",
            "                        self._winrm_send_input(self.protocol, self.shell_id, command_id, data, eof=is_last)",
            "",
            "            except Exception as ex:",
            "                display.warning(\"FATAL ERROR DURING FILE TRANSFER: %s\" % to_text(ex))",
            "                stdin_push_failed = True",
            "",
            "            # NB: this can hang if the receiver is still running (eg, network failed a Send request but the server's still happy).",
            "            # FUTURE: Consider adding pywinrm status check/abort operations to see if the target is still running after a failure.",
            "            resptuple = self.protocol.get_command_output(self.shell_id, command_id)",
            "            # ensure stdout/stderr are text for py3",
            "            # FUTURE: this should probably be done internally by pywinrm",
            "            response = Response(tuple(to_text(v) if isinstance(v, binary_type) else v for v in resptuple))",
            "",
            "            # TODO: check result from response and set stdin_push_failed if we have nonzero",
            "            if from_exec:",
            "                display.vvvvv('WINRM RESULT %r' % to_text(response), host=self._winrm_host)",
            "            else:",
            "                display.vvvvvv('WINRM RESULT %r' % to_text(response), host=self._winrm_host)",
            "",
            "            display.vvvvvv('WINRM STDOUT %s' % to_text(response.std_out), host=self._winrm_host)",
            "            display.vvvvvv('WINRM STDERR %s' % to_text(response.std_err), host=self._winrm_host)",
            "",
            "            if stdin_push_failed:",
            "                stderr = to_bytes(response.std_err, encoding='utf-8')",
            "                if self.is_clixml(stderr):",
            "                    stderr = self.parse_clixml_stream(stderr)",
            "",
            "                raise AnsibleError('winrm send_input failed; \\nstdout: %s\\nstderr %s' % (to_native(response.std_out), to_native(stderr)))",
            "",
            "            return response",
            "        finally:",
            "            if command_id:",
            "                self.protocol.cleanup_command(self.shell_id, command_id)",
            "",
            "    def _connect(self):",
            "",
            "        if not HAS_WINRM:",
            "            raise AnsibleError(\"winrm or requests is not installed: %s\" % to_native(WINRM_IMPORT_ERR))",
            "        elif not HAS_XMLTODICT:",
            "            raise AnsibleError(\"xmltodict is not installed: %s\" % to_native(XMLTODICT_IMPORT_ERR))",
            "",
            "        super(Connection, self)._connect()",
            "        if not self.protocol:",
            "            self._build_winrm_kwargs()  # build the kwargs from the options set",
            "            self.protocol = self._winrm_connect()",
            "            self._connected = True",
            "        return self",
            "",
            "    def reset(self):",
            "        self.protocol = None",
            "        self.shell_id = None",
            "        self._connect()",
            "",
            "    def _wrapper_payload_stream(self, payload, buffer_size=200000):",
            "        payload_bytes = to_bytes(payload)",
            "        byte_count = len(payload_bytes)",
            "        for i in range(0, byte_count, buffer_size):",
            "            yield payload_bytes[i:i + buffer_size], i + buffer_size >= byte_count",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        super(Connection, self).exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "        cmd_parts = self._shell._encode_script(cmd, as_list=True, strict_mode=False, preserve_rc=False)",
            "",
            "        # TODO: display something meaningful here",
            "        display.vvv(\"EXEC (via pipeline wrapper)\")",
            "",
            "        stdin_iterator = None",
            "",
            "        if in_data:",
            "            stdin_iterator = self._wrapper_payload_stream(in_data)",
            "",
            "        result = self._winrm_exec(cmd_parts[0], cmd_parts[1:], from_exec=True, stdin_iterator=stdin_iterator)",
            "",
            "        result.std_out = to_bytes(result.std_out)",
            "        result.std_err = to_bytes(result.std_err)",
            "",
            "        # parse just stderr from CLIXML output",
            "        if self.is_clixml(result.std_err):",
            "            try:",
            "                result.std_err = self.parse_clixml_stream(result.std_err)",
            "            except Exception:",
            "                # unsure if we're guaranteed a valid xml doc- use raw output in case of error",
            "                pass",
            "",
            "        return (result.status_code, result.std_out, result.std_err)",
            "",
            "    def is_clixml(self, value):",
            "        return value.startswith(b\"#< CLIXML\\r\\n\")",
            "",
            "    # hacky way to get just stdout- not always sure of doc framing here, so use with care",
            "    def parse_clixml_stream(self, clixml_doc, stream_name='Error'):",
            "        clixml = ET.fromstring(clixml_doc.split(b\"\\r\\n\", 1)[-1])",
            "        namespace_match = re.match(r'{(.*)}', clixml.tag)",
            "        namespace = \"{%s}\" % namespace_match.group(1) if namespace_match else \"\"",
            "",
            "        strings = clixml.findall(\"./%sS\" % namespace)",
            "        lines = [e.text.replace('_x000D__x000A_', '') for e in strings if e.attrib.get('S') == stream_name]",
            "        return to_bytes('\\r\\n'.join(lines))",
            "",
            "    # FUTURE: determine buffer size at runtime via remote winrm config?",
            "    def _put_file_stdin_iterator(self, in_path, out_path, buffer_size=250000):",
            "        in_size = os.path.getsize(to_bytes(in_path, errors='surrogate_or_strict'))",
            "        offset = 0",
            "        with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file:",
            "            for out_data in iter((lambda: in_file.read(buffer_size)), b''):",
            "                offset += len(out_data)",
            "                self._display.vvvvv('WINRM PUT \"%s\" to \"%s\" (offset=%d size=%d)' % (in_path, out_path, offset, len(out_data)), host=self._winrm_host)",
            "                # yes, we're double-encoding over the wire in this case- we want to ensure that the data shipped to the end PS pipeline is still b64-encoded",
            "                b64_data = base64.b64encode(out_data) + b'\\r\\n'",
            "                # cough up the data, as well as an indicator if this is the last chunk so winrm_send knows to set the End signal",
            "                yield b64_data, (in_file.tell() == in_size)",
            "",
            "            if offset == 0:  # empty file, return an empty buffer + eof to close it",
            "                yield \"\", True",
            "",
            "    def put_file(self, in_path, out_path):",
            "        super(Connection, self).put_file(in_path, out_path)",
            "        out_path = self._shell._unquote(out_path)",
            "        display.vvv('PUT \"%s\" TO \"%s\"' % (in_path, out_path), host=self._winrm_host)",
            "        if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):",
            "            raise AnsibleFileNotFound('file or module does not exist: \"%s\"' % to_native(in_path))",
            "",
            "        script_template = u'''",
            "            begin {{",
            "                $path = '{0}'",
            "",
            "                $DebugPreference = \"Continue\"",
            "                $ErrorActionPreference = \"Stop\"",
            "                Set-StrictMode -Version 2",
            "",
            "                $fd = [System.IO.File]::Create($path)",
            "",
            "                $sha1 = [System.Security.Cryptography.SHA1CryptoServiceProvider]::Create()",
            "",
            "                $bytes = @() #initialize for empty file case",
            "            }}",
            "            process {{",
            "               $bytes = [System.Convert]::FromBase64String($input)",
            "               $sha1.TransformBlock($bytes, 0, $bytes.Length, $bytes, 0) | Out-Null",
            "               $fd.Write($bytes, 0, $bytes.Length)",
            "            }}",
            "            end {{",
            "                $sha1.TransformFinalBlock($bytes, 0, 0) | Out-Null",
            "",
            "                $hash = [System.BitConverter]::ToString($sha1.Hash).Replace(\"-\", \"\").ToLowerInvariant()",
            "",
            "                $fd.Close()",
            "",
            "                Write-Output \"{{\"\"sha1\"\":\"\"$hash\"\"}}\"",
            "            }}",
            "        '''",
            "",
            "        script = script_template.format(self._shell._escape(out_path))",
            "        cmd_parts = self._shell._encode_script(script, as_list=True, strict_mode=False, preserve_rc=False)",
            "",
            "        result = self._winrm_exec(cmd_parts[0], cmd_parts[1:], stdin_iterator=self._put_file_stdin_iterator(in_path, out_path))",
            "        # TODO: improve error handling",
            "        if result.status_code != 0:",
            "            raise AnsibleError(to_native(result.std_err))",
            "",
            "        put_output = json.loads(result.std_out)",
            "        remote_sha1 = put_output.get(\"sha1\")",
            "",
            "        if not remote_sha1:",
            "            raise AnsibleError(\"Remote sha1 was not returned\")",
            "",
            "        local_sha1 = secure_hash(in_path)",
            "",
            "        if not remote_sha1 == local_sha1:",
            "            raise AnsibleError(\"Remote sha1 hash {0} does not match local hash {1}\".format(to_native(remote_sha1), to_native(local_sha1)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "        in_path = self._shell._unquote(in_path)",
            "        out_path = out_path.replace('\\\\', '/')",
            "        display.vvv('FETCH \"%s\" TO \"%s\"' % (in_path, out_path), host=self._winrm_host)",
            "        buffer_size = 2**19  # 0.5MB chunks",
            "        makedirs_safe(os.path.dirname(out_path))",
            "        out_file = None",
            "        try:",
            "            offset = 0",
            "            while True:",
            "                try:",
            "                    script = '''",
            "                        $path = \"%(path)s\"",
            "                        If (Test-Path -Path $path -PathType Leaf)",
            "                        {",
            "                            $buffer_size = %(buffer_size)d",
            "                            $offset = %(offset)d",
            "",
            "                            $stream = New-Object -TypeName IO.FileStream($path, [IO.FileMode]::Open, [IO.FileAccess]::Read, [IO.FileShare]::ReadWrite)",
            "                            $stream.Seek($offset, [System.IO.SeekOrigin]::Begin) > $null",
            "                            $buffer = New-Object -TypeName byte[] $buffer_size",
            "                            $bytes_read = $stream.Read($buffer, 0, $buffer_size)",
            "                            if ($bytes_read -gt 0) {",
            "                                $bytes = $buffer[0..($bytes_read - 1)]",
            "                                [System.Convert]::ToBase64String($bytes)",
            "                            }",
            "                            $stream.Close() > $null",
            "                        }",
            "                        ElseIf (Test-Path -Path $path -PathType Container)",
            "                        {",
            "                            Write-Host \"[DIR]\";",
            "                        }",
            "                        Else",
            "                        {",
            "                            Write-Error \"$path does not exist\";",
            "                            Exit 1;",
            "                        }",
            "                    ''' % dict(buffer_size=buffer_size, path=self._shell._escape(in_path), offset=offset)",
            "                    display.vvvvv('WINRM FETCH \"%s\" to \"%s\" (offset=%d)' % (in_path, out_path, offset), host=self._winrm_host)",
            "                    cmd_parts = self._shell._encode_script(script, as_list=True, preserve_rc=False)",
            "                    result = self._winrm_exec(cmd_parts[0], cmd_parts[1:])",
            "                    if result.status_code != 0:",
            "                        raise IOError(to_native(result.std_err))",
            "                    if result.std_out.strip() == '[DIR]':",
            "                        data = None",
            "                    else:",
            "                        data = base64.b64decode(result.std_out.strip())",
            "                    if data is None:",
            "                        makedirs_safe(out_path)",
            "                        break",
            "                    else:",
            "                        if not out_file:",
            "                            # If out_path is a directory and we're expecting a file, bail out now.",
            "                            if os.path.isdir(to_bytes(out_path, errors='surrogate_or_strict')):",
            "                                break",
            "                            out_file = open(to_bytes(out_path, errors='surrogate_or_strict'), 'wb')",
            "                        out_file.write(data)",
            "                        if len(data) < buffer_size:",
            "                            break",
            "                        offset += len(data)",
            "                except Exception:",
            "                    traceback.print_exc()",
            "                    raise AnsibleError('failed to transfer file to \"%s\"' % to_native(out_path))",
            "        finally:",
            "            if out_file:",
            "                out_file.close()",
            "",
            "    def close(self):",
            "        if self.protocol and self.shell_id:",
            "            display.vvvvv('WINRM CLOSE SHELL: %s' % self.shell_id, host=self._winrm_host)",
            "            self.protocol.close_shell(self.shell_id)",
            "        self.shell_id = None",
            "        self.protocol = None",
            "        self._connected = False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "534": [
                "Connection",
                "is_clixml"
            ],
            "538": [
                "Connection",
                "parse_clixml_stream"
            ],
            "539": [
                "Connection",
                "parse_clixml_stream"
            ],
            "540": [
                "Connection",
                "parse_clixml_stream"
            ],
            "541": [
                "Connection",
                "parse_clixml_stream"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/shell/powershell.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " import re"
            },
            "2": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " import shlex"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+import pkgutil"
            },
            "4": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " from ansible.errors import AnsibleError"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " from ansible.module_utils._text import to_text"
            },
            "7": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         return self._encode_script(script)"
            },
            "8": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     def build_module_command(self, env_string, shebang, cmd, arg_path=None):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        bootstrap_wrapper = pkgutil.get_data(\"ansible.executor.powershell\", \"bootstrap_wrapper.ps1\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         # pipelining bypass"
            },
            "13": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         if cmd == '':"
            },
            "14": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return '-'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            return self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)"
            },
            "16": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 217,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         # non-pipelining"
            },
            "18": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 219,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         cmd_parts = shlex.split(cmd, posix=False)"
            },
            "20": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         cmd_parts = list(map(to_text, cmd_parts))"
            },
            "21": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         if shebang and shebang.lower() == '#!powershell':"
            },
            "22": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "             if not self._unquote(cmd_parts[0]).lower().endswith('.ps1'):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                # we're running a module via the bootstrap wrapper"
            },
            "24": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "                 cmd_parts[0] = '\"%s.ps1\"' % self._unquote(cmd_parts[0])"
            },
            "25": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cmd_parts.insert(0, '&')"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            wrapper_cmd = \"type \" + cmd_parts[0] + \" | \" + self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            return wrapper_cmd"
            },
            "28": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         elif shebang and shebang.startswith('#!'):"
            },
            "29": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             cmd_parts.insert(0, shebang[2:])"
            },
            "30": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         elif not shebang:"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    name: powershell",
            "    plugin_type: shell",
            "    version_added: \"\"",
            "    short_description: Windows Powershell",
            "    description:",
            "      - The only option when using 'winrm' as a connection plugin",
            "    options:",
            "      async_dir:",
            "        description:",
            "        - Directory in which ansible will keep async job information.",
            "        - Before Ansible 2.8, this was set to C(remote_tmp + \"\\\\.ansible_async\").",
            "        default: '%USERPROFILE%\\\\.ansible_async'",
            "        ini:",
            "        - section: powershell",
            "          key: async_dir",
            "        vars:",
            "        - name: ansible_async_dir",
            "        version_added: '2.8'",
            "      remote_tmp:",
            "        description:",
            "        - Temporary directory to use on targets when copying files to the host.",
            "        default: '%TEMP%'",
            "        ini:",
            "        - section: powershell",
            "          key: remote_tmp",
            "        vars:",
            "        - name: ansible_remote_tmp",
            "      set_module_language:",
            "        description:",
            "        - Controls if we set the locale for moduels when executing on the",
            "          target.",
            "        - Windows only supports C(no) as an option.",
            "        type: bool",
            "        default: 'no'",
            "        choices:",
            "        - 'no'",
            "      environment:",
            "        description:",
            "        - Dictionary of environment variables and their values to use when",
            "          executing commands.",
            "        type: dict",
            "        default: {}",
            "'''",
            "# FIXME: admin_users and set_module_language don't belong here but must be set",
            "# so they don't failk when someone get_option('admin_users') on this plugin",
            "",
            "import base64",
            "import os",
            "import re",
            "import shlex",
            "",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_text",
            "from ansible.plugins.shell import ShellBase",
            "",
            "",
            "_common_args = ['PowerShell', '-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Unrestricted']",
            "",
            "# Primarily for testing, allow explicitly specifying PowerShell version via",
            "# an environment variable.",
            "_powershell_version = os.environ.get('POWERSHELL_VERSION', None)",
            "if _powershell_version:",
            "    _common_args = ['PowerShell', '-Version', _powershell_version] + _common_args[1:]",
            "",
            "",
            "class ShellModule(ShellBase):",
            "",
            "    # Common shell filenames that this plugin handles",
            "    # Powershell is handled differently.  It's selected when winrm is the",
            "    # connection",
            "    COMPATIBLE_SHELLS = frozenset()",
            "    # Family of shells this has.  Must match the filename without extension",
            "    SHELL_FAMILY = 'powershell'",
            "",
            "    env = dict()",
            "",
            "    # We're being overly cautious about which keys to accept (more so than",
            "    # the Windows environment is capable of doing), since the powershell",
            "    # env provider's limitations don't appear to be documented.",
            "    safe_envkey = re.compile(r'^[\\d\\w_]{1,255}$')",
            "",
            "    # TODO: add binary module support",
            "",
            "    def assert_safe_env_key(self, key):",
            "        if not self.safe_envkey.match(key):",
            "            raise AnsibleError(\"Invalid PowerShell environment key: %s\" % key)",
            "        return key",
            "",
            "    def safe_env_value(self, key, value):",
            "        if len(value) > 32767:",
            "            raise AnsibleError(\"PowerShell environment value for key '%s' exceeds 32767 characters in length\" % key)",
            "        # powershell single quoted literals need single-quote doubling as their only escaping",
            "        value = value.replace(\"'\", \"''\")",
            "        return to_text(value, errors='surrogate_or_strict')",
            "",
            "    def env_prefix(self, **kwargs):",
            "        # powershell/winrm env handling is handled in the exec wrapper",
            "        return \"\"",
            "",
            "    def join_path(self, *args):",
            "        parts = []",
            "        for arg in args:",
            "            arg = self._unquote(arg).replace('/', '\\\\')",
            "            parts.extend([a for a in arg.split('\\\\') if a])",
            "        path = '\\\\'.join(parts)",
            "        if path.startswith('~'):",
            "            return path",
            "        return path",
            "",
            "    def get_remote_filename(self, pathname):",
            "        # powershell requires that script files end with .ps1",
            "        base_name = os.path.basename(pathname.strip())",
            "        name, ext = os.path.splitext(base_name.strip())",
            "        if ext.lower() not in ['.ps1', '.exe']:",
            "            return name + '.ps1'",
            "",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        # Allow Windows paths to be specified using either slash.",
            "        path = self._unquote(path)",
            "        return path.endswith('/') or path.endswith('\\\\')",
            "",
            "    def chmod(self, paths, mode):",
            "        raise NotImplementedError('chmod is not implemented for Powershell')",
            "",
            "    def chown(self, paths, user):",
            "        raise NotImplementedError('chown is not implemented for Powershell')",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        raise NotImplementedError('set_user_facl is not implemented for Powershell')",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = self._escape(self._unquote(path))",
            "        if recurse:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force -Recurse;''' % path)",
            "        else:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force;''' % path)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=None, tmpdir=None):",
            "        # Windows does not have an equivalent for the system temp files, so",
            "        # the param is ignored",
            "        basefile = self._escape(self._unquote(basefile))",
            "        basetmpdir = tmpdir if tmpdir else self.get_option('remote_tmp')",
            "",
            "        script = '''",
            "        $tmp_path = [System.Environment]::ExpandEnvironmentVariables('%s')",
            "        $tmp = New-Item -Type Directory -Path $tmp_path -Name '%s'",
            "        Write-Output -InputObject $tmp.FullName",
            "        ''' % (basetmpdir, basefile)",
            "        return self._encode_script(script.strip())",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        # PowerShell only supports \"~\" (not \"~username\").  Resolve-Path ~ does",
            "        # not seem to work remotely, though by default we are always starting",
            "        # in the user's home directory.",
            "        user_home_path = self._unquote(user_home_path)",
            "        if user_home_path == '~':",
            "            script = 'Write-Output (Get-Location).Path'",
            "        elif user_home_path.startswith('~\\\\'):",
            "            script = 'Write-Output ((Get-Location).Path + \"%s\")' % self._escape(user_home_path[1:])",
            "        else:",
            "            script = 'Write-Output \"%s\"' % self._escape(user_home_path)",
            "        return self._encode_script(script)",
            "",
            "    def exists(self, path):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path \"%s\")",
            "            {",
            "                $res = 0;",
            "            }",
            "            Else",
            "            {",
            "                $res = 1;",
            "            }",
            "            Write-Output \"$res\";",
            "            Exit $res;",
            "         ''' % path",
            "        return self._encode_script(script)",
            "",
            "    def checksum(self, path, *args, **kwargs):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path -PathType Leaf \"%(path)s\")",
            "            {",
            "                $sp = new-object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider;",
            "                $fp = [System.IO.File]::Open(\"%(path)s\", [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read);",
            "                [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace(\"-\", \"\").ToLower();",
            "                $fp.Dispose();",
            "            }",
            "            ElseIf (Test-Path -PathType Container \"%(path)s\")",
            "            {",
            "                Write-Output \"3\";",
            "            }",
            "            Else",
            "            {",
            "                Write-Output \"1\";",
            "            }",
            "        ''' % dict(path=path)",
            "        return self._encode_script(script)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        # pipelining bypass",
            "        if cmd == '':",
            "            return '-'",
            "",
            "        # non-pipelining",
            "",
            "        cmd_parts = shlex.split(cmd, posix=False)",
            "        cmd_parts = list(map(to_text, cmd_parts))",
            "        if shebang and shebang.lower() == '#!powershell':",
            "            if not self._unquote(cmd_parts[0]).lower().endswith('.ps1'):",
            "                cmd_parts[0] = '\"%s.ps1\"' % self._unquote(cmd_parts[0])",
            "            cmd_parts.insert(0, '&')",
            "        elif shebang and shebang.startswith('#!'):",
            "            cmd_parts.insert(0, shebang[2:])",
            "        elif not shebang:",
            "            # The module is assumed to be a binary",
            "            cmd_parts[0] = self._unquote(cmd_parts[0])",
            "            cmd_parts.append(arg_path)",
            "        script = '''",
            "            Try",
            "            {",
            "                %s",
            "                %s",
            "            }",
            "            Catch",
            "            {",
            "                $_obj = @{ failed = $true }",
            "                If ($_.Exception.GetType)",
            "                {",
            "                    $_obj.Add('msg', $_.Exception.Message)",
            "                }",
            "                Else",
            "                {",
            "                    $_obj.Add('msg', $_.ToString())",
            "                }",
            "                If ($_.InvocationInfo.PositionMessage)",
            "                {",
            "                    $_obj.Add('exception', $_.InvocationInfo.PositionMessage)",
            "                }",
            "                ElseIf ($_.ScriptStackTrace)",
            "                {",
            "                    $_obj.Add('exception', $_.ScriptStackTrace)",
            "                }",
            "                Try",
            "                {",
            "                    $_obj.Add('error_record', ($_ | ConvertTo-Json | ConvertFrom-Json))",
            "                }",
            "                Catch",
            "                {",
            "                }",
            "                Echo $_obj | ConvertTo-Json -Compress -Depth 99",
            "                Exit 1",
            "            }",
            "        ''' % (env_string, ' '.join(cmd_parts))",
            "        return self._encode_script(script, preserve_rc=False)",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        return '& %s; exit $LASTEXITCODE' % cmd",
            "",
            "    def _unquote(self, value):",
            "        '''Remove any matching quotes that wrap the given value.'''",
            "        value = to_text(value or '')",
            "        m = re.match(r'^\\s*?\\'(.*?)\\'\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        m = re.match(r'^\\s*?\"(.*?)\"\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        return value",
            "",
            "    def _escape(self, value, include_vars=False):",
            "        '''Return value escaped for use in PowerShell command.'''",
            "        # http://www.techotopia.com/index.php/Windows_PowerShell_1.0_String_Quoting_and_Escape_Sequences",
            "        # http://stackoverflow.com/questions/764360/a-list-of-string-replacements-in-python",
            "        subs = [('\\n', '`n'), ('\\r', '`r'), ('\\t', '`t'), ('\\a', '`a'),",
            "                ('\\b', '`b'), ('\\f', '`f'), ('\\v', '`v'), ('\"', '`\"'),",
            "                ('\\'', '`\\''), ('`', '``'), ('\\x00', '`0')]",
            "        if include_vars:",
            "            subs.append(('$', '`$'))",
            "        pattern = '|'.join('(%s)' % re.escape(p) for p, s in subs)",
            "        substs = [s for p, s in subs]",
            "",
            "        def replace(m):",
            "            return substs[m.lastindex - 1]",
            "",
            "        return re.sub(pattern, replace, value)",
            "",
            "    def _encode_script(self, script, as_list=False, strict_mode=True, preserve_rc=True):",
            "        '''Convert a PowerShell script to a single base64-encoded command.'''",
            "        script = to_text(script)",
            "",
            "        if script == u'-':",
            "            cmd_parts = _common_args + ['-Command', '-']",
            "",
            "        else:",
            "            if strict_mode:",
            "                script = u'Set-StrictMode -Version Latest\\r\\n%s' % script",
            "            # try to propagate exit code if present- won't work with begin/process/end-style scripts (ala put_file)",
            "            # NB: the exit code returned may be incorrect in the case of a successful command followed by an invalid command",
            "            if preserve_rc:",
            "                script = u'%s\\r\\nIf (-not $?) { If (Get-Variable LASTEXITCODE -ErrorAction SilentlyContinue) { exit $LASTEXITCODE } Else { exit 1 } }\\r\\n'\\",
            "                    % script",
            "            script = '\\n'.join([x.strip() for x in script.splitlines() if x.strip()])",
            "            encoded_script = to_text(base64.b64encode(script.encode('utf-16-le')), 'utf-8')",
            "            cmd_parts = _common_args + ['-EncodedCommand', encoded_script]",
            "",
            "        if as_list:",
            "            return cmd_parts",
            "        return ' '.join(cmd_parts)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2014, Chris Church <chris@ninemoreminutes.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    name: powershell",
            "    plugin_type: shell",
            "    version_added: \"\"",
            "    short_description: Windows Powershell",
            "    description:",
            "      - The only option when using 'winrm' as a connection plugin",
            "    options:",
            "      async_dir:",
            "        description:",
            "        - Directory in which ansible will keep async job information.",
            "        - Before Ansible 2.8, this was set to C(remote_tmp + \"\\\\.ansible_async\").",
            "        default: '%USERPROFILE%\\\\.ansible_async'",
            "        ini:",
            "        - section: powershell",
            "          key: async_dir",
            "        vars:",
            "        - name: ansible_async_dir",
            "        version_added: '2.8'",
            "      remote_tmp:",
            "        description:",
            "        - Temporary directory to use on targets when copying files to the host.",
            "        default: '%TEMP%'",
            "        ini:",
            "        - section: powershell",
            "          key: remote_tmp",
            "        vars:",
            "        - name: ansible_remote_tmp",
            "      set_module_language:",
            "        description:",
            "        - Controls if we set the locale for moduels when executing on the",
            "          target.",
            "        - Windows only supports C(no) as an option.",
            "        type: bool",
            "        default: 'no'",
            "        choices:",
            "        - 'no'",
            "      environment:",
            "        description:",
            "        - Dictionary of environment variables and their values to use when",
            "          executing commands.",
            "        type: dict",
            "        default: {}",
            "'''",
            "# FIXME: admin_users and set_module_language don't belong here but must be set",
            "# so they don't failk when someone get_option('admin_users') on this plugin",
            "",
            "import base64",
            "import os",
            "import re",
            "import shlex",
            "import pkgutil",
            "",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_text",
            "from ansible.plugins.shell import ShellBase",
            "",
            "",
            "_common_args = ['PowerShell', '-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Unrestricted']",
            "",
            "# Primarily for testing, allow explicitly specifying PowerShell version via",
            "# an environment variable.",
            "_powershell_version = os.environ.get('POWERSHELL_VERSION', None)",
            "if _powershell_version:",
            "    _common_args = ['PowerShell', '-Version', _powershell_version] + _common_args[1:]",
            "",
            "",
            "class ShellModule(ShellBase):",
            "",
            "    # Common shell filenames that this plugin handles",
            "    # Powershell is handled differently.  It's selected when winrm is the",
            "    # connection",
            "    COMPATIBLE_SHELLS = frozenset()",
            "    # Family of shells this has.  Must match the filename without extension",
            "    SHELL_FAMILY = 'powershell'",
            "",
            "    env = dict()",
            "",
            "    # We're being overly cautious about which keys to accept (more so than",
            "    # the Windows environment is capable of doing), since the powershell",
            "    # env provider's limitations don't appear to be documented.",
            "    safe_envkey = re.compile(r'^[\\d\\w_]{1,255}$')",
            "",
            "    # TODO: add binary module support",
            "",
            "    def assert_safe_env_key(self, key):",
            "        if not self.safe_envkey.match(key):",
            "            raise AnsibleError(\"Invalid PowerShell environment key: %s\" % key)",
            "        return key",
            "",
            "    def safe_env_value(self, key, value):",
            "        if len(value) > 32767:",
            "            raise AnsibleError(\"PowerShell environment value for key '%s' exceeds 32767 characters in length\" % key)",
            "        # powershell single quoted literals need single-quote doubling as their only escaping",
            "        value = value.replace(\"'\", \"''\")",
            "        return to_text(value, errors='surrogate_or_strict')",
            "",
            "    def env_prefix(self, **kwargs):",
            "        # powershell/winrm env handling is handled in the exec wrapper",
            "        return \"\"",
            "",
            "    def join_path(self, *args):",
            "        parts = []",
            "        for arg in args:",
            "            arg = self._unquote(arg).replace('/', '\\\\')",
            "            parts.extend([a for a in arg.split('\\\\') if a])",
            "        path = '\\\\'.join(parts)",
            "        if path.startswith('~'):",
            "            return path",
            "        return path",
            "",
            "    def get_remote_filename(self, pathname):",
            "        # powershell requires that script files end with .ps1",
            "        base_name = os.path.basename(pathname.strip())",
            "        name, ext = os.path.splitext(base_name.strip())",
            "        if ext.lower() not in ['.ps1', '.exe']:",
            "            return name + '.ps1'",
            "",
            "        return base_name.strip()",
            "",
            "    def path_has_trailing_slash(self, path):",
            "        # Allow Windows paths to be specified using either slash.",
            "        path = self._unquote(path)",
            "        return path.endswith('/') or path.endswith('\\\\')",
            "",
            "    def chmod(self, paths, mode):",
            "        raise NotImplementedError('chmod is not implemented for Powershell')",
            "",
            "    def chown(self, paths, user):",
            "        raise NotImplementedError('chown is not implemented for Powershell')",
            "",
            "    def set_user_facl(self, paths, user, mode):",
            "        raise NotImplementedError('set_user_facl is not implemented for Powershell')",
            "",
            "    def remove(self, path, recurse=False):",
            "        path = self._escape(self._unquote(path))",
            "        if recurse:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force -Recurse;''' % path)",
            "        else:",
            "            return self._encode_script('''Remove-Item \"%s\" -Force;''' % path)",
            "",
            "    def mkdtemp(self, basefile=None, system=False, mode=None, tmpdir=None):",
            "        # Windows does not have an equivalent for the system temp files, so",
            "        # the param is ignored",
            "        basefile = self._escape(self._unquote(basefile))",
            "        basetmpdir = tmpdir if tmpdir else self.get_option('remote_tmp')",
            "",
            "        script = '''",
            "        $tmp_path = [System.Environment]::ExpandEnvironmentVariables('%s')",
            "        $tmp = New-Item -Type Directory -Path $tmp_path -Name '%s'",
            "        Write-Output -InputObject $tmp.FullName",
            "        ''' % (basetmpdir, basefile)",
            "        return self._encode_script(script.strip())",
            "",
            "    def expand_user(self, user_home_path, username=''):",
            "        # PowerShell only supports \"~\" (not \"~username\").  Resolve-Path ~ does",
            "        # not seem to work remotely, though by default we are always starting",
            "        # in the user's home directory.",
            "        user_home_path = self._unquote(user_home_path)",
            "        if user_home_path == '~':",
            "            script = 'Write-Output (Get-Location).Path'",
            "        elif user_home_path.startswith('~\\\\'):",
            "            script = 'Write-Output ((Get-Location).Path + \"%s\")' % self._escape(user_home_path[1:])",
            "        else:",
            "            script = 'Write-Output \"%s\"' % self._escape(user_home_path)",
            "        return self._encode_script(script)",
            "",
            "    def exists(self, path):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path \"%s\")",
            "            {",
            "                $res = 0;",
            "            }",
            "            Else",
            "            {",
            "                $res = 1;",
            "            }",
            "            Write-Output \"$res\";",
            "            Exit $res;",
            "         ''' % path",
            "        return self._encode_script(script)",
            "",
            "    def checksum(self, path, *args, **kwargs):",
            "        path = self._escape(self._unquote(path))",
            "        script = '''",
            "            If (Test-Path -PathType Leaf \"%(path)s\")",
            "            {",
            "                $sp = new-object -TypeName System.Security.Cryptography.SHA1CryptoServiceProvider;",
            "                $fp = [System.IO.File]::Open(\"%(path)s\", [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read);",
            "                [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace(\"-\", \"\").ToLower();",
            "                $fp.Dispose();",
            "            }",
            "            ElseIf (Test-Path -PathType Container \"%(path)s\")",
            "            {",
            "                Write-Output \"3\";",
            "            }",
            "            Else",
            "            {",
            "                Write-Output \"1\";",
            "            }",
            "        ''' % dict(path=path)",
            "        return self._encode_script(script)",
            "",
            "    def build_module_command(self, env_string, shebang, cmd, arg_path=None):",
            "        bootstrap_wrapper = pkgutil.get_data(\"ansible.executor.powershell\", \"bootstrap_wrapper.ps1\")",
            "",
            "        # pipelining bypass",
            "        if cmd == '':",
            "            return self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)",
            "",
            "        # non-pipelining",
            "",
            "        cmd_parts = shlex.split(cmd, posix=False)",
            "        cmd_parts = list(map(to_text, cmd_parts))",
            "        if shebang and shebang.lower() == '#!powershell':",
            "            if not self._unquote(cmd_parts[0]).lower().endswith('.ps1'):",
            "                # we're running a module via the bootstrap wrapper",
            "                cmd_parts[0] = '\"%s.ps1\"' % self._unquote(cmd_parts[0])",
            "            wrapper_cmd = \"type \" + cmd_parts[0] + \" | \" + self._encode_script(script=bootstrap_wrapper, strict_mode=False, preserve_rc=False)",
            "            return wrapper_cmd",
            "        elif shebang and shebang.startswith('#!'):",
            "            cmd_parts.insert(0, shebang[2:])",
            "        elif not shebang:",
            "            # The module is assumed to be a binary",
            "            cmd_parts[0] = self._unquote(cmd_parts[0])",
            "            cmd_parts.append(arg_path)",
            "        script = '''",
            "            Try",
            "            {",
            "                %s",
            "                %s",
            "            }",
            "            Catch",
            "            {",
            "                $_obj = @{ failed = $true }",
            "                If ($_.Exception.GetType)",
            "                {",
            "                    $_obj.Add('msg', $_.Exception.Message)",
            "                }",
            "                Else",
            "                {",
            "                    $_obj.Add('msg', $_.ToString())",
            "                }",
            "                If ($_.InvocationInfo.PositionMessage)",
            "                {",
            "                    $_obj.Add('exception', $_.InvocationInfo.PositionMessage)",
            "                }",
            "                ElseIf ($_.ScriptStackTrace)",
            "                {",
            "                    $_obj.Add('exception', $_.ScriptStackTrace)",
            "                }",
            "                Try",
            "                {",
            "                    $_obj.Add('error_record', ($_ | ConvertTo-Json | ConvertFrom-Json))",
            "                }",
            "                Catch",
            "                {",
            "                }",
            "                Echo $_obj | ConvertTo-Json -Compress -Depth 99",
            "                Exit 1",
            "            }",
            "        ''' % (env_string, ' '.join(cmd_parts))",
            "        return self._encode_script(script, preserve_rc=False)",
            "",
            "    def wrap_for_exec(self, cmd):",
            "        return '& %s; exit $LASTEXITCODE' % cmd",
            "",
            "    def _unquote(self, value):",
            "        '''Remove any matching quotes that wrap the given value.'''",
            "        value = to_text(value or '')",
            "        m = re.match(r'^\\s*?\\'(.*?)\\'\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        m = re.match(r'^\\s*?\"(.*?)\"\\s*?$', value)",
            "        if m:",
            "            return m.group(1)",
            "        return value",
            "",
            "    def _escape(self, value, include_vars=False):",
            "        '''Return value escaped for use in PowerShell command.'''",
            "        # http://www.techotopia.com/index.php/Windows_PowerShell_1.0_String_Quoting_and_Escape_Sequences",
            "        # http://stackoverflow.com/questions/764360/a-list-of-string-replacements-in-python",
            "        subs = [('\\n', '`n'), ('\\r', '`r'), ('\\t', '`t'), ('\\a', '`a'),",
            "                ('\\b', '`b'), ('\\f', '`f'), ('\\v', '`v'), ('\"', '`\"'),",
            "                ('\\'', '`\\''), ('`', '``'), ('\\x00', '`0')]",
            "        if include_vars:",
            "            subs.append(('$', '`$'))",
            "        pattern = '|'.join('(%s)' % re.escape(p) for p, s in subs)",
            "        substs = [s for p, s in subs]",
            "",
            "        def replace(m):",
            "            return substs[m.lastindex - 1]",
            "",
            "        return re.sub(pattern, replace, value)",
            "",
            "    def _encode_script(self, script, as_list=False, strict_mode=True, preserve_rc=True):",
            "        '''Convert a PowerShell script to a single base64-encoded command.'''",
            "        script = to_text(script)",
            "",
            "        if script == u'-':",
            "            cmd_parts = _common_args + ['-Command', '-']",
            "",
            "        else:",
            "            if strict_mode:",
            "                script = u'Set-StrictMode -Version Latest\\r\\n%s' % script",
            "            # try to propagate exit code if present- won't work with begin/process/end-style scripts (ala put_file)",
            "            # NB: the exit code returned may be incorrect in the case of a successful command followed by an invalid command",
            "            if preserve_rc:",
            "                script = u'%s\\r\\nIf (-not $?) { If (Get-Variable LASTEXITCODE -ErrorAction SilentlyContinue) { exit $LASTEXITCODE } Else { exit 1 } }\\r\\n'\\",
            "                    % script",
            "            script = '\\n'.join([x.strip() for x in script.splitlines() if x.strip()])",
            "            encoded_script = to_text(base64.b64encode(script.encode('utf-16-le')), 'utf-8')",
            "            cmd_parts = _common_args + ['-EncodedCommand', encoded_script]",
            "",
            "        if as_list:",
            "            return cmd_parts",
            "        return ' '.join(cmd_parts)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "213": [
                "ShellModule",
                "build_module_command"
            ],
            "222": [
                "ShellModule",
                "build_module_command"
            ]
        },
        "addLocation": []
    }
}