{
    "Tests/test_file_fpx.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from PIL import Image"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+"
            },
            "2": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from .helper import PillowTestCase, unittest"
            },
            "3": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " try:"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         # Test a valid OLE file, but not an FPX file"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "         ole_file = \"Tests/images/test-ole-file.doc\""
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "         self.assertRaises(SyntaxError, FpxImagePlugin.FpxImageFile, ole_file)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    def test_fpx_invalid_number_of_bands(self):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        with self.assertRaisesRegex(IOError, \"Invalid number of bands\"):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+            Image.open(\"Tests/images/input_bw_five_bands.fpx\")"
            }
        },
        "frontPatchFile": [
            "from .helper import PillowTestCase, unittest",
            "",
            "try:",
            "    from PIL import FpxImagePlugin",
            "except ImportError:",
            "    olefile_installed = False",
            "else:",
            "    olefile_installed = True",
            "",
            "",
            "@unittest.skipUnless(olefile_installed, \"olefile package not installed\")",
            "class TestFileFpx(PillowTestCase):",
            "    def test_invalid_file(self):",
            "        # Test an invalid OLE file",
            "        invalid_file = \"Tests/images/flower.jpg\"",
            "        self.assertRaises(SyntaxError, FpxImagePlugin.FpxImageFile, invalid_file)",
            "",
            "        # Test a valid OLE file, but not an FPX file",
            "        ole_file = \"Tests/images/test-ole-file.doc\"",
            "        self.assertRaises(SyntaxError, FpxImagePlugin.FpxImageFile, ole_file)"
        ],
        "afterPatchFile": [
            "from PIL import Image",
            "",
            "from .helper import PillowTestCase, unittest",
            "",
            "try:",
            "    from PIL import FpxImagePlugin",
            "except ImportError:",
            "    olefile_installed = False",
            "else:",
            "    olefile_installed = True",
            "",
            "",
            "@unittest.skipUnless(olefile_installed, \"olefile package not installed\")",
            "class TestFileFpx(PillowTestCase):",
            "    def test_invalid_file(self):",
            "        # Test an invalid OLE file",
            "        invalid_file = \"Tests/images/flower.jpg\"",
            "        self.assertRaises(SyntaxError, FpxImagePlugin.FpxImageFile, invalid_file)",
            "",
            "        # Test a valid OLE file, but not an FPX file",
            "        ole_file = \"Tests/images/test-ole-file.doc\"",
            "        self.assertRaises(SyntaxError, FpxImagePlugin.FpxImageFile, ole_file)",
            "",
            "    def test_fpx_invalid_number_of_bands(self):",
            "        with self.assertRaisesRegex(IOError, \"Invalid number of bands\"):",
            "            Image.open(\"Tests/images/input_bw_five_bands.fpx\")"
        ],
        "action": [
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "aiohttp.web_urldispatcher",
            "Tests.test_file_fpx.TestFileFpx.self"
        ]
    },
    "src/PIL/FpxImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         s = prop[0x2000002 | id]"
            },
            "1": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         colors = []"
            },
            "3": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for i in range(i32(s, 4)):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        bands = i32(s, 4)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        if bands > 4:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            raise IOError(\"Invalid number of bands\")"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        for i in range(bands):"
            },
            "8": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             # note: for now, we ignore the \"uncalibrated\" flag"
            },
            "9": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "             colors.append(i32(s, 8 + i * 4) & 0x7FFFFFFF)"
            },
            "10": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "# THIS IS WORK IN PROGRESS",
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# FlashPix support for PIL",
            "#",
            "# History:",
            "# 97-01-25 fl   Created (reads uncompressed RGB images only)",
            "#",
            "# Copyright (c) Secret Labs AB 1997.",
            "# Copyright (c) Fredrik Lundh 1997.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "import olefile",
            "",
            "from . import Image, ImageFile",
            "from ._binary import i8, i32le as i32",
            "",
            "# __version__ is deprecated and will be removed in a future version. Use",
            "# PIL.__version__ instead.",
            "__version__ = \"0.1\"",
            "",
            "# we map from colour field tuples to (mode, rawmode) descriptors",
            "MODES = {",
            "    # opacity",
            "    (0x00007FFE): (\"A\", \"L\"),",
            "    # monochrome",
            "    (0x00010000,): (\"L\", \"L\"),",
            "    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),",
            "    # photo YCC",
            "    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),",
            "    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),",
            "    # standard RGB (NIFRGB)",
            "    (0x00030000, 0x00030001, 0x00030002): (\"RGB\", \"RGB\"),",
            "    (0x00038000, 0x00038001, 0x00038002, 0x00037FFE): (\"RGBA\", \"RGBA\"),",
            "}",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:8] == olefile.MAGIC",
            "",
            "",
            "##",
            "# Image plugin for the FlashPix images.",
            "",
            "",
            "class FpxImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"FPX\"",
            "    format_description = \"FlashPix\"",
            "",
            "    def _open(self):",
            "        #",
            "        # read the OLE directory and see if this is a likely",
            "        # to be a FlashPix file",
            "",
            "        try:",
            "            self.ole = olefile.OleFileIO(self.fp)",
            "        except IOError:",
            "            raise SyntaxError(\"not an FPX file; invalid OLE file\")",
            "",
            "        if self.ole.root.clsid != \"56616700-C154-11CE-8553-00AA00A1F95B\":",
            "            raise SyntaxError(\"not an FPX file; bad root CLSID\")",
            "",
            "        self._open_index(1)",
            "",
            "    def _open_index(self, index=1):",
            "        #",
            "        # get the Image Contents Property Set",
            "",
            "        prop = self.ole.getproperties(",
            "            [\"Data Object Store %06d\" % index, \"\\005Image Contents\"]",
            "        )",
            "",
            "        # size (highest resolution)",
            "",
            "        self._size = prop[0x1000002], prop[0x1000003]",
            "",
            "        size = max(self.size)",
            "        i = 1",
            "        while size > 64:",
            "            size = size / 2",
            "            i += 1",
            "        self.maxid = i - 1",
            "",
            "        # mode.  instead of using a single field for this, flashpix",
            "        # requires you to specify the mode for each channel in each",
            "        # resolution subimage, and leaves it to the decoder to make",
            "        # sure that they all match.  for now, we'll cheat and assume",
            "        # that this is always the case.",
            "",
            "        id = self.maxid << 16",
            "",
            "        s = prop[0x2000002 | id]",
            "",
            "        colors = []",
            "        for i in range(i32(s, 4)):",
            "            # note: for now, we ignore the \"uncalibrated\" flag",
            "            colors.append(i32(s, 8 + i * 4) & 0x7FFFFFFF)",
            "",
            "        self.mode, self.rawmode = MODES[tuple(colors)]",
            "",
            "        # load JPEG tables, if any",
            "        self.jpeg = {}",
            "        for i in range(256):",
            "            id = 0x3000001 | (i << 16)",
            "            if id in prop:",
            "                self.jpeg[i] = prop[id]",
            "",
            "        self._open_subimage(1, self.maxid)",
            "",
            "    def _open_subimage(self, index=1, subimage=0):",
            "        #",
            "        # setup tile descriptors for a given subimage",
            "",
            "        stream = [",
            "            \"Data Object Store %06d\" % index,",
            "            \"Resolution %04d\" % subimage,",
            "            \"Subimage 0000 Header\",",
            "        ]",
            "",
            "        fp = self.ole.openstream(stream)",
            "",
            "        # skip prefix",
            "        fp.read(28)",
            "",
            "        # header stream",
            "        s = fp.read(36)",
            "",
            "        size = i32(s, 4), i32(s, 8)",
            "        # tilecount = i32(s, 12)",
            "        tilesize = i32(s, 16), i32(s, 20)",
            "        # channels = i32(s, 24)",
            "        offset = i32(s, 28)",
            "        length = i32(s, 32)",
            "",
            "        if size != self.size:",
            "            raise IOError(\"subimage mismatch\")",
            "",
            "        # get tile descriptors",
            "        fp.seek(28 + offset)",
            "        s = fp.read(i32(s, 12) * length)",
            "",
            "        x = y = 0",
            "        xsize, ysize = size",
            "        xtile, ytile = tilesize",
            "        self.tile = []",
            "",
            "        for i in range(0, len(s), length):",
            "",
            "            compression = i32(s, i + 8)",
            "",
            "            if compression == 0:",
            "                self.tile.append(",
            "                    (",
            "                        \"raw\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (self.rawmode),",
            "                    )",
            "                )",
            "",
            "            elif compression == 1:",
            "",
            "                # FIXME: the fill decoder is not implemented",
            "                self.tile.append(",
            "                    (",
            "                        \"fill\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (self.rawmode, s[12:16]),",
            "                    )",
            "                )",
            "",
            "            elif compression == 2:",
            "",
            "                internal_color_conversion = i8(s[14])",
            "                jpeg_tables = i8(s[15])",
            "                rawmode = self.rawmode",
            "",
            "                if internal_color_conversion:",
            "                    # The image is stored as usual (usually YCbCr).",
            "                    if rawmode == \"RGBA\":",
            "                        # For \"RGBA\", data is stored as YCbCrA based on",
            "                        # negative RGB. The following trick works around",
            "                        # this problem :",
            "                        jpegmode, rawmode = \"YCbCrK\", \"CMYK\"",
            "                    else:",
            "                        jpegmode = None  # let the decoder decide",
            "",
            "                else:",
            "                    # The image is stored as defined by rawmode",
            "                    jpegmode = rawmode",
            "",
            "                self.tile.append(",
            "                    (",
            "                        \"jpeg\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (rawmode, jpegmode),",
            "                    )",
            "                )",
            "",
            "                # FIXME: jpeg tables are tile dependent; the prefix",
            "                # data must be placed in the tile descriptor itself!",
            "",
            "                if jpeg_tables:",
            "                    self.tile_prefix = self.jpeg[jpeg_tables]",
            "",
            "            else:",
            "                raise IOError(\"unknown/invalid compression\")",
            "",
            "            x = x + xtile",
            "            if x >= xsize:",
            "                x, y = 0, y + ytile",
            "                if y >= ysize:",
            "                    break  # isn't really required",
            "",
            "        self.stream = stream",
            "        self.fp = None",
            "",
            "    def load(self):",
            "",
            "        if not self.fp:",
            "            self.fp = self.ole.openstream(self.stream[:2] + [\"Subimage 0000 Data\"])",
            "",
            "        return ImageFile.ImageFile.load(self)",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(FpxImageFile.format, FpxImageFile, _accept)",
            "",
            "Image.register_extension(FpxImageFile.format, \".fpx\")"
        ],
        "afterPatchFile": [
            "#",
            "# THIS IS WORK IN PROGRESS",
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# FlashPix support for PIL",
            "#",
            "# History:",
            "# 97-01-25 fl   Created (reads uncompressed RGB images only)",
            "#",
            "# Copyright (c) Secret Labs AB 1997.",
            "# Copyright (c) Fredrik Lundh 1997.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "import olefile",
            "",
            "from . import Image, ImageFile",
            "from ._binary import i8, i32le as i32",
            "",
            "# __version__ is deprecated and will be removed in a future version. Use",
            "# PIL.__version__ instead.",
            "__version__ = \"0.1\"",
            "",
            "# we map from colour field tuples to (mode, rawmode) descriptors",
            "MODES = {",
            "    # opacity",
            "    (0x00007FFE): (\"A\", \"L\"),",
            "    # monochrome",
            "    (0x00010000,): (\"L\", \"L\"),",
            "    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),",
            "    # photo YCC",
            "    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),",
            "    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),",
            "    # standard RGB (NIFRGB)",
            "    (0x00030000, 0x00030001, 0x00030002): (\"RGB\", \"RGB\"),",
            "    (0x00038000, 0x00038001, 0x00038002, 0x00037FFE): (\"RGBA\", \"RGBA\"),",
            "}",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:8] == olefile.MAGIC",
            "",
            "",
            "##",
            "# Image plugin for the FlashPix images.",
            "",
            "",
            "class FpxImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"FPX\"",
            "    format_description = \"FlashPix\"",
            "",
            "    def _open(self):",
            "        #",
            "        # read the OLE directory and see if this is a likely",
            "        # to be a FlashPix file",
            "",
            "        try:",
            "            self.ole = olefile.OleFileIO(self.fp)",
            "        except IOError:",
            "            raise SyntaxError(\"not an FPX file; invalid OLE file\")",
            "",
            "        if self.ole.root.clsid != \"56616700-C154-11CE-8553-00AA00A1F95B\":",
            "            raise SyntaxError(\"not an FPX file; bad root CLSID\")",
            "",
            "        self._open_index(1)",
            "",
            "    def _open_index(self, index=1):",
            "        #",
            "        # get the Image Contents Property Set",
            "",
            "        prop = self.ole.getproperties(",
            "            [\"Data Object Store %06d\" % index, \"\\005Image Contents\"]",
            "        )",
            "",
            "        # size (highest resolution)",
            "",
            "        self._size = prop[0x1000002], prop[0x1000003]",
            "",
            "        size = max(self.size)",
            "        i = 1",
            "        while size > 64:",
            "            size = size / 2",
            "            i += 1",
            "        self.maxid = i - 1",
            "",
            "        # mode.  instead of using a single field for this, flashpix",
            "        # requires you to specify the mode for each channel in each",
            "        # resolution subimage, and leaves it to the decoder to make",
            "        # sure that they all match.  for now, we'll cheat and assume",
            "        # that this is always the case.",
            "",
            "        id = self.maxid << 16",
            "",
            "        s = prop[0x2000002 | id]",
            "",
            "        colors = []",
            "        bands = i32(s, 4)",
            "        if bands > 4:",
            "            raise IOError(\"Invalid number of bands\")",
            "        for i in range(bands):",
            "            # note: for now, we ignore the \"uncalibrated\" flag",
            "            colors.append(i32(s, 8 + i * 4) & 0x7FFFFFFF)",
            "",
            "        self.mode, self.rawmode = MODES[tuple(colors)]",
            "",
            "        # load JPEG tables, if any",
            "        self.jpeg = {}",
            "        for i in range(256):",
            "            id = 0x3000001 | (i << 16)",
            "            if id in prop:",
            "                self.jpeg[i] = prop[id]",
            "",
            "        self._open_subimage(1, self.maxid)",
            "",
            "    def _open_subimage(self, index=1, subimage=0):",
            "        #",
            "        # setup tile descriptors for a given subimage",
            "",
            "        stream = [",
            "            \"Data Object Store %06d\" % index,",
            "            \"Resolution %04d\" % subimage,",
            "            \"Subimage 0000 Header\",",
            "        ]",
            "",
            "        fp = self.ole.openstream(stream)",
            "",
            "        # skip prefix",
            "        fp.read(28)",
            "",
            "        # header stream",
            "        s = fp.read(36)",
            "",
            "        size = i32(s, 4), i32(s, 8)",
            "        # tilecount = i32(s, 12)",
            "        tilesize = i32(s, 16), i32(s, 20)",
            "        # channels = i32(s, 24)",
            "        offset = i32(s, 28)",
            "        length = i32(s, 32)",
            "",
            "        if size != self.size:",
            "            raise IOError(\"subimage mismatch\")",
            "",
            "        # get tile descriptors",
            "        fp.seek(28 + offset)",
            "        s = fp.read(i32(s, 12) * length)",
            "",
            "        x = y = 0",
            "        xsize, ysize = size",
            "        xtile, ytile = tilesize",
            "        self.tile = []",
            "",
            "        for i in range(0, len(s), length):",
            "",
            "            compression = i32(s, i + 8)",
            "",
            "            if compression == 0:",
            "                self.tile.append(",
            "                    (",
            "                        \"raw\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (self.rawmode),",
            "                    )",
            "                )",
            "",
            "            elif compression == 1:",
            "",
            "                # FIXME: the fill decoder is not implemented",
            "                self.tile.append(",
            "                    (",
            "                        \"fill\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (self.rawmode, s[12:16]),",
            "                    )",
            "                )",
            "",
            "            elif compression == 2:",
            "",
            "                internal_color_conversion = i8(s[14])",
            "                jpeg_tables = i8(s[15])",
            "                rawmode = self.rawmode",
            "",
            "                if internal_color_conversion:",
            "                    # The image is stored as usual (usually YCbCr).",
            "                    if rawmode == \"RGBA\":",
            "                        # For \"RGBA\", data is stored as YCbCrA based on",
            "                        # negative RGB. The following trick works around",
            "                        # this problem :",
            "                        jpegmode, rawmode = \"YCbCrK\", \"CMYK\"",
            "                    else:",
            "                        jpegmode = None  # let the decoder decide",
            "",
            "                else:",
            "                    # The image is stored as defined by rawmode",
            "                    jpegmode = rawmode",
            "",
            "                self.tile.append(",
            "                    (",
            "                        \"jpeg\",",
            "                        (x, y, x + xtile, y + ytile),",
            "                        i32(s, i) + 28,",
            "                        (rawmode, jpegmode),",
            "                    )",
            "                )",
            "",
            "                # FIXME: jpeg tables are tile dependent; the prefix",
            "                # data must be placed in the tile descriptor itself!",
            "",
            "                if jpeg_tables:",
            "                    self.tile_prefix = self.jpeg[jpeg_tables]",
            "",
            "            else:",
            "                raise IOError(\"unknown/invalid compression\")",
            "",
            "            x = x + xtile",
            "            if x >= xsize:",
            "                x, y = 0, y + ytile",
            "                if y >= ysize:",
            "                    break  # isn't really required",
            "",
            "        self.stream = stream",
            "        self.fp = None",
            "",
            "    def load(self):",
            "",
            "        if not self.fp:",
            "            self.fp = self.ole.openstream(self.stream[:2] + [\"Subimage 0000 Data\"])",
            "",
            "        return ImageFile.ImageFile.load(self)",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(FpxImageFile.format, FpxImageFile, _accept)",
            "",
            "Image.register_extension(FpxImageFile.format, \".fpx\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "107": [
                "FpxImageFile",
                "_open_index"
            ]
        },
        "addLocation": []
    }
}