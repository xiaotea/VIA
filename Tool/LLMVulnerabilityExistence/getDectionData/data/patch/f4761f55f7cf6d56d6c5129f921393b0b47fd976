{
    "web/pgadmin/about/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from flask import Response, render_template, request"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from flask_babel import gettext"
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_security import current_user, login_required"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from flask_security import current_user"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from pgadmin.user_login_check import pga_login_required"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from pgadmin.utils.menu import MenuItem"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from pgadmin.utils.constants import MIMETYPE_APP_JS"
            },
            "9": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " # A test page"
            },
            "10": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " ##########################################################################"
            },
            "11": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " @blueprint.route(\"/\", endpoint='index')"
            },
            "12": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+@pga_login_required"
            },
            "14": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " def index():"
            },
            "15": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     \"\"\"Render the about box.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     info = {}"
            },
            "17": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " @blueprint.route(\"/about.js\")"
            },
            "20": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+@pga_login_required"
            },
            "22": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " def script():"
            },
            "23": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     \"\"\"render the required javascript\"\"\""
            },
            "24": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     return Response("
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the about box.\"\"\"",
            "",
            "from flask import Response, render_template, request",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.menu import MenuItem",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.utils.ajax import make_json_response",
            "import config",
            "import httpagentparser",
            "from pgadmin.model import User",
            "from user_agents import parse",
            "import platform",
            "",
            "MODULE_NAME = 'about'",
            "",
            "",
            "class AboutModule(PgAdminModule):",
            "    def get_own_menuitems(self):",
            "        appname = config.APP_NAME",
            "",
            "        return {",
            "            'help_items': [",
            "                MenuItem(",
            "                    name='mnu_about',",
            "                    priority=999,",
            "                    module=\"pgAdmin.About\",",
            "                    callback='about_show',",
            "                    icon='fa fa-info-circle',",
            "                    label=gettext('About %(appname)s', appname=appname)",
            "                )",
            "            ]",
            "        }",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        return ['about.index']",
            "",
            "",
            "blueprint = AboutModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "##########################################################################",
            "# A test page",
            "##########################################################################",
            "@blueprint.route(\"/\", endpoint='index')",
            "@login_required",
            "def index():",
            "    \"\"\"Render the about box.\"\"\"",
            "    info = {}",
            "    # Get OS , NW.js, Browser details",
            "    browser, os_details, nwjs_version = detect_browser(request)",
            "    admin = is_admin(current_user.email)",
            "",
            "    if nwjs_version:",
            "        info['nwjs'] = nwjs_version",
            "",
            "    if config.SERVER_MODE:",
            "        info['app_mode'] = gettext('Server')",
            "    else:",
            "        info['app_mode'] = gettext('Desktop')",
            "",
            "    info['browser_details'] = browser",
            "    info['version'] = config.APP_VERSION",
            "    info['admin'] = admin",
            "    info['current_user'] = current_user.email",
            "",
            "    if admin:",
            "        settings = \"\"",
            "        info['os_details'] = os_details",
            "        info['log_file'] = config.LOG_FILE",
            "",
            "        # If external datbase is used do not display SQLITE_PATH",
            "        if not config.CONFIG_DATABASE_URI:",
            "            info['config_db'] = config.SQLITE_PATH",
            "",
            "        for setting in dir(config):",
            "            if not setting.startswith('_') and setting.isupper() and \\",
            "                setting not in ['CSRF_SESSION_KEY',",
            "                                'SECRET_KEY',",
            "                                'SECURITY_PASSWORD_SALT',",
            "                                'SECURITY_PASSWORD_HASH',",
            "                                'ALLOWED_HOSTS',",
            "                                'MAIL_PASSWORD',",
            "                                'LDAP_BIND_PASSWORD',",
            "                                'SECURITY_PASSWORD_HASH']:",
            "                if isinstance(getattr(config, setting), str):",
            "                    settings = \\",
            "                        settings + '{} = \"{}\"\\n'.format(",
            "                            setting, getattr(config, setting))",
            "                else:",
            "                    settings = \\",
            "                        settings + '{} = {}\\n'.format(",
            "                            setting, getattr(config, setting))",
            "",
            "        info['settings'] = settings",
            "",
            "    return make_json_response(",
            "        data=info,",
            "        status=200",
            "    )",
            "",
            "",
            "def is_admin(load_user):",
            "    user = User.query.filter_by(email=load_user).first()",
            "    return user.has_role(\"Administrator\")",
            "",
            "",
            "def detect_browser(request):",
            "    \"\"\"This function returns the browser and os details\"\"\"",
            "    nwjs_version = None",
            "    agent = request.environ.get('HTTP_USER_AGENT')",
            "    os_details = parse(platform.platform()).ua_string",
            "",
            "    if 'Nwjs' in agent:",
            "        agent = agent.split('-')",
            "        nwjs_version = agent[0].split(':')[1]",
            "        browser = 'Chromium' + ' ' + agent[2]",
            "",
            "    else:",
            "        browser = httpagentparser.detect(agent)",
            "        if not browser:",
            "            browser = agent.split('/')[0]",
            "        else:",
            "            browser = browser['browser']['name'] + ' ' + browser['browser'][",
            "                'version']",
            "",
            "    return browser, os_details, nwjs_version",
            "",
            "",
            "@blueprint.route(\"/about.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render the required javascript\"\"\"",
            "    return Response(",
            "        response=render_template(\"about/about.js\", _=gettext),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the about box.\"\"\"",
            "",
            "from flask import Response, render_template, request",
            "from flask_babel import gettext",
            "from flask_security import current_user",
            "from pgadmin.user_login_check import pga_login_required",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.menu import MenuItem",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.utils.ajax import make_json_response",
            "import config",
            "import httpagentparser",
            "from pgadmin.model import User",
            "from user_agents import parse",
            "import platform",
            "",
            "MODULE_NAME = 'about'",
            "",
            "",
            "class AboutModule(PgAdminModule):",
            "    def get_own_menuitems(self):",
            "        appname = config.APP_NAME",
            "",
            "        return {",
            "            'help_items': [",
            "                MenuItem(",
            "                    name='mnu_about',",
            "                    priority=999,",
            "                    module=\"pgAdmin.About\",",
            "                    callback='about_show',",
            "                    icon='fa fa-info-circle',",
            "                    label=gettext('About %(appname)s', appname=appname)",
            "                )",
            "            ]",
            "        }",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        return ['about.index']",
            "",
            "",
            "blueprint = AboutModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "##########################################################################",
            "# A test page",
            "##########################################################################",
            "@blueprint.route(\"/\", endpoint='index')",
            "@pga_login_required",
            "def index():",
            "    \"\"\"Render the about box.\"\"\"",
            "    info = {}",
            "    # Get OS , NW.js, Browser details",
            "    browser, os_details, nwjs_version = detect_browser(request)",
            "    admin = is_admin(current_user.email)",
            "",
            "    if nwjs_version:",
            "        info['nwjs'] = nwjs_version",
            "",
            "    if config.SERVER_MODE:",
            "        info['app_mode'] = gettext('Server')",
            "    else:",
            "        info['app_mode'] = gettext('Desktop')",
            "",
            "    info['browser_details'] = browser",
            "    info['version'] = config.APP_VERSION",
            "    info['admin'] = admin",
            "    info['current_user'] = current_user.email",
            "",
            "    if admin:",
            "        settings = \"\"",
            "        info['os_details'] = os_details",
            "        info['log_file'] = config.LOG_FILE",
            "",
            "        # If external datbase is used do not display SQLITE_PATH",
            "        if not config.CONFIG_DATABASE_URI:",
            "            info['config_db'] = config.SQLITE_PATH",
            "",
            "        for setting in dir(config):",
            "            if not setting.startswith('_') and setting.isupper() and \\",
            "                setting not in ['CSRF_SESSION_KEY',",
            "                                'SECRET_KEY',",
            "                                'SECURITY_PASSWORD_SALT',",
            "                                'SECURITY_PASSWORD_HASH',",
            "                                'ALLOWED_HOSTS',",
            "                                'MAIL_PASSWORD',",
            "                                'LDAP_BIND_PASSWORD',",
            "                                'SECURITY_PASSWORD_HASH']:",
            "                if isinstance(getattr(config, setting), str):",
            "                    settings = \\",
            "                        settings + '{} = \"{}\"\\n'.format(",
            "                            setting, getattr(config, setting))",
            "                else:",
            "                    settings = \\",
            "                        settings + '{} = {}\\n'.format(",
            "                            setting, getattr(config, setting))",
            "",
            "        info['settings'] = settings",
            "",
            "    return make_json_response(",
            "        data=info,",
            "        status=200",
            "    )",
            "",
            "",
            "def is_admin(load_user):",
            "    user = User.query.filter_by(email=load_user).first()",
            "    return user.has_role(\"Administrator\")",
            "",
            "",
            "def detect_browser(request):",
            "    \"\"\"This function returns the browser and os details\"\"\"",
            "    nwjs_version = None",
            "    agent = request.environ.get('HTTP_USER_AGENT')",
            "    os_details = parse(platform.platform()).ua_string",
            "",
            "    if 'Nwjs' in agent:",
            "        agent = agent.split('-')",
            "        nwjs_version = agent[0].split(':')[1]",
            "        browser = 'Chromium' + ' ' + agent[2]",
            "",
            "    else:",
            "        browser = httpagentparser.detect(agent)",
            "        if not browser:",
            "            browser = agent.split('/')[0]",
            "        else:",
            "            browser = browser['browser']['name'] + ' ' + browser['browser'][",
            "                'version']",
            "",
            "    return browser, os_details, nwjs_version",
            "",
            "",
            "@blueprint.route(\"/about.js\")",
            "@pga_login_required",
            "def script():",
            "    \"\"\"render the required javascript\"\"\"",
            "    return Response(",
            "        response=render_template(\"about/about.js\", _=gettext),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [],
            "56": [],
            "141": []
        },
        "addLocation": []
    },
    "web/pgadmin/authenticate/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from flask_login import current_user"
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flask_socketio import disconnect, ConnectionRefusedError"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from pgadmin.model import db, User"
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pgadmin.utils import PgAdminModule, get_safe_post_login_redirect, \\"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    get_safe_post_logout_redirect"
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from pgadmin.utils.constants import KERBEROS, INTERNAL, OAUTH2, LDAP,\\"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     MessageType"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+import pgadmin.utils as pga_utils"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from pgadmin.authenticate.registry import AuthSourceRegistry"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " MODULE_NAME = 'authenticate'"
            },
            "13": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     return wrapped"
            },
            "14": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class AuthenticateModule(PgAdminModule):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+class AuthenticateModule(pga_utils.PgAdminModule):"
            },
            "18": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     def get_exposed_url_endpoints(self):"
            },
            "19": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         return ['authenticate.login']"
            },
            "20": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                           'Administrator.'),"
            },
            "22": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                   MessageType.WARNING)"
            },
            "23": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             logout_user()"
            },
            "24": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return redirect(get_safe_post_logout_redirect())"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            return redirect(pga_utils.get_safe_post_logout_redirect())"
            },
            "26": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     # Validate the user"
            },
            "28": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     if not auth_obj.validate():"
            },
            "29": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                     flash_login_attempt_error = None"
            },
            "30": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                 flash(error, MessageType.WARNING)"
            },
            "31": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return redirect(get_safe_post_logout_redirect())"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        return redirect(pga_utils.get_safe_post_logout_redirect())"
            },
            "34": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     # Authenticate the user"
            },
            "36": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     status, msg = auth_obj.authenticate()"
            },
            "37": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "                     'authenticate.kerberos_login'), url_for('browser.index')))"
            },
            "38": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             flash(msg, MessageType.ERROR)"
            },
            "40": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return redirect(get_safe_post_logout_redirect())"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            return redirect(pga_utils.get_safe_post_logout_redirect())"
            },
            "42": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         session['auth_source_manager'] = current_auth_obj"
            },
            "44": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         if 'auth_obj' in session:"
            },
            "47": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "             session.pop('auth_obj')"
            },
            "48": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return redirect(get_safe_post_login_redirect())"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        return redirect(pga_utils.get_safe_post_login_redirect())"
            },
            "50": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     elif isinstance(msg, Response):"
            },
            "52": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         return msg"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Authentication.\"\"\"",
            "",
            "import config",
            "import copy",
            "import functools",
            "from threading import Lock",
            "",
            "from flask import current_app, flash, Response, request, url_for, \\",
            "    session, redirect, render_template",
            "from flask_babel import gettext",
            "from flask_security.views import _security, _ctx",
            "from flask_security.utils import logout_user, config_value",
            "",
            "from flask_login import current_user",
            "from flask_socketio import disconnect, ConnectionRefusedError",
            "",
            "",
            "from pgadmin.model import db, User",
            "from pgadmin.utils import PgAdminModule, get_safe_post_login_redirect, \\",
            "    get_safe_post_logout_redirect",
            "from pgadmin.utils.constants import KERBEROS, INTERNAL, OAUTH2, LDAP,\\",
            "    MessageType",
            "from pgadmin.authenticate.registry import AuthSourceRegistry",
            "",
            "MODULE_NAME = 'authenticate'",
            "auth_obj = None",
            "",
            "_URL_WITH_NEXT_PARAM = \"{0}?next={1}\"",
            "",
            "",
            "class AuthLocker:",
            "    \"\"\"Implementing lock while authentication.\"\"\"",
            "    lock = Lock()",
            "",
            "    def __enter__(self):",
            "        self.lock.acquire()",
            "        return self",
            "",
            "    def __exit__(self, type, value, traceback):",
            "        if self.lock.locked():",
            "            self.lock.release()",
            "",
            "",
            "def get_logout_url() -> str:",
            "    \"\"\"",
            "    Returns the logout url based on the current authentication method.",
            "",
            "    Returns:",
            "        str: logout url",
            "    \"\"\"",
            "    BROWSER_INDEX = 'browser.index'",
            "    if config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            KERBEROS:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'kerberos.logout'), url_for(BROWSER_INDEX))",
            "    elif config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            OAUTH2:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'oauth2.logout'), url_for(BROWSER_INDEX))",
            "",
            "    return _URL_WITH_NEXT_PARAM.format(",
            "        url_for('security.logout'), url_for(BROWSER_INDEX))",
            "",
            "",
            "def socket_login_required(f):",
            "    @functools.wraps(f)",
            "    def wrapped(*args, **kwargs):",
            "        if not current_user.is_authenticated:",
            "            disconnect()",
            "            raise ConnectionRefusedError(\"Unauthorised !\")",
            "        else:",
            "            return f(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class AuthenticateModule(PgAdminModule):",
            "    def get_exposed_url_endpoints(self):",
            "        return ['authenticate.login']",
            "",
            "",
            "blueprint = AuthenticateModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "@blueprint.route('/login', endpoint='login', methods=['GET', 'POST'])",
            "def login():",
            "    \"\"\"",
            "    Entry point for all the authentication sources.",
            "    The user input will be validated and authenticated.",
            "    \"\"\"",
            "    with AuthLocker():",
            "        return _login()",
            "",
            "",
            "def _login():",
            "    \"\"\"",
            "    Internal authentication process locked by a mutex.",
            "    \"\"\"",
            "    form = _security.forms.get('login_form').cls(request.form)",
            "    if OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "            and 'oauth2_button' in request.form:",
            "        # Sending empty form as oauth2 does not require form attribute",
            "        auth_obj = AuthSourceManager({}, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "        session['auth_obj'] = auth_obj",
            "    else:",
            "        auth_obj = AuthSourceManager(form, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "",
            "    session['auth_source_manager'] = None",
            "",
            "    username = form.data['email']",
            "    user = User.query.filter_by(username=username,",
            "                                auth_source=INTERNAL).first()",
            "",
            "    if user:",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            user.locked = True",
            "        else:",
            "            user.locked = False",
            "        db.session.commit()",
            "",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            flash(gettext('Your account is locked. Please contact the '",
            "                          'Administrator.'),",
            "                  MessageType.WARNING)",
            "            logout_user()",
            "            return redirect(get_safe_post_logout_redirect())",
            "",
            "    # Validate the user",
            "    if not auth_obj.validate():",
            "        for field in form.errors:",
            "            flash_login_attempt_error = None",
            "            if user and field in config.LOGIN_ATTEMPT_FIELDS:",
            "                if config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    user.login_attempts += 1",
            "                    left_attempts = \\",
            "                        config.MAX_LOGIN_ATTEMPTS - user.login_attempts",
            "                    if left_attempts > 1:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempts remaining.'.",
            "                                    format(left_attempts))",
            "                    else:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempt remaining.'.",
            "                                    format(left_attempts))",
            "                db.session.commit()",
            "            for error in form.errors[field]:",
            "                if flash_login_attempt_error:",
            "                    error = error + flash_login_attempt_error",
            "                    flash_login_attempt_error = None",
            "                flash(error, MessageType.WARNING)",
            "",
            "        return redirect(get_safe_post_logout_redirect())",
            "",
            "    # Authenticate the user",
            "    status, msg = auth_obj.authenticate()",
            "    if status:",
            "        # Login the user",
            "        status, msg = auth_obj.login()",
            "        current_auth_obj = auth_obj.as_dict()",
            "",
            "        if not status:",
            "            if current_auth_obj['current_source'] == \\",
            "                    KERBEROS:",
            "                return redirect('{0}?next={1}'.format(url_for(",
            "                    'authenticate.kerberos_login'), url_for('browser.index')))",
            "",
            "            flash(msg, MessageType.ERROR)",
            "            return redirect(get_safe_post_logout_redirect())",
            "",
            "        session['auth_source_manager'] = current_auth_obj",
            "",
            "        if user:",
            "            user.login_attempts = 0",
            "        db.session.commit()",
            "",
            "        if 'auth_obj' in session:",
            "            session.pop('auth_obj')",
            "        return redirect(get_safe_post_login_redirect())",
            "",
            "    elif isinstance(msg, Response):",
            "        return msg",
            "    elif 'oauth2_button' in request.form and not isinstance(msg, str):",
            "        return msg",
            "    if 'auth_obj' in session:",
            "        session.pop('auth_obj')",
            "    flash(msg, MessageType.ERROR)",
            "    form_class = _security.forms.get('login_form').cls",
            "    form = form_class()",
            "",
            "    return _security.render_template(",
            "        config_value('LOGIN_USER_TEMPLATE'),",
            "        login_user_form=form, **_ctx('login'))",
            "",
            "",
            "class AuthSourceManager:",
            "    \"\"\"This class will manage all the authentication sources.",
            "     \"\"\"",
            "",
            "    def __init__(self, form, sources):",
            "        self.form = form",
            "        self.auth_sources = sources",
            "        self.source = None",
            "        self.source_friendly_name = INTERNAL",
            "        self.current_source = INTERNAL",
            "        self.update_auth_sources()",
            "",
            "    def as_dict(self):",
            "        \"\"\"",
            "        Returns the dictionary object representing this object.",
            "        \"\"\"",
            "",
            "        res = dict()",
            "        res['source_friendly_name'] = self.source_friendly_name",
            "        res['auth_sources'] = self.auth_sources",
            "        res['current_source'] = self.current_source",
            "",
            "        return res",
            "",
            "    def update_auth_sources(self):",
            "        for auth_src in [KERBEROS, OAUTH2]:",
            "            if auth_src in self.auth_sources:",
            "                if 'internal_button' in request.form:",
            "                    self.auth_sources.remove(auth_src)",
            "                else:",
            "                    if INTERNAL in self.auth_sources:",
            "                        self.auth_sources.remove(INTERNAL)",
            "                    if LDAP in self.auth_sources:",
            "                        self.auth_sources.remove(LDAP)",
            "",
            "    def set_current_source(self, source):",
            "        self.current_source = source",
            "",
            "    @property",
            "    def get_current_source(self):",
            "        return self.current_source",
            "",
            "    def set_source(self, source):",
            "        self.source = source",
            "",
            "    @property",
            "    def get_source(self):",
            "        return self.source",
            "",
            "    def set_source_friendly_name(self, name):",
            "        self.source_friendly_name = name",
            "",
            "    @property",
            "    def get_source_friendly_name(self):",
            "        return self.source_friendly_name",
            "",
            "    def validate(self):",
            "        \"\"\"Validate through all the sources.\"\"\"",
            "        err_msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            status, err_msg = source.validate(self.form)",
            "            if status:",
            "                return True",
            "        if err_msg:",
            "            flash(err_msg, MessageType.WARNING)",
            "        return False",
            "",
            "    def authenticate(self):",
            "        \"\"\"Authenticate through all the sources.\"\"\"",
            "        status = False",
            "        msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            self.set_source(source)",
            "            current_app.logger.debug(",
            "                \"Authentication initiated via source: %s\" %",
            "                source.get_source_name())",
            "",
            "            status, msg = source.authenticate(self.form)",
            "",
            "            if status:",
            "                self.set_current_source(source.get_source_name())",
            "                if msg is not None and 'username' in msg:",
            "                    self.form._fields['email'].data = msg['username']",
            "                return status, msg",
            "            else:",
            "                current_app.logger.debug(",
            "                    \"Authentication initiated via source: %s is failed.\" %",
            "                    source.get_source_name())",
            "",
            "        return status, msg",
            "",
            "    def login(self):",
            "        status, msg = self.source.login(self.form)",
            "        if status:",
            "            self.set_source_friendly_name(self.source.get_friendly_name())",
            "            current_app.logger.debug(",
            "                \"Authentication and Login successfully done via source : %s\" %",
            "                self.source.get_source_name())",
            "",
            "            # Set the login, logout view as per source  if available",
            "            current_app.login_manager.login_view = getattr(",
            "                self.source, 'LOGIN_VIEW', 'security.login')",
            "            current_app.login_manager.logout_view = getattr(",
            "                self.source, 'LOGOUT_VIEW', 'security.logout')",
            "",
            "        return status, msg",
            "",
            "",
            "def get_auth_sources(type):",
            "    \"\"\"Get the authenticated source object from the registry\"\"\"",
            "",
            "    auth_sources = getattr(current_app, '_pgadmin_auth_sources', None)",
            "",
            "    if auth_sources is None or not isinstance(auth_sources, dict):",
            "        auth_sources = dict()",
            "",
            "    if type in auth_sources:",
            "        return auth_sources[type]",
            "",
            "    auth_source = AuthSourceRegistry.get(type)",
            "",
            "    if auth_source is not None:",
            "        auth_sources[type] = auth_source",
            "        setattr(current_app, '_pgadmin_auth_sources', auth_sources)",
            "",
            "    return auth_source",
            "",
            "",
            "def init_app(app):",
            "    auth_sources = dict()",
            "",
            "    setattr(app, '_pgadmin_auth_sources', auth_sources)",
            "    AuthSourceRegistry.load_modules(app)",
            "",
            "    return auth_sources"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Authentication.\"\"\"",
            "",
            "import config",
            "import copy",
            "import functools",
            "from threading import Lock",
            "",
            "from flask import current_app, flash, Response, request, url_for, \\",
            "    session, redirect, render_template",
            "from flask_babel import gettext",
            "from flask_security.views import _security, _ctx",
            "from flask_security.utils import logout_user, config_value",
            "",
            "from flask_login import current_user",
            "from flask_socketio import disconnect, ConnectionRefusedError",
            "",
            "from pgadmin.model import db, User",
            "from pgadmin.utils.constants import KERBEROS, INTERNAL, OAUTH2, LDAP,\\",
            "    MessageType",
            "import pgadmin.utils as pga_utils",
            "from pgadmin.authenticate.registry import AuthSourceRegistry",
            "",
            "MODULE_NAME = 'authenticate'",
            "auth_obj = None",
            "",
            "_URL_WITH_NEXT_PARAM = \"{0}?next={1}\"",
            "",
            "",
            "class AuthLocker:",
            "    \"\"\"Implementing lock while authentication.\"\"\"",
            "    lock = Lock()",
            "",
            "    def __enter__(self):",
            "        self.lock.acquire()",
            "        return self",
            "",
            "    def __exit__(self, type, value, traceback):",
            "        if self.lock.locked():",
            "            self.lock.release()",
            "",
            "",
            "def get_logout_url() -> str:",
            "    \"\"\"",
            "    Returns the logout url based on the current authentication method.",
            "",
            "    Returns:",
            "        str: logout url",
            "    \"\"\"",
            "    BROWSER_INDEX = 'browser.index'",
            "    if config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            KERBEROS:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'kerberos.logout'), url_for(BROWSER_INDEX))",
            "    elif config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            OAUTH2:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'oauth2.logout'), url_for(BROWSER_INDEX))",
            "",
            "    return _URL_WITH_NEXT_PARAM.format(",
            "        url_for('security.logout'), url_for(BROWSER_INDEX))",
            "",
            "",
            "def socket_login_required(f):",
            "    @functools.wraps(f)",
            "    def wrapped(*args, **kwargs):",
            "        if not current_user.is_authenticated:",
            "            disconnect()",
            "            raise ConnectionRefusedError(\"Unauthorised !\")",
            "        else:",
            "            return f(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class AuthenticateModule(pga_utils.PgAdminModule):",
            "    def get_exposed_url_endpoints(self):",
            "        return ['authenticate.login']",
            "",
            "",
            "blueprint = AuthenticateModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "@blueprint.route('/login', endpoint='login', methods=['GET', 'POST'])",
            "def login():",
            "    \"\"\"",
            "    Entry point for all the authentication sources.",
            "    The user input will be validated and authenticated.",
            "    \"\"\"",
            "    with AuthLocker():",
            "        return _login()",
            "",
            "",
            "def _login():",
            "    \"\"\"",
            "    Internal authentication process locked by a mutex.",
            "    \"\"\"",
            "    form = _security.forms.get('login_form').cls(request.form)",
            "    if OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "            and 'oauth2_button' in request.form:",
            "        # Sending empty form as oauth2 does not require form attribute",
            "        auth_obj = AuthSourceManager({}, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "        session['auth_obj'] = auth_obj",
            "    else:",
            "        auth_obj = AuthSourceManager(form, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "",
            "    session['auth_source_manager'] = None",
            "",
            "    username = form.data['email']",
            "    user = User.query.filter_by(username=username,",
            "                                auth_source=INTERNAL).first()",
            "",
            "    if user:",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            user.locked = True",
            "        else:",
            "            user.locked = False",
            "        db.session.commit()",
            "",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            flash(gettext('Your account is locked. Please contact the '",
            "                          'Administrator.'),",
            "                  MessageType.WARNING)",
            "            logout_user()",
            "            return redirect(pga_utils.get_safe_post_logout_redirect())",
            "",
            "    # Validate the user",
            "    if not auth_obj.validate():",
            "        for field in form.errors:",
            "            flash_login_attempt_error = None",
            "            if user and field in config.LOGIN_ATTEMPT_FIELDS:",
            "                if config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    user.login_attempts += 1",
            "                    left_attempts = \\",
            "                        config.MAX_LOGIN_ATTEMPTS - user.login_attempts",
            "                    if left_attempts > 1:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempts remaining.'.",
            "                                    format(left_attempts))",
            "                    else:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempt remaining.'.",
            "                                    format(left_attempts))",
            "                db.session.commit()",
            "            for error in form.errors[field]:",
            "                if flash_login_attempt_error:",
            "                    error = error + flash_login_attempt_error",
            "                    flash_login_attempt_error = None",
            "                flash(error, MessageType.WARNING)",
            "",
            "        return redirect(pga_utils.get_safe_post_logout_redirect())",
            "",
            "    # Authenticate the user",
            "    status, msg = auth_obj.authenticate()",
            "    if status:",
            "        # Login the user",
            "        status, msg = auth_obj.login()",
            "        current_auth_obj = auth_obj.as_dict()",
            "",
            "        if not status:",
            "            if current_auth_obj['current_source'] == \\",
            "                    KERBEROS:",
            "                return redirect('{0}?next={1}'.format(url_for(",
            "                    'authenticate.kerberos_login'), url_for('browser.index')))",
            "",
            "            flash(msg, MessageType.ERROR)",
            "            return redirect(pga_utils.get_safe_post_logout_redirect())",
            "",
            "        session['auth_source_manager'] = current_auth_obj",
            "",
            "        if user:",
            "            user.login_attempts = 0",
            "        db.session.commit()",
            "",
            "        if 'auth_obj' in session:",
            "            session.pop('auth_obj')",
            "        return redirect(pga_utils.get_safe_post_login_redirect())",
            "",
            "    elif isinstance(msg, Response):",
            "        return msg",
            "    elif 'oauth2_button' in request.form and not isinstance(msg, str):",
            "        return msg",
            "    if 'auth_obj' in session:",
            "        session.pop('auth_obj')",
            "    flash(msg, MessageType.ERROR)",
            "    form_class = _security.forms.get('login_form').cls",
            "    form = form_class()",
            "",
            "    return _security.render_template(",
            "        config_value('LOGIN_USER_TEMPLATE'),",
            "        login_user_form=form, **_ctx('login'))",
            "",
            "",
            "class AuthSourceManager:",
            "    \"\"\"This class will manage all the authentication sources.",
            "     \"\"\"",
            "",
            "    def __init__(self, form, sources):",
            "        self.form = form",
            "        self.auth_sources = sources",
            "        self.source = None",
            "        self.source_friendly_name = INTERNAL",
            "        self.current_source = INTERNAL",
            "        self.update_auth_sources()",
            "",
            "    def as_dict(self):",
            "        \"\"\"",
            "        Returns the dictionary object representing this object.",
            "        \"\"\"",
            "",
            "        res = dict()",
            "        res['source_friendly_name'] = self.source_friendly_name",
            "        res['auth_sources'] = self.auth_sources",
            "        res['current_source'] = self.current_source",
            "",
            "        return res",
            "",
            "    def update_auth_sources(self):",
            "        for auth_src in [KERBEROS, OAUTH2]:",
            "            if auth_src in self.auth_sources:",
            "                if 'internal_button' in request.form:",
            "                    self.auth_sources.remove(auth_src)",
            "                else:",
            "                    if INTERNAL in self.auth_sources:",
            "                        self.auth_sources.remove(INTERNAL)",
            "                    if LDAP in self.auth_sources:",
            "                        self.auth_sources.remove(LDAP)",
            "",
            "    def set_current_source(self, source):",
            "        self.current_source = source",
            "",
            "    @property",
            "    def get_current_source(self):",
            "        return self.current_source",
            "",
            "    def set_source(self, source):",
            "        self.source = source",
            "",
            "    @property",
            "    def get_source(self):",
            "        return self.source",
            "",
            "    def set_source_friendly_name(self, name):",
            "        self.source_friendly_name = name",
            "",
            "    @property",
            "    def get_source_friendly_name(self):",
            "        return self.source_friendly_name",
            "",
            "    def validate(self):",
            "        \"\"\"Validate through all the sources.\"\"\"",
            "        err_msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            status, err_msg = source.validate(self.form)",
            "            if status:",
            "                return True",
            "        if err_msg:",
            "            flash(err_msg, MessageType.WARNING)",
            "        return False",
            "",
            "    def authenticate(self):",
            "        \"\"\"Authenticate through all the sources.\"\"\"",
            "        status = False",
            "        msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            self.set_source(source)",
            "            current_app.logger.debug(",
            "                \"Authentication initiated via source: %s\" %",
            "                source.get_source_name())",
            "",
            "            status, msg = source.authenticate(self.form)",
            "",
            "            if status:",
            "                self.set_current_source(source.get_source_name())",
            "                if msg is not None and 'username' in msg:",
            "                    self.form._fields['email'].data = msg['username']",
            "                return status, msg",
            "            else:",
            "                current_app.logger.debug(",
            "                    \"Authentication initiated via source: %s is failed.\" %",
            "                    source.get_source_name())",
            "",
            "        return status, msg",
            "",
            "    def login(self):",
            "        status, msg = self.source.login(self.form)",
            "        if status:",
            "            self.set_source_friendly_name(self.source.get_friendly_name())",
            "            current_app.logger.debug(",
            "                \"Authentication and Login successfully done via source : %s\" %",
            "                self.source.get_source_name())",
            "",
            "            # Set the login, logout view as per source  if available",
            "            current_app.login_manager.login_view = getattr(",
            "                self.source, 'LOGIN_VIEW', 'security.login')",
            "            current_app.login_manager.logout_view = getattr(",
            "                self.source, 'LOGOUT_VIEW', 'security.logout')",
            "",
            "        return status, msg",
            "",
            "",
            "def get_auth_sources(type):",
            "    \"\"\"Get the authenticated source object from the registry\"\"\"",
            "",
            "    auth_sources = getattr(current_app, '_pgadmin_auth_sources', None)",
            "",
            "    if auth_sources is None or not isinstance(auth_sources, dict):",
            "        auth_sources = dict()",
            "",
            "    if type in auth_sources:",
            "        return auth_sources[type]",
            "",
            "    auth_source = AuthSourceRegistry.get(type)",
            "",
            "    if auth_source is not None:",
            "        auth_sources[type] = auth_source",
            "        setattr(current_app, '_pgadmin_auth_sources', auth_sources)",
            "",
            "    return auth_source",
            "",
            "",
            "def init_app(app):",
            "    auth_sources = dict()",
            "",
            "    setattr(app, '_pgadmin_auth_sources', auth_sources)",
            "    AuthSourceRegistry.load_modules(app)",
            "",
            "    return auth_sources"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "1",
            "1",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "28": [],
            "29": [],
            "87": [
                "AuthenticateModule"
            ],
            "138": [
                "_login"
            ],
            "164": [
                "_login"
            ],
            "180": [
                "_login"
            ],
            "190": [
                "_login"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/authenticate/kerberos.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     current_app, render_template, flash, url_for"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from flask_security.views import _security"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from flask_security.utils import logout_user"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_security import login_required"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from pgadmin.user_login_check import pga_login_required"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import config"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from pgadmin.model import User"
            },
            "8": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     @blueprint.route(\"/update_ticket\","
            },
            "9": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "                      endpoint=\"update_ticket\", methods=[\"GET\"])"
            },
            "10": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     @pgCSRFProtect.exempt"
            },
            "11": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    @pga_login_required"
            },
            "13": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     def kerberos_update_ticket():"
            },
            "14": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         Update the kerberos ticket."
            },
            "16": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     @blueprint.route(\"/validate_ticket\","
            },
            "17": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "                      endpoint=\"validate_ticket\", methods=[\"GET\"])"
            },
            "18": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     @pgCSRFProtect.exempt"
            },
            "19": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    @pga_login_required"
            },
            "21": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     def kerberos_validate_ticket():"
            },
            "22": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         Return the kerberos ticket lifetime left after getting the"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Spnego/Kerberos authentication.\"\"\"",
            "",
            "import base64",
            "from os import environ, path, remove",
            "",
            "from werkzeug.datastructures import Headers, MultiDict",
            "from flask_babel import gettext",
            "from flask import request, Response, session,\\",
            "    current_app, render_template, flash, url_for",
            "from flask_security.views import _security",
            "from flask_security.utils import logout_user",
            "from flask_security import login_required",
            "",
            "import config",
            "from pgadmin.model import User",
            "from pgadmin.tools.user_management import create_user",
            "from pgadmin.utils.constants import KERBEROS, MessageType",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error",
            "",
            "",
            "from pgadmin.authenticate.internal import BaseAuthentication",
            "from pgadmin.authenticate import get_auth_sources",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "",
            "",
            "try:",
            "    import gssapi",
            "    KERBEROS_AUTH_AVAILABLE = True",
            "except ImportError:",
            "    # Do not fail at this time, as this could be a desktop mode.",
            "    # Instead throw the runtime error, when the server attempts",
            "    # to use this authentication method.",
            "    KERBEROS_AUTH_AVAILABLE = False",
            "except OSError:",
            "    # On Windows, it fails with OSError, when KFW libraries not found.",
            "    # Instead throw the runtime error, when the server attempts",
            "    # to use this authentication method.",
            "    KERBEROS_AUTH_AVAILABLE = False",
            "",
            "# Set the Kerberos config file",
            "if config.KRB_KTNAME and config.KRB_KTNAME != '<KRB5_KEYTAB_FILE>':",
            "    environ['KRB5_KTNAME'] = config.KRB_KTNAME",
            "",
            "",
            "class KerberosModule(PgAdminModule):",
            "    def register(self, app, options):",
            "        # Do not look for the sub_modules,",
            "        # instead call blueprint.register(...) directly",
            "        super().register(app, options)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        return ['kerberos.login',",
            "                'kerberos.logout',",
            "                'kerberos.update_ticket',",
            "                'kerberos.validate_ticket']",
            "",
            "",
            "def init_app(app):",
            "    MODULE_NAME = 'kerberos'",
            "",
            "    blueprint = KerberosModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "    @blueprint.route(\"/login\",",
            "                     endpoint=\"login\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    def kerberos_login():",
            "        logout_user()",
            "        return Response(render_template(\"browser/kerberos_login.html\",",
            "                                        login_url=url_for('security.login'),",
            "                                        ))",
            "",
            "    @blueprint.route(\"/logout\",",
            "                     endpoint=\"logout\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    def kerberos_logout():",
            "        logout_user()",
            "        if 'KRB5CCNAME' in session:",
            "            # Remove the credential cache",
            "            cache_file_path = session['KRB5CCNAME'].split(\":\")[1]",
            "            if path.exists(cache_file_path):",
            "                remove(cache_file_path)",
            "",
            "        return Response(render_template(\"browser/kerberos_logout.html\",",
            "                                        login_url=url_for('security.login'),",
            "                                        ))",
            "",
            "    @blueprint.route(\"/update_ticket\",",
            "                     endpoint=\"update_ticket\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    @login_required",
            "    def kerberos_update_ticket():",
            "        \"\"\"",
            "        Update the kerberos ticket.",
            "        \"\"\"",
            "        from werkzeug.datastructures import Headers",
            "        headers = Headers()",
            "",
            "        authorization = request.headers.get(\"Authorization\", None)",
            "",
            "        if authorization is None:",
            "            # Send the Negotiate header to the client",
            "            # if Kerberos ticket is not found.",
            "            headers.add('WWW-Authenticate', 'Negotiate')",
            "            return Response(\"Unauthorised\", 401, headers)",
            "        else:",
            "            source = get_auth_sources(KERBEROS)",
            "            auth_header = authorization.split()",
            "            in_token = auth_header[1]",
            "",
            "            # Validate the Kerberos ticket",
            "            status, context = source.negotiate_start(in_token)",
            "            if status:",
            "                return Response(\"Ticket updated successfully.\")",
            "",
            "            return Response(context, 500)",
            "",
            "    @blueprint.route(\"/validate_ticket\",",
            "                     endpoint=\"validate_ticket\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    @login_required",
            "    def kerberos_validate_ticket():",
            "        \"\"\"",
            "        Return the kerberos ticket lifetime left after getting the",
            "        ticket from the credential cache",
            "        \"\"\"",
            "        import gssapi",
            "",
            "        try:",
            "            del_creds = gssapi.Credentials(store={",
            "                'ccache': session['KRB5CCNAME']})",
            "            creds = del_creds.acquire(store={'ccache': session['KRB5CCNAME']})",
            "        except Exception as e:",
            "            current_app.logger.exception(e)",
            "            return internal_server_error(errormsg=str(e))",
            "",
            "        return make_json_response(",
            "            data={'ticket_lifetime': creds.lifetime},",
            "            status=200",
            "        )",
            "",
            "    app.register_blueprint(blueprint)",
            "",
            "",
            "class KerberosAuthentication(BaseAuthentication):",
            "",
            "    LOGIN_VIEW = 'kerberos.login'",
            "    LOGOUT_VIEW = 'kerberos.logout'",
            "",
            "    def get_source_name(self):",
            "        return KERBEROS",
            "",
            "    def get_friendly_name(self):",
            "        return gettext(\"kerberos\")",
            "",
            "    def validate(self, form):",
            "        return True, None",
            "",
            "    def authenticate(self, frm):",
            "",
            "        if KERBEROS_AUTH_AVAILABLE is not True:",
            "            raise RuntimeError(gettext(",
            "                \"Kerberos authentication can't be used as\"",
            "                \" GSSAPI module couldn't be loaded.\"",
            "            ))",
            "",
            "        retval = [True, None]",
            "        negotiate = False",
            "        headers = Headers()",
            "        authorization = request.headers.get(\"Authorization\", None)",
            "        form_class = _security.forms.get('login_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if req_json:",
            "            form = form_class(MultiDict(req_json))",
            "        else:",
            "            form = form_class()",
            "",
            "        try:",
            "            if authorization is not None:",
            "                auth_header = authorization.split()",
            "                if auth_header[0] == 'Negotiate':",
            "                    status, negotiate = self.negotiate_start(auth_header[1])",
            "",
            "                    if status:",
            "                        # Saving the first 15 characters of the kerberos key",
            "                        # to encrypt/decrypt database password",
            "                        session['pass_enc_key'] = auth_header[1][0:15]",
            "                        # Create user",
            "                        retval = self.__auto_create_user(",
            "                            str(negotiate.initiator_name))",
            "                    elif isinstance(negotiate, Exception):",
            "                        flash(gettext(negotiate), MessageType.ERROR)",
            "                        retval = [status,",
            "                                  Response(render_template(",
            "                                      \"security/login_user.html\",",
            "                                      login_user_form=form))]",
            "                    else:",
            "                        headers.add('WWW-Authenticate', 'Negotiate ' +",
            "                                    str(base64.b64encode(negotiate), 'utf-8'))",
            "                        return False, Response(\"Success\", 200, headers)",
            "            else:",
            "                flash(gettext(\"Kerberos authentication failed. Couldn't find \"",
            "                              \"kerberos ticket.\"), MessageType.ERROR)",
            "                headers.add('WWW-Authenticate', 'Negotiate')",
            "                retval = [False,",
            "                          Response(render_template(",
            "                              \"security/login_user.html\",",
            "                              login_user_form=form), 401, headers)]",
            "        finally:",
            "            if negotiate is not False:",
            "                self.negotiate_end(negotiate)",
            "        return retval",
            "",
            "    def negotiate_start(self, in_token):",
            "        svc_princ = gssapi.Name('HTTP@%s' % config.KRB_APP_HOST_NAME,",
            "                                name_type=gssapi.NameType.hostbased_service)",
            "        cname = svc_princ.canonicalize(gssapi.MechType.kerberos)",
            "",
            "        try:",
            "            server_creds = gssapi.Credentials(usage='accept', name=cname)",
            "            context = gssapi.SecurityContext(creds=server_creds)",
            "            out_token = context.step(base64.b64decode(in_token))",
            "        except Exception as e:",
            "            current_app.logger.exception(e)",
            "            return False, e",
            "",
            "        if out_token and not context.complete:",
            "            return False, out_token",
            "        if context.complete:",
            "            deleg_creds = context.delegated_creds",
            "            if not hasattr(deleg_creds, 'name'):",
            "                error_msg = gettext('Delegated credentials not supplied.')",
            "                current_app.logger.error(error_msg)",
            "                return False, Exception(error_msg)",
            "            try:",
            "                cache_file_path = path.join(",
            "                    config.KERBEROS_CCACHE_DIR, 'pgadmin_cache_{0}'.format(",
            "                        deleg_creds.name)",
            "                )",
            "                CCACHE = 'FILE:{0}'.format(cache_file_path)",
            "                store = {'ccache': CCACHE}",
            "                deleg_creds.store(store, overwrite=True, set_default=True)",
            "                session['KRB5CCNAME'] = CCACHE",
            "            except Exception as e:",
            "                current_app.logger.exception(e)",
            "                return False, e",
            "",
            "            return True, context",
            "        else:",
            "            return False, None",
            "",
            "    def negotiate_end(self, context):",
            "        # Free Delegated Credentials",
            "        del_creds = getattr(context, 'delegated_creds', None)",
            "        if del_creds:",
            "            deleg_creds = context.delegated_creds",
            "            del deleg_creds",
            "",
            "    def __auto_create_user(self, username):",
            "        \"\"\"Add the kerberos user to the internal SQLite database.\"\"\"",
            "        username = str(username)",
            "        if config.KRB_AUTO_CREATE_USER:",
            "            user = User.query.filter_by(",
            "                username=username, auth_source=KERBEROS).first()",
            "            if user is None:",
            "                create_msg = (\"Creating user {0} with email {1} \"",
            "                              \"from auth source KERBEROS.\")",
            "                current_app.logger.info(create_msg.format(username,",
            "                                                          username))",
            "                return create_user({",
            "                    'username': username,",
            "                    'email': username,",
            "                    'role': 2,",
            "                    'active': True,",
            "                    'auth_source': KERBEROS",
            "                })",
            "",
            "        return True, {'username': username}"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Spnego/Kerberos authentication.\"\"\"",
            "",
            "import base64",
            "from os import environ, path, remove",
            "",
            "from werkzeug.datastructures import Headers, MultiDict",
            "from flask_babel import gettext",
            "from flask import request, Response, session,\\",
            "    current_app, render_template, flash, url_for",
            "from flask_security.views import _security",
            "from flask_security.utils import logout_user",
            "from pgadmin.user_login_check import pga_login_required",
            "",
            "import config",
            "from pgadmin.model import User",
            "from pgadmin.tools.user_management import create_user",
            "from pgadmin.utils.constants import KERBEROS, MessageType",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error",
            "",
            "",
            "from pgadmin.authenticate.internal import BaseAuthentication",
            "from pgadmin.authenticate import get_auth_sources",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "",
            "",
            "try:",
            "    import gssapi",
            "    KERBEROS_AUTH_AVAILABLE = True",
            "except ImportError:",
            "    # Do not fail at this time, as this could be a desktop mode.",
            "    # Instead throw the runtime error, when the server attempts",
            "    # to use this authentication method.",
            "    KERBEROS_AUTH_AVAILABLE = False",
            "except OSError:",
            "    # On Windows, it fails with OSError, when KFW libraries not found.",
            "    # Instead throw the runtime error, when the server attempts",
            "    # to use this authentication method.",
            "    KERBEROS_AUTH_AVAILABLE = False",
            "",
            "# Set the Kerberos config file",
            "if config.KRB_KTNAME and config.KRB_KTNAME != '<KRB5_KEYTAB_FILE>':",
            "    environ['KRB5_KTNAME'] = config.KRB_KTNAME",
            "",
            "",
            "class KerberosModule(PgAdminModule):",
            "    def register(self, app, options):",
            "        # Do not look for the sub_modules,",
            "        # instead call blueprint.register(...) directly",
            "        super().register(app, options)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        return ['kerberos.login',",
            "                'kerberos.logout',",
            "                'kerberos.update_ticket',",
            "                'kerberos.validate_ticket']",
            "",
            "",
            "def init_app(app):",
            "    MODULE_NAME = 'kerberos'",
            "",
            "    blueprint = KerberosModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "    @blueprint.route(\"/login\",",
            "                     endpoint=\"login\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    def kerberos_login():",
            "        logout_user()",
            "        return Response(render_template(\"browser/kerberos_login.html\",",
            "                                        login_url=url_for('security.login'),",
            "                                        ))",
            "",
            "    @blueprint.route(\"/logout\",",
            "                     endpoint=\"logout\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    def kerberos_logout():",
            "        logout_user()",
            "        if 'KRB5CCNAME' in session:",
            "            # Remove the credential cache",
            "            cache_file_path = session['KRB5CCNAME'].split(\":\")[1]",
            "            if path.exists(cache_file_path):",
            "                remove(cache_file_path)",
            "",
            "        return Response(render_template(\"browser/kerberos_logout.html\",",
            "                                        login_url=url_for('security.login'),",
            "                                        ))",
            "",
            "    @blueprint.route(\"/update_ticket\",",
            "                     endpoint=\"update_ticket\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    @pga_login_required",
            "    def kerberos_update_ticket():",
            "        \"\"\"",
            "        Update the kerberos ticket.",
            "        \"\"\"",
            "        from werkzeug.datastructures import Headers",
            "        headers = Headers()",
            "",
            "        authorization = request.headers.get(\"Authorization\", None)",
            "",
            "        if authorization is None:",
            "            # Send the Negotiate header to the client",
            "            # if Kerberos ticket is not found.",
            "            headers.add('WWW-Authenticate', 'Negotiate')",
            "            return Response(\"Unauthorised\", 401, headers)",
            "        else:",
            "            source = get_auth_sources(KERBEROS)",
            "            auth_header = authorization.split()",
            "            in_token = auth_header[1]",
            "",
            "            # Validate the Kerberos ticket",
            "            status, context = source.negotiate_start(in_token)",
            "            if status:",
            "                return Response(\"Ticket updated successfully.\")",
            "",
            "            return Response(context, 500)",
            "",
            "    @blueprint.route(\"/validate_ticket\",",
            "                     endpoint=\"validate_ticket\", methods=[\"GET\"])",
            "    @pgCSRFProtect.exempt",
            "    @pga_login_required",
            "    def kerberos_validate_ticket():",
            "        \"\"\"",
            "        Return the kerberos ticket lifetime left after getting the",
            "        ticket from the credential cache",
            "        \"\"\"",
            "        import gssapi",
            "",
            "        try:",
            "            del_creds = gssapi.Credentials(store={",
            "                'ccache': session['KRB5CCNAME']})",
            "            creds = del_creds.acquire(store={'ccache': session['KRB5CCNAME']})",
            "        except Exception as e:",
            "            current_app.logger.exception(e)",
            "            return internal_server_error(errormsg=str(e))",
            "",
            "        return make_json_response(",
            "            data={'ticket_lifetime': creds.lifetime},",
            "            status=200",
            "        )",
            "",
            "    app.register_blueprint(blueprint)",
            "",
            "",
            "class KerberosAuthentication(BaseAuthentication):",
            "",
            "    LOGIN_VIEW = 'kerberos.login'",
            "    LOGOUT_VIEW = 'kerberos.logout'",
            "",
            "    def get_source_name(self):",
            "        return KERBEROS",
            "",
            "    def get_friendly_name(self):",
            "        return gettext(\"kerberos\")",
            "",
            "    def validate(self, form):",
            "        return True, None",
            "",
            "    def authenticate(self, frm):",
            "",
            "        if KERBEROS_AUTH_AVAILABLE is not True:",
            "            raise RuntimeError(gettext(",
            "                \"Kerberos authentication can't be used as\"",
            "                \" GSSAPI module couldn't be loaded.\"",
            "            ))",
            "",
            "        retval = [True, None]",
            "        negotiate = False",
            "        headers = Headers()",
            "        authorization = request.headers.get(\"Authorization\", None)",
            "        form_class = _security.forms.get('login_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if req_json:",
            "            form = form_class(MultiDict(req_json))",
            "        else:",
            "            form = form_class()",
            "",
            "        try:",
            "            if authorization is not None:",
            "                auth_header = authorization.split()",
            "                if auth_header[0] == 'Negotiate':",
            "                    status, negotiate = self.negotiate_start(auth_header[1])",
            "",
            "                    if status:",
            "                        # Saving the first 15 characters of the kerberos key",
            "                        # to encrypt/decrypt database password",
            "                        session['pass_enc_key'] = auth_header[1][0:15]",
            "                        # Create user",
            "                        retval = self.__auto_create_user(",
            "                            str(negotiate.initiator_name))",
            "                    elif isinstance(negotiate, Exception):",
            "                        flash(gettext(negotiate), MessageType.ERROR)",
            "                        retval = [status,",
            "                                  Response(render_template(",
            "                                      \"security/login_user.html\",",
            "                                      login_user_form=form))]",
            "                    else:",
            "                        headers.add('WWW-Authenticate', 'Negotiate ' +",
            "                                    str(base64.b64encode(negotiate), 'utf-8'))",
            "                        return False, Response(\"Success\", 200, headers)",
            "            else:",
            "                flash(gettext(\"Kerberos authentication failed. Couldn't find \"",
            "                              \"kerberos ticket.\"), MessageType.ERROR)",
            "                headers.add('WWW-Authenticate', 'Negotiate')",
            "                retval = [False,",
            "                          Response(render_template(",
            "                              \"security/login_user.html\",",
            "                              login_user_form=form), 401, headers)]",
            "        finally:",
            "            if negotiate is not False:",
            "                self.negotiate_end(negotiate)",
            "        return retval",
            "",
            "    def negotiate_start(self, in_token):",
            "        svc_princ = gssapi.Name('HTTP@%s' % config.KRB_APP_HOST_NAME,",
            "                                name_type=gssapi.NameType.hostbased_service)",
            "        cname = svc_princ.canonicalize(gssapi.MechType.kerberos)",
            "",
            "        try:",
            "            server_creds = gssapi.Credentials(usage='accept', name=cname)",
            "            context = gssapi.SecurityContext(creds=server_creds)",
            "            out_token = context.step(base64.b64decode(in_token))",
            "        except Exception as e:",
            "            current_app.logger.exception(e)",
            "            return False, e",
            "",
            "        if out_token and not context.complete:",
            "            return False, out_token",
            "        if context.complete:",
            "            deleg_creds = context.delegated_creds",
            "            if not hasattr(deleg_creds, 'name'):",
            "                error_msg = gettext('Delegated credentials not supplied.')",
            "                current_app.logger.error(error_msg)",
            "                return False, Exception(error_msg)",
            "            try:",
            "                cache_file_path = path.join(",
            "                    config.KERBEROS_CCACHE_DIR, 'pgadmin_cache_{0}'.format(",
            "                        deleg_creds.name)",
            "                )",
            "                CCACHE = 'FILE:{0}'.format(cache_file_path)",
            "                store = {'ccache': CCACHE}",
            "                deleg_creds.store(store, overwrite=True, set_default=True)",
            "                session['KRB5CCNAME'] = CCACHE",
            "            except Exception as e:",
            "                current_app.logger.exception(e)",
            "                return False, e",
            "",
            "            return True, context",
            "        else:",
            "            return False, None",
            "",
            "    def negotiate_end(self, context):",
            "        # Free Delegated Credentials",
            "        del_creds = getattr(context, 'delegated_creds', None)",
            "        if del_creds:",
            "            deleg_creds = context.delegated_creds",
            "            del deleg_creds",
            "",
            "    def __auto_create_user(self, username):",
            "        \"\"\"Add the kerberos user to the internal SQLite database.\"\"\"",
            "        username = str(username)",
            "        if config.KRB_AUTO_CREATE_USER:",
            "            user = User.query.filter_by(",
            "                username=username, auth_source=KERBEROS).first()",
            "            if user is None:",
            "                create_msg = (\"Creating user {0} with email {1} \"",
            "                              \"from auth source KERBEROS.\")",
            "                current_app.logger.info(create_msg.format(username,",
            "                                                          username))",
            "                return create_user({",
            "                    'username': username,",
            "                    'email': username,",
            "                    'role': 2,",
            "                    'active': True,",
            "                    'auth_source': KERBEROS",
            "                })",
            "",
            "        return True, {'username': username}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "100": [
                "init_app"
            ],
            "130": [
                "init_app"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/authenticate/mfa/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from flask import url_for, session, request, redirect"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from flask_login.utils import login_url"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_security import current_user"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from flask_security import current_user, login_required"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import config"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pgadmin.model import UserMFA, db"
            },
            "8": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         registration_url = url_for('mfa.register')"
            },
            "9": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         if next_url.startswith(registration_url):"
            },
            "11": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return url('browser.index')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+            return url_for('browser.index')"
            },
            "13": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         return next_url"
            },
            "15": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "         return redirect(login_url(\"mfa.register\", next_url=get_next_url()))"
            },
            "17": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "     @wraps(wrapped)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+    @login_required"
            },
            "20": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "     def inner(*args, **kwargs):"
            },
            "21": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "22": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         def execute_func():"
            },
            "23": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "             session['mfa_authenticated'] = True"
            },
            "24": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "             return wrapped(*args, **kwargs)"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##############################################################################",
            "\"\"\"Multi-factor Authentication (MFA) utility functions\"\"\"",
            "",
            "from collections.abc import Callable",
            "from functools import wraps",
            "",
            "from flask import url_for, session, request, redirect",
            "from flask_login.utils import login_url",
            "from flask_security import current_user",
            "",
            "import config",
            "from pgadmin.model import UserMFA, db",
            "from .registry import MultiFactorAuthRegistry",
            "",
            "",
            "class ValidationException(Exception):",
            "    \"\"\"",
            "    class: ValidationException",
            "    Base class: Exception",
            "",
            "    An exception class for raising validation issue.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "def segregate_valid_and_invalid_mfa_methods(",
            "    mfa_supported_methods: list",
            ") -> (list, list):",
            "    \"\"\"",
            "    Segregate the valid and invalid authentication methods from the given",
            "    methods.",
            "",
            "    Args:",
            "        mfa_supported_methods (list): List of auth methods",
            "",
            "    Returns:",
            "        list, list: Set of valid & invalid auth methods",
            "    \"\"\"",
            "",
            "    invalid_auth_methods = []",
            "    valid_auth_methods = []",
            "",
            "    for mfa in mfa_supported_methods:",
            "",
            "        # Put invalid MFA method in separate list",
            "        if mfa not in MultiFactorAuthRegistry._registry:",
            "            if mfa not in invalid_auth_methods:",
            "                invalid_auth_methods.append(mfa)",
            "            continue",
            "",
            "        # Exclude the duplicate entries",
            "        if mfa in valid_auth_methods:",
            "            continue",
            "",
            "        valid_auth_methods.append(mfa)",
            "",
            "    return valid_auth_methods, invalid_auth_methods",
            "",
            "",
            "def mfa_suppored_methods() -> dict:",
            "    \"\"\"",
            "    Returns the dictionary containing information on all supported methods with",
            "    information about whether they're registered for the current user, or not.",
            "",
            "    It returns information in this format:",
            "    {",
            "        <auth_method_name>: {",
            "            \"mfa\": <MFA Auth Object>,",
            "            \"registered\": True|False",
            "        },",
            "        ...",
            "    }",
            "",
            "    Returns:",
            "        dict: List of all supported MFA methods with the flag for the",
            "              registered with the current user or not.",
            "    \"\"\"",
            "    supported_mfa_auth_methods = dict()",
            "",
            "    for auth_method in config.MFA_SUPPORTED_METHODS:",
            "        registry = MultiFactorAuthRegistry.get(auth_method)",
            "        supported_mfa_auth_methods[registry.name] = {",
            "            \"mfa\": registry, \"registered\": False",
            "        }",
            "",
            "    auths = UserMFA.query.filter_by(user_id=current_user.id).all()",
            "",
            "    for auth in auths:",
            "        if auth.mfa_auth in supported_mfa_auth_methods:",
            "            supported_mfa_auth_methods[auth.mfa_auth]['registered'] = True",
            "",
            "    return supported_mfa_auth_methods",
            "",
            "",
            "def user_supported_mfa_methods():",
            "    \"\"\"",
            "    Returns the dict for the authentication methods, registered for the",
            "    current user, among the list of supported.",
            "",
            "    Returns:",
            "        dict: dict for the auth methods",
            "    \"\"\"",
            "    auths = UserMFA.query.filter_by(user_id=current_user.id).all()",
            "    res = dict()",
            "    supported_mfa_auth_methods = dict()",
            "",
            "    if len(auths) > 0:",
            "        for auth_method in config.MFA_SUPPORTED_METHODS:",
            "            registry = MultiFactorAuthRegistry.get(auth_method)",
            "            supported_mfa_auth_methods[registry.name] = registry",
            "",
            "        for auth in auths:",
            "            if auth.mfa_auth in supported_mfa_auth_methods:",
            "                res[auth.mfa_auth] = \\",
            "                    supported_mfa_auth_methods[auth.mfa_auth]",
            "",
            "    return res",
            "",
            "",
            "def is_mfa_session_authenticated() -> bool:",
            "    \"\"\"",
            "    Checks if this session is authenticated, or not.",
            "",
            "    Returns:",
            "        bool: Is this session authenticated?",
            "    \"\"\"",
            "    return session.get('mfa_authenticated', False) is True",
            "",
            "",
            "def mfa_enabled(execute_if_enabled, execute_if_disabled) -> None:",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    configuration for the MFA.",
            "",
            "    When MFA is enabled and has a valid supported auth methods,",
            "    'execute_if_enabled' method is executed, otherwise -",
            "    'execute_if_disabled' method is executed.",
            "",
            "    Args:",
            "        execute_if_enabled (Callable[[], None]):  Method to executed when MFA",
            "                                                  is enabled.",
            "        execute_if_disabled (Callable[[], None]): Method to be executed when",
            "                                                  MFA is disabled.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "",
            "    is_server_mode = getattr(config, 'SERVER_MODE', False)",
            "    enabled = getattr(config, \"MFA_ENABLED\", False)",
            "    supported_methods = getattr(config, \"MFA_SUPPORTED_METHODS\", [])",
            "",
            "    if is_server_mode is True and enabled is True and \\",
            "            isinstance(supported_methods, list):",
            "        supported_methods, _ = segregate_valid_and_invalid_mfa_methods(",
            "            supported_methods",
            "        )",
            "",
            "        if len(supported_methods) > 0:",
            "            return execute_if_enabled()",
            "",
            "    return execute_if_disabled()",
            "",
            "",
            "def mfa_user_force_registration_required(register, not_register) -> None:",
            "    \"\"\"",
            "    A ternary method to cenable calling either of the methods based on the",
            "    condition force registration is required.",
            "",
            "    When force registration is enabled, and the current user has not registered",
            "    for any of the supported authentication method, then the 'register' method",
            "    is executed, otherwise - 'not_register' method is executed.",
            "",
            "    Args:",
            "        register (Callable[[], None])    : Method to be executed when for",
            "                                           registration required and user has",
            "                                           not registered for any auth method.",
            "        not_register (Callable[[], None]): Method to be executed otherwise.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "    \"\"\"",
            "    return register() \\",
            "        if getattr(config, \"MFA_FORCE_REGISTRATION\", False) is True else \\",
            "        not_register()",
            "",
            "",
            "def mfa_user_registered(registered, not_registered) -> None:",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    condition - if the user is registed for any of the auth methods.",
            "",
            "    When current user is registered for any of the supported auth method, then",
            "    the 'registered' method is executed, otherwise - 'not_registered' method is",
            "    executed.",
            "",
            "    Args:",
            "        registered (Callable[[], None])    : Method to be executed when",
            "                                             registered.",
            "        not_registered (Callable[[], None]): Method to be executed when not",
            "                                             registered",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "",
            "    return registered() if len(user_supported_mfa_methods()) > 0 else \\",
            "        not_registered()",
            "",
            "",
            "def mfa_session_authenticated(authenticated, unauthenticated):",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    condition - if the user has already authenticated, or not.",
            "",
            "    When current user is already authenticated, then 'authenticated' method is",
            "    executed, otherwise - 'unauthenticated' method is executed.",
            "",
            "    Args:",
            "        authenticated (Callable[[], None])  : Method to be executed when",
            "                                              user is authenticated.",
            "        unauthenticated (Callable[[], None]): Method to be executed when the",
            "                                              user is not passed the",
            "                                              authentication.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "    return authenticated() if session.get('mfa_authenticated', False) is True \\",
            "        else unauthenticated()",
            "",
            "",
            "def mfa_required(wrapped):",
            "    \"\"\"",
            "    A decorator do decide the next course of action when a page is being",
            "    opened, it will open the appropriate page in case the 2FA is not passed.",
            "",
            "    Function executed",
            "        |",
            "    Check for MFA Enabled? --------+",
            "        |                          |",
            "        | No                       |",
            "        |                          | Yes",
            "    Run the wrapped function [END] |",
            "                                   |",
            "        Is user has registered for at least one MFA method? -+",
            "                    |                                        |",
            "                    | No                                     |",
            "                    |                                        |",
            "        Is force registration required? -+                   |",
            "                    |                    |                   | Yes",
            "                    | No                 |                   |",
            "                    |                    | Yes               |",
            "        Run the wrapped function [END]   |                   |",
            "                                         |                   |",
            "                            Open Registration page [END]     |",
            "                                                              |",
            "                                          Open the authentication page [END]",
            "",
            "    Args:",
            "        func(Callable[..]): Method to be called if authentcation is passed",
            "    \"\"\"",
            "",
            "    def get_next_url():",
            "        next_url = request.url",
            "        registration_url = url_for('mfa.register')",
            "",
            "        if next_url.startswith(registration_url):",
            "            return url('browser.index')",
            "",
            "        return next_url",
            "",
            "    def redirect_to_mfa_validate_url():",
            "        return redirect(login_url(\"mfa.validate\", next_url=get_next_url()))",
            "",
            "    def redirect_to_mfa_registration():",
            "        return redirect(login_url(\"mfa.register\", next_url=get_next_url()))",
            "",
            "    @wraps(wrapped)",
            "    def inner(*args, **kwargs):",
            "",
            "        def execute_func():",
            "            session['mfa_authenticated'] = True",
            "            return wrapped(*args, **kwargs)",
            "",
            "        def if_else_func(_func, first, second):",
            "            def if_else_func_inner():",
            "                return _func(first, second)",
            "            return if_else_func_inner",
            "",
            "        return mfa_enabled(",
            "            if_else_func(",
            "                mfa_session_authenticated,",
            "                execute_func,",
            "                if_else_func(",
            "                    mfa_user_registered,",
            "                    redirect_to_mfa_validate_url,",
            "                    if_else_func(",
            "                        mfa_user_force_registration_required,",
            "                        redirect_to_mfa_registration,",
            "                        execute_func",
            "                    )",
            "                )",
            "            ),",
            "            execute_func",
            "        )",
            "",
            "    return inner",
            "",
            "",
            "def is_mfa_enabled() -> bool:",
            "    \"\"\"",
            "    Returns True if MFA is enabled otherwise False",
            "",
            "    Returns:",
            "        bool: Is MFA Enabled?",
            "    \"\"\"",
            "    return mfa_enabled(lambda: True, lambda: False)",
            "",
            "",
            "def mfa_delete(auth_name: str) -> bool:",
            "    \"\"\"",
            "    A utility function to delete the auth method for the current user from the",
            "    configuration database.",
            "",
            "    Args:",
            "        auth_name (str): Name of the argument",
            "",
            "    Returns:",
            "        bool: True if auth method was registered for the current user, and",
            "              delete successfully, otherwise - False",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    )",
            "",
            "    if int(auth.count()) != 0:",
            "        auth.delete()",
            "        db.session.commit()",
            "",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def mfa_add(auth_name: str, options: str) -> None:",
            "    \"\"\"",
            "    A utility funtion to add/update the auth method in the configuration",
            "    database for the current user with the method specific options.",
            "",
            "    e.g. email-address for 'email' method, and 'secret' for the 'authenticator'",
            "",
            "    Args:",
            "        auth_name (str): Name of the auth method",
            "        options (str)  : A data options specific to the auth method",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    ).first()",
            "",
            "    if auth is None:",
            "        auth = UserMFA(",
            "            user_id=current_user.id,",
            "            mfa_auth=auth_name,",
            "            options=options",
            "        )",
            "        db.session.add(auth)",
            "",
            "    # We will override the existing options",
            "    auth.options = options",
            "",
            "    db.session.commit()",
            "",
            "",
            "def fetch_auth_option(auth_name: str) -> (str, bool):",
            "    \"\"\"",
            "    A utility function to fetch the extra data, stored as options, for the",
            "    given auth method for the current user.",
            "",
            "    Returns a set as (data, Auth method registered?)",
            "",
            "    Args:",
            "        auth_name (str): Name of the auth method",
            "",
            "    Returns:",
            "        (str, bool): (data, has current user registered for the auth method?)",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    ).first()",
            "",
            "    if auth is None:",
            "        return None, False",
            "",
            "    return auth.options, True"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##############################################################################",
            "\"\"\"Multi-factor Authentication (MFA) utility functions\"\"\"",
            "",
            "from collections.abc import Callable",
            "from functools import wraps",
            "",
            "from flask import url_for, session, request, redirect",
            "from flask_login.utils import login_url",
            "from flask_security import current_user, login_required",
            "",
            "import config",
            "from pgadmin.model import UserMFA, db",
            "from .registry import MultiFactorAuthRegistry",
            "",
            "",
            "class ValidationException(Exception):",
            "    \"\"\"",
            "    class: ValidationException",
            "    Base class: Exception",
            "",
            "    An exception class for raising validation issue.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "def segregate_valid_and_invalid_mfa_methods(",
            "    mfa_supported_methods: list",
            ") -> (list, list):",
            "    \"\"\"",
            "    Segregate the valid and invalid authentication methods from the given",
            "    methods.",
            "",
            "    Args:",
            "        mfa_supported_methods (list): List of auth methods",
            "",
            "    Returns:",
            "        list, list: Set of valid & invalid auth methods",
            "    \"\"\"",
            "",
            "    invalid_auth_methods = []",
            "    valid_auth_methods = []",
            "",
            "    for mfa in mfa_supported_methods:",
            "",
            "        # Put invalid MFA method in separate list",
            "        if mfa not in MultiFactorAuthRegistry._registry:",
            "            if mfa not in invalid_auth_methods:",
            "                invalid_auth_methods.append(mfa)",
            "            continue",
            "",
            "        # Exclude the duplicate entries",
            "        if mfa in valid_auth_methods:",
            "            continue",
            "",
            "        valid_auth_methods.append(mfa)",
            "",
            "    return valid_auth_methods, invalid_auth_methods",
            "",
            "",
            "def mfa_suppored_methods() -> dict:",
            "    \"\"\"",
            "    Returns the dictionary containing information on all supported methods with",
            "    information about whether they're registered for the current user, or not.",
            "",
            "    It returns information in this format:",
            "    {",
            "        <auth_method_name>: {",
            "            \"mfa\": <MFA Auth Object>,",
            "            \"registered\": True|False",
            "        },",
            "        ...",
            "    }",
            "",
            "    Returns:",
            "        dict: List of all supported MFA methods with the flag for the",
            "              registered with the current user or not.",
            "    \"\"\"",
            "    supported_mfa_auth_methods = dict()",
            "",
            "    for auth_method in config.MFA_SUPPORTED_METHODS:",
            "        registry = MultiFactorAuthRegistry.get(auth_method)",
            "        supported_mfa_auth_methods[registry.name] = {",
            "            \"mfa\": registry, \"registered\": False",
            "        }",
            "",
            "    auths = UserMFA.query.filter_by(user_id=current_user.id).all()",
            "",
            "    for auth in auths:",
            "        if auth.mfa_auth in supported_mfa_auth_methods:",
            "            supported_mfa_auth_methods[auth.mfa_auth]['registered'] = True",
            "",
            "    return supported_mfa_auth_methods",
            "",
            "",
            "def user_supported_mfa_methods():",
            "    \"\"\"",
            "    Returns the dict for the authentication methods, registered for the",
            "    current user, among the list of supported.",
            "",
            "    Returns:",
            "        dict: dict for the auth methods",
            "    \"\"\"",
            "    auths = UserMFA.query.filter_by(user_id=current_user.id).all()",
            "    res = dict()",
            "    supported_mfa_auth_methods = dict()",
            "",
            "    if len(auths) > 0:",
            "        for auth_method in config.MFA_SUPPORTED_METHODS:",
            "            registry = MultiFactorAuthRegistry.get(auth_method)",
            "            supported_mfa_auth_methods[registry.name] = registry",
            "",
            "        for auth in auths:",
            "            if auth.mfa_auth in supported_mfa_auth_methods:",
            "                res[auth.mfa_auth] = \\",
            "                    supported_mfa_auth_methods[auth.mfa_auth]",
            "",
            "    return res",
            "",
            "",
            "def is_mfa_session_authenticated() -> bool:",
            "    \"\"\"",
            "    Checks if this session is authenticated, or not.",
            "",
            "    Returns:",
            "        bool: Is this session authenticated?",
            "    \"\"\"",
            "    return session.get('mfa_authenticated', False) is True",
            "",
            "",
            "def mfa_enabled(execute_if_enabled, execute_if_disabled) -> None:",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    configuration for the MFA.",
            "",
            "    When MFA is enabled and has a valid supported auth methods,",
            "    'execute_if_enabled' method is executed, otherwise -",
            "    'execute_if_disabled' method is executed.",
            "",
            "    Args:",
            "        execute_if_enabled (Callable[[], None]):  Method to executed when MFA",
            "                                                  is enabled.",
            "        execute_if_disabled (Callable[[], None]): Method to be executed when",
            "                                                  MFA is disabled.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "",
            "    is_server_mode = getattr(config, 'SERVER_MODE', False)",
            "    enabled = getattr(config, \"MFA_ENABLED\", False)",
            "    supported_methods = getattr(config, \"MFA_SUPPORTED_METHODS\", [])",
            "",
            "    if is_server_mode is True and enabled is True and \\",
            "            isinstance(supported_methods, list):",
            "        supported_methods, _ = segregate_valid_and_invalid_mfa_methods(",
            "            supported_methods",
            "        )",
            "",
            "        if len(supported_methods) > 0:",
            "            return execute_if_enabled()",
            "",
            "    return execute_if_disabled()",
            "",
            "",
            "def mfa_user_force_registration_required(register, not_register) -> None:",
            "    \"\"\"",
            "    A ternary method to cenable calling either of the methods based on the",
            "    condition force registration is required.",
            "",
            "    When force registration is enabled, and the current user has not registered",
            "    for any of the supported authentication method, then the 'register' method",
            "    is executed, otherwise - 'not_register' method is executed.",
            "",
            "    Args:",
            "        register (Callable[[], None])    : Method to be executed when for",
            "                                           registration required and user has",
            "                                           not registered for any auth method.",
            "        not_register (Callable[[], None]): Method to be executed otherwise.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "    \"\"\"",
            "    return register() \\",
            "        if getattr(config, \"MFA_FORCE_REGISTRATION\", False) is True else \\",
            "        not_register()",
            "",
            "",
            "def mfa_user_registered(registered, not_registered) -> None:",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    condition - if the user is registed for any of the auth methods.",
            "",
            "    When current user is registered for any of the supported auth method, then",
            "    the 'registered' method is executed, otherwise - 'not_registered' method is",
            "    executed.",
            "",
            "    Args:",
            "        registered (Callable[[], None])    : Method to be executed when",
            "                                             registered.",
            "        not_registered (Callable[[], None]): Method to be executed when not",
            "                                             registered",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "",
            "    return registered() if len(user_supported_mfa_methods()) > 0 else \\",
            "        not_registered()",
            "",
            "",
            "def mfa_session_authenticated(authenticated, unauthenticated):",
            "    \"\"\"",
            "    A ternary method to enable calling either of the methods based on the",
            "    condition - if the user has already authenticated, or not.",
            "",
            "    When current user is already authenticated, then 'authenticated' method is",
            "    executed, otherwise - 'unauthenticated' method is executed.",
            "",
            "    Args:",
            "        authenticated (Callable[[], None])  : Method to be executed when",
            "                                              user is authenticated.",
            "        unauthenticated (Callable[[], None]): Method to be executed when the",
            "                                              user is not passed the",
            "                                              authentication.",
            "",
            "    Returns:",
            "        None: Expecting the methods to return None as it will not be consumed.",
            "",
            "    NOTE: Removed the typing anotation as it was giving errors.",
            "    \"\"\"",
            "    return authenticated() if session.get('mfa_authenticated', False) is True \\",
            "        else unauthenticated()",
            "",
            "",
            "def mfa_required(wrapped):",
            "    \"\"\"",
            "    A decorator do decide the next course of action when a page is being",
            "    opened, it will open the appropriate page in case the 2FA is not passed.",
            "",
            "    Function executed",
            "        |",
            "    Check for MFA Enabled? --------+",
            "        |                          |",
            "        | No                       |",
            "        |                          | Yes",
            "    Run the wrapped function [END] |",
            "                                   |",
            "        Is user has registered for at least one MFA method? -+",
            "                    |                                        |",
            "                    | No                                     |",
            "                    |                                        |",
            "        Is force registration required? -+                   |",
            "                    |                    |                   | Yes",
            "                    | No                 |                   |",
            "                    |                    | Yes               |",
            "        Run the wrapped function [END]   |                   |",
            "                                         |                   |",
            "                            Open Registration page [END]     |",
            "                                                              |",
            "                                          Open the authentication page [END]",
            "",
            "    Args:",
            "        func(Callable[..]): Method to be called if authentcation is passed",
            "    \"\"\"",
            "",
            "    def get_next_url():",
            "        next_url = request.url",
            "        registration_url = url_for('mfa.register')",
            "",
            "        if next_url.startswith(registration_url):",
            "            return url_for('browser.index')",
            "",
            "        return next_url",
            "",
            "    def redirect_to_mfa_validate_url():",
            "        return redirect(login_url(\"mfa.validate\", next_url=get_next_url()))",
            "",
            "    def redirect_to_mfa_registration():",
            "        return redirect(login_url(\"mfa.register\", next_url=get_next_url()))",
            "",
            "    @wraps(wrapped)",
            "    @login_required",
            "    def inner(*args, **kwargs):",
            "        def execute_func():",
            "            session['mfa_authenticated'] = True",
            "            return wrapped(*args, **kwargs)",
            "",
            "        def if_else_func(_func, first, second):",
            "            def if_else_func_inner():",
            "                return _func(first, second)",
            "            return if_else_func_inner",
            "",
            "        return mfa_enabled(",
            "            if_else_func(",
            "                mfa_session_authenticated,",
            "                execute_func,",
            "                if_else_func(",
            "                    mfa_user_registered,",
            "                    redirect_to_mfa_validate_url,",
            "                    if_else_func(",
            "                        mfa_user_force_registration_required,",
            "                        redirect_to_mfa_registration,",
            "                        execute_func",
            "                    )",
            "                )",
            "            ),",
            "            execute_func",
            "        )",
            "",
            "    return inner",
            "",
            "",
            "def is_mfa_enabled() -> bool:",
            "    \"\"\"",
            "    Returns True if MFA is enabled otherwise False",
            "",
            "    Returns:",
            "        bool: Is MFA Enabled?",
            "    \"\"\"",
            "    return mfa_enabled(lambda: True, lambda: False)",
            "",
            "",
            "def mfa_delete(auth_name: str) -> bool:",
            "    \"\"\"",
            "    A utility function to delete the auth method for the current user from the",
            "    configuration database.",
            "",
            "    Args:",
            "        auth_name (str): Name of the argument",
            "",
            "    Returns:",
            "        bool: True if auth method was registered for the current user, and",
            "              delete successfully, otherwise - False",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    )",
            "",
            "    if int(auth.count()) != 0:",
            "        auth.delete()",
            "        db.session.commit()",
            "",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def mfa_add(auth_name: str, options: str) -> None:",
            "    \"\"\"",
            "    A utility funtion to add/update the auth method in the configuration",
            "    database for the current user with the method specific options.",
            "",
            "    e.g. email-address for 'email' method, and 'secret' for the 'authenticator'",
            "",
            "    Args:",
            "        auth_name (str): Name of the auth method",
            "        options (str)  : A data options specific to the auth method",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    ).first()",
            "",
            "    if auth is None:",
            "        auth = UserMFA(",
            "            user_id=current_user.id,",
            "            mfa_auth=auth_name,",
            "            options=options",
            "        )",
            "        db.session.add(auth)",
            "",
            "    # We will override the existing options",
            "    auth.options = options",
            "",
            "    db.session.commit()",
            "",
            "",
            "def fetch_auth_option(auth_name: str) -> (str, bool):",
            "    \"\"\"",
            "    A utility function to fetch the extra data, stored as options, for the",
            "    given auth method for the current user.",
            "",
            "    Returns a set as (data, Auth method registered?)",
            "",
            "    Args:",
            "        auth_name (str): Name of the auth method",
            "",
            "    Returns:",
            "        (str, bool): (data, has current user registered for the auth method?)",
            "    \"\"\"",
            "    auth = UserMFA.query.filter_by(",
            "        user_id=current_user.id, mfa_auth=auth_name",
            "    ).first()",
            "",
            "    if auth is None:",
            "        return None, False",
            "",
            "    return auth.options, True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "282": [
                "mfa_required",
                "get_next_url"
            ],
            "294": [
                "mfa_required",
                "inner"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/browser/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     flash, Response, request, after_this_request, redirect, session"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from flask_babel import gettext"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from libgravatar import Gravatar"
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_security import current_user, login_required"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+from flask_security import current_user"
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from flask_login.utils import login_url"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from flask_security.changeable import send_password_changed_notice"
            },
            "7": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from flask_security.decorators import anonymous_user_required"
            },
            "8": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " from pgadmin.authenticate import AuthSourceManager"
            },
            "9": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " from pgadmin.utils.exception import CryptKeyMissing"
            },
            "10": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+from pgadmin.user_login_check import pga_login_required"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " try:"
            },
            "14": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     from flask_security.views import default_render_json"
            },
            "15": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " except ImportError as e:"
            },
            "16": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 379,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 380,
                "PatchRowcode": " @blueprint.route(\"/\")"
            },
            "18": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 381,
                "PatchRowcode": " @pgCSRFProtect.exempt"
            },
            "19": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "20": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@mfa_required"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+@pga_login_required"
            },
            "22": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 383,
                "PatchRowcode": " def index():"
            },
            "23": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "     \"\"\"Render and process the main browser window.\"\"\""
            },
            "24": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 472,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 473,
                "PatchRowcode": " @blueprint.route(\"/js/utils.js\")"
            },
            "27": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 474,
                "PatchRowcode": " @pgCSRFProtect.exempt"
            },
            "28": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+@pga_login_required"
            },
            "30": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": 476,
                "PatchRowcode": " def utils():"
            },
            "31": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": 477,
                "PatchRowcode": "     layout = get_setting('Browser/Layout', default='')"
            },
            "32": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": 478,
                "PatchRowcode": "     snippets = []"
            },
            "33": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 593,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 594,
                "PatchRowcode": " @blueprint.route(\"/js/error.js\")"
            },
            "35": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 595,
                "PatchRowcode": " @pgCSRFProtect.exempt"
            },
            "36": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+@pga_login_required"
            },
            "38": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 597,
                "PatchRowcode": " def error_js():"
            },
            "39": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "     return make_response("
            },
            "40": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 599,
                "PatchRowcode": "         render_template('browser/js/error.js', _=gettext),"
            },
            "41": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 610,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 611,
                "PatchRowcode": " @blueprint.route(\"/browser.css\")"
            },
            "43": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": 612,
                "PatchRowcode": " @pgCSRFProtect.exempt"
            },
            "44": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 613,
                "PatchRowcode": "+@pga_login_required"
            },
            "46": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": 614,
                "PatchRowcode": " def browser_css():"
            },
            "47": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "     \"\"\"Render and return CSS snippets from the nodes and modules.\"\"\""
            },
            "48": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 616,
                "PatchRowcode": "     snippets = []"
            },
            "49": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 625,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 626,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 627,
                "PatchRowcode": " @blueprint.route(\"/nodes/\", endpoint=\"nodes\")"
            },
            "52": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@login_required"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+@pga_login_required"
            },
            "54": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 629,
                "PatchRowcode": " def get_nodes():"
            },
            "55": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": 630,
                "PatchRowcode": "     \"\"\"Build a list of treeview nodes from the child nodes.\"\"\""
            },
            "56": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": 631,
                "PatchRowcode": "     nodes = []"
            },
            "57": {
                "beforePatchRowNumber": 931,
                "afterPatchRowNumber": 932,
                "PatchRowcode": "     @blueprint.route(\"/change_password\", endpoint=\"change_password\","
            },
            "58": {
                "beforePatchRowNumber": 932,
                "afterPatchRowNumber": 933,
                "PatchRowcode": "                      methods=['GET', 'POST'])"
            },
            "59": {
                "beforePatchRowNumber": 933,
                "afterPatchRowNumber": 934,
                "PatchRowcode": "     @pgCSRFProtect.exempt"
            },
            "60": {
                "beforePatchRowNumber": 934,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 935,
                "PatchRowcode": "+    @pga_login_required"
            },
            "62": {
                "beforePatchRowNumber": 935,
                "afterPatchRowNumber": 936,
                "PatchRowcode": "     def change_password():"
            },
            "63": {
                "beforePatchRowNumber": 936,
                "afterPatchRowNumber": 937,
                "PatchRowcode": "         \"\"\"View function which handles a change password request.\"\"\""
            },
            "64": {
                "beforePatchRowNumber": 937,
                "afterPatchRowNumber": 938,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import json",
            "import logging",
            "import os",
            "import sys",
            "from abc import ABCMeta, abstractmethod",
            "from smtplib import SMTPConnectError, SMTPResponseException, \\",
            "    SMTPServerDisconnected, SMTPDataError, SMTPHeloError, SMTPException, \\",
            "    SMTPAuthenticationError, SMTPSenderRefused, SMTPRecipientsRefused",
            "from socket import error as SOCKETErrorException",
            "from urllib.request import urlopen",
            "from pgadmin.utils.constants import KEY_RING_SERVICE_NAME, \\",
            "    KEY_RING_USERNAME_FORMAT, KEY_RING_DESKTOP_USER, KEY_RING_TUNNEL_FORMAT, \\",
            "    MessageType",
            "",
            "import time",
            "",
            "import keyring",
            "from flask import current_app, render_template, url_for, make_response, \\",
            "    flash, Response, request, after_this_request, redirect, session",
            "from flask_babel import gettext",
            "from libgravatar import Gravatar",
            "from flask_security import current_user, login_required",
            "from flask_login.utils import login_url",
            "from flask_security.changeable import send_password_changed_notice",
            "from flask_security.decorators import anonymous_user_required",
            "from flask_security.recoverable import reset_password_token_status, \\",
            "    generate_reset_password_token, update_password",
            "from flask_security.signals import reset_password_instructions_sent",
            "from flask_security.utils import config_value, do_flash, get_url, \\",
            "    get_message, slash_url_suffix, login_user, send_mail, hash_password, \\",
            "    get_post_logout_redirect",
            "from flask_security.views import _security, view_commit, _ctx",
            "from werkzeug.datastructures import MultiDict",
            "",
            "import config",
            "from pgadmin import current_blueprint",
            "from pgadmin.authenticate import get_logout_url",
            "from pgadmin.authenticate.mfa.utils import mfa_required, is_mfa_enabled",
            "from pgadmin.settings import get_setting, store_setting",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error, \\",
            "    bad_request",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "from pgadmin.utils.preferences import Preferences",
            "from pgadmin.utils.menu import MenuItem",
            "from pgadmin.browser.register_browser_preferences import \\",
            "    register_browser_preferences",
            "from pgadmin.utils.master_password import validate_master_password, \\",
            "    set_masterpass_check_text, cleanup_master_password, get_crypt_key, \\",
            "    set_crypt_key, process_masterpass_disabled",
            "from pgadmin.model import User, db",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS, PGADMIN_NODE,\\",
            "    INTERNAL, KERBEROS, LDAP, QT_DEFAULT_PLACEHOLDER, OAUTH2, WEBSERVER,\\",
            "    VW_EDT_DEFAULT_PLACEHOLDER",
            "from pgadmin.authenticate import AuthSourceManager",
            "from pgadmin.utils.exception import CryptKeyMissing",
            "",
            "try:",
            "    from flask_security.views import default_render_json",
            "except ImportError as e:",
            "    # Support Flask-Security-Too == 3.2",
            "    if sys.version_info < (3, 8):",
            "        from flask_security.views import _render_json as default_render_json",
            "",
            "MODULE_NAME = 'browser'",
            "BROWSER_STATIC = 'browser.static'",
            "BROWSER_INDEX = 'browser.index'",
            "PGADMIN_BROWSER = 'pgAdmin.Browser'",
            "PASS_ERROR_MSG = gettext('Your password has not been changed.')",
            "SMTP_SOCKET_ERROR = gettext(",
            "    'SMTP Socket error: {error}\\n {pass_error}').format(",
            "        error={}, pass_error=PASS_ERROR_MSG)",
            "SMTP_ERROR = gettext('SMTP error: {error}\\n {pass_error}').format(",
            "    error={}, pass_error=PASS_ERROR_MSG)",
            "PASS_ERROR = gettext('Error: {error}\\n {pass_error}').format(",
            "    error={}, pass_error=PASS_ERROR_MSG)",
            "",
            "",
            "class BrowserModule(PgAdminModule):",
            "    LABEL = gettext('Browser')",
            "",
            "    def register_preferences(self):",
            "        register_browser_preferences(self)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return [BROWSER_INDEX, 'browser.nodes',",
            "                'browser.check_corrupted_db_file',",
            "                'browser.check_master_password',",
            "                'browser.set_master_password',",
            "                'browser.reset_master_password',",
            "                ]",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .server_groups import blueprint as module",
            "        self.submodules.append(module)",
            "        super().register(app, options)",
            "",
            "",
            "blueprint = BrowserModule(MODULE_NAME, __name__)",
            "",
            "",
            "class BrowserPluginModule(PgAdminModule, metaclass=ABCMeta):",
            "    \"\"\"",
            "    Abstract base class for browser submodules.",
            "",
            "    It helps to define the node for each and every node comes under the browser",
            "    tree. It makes sure every module comes under browser will have prefix",
            "    '/browser', and sets the 'url_prefix', 'static_url_path', etc.",
            "",
            "    Also, creates some of the preferences to be used by the node.",
            "    \"\"\"",
            "",
            "    browser_url_prefix = blueprint.url_prefix + '/'",
            "    SHOW_ON_BROWSER = True",
            "",
            "    def __init__(self, import_name, **kwargs):",
            "        \"\"\"",
            "        Construct a new 'BrowserPluginModule' object.",
            "",
            "        :param import_name: Name of the module",
            "        :param **kwargs:    Extra parameters passed to the base class",
            "                            pgAdminModule.",
            "",
            "        :return: returns nothing",
            "",
            "        It sets the url_prefix to based on the 'node_path'. And,",
            "        static_url_path to relative path to '/static'.",
            "",
            "        Every module extended from this will be identified as 'NODE-<type>'.",
            "",
            "        Also, create a preference 'show_node_<type>' to fetch whether it",
            "        can be shown in the browser or not. Also,  refer to the",
            "        browser-preference.",
            "        \"\"\"",
            "        kwargs.setdefault(\"url_prefix\", self.node_path)",
            "        kwargs.setdefault(\"static_url_path\", '/static')",
            "",
            "        self.browser_preference = None",
            "        self.pref_show_system_objects = None",
            "        self.pref_show_node = None",
            "",
            "        super().__init__(",
            "            \"NODE-%s\" % self.node_type,",
            "            import_name,",
            "            **kwargs",
            "        )",
            "",
            "    @property",
            "    def jssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of javascript to include in the page",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def module_use_template_javascript(self):",
            "        \"\"\"",
            "        Returns whether Jinja2 template is used for generating the javascript",
            "        module.",
            "        \"\"\"",
            "        return False",
            "",
            "    def generate_browser_node(",
            "        self, node_id, parent_id, label, icon, inode, node_type, **kwargs",
            "    ):",
            "        \"\"\"",
            "        Helper function to create a browser node for this particular subnode.",
            "",
            "        :param node_id:   Unique Id for each node",
            "        :param parent_id: Id of the parent.",
            "        :param label:     Label for the node",
            "        :param icon:      Icon for displaying along with this node on browser",
            "                          tree. Icon refers to a class name, it refers to.",
            "        :param inode:     True/False.",
            "                          Used by the browser tree node to check, if the",
            "                          current node will have children or not.",
            "        :param node_type: String to refer to the node type.",
            "        :param **kwargs:  A node can have extra information other than this",
            "                          data, which can be passed as key-value pair as",
            "                          argument here.",
            "                          i.e. A database, server node can have extra",
            "                          information like connected, or not.",
            "",
            "        Returns a dictionary object representing this node object for the",
            "        browser tree.",
            "        \"\"\"",
            "        obj = {",
            "            \"id\": \"%s_%s\" % (node_type, node_id),",
            "            \"label\": label,",
            "            \"icon\": icon,",
            "            \"inode\": inode,",
            "            \"_type\": node_type,",
            "            \"_id\": node_id,",
            "            \"_pid\": parent_id,",
            "            \"module\": PGADMIN_NODE % node_type",
            "        }",
            "        for key in kwargs:",
            "            obj.setdefault(key, kwargs[key])",
            "        return obj",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        snippets = [",
            "            render_template(",
            "                \"browser/css/node.css\",",
            "                node_type=self.node_type,",
            "                _=gettext",
            "            )]",
            "",
            "        for submodule in self.submodules:",
            "            snippets.extend(submodule.csssnippets)",
            "        return snippets",
            "",
            "    @abstractmethod",
            "    def get_nodes(self):",
            "        \"\"\"",
            "        Each browser module is responsible for fetching",
            "        its own tree subnodes.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    @abstractmethod",
            "    def node_type(self):",
            "        pass",
            "",
            "    @property",
            "    @abstractmethod",
            "    def script_load(self):",
            "        \"\"\"",
            "        This property defines, when to load this script.",
            "        In order to allow creation of an object, we need to load script for any",
            "        node at the parent level.",
            "",
            "        i.e.",
            "        - In order to allow creating a server object, it should be loaded at",
            "          server-group node.",
            "        \"\"\"",
            "        pass",
            "",
            "    @property",
            "    def node_path(self):",
            "        \"\"\"",
            "        Defines the url path prefix for this submodule.",
            "        \"\"\"",
            "        return self.browser_url_prefix + self.node_type",
            "",
            "    @property",
            "    def label(self):",
            "        \"\"\"",
            "        Module label.",
            "        \"\"\"",
            "        return self.LABEL",
            "",
            "    @property",
            "    def show_node(self):",
            "        \"\"\"",
            "        A proper to check to show node for this module on the browser tree or",
            "        not.",
            "",
            "        Relies on show_node preference object, otherwise on the SHOW_ON_BROWSER",
            "        default value.",
            "        \"\"\"",
            "        if self.pref_show_node:",
            "            return self.pref_show_node.get()",
            "        else:",
            "            return self.SHOW_ON_BROWSER",
            "",
            "    @property",
            "    def show_system_objects(self):",
            "        \"\"\"",
            "        Show/Hide the system objects in the database server.",
            "        \"\"\"",
            "        if self.pref_show_system_objects:",
            "            return self.pref_show_system_objects.get()",
            "        else:",
            "            return False",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        Registers the preferences object for this module.",
            "",
            "        Sets the browser_preference, show_system_objects, show_node preference",
            "        objects for this submodule.",
            "        \"\"\"",
            "        # Add the node information for browser, not in respective node",
            "        # preferences",
            "        self.browser_preference = blueprint.preference",
            "        self.pref_show_system_objects = blueprint.preference.preference(",
            "            'display', 'show_system_objects'",
            "        )",
            "        self.pref_show_node = self.browser_preference.preference(",
            "            'node', 'show_node_' + self.node_type,",
            "            self.label, 'boolean', self.SHOW_ON_BROWSER,",
            "            category_label=gettext('Nodes')",
            "        )",
            "",
            "",
            "def _get_logout_url():",
            "    return '{0}?next={1}'.format(",
            "        url_for(current_app.login_manager.logout_view), url_for(BROWSER_INDEX))",
            "",
            "",
            "def _get_supported_browser():",
            "    \"\"\"",
            "    This function return supported browser.",
            "    :return: browser name, browser known, browser version",
            "    \"\"\"",
            "    browser = request.user_agent.browser",
            "    version = request.user_agent.version and int(",
            "        request.user_agent.version.split('.')[0])",
            "",
            "    browser_name = None",
            "    browser_known = True",
            "    if browser == 'chrome' and version < 72:",
            "        browser_name = 'Chrome'",
            "    elif browser == 'firefox' and version < 65:",
            "        browser_name = 'Firefox'",
            "    # comparing EdgeHTML engine version",
            "    elif browser == 'edge' and version < 18:",
            "        browser_name = 'Edge'",
            "        # browser version returned by edge browser is actual EdgeHTML",
            "        # engine version. Below code gets actual browser version using",
            "        # EdgeHTML version",
            "        engine_to_actual_browser_version = {",
            "            16: 41,",
            "            17: 42,",
            "            18: 44",
            "        }",
            "        version = engine_to_actual_browser_version.get(version, '< 44')",
            "    elif browser == 'safari' and version < 12:",
            "        browser_name = 'Safari'",
            "    elif browser == 'msie':",
            "        browser_name = 'Internet Explorer'",
            "    elif browser != 'chrome' and browser != 'firefox' and \\",
            "            browser != 'edge' and browser != 'safari':",
            "        browser_name = browser",
            "        browser_known = False",
            "",
            "    return browser_name, browser_known, version",
            "",
            "",
            "@blueprint.add_app_template_filter",
            "def gravatar(username):",
            "    \"\"\"",
            "    This function adds a template filter which",
            "    returns gravatar image for user.",
            "    :return: gravatar image",
            "    \"\"\"",
            "    g = Gravatar(username)",
            "    return g.get_image(",
            "        size=100,",
            "        rating='g',",
            "        default='retro'",
            "    )",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@pgCSRFProtect.exempt",
            "@login_required",
            "@mfa_required",
            "def index():",
            "    \"\"\"Render and process the main browser window.\"\"\"",
            "",
            "    # Check the browser is a supported version",
            "    # NOTE: If the checks here are updated, make sure the supported versions",
            "    # at https://www.pgadmin.org/faq/#11 are updated to match!",
            "    if config.CHECK_SUPPORTED_BROWSER:",
            "        browser_name, browser_known, version = _get_supported_browser()",
            "",
            "        if browser_name is not None:",
            "            msg = render_template(",
            "                MODULE_NAME + \"/browser.html\",",
            "                version=version,",
            "                browser=browser_name,",
            "                known=browser_known",
            "            )",
            "",
            "            flash(msg, MessageType.WARNING)",
            "",
            "    session['allow_save_password'] = True",
            "",
            "    if config.SERVER_MODE and not config.MASTER_PASSWORD_REQUIRED and \\",
            "            'pass_enc_key' in session:",
            "        session['allow_save_password'] = False",
            "",
            "    response = Response(render_template(",
            "        MODULE_NAME + \"/index.html\",",
            "        username=current_user.username,",
            "        _=gettext",
            "    ))",
            "",
            "    # Set the language cookie after login, so next time the user will have that",
            "    # same option at the login time.",
            "    misc_preference = Preferences.module('misc')",
            "    user_languages = misc_preference.preference(",
            "        'user_language'",
            "    )",
            "    language = 'en'",
            "    if user_languages:",
            "        language = user_languages.get() or 'en'",
            "",
            "    domain = dict()",
            "    if config.COOKIE_DEFAULT_DOMAIN and\\",
            "            config.COOKIE_DEFAULT_DOMAIN != 'localhost':",
            "        domain['domain'] = config.COOKIE_DEFAULT_DOMAIN",
            "",
            "    response.set_cookie(\"PGADMIN_LANGUAGE\", value=language,",
            "                        path=config.SESSION_COOKIE_PATH,",
            "                        secure=config.SESSION_COOKIE_SECURE,",
            "                        httponly=config.SESSION_COOKIE_HTTPONLY,",
            "                        samesite=config.SESSION_COOKIE_SAMESITE,",
            "                        **domain)",
            "",
            "    return response",
            "",
            "",
            "def validate_shared_storage_config(data, shared_storage_keys):",
            "    \"\"\"",
            "    Validate the config values are correct or not",
            "    \"\"\"",
            "    if shared_storage_keys.issubset(data.keys()):",
            "        if isinstance(data['name'], str) and isinstance(",
            "                data['path'], str) and \\",
            "                isinstance(data['restricted_access'], bool):",
            "            return True",
            "    return False",
            "",
            "",
            "def get_shared_storage_list():",
            "    \"\"\"",
            "    Return the shared storage list after checking all required keys are present",
            "    or not in config. This is for server mode only.",
            "    \"\"\"",
            "    shared_storage_list = []",
            "    restricted_shared_storage_list = []",
            "    if config.SERVER_MODE:",
            "        shared_storage_keys = set(['name', 'path', 'restricted_access'])",
            "        shared_storage_config = [",
            "            sdir for sdir in config.SHARED_STORAGE if",
            "            validate_shared_storage_config(sdir, shared_storage_keys)]",
            "",
            "        config.SHARED_STORAGE = shared_storage_config",
            "        shared_storage_list = [sdir['name'] for sdir in shared_storage_config]",
            "        restricted_shared_storage_list = [sdir['name'] for sdir in",
            "                                          shared_storage_config if",
            "                                          sdir['restricted_access']]",
            "",
            "    return shared_storage_list, restricted_shared_storage_list",
            "",
            "",
            "@blueprint.route(\"/js/utils.js\")",
            "@pgCSRFProtect.exempt",
            "@login_required",
            "def utils():",
            "    layout = get_setting('Browser/Layout', default='')",
            "    snippets = []",
            "",
            "    prefs = Preferences.module('paths')",
            "    pg_help_path_pref = prefs.preference('pg_help_path')",
            "    pg_help_path = pg_help_path_pref.get()",
            "",
            "    # Added to have theme value available at app start page loading",
            "    prefs = Preferences.module('misc')",
            "    theme = prefs.preference('theme').get()",
            "",
            "    # Get sqleditor options",
            "    prefs = Preferences.module('sqleditor')",
            "",
            "    editor_tab_size_pref = prefs.preference('tab_size')",
            "    editor_tab_size = editor_tab_size_pref.get()",
            "",
            "    editor_use_spaces_pref = prefs.preference('use_spaces')",
            "    editor_use_spaces = editor_use_spaces_pref.get()",
            "",
            "    editor_wrap_code_pref = prefs.preference('wrap_code')",
            "    editor_wrap_code = editor_wrap_code_pref.get()",
            "",
            "    brace_matching_pref = prefs.preference('brace_matching')",
            "    brace_matching = brace_matching_pref.get()",
            "",
            "    insert_pair_brackets_perf = prefs.preference('insert_pair_brackets')",
            "    insert_pair_brackets = insert_pair_brackets_perf.get()",
            "",
            "    # This will be opposite of use_space option",
            "    editor_indent_with_tabs = False if editor_use_spaces else True",
            "",
            "    prefs = Preferences.module('browser')",
            "    # Try to fetch current libpq version from the driver",
            "    try:",
            "        from config import PG_DEFAULT_DRIVER",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        pg_libpq_version = driver.libpq_version()",
            "    except Exception:",
            "        pg_libpq_version = 0",
            "",
            "    # Get the pgadmin server's locale",
            "    default_locale = ''",
            "    if current_app.PGADMIN_RUNTIME:",
            "        import locale",
            "        try:",
            "            locale_info = locale.getdefaultlocale()",
            "            if len(locale_info) > 0:",
            "                default_locale = locale_info[0].replace('_', '-')",
            "        except Exception:",
            "            current_app.logger.debug('Failed to get the default locale.')",
            "",
            "    for submodule in current_blueprint.submodules:",
            "        snippets.extend(submodule.jssnippets)",
            "",
            "    auth_only_internal = False",
            "    auth_source = []",
            "",
            "    if config.SERVER_MODE:",
            "        if session['auth_source_manager']['current_source'] == INTERNAL:",
            "            auth_only_internal = True",
            "        auth_source = session['auth_source_manager'][",
            "            'source_friendly_name']",
            "",
            "    shared_storage_list, \\",
            "        restricted_shared_storage_list = get_shared_storage_list()",
            "",
            "    return make_response(",
            "        render_template(",
            "            'browser/js/utils.js',",
            "            layout=layout,",
            "            theme=theme,",
            "            jssnippets=snippets,",
            "            pg_help_path=pg_help_path,",
            "            editor_tab_size=editor_tab_size,",
            "            editor_use_spaces=editor_use_spaces,",
            "            editor_wrap_code=editor_wrap_code,",
            "            editor_brace_matching=brace_matching,",
            "            editor_insert_pair_brackets=insert_pair_brackets,",
            "            editor_indent_with_tabs=editor_indent_with_tabs,",
            "            app_name=config.APP_NAME,",
            "            app_version_int=config.APP_VERSION_INT,",
            "            pg_libpq_version=pg_libpq_version,",
            "            support_ssh_tunnel=config.SUPPORT_SSH_TUNNEL,",
            "            logout_url=get_logout_url(),",
            "            platform=sys.platform,",
            "            qt_default_placeholder=QT_DEFAULT_PLACEHOLDER,",
            "            vw_edt_default_placeholder=VW_EDT_DEFAULT_PLACEHOLDER,",
            "            enable_psql=config.ENABLE_PSQL,",
            "            pgadmin_server_locale=default_locale,",
            "            _=gettext,",
            "            auth_only_internal=auth_only_internal,",
            "            mfa_enabled=is_mfa_enabled(),",
            "            is_admin=current_user.has_role(\"Administrator\"),",
            "            login_url=login_url,",
            "            username=current_user.username.replace(\"'\",\"\\\\'\"),",
            "            auth_source=auth_source,",
            "            heartbeat_timeout=config.SERVER_HEARTBEAT_TIMEOUT,",
            "            password_length_min=config.PASSWORD_LENGTH_MIN,",
            "            shared_storage_list=shared_storage_list,",
            "            restricted_shared_storage_list=[] if current_user.has_role(",
            "                \"Administrator\") else restricted_shared_storage_list,",
            "            enable_server_passexec_cmd=config.ENABLE_SERVER_PASS_EXEC_CMD,",
            "        ),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/js/endpoints.js\")",
            "@pgCSRFProtect.exempt",
            "def exposed_urls():",
            "    return make_response(",
            "        render_template('browser/js/endpoints.js'),",
            "        200, {'Content-Type': MIMETYPE_APP_JS}",
            "    )",
            "",
            "",
            "@blueprint.route(\"/js/error.js\")",
            "@pgCSRFProtect.exempt",
            "@login_required",
            "def error_js():",
            "    return make_response(",
            "        render_template('browser/js/error.js', _=gettext),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/js/messages.js\")",
            "@pgCSRFProtect.exempt",
            "def messages_js():",
            "    return make_response(",
            "        render_template('browser/js/messages.js', _=gettext),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/browser.css\")",
            "@pgCSRFProtect.exempt",
            "@login_required",
            "def browser_css():",
            "    \"\"\"Render and return CSS snippets from the nodes and modules.\"\"\"",
            "    snippets = []",
            "",
            "    for submodule in blueprint.submodules:",
            "        snippets.extend(submodule.csssnippets)",
            "    return make_response(",
            "        render_template(",
            "            'browser/css/browser.css', snippets=snippets, _=gettext",
            "        ),",
            "        200, {'Content-Type': 'text/css'})",
            "",
            "",
            "@blueprint.route(\"/nodes/\", endpoint=\"nodes\")",
            "@login_required",
            "def get_nodes():",
            "    \"\"\"Build a list of treeview nodes from the child nodes.\"\"\"",
            "    nodes = []",
            "    for submodule in current_blueprint.submodules:",
            "        nodes.extend(submodule.get_nodes())",
            "",
            "    return make_json_response(data=nodes)",
            "",
            "",
            "def form_master_password_response(existing=True, present=False, errmsg=None,",
            "                                  keyring_name='',",
            "                                  invalid_master_password_hook=False):",
            "    return make_json_response(data={",
            "        'present': present,",
            "        'reset': existing,",
            "        'errmsg': errmsg,",
            "        'keyring_name': keyring_name,",
            "        'invalid_master_password_hook': invalid_master_password_hook,",
            "        'is_error': True if errmsg else False",
            "    })",
            "",
            "",
            "@blueprint.route(\"/check_corrupted_db_file\",",
            "                 endpoint=\"check_corrupted_db_file\", methods=[\"GET\"])",
            "def check_corrupted_db_file():",
            "    \"\"\"",
            "    Get the corrupted database file path.",
            "    \"\"\"",
            "    file_location = os.environ['CORRUPTED_DB_BACKUP_FILE'] \\",
            "        if 'CORRUPTED_DB_BACKUP_FILE' in os.environ else ''",
            "    # reset the corrupted db file path in env.",
            "    os.environ['CORRUPTED_DB_BACKUP_FILE'] = ''",
            "    return make_json_response(data=file_location)",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"check_master_password\",",
            "                 methods=[\"GET\"])",
            "def check_master_password():",
            "    \"\"\"",
            "    Checks if the master password is available in the memory",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "    return make_json_response(data=get_crypt_key()[0])",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"reset_master_password\",",
            "                 methods=[\"DELETE\"])",
            "def reset_master_password():",
            "    \"\"\"",
            "    Removes the master password and remove all saved passwords",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "    if not config.DISABLED_LOCAL_PASSWORD_STORAGE:",
            "        # This is to set the Desktop user password so it will not ask for",
            "        # migrate exiting passwords as those are getting cleared",
            "        keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                             KEY_RING_DESKTOP_USER.format(",
            "                                 current_user.username), 'test')",
            "    cleanup_master_password()",
            "    status, crypt_key = get_crypt_key()",
            "    # Set masterpass_check if MASTER_PASSWORD_HOOK is set which provides",
            "    # encryption key",
            "    if config.MASTER_PASSWORD_REQUIRED and config.MASTER_PASSWORD_HOOK:",
            "        set_masterpass_check_text(crypt_key)",
            "    return make_json_response(data=status)",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"set_master_password\",",
            "                 methods=[\"POST\"])",
            "def set_master_password():",
            "    \"\"\"",
            "    Set the master password and store in the memory",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "",
            "    data = None",
            "",
            "    if request.form:",
            "        data = request.form",
            "    elif request.data:",
            "        data = request.data",
            "        if hasattr(request.data, 'decode'):",
            "            data = request.data.decode('utf-8')",
            "",
            "        if data != '':",
            "            data = json.loads(data)",
            "",
            "    if not config.DISABLED_LOCAL_PASSWORD_STORAGE and \\",
            "            (config.ALLOW_SAVE_PASSWORD or config.ALLOW_SAVE_TUNNEL_PASSWORD):",
            "        if data.get('password') and config.MASTER_PASSWORD_REQUIRED and\\",
            "                not validate_master_password(data.get('password')):",
            "            return form_master_password_response(",
            "                present=False,",
            "                keyring_name=config.KEYRING_NAME,",
            "                errmsg=gettext(\"Incorrect master password\")",
            "            )",
            "        from pgadmin.model import Server",
            "        from pgadmin.utils.crypto import decrypt",
            "        desktop_user = current_user",
            "",
            "        enc_key = data['password']",
            "        if not config.MASTER_PASSWORD_REQUIRED:",
            "            status, enc_key = get_crypt_key()",
            "            if not status:",
            "                raise CryptKeyMissing",
            "",
            "        try:",
            "            all_server = Server.query.all()",
            "            saved_password_servers = [server for server in all_server if",
            "                                      server.save_password]",
            "            # pgAdmin will use the OS password manager to store the server",
            "            # password, here migrating the existing saved server password to",
            "            # OS password manager",
            "            if len(saved_password_servers) > 0 and (keyring.get_password(",
            "                    KEY_RING_SERVICE_NAME, KEY_RING_DESKTOP_USER.format(",
            "                        desktop_user.username)) or enc_key):",
            "                is_migrated = False",
            "",
            "                for server in saved_password_servers:",
            "                    if enc_key:",
            "                        if server.password and config.ALLOW_SAVE_PASSWORD:",
            "                            name = KEY_RING_USERNAME_FORMAT.format(server.name,",
            "                                                                   server.id)",
            "                            password = decrypt(server.password,",
            "                                               enc_key).decode()",
            "                            # Store the password using OS password manager",
            "                            keyring.set_password(KEY_RING_SERVICE_NAME, name,",
            "                                                 password)",
            "                            is_migrated = True",
            "                            setattr(server, 'password', None)",
            "",
            "                        if server.tunnel_password and \\",
            "                                config.ALLOW_SAVE_TUNNEL_PASSWORD:",
            "                            tname = KEY_RING_TUNNEL_FORMAT.format(server.name,",
            "                                                                  server.id)",
            "                            tpassword = decrypt(server.tunnel_password,",
            "                                                enc_key).decode()",
            "                            # Store the password using OS password manager",
            "                            keyring.set_password(KEY_RING_SERVICE_NAME, tname,",
            "                                                 tpassword)",
            "                            is_migrated = True",
            "                            setattr(server, 'tunnel_password', None)",
            "",
            "                db.session.commit()",
            "",
            "                # Store the password using OS password manager",
            "                keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                     KEY_RING_DESKTOP_USER.format(",
            "                                         desktop_user.username), 'test')",
            "                return form_master_password_response(",
            "                    existing=True,",
            "                    present=True,",
            "                    keyring_name=config.KEYRING_NAME if is_migrated else ''",
            "                )",
            "            else:",
            "                if len(all_server) == 0:",
            "                    # Store the password using OS password manager",
            "                    keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                         KEY_RING_DESKTOP_USER.format(",
            "                                             desktop_user.username), 'test')",
            "                    return form_master_password_response(",
            "                        present=True,",
            "                    )",
            "                else:",
            "                    is_master_password_present = True",
            "                    keyring_name = ''",
            "                    for server in all_server:",
            "                        is_password_present = \\",
            "                            server.save_password or server.tunnel_password",
            "                        if server.password and is_password_present:",
            "                            is_master_password_present = False",
            "                            keyring_name = config.KEYRING_NAME",
            "                            break",
            "",
            "                    if is_master_password_present:",
            "                        # Store the password using OS password manager",
            "                        keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                             KEY_RING_DESKTOP_USER.format(",
            "                                                 desktop_user.username),",
            "                                             'test')",
            "",
            "                    return form_master_password_response(",
            "                        present=is_master_password_present,",
            "                        keyring_name=keyring_name",
            "                    )",
            "        except Exception as e:",
            "            current_app.logger.warning(",
            "                'Fail set password using OS password manager'",
            "                ', fallback to master password. Error: {0}'.format(e)",
            "            )",
            "            config.DISABLED_LOCAL_PASSWORD_STORAGE = True",
            "",
            "    # If the master password is required and the master password hook",
            "    # is specified then try to retrieve the encryption key and update data.",
            "    # If there is an error while retrieving it, return an error message.",
            "    if config.SERVER_MODE and config.MASTER_PASSWORD_REQUIRED and \\",
            "            config.MASTER_PASSWORD_HOOK:",
            "        status, enc_key = get_crypt_key()",
            "        if status:",
            "            data = {'password': enc_key, 'submit_password': True}",
            "        else:",
            "            error = gettext('The master password could not be retrieved from '",
            "                            'the MASTER_PASSWORD_HOOK utility specified {0}.'",
            "                            'Please check that the hook utility is configured'",
            "                            ' correctly.'.format(config.MASTER_PASSWORD_HOOK))",
            "            return form_master_password_response(",
            "                existing=False,",
            "                present=False,",
            "                errmsg=error,",
            "                invalid_master_password_hook=True",
            "            )",
            "",
            "    # Master password is applicable for Desktop mode and in server mode",
            "    # only when auth sources are oauth, kerberos, webserver.",
            "    if (not config.SERVER_MODE) or OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "        or KERBEROS in config.AUTHENTICATION_SOURCES \\",
            "        or WEBSERVER in config.AUTHENTICATION_SOURCES \\",
            "            and config.MASTER_PASSWORD_REQUIRED:",
            "        # if master pass is set previously",
            "        if current_user.masterpass_check is not None and \\",
            "            data.get('submit_password', False) and \\",
            "                not validate_master_password(data.get('password')):",
            "            errmsg = '' if config.MASTER_PASSWORD_HOOK \\",
            "                else gettext(\"Incorrect master password\")",
            "            invalid_master_password_hook = \\",
            "                True if config.MASTER_PASSWORD_HOOK else False",
            "            return form_master_password_response(",
            "                existing=True,",
            "                present=False,",
            "                errmsg=errmsg,",
            "                invalid_master_password_hook=invalid_master_password_hook",
            "            )",
            "",
            "        # if master password received in request",
            "        if data != '' and data.get('password', '') != '':",
            "",
            "            # store the master pass in the memory",
            "            set_crypt_key(data.get('password'))",
            "",
            "            if current_user.masterpass_check is None:",
            "                # master check is not set, which means the server password",
            "                # data is old and is encrypted with old key",
            "                # Re-encrypt with new key",
            "",
            "                from pgadmin.browser.server_groups.servers.utils \\",
            "                    import reencrpyt_server_passwords",
            "                reencrpyt_server_passwords(",
            "                    current_user.id, current_user.password,",
            "                    data.get('password'))",
            "",
            "            # set the encrypted sample text with the new",
            "            # master pass",
            "            set_masterpass_check_text(data.get('password'))",
            "",
            "        # If password in request is empty then try to get it with",
            "        # get_crypt_key method. If get_crypt_key() returns false status and",
            "        # masterpass_check is already set, provide a pop to enter",
            "        # master password(present) without the reset option.(existing).",
            "        elif not get_crypt_key()[0] and \\",
            "                current_user.masterpass_check is not None:",
            "            return form_master_password_response(",
            "                existing=True,",
            "                present=False,",
            "            )",
            "",
            "        # If get_crypt_key return True,but crypt_key is none and",
            "        # user entered blank password, return error message.",
            "        elif not get_crypt_key()[1]:",
            "            error_message = None",
            "            # If user attempted to enter a blank password, then throw error",
            "            if data.get('submit_password') and data.get('password') == '':",
            "                error_message = gettext(\"Master password cannot be empty\")",
            "            return form_master_password_response(",
            "                existing=False,",
            "                present=False,",
            "                errmsg=error_message",
            "            )",
            "",
            "    # if master password is disabled now, but was used once then",
            "    # remove all the saved passwords",
            "    process_masterpass_disabled()",
            "",
            "    if config.SERVER_MODE and current_user.masterpass_check is None:",
            "",
            "        crypt_key = get_crypt_key()[1]",
            "        from pgadmin.browser.server_groups.servers.utils \\",
            "            import reencrpyt_server_passwords",
            "        reencrpyt_server_passwords(",
            "            current_user.id, current_user.password, crypt_key)",
            "",
            "        set_masterpass_check_text(crypt_key)",
            "",
            "    return form_master_password_response(",
            "        present=True,",
            "    )",
            "",
            "",
            "# Only register route if SECURITY_CHANGEABLE is set to True",
            "# We can't access app context here so cannot",
            "# use app.config['SECURITY_CHANGEABLE']",
            "",
            "",
            "if hasattr(config, 'SECURITY_CHANGEABLE') and config.SECURITY_CHANGEABLE:",
            "    @blueprint.route(\"/change_password\", endpoint=\"change_password\",",
            "                     methods=['GET', 'POST'])",
            "    @pgCSRFProtect.exempt",
            "    @login_required",
            "    def change_password():",
            "        \"\"\"View function which handles a change password request.\"\"\"",
            "",
            "        form_class = _security.forms.get('change_password_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if not req_json:",
            "            form = form_class()",
            "            return {",
            "                'csrf_token': form.csrf_token._value()",
            "            }",
            "        elif req_json:",
            "            form = form_class(MultiDict(req_json))",
            "            if form.validate():",
            "                errormsg = None",
            "                # change_user_password from flask-security logs out the user",
            "                # this is undesirable, so change password on own",
            "                try:",
            "                    user = User.query.filter(",
            "                        User.fs_uniquifier == current_user.fs_uniquifier)\\",
            "                        .first()",
            "                    user.password = hash_password(form.new_password.data)",
            "",
            "                    try:",
            "                        send_password_changed_notice(user)",
            "                    except Exception as _:",
            "                        # No need to throw error if failed in sending email",
            "                        pass",
            "                except Exception as e:",
            "                    # Handle other exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    errormsg = gettext(PASS_ERROR).format(e)",
            "",
            "                if errormsg is None:",
            "                    old_key = get_crypt_key()[1]",
            "                    set_crypt_key(form.new_password.data, False)",
            "",
            "                    from pgadmin.browser.server_groups.servers.utils \\",
            "                        import reencrpyt_server_passwords",
            "                    reencrpyt_server_passwords(",
            "                        current_user.id, old_key, form.new_password.data)",
            "",
            "                    db.session.commit()",
            "                elif errormsg is not None:",
            "                    return internal_server_error(errormsg)",
            "            else:",
            "                return bad_request(list(form.errors.values())[0][0])",
            "",
            "        return make_json_response(",
            "            success=1,",
            "            info=gettext('pgAdmin user password changed successfully')",
            "        )",
            "",
            "# Only register route if SECURITY_RECOVERABLE is set to True",
            "if hasattr(config, 'SECURITY_RECOVERABLE') and config.SECURITY_RECOVERABLE:",
            "",
            "    def send_reset_password_instructions(user):",
            "        \"\"\"Sends the reset password instructions email for the specified user.",
            "",
            "        :param user: The user to send the instructions to",
            "        \"\"\"",
            "        token = generate_reset_password_token(user)",
            "        reset_link = url_for('browser.reset_password', token=token,",
            "                             _external=True)",
            "",
            "        send_mail(config_value('EMAIL_SUBJECT_PASSWORD_RESET'), user.email,",
            "                  'reset_instructions',",
            "                  user=user, reset_link=reset_link)",
            "",
            "        reset_password_instructions_sent.send(",
            "            current_app._get_current_object(),",
            "            user=user, token=token)",
            "",
            "    @blueprint.route(\"/reset_password\", endpoint=\"forgot_password\",",
            "                     methods=['GET', 'POST'])",
            "    @pgCSRFProtect.exempt",
            "    @anonymous_user_required",
            "    def forgot_password():",
            "        \"\"\"View function that handles a forgotten password request.\"\"\"",
            "        has_error = False",
            "        form_class = _security.forms.get('forgot_password_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if req_json:",
            "            form = form_class(MultiDict(req_json))",
            "        else:",
            "            form = form_class()",
            "",
            "        if form.validate_on_submit():",
            "            # Check the Authentication source of the User",
            "            user = User.query.filter_by(",
            "                email=form.data['email'],",
            "                auth_source=INTERNAL",
            "            ).first()",
            "",
            "            if user is None:",
            "                # If the user is not an internal user, raise the exception",
            "                flash(gettext('Your account is authenticated using an '",
            "                              'external {} source. '",
            "                              'Please contact the administrators of this '",
            "                              'service if you need to reset your password.'",
            "                              ).format(form.user.auth_source),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            if not has_error:",
            "                try:",
            "                    send_reset_password_instructions(form.user)",
            "                except SOCKETErrorException as e:",
            "                    # Handle socket errors which are not",
            "                    # covered by SMTPExceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(SMTP_SOCKET_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "                except (SMTPConnectError, SMTPResponseException,",
            "                        SMTPServerDisconnected, SMTPDataError, SMTPHeloError,",
            "                        SMTPException, SMTPAuthenticationError,",
            "                        SMTPSenderRefused, SMTPRecipientsRefused) as e:",
            "",
            "                    # Handle smtp specific exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(SMTP_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "                except Exception as e:",
            "                    # Handle other exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(PASS_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "",
            "            if request.get_json(silent=True) is None and not has_error:",
            "                do_flash(*get_message('PASSWORD_RESET_REQUEST',",
            "                                      email=form.user.email))",
            "",
            "        if request.get_json(silent=True) and not has_error:",
            "            return default_render_json(form, include_user=False)",
            "",
            "        for errors in form.errors.values():",
            "            for error in errors:",
            "                flash(error, MessageType.WARNING)",
            "",
            "        return _security.render_template(",
            "            config_value('FORGOT_PASSWORD_TEMPLATE'),",
            "            forgot_password_form=form,",
            "            **_ctx('forgot_password'))",
            "",
            "    # We are not in app context so cannot use",
            "    # url_for('browser.forgot_password')",
            "    # So hard code the url '/browser/reset_password' while passing as",
            "    # parameter to slash_url_suffix function.",
            "    @blueprint.route(",
            "        '/reset_password' + slash_url_suffix(",
            "            '/browser/reset_password', '<token>'",
            "        ),",
            "        methods=['GET', 'POST'],",
            "        endpoint='reset_password'",
            "    )",
            "    @pgCSRFProtect.exempt",
            "    @anonymous_user_required",
            "    def reset_password(token):",
            "        \"\"\"View function that handles a reset password request.\"\"\"",
            "        expired, invalid, user = reset_password_token_status(token)",
            "",
            "        if invalid:",
            "            do_flash(*get_message('INVALID_RESET_PASSWORD_TOKEN'))",
            "        if expired:",
            "            do_flash(*get_message('PASSWORD_RESET_EXPIRED', email=user.email,",
            "                                  within=_security.reset_password_within))",
            "        if invalid or expired:",
            "            return redirect(url_for('browser.forgot_password'))",
            "        has_error = False",
            "        form_class = _security.forms.get('reset_password_form').cls",
            "        form = form_class(request.form) if request.form else form_class()",
            "",
            "        if form.validate_on_submit():",
            "            try:",
            "                update_password(user, form.password.data)",
            "            except SOCKETErrorException as e:",
            "                # Handle socket errors which are not covered by SMTPExceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(SMTP_SOCKET_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            except (SMTPConnectError, SMTPResponseException,",
            "                    SMTPServerDisconnected, SMTPDataError, SMTPHeloError,",
            "                    SMTPException, SMTPAuthenticationError, SMTPSenderRefused,",
            "                    SMTPRecipientsRefused) as e:",
            "",
            "                # Handle smtp specific exceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(SMTP_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            except Exception as e:",
            "                # Handle other exceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(PASS_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "",
            "            if not has_error:",
            "                after_this_request(view_commit)",
            "                auth_obj = AuthSourceManager(form, [INTERNAL])",
            "                session['_auth_source_manager_obj'] = auth_obj.as_dict()",
            "",
            "                if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    flash(gettext('You successfully reset your password but'",
            "                                  ' your account is locked. Please contact '",
            "                                  'the Administrator.'),",
            "                          MessageType.WARNING)",
            "                    return redirect(get_post_logout_redirect())",
            "                do_flash(*get_message('PASSWORD_RESET'))",
            "                login_user(user)",
            "                auth_obj = AuthSourceManager(form, [INTERNAL])",
            "                session['auth_source_manager'] = auth_obj.as_dict()",
            "",
            "                return redirect(get_url(_security.post_reset_view) or",
            "                                get_url(_security.post_login_view))",
            "",
            "        return _security.render_template(",
            "            config_value('RESET_PASSWORD_TEMPLATE'),",
            "            reset_password_form=form,",
            "            reset_password_token=token,",
            "            **_ctx('reset_password'))"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import json",
            "import logging",
            "import os",
            "import sys",
            "from abc import ABCMeta, abstractmethod",
            "from smtplib import SMTPConnectError, SMTPResponseException, \\",
            "    SMTPServerDisconnected, SMTPDataError, SMTPHeloError, SMTPException, \\",
            "    SMTPAuthenticationError, SMTPSenderRefused, SMTPRecipientsRefused",
            "from socket import error as SOCKETErrorException",
            "from urllib.request import urlopen",
            "from pgadmin.utils.constants import KEY_RING_SERVICE_NAME, \\",
            "    KEY_RING_USERNAME_FORMAT, KEY_RING_DESKTOP_USER, KEY_RING_TUNNEL_FORMAT, \\",
            "    MessageType",
            "",
            "import time",
            "",
            "import keyring",
            "from flask import current_app, render_template, url_for, make_response, \\",
            "    flash, Response, request, after_this_request, redirect, session",
            "from flask_babel import gettext",
            "from libgravatar import Gravatar",
            "from flask_security import current_user",
            "from flask_login.utils import login_url",
            "from flask_security.changeable import send_password_changed_notice",
            "from flask_security.decorators import anonymous_user_required",
            "from flask_security.recoverable import reset_password_token_status, \\",
            "    generate_reset_password_token, update_password",
            "from flask_security.signals import reset_password_instructions_sent",
            "from flask_security.utils import config_value, do_flash, get_url, \\",
            "    get_message, slash_url_suffix, login_user, send_mail, hash_password, \\",
            "    get_post_logout_redirect",
            "from flask_security.views import _security, view_commit, _ctx",
            "from werkzeug.datastructures import MultiDict",
            "",
            "import config",
            "from pgadmin import current_blueprint",
            "from pgadmin.authenticate import get_logout_url",
            "from pgadmin.authenticate.mfa.utils import mfa_required, is_mfa_enabled",
            "from pgadmin.settings import get_setting, store_setting",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error, \\",
            "    bad_request",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "from pgadmin.utils.preferences import Preferences",
            "from pgadmin.utils.menu import MenuItem",
            "from pgadmin.browser.register_browser_preferences import \\",
            "    register_browser_preferences",
            "from pgadmin.utils.master_password import validate_master_password, \\",
            "    set_masterpass_check_text, cleanup_master_password, get_crypt_key, \\",
            "    set_crypt_key, process_masterpass_disabled",
            "from pgadmin.model import User, db",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS, PGADMIN_NODE,\\",
            "    INTERNAL, KERBEROS, LDAP, QT_DEFAULT_PLACEHOLDER, OAUTH2, WEBSERVER,\\",
            "    VW_EDT_DEFAULT_PLACEHOLDER",
            "from pgadmin.authenticate import AuthSourceManager",
            "from pgadmin.utils.exception import CryptKeyMissing",
            "",
            "from pgadmin.user_login_check import pga_login_required",
            "",
            "try:",
            "    from flask_security.views import default_render_json",
            "except ImportError as e:",
            "    # Support Flask-Security-Too == 3.2",
            "    if sys.version_info < (3, 8):",
            "        from flask_security.views import _render_json as default_render_json",
            "",
            "MODULE_NAME = 'browser'",
            "BROWSER_STATIC = 'browser.static'",
            "BROWSER_INDEX = 'browser.index'",
            "PGADMIN_BROWSER = 'pgAdmin.Browser'",
            "PASS_ERROR_MSG = gettext('Your password has not been changed.')",
            "SMTP_SOCKET_ERROR = gettext(",
            "    'SMTP Socket error: {error}\\n {pass_error}').format(",
            "        error={}, pass_error=PASS_ERROR_MSG)",
            "SMTP_ERROR = gettext('SMTP error: {error}\\n {pass_error}').format(",
            "    error={}, pass_error=PASS_ERROR_MSG)",
            "PASS_ERROR = gettext('Error: {error}\\n {pass_error}').format(",
            "    error={}, pass_error=PASS_ERROR_MSG)",
            "",
            "",
            "class BrowserModule(PgAdminModule):",
            "    LABEL = gettext('Browser')",
            "",
            "    def register_preferences(self):",
            "        register_browser_preferences(self)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return [BROWSER_INDEX, 'browser.nodes',",
            "                'browser.check_corrupted_db_file',",
            "                'browser.check_master_password',",
            "                'browser.set_master_password',",
            "                'browser.reset_master_password',",
            "                ]",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .server_groups import blueprint as module",
            "        self.submodules.append(module)",
            "        super().register(app, options)",
            "",
            "",
            "blueprint = BrowserModule(MODULE_NAME, __name__)",
            "",
            "",
            "class BrowserPluginModule(PgAdminModule, metaclass=ABCMeta):",
            "    \"\"\"",
            "    Abstract base class for browser submodules.",
            "",
            "    It helps to define the node for each and every node comes under the browser",
            "    tree. It makes sure every module comes under browser will have prefix",
            "    '/browser', and sets the 'url_prefix', 'static_url_path', etc.",
            "",
            "    Also, creates some of the preferences to be used by the node.",
            "    \"\"\"",
            "",
            "    browser_url_prefix = blueprint.url_prefix + '/'",
            "    SHOW_ON_BROWSER = True",
            "",
            "    def __init__(self, import_name, **kwargs):",
            "        \"\"\"",
            "        Construct a new 'BrowserPluginModule' object.",
            "",
            "        :param import_name: Name of the module",
            "        :param **kwargs:    Extra parameters passed to the base class",
            "                            pgAdminModule.",
            "",
            "        :return: returns nothing",
            "",
            "        It sets the url_prefix to based on the 'node_path'. And,",
            "        static_url_path to relative path to '/static'.",
            "",
            "        Every module extended from this will be identified as 'NODE-<type>'.",
            "",
            "        Also, create a preference 'show_node_<type>' to fetch whether it",
            "        can be shown in the browser or not. Also,  refer to the",
            "        browser-preference.",
            "        \"\"\"",
            "        kwargs.setdefault(\"url_prefix\", self.node_path)",
            "        kwargs.setdefault(\"static_url_path\", '/static')",
            "",
            "        self.browser_preference = None",
            "        self.pref_show_system_objects = None",
            "        self.pref_show_node = None",
            "",
            "        super().__init__(",
            "            \"NODE-%s\" % self.node_type,",
            "            import_name,",
            "            **kwargs",
            "        )",
            "",
            "    @property",
            "    def jssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of javascript to include in the page",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def module_use_template_javascript(self):",
            "        \"\"\"",
            "        Returns whether Jinja2 template is used for generating the javascript",
            "        module.",
            "        \"\"\"",
            "        return False",
            "",
            "    def generate_browser_node(",
            "        self, node_id, parent_id, label, icon, inode, node_type, **kwargs",
            "    ):",
            "        \"\"\"",
            "        Helper function to create a browser node for this particular subnode.",
            "",
            "        :param node_id:   Unique Id for each node",
            "        :param parent_id: Id of the parent.",
            "        :param label:     Label for the node",
            "        :param icon:      Icon for displaying along with this node on browser",
            "                          tree. Icon refers to a class name, it refers to.",
            "        :param inode:     True/False.",
            "                          Used by the browser tree node to check, if the",
            "                          current node will have children or not.",
            "        :param node_type: String to refer to the node type.",
            "        :param **kwargs:  A node can have extra information other than this",
            "                          data, which can be passed as key-value pair as",
            "                          argument here.",
            "                          i.e. A database, server node can have extra",
            "                          information like connected, or not.",
            "",
            "        Returns a dictionary object representing this node object for the",
            "        browser tree.",
            "        \"\"\"",
            "        obj = {",
            "            \"id\": \"%s_%s\" % (node_type, node_id),",
            "            \"label\": label,",
            "            \"icon\": icon,",
            "            \"inode\": inode,",
            "            \"_type\": node_type,",
            "            \"_id\": node_id,",
            "            \"_pid\": parent_id,",
            "            \"module\": PGADMIN_NODE % node_type",
            "        }",
            "        for key in kwargs:",
            "            obj.setdefault(key, kwargs[key])",
            "        return obj",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        snippets = [",
            "            render_template(",
            "                \"browser/css/node.css\",",
            "                node_type=self.node_type,",
            "                _=gettext",
            "            )]",
            "",
            "        for submodule in self.submodules:",
            "            snippets.extend(submodule.csssnippets)",
            "        return snippets",
            "",
            "    @abstractmethod",
            "    def get_nodes(self):",
            "        \"\"\"",
            "        Each browser module is responsible for fetching",
            "        its own tree subnodes.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    @abstractmethod",
            "    def node_type(self):",
            "        pass",
            "",
            "    @property",
            "    @abstractmethod",
            "    def script_load(self):",
            "        \"\"\"",
            "        This property defines, when to load this script.",
            "        In order to allow creation of an object, we need to load script for any",
            "        node at the parent level.",
            "",
            "        i.e.",
            "        - In order to allow creating a server object, it should be loaded at",
            "          server-group node.",
            "        \"\"\"",
            "        pass",
            "",
            "    @property",
            "    def node_path(self):",
            "        \"\"\"",
            "        Defines the url path prefix for this submodule.",
            "        \"\"\"",
            "        return self.browser_url_prefix + self.node_type",
            "",
            "    @property",
            "    def label(self):",
            "        \"\"\"",
            "        Module label.",
            "        \"\"\"",
            "        return self.LABEL",
            "",
            "    @property",
            "    def show_node(self):",
            "        \"\"\"",
            "        A proper to check to show node for this module on the browser tree or",
            "        not.",
            "",
            "        Relies on show_node preference object, otherwise on the SHOW_ON_BROWSER",
            "        default value.",
            "        \"\"\"",
            "        if self.pref_show_node:",
            "            return self.pref_show_node.get()",
            "        else:",
            "            return self.SHOW_ON_BROWSER",
            "",
            "    @property",
            "    def show_system_objects(self):",
            "        \"\"\"",
            "        Show/Hide the system objects in the database server.",
            "        \"\"\"",
            "        if self.pref_show_system_objects:",
            "            return self.pref_show_system_objects.get()",
            "        else:",
            "            return False",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        Registers the preferences object for this module.",
            "",
            "        Sets the browser_preference, show_system_objects, show_node preference",
            "        objects for this submodule.",
            "        \"\"\"",
            "        # Add the node information for browser, not in respective node",
            "        # preferences",
            "        self.browser_preference = blueprint.preference",
            "        self.pref_show_system_objects = blueprint.preference.preference(",
            "            'display', 'show_system_objects'",
            "        )",
            "        self.pref_show_node = self.browser_preference.preference(",
            "            'node', 'show_node_' + self.node_type,",
            "            self.label, 'boolean', self.SHOW_ON_BROWSER,",
            "            category_label=gettext('Nodes')",
            "        )",
            "",
            "",
            "def _get_logout_url():",
            "    return '{0}?next={1}'.format(",
            "        url_for(current_app.login_manager.logout_view), url_for(BROWSER_INDEX))",
            "",
            "",
            "def _get_supported_browser():",
            "    \"\"\"",
            "    This function return supported browser.",
            "    :return: browser name, browser known, browser version",
            "    \"\"\"",
            "    browser = request.user_agent.browser",
            "    version = request.user_agent.version and int(",
            "        request.user_agent.version.split('.')[0])",
            "",
            "    browser_name = None",
            "    browser_known = True",
            "    if browser == 'chrome' and version < 72:",
            "        browser_name = 'Chrome'",
            "    elif browser == 'firefox' and version < 65:",
            "        browser_name = 'Firefox'",
            "    # comparing EdgeHTML engine version",
            "    elif browser == 'edge' and version < 18:",
            "        browser_name = 'Edge'",
            "        # browser version returned by edge browser is actual EdgeHTML",
            "        # engine version. Below code gets actual browser version using",
            "        # EdgeHTML version",
            "        engine_to_actual_browser_version = {",
            "            16: 41,",
            "            17: 42,",
            "            18: 44",
            "        }",
            "        version = engine_to_actual_browser_version.get(version, '< 44')",
            "    elif browser == 'safari' and version < 12:",
            "        browser_name = 'Safari'",
            "    elif browser == 'msie':",
            "        browser_name = 'Internet Explorer'",
            "    elif browser != 'chrome' and browser != 'firefox' and \\",
            "            browser != 'edge' and browser != 'safari':",
            "        browser_name = browser",
            "        browser_known = False",
            "",
            "    return browser_name, browser_known, version",
            "",
            "",
            "@blueprint.add_app_template_filter",
            "def gravatar(username):",
            "    \"\"\"",
            "    This function adds a template filter which",
            "    returns gravatar image for user.",
            "    :return: gravatar image",
            "    \"\"\"",
            "    g = Gravatar(username)",
            "    return g.get_image(",
            "        size=100,",
            "        rating='g',",
            "        default='retro'",
            "    )",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@pgCSRFProtect.exempt",
            "@pga_login_required",
            "def index():",
            "    \"\"\"Render and process the main browser window.\"\"\"",
            "",
            "    # Check the browser is a supported version",
            "    # NOTE: If the checks here are updated, make sure the supported versions",
            "    # at https://www.pgadmin.org/faq/#11 are updated to match!",
            "    if config.CHECK_SUPPORTED_BROWSER:",
            "        browser_name, browser_known, version = _get_supported_browser()",
            "",
            "        if browser_name is not None:",
            "            msg = render_template(",
            "                MODULE_NAME + \"/browser.html\",",
            "                version=version,",
            "                browser=browser_name,",
            "                known=browser_known",
            "            )",
            "",
            "            flash(msg, MessageType.WARNING)",
            "",
            "    session['allow_save_password'] = True",
            "",
            "    if config.SERVER_MODE and not config.MASTER_PASSWORD_REQUIRED and \\",
            "            'pass_enc_key' in session:",
            "        session['allow_save_password'] = False",
            "",
            "    response = Response(render_template(",
            "        MODULE_NAME + \"/index.html\",",
            "        username=current_user.username,",
            "        _=gettext",
            "    ))",
            "",
            "    # Set the language cookie after login, so next time the user will have that",
            "    # same option at the login time.",
            "    misc_preference = Preferences.module('misc')",
            "    user_languages = misc_preference.preference(",
            "        'user_language'",
            "    )",
            "    language = 'en'",
            "    if user_languages:",
            "        language = user_languages.get() or 'en'",
            "",
            "    domain = dict()",
            "    if config.COOKIE_DEFAULT_DOMAIN and\\",
            "            config.COOKIE_DEFAULT_DOMAIN != 'localhost':",
            "        domain['domain'] = config.COOKIE_DEFAULT_DOMAIN",
            "",
            "    response.set_cookie(\"PGADMIN_LANGUAGE\", value=language,",
            "                        path=config.SESSION_COOKIE_PATH,",
            "                        secure=config.SESSION_COOKIE_SECURE,",
            "                        httponly=config.SESSION_COOKIE_HTTPONLY,",
            "                        samesite=config.SESSION_COOKIE_SAMESITE,",
            "                        **domain)",
            "",
            "    return response",
            "",
            "",
            "def validate_shared_storage_config(data, shared_storage_keys):",
            "    \"\"\"",
            "    Validate the config values are correct or not",
            "    \"\"\"",
            "    if shared_storage_keys.issubset(data.keys()):",
            "        if isinstance(data['name'], str) and isinstance(",
            "                data['path'], str) and \\",
            "                isinstance(data['restricted_access'], bool):",
            "            return True",
            "    return False",
            "",
            "",
            "def get_shared_storage_list():",
            "    \"\"\"",
            "    Return the shared storage list after checking all required keys are present",
            "    or not in config. This is for server mode only.",
            "    \"\"\"",
            "    shared_storage_list = []",
            "    restricted_shared_storage_list = []",
            "    if config.SERVER_MODE:",
            "        shared_storage_keys = set(['name', 'path', 'restricted_access'])",
            "        shared_storage_config = [",
            "            sdir for sdir in config.SHARED_STORAGE if",
            "            validate_shared_storage_config(sdir, shared_storage_keys)]",
            "",
            "        config.SHARED_STORAGE = shared_storage_config",
            "        shared_storage_list = [sdir['name'] for sdir in shared_storage_config]",
            "        restricted_shared_storage_list = [sdir['name'] for sdir in",
            "                                          shared_storage_config if",
            "                                          sdir['restricted_access']]",
            "",
            "    return shared_storage_list, restricted_shared_storage_list",
            "",
            "",
            "@blueprint.route(\"/js/utils.js\")",
            "@pgCSRFProtect.exempt",
            "@pga_login_required",
            "def utils():",
            "    layout = get_setting('Browser/Layout', default='')",
            "    snippets = []",
            "",
            "    prefs = Preferences.module('paths')",
            "    pg_help_path_pref = prefs.preference('pg_help_path')",
            "    pg_help_path = pg_help_path_pref.get()",
            "",
            "    # Added to have theme value available at app start page loading",
            "    prefs = Preferences.module('misc')",
            "    theme = prefs.preference('theme').get()",
            "",
            "    # Get sqleditor options",
            "    prefs = Preferences.module('sqleditor')",
            "",
            "    editor_tab_size_pref = prefs.preference('tab_size')",
            "    editor_tab_size = editor_tab_size_pref.get()",
            "",
            "    editor_use_spaces_pref = prefs.preference('use_spaces')",
            "    editor_use_spaces = editor_use_spaces_pref.get()",
            "",
            "    editor_wrap_code_pref = prefs.preference('wrap_code')",
            "    editor_wrap_code = editor_wrap_code_pref.get()",
            "",
            "    brace_matching_pref = prefs.preference('brace_matching')",
            "    brace_matching = brace_matching_pref.get()",
            "",
            "    insert_pair_brackets_perf = prefs.preference('insert_pair_brackets')",
            "    insert_pair_brackets = insert_pair_brackets_perf.get()",
            "",
            "    # This will be opposite of use_space option",
            "    editor_indent_with_tabs = False if editor_use_spaces else True",
            "",
            "    prefs = Preferences.module('browser')",
            "    # Try to fetch current libpq version from the driver",
            "    try:",
            "        from config import PG_DEFAULT_DRIVER",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        pg_libpq_version = driver.libpq_version()",
            "    except Exception:",
            "        pg_libpq_version = 0",
            "",
            "    # Get the pgadmin server's locale",
            "    default_locale = ''",
            "    if current_app.PGADMIN_RUNTIME:",
            "        import locale",
            "        try:",
            "            locale_info = locale.getdefaultlocale()",
            "            if len(locale_info) > 0:",
            "                default_locale = locale_info[0].replace('_', '-')",
            "        except Exception:",
            "            current_app.logger.debug('Failed to get the default locale.')",
            "",
            "    for submodule in current_blueprint.submodules:",
            "        snippets.extend(submodule.jssnippets)",
            "",
            "    auth_only_internal = False",
            "    auth_source = []",
            "",
            "    if config.SERVER_MODE:",
            "        if session['auth_source_manager']['current_source'] == INTERNAL:",
            "            auth_only_internal = True",
            "        auth_source = session['auth_source_manager'][",
            "            'source_friendly_name']",
            "",
            "    shared_storage_list, \\",
            "        restricted_shared_storage_list = get_shared_storage_list()",
            "",
            "    return make_response(",
            "        render_template(",
            "            'browser/js/utils.js',",
            "            layout=layout,",
            "            theme=theme,",
            "            jssnippets=snippets,",
            "            pg_help_path=pg_help_path,",
            "            editor_tab_size=editor_tab_size,",
            "            editor_use_spaces=editor_use_spaces,",
            "            editor_wrap_code=editor_wrap_code,",
            "            editor_brace_matching=brace_matching,",
            "            editor_insert_pair_brackets=insert_pair_brackets,",
            "            editor_indent_with_tabs=editor_indent_with_tabs,",
            "            app_name=config.APP_NAME,",
            "            app_version_int=config.APP_VERSION_INT,",
            "            pg_libpq_version=pg_libpq_version,",
            "            support_ssh_tunnel=config.SUPPORT_SSH_TUNNEL,",
            "            logout_url=get_logout_url(),",
            "            platform=sys.platform,",
            "            qt_default_placeholder=QT_DEFAULT_PLACEHOLDER,",
            "            vw_edt_default_placeholder=VW_EDT_DEFAULT_PLACEHOLDER,",
            "            enable_psql=config.ENABLE_PSQL,",
            "            pgadmin_server_locale=default_locale,",
            "            _=gettext,",
            "            auth_only_internal=auth_only_internal,",
            "            mfa_enabled=is_mfa_enabled(),",
            "            is_admin=current_user.has_role(\"Administrator\"),",
            "            login_url=login_url,",
            "            username=current_user.username.replace(\"'\",\"\\\\'\"),",
            "            auth_source=auth_source,",
            "            heartbeat_timeout=config.SERVER_HEARTBEAT_TIMEOUT,",
            "            password_length_min=config.PASSWORD_LENGTH_MIN,",
            "            shared_storage_list=shared_storage_list,",
            "            restricted_shared_storage_list=[] if current_user.has_role(",
            "                \"Administrator\") else restricted_shared_storage_list,",
            "            enable_server_passexec_cmd=config.ENABLE_SERVER_PASS_EXEC_CMD,",
            "        ),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/js/endpoints.js\")",
            "@pgCSRFProtect.exempt",
            "def exposed_urls():",
            "    return make_response(",
            "        render_template('browser/js/endpoints.js'),",
            "        200, {'Content-Type': MIMETYPE_APP_JS}",
            "    )",
            "",
            "",
            "@blueprint.route(\"/js/error.js\")",
            "@pgCSRFProtect.exempt",
            "@pga_login_required",
            "def error_js():",
            "    return make_response(",
            "        render_template('browser/js/error.js', _=gettext),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/js/messages.js\")",
            "@pgCSRFProtect.exempt",
            "def messages_js():",
            "    return make_response(",
            "        render_template('browser/js/messages.js', _=gettext),",
            "        200, {'Content-Type': MIMETYPE_APP_JS})",
            "",
            "",
            "@blueprint.route(\"/browser.css\")",
            "@pgCSRFProtect.exempt",
            "@pga_login_required",
            "def browser_css():",
            "    \"\"\"Render and return CSS snippets from the nodes and modules.\"\"\"",
            "    snippets = []",
            "",
            "    for submodule in blueprint.submodules:",
            "        snippets.extend(submodule.csssnippets)",
            "    return make_response(",
            "        render_template(",
            "            'browser/css/browser.css', snippets=snippets, _=gettext",
            "        ),",
            "        200, {'Content-Type': 'text/css'})",
            "",
            "",
            "@blueprint.route(\"/nodes/\", endpoint=\"nodes\")",
            "@pga_login_required",
            "def get_nodes():",
            "    \"\"\"Build a list of treeview nodes from the child nodes.\"\"\"",
            "    nodes = []",
            "    for submodule in current_blueprint.submodules:",
            "        nodes.extend(submodule.get_nodes())",
            "",
            "    return make_json_response(data=nodes)",
            "",
            "",
            "def form_master_password_response(existing=True, present=False, errmsg=None,",
            "                                  keyring_name='',",
            "                                  invalid_master_password_hook=False):",
            "    return make_json_response(data={",
            "        'present': present,",
            "        'reset': existing,",
            "        'errmsg': errmsg,",
            "        'keyring_name': keyring_name,",
            "        'invalid_master_password_hook': invalid_master_password_hook,",
            "        'is_error': True if errmsg else False",
            "    })",
            "",
            "",
            "@blueprint.route(\"/check_corrupted_db_file\",",
            "                 endpoint=\"check_corrupted_db_file\", methods=[\"GET\"])",
            "def check_corrupted_db_file():",
            "    \"\"\"",
            "    Get the corrupted database file path.",
            "    \"\"\"",
            "    file_location = os.environ['CORRUPTED_DB_BACKUP_FILE'] \\",
            "        if 'CORRUPTED_DB_BACKUP_FILE' in os.environ else ''",
            "    # reset the corrupted db file path in env.",
            "    os.environ['CORRUPTED_DB_BACKUP_FILE'] = ''",
            "    return make_json_response(data=file_location)",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"check_master_password\",",
            "                 methods=[\"GET\"])",
            "def check_master_password():",
            "    \"\"\"",
            "    Checks if the master password is available in the memory",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "    return make_json_response(data=get_crypt_key()[0])",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"reset_master_password\",",
            "                 methods=[\"DELETE\"])",
            "def reset_master_password():",
            "    \"\"\"",
            "    Removes the master password and remove all saved passwords",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "    if not config.DISABLED_LOCAL_PASSWORD_STORAGE:",
            "        # This is to set the Desktop user password so it will not ask for",
            "        # migrate exiting passwords as those are getting cleared",
            "        keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                             KEY_RING_DESKTOP_USER.format(",
            "                                 current_user.username), 'test')",
            "    cleanup_master_password()",
            "    status, crypt_key = get_crypt_key()",
            "    # Set masterpass_check if MASTER_PASSWORD_HOOK is set which provides",
            "    # encryption key",
            "    if config.MASTER_PASSWORD_REQUIRED and config.MASTER_PASSWORD_HOOK:",
            "        set_masterpass_check_text(crypt_key)",
            "    return make_json_response(data=status)",
            "",
            "",
            "@blueprint.route(\"/master_password\", endpoint=\"set_master_password\",",
            "                 methods=[\"POST\"])",
            "def set_master_password():",
            "    \"\"\"",
            "    Set the master password and store in the memory",
            "    This password will be used to encrypt/decrypt saved server passwords",
            "    \"\"\"",
            "",
            "    data = None",
            "",
            "    if request.form:",
            "        data = request.form",
            "    elif request.data:",
            "        data = request.data",
            "        if hasattr(request.data, 'decode'):",
            "            data = request.data.decode('utf-8')",
            "",
            "        if data != '':",
            "            data = json.loads(data)",
            "",
            "    if not config.DISABLED_LOCAL_PASSWORD_STORAGE and \\",
            "            (config.ALLOW_SAVE_PASSWORD or config.ALLOW_SAVE_TUNNEL_PASSWORD):",
            "        if data.get('password') and config.MASTER_PASSWORD_REQUIRED and\\",
            "                not validate_master_password(data.get('password')):",
            "            return form_master_password_response(",
            "                present=False,",
            "                keyring_name=config.KEYRING_NAME,",
            "                errmsg=gettext(\"Incorrect master password\")",
            "            )",
            "        from pgadmin.model import Server",
            "        from pgadmin.utils.crypto import decrypt",
            "        desktop_user = current_user",
            "",
            "        enc_key = data['password']",
            "        if not config.MASTER_PASSWORD_REQUIRED:",
            "            status, enc_key = get_crypt_key()",
            "            if not status:",
            "                raise CryptKeyMissing",
            "",
            "        try:",
            "            all_server = Server.query.all()",
            "            saved_password_servers = [server for server in all_server if",
            "                                      server.save_password]",
            "            # pgAdmin will use the OS password manager to store the server",
            "            # password, here migrating the existing saved server password to",
            "            # OS password manager",
            "            if len(saved_password_servers) > 0 and (keyring.get_password(",
            "                    KEY_RING_SERVICE_NAME, KEY_RING_DESKTOP_USER.format(",
            "                        desktop_user.username)) or enc_key):",
            "                is_migrated = False",
            "",
            "                for server in saved_password_servers:",
            "                    if enc_key:",
            "                        if server.password and config.ALLOW_SAVE_PASSWORD:",
            "                            name = KEY_RING_USERNAME_FORMAT.format(server.name,",
            "                                                                   server.id)",
            "                            password = decrypt(server.password,",
            "                                               enc_key).decode()",
            "                            # Store the password using OS password manager",
            "                            keyring.set_password(KEY_RING_SERVICE_NAME, name,",
            "                                                 password)",
            "                            is_migrated = True",
            "                            setattr(server, 'password', None)",
            "",
            "                        if server.tunnel_password and \\",
            "                                config.ALLOW_SAVE_TUNNEL_PASSWORD:",
            "                            tname = KEY_RING_TUNNEL_FORMAT.format(server.name,",
            "                                                                  server.id)",
            "                            tpassword = decrypt(server.tunnel_password,",
            "                                                enc_key).decode()",
            "                            # Store the password using OS password manager",
            "                            keyring.set_password(KEY_RING_SERVICE_NAME, tname,",
            "                                                 tpassword)",
            "                            is_migrated = True",
            "                            setattr(server, 'tunnel_password', None)",
            "",
            "                db.session.commit()",
            "",
            "                # Store the password using OS password manager",
            "                keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                     KEY_RING_DESKTOP_USER.format(",
            "                                         desktop_user.username), 'test')",
            "                return form_master_password_response(",
            "                    existing=True,",
            "                    present=True,",
            "                    keyring_name=config.KEYRING_NAME if is_migrated else ''",
            "                )",
            "            else:",
            "                if len(all_server) == 0:",
            "                    # Store the password using OS password manager",
            "                    keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                         KEY_RING_DESKTOP_USER.format(",
            "                                             desktop_user.username), 'test')",
            "                    return form_master_password_response(",
            "                        present=True,",
            "                    )",
            "                else:",
            "                    is_master_password_present = True",
            "                    keyring_name = ''",
            "                    for server in all_server:",
            "                        is_password_present = \\",
            "                            server.save_password or server.tunnel_password",
            "                        if server.password and is_password_present:",
            "                            is_master_password_present = False",
            "                            keyring_name = config.KEYRING_NAME",
            "                            break",
            "",
            "                    if is_master_password_present:",
            "                        # Store the password using OS password manager",
            "                        keyring.set_password(KEY_RING_SERVICE_NAME,",
            "                                             KEY_RING_DESKTOP_USER.format(",
            "                                                 desktop_user.username),",
            "                                             'test')",
            "",
            "                    return form_master_password_response(",
            "                        present=is_master_password_present,",
            "                        keyring_name=keyring_name",
            "                    )",
            "        except Exception as e:",
            "            current_app.logger.warning(",
            "                'Fail set password using OS password manager'",
            "                ', fallback to master password. Error: {0}'.format(e)",
            "            )",
            "            config.DISABLED_LOCAL_PASSWORD_STORAGE = True",
            "",
            "    # If the master password is required and the master password hook",
            "    # is specified then try to retrieve the encryption key and update data.",
            "    # If there is an error while retrieving it, return an error message.",
            "    if config.SERVER_MODE and config.MASTER_PASSWORD_REQUIRED and \\",
            "            config.MASTER_PASSWORD_HOOK:",
            "        status, enc_key = get_crypt_key()",
            "        if status:",
            "            data = {'password': enc_key, 'submit_password': True}",
            "        else:",
            "            error = gettext('The master password could not be retrieved from '",
            "                            'the MASTER_PASSWORD_HOOK utility specified {0}.'",
            "                            'Please check that the hook utility is configured'",
            "                            ' correctly.'.format(config.MASTER_PASSWORD_HOOK))",
            "            return form_master_password_response(",
            "                existing=False,",
            "                present=False,",
            "                errmsg=error,",
            "                invalid_master_password_hook=True",
            "            )",
            "",
            "    # Master password is applicable for Desktop mode and in server mode",
            "    # only when auth sources are oauth, kerberos, webserver.",
            "    if (not config.SERVER_MODE) or OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "        or KERBEROS in config.AUTHENTICATION_SOURCES \\",
            "        or WEBSERVER in config.AUTHENTICATION_SOURCES \\",
            "            and config.MASTER_PASSWORD_REQUIRED:",
            "        # if master pass is set previously",
            "        if current_user.masterpass_check is not None and \\",
            "            data.get('submit_password', False) and \\",
            "                not validate_master_password(data.get('password')):",
            "            errmsg = '' if config.MASTER_PASSWORD_HOOK \\",
            "                else gettext(\"Incorrect master password\")",
            "            invalid_master_password_hook = \\",
            "                True if config.MASTER_PASSWORD_HOOK else False",
            "            return form_master_password_response(",
            "                existing=True,",
            "                present=False,",
            "                errmsg=errmsg,",
            "                invalid_master_password_hook=invalid_master_password_hook",
            "            )",
            "",
            "        # if master password received in request",
            "        if data != '' and data.get('password', '') != '':",
            "",
            "            # store the master pass in the memory",
            "            set_crypt_key(data.get('password'))",
            "",
            "            if current_user.masterpass_check is None:",
            "                # master check is not set, which means the server password",
            "                # data is old and is encrypted with old key",
            "                # Re-encrypt with new key",
            "",
            "                from pgadmin.browser.server_groups.servers.utils \\",
            "                    import reencrpyt_server_passwords",
            "                reencrpyt_server_passwords(",
            "                    current_user.id, current_user.password,",
            "                    data.get('password'))",
            "",
            "            # set the encrypted sample text with the new",
            "            # master pass",
            "            set_masterpass_check_text(data.get('password'))",
            "",
            "        # If password in request is empty then try to get it with",
            "        # get_crypt_key method. If get_crypt_key() returns false status and",
            "        # masterpass_check is already set, provide a pop to enter",
            "        # master password(present) without the reset option.(existing).",
            "        elif not get_crypt_key()[0] and \\",
            "                current_user.masterpass_check is not None:",
            "            return form_master_password_response(",
            "                existing=True,",
            "                present=False,",
            "            )",
            "",
            "        # If get_crypt_key return True,but crypt_key is none and",
            "        # user entered blank password, return error message.",
            "        elif not get_crypt_key()[1]:",
            "            error_message = None",
            "            # If user attempted to enter a blank password, then throw error",
            "            if data.get('submit_password') and data.get('password') == '':",
            "                error_message = gettext(\"Master password cannot be empty\")",
            "            return form_master_password_response(",
            "                existing=False,",
            "                present=False,",
            "                errmsg=error_message",
            "            )",
            "",
            "    # if master password is disabled now, but was used once then",
            "    # remove all the saved passwords",
            "    process_masterpass_disabled()",
            "",
            "    if config.SERVER_MODE and current_user.masterpass_check is None:",
            "",
            "        crypt_key = get_crypt_key()[1]",
            "        from pgadmin.browser.server_groups.servers.utils \\",
            "            import reencrpyt_server_passwords",
            "        reencrpyt_server_passwords(",
            "            current_user.id, current_user.password, crypt_key)",
            "",
            "        set_masterpass_check_text(crypt_key)",
            "",
            "    return form_master_password_response(",
            "        present=True,",
            "    )",
            "",
            "",
            "# Only register route if SECURITY_CHANGEABLE is set to True",
            "# We can't access app context here so cannot",
            "# use app.config['SECURITY_CHANGEABLE']",
            "",
            "",
            "if hasattr(config, 'SECURITY_CHANGEABLE') and config.SECURITY_CHANGEABLE:",
            "    @blueprint.route(\"/change_password\", endpoint=\"change_password\",",
            "                     methods=['GET', 'POST'])",
            "    @pgCSRFProtect.exempt",
            "    @pga_login_required",
            "    def change_password():",
            "        \"\"\"View function which handles a change password request.\"\"\"",
            "",
            "        form_class = _security.forms.get('change_password_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if not req_json:",
            "            form = form_class()",
            "            return {",
            "                'csrf_token': form.csrf_token._value()",
            "            }",
            "        elif req_json:",
            "            form = form_class(MultiDict(req_json))",
            "            if form.validate():",
            "                errormsg = None",
            "                # change_user_password from flask-security logs out the user",
            "                # this is undesirable, so change password on own",
            "                try:",
            "                    user = User.query.filter(",
            "                        User.fs_uniquifier == current_user.fs_uniquifier)\\",
            "                        .first()",
            "                    user.password = hash_password(form.new_password.data)",
            "",
            "                    try:",
            "                        send_password_changed_notice(user)",
            "                    except Exception as _:",
            "                        # No need to throw error if failed in sending email",
            "                        pass",
            "                except Exception as e:",
            "                    # Handle other exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    errormsg = gettext(PASS_ERROR).format(e)",
            "",
            "                if errormsg is None:",
            "                    old_key = get_crypt_key()[1]",
            "                    set_crypt_key(form.new_password.data, False)",
            "",
            "                    from pgadmin.browser.server_groups.servers.utils \\",
            "                        import reencrpyt_server_passwords",
            "                    reencrpyt_server_passwords(",
            "                        current_user.id, old_key, form.new_password.data)",
            "",
            "                    db.session.commit()",
            "                elif errormsg is not None:",
            "                    return internal_server_error(errormsg)",
            "            else:",
            "                return bad_request(list(form.errors.values())[0][0])",
            "",
            "        return make_json_response(",
            "            success=1,",
            "            info=gettext('pgAdmin user password changed successfully')",
            "        )",
            "",
            "# Only register route if SECURITY_RECOVERABLE is set to True",
            "if hasattr(config, 'SECURITY_RECOVERABLE') and config.SECURITY_RECOVERABLE:",
            "",
            "    def send_reset_password_instructions(user):",
            "        \"\"\"Sends the reset password instructions email for the specified user.",
            "",
            "        :param user: The user to send the instructions to",
            "        \"\"\"",
            "        token = generate_reset_password_token(user)",
            "        reset_link = url_for('browser.reset_password', token=token,",
            "                             _external=True)",
            "",
            "        send_mail(config_value('EMAIL_SUBJECT_PASSWORD_RESET'), user.email,",
            "                  'reset_instructions',",
            "                  user=user, reset_link=reset_link)",
            "",
            "        reset_password_instructions_sent.send(",
            "            current_app._get_current_object(),",
            "            user=user, token=token)",
            "",
            "    @blueprint.route(\"/reset_password\", endpoint=\"forgot_password\",",
            "                     methods=['GET', 'POST'])",
            "    @pgCSRFProtect.exempt",
            "    @anonymous_user_required",
            "    def forgot_password():",
            "        \"\"\"View function that handles a forgotten password request.\"\"\"",
            "        has_error = False",
            "        form_class = _security.forms.get('forgot_password_form').cls",
            "        req_json = request.get_json(silent=True)",
            "",
            "        if req_json:",
            "            form = form_class(MultiDict(req_json))",
            "        else:",
            "            form = form_class()",
            "",
            "        if form.validate_on_submit():",
            "            # Check the Authentication source of the User",
            "            user = User.query.filter_by(",
            "                email=form.data['email'],",
            "                auth_source=INTERNAL",
            "            ).first()",
            "",
            "            if user is None:",
            "                # If the user is not an internal user, raise the exception",
            "                flash(gettext('Your account is authenticated using an '",
            "                              'external {} source. '",
            "                              'Please contact the administrators of this '",
            "                              'service if you need to reset your password.'",
            "                              ).format(form.user.auth_source),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            if not has_error:",
            "                try:",
            "                    send_reset_password_instructions(form.user)",
            "                except SOCKETErrorException as e:",
            "                    # Handle socket errors which are not",
            "                    # covered by SMTPExceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(SMTP_SOCKET_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "                except (SMTPConnectError, SMTPResponseException,",
            "                        SMTPServerDisconnected, SMTPDataError, SMTPHeloError,",
            "                        SMTPException, SMTPAuthenticationError,",
            "                        SMTPSenderRefused, SMTPRecipientsRefused) as e:",
            "",
            "                    # Handle smtp specific exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(SMTP_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "                except Exception as e:",
            "                    # Handle other exceptions.",
            "                    logging.exception(str(e), exc_info=True)",
            "                    flash(gettext(PASS_ERROR).format(e),",
            "                          MessageType.ERROR)",
            "                    has_error = True",
            "",
            "            if request.get_json(silent=True) is None and not has_error:",
            "                do_flash(*get_message('PASSWORD_RESET_REQUEST',",
            "                                      email=form.user.email))",
            "",
            "        if request.get_json(silent=True) and not has_error:",
            "            return default_render_json(form, include_user=False)",
            "",
            "        for errors in form.errors.values():",
            "            for error in errors:",
            "                flash(error, MessageType.WARNING)",
            "",
            "        return _security.render_template(",
            "            config_value('FORGOT_PASSWORD_TEMPLATE'),",
            "            forgot_password_form=form,",
            "            **_ctx('forgot_password'))",
            "",
            "    # We are not in app context so cannot use",
            "    # url_for('browser.forgot_password')",
            "    # So hard code the url '/browser/reset_password' while passing as",
            "    # parameter to slash_url_suffix function.",
            "    @blueprint.route(",
            "        '/reset_password' + slash_url_suffix(",
            "            '/browser/reset_password', '<token>'",
            "        ),",
            "        methods=['GET', 'POST'],",
            "        endpoint='reset_password'",
            "    )",
            "    @pgCSRFProtect.exempt",
            "    @anonymous_user_required",
            "    def reset_password(token):",
            "        \"\"\"View function that handles a reset password request.\"\"\"",
            "        expired, invalid, user = reset_password_token_status(token)",
            "",
            "        if invalid:",
            "            do_flash(*get_message('INVALID_RESET_PASSWORD_TOKEN'))",
            "        if expired:",
            "            do_flash(*get_message('PASSWORD_RESET_EXPIRED', email=user.email,",
            "                                  within=_security.reset_password_within))",
            "        if invalid or expired:",
            "            return redirect(url_for('browser.forgot_password'))",
            "        has_error = False",
            "        form_class = _security.forms.get('reset_password_form').cls",
            "        form = form_class(request.form) if request.form else form_class()",
            "",
            "        if form.validate_on_submit():",
            "            try:",
            "                update_password(user, form.password.data)",
            "            except SOCKETErrorException as e:",
            "                # Handle socket errors which are not covered by SMTPExceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(SMTP_SOCKET_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            except (SMTPConnectError, SMTPResponseException,",
            "                    SMTPServerDisconnected, SMTPDataError, SMTPHeloError,",
            "                    SMTPException, SMTPAuthenticationError, SMTPSenderRefused,",
            "                    SMTPRecipientsRefused) as e:",
            "",
            "                # Handle smtp specific exceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(SMTP_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "            except Exception as e:",
            "                # Handle other exceptions.",
            "                logging.exception(str(e), exc_info=True)",
            "                flash(gettext(PASS_ERROR).format(e),",
            "                      MessageType.ERROR)",
            "                has_error = True",
            "",
            "            if not has_error:",
            "                after_this_request(view_commit)",
            "                auth_obj = AuthSourceManager(form, [INTERNAL])",
            "                session['_auth_source_manager_obj'] = auth_obj.as_dict()",
            "",
            "                if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    flash(gettext('You successfully reset your password but'",
            "                                  ' your account is locked. Please contact '",
            "                                  'the Administrator.'),",
            "                          MessageType.WARNING)",
            "                    return redirect(get_post_logout_redirect())",
            "                do_flash(*get_message('PASSWORD_RESET'))",
            "                login_user(user)",
            "                auth_obj = AuthSourceManager(form, [INTERNAL])",
            "                session['auth_source_manager'] = auth_obj.as_dict()",
            "",
            "                return redirect(get_url(_security.post_reset_view) or",
            "                                get_url(_security.post_login_view))",
            "",
            "        return _security.render_template(",
            "            config_value('RESET_PASSWORD_TEMPLATE'),",
            "            reset_password_form=form,",
            "            reset_password_token=token,",
            "            **_ctx('reset_password'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [],
            "380": [],
            "381": [],
            "474": [],
            "595": [],
            "612": [],
            "627": [],
            "934": []
        },
        "addLocation": []
    },
    "web/pgadmin/browser/server_groups/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from flask import request, jsonify, render_template"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from flask_babel import gettext"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_security import current_user, login_required"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from flask_security import current_user"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from pgadmin.user_login_check import pga_login_required"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pgadmin.browser import BrowserPluginModule"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pgadmin.browser.utils import NodeView"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from pgadmin.utils.ajax import make_json_response, gone, \\"
            },
            "9": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     parent_ids = []"
            },
            "10": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     ids = [{'type': 'int', 'id': 'gid'}]"
            },
            "11": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    @pga_login_required"
            },
            "14": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     def list(self):"
            },
            "15": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         res = []"
            },
            "16": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         return ajax_response(response=res, status=200)"
            },
            "19": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+    @pga_login_required"
            },
            "22": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     def delete(self, gid):"
            },
            "23": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         \"\"\"Delete a server group node in the settings database\"\"\""
            },
            "24": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         return make_json_response(result=request.form)"
            },
            "27": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+    @pga_login_required"
            },
            "30": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     def update(self, gid):"
            },
            "31": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         \"\"\"Update the server-group properties\"\"\""
            },
            "32": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             )"
            },
            "34": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         )"
            },
            "35": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 284,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    @pga_login_required"
            },
            "38": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "     def properties(self, gid):"
            },
            "39": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         \"\"\"Update the server-group properties\"\"\""
            },
            "40": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "                 status=200"
            },
            "42": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             )"
            },
            "43": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    @pga_login_required"
            },
            "46": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     def create(self):"
            },
            "47": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "         \"\"\"Creates new server-group \"\"\""
            },
            "48": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "         data = request.form if request.form else json.loads("
            },
            "49": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "                 success=0,"
            },
            "50": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "                 errormsg=gettext('No server group name was specified'))"
            },
            "51": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 352,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    @pga_login_required"
            },
            "54": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "     def sql(self, gid):"
            },
            "55": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         return make_json_response(status=422)"
            },
            "56": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 356,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    @pga_login_required"
            },
            "59": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "     def modified_sql(self, gid):"
            },
            "60": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         return make_json_response(status=422)"
            },
            "61": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+    @pga_login_required"
            },
            "64": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     def statistics(self, gid):"
            },
            "65": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         return make_json_response(status=422)"
            },
            "66": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 364,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+    @pga_login_required"
            },
            "69": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "     def dependencies(self, gid):"
            },
            "70": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "         return make_json_response(status=422)"
            },
            "71": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 368,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+    @pga_login_required"
            },
            "74": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "     def dependents(self, gid):"
            },
            "75": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         return make_json_response(status=422)"
            },
            "76": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 372,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "                 groups.append(group)"
            },
            "78": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         return groups"
            },
            "79": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 397,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @login_required"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+    @pga_login_required"
            },
            "82": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "     def nodes(self, gid=None):"
            },
            "83": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         \"\"\"Return a JSON document listing the server groups for the user\"\"\""
            },
            "84": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         nodes = []"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"Defines views for management of server groups\"\"\"",
            "",
            "import json",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from flask import request, jsonify, render_template",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from pgadmin.browser import BrowserPluginModule",
            "from pgadmin.browser.utils import NodeView",
            "from pgadmin.utils.ajax import make_json_response, gone, \\",
            "    make_response as ajax_response, bad_request",
            "from pgadmin.utils.menu import MenuItem",
            "from sqlalchemy import exc",
            "from pgadmin.model import db, ServerGroup, Server",
            "import config",
            "from pgadmin.utils.preferences import Preferences",
            "",
            "",
            "def get_icon_css_class(group_id, group_user_id,",
            "                       default_val='icon-server_group'):",
            "    \"\"\"",
            "    Returns css value",
            "    :param group_id:",
            "    :param group_user_id:",
            "    :param default_val:",
            "    :return: default_val",
            "    \"\"\"",
            "    if (config.SERVER_MODE and",
            "        group_user_id != current_user.id and",
            "            ServerGroupModule.has_shared_server(group_id)):",
            "        default_val = 'icon-server_group_shared'",
            "        return default_val, True",
            "",
            "    return default_val, False",
            "",
            "",
            "SG_NOT_FOUND_ERROR = 'The specified server group could not be found.'",
            "",
            "",
            "class ServerGroupModule(BrowserPluginModule):",
            "    _NODE_TYPE = \"server_group\"",
            "    node_icon = \"icon-%s\" % _NODE_TYPE",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        snippets = [render_template(\"css/server_group.css\")]",
            "",
            "        for submodule in self.submodules:",
            "            snippets.extend(submodule.csssnippets)",
            "",
            "        return snippets",
            "",
            "    @staticmethod",
            "    def has_shared_server(gid):",
            "        \"\"\"",
            "        To check whether given server group contains shared server or not",
            "        :param gid:",
            "        :return: True if servergroup contains shared server else false",
            "        \"\"\"",
            "        servers = Server.query.filter_by(servergroup_id=gid)",
            "        for s in servers:",
            "            if s.shared:",
            "                return True",
            "        return False",
            "",
            "    def get_nodes(self, *arg, **kwargs):",
            "        \"\"\"Return a JSON document listing the server groups for the user\"\"\"",
            "",
            "        if config.SERVER_MODE:",
            "            groups = ServerGroupView.get_all_server_groups()",
            "        else:",
            "            groups = ServerGroup.query.filter_by(",
            "                user_id=current_user.id",
            "            ).order_by(\"id\")",
            "",
            "        for idx, group in enumerate(groups):",
            "            icon_class, is_shared = get_icon_css_class(group.id, group.user_id)",
            "            yield self.generate_browser_node(",
            "                \"%d\" % (group.id), None,",
            "                group.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                can_delete=True if idx > 0 else False,",
            "                user_id=group.user_id,",
            "                is_shared=is_shared",
            "            )",
            "",
            "    @property",
            "    def node_type(self):",
            "        \"\"\"",
            "        node_type",
            "        Node type for Server Group is server-group. It is defined by _NODE_TYPE",
            "        static attribute of the class.",
            "        \"\"\"",
            "        return self._NODE_TYPE",
            "",
            "    @property",
            "    def script_load(self):",
            "        \"\"\"",
            "        script_load",
            "        Load the server-group javascript module on loading of browser module.",
            "        \"\"\"",
            "        return None",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        register_preferences",
            "        Overrides the register_preferences PgAdminModule, because - we will not",
            "        register any preference for server-group (specially the show_node",
            "        preference.)",
            "        \"\"\"",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .servers import blueprint as module",
            "        self.submodules.append(module)",
            "        super().register(app, options)",
            "",
            "",
            "class ServerGroupMenuItem(MenuItem):",
            "    def __init__(self, **kwargs):",
            "        kwargs.setdefault(\"type\", ServerGroupModule.node_type)",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class ServerGroupPluginModule(BrowserPluginModule, metaclass=ABCMeta):",
            "    \"\"\"",
            "    Base class for server group plugins.",
            "    \"\"\"",
            "",
            "    @abstractmethod",
            "    def get_nodes(self, *arg, **kwargs):",
            "        pass",
            "",
            "",
            "blueprint = ServerGroupModule(__name__)",
            "",
            "",
            "class ServerGroupView(NodeView):",
            "    node_type = ServerGroupModule._NODE_TYPE",
            "    node_icon = ServerGroupModule.node_icon",
            "    node_label = \"Server Group\"",
            "",
            "    parent_ids = []",
            "    ids = [{'type': 'int', 'id': 'gid'}]",
            "",
            "    @login_required",
            "    def list(self):",
            "        res = []",
            "",
            "        for sg in ServerGroup.query.filter_by(",
            "                user_id=current_user.id",
            "        ).order_by('name'):",
            "            res.append({",
            "                'id': sg.id,",
            "                'name': sg.name",
            "            })",
            "",
            "        return ajax_response(response=res, status=200)",
            "",
            "    @login_required",
            "    def delete(self, gid):",
            "        \"\"\"Delete a server group node in the settings database\"\"\"",
            "",
            "        groups = ServerGroup.query.filter_by(",
            "            user_id=current_user.id",
            "        ).order_by(\"id\")",
            "",
            "        # if server group id is 1 we won't delete it.",
            "        # This matches the behavior of",
            "        # web/pgadmin/utils/__init.py__#clear_database_servers",
            "        # called by the setup script when importing and replacing servers:",
            "        # `python setup.py load-servers input_file.json --replace`",
            "        sg = groups.first()",
            "",
            "        shared_servers = Server.query.filter_by(servergroup_id=gid,",
            "                                                shared=True).all()",
            "        if shared_servers:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(",
            "                    'The specified server group cannot be deleted.'",
            "                )",
            "            )",
            "",
            "        if sg.id == gid:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(",
            "                    'The specified server group cannot be deleted.'",
            "                )",
            "            )",
            "",
            "        # There can be only one record at most",
            "        sg = groups.filter_by(id=gid).first()",
            "",
            "        if sg is None:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            try:",
            "                db.session.delete(sg)",
            "                db.session.commit()",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410, success=0, errormsg=e.message",
            "                )",
            "",
            "        return make_json_response(result=request.form)",
            "",
            "    @login_required",
            "    def update(self, gid):",
            "        \"\"\"Update the server-group properties\"\"\"",
            "",
            "        # There can be only one record at most",
            "        servergroup = ServerGroup.query.filter_by(",
            "            user_id=current_user.id,",
            "            id=gid).first()",
            "",
            "        data = request.form if request.form else json.loads(",
            "            request.data",
            "        )",
            "",
            "        if servergroup is None:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            try:",
            "                if 'name' in data:",
            "                    servergroup.name = data['name']",
            "                db.session.commit()",
            "            except exc.IntegrityError:",
            "                db.session.rollback()",
            "                return bad_request(gettext(",
            "                    \"The specified server group already exists.\"",
            "                ))",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410, success=0, errormsg=e.message",
            "                )",
            "",
            "        icon_class, is_shared = get_icon_css_class(gid, servergroup.user_id)",
            "        return jsonify(",
            "            node=self.blueprint.generate_browser_node(",
            "                gid,",
            "                None,",
            "                servergroup.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                can_delete=True,  # This is user created hence can delete",
            "                is_shared=is_shared",
            "            )",
            "        )",
            "",
            "    @login_required",
            "    def properties(self, gid):",
            "        \"\"\"Update the server-group properties\"\"\"",
            "",
            "        sg = ServerGroup.query.filter(ServerGroup.id == gid).first()",
            "",
            "        if sg is None:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            return ajax_response(",
            "                response={'id': sg.id, 'name': sg.name, 'user_id': sg.user_id},",
            "                status=200",
            "            )",
            "",
            "    @login_required",
            "    def create(self):",
            "        \"\"\"Creates new server-group \"\"\"",
            "        data = request.form if request.form else json.loads(",
            "            request.data",
            "        )",
            "        if data['name'] != '':",
            "            try:",
            "                sg = ServerGroup(",
            "                    user_id=current_user.id,",
            "                    name=data['name'])",
            "                db.session.add(sg)",
            "                db.session.commit()",
            "",
            "                data['id'] = sg.id",
            "                data['name'] = sg.name",
            "",
            "                icon_class, is_shared = get_icon_css_class(sg.id, sg.user_id)",
            "                return jsonify(",
            "                    node=self.blueprint.generate_browser_node(",
            "                        \"%d\" % sg.id,",
            "                        None,",
            "                        sg.name,",
            "                        icon_class,",
            "                        True,",
            "                        self.node_type,",
            "                        # This is user created hence can deleted",
            "                        can_delete=True,",
            "                        is_shared=is_shared",
            "                    )",
            "                )",
            "            except exc.IntegrityError:",
            "                db.session.rollback()",
            "                return bad_request(gettext(",
            "                    \"The specified server group already exists.\"",
            "                ))",
            "",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410,",
            "                    success=0,",
            "                    errormsg=e.message)",
            "",
            "        else:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext('No server group name was specified'))",
            "",
            "    @login_required",
            "    def sql(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @login_required",
            "    def modified_sql(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @login_required",
            "    def statistics(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @login_required",
            "    def dependencies(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @login_required",
            "    def dependents(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @staticmethod",
            "    def get_all_server_groups():",
            "        \"\"\"",
            "        Returns the list of server groups to show in server mode and",
            "        if there is any shared server in the group.",
            "        :return: server groups",
            "        \"\"\"",
            "",
            "        # Don't display shared server if user has",
            "        # selected 'Hide shared server'",
            "        pref = Preferences.module('browser')",
            "        hide_shared_server = pref.preference('hide_shared_server').get()",
            "",
            "        server_groups = ServerGroup.query.all()",
            "        groups = []",
            "        for group in server_groups:",
            "            if hide_shared_server and \\",
            "                ServerGroupModule.has_shared_server(group.id) and \\",
            "                    group.user_id != current_user.id:",
            "                continue",
            "            if group.user_id == current_user.id or \\",
            "                    ServerGroupModule.has_shared_server(group.id):",
            "                groups.append(group)",
            "        return groups",
            "",
            "    @login_required",
            "    def nodes(self, gid=None):",
            "        \"\"\"Return a JSON document listing the server groups for the user\"\"\"",
            "        nodes = []",
            "        if gid is None:",
            "            if config.SERVER_MODE:",
            "",
            "                groups = self.get_all_server_groups()",
            "            else:",
            "                groups = ServerGroup.query.filter_by(user_id=current_user.id)",
            "",
            "            for group in groups:",
            "                icon_class, is_shared = get_icon_css_class(group.id,",
            "                                                           group.user_id)",
            "                nodes.append(",
            "                    self.blueprint.generate_browser_node(",
            "                        \"%d\" % group.id,",
            "                        None,",
            "                        group.name,",
            "                        icon_class,",
            "                        True,",
            "                        self.node_type,",
            "                        is_shared=is_shared",
            "                    )",
            "                )",
            "        else:",
            "            group = ServerGroup.query.filter(ServerGroup.id == gid).first()",
            "",
            "            if not group:",
            "                return gone(",
            "                    errormsg=gettext(\"Could not find the server group.\")",
            "                )",
            "",
            "            icon_class, is_shared = get_icon_css_class(group.id,",
            "                                                       group.user_id)",
            "            nodes = self.blueprint.generate_browser_node(",
            "                \"%d\" % (group.id), None,",
            "                group.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                is_shared=is_shared",
            "            )",
            "",
            "        return make_json_response(data=nodes)",
            "",
            "    def node(self, gid):",
            "        return self.nodes(gid)",
            "",
            "",
            "ServerGroupView.register_node_view(blueprint)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"Defines views for management of server groups\"\"\"",
            "",
            "import json",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from flask import request, jsonify, render_template",
            "from flask_babel import gettext",
            "from flask_security import current_user",
            "from pgadmin.user_login_check import pga_login_required",
            "from pgadmin.browser import BrowserPluginModule",
            "from pgadmin.browser.utils import NodeView",
            "from pgadmin.utils.ajax import make_json_response, gone, \\",
            "    make_response as ajax_response, bad_request",
            "from pgadmin.utils.menu import MenuItem",
            "from sqlalchemy import exc",
            "from pgadmin.model import db, ServerGroup, Server",
            "import config",
            "from pgadmin.utils.preferences import Preferences",
            "",
            "",
            "def get_icon_css_class(group_id, group_user_id,",
            "                       default_val='icon-server_group'):",
            "    \"\"\"",
            "    Returns css value",
            "    :param group_id:",
            "    :param group_user_id:",
            "    :param default_val:",
            "    :return: default_val",
            "    \"\"\"",
            "    if (config.SERVER_MODE and",
            "        group_user_id != current_user.id and",
            "            ServerGroupModule.has_shared_server(group_id)):",
            "        default_val = 'icon-server_group_shared'",
            "        return default_val, True",
            "",
            "    return default_val, False",
            "",
            "",
            "SG_NOT_FOUND_ERROR = 'The specified server group could not be found.'",
            "",
            "",
            "class ServerGroupModule(BrowserPluginModule):",
            "    _NODE_TYPE = \"server_group\"",
            "    node_icon = \"icon-%s\" % _NODE_TYPE",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        snippets = [render_template(\"css/server_group.css\")]",
            "",
            "        for submodule in self.submodules:",
            "            snippets.extend(submodule.csssnippets)",
            "",
            "        return snippets",
            "",
            "    @staticmethod",
            "    def has_shared_server(gid):",
            "        \"\"\"",
            "        To check whether given server group contains shared server or not",
            "        :param gid:",
            "        :return: True if servergroup contains shared server else false",
            "        \"\"\"",
            "        servers = Server.query.filter_by(servergroup_id=gid)",
            "        for s in servers:",
            "            if s.shared:",
            "                return True",
            "        return False",
            "",
            "    def get_nodes(self, *arg, **kwargs):",
            "        \"\"\"Return a JSON document listing the server groups for the user\"\"\"",
            "",
            "        if config.SERVER_MODE:",
            "            groups = ServerGroupView.get_all_server_groups()",
            "        else:",
            "            groups = ServerGroup.query.filter_by(",
            "                user_id=current_user.id",
            "            ).order_by(\"id\")",
            "",
            "        for idx, group in enumerate(groups):",
            "            icon_class, is_shared = get_icon_css_class(group.id, group.user_id)",
            "            yield self.generate_browser_node(",
            "                \"%d\" % (group.id), None,",
            "                group.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                can_delete=True if idx > 0 else False,",
            "                user_id=group.user_id,",
            "                is_shared=is_shared",
            "            )",
            "",
            "    @property",
            "    def node_type(self):",
            "        \"\"\"",
            "        node_type",
            "        Node type for Server Group is server-group. It is defined by _NODE_TYPE",
            "        static attribute of the class.",
            "        \"\"\"",
            "        return self._NODE_TYPE",
            "",
            "    @property",
            "    def script_load(self):",
            "        \"\"\"",
            "        script_load",
            "        Load the server-group javascript module on loading of browser module.",
            "        \"\"\"",
            "        return None",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        register_preferences",
            "        Overrides the register_preferences PgAdminModule, because - we will not",
            "        register any preference for server-group (specially the show_node",
            "        preference.)",
            "        \"\"\"",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .servers import blueprint as module",
            "        self.submodules.append(module)",
            "        super().register(app, options)",
            "",
            "",
            "class ServerGroupMenuItem(MenuItem):",
            "    def __init__(self, **kwargs):",
            "        kwargs.setdefault(\"type\", ServerGroupModule.node_type)",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class ServerGroupPluginModule(BrowserPluginModule, metaclass=ABCMeta):",
            "    \"\"\"",
            "    Base class for server group plugins.",
            "    \"\"\"",
            "",
            "    @abstractmethod",
            "    def get_nodes(self, *arg, **kwargs):",
            "        pass",
            "",
            "",
            "blueprint = ServerGroupModule(__name__)",
            "",
            "",
            "class ServerGroupView(NodeView):",
            "    node_type = ServerGroupModule._NODE_TYPE",
            "    node_icon = ServerGroupModule.node_icon",
            "    node_label = \"Server Group\"",
            "",
            "    parent_ids = []",
            "    ids = [{'type': 'int', 'id': 'gid'}]",
            "",
            "    @pga_login_required",
            "    def list(self):",
            "        res = []",
            "",
            "        for sg in ServerGroup.query.filter_by(",
            "                user_id=current_user.id",
            "        ).order_by('name'):",
            "            res.append({",
            "                'id': sg.id,",
            "                'name': sg.name",
            "            })",
            "",
            "        return ajax_response(response=res, status=200)",
            "",
            "    @pga_login_required",
            "    def delete(self, gid):",
            "        \"\"\"Delete a server group node in the settings database\"\"\"",
            "",
            "        groups = ServerGroup.query.filter_by(",
            "            user_id=current_user.id",
            "        ).order_by(\"id\")",
            "",
            "        # if server group id is 1 we won't delete it.",
            "        # This matches the behavior of",
            "        # web/pgadmin/utils/__init.py__#clear_database_servers",
            "        # called by the setup script when importing and replacing servers:",
            "        # `python setup.py load-servers input_file.json --replace`",
            "        sg = groups.first()",
            "",
            "        shared_servers = Server.query.filter_by(servergroup_id=gid,",
            "                                                shared=True).all()",
            "        if shared_servers:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(",
            "                    'The specified server group cannot be deleted.'",
            "                )",
            "            )",
            "",
            "        if sg.id == gid:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(",
            "                    'The specified server group cannot be deleted.'",
            "                )",
            "            )",
            "",
            "        # There can be only one record at most",
            "        sg = groups.filter_by(id=gid).first()",
            "",
            "        if sg is None:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            try:",
            "                db.session.delete(sg)",
            "                db.session.commit()",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410, success=0, errormsg=e.message",
            "                )",
            "",
            "        return make_json_response(result=request.form)",
            "",
            "    @pga_login_required",
            "    def update(self, gid):",
            "        \"\"\"Update the server-group properties\"\"\"",
            "",
            "        # There can be only one record at most",
            "        servergroup = ServerGroup.query.filter_by(",
            "            user_id=current_user.id,",
            "            id=gid).first()",
            "",
            "        data = request.form if request.form else json.loads(",
            "            request.data",
            "        )",
            "",
            "        if servergroup is None:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            try:",
            "                if 'name' in data:",
            "                    servergroup.name = data['name']",
            "                db.session.commit()",
            "            except exc.IntegrityError:",
            "                db.session.rollback()",
            "                return bad_request(gettext(",
            "                    \"The specified server group already exists.\"",
            "                ))",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410, success=0, errormsg=e.message",
            "                )",
            "",
            "        icon_class, is_shared = get_icon_css_class(gid, servergroup.user_id)",
            "        return jsonify(",
            "            node=self.blueprint.generate_browser_node(",
            "                gid,",
            "                None,",
            "                servergroup.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                can_delete=True,  # This is user created hence can delete",
            "                is_shared=is_shared",
            "            )",
            "        )",
            "",
            "    @pga_login_required",
            "    def properties(self, gid):",
            "        \"\"\"Update the server-group properties\"\"\"",
            "",
            "        sg = ServerGroup.query.filter(ServerGroup.id == gid).first()",
            "",
            "        if sg is None:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=gettext(SG_NOT_FOUND_ERROR)",
            "            )",
            "        else:",
            "            return ajax_response(",
            "                response={'id': sg.id, 'name': sg.name, 'user_id': sg.user_id},",
            "                status=200",
            "            )",
            "",
            "    @pga_login_required",
            "    def create(self):",
            "        \"\"\"Creates new server-group \"\"\"",
            "        data = request.form if request.form else json.loads(",
            "            request.data",
            "        )",
            "        if data['name'] != '':",
            "            try:",
            "                sg = ServerGroup(",
            "                    user_id=current_user.id,",
            "                    name=data['name'])",
            "                db.session.add(sg)",
            "                db.session.commit()",
            "",
            "                data['id'] = sg.id",
            "                data['name'] = sg.name",
            "",
            "                icon_class, is_shared = get_icon_css_class(sg.id, sg.user_id)",
            "                return jsonify(",
            "                    node=self.blueprint.generate_browser_node(",
            "                        \"%d\" % sg.id,",
            "                        None,",
            "                        sg.name,",
            "                        icon_class,",
            "                        True,",
            "                        self.node_type,",
            "                        # This is user created hence can deleted",
            "                        can_delete=True,",
            "                        is_shared=is_shared",
            "                    )",
            "                )",
            "            except exc.IntegrityError:",
            "                db.session.rollback()",
            "                return bad_request(gettext(",
            "                    \"The specified server group already exists.\"",
            "                ))",
            "",
            "            except Exception as e:",
            "                db.session.rollback()",
            "                return make_json_response(",
            "                    status=410,",
            "                    success=0,",
            "                    errormsg=e.message)",
            "",
            "        else:",
            "            return make_json_response(",
            "                status=417,",
            "                success=0,",
            "                errormsg=gettext('No server group name was specified'))",
            "",
            "    @pga_login_required",
            "    def sql(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @pga_login_required",
            "    def modified_sql(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @pga_login_required",
            "    def statistics(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @pga_login_required",
            "    def dependencies(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @pga_login_required",
            "    def dependents(self, gid):",
            "        return make_json_response(status=422)",
            "",
            "    @staticmethod",
            "    def get_all_server_groups():",
            "        \"\"\"",
            "        Returns the list of server groups to show in server mode and",
            "        if there is any shared server in the group.",
            "        :return: server groups",
            "        \"\"\"",
            "",
            "        # Don't display shared server if user has",
            "        # selected 'Hide shared server'",
            "        pref = Preferences.module('browser')",
            "        hide_shared_server = pref.preference('hide_shared_server').get()",
            "",
            "        server_groups = ServerGroup.query.all()",
            "        groups = []",
            "        for group in server_groups:",
            "            if hide_shared_server and \\",
            "                ServerGroupModule.has_shared_server(group.id) and \\",
            "                    group.user_id != current_user.id:",
            "                continue",
            "            if group.user_id == current_user.id or \\",
            "                    ServerGroupModule.has_shared_server(group.id):",
            "                groups.append(group)",
            "        return groups",
            "",
            "    @pga_login_required",
            "    def nodes(self, gid=None):",
            "        \"\"\"Return a JSON document listing the server groups for the user\"\"\"",
            "        nodes = []",
            "        if gid is None:",
            "            if config.SERVER_MODE:",
            "",
            "                groups = self.get_all_server_groups()",
            "            else:",
            "                groups = ServerGroup.query.filter_by(user_id=current_user.id)",
            "",
            "            for group in groups:",
            "                icon_class, is_shared = get_icon_css_class(group.id,",
            "                                                           group.user_id)",
            "                nodes.append(",
            "                    self.blueprint.generate_browser_node(",
            "                        \"%d\" % group.id,",
            "                        None,",
            "                        group.name,",
            "                        icon_class,",
            "                        True,",
            "                        self.node_type,",
            "                        is_shared=is_shared",
            "                    )",
            "                )",
            "        else:",
            "            group = ServerGroup.query.filter(ServerGroup.id == gid).first()",
            "",
            "            if not group:",
            "                return gone(",
            "                    errormsg=gettext(\"Could not find the server group.\")",
            "                )",
            "",
            "            icon_class, is_shared = get_icon_css_class(group.id,",
            "                                                       group.user_id)",
            "            nodes = self.blueprint.generate_browser_node(",
            "                \"%d\" % (group.id), None,",
            "                group.name,",
            "                icon_class,",
            "                True,",
            "                self.node_type,",
            "                is_shared=is_shared",
            "            )",
            "",
            "        return make_json_response(data=nodes)",
            "",
            "    def node(self, gid):",
            "        return self.nodes(gid)",
            "",
            "",
            "ServerGroupView.register_node_view(blueprint)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [],
            "165": [
                "ServerGroupView"
            ],
            "179": [
                "ServerGroupView"
            ],
            "235": [
                "ServerGroupView"
            ],
            "284": [
                "ServerGroupView"
            ],
            "302": [
                "ServerGroupView"
            ],
            "352": [
                "ServerGroupView"
            ],
            "356": [
                "ServerGroupView"
            ],
            "360": [
                "ServerGroupView"
            ],
            "364": [
                "ServerGroupView"
            ],
            "368": [
                "ServerGroupView"
            ],
            "397": [
                "ServerGroupView"
            ]
        },
        "addLocation": []
    }
}