{
    "poetry/core/vcs/git.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Any"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Optional"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from poetry.core.utils._compat import WINDOWS"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " pattern_formats = {"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     \"protocol\": r\"\\w+\","
            },
            "8": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\", \"subdirectory\"])"
            },
            "9": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+_executable: Optional[str] = None"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+def executable():"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    global _executable"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+    if _executable is not None:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        return _executable"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+    if WINDOWS:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        # Finding git via where.exe"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        where = \"%WINDIR%\\\\System32\\\\where.exe\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        paths = subprocess.check_output("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            [where, \"git\"], shell=True, encoding=\"oem\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+        ).split(\"\\n\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        for path in paths:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            if not path:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                continue"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            path = Path(path.strip())"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+            try:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                path.relative_to(Path.cwd())"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            except ValueError:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                _executable = str(path)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                break"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    else:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        _executable = \"git\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+    if _executable is None:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        raise RuntimeError(\"Unable to find a valid git executable\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    return _executable"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+def _reset_executable():"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+    global _executable"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+    _executable = None"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " class GitConfig:"
            },
            "53": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "     def __init__(self, requires_git_presence: bool = False) -> None:"
            },
            "54": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         self._config = {}"
            },
            "55": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         try:"
            },
            "57": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             config_list = subprocess.check_output("
            },
            "58": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                [executable(), \"config\", \"-l\"], stderr=subprocess.STDOUT"
            },
            "60": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "             ).decode()"
            },
            "61": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "             m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)"
            },
            "63": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "             ) + args"
            },
            "64": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 388,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         return ("
            },
            "66": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+            subprocess.check_output("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+                [executable()] + list(args), stderr=subprocess.STDOUT"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+            )"
            },
            "70": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "             .decode()"
            },
            "71": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "             .strip()"
            },
            "72": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from pathlib import Path",
            "from typing import Any",
            "from typing import Optional",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+?\",",
            "    \"subdir\": r\"[\\w\\-/\\\\]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=.+?\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir}))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class GitError(RuntimeError):",
            "",
            "    pass",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol: Optional[str],",
            "        resource: Optional[str],",
            "        pathname: Optional[str],",
            "        user: Optional[str],",
            "        port: Optional[str],",
            "        name: Optional[str],",
            "        rev: Optional[str],",
            "        subdirectory: Optional[str] = None,",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "        self.subdirectory = subdirectory",
            "",
            "    @classmethod",
            "    def parse(cls, url: str) -> \"ParsedUrl\":",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                    groups.get(\"rev_subdirectory\") or groups.get(\"subdirectory\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self) -> str:",
            "        return self.url",
            "",
            "    def __str__(self) -> str:",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\", \"subdirectory\"])",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence: bool = False) -> None:",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = subprocess.check_output(",
            "                [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "            ).decode()",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key: Any, default: Optional[Any] = None) -> Any:",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item: Any) -> Any:",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir: Optional[Path] = None) -> None:",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url: str) -> GitUrl:",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        if parsed.subdirectory:",
            "            formatted = re.sub(",
            "                r\"[#&]subdirectory={}$\".format(parsed.subdirectory), \"\", formatted",
            "            )",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(",
            "            re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev, parsed.subdirectory",
            "        )",
            "",
            "    @property",
            "    def config(self) -> GitConfig:",
            "        return self._config",
            "",
            "    def clone(self, repository: str, dest: Path) -> str:",
            "        self._check_parameter(repository)",
            "",
            "        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))",
            "",
            "    def checkout(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        self._check_parameter(rev)",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args, folder=folder)",
            "",
            "    def get_current_branch(self, folder: Optional[Path] = None) -> str:",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        output = self.run(\"symbolic-ref\", \"--short\", \"HEAD\", folder=folder)",
            "",
            "        return output.strip()",
            "",
            "    def get_ignored_files(self, folder: Optional[Path] = None) -> list:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder: Optional[Path] = None) -> dict:",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder: Optional[Path] = None) -> str:",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args: Any, **kwargs: Any) -> str:",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return (",
            "            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)",
            "            .decode()",
            "            .strip()",
            "        )",
            "",
            "    def _check_parameter(self, parameter: str) -> str:",
            "        \"\"\"",
            "        Checks a git parameter to avoid unwanted code execution.",
            "        \"\"\"",
            "        if parameter.strip().startswith(\"-\"):",
            "            raise GitError(f\"Invalid Git parameter: {parameter}\")"
        ],
        "afterPatchFile": [
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from pathlib import Path",
            "from typing import Any",
            "from typing import Optional",
            "",
            "from poetry.core.utils._compat import WINDOWS",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+?\",",
            "    \"subdir\": r\"[\\w\\-/\\\\]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=.+?\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir}))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"(?:\"",
            "        r\"#egg=?.+\"",
            "        r\"|\"",
            "        r\"#(?:egg=.+?&subdirectory=|subdirectory=)(?P<subdirectory>{subdir})\"",
            "        r\"|\"",
            "        r\"[@#](?P<rev>{rev})(?:[&#](?:egg=.+?|(?:egg=.+?&subdirectory=|subdirectory=)(?P<rev_subdirectory>{subdir})))?\"",
            "        r\")?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "            subdir=pattern_formats[\"subdir\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class GitError(RuntimeError):",
            "",
            "    pass",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol: Optional[str],",
            "        resource: Optional[str],",
            "        pathname: Optional[str],",
            "        user: Optional[str],",
            "        port: Optional[str],",
            "        name: Optional[str],",
            "        rev: Optional[str],",
            "        subdirectory: Optional[str] = None,",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "        self.subdirectory = subdirectory",
            "",
            "    @classmethod",
            "    def parse(cls, url: str) -> \"ParsedUrl\":",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                    groups.get(\"rev_subdirectory\") or groups.get(\"subdirectory\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self) -> str:",
            "        return self.url",
            "",
            "    def __str__(self) -> str:",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\", \"subdirectory\"])",
            "",
            "",
            "_executable: Optional[str] = None",
            "",
            "",
            "def executable():",
            "    global _executable",
            "",
            "    if _executable is not None:",
            "        return _executable",
            "",
            "    if WINDOWS:",
            "        # Finding git via where.exe",
            "        where = \"%WINDIR%\\\\System32\\\\where.exe\"",
            "        paths = subprocess.check_output(",
            "            [where, \"git\"], shell=True, encoding=\"oem\"",
            "        ).split(\"\\n\")",
            "        for path in paths:",
            "            if not path:",
            "                continue",
            "",
            "            path = Path(path.strip())",
            "            try:",
            "                path.relative_to(Path.cwd())",
            "            except ValueError:",
            "                _executable = str(path)",
            "",
            "                break",
            "    else:",
            "        _executable = \"git\"",
            "",
            "    if _executable is None:",
            "        raise RuntimeError(\"Unable to find a valid git executable\")",
            "",
            "    return _executable",
            "",
            "",
            "def _reset_executable():",
            "    global _executable",
            "",
            "    _executable = None",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence: bool = False) -> None:",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = subprocess.check_output(",
            "                [executable(), \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "            ).decode()",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key: Any, default: Optional[Any] = None) -> Any:",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item: Any) -> Any:",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir: Optional[Path] = None) -> None:",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url: str) -> GitUrl:",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        if parsed.subdirectory:",
            "            formatted = re.sub(",
            "                r\"[#&]subdirectory={}$\".format(parsed.subdirectory), \"\", formatted",
            "            )",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(",
            "            re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev, parsed.subdirectory",
            "        )",
            "",
            "    @property",
            "    def config(self) -> GitConfig:",
            "        return self._config",
            "",
            "    def clone(self, repository: str, dest: Path) -> str:",
            "        self._check_parameter(repository)",
            "",
            "        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))",
            "",
            "    def checkout(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev: str, folder: Optional[Path] = None) -> str:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        self._check_parameter(rev)",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args, folder=folder)",
            "",
            "    def get_current_branch(self, folder: Optional[Path] = None) -> str:",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        output = self.run(\"symbolic-ref\", \"--short\", \"HEAD\", folder=folder)",
            "",
            "        return output.strip()",
            "",
            "    def get_ignored_files(self, folder: Optional[Path] = None) -> list:",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder: Optional[Path] = None) -> dict:",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder: Optional[Path] = None) -> str:",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args: Any, **kwargs: Any) -> str:",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return (",
            "            subprocess.check_output(",
            "                [executable()] + list(args), stderr=subprocess.STDOUT",
            "            )",
            "            .decode()",
            "            .strip()",
            "        )",
            "",
            "    def _check_parameter(self, parameter: str) -> str:",
            "        \"\"\"",
            "        Checks a git parameter to avoid unwanted code execution.",
            "        \"\"\"",
            "        if parameter.strip().startswith(\"-\"):",
            "            raise GitError(f\"Invalid Git parameter: {parameter}\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "192": [
                "GitConfig",
                "__init__"
            ],
            "347": [
                "Git",
                "run"
            ]
        },
        "addLocation": [
            "poetry.core.vcs.git.Git.run",
            "poetry.core.vcs.git.GitConfig.__init__",
            "knowledge_repo.app.routes.comment"
        ]
    }
}