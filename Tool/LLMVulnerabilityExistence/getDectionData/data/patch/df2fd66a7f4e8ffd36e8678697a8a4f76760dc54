{
    "solara/server/cdn_helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import os"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import pathlib"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import shutil"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import requests"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from solara.server.utils import path_is_child_of"
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import solara.settings"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " def put_in_cache(base_cache_dir: pathlib.Path, path, data: bytes):"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     cache_path = base_cache_dir / path"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    if not path_is_child_of(cache_path, base_cache_dir):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+        raise PermissionError(\"Trying to write outside of cache directory\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     pathlib.Path(cache_path.parent).mkdir(parents=True, exist_ok=True)"
            },
            "17": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     try:"
            },
            "18": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "         logger.info(\"Writing cache file: %s\", cache_path)"
            },
            "19": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     # Make sure cache_path is a subdirectory of base_cache_dir"
            },
            "20": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     # so we don't accidentally read files from the parent directory"
            },
            "21": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     # which is a security risk."
            },
            "22": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # We use os.path.normpath() because we do not want to follow symlinks"
            },
            "23": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # in editable installs, since some packages are symlinked"
            },
            "24": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not os.path.normpath(cache_path).startswith(os.path.normpath(base_cache_dir)):"
            },
            "25": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        logger.warning("
            },
            "26": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"Trying to read from outside of cache directory: %s is not a subdir of %s (%s - %s)\","
            },
            "27": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cache_path,"
            },
            "28": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            base_cache_dir,"
            },
            "29": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            os.path.normpath(cache_path),"
            },
            "30": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            os.path.normpath(base_cache_dir),"
            },
            "31": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    if not path_is_child_of(cache_path, base_cache_dir):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        logger.warning(\"Trying to read from outside of cache directory: %s is not a subdir of %s\", cache_path, base_cache_dir)"
            },
            "34": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         raise PermissionError(\"Trying to read from outside of cache directory\")"
            },
            "35": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     try:"
            },
            "37": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     store_path = path if len(parts) != 1 else pathlib.Path(path) / \"__main.js\""
            },
            "38": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     cache_path = base_cache_dir / store_path"
            },
            "39": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    if not path_is_child_of(cache_path, base_cache_dir):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        raise PermissionError(\"Trying to read from outside of cache directory\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     if cache_path.exists():"
            },
            "44": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         # before d7eba856f100d5c3c64f4eec22c62390f084cb40 on windows, we could"
            },
            "45": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         # accidentally write to the cache directory, so we need to check if we still"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import os",
            "import pathlib",
            "import shutil",
            "",
            "import requests",
            "",
            "import solara.settings",
            "",
            "logger = logging.getLogger(\"Solara.cdn\")",
            "",
            "cdn_url_path = \"_solara/cdn\"",
            "",
            "",
            "def put_in_cache(base_cache_dir: pathlib.Path, path, data: bytes):",
            "    cache_path = base_cache_dir / path",
            "    pathlib.Path(cache_path.parent).mkdir(parents=True, exist_ok=True)",
            "    try:",
            "        logger.info(\"Writing cache file: %s\", cache_path)",
            "        cache_path.write_bytes(data)",
            "    except FileNotFoundError:",
            "        logger.info(\"Failed writing cache file: %s\", cache_path)",
            "",
            "",
            "def get_from_cache(base_cache_dir: pathlib.Path, path):",
            "    cache_path = pathlib.Path(base_cache_dir / path)",
            "    # Make sure cache_path is a subdirectory of base_cache_dir",
            "    # so we don't accidentally read files from the parent directory",
            "    # which is a security risk.",
            "    # We use os.path.normpath() because we do not want to follow symlinks",
            "    # in editable installs, since some packages are symlinked",
            "    if not os.path.normpath(cache_path).startswith(os.path.normpath(base_cache_dir)):",
            "        logger.warning(",
            "            \"Trying to read from outside of cache directory: %s is not a subdir of %s (%s - %s)\",",
            "            cache_path,",
            "            base_cache_dir,",
            "            os.path.normpath(cache_path),",
            "            os.path.normpath(base_cache_dir),",
            "        )",
            "        raise PermissionError(\"Trying to read from outside of cache directory\")",
            "",
            "    try:",
            "        logger.info(\"Opening cache file: %s\", cache_path)",
            "        return cache_path.read_bytes()",
            "    except FileNotFoundError:",
            "        pass",
            "",
            "",
            "def get_cdn_url(path):",
            "    path = str(path)  # on windows, the path can contain a \\",
            "    return str(solara.settings.assets.cdn) + str(path).replace(\"\\\\\", \"/\")",
            "",
            "",
            "def get_data(base_cache_dir: pathlib.Path, path):",
            "    parts = path.replace(\"\\\\\", \"/\").split(\"/\")",
            "    store_path = path if len(parts) != 1 else pathlib.Path(path) / \"__main.js\"",
            "",
            "    content = get_from_cache(base_cache_dir, store_path)",
            "    if content:",
            "        return content",
            "",
            "    url = get_cdn_url(path)",
            "    response = requests.get(url)",
            "    if response.ok:",
            "        put_in_cache(base_cache_dir, store_path, response.content)",
            "        return response.content",
            "    else:",
            "        logger.warning(\"Could not load URL: %r\", url)",
            "        raise Exception(f\"Could not load URL: {url}\")",
            "",
            "",
            "def get_path(base_cache_dir: pathlib.Path, path) -> pathlib.Path:",
            "    parts = path.replace(\"\\\\\", \"/\").split(\"/\")",
            "    store_path = path if len(parts) != 1 else pathlib.Path(path) / \"__main.js\"",
            "    cache_path = base_cache_dir / store_path",
            "",
            "    if cache_path.exists():",
            "        # before d7eba856f100d5c3c64f4eec22c62390f084cb40 on windows, we could",
            "        # accidentally write to the cache directory, so we need to check if we still",
            "        # have an old directory layout, and remove that first.",
            "        if cache_path.is_dir():",
            "            shutil.rmtree(cache_path)",
            "        else:",
            "            return cache_path",
            "    url = get_cdn_url(path)",
            "    response = requests.get(url)",
            "    if response.ok:",
            "        put_in_cache(base_cache_dir, store_path, response.content)",
            "        assert cache_path.exists(), f\"Could not write to {cache_path}\"",
            "        return cache_path",
            "    else:",
            "        logger.warning(\"Could not load URL: %r\", url)",
            "        raise Exception(f\"Could not load URL: {url}\")"
        ],
        "afterPatchFile": [
            "import logging",
            "import pathlib",
            "import shutil",
            "",
            "import requests",
            "from solara.server.utils import path_is_child_of",
            "",
            "import solara.settings",
            "",
            "logger = logging.getLogger(\"Solara.cdn\")",
            "",
            "cdn_url_path = \"_solara/cdn\"",
            "",
            "",
            "def put_in_cache(base_cache_dir: pathlib.Path, path, data: bytes):",
            "    cache_path = base_cache_dir / path",
            "    if not path_is_child_of(cache_path, base_cache_dir):",
            "        raise PermissionError(\"Trying to write outside of cache directory\")",
            "",
            "    pathlib.Path(cache_path.parent).mkdir(parents=True, exist_ok=True)",
            "    try:",
            "        logger.info(\"Writing cache file: %s\", cache_path)",
            "        cache_path.write_bytes(data)",
            "    except FileNotFoundError:",
            "        logger.info(\"Failed writing cache file: %s\", cache_path)",
            "",
            "",
            "def get_from_cache(base_cache_dir: pathlib.Path, path):",
            "    cache_path = pathlib.Path(base_cache_dir / path)",
            "    # Make sure cache_path is a subdirectory of base_cache_dir",
            "    # so we don't accidentally read files from the parent directory",
            "    # which is a security risk.",
            "    if not path_is_child_of(cache_path, base_cache_dir):",
            "        logger.warning(\"Trying to read from outside of cache directory: %s is not a subdir of %s\", cache_path, base_cache_dir)",
            "        raise PermissionError(\"Trying to read from outside of cache directory\")",
            "",
            "    try:",
            "        logger.info(\"Opening cache file: %s\", cache_path)",
            "        return cache_path.read_bytes()",
            "    except FileNotFoundError:",
            "        pass",
            "",
            "",
            "def get_cdn_url(path):",
            "    path = str(path)  # on windows, the path can contain a \\",
            "    return str(solara.settings.assets.cdn) + str(path).replace(\"\\\\\", \"/\")",
            "",
            "",
            "def get_data(base_cache_dir: pathlib.Path, path):",
            "    parts = path.replace(\"\\\\\", \"/\").split(\"/\")",
            "    store_path = path if len(parts) != 1 else pathlib.Path(path) / \"__main.js\"",
            "",
            "    content = get_from_cache(base_cache_dir, store_path)",
            "    if content:",
            "        return content",
            "",
            "    url = get_cdn_url(path)",
            "    response = requests.get(url)",
            "    if response.ok:",
            "        put_in_cache(base_cache_dir, store_path, response.content)",
            "        return response.content",
            "    else:",
            "        logger.warning(\"Could not load URL: %r\", url)",
            "        raise Exception(f\"Could not load URL: {url}\")",
            "",
            "",
            "def get_path(base_cache_dir: pathlib.Path, path) -> pathlib.Path:",
            "    parts = path.replace(\"\\\\\", \"/\").split(\"/\")",
            "    store_path = path if len(parts) != 1 else pathlib.Path(path) / \"__main.js\"",
            "    cache_path = base_cache_dir / store_path",
            "",
            "    if not path_is_child_of(cache_path, base_cache_dir):",
            "        raise PermissionError(\"Trying to read from outside of cache directory\")",
            "",
            "    if cache_path.exists():",
            "        # before d7eba856f100d5c3c64f4eec22c62390f084cb40 on windows, we could",
            "        # accidentally write to the cache directory, so we need to check if we still",
            "        # have an old directory layout, and remove that first.",
            "        if cache_path.is_dir():",
            "            shutil.rmtree(cache_path)",
            "        else:",
            "            return cache_path",
            "    url = get_cdn_url(path)",
            "    response = requests.get(url)",
            "    if response.ok:",
            "        put_in_cache(base_cache_dir, store_path, response.content)",
            "        assert cache_path.exists(), f\"Could not write to {cache_path}\"",
            "        return cache_path",
            "    else:",
            "        logger.warning(\"Could not load URL: %r\", url)",
            "        raise Exception(f\"Could not load URL: {url}\")"
        ],
        "action": [
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": [],
            "30": [
                "get_from_cache"
            ],
            "31": [
                "get_from_cache"
            ],
            "32": [
                "get_from_cache"
            ],
            "33": [
                "get_from_cache"
            ],
            "34": [
                "get_from_cache"
            ],
            "35": [
                "get_from_cache"
            ],
            "36": [
                "get_from_cache"
            ],
            "37": [
                "get_from_cache"
            ],
            "38": [
                "get_from_cache"
            ],
            "39": [
                "get_from_cache"
            ]
        },
        "addLocation": []
    },
    "solara/server/flask.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     for directory in server.nbextensions_directories:"
            },
            "1": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         file = directory / dir / filename"
            },
            "2": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         if file.exists():"
            },
            "3": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return send_from_directory(directory / dir, filename)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            return send_from_directory(directory, dir + os.path.sep + filename)"
            },
            "5": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "     return flask.Response(\"not found\", status=404)"
            },
            "6": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 205,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         if not allowed():"
            },
            "9": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             abort(401)"
            },
            "10": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         cache_directory = settings.assets.proxy_cache_dir"
            },
            "11": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        content = cdn_helper.get_data(Path(cache_directory), path)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        try:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            content = cdn_helper.get_data(Path(cache_directory), path)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        except PermissionError:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            return flask.Response(\"not found\", status=404)"
            },
            "16": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         mime = mimetypes.guess_type(path)"
            },
            "17": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         return flask.Response(content, mimetype=mime[0])"
            },
            "18": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import logging",
            "import mimetypes",
            "import os",
            "import threading",
            "from http.server import HTTPServer",
            "from pathlib import Path",
            "from typing import Any, Dict, List",
            "from urllib.parse import urlparse",
            "from uuid import uuid4",
            "",
            "import flask",
            "import simple_websocket",
            "from flask import Blueprint, Flask, abort, request, send_from_directory, url_for",
            "from flask_sock import Sock",
            "",
            "try:",
            "    import solara_enterprise  # type: ignore",
            "",
            "    del solara_enterprise",
            "",
            "    has_solara_enterprise = True",
            "except ImportError:",
            "    has_solara_enterprise = False",
            "",
            "if has_solara_enterprise:",
            "    from solara_enterprise.auth.flask import allowed  # type: ignore",
            "    from solara_enterprise.auth.flask import (",
            "        authorize,",
            "        get_user,",
            "        init_flask,",
            "        login,",
            "        logout,",
            "    )",
            "else:",
            "",
            "    def allowed():",
            "        return True",
            "",
            "",
            "import solara",
            "import solara.settings",
            "from solara.server.threaded import ServerBase",
            "",
            "from . import app as appmod",
            "from . import cdn_helper, kernel_context, server, settings, websocket",
            "",
            "os.environ[\"SERVER_SOFTWARE\"] = \"solara/\" + str(solara.__version__)",
            "",
            "logger = logging.getLogger(\"solara.server.flask\")",
            "blueprint = Blueprint(\"blueprint-solara\", __name__)",
            "websocket_extension = Sock()",
            "",
            "",
            "class WebsocketWrapper(websocket.WebsocketWrapper):",
            "    ws: simple_websocket.Server",
            "",
            "    def __init__(self, ws: simple_websocket.Server) -> None:",
            "        self.ws = ws",
            "        self.lock = threading.Lock()",
            "",
            "    def close(self):",
            "        with self.lock:",
            "            self.ws.close()",
            "",
            "    def send_text(self, data: str) -> None:",
            "        with self.lock:",
            "            self.ws.send(data)",
            "",
            "    def send_bytes(self, data: bytes) -> None:",
            "        with self.lock:",
            "            self.ws.send(data)",
            "",
            "    async def receive(self):",
            "        from anyio import to_thread",
            "",
            "        try:",
            "            return await to_thread.run_sync(lambda: self.ws.receive())  # type: ignore",
            "        except simple_websocket.ws.ConnectionClosed:",
            "            raise websocket.WebSocketDisconnect()",
            "",
            "",
            "class ServerFlask(ServerBase):",
            "    server: Any",
            "    name = \"flask\"",
            "",
            "    def __init__(self, port: int, host: str = \"localhost\", flask_app=None, url_prefix=\"\", **kwargs):",
            "        super().__init__(port, host, **kwargs)",
            "        self.app = flask_app or app",
            "        self.url_prefix = url_prefix",
            "        self.server = None",
            "",
            "    def has_started(self):",
            "        return server.is_ready(f\"http://{self.host}:{self.port}{self.url_prefix}\")",
            "",
            "    def signal_stop(self):",
            "        if self.server:",
            "            assert isinstance(self.server, HTTPServer)",
            "            self.server.shutdown()  # type: ignore",
            "",
            "    def serve(self):",
            "        from werkzeug.serving import make_server",
            "",
            "        self.server = make_server(self.host, self.port, self.app, threaded=True)  # type: ignore",
            "        assert isinstance(self.server, HTTPServer)",
            "        self.started.set()",
            "        self.server.serve_forever(poll_interval=0.05)  # type: ignore",
            "",
            "",
            "@blueprint.route(\"/jupyter/api/kernels/<id>\")",
            "def kernels(id):",
            "    if not allowed():",
            "        abort(401)",
            "    return {\"name\": \"lala\", \"id\": \"dsa\"}",
            "",
            "",
            "@websocket_extension.route(\"/jupyter/api/kernels/<kernel_id>/<name>\")",
            "def kernels_connection(ws: simple_websocket.Server, kernel_id: str, name: str):",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = url_for(\"blueprint-solara.read_root\", _external=True)",
            "    if settings.oauth.private and not has_solara_enterprise:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    if has_solara_enterprise:",
            "        user = get_user()",
            "        if user is None and settings.oauth.private:",
            "            logger.error(\"app is private, requires login\")",
            "            ws.close(1008, \"app is private, requires login\")  # policy violation",
            "            return",
            "    else:",
            "        user = None",
            "",
            "    try:",
            "        page_id = request.args[\"session_id\"]",
            "        session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID)",
            "        logger.info(\"Solara kernel requested for session_id=%s kernel_id=%s\", session_id, kernel_id)",
            "        if session_id is None:",
            "            logger.warning(\"no session cookie\")",
            "            session_id = \"session-id-cookie-unavailable:\" + str(uuid4())",
            "        ws_wrapper = WebsocketWrapper(ws)",
            "        headers_dict: Dict[str, List[str]] = {}",
            "        for k, v in request.headers.__iter__():",
            "            if k not in headers_dict.keys():",
            "                headers_dict[k] = [v]",
            "            else:",
            "                headers_dict[k].append(v)",
            "        asyncio.run(",
            "            server.app_loop(",
            "                ws_wrapper,",
            "                cookies=request.cookies.to_dict(),",
            "                headers=headers_dict,",
            "                session_id=session_id,",
            "                kernel_id=kernel_id,",
            "                page_id=page_id,",
            "                user=user,",
            "            )",
            "        )",
            "    except:  # noqa",
            "        logger.exception(\"Error in kernel handler\")",
            "        raise",
            "",
            "",
            "@blueprint.route(\"/_solara/api/close/<kernel_id>\", methods=[\"GET\", \"POST\"])",
            "def close(kernel_id: str):",
            "    page_id = request.args[\"session_id\"]",
            "    context = kernel_context.contexts.get(kernel_id, None)",
            "    if context is not None:",
            "        context.page_close(page_id)",
            "    return \"\"",
            "",
            "",
            "@blueprint.route(\"/static/public/<path:path>\")",
            "def public(path):",
            "    if not allowed():",
            "        abort(401)",
            "    directories = [app.directory.parent / \"public\" for app in appmod.apps.values()]",
            "    for directory in directories:",
            "        file = directory / path",
            "        if file.exists():",
            "            return send_from_directory(directory, path)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/assets/<path:path>\")",
            "def assets(path):",
            "    if not allowed():",
            "        abort(401)",
            "    directories = server.asset_directories()",
            "    for directory in directories:",
            "        file = directory / path",
            "        if file.exists():",
            "            return send_from_directory(directory, path)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/nbextensions/<dir>/<filename>\")",
            "def nbext(dir, filename):",
            "    if not allowed():",
            "        abort(401)",
            "    for directory in server.nbextensions_directories:",
            "        file = directory / dir / filename",
            "        if file.exists():",
            "            return send_from_directory(directory / dir, filename)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/<path:path>\")",
            "def serve_static(path):",
            "    if not allowed():",
            "        abort(401)",
            "    return send_from_directory(server.solara_static, path)",
            "",
            "",
            "if solara.settings.assets.proxy:",
            "",
            "    @blueprint.route(f\"/{cdn_helper.cdn_url_path}/<path:path>\")",
            "    def cdn(path):",
            "        if not allowed():",
            "            abort(401)",
            "        cache_directory = settings.assets.proxy_cache_dir",
            "        content = cdn_helper.get_data(Path(cache_directory), path)",
            "        mime = mimetypes.guess_type(path)",
            "        return flask.Response(content, mimetype=mime[0])",
            "",
            "",
            "@blueprint.route(\"/\", defaults={\"path\": \"\"})",
            "@blueprint.route(\"/<path:path>\")",
            "def read_root(path):",
            "    root_path = url_for(\".read_root\")",
            "    if root_path.endswith(\"/\"):",
            "        root_path = root_path[:-1]",
            "",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = url_for(\"blueprint-solara.read_root\", _external=True)",
            "",
            "    session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID) or str(uuid4())",
            "    if root_path:",
            "        path = flask.request.path[len(root_path) :]",
            "    content = server.read_root(path, root_path=root_path)",
            "    if content is None:",
            "        if not allowed():",
            "            abort(401)",
            "        return flask.Response(\"not found\", status=404)",
            "",
            "    if not allowed():",
            "        return login()",
            "",
            "    samesite = \"lax\"",
            "    secure = False",
            "    # we want samesite, so we can set a cookie when embedded in an iframe, such as on huggingface",
            "    # however, samesite=none requires Secure https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite",
            "    # when hosted on the localhost domain we can always set the Secure flag",
            "    # to allow samesite https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies",
            "    o = urlparse(request.base_url)",
            "    if request.headers.get(\"x-forwarded-proto\", \"http\") == \"https\" or o.hostname == \"localhost\":",
            "        samesite = \"none\"",
            "        secure = True",
            "",
            "    assert session_id is not None",
            "    response = flask.Response(content, mimetype=\"text/html\")",
            "    response.set_cookie(server.COOKIE_KEY_SESSION_ID, value=session_id, secure=secure, samesite=samesite)",
            "    return response",
            "",
            "",
            "if has_solara_enterprise:",
            "    blueprint.route(\"/_solara/auth/authorize\")(authorize)",
            "    blueprint.route(\"/_solara/auth/logout\")(logout)",
            "    blueprint.route(\"/_solara/auth/login\")(login)",
            "",
            "",
            "@blueprint.route(\"/readyz\")",
            "def readyz():",
            "    json, status = server.readyz()",
            "    return flask.Response(json, mimetype=\"application/json\", status=status)",
            "",
            "",
            "# using the blueprint and websocket blueprint makes it easier to integrate into other applications",
            "websocket_extension.init_app(blueprint)",
            "app = Flask(__name__, static_url_path=\"/_static\")  # do not intervere with out static files",
            "app.register_blueprint(blueprint)",
            "if has_solara_enterprise:",
            "    init_flask(app)",
            "",
            "if __name__ == \"__main__\":",
            "    app.run(debug=False, port=8765)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import logging",
            "import mimetypes",
            "import os",
            "import threading",
            "from http.server import HTTPServer",
            "from pathlib import Path",
            "from typing import Any, Dict, List",
            "from urllib.parse import urlparse",
            "from uuid import uuid4",
            "",
            "import flask",
            "import simple_websocket",
            "from flask import Blueprint, Flask, abort, request, send_from_directory, url_for",
            "from flask_sock import Sock",
            "",
            "try:",
            "    import solara_enterprise  # type: ignore",
            "",
            "    del solara_enterprise",
            "",
            "    has_solara_enterprise = True",
            "except ImportError:",
            "    has_solara_enterprise = False",
            "",
            "if has_solara_enterprise:",
            "    from solara_enterprise.auth.flask import allowed  # type: ignore",
            "    from solara_enterprise.auth.flask import (",
            "        authorize,",
            "        get_user,",
            "        init_flask,",
            "        login,",
            "        logout,",
            "    )",
            "else:",
            "",
            "    def allowed():",
            "        return True",
            "",
            "",
            "import solara",
            "import solara.settings",
            "from solara.server.threaded import ServerBase",
            "",
            "from . import app as appmod",
            "from . import cdn_helper, kernel_context, server, settings, websocket",
            "",
            "os.environ[\"SERVER_SOFTWARE\"] = \"solara/\" + str(solara.__version__)",
            "",
            "logger = logging.getLogger(\"solara.server.flask\")",
            "blueprint = Blueprint(\"blueprint-solara\", __name__)",
            "websocket_extension = Sock()",
            "",
            "",
            "class WebsocketWrapper(websocket.WebsocketWrapper):",
            "    ws: simple_websocket.Server",
            "",
            "    def __init__(self, ws: simple_websocket.Server) -> None:",
            "        self.ws = ws",
            "        self.lock = threading.Lock()",
            "",
            "    def close(self):",
            "        with self.lock:",
            "            self.ws.close()",
            "",
            "    def send_text(self, data: str) -> None:",
            "        with self.lock:",
            "            self.ws.send(data)",
            "",
            "    def send_bytes(self, data: bytes) -> None:",
            "        with self.lock:",
            "            self.ws.send(data)",
            "",
            "    async def receive(self):",
            "        from anyio import to_thread",
            "",
            "        try:",
            "            return await to_thread.run_sync(lambda: self.ws.receive())  # type: ignore",
            "        except simple_websocket.ws.ConnectionClosed:",
            "            raise websocket.WebSocketDisconnect()",
            "",
            "",
            "class ServerFlask(ServerBase):",
            "    server: Any",
            "    name = \"flask\"",
            "",
            "    def __init__(self, port: int, host: str = \"localhost\", flask_app=None, url_prefix=\"\", **kwargs):",
            "        super().__init__(port, host, **kwargs)",
            "        self.app = flask_app or app",
            "        self.url_prefix = url_prefix",
            "        self.server = None",
            "",
            "    def has_started(self):",
            "        return server.is_ready(f\"http://{self.host}:{self.port}{self.url_prefix}\")",
            "",
            "    def signal_stop(self):",
            "        if self.server:",
            "            assert isinstance(self.server, HTTPServer)",
            "            self.server.shutdown()  # type: ignore",
            "",
            "    def serve(self):",
            "        from werkzeug.serving import make_server",
            "",
            "        self.server = make_server(self.host, self.port, self.app, threaded=True)  # type: ignore",
            "        assert isinstance(self.server, HTTPServer)",
            "        self.started.set()",
            "        self.server.serve_forever(poll_interval=0.05)  # type: ignore",
            "",
            "",
            "@blueprint.route(\"/jupyter/api/kernels/<id>\")",
            "def kernels(id):",
            "    if not allowed():",
            "        abort(401)",
            "    return {\"name\": \"lala\", \"id\": \"dsa\"}",
            "",
            "",
            "@websocket_extension.route(\"/jupyter/api/kernels/<kernel_id>/<name>\")",
            "def kernels_connection(ws: simple_websocket.Server, kernel_id: str, name: str):",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = url_for(\"blueprint-solara.read_root\", _external=True)",
            "    if settings.oauth.private and not has_solara_enterprise:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    if has_solara_enterprise:",
            "        user = get_user()",
            "        if user is None and settings.oauth.private:",
            "            logger.error(\"app is private, requires login\")",
            "            ws.close(1008, \"app is private, requires login\")  # policy violation",
            "            return",
            "    else:",
            "        user = None",
            "",
            "    try:",
            "        page_id = request.args[\"session_id\"]",
            "        session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID)",
            "        logger.info(\"Solara kernel requested for session_id=%s kernel_id=%s\", session_id, kernel_id)",
            "        if session_id is None:",
            "            logger.warning(\"no session cookie\")",
            "            session_id = \"session-id-cookie-unavailable:\" + str(uuid4())",
            "        ws_wrapper = WebsocketWrapper(ws)",
            "        headers_dict: Dict[str, List[str]] = {}",
            "        for k, v in request.headers.__iter__():",
            "            if k not in headers_dict.keys():",
            "                headers_dict[k] = [v]",
            "            else:",
            "                headers_dict[k].append(v)",
            "        asyncio.run(",
            "            server.app_loop(",
            "                ws_wrapper,",
            "                cookies=request.cookies.to_dict(),",
            "                headers=headers_dict,",
            "                session_id=session_id,",
            "                kernel_id=kernel_id,",
            "                page_id=page_id,",
            "                user=user,",
            "            )",
            "        )",
            "    except:  # noqa",
            "        logger.exception(\"Error in kernel handler\")",
            "        raise",
            "",
            "",
            "@blueprint.route(\"/_solara/api/close/<kernel_id>\", methods=[\"GET\", \"POST\"])",
            "def close(kernel_id: str):",
            "    page_id = request.args[\"session_id\"]",
            "    context = kernel_context.contexts.get(kernel_id, None)",
            "    if context is not None:",
            "        context.page_close(page_id)",
            "    return \"\"",
            "",
            "",
            "@blueprint.route(\"/static/public/<path:path>\")",
            "def public(path):",
            "    if not allowed():",
            "        abort(401)",
            "    directories = [app.directory.parent / \"public\" for app in appmod.apps.values()]",
            "    for directory in directories:",
            "        file = directory / path",
            "        if file.exists():",
            "            return send_from_directory(directory, path)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/assets/<path:path>\")",
            "def assets(path):",
            "    if not allowed():",
            "        abort(401)",
            "    directories = server.asset_directories()",
            "    for directory in directories:",
            "        file = directory / path",
            "        if file.exists():",
            "            return send_from_directory(directory, path)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/nbextensions/<dir>/<filename>\")",
            "def nbext(dir, filename):",
            "    if not allowed():",
            "        abort(401)",
            "    for directory in server.nbextensions_directories:",
            "        file = directory / dir / filename",
            "        if file.exists():",
            "            return send_from_directory(directory, dir + os.path.sep + filename)",
            "    return flask.Response(\"not found\", status=404)",
            "",
            "",
            "@blueprint.route(\"/static/<path:path>\")",
            "def serve_static(path):",
            "    if not allowed():",
            "        abort(401)",
            "    return send_from_directory(server.solara_static, path)",
            "",
            "",
            "if solara.settings.assets.proxy:",
            "",
            "    @blueprint.route(f\"/{cdn_helper.cdn_url_path}/<path:path>\")",
            "    def cdn(path):",
            "        if not allowed():",
            "            abort(401)",
            "        cache_directory = settings.assets.proxy_cache_dir",
            "        try:",
            "            content = cdn_helper.get_data(Path(cache_directory), path)",
            "        except PermissionError:",
            "            return flask.Response(\"not found\", status=404)",
            "        mime = mimetypes.guess_type(path)",
            "        return flask.Response(content, mimetype=mime[0])",
            "",
            "",
            "@blueprint.route(\"/\", defaults={\"path\": \"\"})",
            "@blueprint.route(\"/<path:path>\")",
            "def read_root(path):",
            "    root_path = url_for(\".read_root\")",
            "    if root_path.endswith(\"/\"):",
            "        root_path = root_path[:-1]",
            "",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = url_for(\"blueprint-solara.read_root\", _external=True)",
            "",
            "    session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID) or str(uuid4())",
            "    if root_path:",
            "        path = flask.request.path[len(root_path) :]",
            "    content = server.read_root(path, root_path=root_path)",
            "    if content is None:",
            "        if not allowed():",
            "            abort(401)",
            "        return flask.Response(\"not found\", status=404)",
            "",
            "    if not allowed():",
            "        return login()",
            "",
            "    samesite = \"lax\"",
            "    secure = False",
            "    # we want samesite, so we can set a cookie when embedded in an iframe, such as on huggingface",
            "    # however, samesite=none requires Secure https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite",
            "    # when hosted on the localhost domain we can always set the Secure flag",
            "    # to allow samesite https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies",
            "    o = urlparse(request.base_url)",
            "    if request.headers.get(\"x-forwarded-proto\", \"http\") == \"https\" or o.hostname == \"localhost\":",
            "        samesite = \"none\"",
            "        secure = True",
            "",
            "    assert session_id is not None",
            "    response = flask.Response(content, mimetype=\"text/html\")",
            "    response.set_cookie(server.COOKIE_KEY_SESSION_ID, value=session_id, secure=secure, samesite=samesite)",
            "    return response",
            "",
            "",
            "if has_solara_enterprise:",
            "    blueprint.route(\"/_solara/auth/authorize\")(authorize)",
            "    blueprint.route(\"/_solara/auth/logout\")(logout)",
            "    blueprint.route(\"/_solara/auth/login\")(login)",
            "",
            "",
            "@blueprint.route(\"/readyz\")",
            "def readyz():",
            "    json, status = server.readyz()",
            "    return flask.Response(json, mimetype=\"application/json\", status=status)",
            "",
            "",
            "# using the blueprint and websocket blueprint makes it easier to integrate into other applications",
            "websocket_extension.init_app(blueprint)",
            "app = Flask(__name__, static_url_path=\"/_static\")  # do not intervere with out static files",
            "app.register_blueprint(blueprint)",
            "if has_solara_enterprise:",
            "    init_flask(app)",
            "",
            "if __name__ == \"__main__\":",
            "    app.run(debug=False, port=8765)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "202": [
                "nbext"
            ],
            "220": [
                "cdn"
            ]
        },
        "addLocation": []
    },
    "solara/server/starlette.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import math"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import sys"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import threading"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import typing"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import uvicorn.server"
            },
            "8": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import websockets.legacy.http"
            },
            "9": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from solara.server.utils import path_is_child_of"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " try:"
            },
            "13": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     import solara_enterprise"
            },
            "14": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "             original_path = os.path.join(directory, path)"
            },
            "16": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             full_path = os.path.realpath(original_path)"
            },
            "17": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "             directory = os.path.realpath(directory)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            # return early if someone tries to access a file outside of the directory"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+            if not path_is_child_of(Path(original_path), Path(directory)):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+                return \"\", None"
            },
            "21": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "             try:"
            },
            "22": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "                 return full_path, os.stat(full_path)"
            },
            "23": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "             except (FileNotFoundError, NotADirectoryError):"
            },
            "24": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "             full_path = str(get_path(settings.assets.proxy_cache_dir, path))"
            },
            "25": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "         except Exception:"
            },
            "26": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "             return \"\", None"
            },
            "27": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "28": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "         return full_path, os.stat(full_path)"
            },
            "29": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 459,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 460,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import math",
            "import os",
            "import sys",
            "import threading",
            "import typing",
            "from typing import Any, Dict, List, Optional, Set, Union, cast",
            "from uuid import uuid4",
            "",
            "import anyio",
            "import starlette.websockets",
            "import uvicorn.server",
            "import websockets.legacy.http",
            "",
            "try:",
            "    import solara_enterprise",
            "",
            "    del solara_enterprise",
            "    has_solara_enterprise = True",
            "except ImportError:",
            "    has_solara_enterprise = False",
            "if has_solara_enterprise and sys.version_info[:2] > (3, 6):",
            "    has_auth_support = True",
            "    from solara_enterprise.auth.middleware import MutateDetectSessionMiddleware",
            "    from solara_enterprise.auth.starlette import (",
            "        AuthBackend,",
            "        authorize,",
            "        get_user,",
            "        login,",
            "        logout,",
            "    )",
            "else:",
            "    has_auth_support = False",
            "",
            "from starlette.applications import Starlette",
            "from starlette.exceptions import HTTPException",
            "from starlette.middleware import Middleware",
            "from starlette.middleware.authentication import AuthenticationMiddleware",
            "from starlette.middleware.gzip import GZipMiddleware",
            "from starlette.requests import HTTPConnection, Request",
            "from starlette.responses import HTMLResponse, JSONResponse, RedirectResponse, Response",
            "from starlette.routing import Mount, Route, WebSocketRoute",
            "from starlette.staticfiles import StaticFiles",
            "from starlette.types import Receive, Scope, Send",
            "",
            "import solara",
            "import solara.settings",
            "from solara.server.threaded import ServerBase",
            "",
            "from . import app as appmod",
            "from . import kernel_context, server, settings, telemetry, websocket",
            "from .cdn_helper import cdn_url_path, get_path",
            "",
            "os.environ[\"SERVER_SOFTWARE\"] = \"solara/\" + str(solara.__version__)",
            "limiter: Optional[anyio.CapacityLimiter] = None",
            "lock = threading.Lock()",
            "",
            "",
            "def _ensure_limiter():",
            "    # in older anyios (<4) the limiter can only be created in an async context",
            "    # so we call this in a starlette handler",
            "    global limiter",
            "    if limiter is None:",
            "        with lock:",
            "            if limiter is None:",
            "                limiter = anyio.CapacityLimiter(settings.kernel.max_count if settings.kernel.max_count is not None else math.inf)",
            "",
            "",
            "logger = logging.getLogger(\"solara.server.fastapi\")",
            "# if we add these to the router, the server_test does not run (404's)",
            "prefix = \"\"",
            "",
            "# The limit for starlette's http traffic should come from h11's DEFAULT_MAX_INCOMPLETE_EVENT_SIZE=16kb",
            "# In practice, testing with 132kb cookies (server_test.py:test_large_cookie) seems to work fine.",
            "# For the websocket, the limit is set to 4kb till 10.4, see",
            "#  * https://github.com/aaugustin/websockets/blob/10.4/src/websockets/legacy/http.py#L14",
            "# Later releases should set this to 8kb. See",
            "#  * https://github.com/aaugustin/websockets/commit/8ce4739b7efed3ac78b287da7fb5e537f78e72aa",
            "#  * https://github.com/aaugustin/websockets/issues/743",
            "# Since starlette seems to accept really large values for http, lets do the same for websockets",
            "# An arbitrarily large value we settled on for now is 32kb",
            "# If we don't do this, users with many cookies will fail to get a websocket connection.",
            "websockets.legacy.http.MAX_LINE = 1024 * 32",
            "",
            "",
            "class WebsocketDebugInfo:",
            "    lock = threading.Lock()",
            "    attempts = 0",
            "    connecting = 0",
            "    open = 0",
            "    closed = 0",
            "",
            "",
            "class WebsocketWrapper(websocket.WebsocketWrapper):",
            "    ws: starlette.websockets.WebSocket",
            "",
            "    def __init__(self, ws: starlette.websockets.WebSocket, portal: Optional[anyio.from_thread.BlockingPortal]) -> None:",
            "        self.ws = ws",
            "        self.portal = portal",
            "        self.to_send: List[Union[str, bytes]] = []",
            "        # following https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task",
            "        # we store a strong reference",
            "        self.tasks: Set[asyncio.Task] = set()",
            "        self.event_loop = asyncio.get_event_loop()",
            "        if settings.main.experimental_performance:",
            "            self.task = asyncio.ensure_future(self.process_messages_task())",
            "",
            "    async def process_messages_task(self):",
            "        while True:",
            "            await asyncio.sleep(0.05)",
            "            while len(self.to_send) > 0:",
            "                first = self.to_send.pop(0)",
            "                if isinstance(first, bytes):",
            "                    await self.ws.send_bytes(first)",
            "                else:",
            "                    await self.ws.send_text(first)",
            "",
            "    def close(self):",
            "        if self.portal is None:",
            "            asyncio.ensure_future(self.ws.close())",
            "        else:",
            "            self.portal.call(self.ws.close)  # type: ignore",
            "",
            "    def send_text(self, data: str) -> None:",
            "        if self.portal is None:",
            "            task = self.event_loop.create_task(self.ws.send_text(data))",
            "            self.tasks.add(task)",
            "            task.add_done_callback(self.tasks.discard)",
            "        else:",
            "            if settings.main.experimental_performance:",
            "                self.to_send.append(data)",
            "            else:",
            "                self.portal.call(self.ws.send_bytes, data)  # type: ignore",
            "",
            "    def send_bytes(self, data: bytes) -> None:",
            "        if self.portal is None:",
            "            task = self.event_loop.create_task(self.ws.send_bytes(data))",
            "            self.tasks.add(task)",
            "            task.add_done_callback(self.tasks.discard)",
            "        else:",
            "            if settings.main.experimental_performance:",
            "                self.to_send.append(data)",
            "            else:",
            "                self.portal.call(self.ws.send_bytes, data)  # type: ignore",
            "",
            "    async def receive(self):",
            "        if self.portal is None:",
            "            message = await asyncio.ensure_future(self.ws.receive())",
            "        else:",
            "            if hasattr(self.portal, \"start_task_soon\"):",
            "                # version 3+",
            "                fut = self.portal.start_task_soon(self.ws.receive)  # type: ignore",
            "            else:",
            "                fut = self.portal.spawn_task(self.ws.receive)  # type: ignore",
            "",
            "            message = await asyncio.wrap_future(fut)",
            "        if \"text\" in message:",
            "            return message[\"text\"]",
            "        elif \"bytes\" in message:",
            "            return message[\"bytes\"]",
            "        elif message.get(\"type\") == \"websocket.disconnect\":",
            "            raise websocket.WebSocketDisconnect()",
            "        else:",
            "            raise RuntimeError(f\"Unknown message type {message}\")",
            "",
            "",
            "class ServerStarlette(ServerBase):",
            "    server: uvicorn.server.Server",
            "    name = \"starlette\"",
            "",
            "    def __init__(self, port: int, host: str = \"localhost\", starlette_app=None, **kwargs):",
            "        super().__init__(port, host, **kwargs)",
            "        self.app = starlette_app or app",
            "",
            "    def has_started(self):",
            "        return self.server.started",
            "",
            "    def signal_stop(self):",
            "        self.server.should_exit = True",
            "        # this cause uvicorn to not wait for background tasks, e.g.:",
            "        # <Task pending name='Task-55'",
            "        #  coro=<WebSocketProtocol.run_asgi() running at",
            "        #  /.../uvicorn/protocols/websockets/websockets_impl.py:184>",
            "        # wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x16896aa00>()]>",
            "        # cb=[WebSocketProtocol.on_task_complete()]>",
            "        self.server.force_exit = True",
            "        self.server.lifespan.should_exit = True",
            "",
            "    def serve(self):",
            "        from uvicorn.config import Config",
            "        from uvicorn.server import Server",
            "",
            "        if sys.version_info[:2] < (3, 7):",
            "            # make python 3.6 work",
            "            import asyncio",
            "",
            "            loop = asyncio.new_event_loop()",
            "            asyncio.set_event_loop(loop)",
            "",
            "        # uvloop will trigger a: RuntimeError: There is no current event loop in thread 'fastapi-thread'",
            "        config = Config(self.app, host=self.host, port=self.port, **self.kwargs, access_log=False, loop=\"asyncio\")",
            "        self.server = Server(config=config)",
            "        self.started.set()",
            "        self.server.run()",
            "",
            "",
            "async def kernels(id):",
            "    return JSONResponse({\"name\": \"lala\", \"id\": \"dsa\"})",
            "",
            "",
            "async def kernel_connection(ws: starlette.websockets.WebSocket):",
            "    _ensure_limiter()",
            "    try:",
            "        with WebsocketDebugInfo.lock:",
            "            WebsocketDebugInfo.attempts += 1",
            "            WebsocketDebugInfo.connecting += 1",
            "        await _kernel_connection(ws)",
            "    finally:",
            "        with WebsocketDebugInfo.lock:",
            "            WebsocketDebugInfo.closed += 1",
            "            WebsocketDebugInfo.open -= 1",
            "",
            "",
            "async def _kernel_connection(ws: starlette.websockets.WebSocket):",
            "    session_id = ws.cookies.get(server.COOKIE_KEY_SESSION_ID)",
            "",
            "    if settings.oauth.private and not has_auth_support:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    if has_auth_support and \"session\" in ws.scope:",
            "        user = get_user(ws)",
            "        if user is None and settings.oauth.private:",
            "            await ws.accept()",
            "            logger.error(\"app is private, requires login\")",
            "            await ws.close(code=1008, reason=\"app is private, requires login\")",
            "            return",
            "    else:",
            "        user = None",
            "",
            "    if not session_id:",
            "        logger.warning(\"no session cookie\")",
            "        session_id = \"session-id-cookie-unavailable:\" + str(uuid4())",
            "    # we use the jupyter session_id query parameter as the key/id",
            "    # for a page scope.",
            "    page_id = ws.query_params[\"session_id\"]",
            "    if not page_id:",
            "        logger.error(\"no page_id\")",
            "    kernel_id = ws.path_params[\"kernel_id\"]",
            "    if not kernel_id:",
            "        logger.error(\"no kernel_id\")",
            "        await ws.close()",
            "        return",
            "    logger.info(\"Solara kernel requested for session_id=%s kernel_id=%s\", session_id, kernel_id)",
            "    await ws.accept()",
            "    with WebsocketDebugInfo.lock:",
            "        WebsocketDebugInfo.connecting -= 1",
            "        WebsocketDebugInfo.open += 1",
            "",
            "    async def run(ws_wrapper: WebsocketWrapper):",
            "        if kernel_context.async_context_id is not None:",
            "            kernel_context.async_context_id.set(uuid4().hex)",
            "        assert session_id is not None",
            "        assert kernel_id is not None",
            "        telemetry.connection_open(session_id)",
            "        headers_dict: Dict[str, List[str]] = {}",
            "        for k, v in ws.headers.items():",
            "            if k not in headers_dict.keys():",
            "                headers_dict[k] = [v]",
            "            else:",
            "                headers_dict[k].append(v)",
            "        await server.app_loop(ws_wrapper, ws.cookies, headers_dict, session_id, kernel_id, page_id, user)",
            "",
            "    def websocket_thread_runner(ws_wrapper: WebsocketWrapper, portal: anyio.from_thread.BlockingPortal):",
            "        async def run_wrapper():",
            "            try:",
            "                await run(ws_wrapper)",
            "            except:  # noqa",
            "                if portal is not None:",
            "                    await portal.stop(cancel_remaining=True)",
            "                raise",
            "            finally:",
            "                telemetry.connection_close(session_id)",
            "",
            "        # sometimes throws: RuntimeError: Already running asyncio in this thread",
            "        anyio.run(run_wrapper)  # type: ignore",
            "",
            "    # this portal allows us to sync call the websocket calls from this current event loop we are in",
            "    # each websocket however, is handled from a separate thread",
            "    try:",
            "        if settings.kernel.threaded:",
            "            async with anyio.from_thread.BlockingPortal() as portal:",
            "                ws_wrapper = WebsocketWrapper(ws, portal)",
            "                thread_return = anyio.to_thread.run_sync(websocket_thread_runner, ws_wrapper, portal, limiter=limiter)  # type: ignore",
            "                await thread_return",
            "        else:",
            "            ws_wrapper = WebsocketWrapper(ws, None)",
            "            await run(ws_wrapper)",
            "    finally:",
            "        if settings.main.experimental_performance:",
            "            try:",
            "                ws_wrapper.task.cancel()",
            "            except:  # noqa",
            "                logger.exception(\"error cancelling websocket task\")",
            "        try:",
            "            await ws.close()",
            "        except:  # noqa",
            "            pass",
            "",
            "",
            "def close(request: Request):",
            "    kernel_id = request.path_params[\"kernel_id\"]",
            "    page_id = request.query_params[\"session_id\"]",
            "    context = kernel_context.contexts.get(kernel_id, None)",
            "    if context is not None:",
            "        context.page_close(page_id)",
            "    response = HTMLResponse(content=\"\", status_code=200)",
            "    return response",
            "",
            "",
            "async def root(request: Request, fullpath: str = \"\"):",
            "    if settings.oauth.private and not has_auth_support:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    root_path = settings.main.root_path or \"\"",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = str(request.base_url)",
            "    # if not explicltly set,",
            "    if settings.main.root_path is None:",
            "        # use the default root path from the app, which seems to also include the path",
            "        # if we are mounted under a path",
            "        scope = request.scope",
            "        root_path = scope.get(\"route_root_path\", scope.get(\"root_path\", \"\"))",
            "        logger.debug(\"root_path: %s\", root_path)",
            "        # or use the script-name header, for instance when running under a reverse proxy",
            "        script_name = request.headers.get(\"script-name\")",
            "        if script_name:",
            "            logger.debug(\"override root_path using script-name header from %s to %s\", root_path, script_name)",
            "            root_path = script_name",
            "        script_name = request.headers.get(\"x-script-name\")",
            "        if script_name:",
            "            logger.debug(\"override root_path using x-script-name header from %s to %s\", root_path, script_name)",
            "            root_path = script_name",
            "        settings.main.root_path = root_path",
            "",
            "    request_path = request.url.path",
            "    if request_path.startswith(root_path):",
            "        request_path = request_path[len(root_path) :]",
            "    if request_path in server._redirects.keys():",
            "        return RedirectResponse(server._redirects[request_path])",
            "",
            "    content = server.read_root(request_path, root_path)",
            "    if content is None:",
            "        if settings.oauth.private and not request.user.is_authenticated:",
            "            raise HTTPException(status_code=401, detail=\"Unauthorized\")",
            "        raise HTTPException(status_code=404, detail=\"Page not found by Solara router\")",
            "",
            "    if settings.oauth.private and not request.user.is_authenticated:",
            "        from solara_enterprise.auth.starlette import login",
            "",
            "        return await login(request)",
            "",
            "    response = HTMLResponse(content=content)",
            "    session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID) or str(uuid4())",
            "    samesite = \"lax\"",
            "    secure = False",
            "    # we want samesite, so we can set a cookie when embedded in an iframe, such as on huggingface",
            "    # however, samesite=none requires Secure https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite",
            "    # when hosted on the localhost domain we can always set the Secure flag",
            "    # to allow samesite https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies",
            "    if request.headers.get(\"x-forwarded-proto\", \"http\") == \"https\" or request.base_url.hostname == \"localhost\":",
            "        samesite = \"none\"",
            "        secure = True",
            "    response.set_cookie(",
            "        server.COOKIE_KEY_SESSION_ID,",
            "        value=session_id,",
            "        expires=\"Fri, 01 Jan 2038 00:00:00 GMT\",",
            "        samesite=samesite,  # type: ignore",
            "        secure=secure,  # type: ignore",
            "    )  # type: ignore",
            "    return response",
            "",
            "",
            "class StaticFilesOptionalAuth(StaticFiles):",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        conn = HTTPConnection(scope)",
            "        if settings.oauth.private and not has_auth_support:",
            "            raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "        if has_auth_support and settings.oauth.private and not conn.user.is_authenticated:",
            "            raise HTTPException(status_code=401, detail=\"Unauthorized\")",
            "        await super().__call__(scope, receive, send)",
            "",
            "",
            "class StaticNbFiles(StaticFilesOptionalAuth):",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], server.nbextensions_directories)",
            "",
            "    # follow symlinks",
            "    # from https://github.com/encode/starlette/pull/1377/files",
            "    def lookup_path(self, path: str) -> typing.Tuple[str, typing.Optional[os.stat_result]]:",
            "        for directory in self.all_directories:",
            "            original_path = os.path.join(directory, path)",
            "            full_path = os.path.realpath(original_path)",
            "            directory = os.path.realpath(directory)",
            "            try:",
            "                return full_path, os.stat(full_path)",
            "            except (FileNotFoundError, NotADirectoryError):",
            "                continue",
            "        return \"\", None",
            "",
            "",
            "class StaticPublic(StaticFilesOptionalAuth):",
            "    def lookup_path(self, *args, **kwargs):",
            "        self.all_directories = self.get_directories(None, None)",
            "        return super().lookup_path(*args, **kwargs)",
            "",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        # we only know the .directory at runtime (after startup)",
            "        # which means we cannot pass the directory to the StaticFiles constructor",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], [app.directory.parent / \"public\" for app in appmod.apps.values()])",
            "",
            "",
            "class StaticAssets(StaticFilesOptionalAuth):",
            "    def lookup_path(self, *args, **kwargs):",
            "        self.all_directories = self.get_directories(None, None)",
            "        return super().lookup_path(*args, **kwargs)",
            "",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        # we only know the .directory at runtime (after startup)",
            "        # which means we cannot pass the directory to the StaticFiles constructor",
            "        directories = server.asset_directories()",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], directories)",
            "",
            "",
            "class StaticCdn(StaticFilesOptionalAuth):",
            "    def lookup_path(self, path: str) -> typing.Tuple[str, typing.Optional[os.stat_result]]:",
            "        try:",
            "            full_path = str(get_path(settings.assets.proxy_cache_dir, path))",
            "        except Exception:",
            "            return \"\", None",
            "",
            "        return full_path, os.stat(full_path)",
            "",
            "",
            "def on_startup():",
            "    # TODO: configure and set max number of threads",
            "    # see https://github.com/encode/starlette/issues/1724",
            "    telemetry.server_start()",
            "",
            "",
            "def on_shutdown():",
            "    telemetry.server_stop()",
            "",
            "",
            "def readyz(request: Request):",
            "    json, status = server.readyz()",
            "    return JSONResponse(json, status_code=status)",
            "",
            "",
            "async def resourcez(request: Request):",
            "    _ensure_limiter()",
            "    assert limiter is not None",
            "    data: Dict[str, Any] = {}",
            "    verbose = request.query_params.get(\"verbose\", None) is not None",
            "    data[\"websockets\"] = {",
            "        \"attempts\": WebsocketDebugInfo.attempts,",
            "        \"connecting\": WebsocketDebugInfo.connecting,",
            "        \"open\": WebsocketDebugInfo.open,",
            "        \"closed\": WebsocketDebugInfo.closed,",
            "    }",
            "    from . import patch",
            "",
            "    data[\"threads\"] = {",
            "        \"created\": patch.ThreadDebugInfo.created,",
            "        \"running\": patch.ThreadDebugInfo.running,",
            "        \"stopped\": patch.ThreadDebugInfo.stopped,",
            "        \"active\": threading.active_count(),",
            "    }",
            "    contexts = list(kernel_context.contexts.values())",
            "    data[\"kernels\"] = {",
            "        \"total\": len(contexts),",
            "        \"has_connected\": len([k for k in contexts if kernel_context.PageStatus.CONNECTED in k.page_status.values()]),",
            "        \"has_disconnected\": len([k for k in contexts if kernel_context.PageStatus.DISCONNECTED in k.page_status.values()]),",
            "        \"has_closed\": len([k for k in contexts if kernel_context.PageStatus.CLOSED in k.page_status.values()]),",
            "        \"limiter\": {",
            "            \"total_tokens\": limiter.total_tokens,",
            "            \"borrowed_tokens\": limiter.borrowed_tokens,",
            "            \"available_tokens\": limiter.available_tokens,",
            "        },",
            "    }",
            "    default_limiter = anyio.to_thread.current_default_thread_limiter()",
            "    data[\"anyio.to_thread.limiter\"] = {",
            "        \"total_tokens\": default_limiter.total_tokens,",
            "        \"borrowed_tokens\": default_limiter.borrowed_tokens,",
            "        \"available_tokens\": default_limiter.available_tokens,",
            "    }",
            "    if verbose:",
            "        try:",
            "            import psutil",
            "",
            "            def expand(named_tuple):",
            "                return {key: getattr(named_tuple, key) for key in named_tuple._fields}",
            "",
            "            data[\"cpu\"] = {}",
            "            try:",
            "                data[\"cpu\"][\"percent\"] = psutil.cpu_percent()",
            "            except Exception as e:",
            "                data[\"cpu\"][\"percent\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"count\"] = psutil.cpu_count()",
            "            except Exception as e:",
            "                data[\"cpu\"][\"count\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"times\"] = expand(psutil.cpu_times())",
            "                data[\"cpu\"][\"times\"][\"per_cpu\"] = [expand(x) for x in psutil.cpu_times(percpu=True)]",
            "            except Exception as e:",
            "                data[\"cpu\"][\"times\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"times_percent\"] = expand(psutil.cpu_times_percent())",
            "                data[\"cpu\"][\"times_percent\"][\"per_cpu\"] = [expand(x) for x in psutil.cpu_times_percent(percpu=True)]",
            "            except Exception as e:",
            "                data[\"cpu\"][\"times_percent\"] = str(e)",
            "            try:",
            "                memory = psutil.virtual_memory()",
            "            except Exception as e:",
            "                data[\"memory\"] = str(e)",
            "            else:",
            "                data[\"memory\"] = {",
            "                    \"bytes\": expand(memory),",
            "                    \"GB\": {key: getattr(memory, key) / 1024**3 for key in memory._fields},",
            "                }",
            "",
            "        except ModuleNotFoundError:",
            "            pass",
            "",
            "    json_string = json.dumps(data, indent=2)",
            "    return Response(content=json_string, media_type=\"application/json\")",
            "",
            "",
            "middleware = [",
            "    Middleware(GZipMiddleware, minimum_size=1000),",
            "]",
            "",
            "if has_auth_support:",
            "    middleware = [",
            "        *middleware,",
            "        Middleware(",
            "            MutateDetectSessionMiddleware,",
            "            secret_key=settings.session.secret_key,  # type: ignore",
            "            session_cookie=\"solara-session\",  # type: ignore",
            "            https_only=settings.session.https_only,  # type: ignore",
            "            same_site=settings.session.same_site,  # type: ignore",
            "        ),",
            "        Middleware(AuthenticationMiddleware, backend=AuthBackend()),",
            "    ]",
            "",
            "routes_auth = []",
            "if has_auth_support:",
            "    routes_auth = [",
            "        Route(\"/_solara/auth/authorize\", endpoint=authorize),  #",
            "        Route(\"/_solara/auth/logout\", endpoint=logout),",
            "        Route(\"/_solara/auth/login\", endpoint=login),",
            "    ]",
            "routes = [",
            "    Route(\"/readyz\", endpoint=readyz),",
            "    Route(\"/resourcez\", endpoint=resourcez),",
            "    *routes_auth,",
            "    Route(\"/jupyter/api/kernels/{id}\", endpoint=kernels),",
            "    WebSocketRoute(\"/jupyter/api/kernels/{kernel_id}/{name}\", endpoint=kernel_connection),",
            "    Route(\"/\", endpoint=root),",
            "    Route(\"/{fullpath}\", endpoint=root),",
            "    Route(\"/_solara/api/close/{kernel_id}\", endpoint=close, methods=[\"POST\"]),",
            "    # only enable when the proxy is turned on, otherwise if the directory does not exists we will get an exception",
            "    *([Mount(f\"/{cdn_url_path}\", app=StaticCdn(directory=settings.assets.proxy_cache_dir))] if solara.settings.assets.proxy else []),",
            "    Mount(f\"{prefix}/static/public\", app=StaticPublic()),",
            "    Mount(f\"{prefix}/static/assets\", app=StaticAssets()),",
            "    Mount(f\"{prefix}/static/nbextensions\", app=StaticNbFiles()),",
            "    Mount(f\"{prefix}/static\", app=StaticFilesOptionalAuth(directory=server.solara_static)),",
            "    Route(\"/{fullpath:path}\", endpoint=root),",
            "]",
            "",
            "app = Starlette(routes=routes, on_startup=[on_startup], on_shutdown=[on_shutdown], middleware=middleware)",
            "",
            "# Uncomment the lines below to test solara mouted under a subpath",
            "# def myroot(request: Request):",
            "#     return JSONResponse({\"framework\": \"solara\"})",
            "",
            "# routes_test_sub = [Route(\"/\", endpoint=myroot), Mount(\"/foo/\", routes=routes)]",
            "# app = Starlette(routes=routes_test_sub, on_startup=[on_startup], on_shutdown=[on_shutdown], middleware=middleware)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import math",
            "import os",
            "from pathlib import Path",
            "import sys",
            "import threading",
            "import typing",
            "from typing import Any, Dict, List, Optional, Set, Union, cast",
            "from uuid import uuid4",
            "",
            "import anyio",
            "import starlette.websockets",
            "import uvicorn.server",
            "import websockets.legacy.http",
            "",
            "from solara.server.utils import path_is_child_of",
            "",
            "try:",
            "    import solara_enterprise",
            "",
            "    del solara_enterprise",
            "    has_solara_enterprise = True",
            "except ImportError:",
            "    has_solara_enterprise = False",
            "if has_solara_enterprise and sys.version_info[:2] > (3, 6):",
            "    has_auth_support = True",
            "    from solara_enterprise.auth.middleware import MutateDetectSessionMiddleware",
            "    from solara_enterprise.auth.starlette import (",
            "        AuthBackend,",
            "        authorize,",
            "        get_user,",
            "        login,",
            "        logout,",
            "    )",
            "else:",
            "    has_auth_support = False",
            "",
            "from starlette.applications import Starlette",
            "from starlette.exceptions import HTTPException",
            "from starlette.middleware import Middleware",
            "from starlette.middleware.authentication import AuthenticationMiddleware",
            "from starlette.middleware.gzip import GZipMiddleware",
            "from starlette.requests import HTTPConnection, Request",
            "from starlette.responses import HTMLResponse, JSONResponse, RedirectResponse, Response",
            "from starlette.routing import Mount, Route, WebSocketRoute",
            "from starlette.staticfiles import StaticFiles",
            "from starlette.types import Receive, Scope, Send",
            "",
            "import solara",
            "import solara.settings",
            "from solara.server.threaded import ServerBase",
            "",
            "from . import app as appmod",
            "from . import kernel_context, server, settings, telemetry, websocket",
            "from .cdn_helper import cdn_url_path, get_path",
            "",
            "os.environ[\"SERVER_SOFTWARE\"] = \"solara/\" + str(solara.__version__)",
            "limiter: Optional[anyio.CapacityLimiter] = None",
            "lock = threading.Lock()",
            "",
            "",
            "def _ensure_limiter():",
            "    # in older anyios (<4) the limiter can only be created in an async context",
            "    # so we call this in a starlette handler",
            "    global limiter",
            "    if limiter is None:",
            "        with lock:",
            "            if limiter is None:",
            "                limiter = anyio.CapacityLimiter(settings.kernel.max_count if settings.kernel.max_count is not None else math.inf)",
            "",
            "",
            "logger = logging.getLogger(\"solara.server.fastapi\")",
            "# if we add these to the router, the server_test does not run (404's)",
            "prefix = \"\"",
            "",
            "# The limit for starlette's http traffic should come from h11's DEFAULT_MAX_INCOMPLETE_EVENT_SIZE=16kb",
            "# In practice, testing with 132kb cookies (server_test.py:test_large_cookie) seems to work fine.",
            "# For the websocket, the limit is set to 4kb till 10.4, see",
            "#  * https://github.com/aaugustin/websockets/blob/10.4/src/websockets/legacy/http.py#L14",
            "# Later releases should set this to 8kb. See",
            "#  * https://github.com/aaugustin/websockets/commit/8ce4739b7efed3ac78b287da7fb5e537f78e72aa",
            "#  * https://github.com/aaugustin/websockets/issues/743",
            "# Since starlette seems to accept really large values for http, lets do the same for websockets",
            "# An arbitrarily large value we settled on for now is 32kb",
            "# If we don't do this, users with many cookies will fail to get a websocket connection.",
            "websockets.legacy.http.MAX_LINE = 1024 * 32",
            "",
            "",
            "class WebsocketDebugInfo:",
            "    lock = threading.Lock()",
            "    attempts = 0",
            "    connecting = 0",
            "    open = 0",
            "    closed = 0",
            "",
            "",
            "class WebsocketWrapper(websocket.WebsocketWrapper):",
            "    ws: starlette.websockets.WebSocket",
            "",
            "    def __init__(self, ws: starlette.websockets.WebSocket, portal: Optional[anyio.from_thread.BlockingPortal]) -> None:",
            "        self.ws = ws",
            "        self.portal = portal",
            "        self.to_send: List[Union[str, bytes]] = []",
            "        # following https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task",
            "        # we store a strong reference",
            "        self.tasks: Set[asyncio.Task] = set()",
            "        self.event_loop = asyncio.get_event_loop()",
            "        if settings.main.experimental_performance:",
            "            self.task = asyncio.ensure_future(self.process_messages_task())",
            "",
            "    async def process_messages_task(self):",
            "        while True:",
            "            await asyncio.sleep(0.05)",
            "            while len(self.to_send) > 0:",
            "                first = self.to_send.pop(0)",
            "                if isinstance(first, bytes):",
            "                    await self.ws.send_bytes(first)",
            "                else:",
            "                    await self.ws.send_text(first)",
            "",
            "    def close(self):",
            "        if self.portal is None:",
            "            asyncio.ensure_future(self.ws.close())",
            "        else:",
            "            self.portal.call(self.ws.close)  # type: ignore",
            "",
            "    def send_text(self, data: str) -> None:",
            "        if self.portal is None:",
            "            task = self.event_loop.create_task(self.ws.send_text(data))",
            "            self.tasks.add(task)",
            "            task.add_done_callback(self.tasks.discard)",
            "        else:",
            "            if settings.main.experimental_performance:",
            "                self.to_send.append(data)",
            "            else:",
            "                self.portal.call(self.ws.send_bytes, data)  # type: ignore",
            "",
            "    def send_bytes(self, data: bytes) -> None:",
            "        if self.portal is None:",
            "            task = self.event_loop.create_task(self.ws.send_bytes(data))",
            "            self.tasks.add(task)",
            "            task.add_done_callback(self.tasks.discard)",
            "        else:",
            "            if settings.main.experimental_performance:",
            "                self.to_send.append(data)",
            "            else:",
            "                self.portal.call(self.ws.send_bytes, data)  # type: ignore",
            "",
            "    async def receive(self):",
            "        if self.portal is None:",
            "            message = await asyncio.ensure_future(self.ws.receive())",
            "        else:",
            "            if hasattr(self.portal, \"start_task_soon\"):",
            "                # version 3+",
            "                fut = self.portal.start_task_soon(self.ws.receive)  # type: ignore",
            "            else:",
            "                fut = self.portal.spawn_task(self.ws.receive)  # type: ignore",
            "",
            "            message = await asyncio.wrap_future(fut)",
            "        if \"text\" in message:",
            "            return message[\"text\"]",
            "        elif \"bytes\" in message:",
            "            return message[\"bytes\"]",
            "        elif message.get(\"type\") == \"websocket.disconnect\":",
            "            raise websocket.WebSocketDisconnect()",
            "        else:",
            "            raise RuntimeError(f\"Unknown message type {message}\")",
            "",
            "",
            "class ServerStarlette(ServerBase):",
            "    server: uvicorn.server.Server",
            "    name = \"starlette\"",
            "",
            "    def __init__(self, port: int, host: str = \"localhost\", starlette_app=None, **kwargs):",
            "        super().__init__(port, host, **kwargs)",
            "        self.app = starlette_app or app",
            "",
            "    def has_started(self):",
            "        return self.server.started",
            "",
            "    def signal_stop(self):",
            "        self.server.should_exit = True",
            "        # this cause uvicorn to not wait for background tasks, e.g.:",
            "        # <Task pending name='Task-55'",
            "        #  coro=<WebSocketProtocol.run_asgi() running at",
            "        #  /.../uvicorn/protocols/websockets/websockets_impl.py:184>",
            "        # wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x16896aa00>()]>",
            "        # cb=[WebSocketProtocol.on_task_complete()]>",
            "        self.server.force_exit = True",
            "        self.server.lifespan.should_exit = True",
            "",
            "    def serve(self):",
            "        from uvicorn.config import Config",
            "        from uvicorn.server import Server",
            "",
            "        if sys.version_info[:2] < (3, 7):",
            "            # make python 3.6 work",
            "            import asyncio",
            "",
            "            loop = asyncio.new_event_loop()",
            "            asyncio.set_event_loop(loop)",
            "",
            "        # uvloop will trigger a: RuntimeError: There is no current event loop in thread 'fastapi-thread'",
            "        config = Config(self.app, host=self.host, port=self.port, **self.kwargs, access_log=False, loop=\"asyncio\")",
            "        self.server = Server(config=config)",
            "        self.started.set()",
            "        self.server.run()",
            "",
            "",
            "async def kernels(id):",
            "    return JSONResponse({\"name\": \"lala\", \"id\": \"dsa\"})",
            "",
            "",
            "async def kernel_connection(ws: starlette.websockets.WebSocket):",
            "    _ensure_limiter()",
            "    try:",
            "        with WebsocketDebugInfo.lock:",
            "            WebsocketDebugInfo.attempts += 1",
            "            WebsocketDebugInfo.connecting += 1",
            "        await _kernel_connection(ws)",
            "    finally:",
            "        with WebsocketDebugInfo.lock:",
            "            WebsocketDebugInfo.closed += 1",
            "            WebsocketDebugInfo.open -= 1",
            "",
            "",
            "async def _kernel_connection(ws: starlette.websockets.WebSocket):",
            "    session_id = ws.cookies.get(server.COOKIE_KEY_SESSION_ID)",
            "",
            "    if settings.oauth.private and not has_auth_support:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    if has_auth_support and \"session\" in ws.scope:",
            "        user = get_user(ws)",
            "        if user is None and settings.oauth.private:",
            "            await ws.accept()",
            "            logger.error(\"app is private, requires login\")",
            "            await ws.close(code=1008, reason=\"app is private, requires login\")",
            "            return",
            "    else:",
            "        user = None",
            "",
            "    if not session_id:",
            "        logger.warning(\"no session cookie\")",
            "        session_id = \"session-id-cookie-unavailable:\" + str(uuid4())",
            "    # we use the jupyter session_id query parameter as the key/id",
            "    # for a page scope.",
            "    page_id = ws.query_params[\"session_id\"]",
            "    if not page_id:",
            "        logger.error(\"no page_id\")",
            "    kernel_id = ws.path_params[\"kernel_id\"]",
            "    if not kernel_id:",
            "        logger.error(\"no kernel_id\")",
            "        await ws.close()",
            "        return",
            "    logger.info(\"Solara kernel requested for session_id=%s kernel_id=%s\", session_id, kernel_id)",
            "    await ws.accept()",
            "    with WebsocketDebugInfo.lock:",
            "        WebsocketDebugInfo.connecting -= 1",
            "        WebsocketDebugInfo.open += 1",
            "",
            "    async def run(ws_wrapper: WebsocketWrapper):",
            "        if kernel_context.async_context_id is not None:",
            "            kernel_context.async_context_id.set(uuid4().hex)",
            "        assert session_id is not None",
            "        assert kernel_id is not None",
            "        telemetry.connection_open(session_id)",
            "        headers_dict: Dict[str, List[str]] = {}",
            "        for k, v in ws.headers.items():",
            "            if k not in headers_dict.keys():",
            "                headers_dict[k] = [v]",
            "            else:",
            "                headers_dict[k].append(v)",
            "        await server.app_loop(ws_wrapper, ws.cookies, headers_dict, session_id, kernel_id, page_id, user)",
            "",
            "    def websocket_thread_runner(ws_wrapper: WebsocketWrapper, portal: anyio.from_thread.BlockingPortal):",
            "        async def run_wrapper():",
            "            try:",
            "                await run(ws_wrapper)",
            "            except:  # noqa",
            "                if portal is not None:",
            "                    await portal.stop(cancel_remaining=True)",
            "                raise",
            "            finally:",
            "                telemetry.connection_close(session_id)",
            "",
            "        # sometimes throws: RuntimeError: Already running asyncio in this thread",
            "        anyio.run(run_wrapper)  # type: ignore",
            "",
            "    # this portal allows us to sync call the websocket calls from this current event loop we are in",
            "    # each websocket however, is handled from a separate thread",
            "    try:",
            "        if settings.kernel.threaded:",
            "            async with anyio.from_thread.BlockingPortal() as portal:",
            "                ws_wrapper = WebsocketWrapper(ws, portal)",
            "                thread_return = anyio.to_thread.run_sync(websocket_thread_runner, ws_wrapper, portal, limiter=limiter)  # type: ignore",
            "                await thread_return",
            "        else:",
            "            ws_wrapper = WebsocketWrapper(ws, None)",
            "            await run(ws_wrapper)",
            "    finally:",
            "        if settings.main.experimental_performance:",
            "            try:",
            "                ws_wrapper.task.cancel()",
            "            except:  # noqa",
            "                logger.exception(\"error cancelling websocket task\")",
            "        try:",
            "            await ws.close()",
            "        except:  # noqa",
            "            pass",
            "",
            "",
            "def close(request: Request):",
            "    kernel_id = request.path_params[\"kernel_id\"]",
            "    page_id = request.query_params[\"session_id\"]",
            "    context = kernel_context.contexts.get(kernel_id, None)",
            "    if context is not None:",
            "        context.page_close(page_id)",
            "    response = HTMLResponse(content=\"\", status_code=200)",
            "    return response",
            "",
            "",
            "async def root(request: Request, fullpath: str = \"\"):",
            "    if settings.oauth.private and not has_auth_support:",
            "        raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "    root_path = settings.main.root_path or \"\"",
            "    if not settings.main.base_url:",
            "        settings.main.base_url = str(request.base_url)",
            "    # if not explicltly set,",
            "    if settings.main.root_path is None:",
            "        # use the default root path from the app, which seems to also include the path",
            "        # if we are mounted under a path",
            "        scope = request.scope",
            "        root_path = scope.get(\"route_root_path\", scope.get(\"root_path\", \"\"))",
            "        logger.debug(\"root_path: %s\", root_path)",
            "        # or use the script-name header, for instance when running under a reverse proxy",
            "        script_name = request.headers.get(\"script-name\")",
            "        if script_name:",
            "            logger.debug(\"override root_path using script-name header from %s to %s\", root_path, script_name)",
            "            root_path = script_name",
            "        script_name = request.headers.get(\"x-script-name\")",
            "        if script_name:",
            "            logger.debug(\"override root_path using x-script-name header from %s to %s\", root_path, script_name)",
            "            root_path = script_name",
            "        settings.main.root_path = root_path",
            "",
            "    request_path = request.url.path",
            "    if request_path.startswith(root_path):",
            "        request_path = request_path[len(root_path) :]",
            "    if request_path in server._redirects.keys():",
            "        return RedirectResponse(server._redirects[request_path])",
            "",
            "    content = server.read_root(request_path, root_path)",
            "    if content is None:",
            "        if settings.oauth.private and not request.user.is_authenticated:",
            "            raise HTTPException(status_code=401, detail=\"Unauthorized\")",
            "        raise HTTPException(status_code=404, detail=\"Page not found by Solara router\")",
            "",
            "    if settings.oauth.private and not request.user.is_authenticated:",
            "        from solara_enterprise.auth.starlette import login",
            "",
            "        return await login(request)",
            "",
            "    response = HTMLResponse(content=content)",
            "    session_id = request.cookies.get(server.COOKIE_KEY_SESSION_ID) or str(uuid4())",
            "    samesite = \"lax\"",
            "    secure = False",
            "    # we want samesite, so we can set a cookie when embedded in an iframe, such as on huggingface",
            "    # however, samesite=none requires Secure https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite",
            "    # when hosted on the localhost domain we can always set the Secure flag",
            "    # to allow samesite https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies",
            "    if request.headers.get(\"x-forwarded-proto\", \"http\") == \"https\" or request.base_url.hostname == \"localhost\":",
            "        samesite = \"none\"",
            "        secure = True",
            "    response.set_cookie(",
            "        server.COOKIE_KEY_SESSION_ID,",
            "        value=session_id,",
            "        expires=\"Fri, 01 Jan 2038 00:00:00 GMT\",",
            "        samesite=samesite,  # type: ignore",
            "        secure=secure,  # type: ignore",
            "    )  # type: ignore",
            "    return response",
            "",
            "",
            "class StaticFilesOptionalAuth(StaticFiles):",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        conn = HTTPConnection(scope)",
            "        if settings.oauth.private and not has_auth_support:",
            "            raise RuntimeError(\"SOLARA_OAUTH_PRIVATE requires solara-enterprise\")",
            "        if has_auth_support and settings.oauth.private and not conn.user.is_authenticated:",
            "            raise HTTPException(status_code=401, detail=\"Unauthorized\")",
            "        await super().__call__(scope, receive, send)",
            "",
            "",
            "class StaticNbFiles(StaticFilesOptionalAuth):",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], server.nbextensions_directories)",
            "",
            "    # follow symlinks",
            "    # from https://github.com/encode/starlette/pull/1377/files",
            "    def lookup_path(self, path: str) -> typing.Tuple[str, typing.Optional[os.stat_result]]:",
            "        for directory in self.all_directories:",
            "            original_path = os.path.join(directory, path)",
            "            full_path = os.path.realpath(original_path)",
            "            directory = os.path.realpath(directory)",
            "            # return early if someone tries to access a file outside of the directory",
            "            if not path_is_child_of(Path(original_path), Path(directory)):",
            "                return \"\", None",
            "            try:",
            "                return full_path, os.stat(full_path)",
            "            except (FileNotFoundError, NotADirectoryError):",
            "                continue",
            "        return \"\", None",
            "",
            "",
            "class StaticPublic(StaticFilesOptionalAuth):",
            "    def lookup_path(self, *args, **kwargs):",
            "        self.all_directories = self.get_directories(None, None)",
            "        return super().lookup_path(*args, **kwargs)",
            "",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        # we only know the .directory at runtime (after startup)",
            "        # which means we cannot pass the directory to the StaticFiles constructor",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], [app.directory.parent / \"public\" for app in appmod.apps.values()])",
            "",
            "",
            "class StaticAssets(StaticFilesOptionalAuth):",
            "    def lookup_path(self, *args, **kwargs):",
            "        self.all_directories = self.get_directories(None, None)",
            "        return super().lookup_path(*args, **kwargs)",
            "",
            "    def get_directories(",
            "        self,",
            "        directory: Union[str, \"os.PathLike[str]\", None] = None,",
            "        packages=None,  # type: ignore",
            "    ) -> List[Union[str, \"os.PathLike[str]\"]]:",
            "        # we only know the .directory at runtime (after startup)",
            "        # which means we cannot pass the directory to the StaticFiles constructor",
            "        directories = server.asset_directories()",
            "        return cast(List[Union[str, \"os.PathLike[str]\"]], directories)",
            "",
            "",
            "class StaticCdn(StaticFilesOptionalAuth):",
            "    def lookup_path(self, path: str) -> typing.Tuple[str, typing.Optional[os.stat_result]]:",
            "        try:",
            "            full_path = str(get_path(settings.assets.proxy_cache_dir, path))",
            "        except Exception:",
            "            return \"\", None",
            "        return full_path, os.stat(full_path)",
            "",
            "",
            "def on_startup():",
            "    # TODO: configure and set max number of threads",
            "    # see https://github.com/encode/starlette/issues/1724",
            "    telemetry.server_start()",
            "",
            "",
            "def on_shutdown():",
            "    telemetry.server_stop()",
            "",
            "",
            "def readyz(request: Request):",
            "    json, status = server.readyz()",
            "    return JSONResponse(json, status_code=status)",
            "",
            "",
            "async def resourcez(request: Request):",
            "    _ensure_limiter()",
            "    assert limiter is not None",
            "    data: Dict[str, Any] = {}",
            "    verbose = request.query_params.get(\"verbose\", None) is not None",
            "    data[\"websockets\"] = {",
            "        \"attempts\": WebsocketDebugInfo.attempts,",
            "        \"connecting\": WebsocketDebugInfo.connecting,",
            "        \"open\": WebsocketDebugInfo.open,",
            "        \"closed\": WebsocketDebugInfo.closed,",
            "    }",
            "    from . import patch",
            "",
            "    data[\"threads\"] = {",
            "        \"created\": patch.ThreadDebugInfo.created,",
            "        \"running\": patch.ThreadDebugInfo.running,",
            "        \"stopped\": patch.ThreadDebugInfo.stopped,",
            "        \"active\": threading.active_count(),",
            "    }",
            "    contexts = list(kernel_context.contexts.values())",
            "    data[\"kernels\"] = {",
            "        \"total\": len(contexts),",
            "        \"has_connected\": len([k for k in contexts if kernel_context.PageStatus.CONNECTED in k.page_status.values()]),",
            "        \"has_disconnected\": len([k for k in contexts if kernel_context.PageStatus.DISCONNECTED in k.page_status.values()]),",
            "        \"has_closed\": len([k for k in contexts if kernel_context.PageStatus.CLOSED in k.page_status.values()]),",
            "        \"limiter\": {",
            "            \"total_tokens\": limiter.total_tokens,",
            "            \"borrowed_tokens\": limiter.borrowed_tokens,",
            "            \"available_tokens\": limiter.available_tokens,",
            "        },",
            "    }",
            "    default_limiter = anyio.to_thread.current_default_thread_limiter()",
            "    data[\"anyio.to_thread.limiter\"] = {",
            "        \"total_tokens\": default_limiter.total_tokens,",
            "        \"borrowed_tokens\": default_limiter.borrowed_tokens,",
            "        \"available_tokens\": default_limiter.available_tokens,",
            "    }",
            "    if verbose:",
            "        try:",
            "            import psutil",
            "",
            "            def expand(named_tuple):",
            "                return {key: getattr(named_tuple, key) for key in named_tuple._fields}",
            "",
            "            data[\"cpu\"] = {}",
            "            try:",
            "                data[\"cpu\"][\"percent\"] = psutil.cpu_percent()",
            "            except Exception as e:",
            "                data[\"cpu\"][\"percent\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"count\"] = psutil.cpu_count()",
            "            except Exception as e:",
            "                data[\"cpu\"][\"count\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"times\"] = expand(psutil.cpu_times())",
            "                data[\"cpu\"][\"times\"][\"per_cpu\"] = [expand(x) for x in psutil.cpu_times(percpu=True)]",
            "            except Exception as e:",
            "                data[\"cpu\"][\"times\"] = str(e)",
            "            try:",
            "                data[\"cpu\"][\"times_percent\"] = expand(psutil.cpu_times_percent())",
            "                data[\"cpu\"][\"times_percent\"][\"per_cpu\"] = [expand(x) for x in psutil.cpu_times_percent(percpu=True)]",
            "            except Exception as e:",
            "                data[\"cpu\"][\"times_percent\"] = str(e)",
            "            try:",
            "                memory = psutil.virtual_memory()",
            "            except Exception as e:",
            "                data[\"memory\"] = str(e)",
            "            else:",
            "                data[\"memory\"] = {",
            "                    \"bytes\": expand(memory),",
            "                    \"GB\": {key: getattr(memory, key) / 1024**3 for key in memory._fields},",
            "                }",
            "",
            "        except ModuleNotFoundError:",
            "            pass",
            "",
            "    json_string = json.dumps(data, indent=2)",
            "    return Response(content=json_string, media_type=\"application/json\")",
            "",
            "",
            "middleware = [",
            "    Middleware(GZipMiddleware, minimum_size=1000),",
            "]",
            "",
            "if has_auth_support:",
            "    middleware = [",
            "        *middleware,",
            "        Middleware(",
            "            MutateDetectSessionMiddleware,",
            "            secret_key=settings.session.secret_key,  # type: ignore",
            "            session_cookie=\"solara-session\",  # type: ignore",
            "            https_only=settings.session.https_only,  # type: ignore",
            "            same_site=settings.session.same_site,  # type: ignore",
            "        ),",
            "        Middleware(AuthenticationMiddleware, backend=AuthBackend()),",
            "    ]",
            "",
            "routes_auth = []",
            "if has_auth_support:",
            "    routes_auth = [",
            "        Route(\"/_solara/auth/authorize\", endpoint=authorize),  #",
            "        Route(\"/_solara/auth/logout\", endpoint=logout),",
            "        Route(\"/_solara/auth/login\", endpoint=login),",
            "    ]",
            "routes = [",
            "    Route(\"/readyz\", endpoint=readyz),",
            "    Route(\"/resourcez\", endpoint=resourcez),",
            "    *routes_auth,",
            "    Route(\"/jupyter/api/kernels/{id}\", endpoint=kernels),",
            "    WebSocketRoute(\"/jupyter/api/kernels/{kernel_id}/{name}\", endpoint=kernel_connection),",
            "    Route(\"/\", endpoint=root),",
            "    Route(\"/{fullpath}\", endpoint=root),",
            "    Route(\"/_solara/api/close/{kernel_id}\", endpoint=close, methods=[\"POST\"]),",
            "    # only enable when the proxy is turned on, otherwise if the directory does not exists we will get an exception",
            "    *([Mount(f\"/{cdn_url_path}\", app=StaticCdn(directory=settings.assets.proxy_cache_dir))] if solara.settings.assets.proxy else []),",
            "    Mount(f\"{prefix}/static/public\", app=StaticPublic()),",
            "    Mount(f\"{prefix}/static/assets\", app=StaticAssets()),",
            "    Mount(f\"{prefix}/static/nbextensions\", app=StaticNbFiles()),",
            "    Mount(f\"{prefix}/static\", app=StaticFilesOptionalAuth(directory=server.solara_static)),",
            "    Route(\"/{fullpath:path}\", endpoint=root),",
            "]",
            "",
            "app = Starlette(routes=routes, on_startup=[on_startup], on_shutdown=[on_shutdown], middleware=middleware)",
            "",
            "# Uncomment the lines below to test solara mouted under a subpath",
            "# def myroot(request: Request):",
            "#     return JSONResponse({\"framework\": \"solara\"})",
            "",
            "# routes_test_sub = [Route(\"/\", endpoint=myroot), Mount(\"/foo/\", routes=routes)]",
            "# app = Starlette(routes=routes_test_sub, on_startup=[on_startup], on_shutdown=[on_shutdown], middleware=middleware)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "452": [
                "StaticCdn",
                "lookup_path"
            ]
        },
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes"
        ]
    },
    "solara/server/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import contextlib"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import pdb"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import traceback"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     os._exit(-1)"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+def path_is_child_of(path: Path, parent: Path) -> bool:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    # We use os.path.normpath() because we do not want to follow symlinks"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    # in editable installs, since some packages are symlinked"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    return os.path.normpath(path).startswith(os.path.normpath(parent))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " @contextlib.contextmanager"
            },
            "17": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " def pdb_guard():"
            },
            "18": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     from . import settings"
            }
        },
        "frontPatchFile": [
            "import contextlib",
            "import logging",
            "import os",
            "import pdb",
            "import traceback",
            "",
            "from rich import print",
            "",
            "logger = logging.getLogger(\"solara.server\")",
            "",
            "",
            "def start_error(title, msg, exception: Exception = None):",
            "    if exception:",
            "        traceback.print_exception(None, exception, exception.__traceback__)",
            "    print(f\"[red]{title}:\\n\\t[blue]{msg}\")  # noqa",
            "    os._exit(-1)",
            "",
            "",
            "@contextlib.contextmanager",
            "def pdb_guard():",
            "    from . import settings",
            "",
            "    try:",
            "        yield",
            "    except Exception:",
            "        if settings.main.use_pdb:",
            "            logger.exception(\"Exception, will be handled by debugger\")",
            "            pdb.post_mortem()",
            "        else:",
            "            raise"
        ],
        "afterPatchFile": [
            "import contextlib",
            "import logging",
            "import os",
            "from pathlib import Path",
            "import pdb",
            "import traceback",
            "",
            "from rich import print",
            "",
            "logger = logging.getLogger(\"solara.server\")",
            "",
            "",
            "def start_error(title, msg, exception: Exception = None):",
            "    if exception:",
            "        traceback.print_exception(None, exception, exception.__traceback__)",
            "    print(f\"[red]{title}:\\n\\t[blue]{msg}\")  # noqa",
            "    os._exit(-1)",
            "",
            "",
            "def path_is_child_of(path: Path, parent: Path) -> bool:",
            "    # We use os.path.normpath() because we do not want to follow symlinks",
            "    # in editable installs, since some packages are symlinked",
            "    return os.path.normpath(path).startswith(os.path.normpath(parent))",
            "",
            "",
            "@contextlib.contextmanager",
            "def pdb_guard():",
            "    from . import settings",
            "",
            "    try:",
            "        yield",
            "    except Exception:",
            "        if settings.main.use_pdb:",
            "            logger.exception(\"Exception, will be handled by debugger\")",
            "            pdb.post_mortem()",
            "        else:",
            "            raise"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes"
        ]
    }
}