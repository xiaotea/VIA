{
    "rdiffweb/core/model/_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                     _(\"Duplicate key. This key already exists or is associated to another user.\")"
            },
            "1": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                 )"
            },
            "2": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)"
            },
            "4": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     def add_access_token(self, name, expiration_time=None, length=16):"
            },
            "6": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Integer, SmallInteger, String, and_, event, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False, unique=True)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object.\"\"\"",
            "        return UserObject.query.filter(UserObject.username == user).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Integer, SmallInteger, String, and_, event, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False, unique=True)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object.\"\"\"",
            "        return UserObject.query.filter(UserObject.username == user).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.kernel_tests.array_ops_test.StridedSliceTest"
        ]
    },
    "rdiffweb/core/notification.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         self.bus.log('Start Notification plugin')"
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         self.bus.publish('schedule_job', self.execution_time, self.notification_job)"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.bus.subscribe('access_token_added', self.access_token_added)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        self.bus.subscribe('authorizedkey_added', self.authorizedkey_added)"
            },
            "4": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         self.bus.subscribe('user_attr_changed', self.user_attr_changed)"
            },
            "5": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         self.bus.subscribe('user_password_changed', self.user_password_changed)"
            },
            "6": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         self.bus.log('Stop Notification plugin')"
            },
            "8": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         self.bus.publish('unschedule_job', self.notification_job)"
            },
            "9": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         self.bus.unsubscribe('access_token_added', self.access_token_added)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        self.bus.unsubscribe('authorizedkey_added', self.authorizedkey_added)"
            },
            "11": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.bus.unsubscribe('user_attr_changed', self.user_attr_changed)"
            },
            "12": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self.bus.unsubscribe('user_password_changed', self.user_password_changed)"
            },
            "13": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         )"
            },
            "15": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         self.bus.publish('queue_mail', to=userobj.email, subject=_(\"A new access token has been created\"), message=body)"
            },
            "16": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    def authorizedkey_added(self, userobj, fingerprint, comment, **kwargs):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        if not self.send_changed:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            return"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        if not userobj.email:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            return"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        # If the email attributes was changed, send a mail notification."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        body = self.app.templates.compile_template("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            \"email_authorizedkey_added.html\","
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            **{\"header_name\": self.app.cfg.header_name, 'user': userobj, 'comment': comment, 'fingerprint': fingerprint}"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        )"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"A new SSH Key has been added\"), message=body)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     def user_attr_changed(self, userobj, attrs={}):"
            },
            "33": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         if not self.send_changed:"
            },
            "34": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             return"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Plugin used to send email to users when their repository is getting too old.",
            "User can control the notification period.",
            "\"\"\"",
            "",
            "import datetime",
            "import logging",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "",
            "from rdiffweb.core import librdiff",
            "from rdiffweb.core.model import UserObject",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NotificationPlugin(SimplePlugin):",
            "    \"\"\"",
            "    Send email notification when a repository get too old (without a backup).",
            "    \"\"\"",
            "",
            "    execution_time = '23:00'",
            "",
            "    send_changed = False",
            "",
            "    def start(self):",
            "        self.bus.log('Start Notification plugin')",
            "        self.bus.publish('schedule_job', self.execution_time, self.notification_job)",
            "        self.bus.subscribe('access_token_added', self.access_token_added)",
            "        self.bus.subscribe('user_attr_changed', self.user_attr_changed)",
            "        self.bus.subscribe('user_password_changed', self.user_password_changed)",
            "",
            "    start.priority = 55",
            "",
            "    def stop(self):",
            "        self.bus.log('Stop Notification plugin')",
            "        self.bus.publish('unschedule_job', self.notification_job)",
            "        self.bus.unsubscribe('access_token_added', self.access_token_added)",
            "        self.bus.unsubscribe('user_attr_changed', self.user_attr_changed)",
            "        self.bus.unsubscribe('user_password_changed', self.user_password_changed)",
            "",
            "    stop.priority = 45",
            "",
            "    @property",
            "    def app(self):",
            "        return cherrypy.tree.apps['']",
            "",
            "    def access_token_added(self, userobj, name):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        if not userobj.email:",
            "            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "            return",
            "",
            "        # Send a mail notification",
            "        body = self.app.templates.compile_template(",
            "            \"email_access_token_added.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj, 'name': name}",
            "        )",
            "        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"A new access token has been created\"), message=body)",
            "",
            "    def user_attr_changed(self, userobj, attrs={}):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        # Leave if the mail was not changed.",
            "        if 'email' in attrs:",
            "            old_email = attrs['email'][0]",
            "            if not old_email:",
            "                logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "                return",
            "            # If the email attributes was changed, send a mail notification.",
            "            subject = _(\"Email address changed\")",
            "            body = self.app.templates.compile_template(",
            "                \"email_changed.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "            )",
            "            self.bus.publish('queue_mail', to=old_email, subject=str(subject), message=body)",
            "",
            "        if 'mfa' in attrs:",
            "            if not userobj.email:",
            "                logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "                return",
            "            subject = (",
            "                _(\"Two-Factor Authentication turned off\")",
            "                if userobj.mfa == UserObject.DISABLED_MFA",
            "                else _(\"Two-Factor Authentication turned on\")",
            "            )",
            "            body = self.app.templates.compile_template(",
            "                \"email_mfa.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "            )",
            "            self.bus.publish('queue_mail', to=userobj.email, subject=str(subject), message=body)",
            "",
            "    def user_password_changed(self, userobj):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        if not userobj.email:",
            "            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "            return",
            "",
            "        # If the email attributes was changed, send a mail notification.",
            "        body = self.app.templates.compile_template(",
            "            \"email_password_changed.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "        )",
            "        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"Password changed\"), message=body)",
            "",
            "    def notification_job(self):",
            "        \"\"\"",
            "        Loop trough all the user repository and send notifications.",
            "        \"\"\"",
            "",
            "        now = librdiff.RdiffTime()",
            "",
            "        def _user_repos():",
            "            \"\"\"Return a generator trought user repos to be notified.\"\"\"",
            "            for user in UserObject.query.all():",
            "                # Check if user has email.",
            "                if not user.email:",
            "                    continue",
            "                # Identify old repo for current user.",
            "                old_repos = []",
            "                for repo in user.repo_objs:",
            "                    # Check if repo has age configured (in days)",
            "                    maxage = repo.maxage",
            "                    if not maxage or maxage <= 0:",
            "                        continue",
            "                    # Check repo age.",
            "                    if repo.last_backup_date is None or repo.last_backup_date < (now - datetime.timedelta(days=maxage)):",
            "                        old_repos.append(repo)",
            "                # Return an item only if user had old repo",
            "                if old_repos:",
            "                    yield user, old_repos",
            "",
            "        # For each candidate, send mail.",
            "        for user, repos in _user_repos():",
            "            parms = {'user': user, 'repos': repos}",
            "            body = self.app.templates.compile_template(\"email_notification.html\", **parms)",
            "            cherrypy.engine.publish('queue_mail', to=user.email, subject=_(\"Notification\"), message=body)",
            "",
            "",
            "cherrypy.notification = NotificationPlugin(cherrypy.engine)",
            "cherrypy.notification.subscribe()",
            "",
            "cherrypy.config.namespaces['notification'] = lambda key, value: setattr(cherrypy.notification, key, value)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Plugin used to send email to users when their repository is getting too old.",
            "User can control the notification period.",
            "\"\"\"",
            "",
            "import datetime",
            "import logging",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "",
            "from rdiffweb.core import librdiff",
            "from rdiffweb.core.model import UserObject",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NotificationPlugin(SimplePlugin):",
            "    \"\"\"",
            "    Send email notification when a repository get too old (without a backup).",
            "    \"\"\"",
            "",
            "    execution_time = '23:00'",
            "",
            "    send_changed = False",
            "",
            "    def start(self):",
            "        self.bus.log('Start Notification plugin')",
            "        self.bus.publish('schedule_job', self.execution_time, self.notification_job)",
            "        self.bus.subscribe('access_token_added', self.access_token_added)",
            "        self.bus.subscribe('authorizedkey_added', self.authorizedkey_added)",
            "        self.bus.subscribe('user_attr_changed', self.user_attr_changed)",
            "        self.bus.subscribe('user_password_changed', self.user_password_changed)",
            "",
            "    start.priority = 55",
            "",
            "    def stop(self):",
            "        self.bus.log('Stop Notification plugin')",
            "        self.bus.publish('unschedule_job', self.notification_job)",
            "        self.bus.unsubscribe('access_token_added', self.access_token_added)",
            "        self.bus.unsubscribe('authorizedkey_added', self.authorizedkey_added)",
            "        self.bus.unsubscribe('user_attr_changed', self.user_attr_changed)",
            "        self.bus.unsubscribe('user_password_changed', self.user_password_changed)",
            "",
            "    stop.priority = 45",
            "",
            "    @property",
            "    def app(self):",
            "        return cherrypy.tree.apps['']",
            "",
            "    def access_token_added(self, userobj, name):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        if not userobj.email:",
            "            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "            return",
            "",
            "        # Send a mail notification",
            "        body = self.app.templates.compile_template(",
            "            \"email_access_token_added.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj, 'name': name}",
            "        )",
            "        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"A new access token has been created\"), message=body)",
            "",
            "    def authorizedkey_added(self, userobj, fingerprint, comment, **kwargs):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        if not userobj.email:",
            "            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "            return",
            "",
            "        # If the email attributes was changed, send a mail notification.",
            "        body = self.app.templates.compile_template(",
            "            \"email_authorizedkey_added.html\",",
            "            **{\"header_name\": self.app.cfg.header_name, 'user': userobj, 'comment': comment, 'fingerprint': fingerprint}",
            "        )",
            "        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"A new SSH Key has been added\"), message=body)",
            "",
            "    def user_attr_changed(self, userobj, attrs={}):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        # Leave if the mail was not changed.",
            "        if 'email' in attrs:",
            "            old_email = attrs['email'][0]",
            "            if not old_email:",
            "                logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "                return",
            "            # If the email attributes was changed, send a mail notification.",
            "            subject = _(\"Email address changed\")",
            "            body = self.app.templates.compile_template(",
            "                \"email_changed.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "            )",
            "            self.bus.publish('queue_mail', to=old_email, subject=str(subject), message=body)",
            "",
            "        if 'mfa' in attrs:",
            "            if not userobj.email:",
            "                logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "                return",
            "            subject = (",
            "                _(\"Two-Factor Authentication turned off\")",
            "                if userobj.mfa == UserObject.DISABLED_MFA",
            "                else _(\"Two-Factor Authentication turned on\")",
            "            )",
            "            body = self.app.templates.compile_template(",
            "                \"email_mfa.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "            )",
            "            self.bus.publish('queue_mail', to=userobj.email, subject=str(subject), message=body)",
            "",
            "    def user_password_changed(self, userobj):",
            "        if not self.send_changed:",
            "            return",
            "",
            "        if not userobj.email:",
            "            logger.info(\"can't sent mail to user [%s] without an email\", userobj.username)",
            "            return",
            "",
            "        # If the email attributes was changed, send a mail notification.",
            "        body = self.app.templates.compile_template(",
            "            \"email_password_changed.html\", **{\"header_name\": self.app.cfg.header_name, 'user': userobj}",
            "        )",
            "        self.bus.publish('queue_mail', to=userobj.email, subject=_(\"Password changed\"), message=body)",
            "",
            "    def notification_job(self):",
            "        \"\"\"",
            "        Loop trough all the user repository and send notifications.",
            "        \"\"\"",
            "",
            "        now = librdiff.RdiffTime()",
            "",
            "        def _user_repos():",
            "            \"\"\"Return a generator trought user repos to be notified.\"\"\"",
            "            for user in UserObject.query.all():",
            "                # Check if user has email.",
            "                if not user.email:",
            "                    continue",
            "                # Identify old repo for current user.",
            "                old_repos = []",
            "                for repo in user.repo_objs:",
            "                    # Check if repo has age configured (in days)",
            "                    maxage = repo.maxage",
            "                    if not maxage or maxage <= 0:",
            "                        continue",
            "                    # Check repo age.",
            "                    if repo.last_backup_date is None or repo.last_backup_date < (now - datetime.timedelta(days=maxage)):",
            "                        old_repos.append(repo)",
            "                # Return an item only if user had old repo",
            "                if old_repos:",
            "                    yield user, old_repos",
            "",
            "        # For each candidate, send mail.",
            "        for user, repos in _user_repos():",
            "            parms = {'user': user, 'repos': repos}",
            "            body = self.app.templates.compile_template(\"email_notification.html\", **parms)",
            "            cherrypy.engine.publish('queue_mail', to=user.email, subject=_(\"Notification\"), message=body)",
            "",
            "",
            "cherrypy.notification = NotificationPlugin(cherrypy.engine)",
            "cherrypy.notification.subscribe()",
            "",
            "cherrypy.config.namespaces['notification'] = lambda key, value: setattr(cherrypy.notification, key, value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "rdiffweb.core.notification.NotificationPlugin.self",
            "rdiffweb.core.notification.NotificationPlugin.user_attr_changed.attrs",
            "tensorflow.python.kernel_tests.array_ops_test.StridedSliceTest",
            "cherrypy.notification"
        ]
    },
    "rdiffweb/core/tests/test_notification.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "             subject='Password changed',"
            },
            "1": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>You recently changed the password associated with your Rdiffweb account.</p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',"
            },
            "2": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    def test_access_token_added(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        # Given a user with a email."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        user = UserObject.get_user(self.USERNAME)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        user.email = 'password_change@test.com'"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        user.set_password('new_password')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        user.add().commit()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        self.listener.queue_email.reset_mock()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        # When adding a new access token"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        user.add_access_token('TEST')"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        # Then a notification is sent to the user"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        self.listener.queue_email.assert_called_once_with("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            to='password_change@test.com',"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            subject='A new access token has been created',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>A new access token, named \"TEST\", has been created.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        )"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+    def test_authorizedkey_added(self):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        # Given a user with a email."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        user = UserObject.get_user(self.USERNAME)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        user.email = 'password_change@test.com'"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        user.set_password('new_password')"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        user.add().commit()"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        self.listener.queue_email.reset_mock()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        # When adding a new access token"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        user.add_authorizedkey("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            key=\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDSEN5VTn9MLituZvdYTZMbZEaMxe0UuU7BelxHkvxzSpVWtazrIBEc3KZjtVoK9F3+0kd26P4DzSQuPUl3yZDgyZZeXrF6p2GlEA7A3tPuOEsAQ9c0oTiDYktq5/Go8vD+XAZKLd//qmCWW1Jg4datkWchMKJzbHUgBrBH015FDbGvGDWYTfVyb8I9H+LQ0GmbTHsuTu63DhPODncMtWPuS9be/flb4EEojMIx5Vce0SNO9Eih38W7jTvNWxZb75k5yfPJxBULRnS5v/fPnDVVtD3JSGybSwKoMdsMX5iImAeNhqnvd8gBu1f0IycUQexTbJXk1rPiRcF13SjKrfXz ikus060@ikus060-t530\","
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            comment=\"test@mysshkey\","
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        )"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        # Then a notification is sent to the user"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        self.listener.queue_email.assert_called_once_with("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            to='password_change@test.com',"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            subject='A new SSH Key has been added',"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>A new SSH Key, titled \"test@mysshkey\" with fingerprint \"4d:42:8b:35:e5:55:71:f7:b3:0d:58:f9:b1:2c:9e:91\" has been created in your account.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        )"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"",
            "Created on Feb 13, 2016",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.core.notification",
            "import rdiffweb.test",
            "from rdiffweb.core.model import RepoObject, UserObject",
            "",
            "",
            "class NotificationJobTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_email)",
            "        return super().tearDown()",
            "",
            "    def test_check_schedule(self):",
            "        # Given the application is started",
            "        # Then remove_older job should be schedule",
            "        self.assertEqual(1, len([job for job in cherrypy.scheduler.list_jobs() if job.name == 'notification_job']))",
            "",
            "    def test_notification_job(self):",
            "        \"\"\"",
            "        Run the notification and check if mails are sent",
            "        \"\"\"",
            "        # Given a user with an email address and a repository with a maxage",
            "        # Set user config",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.commit()",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "        repo.maxage = 1",
            "        repo.commit()",
            "        # When running notification_job",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Then an email is queue for this user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='test@test.com',",
            "            subject='Notification',",
            "            message=\"<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      You are receiving this email to notify you about your backups. The\\n      following repositories are inactive for some time. We invite you to have a look\\n      at your last backup schedule.\\n    </p>\\n    <ul>\\n      \\n        <li>\\n          <a>testcases</a>\\n        </li>\\n      \\n    </ul>\\n    <p>If you don't want to be notify about this. You need to review your user preferences.</p>\\n  </body>\\n</html>\",",
            "        )",
            "",
            "    def test_notification_job_undefined_last_backup_date(self):",
            "        # Given a valid user with a repository configured for notification",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.add().commit()",
            "        # Given a repo with last_backup_date None",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == 'broker-repo').first()",
            "        repo.maxage = 1",
            "        repo.add().commit()",
            "        self.assertIsNone(repo.last_backup_date)",
            "",
            "        # When Notification job is running",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Then a notification is sent to the user.",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='test@test.com',",
            "            subject='Notification',",
            "            message=\"<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      You are receiving this email to notify you about your backups. The\\n      following repositories are inactive for some time. We invite you to have a look\\n      at your last backup schedule.\\n    </p>\\n    <ul>\\n      \\n        <li>\\n          <a>broker-repo</a>\\n        </li>\\n      \\n    </ul>\\n    <p>If you don't want to be notify about this. You need to review your user preferences.</p>\\n  </body>\\n</html>\",",
            "        )",
            "",
            "    def test_notification_job_without_notification(self):",
            "        # Given a valid user with a repository configured without notification (-1)",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.add().commit()",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "        repo.maxage = -1",
            "        repo.add().commit()",
            "",
            "        # Call notification.",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Expect it to be called.",
            "        self.listener.queue_email.assert_not_called()",
            "",
            "",
            "class NotificationPluginTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {",
            "        'email-send-changed-notification': True,",
            "    }",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_email)",
            "        return super().tearDown()",
            "",
            "    def test_email_changed(self):",
            "        # Given a user with an email address",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'original_email@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user's email",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "",
            "        # Then a email is queue to notify the user.",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='original_email@test.com',",
            "            subject='Email address changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>You recently changed the email address associated with your Rdiffweb account.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_email_updated_with_same_value(self):",
            "        # Given a user with an email",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user's email with the same value",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "",
            "        # Then no email are sent to the user",
            "        self.listener.queue_email.assert_not_called()",
            "",
            "    def test_password_change_notification(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user password",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "",
            "        # Then a email is send to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='Password changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>You recently changed the password associated with your Rdiffweb account.</p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_password_change_with_same_value(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user password with the same value",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "",
            "        # Then an email is sent to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='Password changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>You recently changed the password associated with your Rdiffweb account.</p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"",
            "Created on Feb 13, 2016",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.core.notification",
            "import rdiffweb.test",
            "from rdiffweb.core.model import RepoObject, UserObject",
            "",
            "",
            "class NotificationJobTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_email)",
            "        return super().tearDown()",
            "",
            "    def test_check_schedule(self):",
            "        # Given the application is started",
            "        # Then remove_older job should be schedule",
            "        self.assertEqual(1, len([job for job in cherrypy.scheduler.list_jobs() if job.name == 'notification_job']))",
            "",
            "    def test_notification_job(self):",
            "        \"\"\"",
            "        Run the notification and check if mails are sent",
            "        \"\"\"",
            "        # Given a user with an email address and a repository with a maxage",
            "        # Set user config",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.commit()",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "        repo.maxage = 1",
            "        repo.commit()",
            "        # When running notification_job",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Then an email is queue for this user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='test@test.com',",
            "            subject='Notification',",
            "            message=\"<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      You are receiving this email to notify you about your backups. The\\n      following repositories are inactive for some time. We invite you to have a look\\n      at your last backup schedule.\\n    </p>\\n    <ul>\\n      \\n        <li>\\n          <a>testcases</a>\\n        </li>\\n      \\n    </ul>\\n    <p>If you don't want to be notify about this. You need to review your user preferences.</p>\\n  </body>\\n</html>\",",
            "        )",
            "",
            "    def test_notification_job_undefined_last_backup_date(self):",
            "        # Given a valid user with a repository configured for notification",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.add().commit()",
            "        # Given a repo with last_backup_date None",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == 'broker-repo').first()",
            "        repo.maxage = 1",
            "        repo.add().commit()",
            "        self.assertIsNone(repo.last_backup_date)",
            "",
            "        # When Notification job is running",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Then a notification is sent to the user.",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='test@test.com',",
            "            subject='Notification',",
            "            message=\"<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      You are receiving this email to notify you about your backups. The\\n      following repositories are inactive for some time. We invite you to have a look\\n      at your last backup schedule.\\n    </p>\\n    <ul>\\n      \\n        <li>\\n          <a>broker-repo</a>\\n        </li>\\n      \\n    </ul>\\n    <p>If you don't want to be notify about this. You need to review your user preferences.</p>\\n  </body>\\n</html>\",",
            "        )",
            "",
            "    def test_notification_job_without_notification(self):",
            "        # Given a valid user with a repository configured without notification (-1)",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'test@test.com'",
            "        user.add().commit()",
            "        repo = RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "        repo.maxage = -1",
            "        repo.add().commit()",
            "",
            "        # Call notification.",
            "        cherrypy.notification.notification_job()",
            "",
            "        # Expect it to be called.",
            "        self.listener.queue_email.assert_not_called()",
            "",
            "",
            "class NotificationPluginTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {",
            "        'email-send-changed-notification': True,",
            "    }",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_email)",
            "        return super().tearDown()",
            "",
            "    def test_email_changed(self):",
            "        # Given a user with an email address",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'original_email@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user's email",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "",
            "        # Then a email is queue to notify the user.",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='original_email@test.com',",
            "            subject='Email address changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>You recently changed the email address associated with your Rdiffweb account.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_email_updated_with_same_value(self):",
            "        # Given a user with an email",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user's email with the same value",
            "        user.email = 'email_changed@test.com'",
            "        user.add().commit()",
            "",
            "        # Then no email are sent to the user",
            "        self.listener.queue_email.assert_not_called()",
            "",
            "    def test_password_change_notification(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user password",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "",
            "        # Then a email is send to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='Password changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>You recently changed the password associated with your Rdiffweb account.</p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_password_change_with_same_value(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When updating the user password with the same value",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "",
            "        # Then an email is sent to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='Password changed',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>You recently changed the password associated with your Rdiffweb account.</p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_access_token_added(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When adding a new access token",
            "        user.add_access_token('TEST')",
            "",
            "        # Then a notification is sent to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='A new access token has been created',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>A new access token, named \"TEST\", has been created.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )",
            "",
            "    def test_authorizedkey_added(self):",
            "        # Given a user with a email.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.email = 'password_change@test.com'",
            "        user.set_password('new_password')",
            "        user.add().commit()",
            "        self.listener.queue_email.reset_mock()",
            "",
            "        # When adding a new access token",
            "        user.add_authorizedkey(",
            "            key=\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDSEN5VTn9MLituZvdYTZMbZEaMxe0UuU7BelxHkvxzSpVWtazrIBEc3KZjtVoK9F3+0kd26P4DzSQuPUl3yZDgyZZeXrF6p2GlEA7A3tPuOEsAQ9c0oTiDYktq5/Go8vD+XAZKLd//qmCWW1Jg4datkWchMKJzbHUgBrBH015FDbGvGDWYTfVyb8I9H+LQ0GmbTHsuTu63DhPODncMtWPuS9be/flb4EEojMIx5Vce0SNO9Eih38W7jTvNWxZb75k5yfPJxBULRnS5v/fPnDVVtD3JSGybSwKoMdsMX5iImAeNhqnvd8gBu1f0IycUQexTbJXk1rPiRcF13SjKrfXz ikus060@ikus060-t530\",",
            "            comment=\"test@mysshkey\",",
            "        )",
            "",
            "        # Then a notification is sent to the user",
            "        self.listener.queue_email.assert_called_once_with(",
            "            to='password_change@test.com',",
            "            subject='A new SSH Key has been added',",
            "            message='<html>\\n  <head></head>\\n  <body>\\n    <p>\\n      <a>Hey admin,</a>\\n    </p>\\n    <p>\\n      <a>A new SSH Key, titled \"test@mysshkey\" with fingerprint \"4d:42:8b:35:e5:55:71:f7:b3:0d:58:f9:b1:2c:9e:91\" has been created in your account.</a>\\n    </p>\\n    <p>\\n      If you did not make this change and believe your account has been compromised, please contact your administrator.\\n    </p>\\n  </body>\\n</html>',",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.kernel_tests.array_ops_test.StridedSliceTest",
            "rdiffweb.core.tests.test_notification.NotificationPluginTest.default_config",
            "rdiffweb.core.tests.test_notification.NotificationPluginTest.self"
        ]
    }
}