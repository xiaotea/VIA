{
    "django/contrib/auth/hashers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import binascii"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import hashlib"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import importlib"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import warnings"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from collections import OrderedDict"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.conf import settings"
            },
            "7": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     preferred = get_hasher(preferred)"
            },
            "8": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     hasher = identify_hasher(encoded)"
            },
            "9": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    must_update = hasher.algorithm != preferred.algorithm"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not must_update:"
            },
            "12": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        must_update = preferred.must_update(encoded)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    hasher_changed = hasher.algorithm != preferred.algorithm"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    must_update = hasher_changed or preferred.must_update(encoded)"
            },
            "15": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     is_correct = hasher.verify(password, encoded)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    # If the hasher didn't change (we don't protect against enumeration if it"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    # does) and the password should get updated, try to close the timing gap"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    # between the work factor of the current encoded password and the default"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    # work factor."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    if not is_correct and not hasher_changed and must_update:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        hasher.harden_runtime(password, encoded)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     if setter and is_correct and must_update:"
            },
            "25": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         setter(password)"
            },
            "26": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     return is_correct"
            },
            "27": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "     def must_update(self, encoded):"
            },
            "28": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         return False"
            },
            "29": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        Bridge the runtime gap between the work factor supplied in `encoded`"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        and the work factor suggested by this hasher."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        `self.iterations` is 30000, this method should run password through"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        another 10000 iterations of PBKDF2. Similar approaches should exist"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        for any hasher that has a work factor. If not, this method should be"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        defined as a no-op to silence the warning."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        \"\"\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 241,
                "PatchRowcode": " class PBKDF2PasswordHasher(BasePasswordHasher):"
            },
            "45": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "     \"\"\""
            },
            "46": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         algorithm, iterations, salt, hash = encoded.split('$', 3)"
            },
            "47": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         return int(iterations) != self.iterations"
            },
            "48": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+        algorithm, iterations, salt, hash = encoded.split('$', 3)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        extra_iterations = self.iterations - int(iterations)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        if extra_iterations > 0:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+            self.encode(password, salt, extra_iterations)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):"
            },
            "57": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     \"\"\""
            },
            "58": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "59": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         algorithm, data = encoded.split('$', 1)"
            },
            "60": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "61": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        bcrypt = self._load_library()"
            },
            "62": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "63": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Hash the password prior to using bcrypt to prevent password truncation"
            },
            "64": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        #   See: https://code.djangoproject.com/ticket/20138"
            },
            "65": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.digest is not None:"
            },
            "66": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # We use binascii.hexlify here because Python3 decided that a hex encoded"
            },
            "67": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            #   bytestring is somehow a unicode."
            },
            "68": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            password = binascii.hexlify(self.digest(force_bytes(password)).digest())"
            },
            "69": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "70": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            password = force_bytes(password)"
            },
            "71": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "72": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Ensure that our data is a bytestring"
            },
            "73": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = force_bytes(data)"
            },
            "74": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # force_bytes() necessary for py-bcrypt compatibility"
            },
            "75": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        hashpw = force_bytes(bcrypt.hashpw(password, data))"
            },
            "76": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "77": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return constant_time_compare(data, hashpw)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+        encoded_2 = self.encode(password, force_bytes(data))"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+        return constant_time_compare(encoded, encoded_2)"
            },
            "80": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 340,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "     def safe_summary(self, encoded):"
            },
            "82": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)"
            },
            "83": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "             (_('checksum'), mask_hash(checksum)),"
            },
            "84": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         ])"
            },
            "85": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 351,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+        _, data = encoded.split('$', 1)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        salt = data[:29]  # Length of the salt in bcrypt."
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        rounds = data.split('$')[2]"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        # work factor is logarithmic, adding one doubles the load."
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        diff = 2**(self.rounds - int(rounds)) - 1"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        while diff > 0:"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+            self.encode(password, force_bytes(salt))"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+            diff -= 1"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+"
            },
            "96": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 362,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 363,
                "PatchRowcode": " class BCryptPasswordHasher(BCryptSHA256PasswordHasher):"
            },
            "98": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "     \"\"\""
            },
            "99": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "             (_('hash'), mask_hash(hash)),"
            },
            "100": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         ])"
            },
            "101": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 408,
                "PatchRowcode": " "
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        pass"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+"
            },
            "105": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 412,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 413,
                "PatchRowcode": " class MD5PasswordHasher(BasePasswordHasher):"
            },
            "107": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "     \"\"\""
            },
            "108": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "             (_('hash'), mask_hash(hash)),"
            },
            "109": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         ])"
            },
            "110": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 439,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        pass"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+"
            },
            "114": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 443,
                "PatchRowcode": " "
            },
            "115": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 444,
                "PatchRowcode": " class UnsaltedSHA1PasswordHasher(BasePasswordHasher):"
            },
            "116": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "     \"\"\""
            },
            "117": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "             (_('hash'), mask_hash(hash)),"
            },
            "118": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "         ])"
            },
            "119": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 474,
                "PatchRowcode": " "
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+        pass"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+"
            },
            "123": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 478,
                "PatchRowcode": " "
            },
            "124": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 479,
                "PatchRowcode": " class UnsaltedMD5PasswordHasher(BasePasswordHasher):"
            },
            "125": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "     \"\"\""
            },
            "126": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "             (_('hash'), mask_hash(encoded, show=3)),"
            },
            "127": {
                "beforePatchRowNumber": 478,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "         ])"
            },
            "128": {
                "beforePatchRowNumber": 479,
                "afterPatchRowNumber": 510,
                "PatchRowcode": " "
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+        pass"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+"
            },
            "132": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 514,
                "PatchRowcode": " "
            },
            "133": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": 515,
                "PatchRowcode": " class CryptPasswordHasher(BasePasswordHasher):"
            },
            "134": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "     \"\"\""
            },
            "135": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": 545,
                "PatchRowcode": "             (_('salt'), salt),"
            },
            "136": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "             (_('hash'), mask_hash(data, show=3)),"
            },
            "137": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "         ])"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+    def harden_runtime(self, password, encoded):"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 550,
                "PatchRowcode": "+        pass"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import binascii",
            "import hashlib",
            "import importlib",
            "from collections import OrderedDict",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.core.signals import setting_changed",
            "from django.dispatch import receiver",
            "from django.utils import lru_cache",
            "from django.utils.crypto import (",
            "    constant_time_compare, get_random_string, pbkdf2,",
            ")",
            "from django.utils.encoding import force_bytes, force_str, force_text",
            "from django.utils.module_loading import import_string",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash",
            "UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX",
            "",
            "",
            "def is_password_usable(encoded):",
            "    if encoded is None or encoded.startswith(UNUSABLE_PASSWORD_PREFIX):",
            "        return False",
            "    try:",
            "        identify_hasher(encoded)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if password is None or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    hasher = identify_hasher(encoded)",
            "",
            "    must_update = hasher.algorithm != preferred.algorithm",
            "    if not must_update:",
            "        must_update = preferred.must_update(encoded)",
            "    is_correct = hasher.verify(password, encoded)",
            "    if setter and is_correct and must_update:",
            "        setter(password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.",
            "    If password is None then a concatenation of",
            "    UNUSABLE_PASSWORD_PREFIX and a random string will be returned",
            "    which disallows logins. Additional random string reduces chances",
            "    of gaining access to staff or superuser accounts.",
            "    See ticket #20079 for more info.",
            "    \"\"\"",
            "    if password is None:",
            "        return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)",
            "    hasher = get_hasher(hasher)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "@lru_cache.lru_cache()",
            "def get_hashers():",
            "    hashers = []",
            "    for hasher_path in settings.PASSWORD_HASHERS:",
            "        hasher_cls = import_string(hasher_path)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % hasher_path)",
            "        hashers.append(hasher)",
            "    return hashers",
            "",
            "",
            "@lru_cache.lru_cache()",
            "def get_hashers_by_algorithm():",
            "    return {hasher.algorithm: hasher for hasher in get_hashers()}",
            "",
            "",
            "@receiver(setting_changed)",
            "def reset_hashers(**kwargs):",
            "    if kwargs['setting'] == 'PASSWORD_HASHERS':",
            "        get_hashers.cache_clear()",
            "        get_hashers_by_algorithm.cache_clear()",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        return get_hashers()[0]",
            "",
            "    else:",
            "        hashers = get_hashers_by_algorithm()",
            "        try:",
            "            return hashers[algorithm]",
            "        except KeyError:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "",
            "",
            "def identify_hasher(encoded):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    Identifies hasher algorithm by examining encoded hash, and calls",
            "    get_hasher() to return hasher. Raises ValueError if",
            "    algorithm cannot be identified, or if hasher is not loaded.",
            "    \"\"\"",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        algorithm = 'unsalted_md5'",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        algorithm = 'unsalted_sha1'",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "    return get_hasher(algorithm)",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError as e:",
            "                raise ValueError(\"Couldn't load %r algorithm library: %s\" %",
            "                                 (self.__class__.__name__, e))",
            "            return module",
            "        raise ValueError(\"Hasher %r doesn't specify a library attribute\" %",
            "                         self.__class__.__name__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ASCII",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide a verify() method')",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide an encode() method')",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide a safe_summary() method')",
            "",
            "    def must_update(self, encoded):",
            "        return False",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 20000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 20000",
            "    digest = hashlib.sha256",
            "",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = base64.b64encode(hash).decode('ascii').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "    def must_update(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        return int(iterations) != self.iterations",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptSHA256PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt_sha256\"",
            "    digest = hashlib.sha256",
            "    library = (\"bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        # Need to reevaluate the force_bytes call once bcrypt is supported on",
            "        # Python 3",
            "",
            "        # Hash the password prior to using bcrypt to prevent password truncation",
            "        #   See: https://code.djangoproject.com/ticket/20138",
            "        if self.digest is not None:",
            "            # We use binascii.hexlify here because Python3 decided that a hex encoded",
            "            #   bytestring is somehow a unicode.",
            "            password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
            "        else:",
            "            password = force_bytes(password)",
            "",
            "        data = bcrypt.hashpw(password, salt)",
            "        return \"%s$%s\" % (self.algorithm, force_text(data))",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        bcrypt = self._load_library()",
            "",
            "        # Hash the password prior to using bcrypt to prevent password truncation",
            "        #   See: https://code.djangoproject.com/ticket/20138",
            "        if self.digest is not None:",
            "            # We use binascii.hexlify here because Python3 decided that a hex encoded",
            "            #   bytestring is somehow a unicode.",
            "            password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
            "        else:",
            "            password = force_bytes(password)",
            "",
            "        # Ensure that our data is a bytestring",
            "        data = force_bytes(data)",
            "        # force_bytes() necessary for py-bcrypt compatibility",
            "        hashpw = force_bytes(bcrypt.hashpw(password, data))",
            "",
            "        return constant_time_compare(data, hashpw)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "",
            "class BCryptPasswordHasher(BCryptSHA256PasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "",
            "    This hasher does not first hash the password which means it is subject to",
            "    the 72 character bcrypt password truncation, most use cases should prefer",
            "    the BCryptSHA256PasswordHasher.",
            "",
            "    See: https://code.djangoproject.com/ticket/20138",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    digest = None",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(force_bytes(password)).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return OrderedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(force_bytes(password)).hexdigest()",
            "",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return OrderedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(force_str(password), salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(force_str(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import binascii",
            "import hashlib",
            "import importlib",
            "import warnings",
            "from collections import OrderedDict",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.core.signals import setting_changed",
            "from django.dispatch import receiver",
            "from django.utils import lru_cache",
            "from django.utils.crypto import (",
            "    constant_time_compare, get_random_string, pbkdf2,",
            ")",
            "from django.utils.encoding import force_bytes, force_str, force_text",
            "from django.utils.module_loading import import_string",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash",
            "UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX",
            "",
            "",
            "def is_password_usable(encoded):",
            "    if encoded is None or encoded.startswith(UNUSABLE_PASSWORD_PREFIX):",
            "        return False",
            "    try:",
            "        identify_hasher(encoded)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if password is None or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    hasher = identify_hasher(encoded)",
            "",
            "    hasher_changed = hasher.algorithm != preferred.algorithm",
            "    must_update = hasher_changed or preferred.must_update(encoded)",
            "    is_correct = hasher.verify(password, encoded)",
            "",
            "    # If the hasher didn't change (we don't protect against enumeration if it",
            "    # does) and the password should get updated, try to close the timing gap",
            "    # between the work factor of the current encoded password and the default",
            "    # work factor.",
            "    if not is_correct and not hasher_changed and must_update:",
            "        hasher.harden_runtime(password, encoded)",
            "",
            "    if setter and is_correct and must_update:",
            "        setter(password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.",
            "    If password is None then a concatenation of",
            "    UNUSABLE_PASSWORD_PREFIX and a random string will be returned",
            "    which disallows logins. Additional random string reduces chances",
            "    of gaining access to staff or superuser accounts.",
            "    See ticket #20079 for more info.",
            "    \"\"\"",
            "    if password is None:",
            "        return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)",
            "    hasher = get_hasher(hasher)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "@lru_cache.lru_cache()",
            "def get_hashers():",
            "    hashers = []",
            "    for hasher_path in settings.PASSWORD_HASHERS:",
            "        hasher_cls = import_string(hasher_path)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % hasher_path)",
            "        hashers.append(hasher)",
            "    return hashers",
            "",
            "",
            "@lru_cache.lru_cache()",
            "def get_hashers_by_algorithm():",
            "    return {hasher.algorithm: hasher for hasher in get_hashers()}",
            "",
            "",
            "@receiver(setting_changed)",
            "def reset_hashers(**kwargs):",
            "    if kwargs['setting'] == 'PASSWORD_HASHERS':",
            "        get_hashers.cache_clear()",
            "        get_hashers_by_algorithm.cache_clear()",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        return get_hashers()[0]",
            "",
            "    else:",
            "        hashers = get_hashers_by_algorithm()",
            "        try:",
            "            return hashers[algorithm]",
            "        except KeyError:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "",
            "",
            "def identify_hasher(encoded):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    Identifies hasher algorithm by examining encoded hash, and calls",
            "    get_hasher() to return hasher. Raises ValueError if",
            "    algorithm cannot be identified, or if hasher is not loaded.",
            "    \"\"\"",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        algorithm = 'unsalted_md5'",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        algorithm = 'unsalted_sha1'",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "    return get_hasher(algorithm)",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError as e:",
            "                raise ValueError(\"Couldn't load %r algorithm library: %s\" %",
            "                                 (self.__class__.__name__, e))",
            "            return module",
            "        raise ValueError(\"Hasher %r doesn't specify a library attribute\" %",
            "                         self.__class__.__name__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ASCII",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide a verify() method')",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide an encode() method')",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of BasePasswordHasher must provide a safe_summary() method')",
            "",
            "    def must_update(self, encoded):",
            "        return False",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        \"\"\"",
            "        Bridge the runtime gap between the work factor supplied in `encoded`",
            "        and the work factor suggested by this hasher.",
            "",
            "        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and",
            "        `self.iterations` is 30000, this method should run password through",
            "        another 10000 iterations of PBKDF2. Similar approaches should exist",
            "        for any hasher that has a work factor. If not, this method should be",
            "        defined as a no-op to silence the warning.",
            "        \"\"\"",
            "        warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 20000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 20000",
            "    digest = hashlib.sha256",
            "",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = base64.b64encode(hash).decode('ascii').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "    def must_update(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        return int(iterations) != self.iterations",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        extra_iterations = self.iterations - int(iterations)",
            "        if extra_iterations > 0:",
            "            self.encode(password, salt, extra_iterations)",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptSHA256PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt_sha256\"",
            "    digest = hashlib.sha256",
            "    library = (\"bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        # Need to reevaluate the force_bytes call once bcrypt is supported on",
            "        # Python 3",
            "",
            "        # Hash the password prior to using bcrypt to prevent password truncation",
            "        #   See: https://code.djangoproject.com/ticket/20138",
            "        if self.digest is not None:",
            "            # We use binascii.hexlify here because Python3 decided that a hex encoded",
            "            #   bytestring is somehow a unicode.",
            "            password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
            "        else:",
            "            password = force_bytes(password)",
            "",
            "        data = bcrypt.hashpw(password, salt)",
            "        return \"%s$%s\" % (self.algorithm, force_text(data))",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, force_bytes(data))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        _, data = encoded.split('$', 1)",
            "        salt = data[:29]  # Length of the salt in bcrypt.",
            "        rounds = data.split('$')[2]",
            "        # work factor is logarithmic, adding one doubles the load.",
            "        diff = 2**(self.rounds - int(rounds)) - 1",
            "        while diff > 0:",
            "            self.encode(password, force_bytes(salt))",
            "            diff -= 1",
            "",
            "",
            "class BCryptPasswordHasher(BCryptSHA256PasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "",
            "    This hasher does not first hash the password which means it is subject to",
            "    the 72 character bcrypt password truncation, most use cases should prefer",
            "    the BCryptSHA256PasswordHasher.",
            "",
            "    See: https://code.djangoproject.com/ticket/20138",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    digest = None",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        pass",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password is not None",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        pass",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(force_bytes(password)).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return OrderedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        pass",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(force_bytes(password)).hexdigest()",
            "",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return OrderedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        pass",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(force_str(password), salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(force_str(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return OrderedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])",
            "",
            "    def harden_runtime(self, password, encoded):",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "49": [
                "check_password"
            ],
            "50": [
                "check_password"
            ],
            "51": [
                "check_password"
            ],
            "311": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "312": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "313": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "314": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "315": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "316": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "317": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "318": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "319": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "320": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "321": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "322": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "323": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "324": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "325": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "326": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ],
            "327": [
                "BCryptSHA256PasswordHasher",
                "verify"
            ]
        },
        "addLocation": []
    }
}