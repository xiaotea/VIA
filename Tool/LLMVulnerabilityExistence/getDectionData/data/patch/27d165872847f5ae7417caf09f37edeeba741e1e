{
    "mobsf/MobSF/init.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VERSION = '4.2.8'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+VERSION = '4.2.9'"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " BANNER = r\"\"\""
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "   __  __       _    ____  _____       _  _    ____  "
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "  |  \\/  | ___ | |__/ ___||  ___|_   _| || |  |___ \\ "
            }
        },
        "frontPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "import threading",
            "from hashlib import sha256",
            "from pathlib import Path",
            "from importlib import (",
            "    machinery,",
            "    util,",
            ")",
            "",
            "from mobsf.MobSF.tools_download import install_jadx",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '4.2.8'",
            "BANNER = r\"\"\"",
            "  __  __       _    ____  _____       _  _    ____  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _| || |  |___ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / || |_   __) |",
            " | |  | | (_) | |_) |__) |  _|  \\ V /|__   _| / __/ ",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/    |_|(_)_____|",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    base_dir = Path(base_dir)",
            "    mobsf_home = Path(mobsf_home)",
            "    secret_file = Path(secret_file)",
            "    if os.getenv('MOBSF_SECRET_KEY'):",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif secret_file.exists() and secret_file.is_file():",
            "        secret_key = secret_file.read_text().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret_file.write_text(secret_key)",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Install JADX",
            "        thread = threading.Thread(",
            "            target=install_jadx,",
            "            name='install_jadx',",
            "            args=(mobsf_home.as_posix(),))",
            "        thread.start()",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home.as_posix())",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = mobsf_home / 'config.py'",
            "        if not config_path.exists():",
            "            sample_conf = base_dir / 'MobSF' / 'settings.py'",
            "            dat = sample_conf.read_text().splitlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = '\\n'.join(config)",
            "            config_path.write_text(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = base_dir.parent / 'manage.py'",
            "    if manage.exists() and manage.is_file():",
            "        # Bail out for package",
            "        return",
            "    print(manage)",
            "    args = [sys.executable, manage.as_posix()]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "        django_operation(['create_roles'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        base_dir = Path(base_dir)",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = Path.home() / '.MobSF'",
            "            custom_home = os.getenv('MOBSF_HOME_DIR')",
            "            if custom_home:",
            "                p = Path(custom_home)",
            "                if p.exists() and p.is_absolute() and p.is_dir():",
            "                    mobsf_home = p",
            "            # MobSF Home Directory",
            "            if not mobsf_home.exists():",
            "                mobsf_home.mkdir(parents=True, exist_ok=True)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = mobsf_home / 'downloads'",
            "        dwd_dir.mkdir(parents=True, exist_ok=True)",
            "        # Screenshot Directory",
            "        screen_dir = mobsf_home / 'screen'",
            "        screen_dir.mkdir(parents=True, exist_ok=True)",
            "        # Upload Directory",
            "        upload_dir = mobsf_home / 'uploads'",
            "        upload_dir.mkdir(parents=True, exist_ok=True)",
            "        # Downloaded tools",
            "        downloaded_tools_dir = mobsf_home / 'tools'",
            "        downloaded_tools_dir.mkdir(parents=True, exist_ok=True)",
            "        # Signatures Directory",
            "        sig_dir = mobsf_home / 'signatures'",
            "        sig_dir.mkdir(parents=True, exist_ok=True)",
            "        if use_home:",
            "            src = Path(base_dir) / 'signatures'",
            "            try:",
            "                shutil.copytree(src, sig_dir, dirs_exist_ok=True)",
            "            except Exception:",
            "                pass",
            "        return mobsf_home.as_posix()",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION}'",
            "",
            "",
            "def load_source(modname, filename):",
            "    loader = machinery.SourceFileLoader(modname, filename)",
            "    spec = util.spec_from_file_location(modname, filename, loader=loader)",
            "    module = util.module_from_spec(spec)",
            "    loader.exec_module(module)",
            "    return module",
            "",
            "",
            "def get_docker_secret_by_file(secret_key):",
            "    try:",
            "        secret_path = os.environ.get(secret_key)",
            "        path = Path(secret_path)",
            "        if path.exists() and path.is_file():",
            "            return path.read_text().strip()",
            "    except Exception:",
            "        logger.exception('Cannot read secret from %s', secret_path)",
            "    raise Exception('Cannot read secret from file')",
            "",
            "",
            "def get_secret_from_file_or_env(env_secret_key):",
            "    docker_secret_key = f'{env_secret_key}_FILE'",
            "    if os.environ.get(docker_secret_key):",
            "        return get_docker_secret_by_file(docker_secret_key)",
            "    else:",
            "        return os.environ[env_secret_key]",
            "",
            "",
            "def api_key(home_dir):",
            "    \"\"\"Print REST API Key.\"\"\"",
            "    # Form Docker Secrets",
            "    if os.environ.get('MOBSF_API_KEY_FILE'):",
            "        logger.info('\\nAPI Key read from docker secrets')",
            "        try:",
            "            return get_docker_secret_by_file('MOBSF_API_KEY_FILE')",
            "        except Exception:",
            "            logger.exception('Cannot read API Key from docker secrets')",
            "    # From Environment Variable",
            "    if os.environ.get('MOBSF_API_KEY'):",
            "        logger.info('\\nAPI Key read from environment variable')",
            "        return os.environ['MOBSF_API_KEY']",
            "    home_dir = Path(home_dir)",
            "    secret_file = home_dir / 'secret'",
            "    if secret_file.exists() and secret_file.is_file():",
            "        try:",
            "            _api_key = secret_file.read_bytes().strip()",
            "            return sha256(_api_key).hexdigest()",
            "        except Exception:",
            "            logger.exception('Cannot Read API Key')",
            "    return None"
        ],
        "afterPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "import threading",
            "from hashlib import sha256",
            "from pathlib import Path",
            "from importlib import (",
            "    machinery,",
            "    util,",
            ")",
            "",
            "from mobsf.MobSF.tools_download import install_jadx",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '4.2.9'",
            "BANNER = r\"\"\"",
            "  __  __       _    ____  _____       _  _    ____  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _| || |  |___ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / || |_   __) |",
            " | |  | | (_) | |_) |__) |  _|  \\ V /|__   _| / __/ ",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/    |_|(_)_____|",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    base_dir = Path(base_dir)",
            "    mobsf_home = Path(mobsf_home)",
            "    secret_file = Path(secret_file)",
            "    if os.getenv('MOBSF_SECRET_KEY'):",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif secret_file.exists() and secret_file.is_file():",
            "        secret_key = secret_file.read_text().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret_file.write_text(secret_key)",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Install JADX",
            "        thread = threading.Thread(",
            "            target=install_jadx,",
            "            name='install_jadx',",
            "            args=(mobsf_home.as_posix(),))",
            "        thread.start()",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home.as_posix())",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = mobsf_home / 'config.py'",
            "        if not config_path.exists():",
            "            sample_conf = base_dir / 'MobSF' / 'settings.py'",
            "            dat = sample_conf.read_text().splitlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = '\\n'.join(config)",
            "            config_path.write_text(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = base_dir.parent / 'manage.py'",
            "    if manage.exists() and manage.is_file():",
            "        # Bail out for package",
            "        return",
            "    print(manage)",
            "    args = [sys.executable, manage.as_posix()]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "        django_operation(['create_roles'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        base_dir = Path(base_dir)",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = Path.home() / '.MobSF'",
            "            custom_home = os.getenv('MOBSF_HOME_DIR')",
            "            if custom_home:",
            "                p = Path(custom_home)",
            "                if p.exists() and p.is_absolute() and p.is_dir():",
            "                    mobsf_home = p",
            "            # MobSF Home Directory",
            "            if not mobsf_home.exists():",
            "                mobsf_home.mkdir(parents=True, exist_ok=True)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = mobsf_home / 'downloads'",
            "        dwd_dir.mkdir(parents=True, exist_ok=True)",
            "        # Screenshot Directory",
            "        screen_dir = mobsf_home / 'screen'",
            "        screen_dir.mkdir(parents=True, exist_ok=True)",
            "        # Upload Directory",
            "        upload_dir = mobsf_home / 'uploads'",
            "        upload_dir.mkdir(parents=True, exist_ok=True)",
            "        # Downloaded tools",
            "        downloaded_tools_dir = mobsf_home / 'tools'",
            "        downloaded_tools_dir.mkdir(parents=True, exist_ok=True)",
            "        # Signatures Directory",
            "        sig_dir = mobsf_home / 'signatures'",
            "        sig_dir.mkdir(parents=True, exist_ok=True)",
            "        if use_home:",
            "            src = Path(base_dir) / 'signatures'",
            "            try:",
            "                shutil.copytree(src, sig_dir, dirs_exist_ok=True)",
            "            except Exception:",
            "                pass",
            "        return mobsf_home.as_posix()",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION}'",
            "",
            "",
            "def load_source(modname, filename):",
            "    loader = machinery.SourceFileLoader(modname, filename)",
            "    spec = util.spec_from_file_location(modname, filename, loader=loader)",
            "    module = util.module_from_spec(spec)",
            "    loader.exec_module(module)",
            "    return module",
            "",
            "",
            "def get_docker_secret_by_file(secret_key):",
            "    try:",
            "        secret_path = os.environ.get(secret_key)",
            "        path = Path(secret_path)",
            "        if path.exists() and path.is_file():",
            "            return path.read_text().strip()",
            "    except Exception:",
            "        logger.exception('Cannot read secret from %s', secret_path)",
            "    raise Exception('Cannot read secret from file')",
            "",
            "",
            "def get_secret_from_file_or_env(env_secret_key):",
            "    docker_secret_key = f'{env_secret_key}_FILE'",
            "    if os.environ.get(docker_secret_key):",
            "        return get_docker_secret_by_file(docker_secret_key)",
            "    else:",
            "        return os.environ[env_secret_key]",
            "",
            "",
            "def api_key(home_dir):",
            "    \"\"\"Print REST API Key.\"\"\"",
            "    # Form Docker Secrets",
            "    if os.environ.get('MOBSF_API_KEY_FILE'):",
            "        logger.info('\\nAPI Key read from docker secrets')",
            "        try:",
            "            return get_docker_secret_by_file('MOBSF_API_KEY_FILE')",
            "        except Exception:",
            "            logger.exception('Cannot read API Key from docker secrets')",
            "    # From Environment Variable",
            "    if os.environ.get('MOBSF_API_KEY'):",
            "        logger.info('\\nAPI Key read from environment variable')",
            "        return os.environ['MOBSF_API_KEY']",
            "    home_dir = Path(home_dir)",
            "    secret_file = home_dir / 'secret'",
            "    if secret_file.exists() and secret_file.is_file():",
            "        try:",
            "            _api_key = secret_file.read_bytes().strip()",
            "            return sha256(_api_key).hexdigest()",
            "        except Exception:",
            "            logger.exception('Cannot Read API Key')",
            "    return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [
                "VERSION"
            ]
        },
        "addLocation": []
    },
    "mobsf/MobSF/views/home.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         request = self.request"
            },
            "1": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         scanning = Scanning(request)"
            },
            "2": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         content_type = self.file.content_type"
            },
            "3": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file_name = self.file.name"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        file_name = sanitize_filename(self.file.name)"
            },
            "5": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         logger.info('MIME Type: %s FILE: %s', content_type, file_name)"
            },
            "6": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         if self.file_type.is_apk():"
            },
            "7": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             return scanning.scan_apk()"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"MobSF File Upload and Home Routes.\"\"\"",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import shutil",
            "from pathlib import Path",
            "from datetime import timedelta",
            "from wsgiref.util import FileWrapper",
            "",
            "from django.conf import settings",
            "from django.utils.timezone import now",
            "from django.core.paginator import Paginator",
            "from django.http import HttpResponse, HttpResponseRedirect",
            "from django.views.decorators.http import require_http_methods",
            "from django.utils import timezone",
            "from django.shortcuts import (",
            "    redirect,",
            "    render,",
            ")",
            "from django.template.defaulttags import register",
            "",
            "from mobsf.MobSF.forms import FormUtil, UploadFileForm",
            "from mobsf.MobSF.utils import (",
            "    MD5_REGEX,",
            "    get_md5,",
            "    is_dir_exists,",
            "    is_file_exists,",
            "    is_md5,",
            "    is_safe_path,",
            "    key,",
            "    print_n_send_error_response,",
            "    python_dict,",
            ")",
            "from mobsf.MobSF.init import api_key",
            "from mobsf.MobSF.security import sanitize_filename",
            "from mobsf.MobSF.views.helpers import FileType",
            "from mobsf.MobSF.views.scanning import Scanning",
            "from mobsf.MobSF.views.apk_downloader import apk_download",
            "from mobsf.StaticAnalyzer.models import (",
            "    EnqueuedTask,",
            "    RecentScansDB,",
            "    StaticAnalyzerAndroid,",
            "    StaticAnalyzerIOS,",
            "    StaticAnalyzerWindows,",
            ")",
            "from mobsf.DynamicAnalyzer.views.common.shared import (",
            "    invalid_params,",
            "    send_response,",
            ")",
            "from mobsf.MobSF.views.authentication import (",
            "    login_required,",
            ")",
            "from mobsf.MobSF.views.authorization import (",
            "    MAINTAINER_GROUP,",
            "    Permissions,",
            "    permission_required,",
            ")",
            "",
            "LINUX_PLATFORM = ['Darwin', 'Linux']",
            "HTTP_BAD_REQUEST = 400",
            "HTTP_STATUS_404 = 404",
            "HTTP_SERVER_ERROR = 500",
            "logger = logging.getLogger(__name__)",
            "register.filter('key', key)",
            "",
            "",
            "@login_required",
            "def index(request):",
            "    \"\"\"Index Route.\"\"\"",
            "    mimes = (settings.APK_MIME",
            "             + settings.IPA_MIME",
            "             + settings.ZIP_MIME",
            "             + settings.APPX_MIME)",
            "    exts = (settings.ANDROID_EXTS",
            "            + settings.IOS_EXTS",
            "            + settings.WINDOWS_EXTS)",
            "    context = {",
            "        'version': settings.MOBSF_VER,",
            "        'mimes': mimes,",
            "        'exts': '|'.join(exts),",
            "    }",
            "    template = 'general/home.html'",
            "    return render(request, template, context)",
            "",
            "",
            "class Upload(object):",
            "    \"\"\"Handle File Upload based on App type.\"\"\"",
            "",
            "    def __init__(self, request):",
            "        self.request = request",
            "        self.form = UploadFileForm(request.POST, request.FILES)",
            "        self.file_type = None",
            "        self.file = None",
            "",
            "    @staticmethod",
            "    @login_required",
            "    @permission_required(Permissions.SCAN)",
            "    def as_view(request):",
            "        upload = Upload(request)",
            "        return upload.upload_html()",
            "",
            "    def resp_json(self, data):",
            "        resp = HttpResponse(json.dumps(data),",
            "                            content_type='application/json; charset=utf-8')",
            "        resp['Access-Control-Allow-Origin'] = '*'",
            "        return resp",
            "",
            "    def upload_html(self):",
            "        request = self.request",
            "        response_data = {",
            "            'description': '',",
            "            'status': 'error',",
            "        }",
            "        if request.method != 'POST':",
            "            msg = 'Method not Supported!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        if not self.form.is_valid():",
            "            msg = 'Invalid Form Data!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        self.file = request.FILES['file']",
            "        self.file_type = FileType(self.file)",
            "        if not self.file_type.is_allow_file():",
            "            msg = 'File format not Supported!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        if self.file_type.is_ipa():",
            "            if platform.system() not in LINUX_PLATFORM:",
            "                msg = 'Static Analysis of iOS IPA requires Mac or Linux'",
            "                logger.error(msg)",
            "                response_data['description'] = msg",
            "                return self.resp_json(response_data)",
            "",
            "        response_data = self.upload()",
            "        return self.resp_json(response_data)",
            "",
            "    def upload_api(self):",
            "        \"\"\"API File Upload.\"\"\"",
            "        api_response = {}",
            "        request = self.request",
            "        if not self.form.is_valid():",
            "            api_response['error'] = FormUtil.errors_message(self.form)",
            "            return api_response, HTTP_BAD_REQUEST",
            "        self.file = request.FILES['file']",
            "        self.file_type = FileType(self.file)",
            "        if not self.file_type.is_allow_file():",
            "            api_response['error'] = 'File format not Supported!'",
            "            return api_response, HTTP_BAD_REQUEST",
            "        api_response = self.upload()",
            "        return api_response, 200",
            "",
            "    def upload(self):",
            "        request = self.request",
            "        scanning = Scanning(request)",
            "        content_type = self.file.content_type",
            "        file_name = self.file.name",
            "        logger.info('MIME Type: %s FILE: %s', content_type, file_name)",
            "        if self.file_type.is_apk():",
            "            return scanning.scan_apk()",
            "        elif self.file_type.is_xapk():",
            "            return scanning.scan_xapk()",
            "        elif self.file_type.is_apks():",
            "            return scanning.scan_apks()",
            "        elif self.file_type.is_aab():",
            "            return scanning.scan_aab()",
            "        elif self.file_type.is_jar():",
            "            return scanning.scan_jar()",
            "        elif self.file_type.is_aar():",
            "            return scanning.scan_aar()",
            "        elif self.file_type.is_so():",
            "            return scanning.scan_so()",
            "        elif self.file_type.is_zip():",
            "            return scanning.scan_zip()",
            "        elif self.file_type.is_ipa():",
            "            return scanning.scan_ipa()",
            "        elif self.file_type.is_dylib():",
            "            return scanning.scan_dylib()",
            "        elif self.file_type.is_a():",
            "            return scanning.scan_a()",
            "        elif self.file_type.is_appx():",
            "            return scanning.scan_appx()",
            "",
            "",
            "@login_required",
            "def api_docs(request):",
            "    \"\"\"Api Docs Route.\"\"\"",
            "    key = '*******'",
            "    try:",
            "        if (settings.DISABLE_AUTHENTICATION == '1'",
            "                or request.user.is_staff",
            "                or request.user.groups.filter(name=MAINTAINER_GROUP).exists()):",
            "            key = api_key(settings.MOBSF_HOME)",
            "    except Exception:",
            "        logger.exception('[ERROR] Failed to get API key')",
            "    context = {",
            "        'title': 'API Docs',",
            "        'api_key': key,",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/apidocs.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def about(request):",
            "    \"\"\"About Route.\"\"\"",
            "    context = {",
            "        'title': 'About',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/about.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def donate(request):",
            "    \"\"\"Donate Route.\"\"\"",
            "    context = {",
            "        'title': 'Donate',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/donate.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def error(request):",
            "    \"\"\"Error Route.\"\"\"",
            "    context = {",
            "        'title': 'Error',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/error.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def zip_format(request):",
            "    \"\"\"Zip Format Message Route.\"\"\"",
            "    context = {",
            "        'title': 'Zipped Source Instruction',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/zip.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def robots_txt(request):",
            "    content = 'User-agent: *\\nDisallow: /*/\\nAllow: /*\\n'",
            "    return HttpResponse(content, content_type='text/plain')",
            "",
            "",
            "@login_required",
            "def dynamic_analysis(request):",
            "    \"\"\"Dynamic Analysis Landing.\"\"\"",
            "    context = {",
            "        'title': 'Dynamic Analysis',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/dynamic.html'",
            "    return render(request, template, context)",
            "",
            "",
            "@login_required",
            "def recent_scans(request, page_size=10, page_number=1):",
            "    \"\"\"Show Recent Scans Route.\"\"\"",
            "    entries = []",
            "    paginator = Paginator(",
            "        RecentScansDB.objects.all().order_by('-TIMESTAMP').values(), page_size)",
            "    page_obj = paginator.get_page(page_number)",
            "    page_obj.page_size = page_size",
            "    md5_list = [i['MD5'] for i in page_obj]",
            "",
            "    android = StaticAnalyzerAndroid.objects.filter(",
            "        MD5__in=md5_list).only(",
            "            'PACKAGE_NAME', 'VERSION_NAME', 'FILE_NAME', 'MD5')",
            "    ios = StaticAnalyzerIOS.objects.filter(",
            "        MD5__in=md5_list).only('FILE_NAME', 'MD5')",
            "",
            "    updir = Path(settings.UPLD_DIR)",
            "    icon_mapping = {}",
            "    package_mapping = {}",
            "    for item in android:",
            "        package_mapping[item.MD5] = item.PACKAGE_NAME",
            "        icon_mapping[item.MD5] = item.ICON_PATH",
            "    for item in ios:",
            "        icon_mapping[item.MD5] = item.ICON_PATH",
            "",
            "    for entry in page_obj:",
            "        if entry['MD5'] in package_mapping.keys():",
            "            entry['PACKAGE'] = package_mapping[entry['MD5']]",
            "        else:",
            "            entry['PACKAGE'] = ''",
            "        entry['ICON_PATH'] = icon_mapping.get(entry['MD5'], '')",
            "",
            "        if entry['FILE_NAME'].endswith('.ipa'):",
            "            entry['BUNDLE_HASH'] = get_md5(",
            "                entry['PACKAGE_NAME'].encode('utf-8'))",
            "            report_file = updir / entry['BUNDLE_HASH'] / 'mobsf_dump_file.txt'",
            "        else:",
            "            report_file = updir / entry['MD5'] / 'logcat.txt'",
            "        entry['DYNAMIC_REPORT_EXISTS'] = report_file.exists()",
            "        entries.append(entry)",
            "    context = {",
            "        'title': 'Recent Scans',",
            "        'entries': entries,",
            "        'version': settings.MOBSF_VER,",
            "        'page_obj': page_obj,",
            "        'async_scans': settings.ASYNC_ANALYSIS,",
            "    }",
            "    template = 'general/recent.html'",
            "    return render(request, template, context)",
            "",
            "",
            "@login_required",
            "@permission_required(Permissions.SCAN)",
            "def download_apk(request):",
            "    \"\"\"Download and APK by package name.\"\"\"",
            "    package = request.POST['package']",
            "    # Package validated in apk_download()",
            "    context = {",
            "        'status': 'failed',",
            "        'description': 'Unable to download APK',",
            "    }",
            "    res = apk_download(package)",
            "    if res:",
            "        context = res",
            "        context['status'] = 'ok'",
            "        context['package'] = package",
            "    resp = HttpResponse(",
            "        json.dumps(context),",
            "        content_type='application/json; charset=utf-8')",
            "    return resp",
            "",
            "",
            "@login_required",
            "def search(request, api=False):",
            "    \"\"\"Search scan by checksum or text.\"\"\"",
            "    if request.method == 'POST':",
            "        query = request.POST['query']",
            "    else:",
            "        query = request.GET['query']",
            "",
            "    if not query:",
            "        msg = 'No search query provided.'",
            "        return print_n_send_error_response(request, msg, api)",
            "",
            "    checksum = query if re.match(MD5_REGEX, query) else find_checksum(query)",
            "",
            "    if checksum and re.match(MD5_REGEX, checksum):",
            "        db_obj = RecentScansDB.objects.filter(MD5=checksum).first()",
            "        if db_obj:",
            "            url = f'/{db_obj.ANALYZER}/{db_obj.MD5}/'",
            "            if api:",
            "                return {'checksum': db_obj.MD5}",
            "            else:",
            "                return HttpResponseRedirect(url)",
            "",
            "    msg = 'You can search by MD5, app name, package name, or file name.'",
            "    return print_n_send_error_response(request, msg, api, 'Scan not found')",
            "",
            "",
            "def find_checksum(query):",
            "    \"\"\"Get the first matching checksum from the database.\"\"\"",
            "    search_fields = ['FILE_NAME', 'PACKAGE_NAME', 'APP_NAME']",
            "",
            "    for field in search_fields:",
            "        result = RecentScansDB.objects.filter(",
            "            **{f'{field}__icontains': query}).first()",
            "        if result:",
            "            return result.MD5",
            "",
            "    return None",
            "",
            "# AJAX",
            "",
            "",
            "@login_required",
            "@require_http_methods(['POST'])",
            "def scan_status(request, api=False):",
            "    \"\"\"Get Current Status of a scan in progress.\"\"\"",
            "    try:",
            "        scan_hash = request.POST['hash']",
            "        if not is_md5(scan_hash):",
            "            return invalid_params(api)",
            "        robj = RecentScansDB.objects.filter(MD5=scan_hash)",
            "        if not robj.exists():",
            "            data = {'status': 'failed', 'error': 'scan hash not found'}",
            "            return send_response(data, api)",
            "        data = {'status': 'ok', 'logs': python_dict(robj[0].SCAN_LOGS)}",
            "    except Exception as exp:",
            "        logger.exception('Fetching Scan Status')",
            "        data = {'status': 'failed', 'message': str(exp)}",
            "    return send_response(data, api)",
            "",
            "",
            "def file_download(dwd_file, filename, content_type):",
            "    \"\"\"HTTP file download response.\"\"\"",
            "    with open(dwd_file, 'rb') as file:",
            "        wrapper = FileWrapper(file)",
            "        response = HttpResponse(wrapper, content_type=content_type)",
            "        response['Content-Length'] = dwd_file.stat().st_size",
            "        if filename:",
            "            val = f'attachment; filename=\"{filename}\"'",
            "            response['Content-Disposition'] = val",
            "        return response",
            "",
            "",
            "@login_required",
            "@require_http_methods(['GET'])",
            "def download_binary(request, checksum, api=False):",
            "    \"\"\"Download binary from uploads directory.\"\"\"",
            "    try:",
            "        allowed_exts = settings.ALLOWED_EXTENSIONS",
            "        if not is_md5(checksum):",
            "            return HttpResponse(",
            "                'Invalid MD5 Hash',",
            "                status=HTTP_STATUS_404)",
            "        robj = RecentScansDB.objects.filter(MD5=checksum).first()",
            "        if not robj:",
            "            return HttpResponse(",
            "                'Scan hash not found',",
            "                status=HTTP_STATUS_404)",
            "        file_ext = f'.{robj.SCAN_TYPE}'",
            "        if file_ext not in allowed_exts.keys():",
            "            return HttpResponse(",
            "                'Invalid Scan Type',",
            "                status=HTTP_STATUS_404)",
            "        filename = f'{checksum}{file_ext}'",
            "        dwd_file = Path(settings.UPLD_DIR) / checksum / filename",
            "        if not dwd_file.exists():",
            "            return HttpResponse(",
            "                'File not found',",
            "                status=HTTP_STATUS_404)",
            "        return file_download(",
            "            dwd_file,",
            "            sanitize_filename(robj.FILE_NAME),",
            "            allowed_exts[file_ext])",
            "    except Exception:",
            "        logger.exception('Download Binary Failed')",
            "        return HttpResponse(",
            "            'Failed to download file due to an error',",
            "            status=HTTP_SERVER_ERROR)",
            "",
            "",
            "@login_required",
            "@require_http_methods(['GET'])",
            "def download(request):",
            "    \"\"\"Download from mobsf downloads directory.\"\"\"",
            "    root = settings.DWD_DIR",
            "    filename = request.path.replace('/download/', '', 1)",
            "    dwd_file = Path(root) / filename",
            "",
            "    # Security Checks",
            "    if '../' in filename or not is_safe_path(root, dwd_file):",
            "        msg = 'Path Traversal Attack Detected'",
            "        return print_n_send_error_response(request, msg)",
            "",
            "    # File and Extension Check",
            "    ext = dwd_file.suffix",
            "    allowed_exts = settings.ALLOWED_EXTENSIONS",
            "    if ext in allowed_exts and dwd_file.is_file():",
            "        return file_download(",
            "            dwd_file,",
            "            None,",
            "            allowed_exts[ext])",
            "",
            "    # Special Case for Certain Image Files",
            "    if filename.endswith(('screen/screen.png', '-icon.png')):",
            "        return HttpResponse('')",
            "",
            "    return HttpResponse(status=HTTP_STATUS_404)",
            "",
            "",
            "@login_required",
            "def generate_download(request):",
            "    \"\"\"Generate downloads for smali/java zip.\"\"\"",
            "    try:",
            "        logger.info('Generating Downloads')",
            "        md5 = request.GET['hash']",
            "        file_type = request.GET['file_type']",
            "        if (not is_md5(md5)",
            "                or file_type not in ('smali', 'java')):",
            "            msg = 'Invalid download type or hash'",
            "            logger.exception(msg)",
            "            return print_n_send_error_response(request, msg)",
            "        app_dir = Path(settings.UPLD_DIR) / md5",
            "        dwd_dir = Path(settings.DWD_DIR)",
            "        file_name = ''",
            "        if file_type == 'java':",
            "            # For Java zipped source code",
            "            directory = app_dir / 'java_source'",
            "            dwd_file = dwd_dir / f'{md5}-java'",
            "            shutil.make_archive(",
            "                dwd_file.as_posix(), 'zip', directory.as_posix())",
            "            file_name = f'{md5}-java.zip'",
            "        elif file_type == 'smali':",
            "            # For Smali zipped source code",
            "            directory = app_dir / 'smali_source'",
            "            dwd_file = dwd_dir / f'{md5}-smali'",
            "            shutil.make_archive(",
            "                dwd_file.as_posix(), 'zip', directory.as_posix())",
            "            file_name = f'{md5}-smali.zip'",
            "        return redirect(f'/download/{file_name}')",
            "    except Exception:",
            "        msg = 'Generating Downloads'",
            "        logger.exception(msg)",
            "        return print_n_send_error_response(request, msg)",
            "",
            "",
            "@login_required",
            "@permission_required(Permissions.DELETE)",
            "@require_http_methods(['POST'])",
            "def delete_scan(request, api=False):",
            "    \"\"\"Delete Scan from DB and remove the scan related files.\"\"\"",
            "    try:",
            "        if api:",
            "            md5_hash = request.POST['hash']",
            "        else:",
            "            md5_hash = request.POST['md5']",
            "",
            "        if not re.match(MD5_REGEX, md5_hash):",
            "            return send_response({'deleted': 'Invalid scan hash'}, api)",
            "",
            "        # Delete DB Entries",
            "        scan = RecentScansDB.objects.filter(MD5=md5_hash)",
            "        if not scan.exists():",
            "            return send_response({'deleted': 'Scan not found in Database'}, api)",
            "        if settings.ASYNC_ANALYSIS:",
            "            # Handle Async Tasks",
            "            et = EnqueuedTask.objects.filter(checksum=md5_hash).first()",
            "            if et:",
            "                max_time_passed = now() - et.created_at > timedelta(",
            "                    minutes=settings.ASYNC_ANALYSIS_TIMEOUT)",
            "                if not (et.completed_at or max_time_passed):",
            "                    # Queue is in progress, cannot delete the task",
            "                    return send_response(",
            "                        {'deleted': 'A scan can only be deleted after it is completed'},",
            "                        api)",
            "        # Delete all related DB entries",
            "        EnqueuedTask.objects.filter(checksum=md5_hash).all().delete()",
            "        RecentScansDB.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerAndroid.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerIOS.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerWindows.objects.filter(MD5=md5_hash).delete()",
            "        # Delete Upload Dir Contents",
            "        app_upload_dir = os.path.join(settings.UPLD_DIR, md5_hash)",
            "        if is_dir_exists(app_upload_dir):",
            "            shutil.rmtree(app_upload_dir)",
            "        # Delete Download Dir Contents",
            "        dw_dir = settings.DWD_DIR",
            "        for item in os.listdir(dw_dir):",
            "            item_path = os.path.join(dw_dir, item)",
            "            valid_item = item.startswith(md5_hash + '-')",
            "            # Delete all related files",
            "            if is_file_exists(item_path) and valid_item:",
            "                os.remove(item_path)",
            "            # Delete related directories",
            "            if is_dir_exists(item_path) and valid_item:",
            "                shutil.rmtree(item_path, ignore_errors=True)",
            "        return send_response({'deleted': 'yes'}, api)",
            "    except Exception as exp:",
            "        msg = str(exp)",
            "        exp_doc = exp.__doc__",
            "        return print_n_send_error_response(request, msg, api, exp_doc)",
            "",
            "",
            "class RecentScans(object):",
            "",
            "    def __init__(self, request):",
            "        self.request = request",
            "",
            "    def recent_scans(self):",
            "        page = self.request.GET.get('page', 1)",
            "        page_size = self.request.GET.get('page_size', 10)",
            "        result = RecentScansDB.objects.all().values().order_by('-TIMESTAMP')",
            "        try:",
            "            paginator = Paginator(result, page_size)",
            "            content = paginator.page(page)",
            "            data = {",
            "                'content': list(content),",
            "                'count': paginator.count,",
            "                'num_pages': paginator.num_pages,",
            "            }",
            "        except Exception as exp:",
            "            data = {'error': str(exp)}",
            "        return data",
            "",
            "",
            "def update_scan_timestamp(scan_hash):",
            "    # Update the last scan time.",
            "    tms = timezone.now()",
            "    RecentScansDB.objects.filter(MD5=scan_hash).update(TIMESTAMP=tms)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"MobSF File Upload and Home Routes.\"\"\"",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import shutil",
            "from pathlib import Path",
            "from datetime import timedelta",
            "from wsgiref.util import FileWrapper",
            "",
            "from django.conf import settings",
            "from django.utils.timezone import now",
            "from django.core.paginator import Paginator",
            "from django.http import HttpResponse, HttpResponseRedirect",
            "from django.views.decorators.http import require_http_methods",
            "from django.utils import timezone",
            "from django.shortcuts import (",
            "    redirect,",
            "    render,",
            ")",
            "from django.template.defaulttags import register",
            "",
            "from mobsf.MobSF.forms import FormUtil, UploadFileForm",
            "from mobsf.MobSF.utils import (",
            "    MD5_REGEX,",
            "    get_md5,",
            "    is_dir_exists,",
            "    is_file_exists,",
            "    is_md5,",
            "    is_safe_path,",
            "    key,",
            "    print_n_send_error_response,",
            "    python_dict,",
            ")",
            "from mobsf.MobSF.init import api_key",
            "from mobsf.MobSF.security import sanitize_filename",
            "from mobsf.MobSF.views.helpers import FileType",
            "from mobsf.MobSF.views.scanning import Scanning",
            "from mobsf.MobSF.views.apk_downloader import apk_download",
            "from mobsf.StaticAnalyzer.models import (",
            "    EnqueuedTask,",
            "    RecentScansDB,",
            "    StaticAnalyzerAndroid,",
            "    StaticAnalyzerIOS,",
            "    StaticAnalyzerWindows,",
            ")",
            "from mobsf.DynamicAnalyzer.views.common.shared import (",
            "    invalid_params,",
            "    send_response,",
            ")",
            "from mobsf.MobSF.views.authentication import (",
            "    login_required,",
            ")",
            "from mobsf.MobSF.views.authorization import (",
            "    MAINTAINER_GROUP,",
            "    Permissions,",
            "    permission_required,",
            ")",
            "",
            "LINUX_PLATFORM = ['Darwin', 'Linux']",
            "HTTP_BAD_REQUEST = 400",
            "HTTP_STATUS_404 = 404",
            "HTTP_SERVER_ERROR = 500",
            "logger = logging.getLogger(__name__)",
            "register.filter('key', key)",
            "",
            "",
            "@login_required",
            "def index(request):",
            "    \"\"\"Index Route.\"\"\"",
            "    mimes = (settings.APK_MIME",
            "             + settings.IPA_MIME",
            "             + settings.ZIP_MIME",
            "             + settings.APPX_MIME)",
            "    exts = (settings.ANDROID_EXTS",
            "            + settings.IOS_EXTS",
            "            + settings.WINDOWS_EXTS)",
            "    context = {",
            "        'version': settings.MOBSF_VER,",
            "        'mimes': mimes,",
            "        'exts': '|'.join(exts),",
            "    }",
            "    template = 'general/home.html'",
            "    return render(request, template, context)",
            "",
            "",
            "class Upload(object):",
            "    \"\"\"Handle File Upload based on App type.\"\"\"",
            "",
            "    def __init__(self, request):",
            "        self.request = request",
            "        self.form = UploadFileForm(request.POST, request.FILES)",
            "        self.file_type = None",
            "        self.file = None",
            "",
            "    @staticmethod",
            "    @login_required",
            "    @permission_required(Permissions.SCAN)",
            "    def as_view(request):",
            "        upload = Upload(request)",
            "        return upload.upload_html()",
            "",
            "    def resp_json(self, data):",
            "        resp = HttpResponse(json.dumps(data),",
            "                            content_type='application/json; charset=utf-8')",
            "        resp['Access-Control-Allow-Origin'] = '*'",
            "        return resp",
            "",
            "    def upload_html(self):",
            "        request = self.request",
            "        response_data = {",
            "            'description': '',",
            "            'status': 'error',",
            "        }",
            "        if request.method != 'POST':",
            "            msg = 'Method not Supported!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        if not self.form.is_valid():",
            "            msg = 'Invalid Form Data!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        self.file = request.FILES['file']",
            "        self.file_type = FileType(self.file)",
            "        if not self.file_type.is_allow_file():",
            "            msg = 'File format not Supported!'",
            "            logger.error(msg)",
            "            response_data['description'] = msg",
            "            return self.resp_json(response_data)",
            "",
            "        if self.file_type.is_ipa():",
            "            if platform.system() not in LINUX_PLATFORM:",
            "                msg = 'Static Analysis of iOS IPA requires Mac or Linux'",
            "                logger.error(msg)",
            "                response_data['description'] = msg",
            "                return self.resp_json(response_data)",
            "",
            "        response_data = self.upload()",
            "        return self.resp_json(response_data)",
            "",
            "    def upload_api(self):",
            "        \"\"\"API File Upload.\"\"\"",
            "        api_response = {}",
            "        request = self.request",
            "        if not self.form.is_valid():",
            "            api_response['error'] = FormUtil.errors_message(self.form)",
            "            return api_response, HTTP_BAD_REQUEST",
            "        self.file = request.FILES['file']",
            "        self.file_type = FileType(self.file)",
            "        if not self.file_type.is_allow_file():",
            "            api_response['error'] = 'File format not Supported!'",
            "            return api_response, HTTP_BAD_REQUEST",
            "        api_response = self.upload()",
            "        return api_response, 200",
            "",
            "    def upload(self):",
            "        request = self.request",
            "        scanning = Scanning(request)",
            "        content_type = self.file.content_type",
            "        file_name = sanitize_filename(self.file.name)",
            "        logger.info('MIME Type: %s FILE: %s', content_type, file_name)",
            "        if self.file_type.is_apk():",
            "            return scanning.scan_apk()",
            "        elif self.file_type.is_xapk():",
            "            return scanning.scan_xapk()",
            "        elif self.file_type.is_apks():",
            "            return scanning.scan_apks()",
            "        elif self.file_type.is_aab():",
            "            return scanning.scan_aab()",
            "        elif self.file_type.is_jar():",
            "            return scanning.scan_jar()",
            "        elif self.file_type.is_aar():",
            "            return scanning.scan_aar()",
            "        elif self.file_type.is_so():",
            "            return scanning.scan_so()",
            "        elif self.file_type.is_zip():",
            "            return scanning.scan_zip()",
            "        elif self.file_type.is_ipa():",
            "            return scanning.scan_ipa()",
            "        elif self.file_type.is_dylib():",
            "            return scanning.scan_dylib()",
            "        elif self.file_type.is_a():",
            "            return scanning.scan_a()",
            "        elif self.file_type.is_appx():",
            "            return scanning.scan_appx()",
            "",
            "",
            "@login_required",
            "def api_docs(request):",
            "    \"\"\"Api Docs Route.\"\"\"",
            "    key = '*******'",
            "    try:",
            "        if (settings.DISABLE_AUTHENTICATION == '1'",
            "                or request.user.is_staff",
            "                or request.user.groups.filter(name=MAINTAINER_GROUP).exists()):",
            "            key = api_key(settings.MOBSF_HOME)",
            "    except Exception:",
            "        logger.exception('[ERROR] Failed to get API key')",
            "    context = {",
            "        'title': 'API Docs',",
            "        'api_key': key,",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/apidocs.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def about(request):",
            "    \"\"\"About Route.\"\"\"",
            "    context = {",
            "        'title': 'About',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/about.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def donate(request):",
            "    \"\"\"Donate Route.\"\"\"",
            "    context = {",
            "        'title': 'Donate',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/donate.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def error(request):",
            "    \"\"\"Error Route.\"\"\"",
            "    context = {",
            "        'title': 'Error',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/error.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def zip_format(request):",
            "    \"\"\"Zip Format Message Route.\"\"\"",
            "    context = {",
            "        'title': 'Zipped Source Instruction',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/zip.html'",
            "    return render(request, template, context)",
            "",
            "",
            "def robots_txt(request):",
            "    content = 'User-agent: *\\nDisallow: /*/\\nAllow: /*\\n'",
            "    return HttpResponse(content, content_type='text/plain')",
            "",
            "",
            "@login_required",
            "def dynamic_analysis(request):",
            "    \"\"\"Dynamic Analysis Landing.\"\"\"",
            "    context = {",
            "        'title': 'Dynamic Analysis',",
            "        'version': settings.MOBSF_VER,",
            "    }",
            "    template = 'general/dynamic.html'",
            "    return render(request, template, context)",
            "",
            "",
            "@login_required",
            "def recent_scans(request, page_size=10, page_number=1):",
            "    \"\"\"Show Recent Scans Route.\"\"\"",
            "    entries = []",
            "    paginator = Paginator(",
            "        RecentScansDB.objects.all().order_by('-TIMESTAMP').values(), page_size)",
            "    page_obj = paginator.get_page(page_number)",
            "    page_obj.page_size = page_size",
            "    md5_list = [i['MD5'] for i in page_obj]",
            "",
            "    android = StaticAnalyzerAndroid.objects.filter(",
            "        MD5__in=md5_list).only(",
            "            'PACKAGE_NAME', 'VERSION_NAME', 'FILE_NAME', 'MD5')",
            "    ios = StaticAnalyzerIOS.objects.filter(",
            "        MD5__in=md5_list).only('FILE_NAME', 'MD5')",
            "",
            "    updir = Path(settings.UPLD_DIR)",
            "    icon_mapping = {}",
            "    package_mapping = {}",
            "    for item in android:",
            "        package_mapping[item.MD5] = item.PACKAGE_NAME",
            "        icon_mapping[item.MD5] = item.ICON_PATH",
            "    for item in ios:",
            "        icon_mapping[item.MD5] = item.ICON_PATH",
            "",
            "    for entry in page_obj:",
            "        if entry['MD5'] in package_mapping.keys():",
            "            entry['PACKAGE'] = package_mapping[entry['MD5']]",
            "        else:",
            "            entry['PACKAGE'] = ''",
            "        entry['ICON_PATH'] = icon_mapping.get(entry['MD5'], '')",
            "",
            "        if entry['FILE_NAME'].endswith('.ipa'):",
            "            entry['BUNDLE_HASH'] = get_md5(",
            "                entry['PACKAGE_NAME'].encode('utf-8'))",
            "            report_file = updir / entry['BUNDLE_HASH'] / 'mobsf_dump_file.txt'",
            "        else:",
            "            report_file = updir / entry['MD5'] / 'logcat.txt'",
            "        entry['DYNAMIC_REPORT_EXISTS'] = report_file.exists()",
            "        entries.append(entry)",
            "    context = {",
            "        'title': 'Recent Scans',",
            "        'entries': entries,",
            "        'version': settings.MOBSF_VER,",
            "        'page_obj': page_obj,",
            "        'async_scans': settings.ASYNC_ANALYSIS,",
            "    }",
            "    template = 'general/recent.html'",
            "    return render(request, template, context)",
            "",
            "",
            "@login_required",
            "@permission_required(Permissions.SCAN)",
            "def download_apk(request):",
            "    \"\"\"Download and APK by package name.\"\"\"",
            "    package = request.POST['package']",
            "    # Package validated in apk_download()",
            "    context = {",
            "        'status': 'failed',",
            "        'description': 'Unable to download APK',",
            "    }",
            "    res = apk_download(package)",
            "    if res:",
            "        context = res",
            "        context['status'] = 'ok'",
            "        context['package'] = package",
            "    resp = HttpResponse(",
            "        json.dumps(context),",
            "        content_type='application/json; charset=utf-8')",
            "    return resp",
            "",
            "",
            "@login_required",
            "def search(request, api=False):",
            "    \"\"\"Search scan by checksum or text.\"\"\"",
            "    if request.method == 'POST':",
            "        query = request.POST['query']",
            "    else:",
            "        query = request.GET['query']",
            "",
            "    if not query:",
            "        msg = 'No search query provided.'",
            "        return print_n_send_error_response(request, msg, api)",
            "",
            "    checksum = query if re.match(MD5_REGEX, query) else find_checksum(query)",
            "",
            "    if checksum and re.match(MD5_REGEX, checksum):",
            "        db_obj = RecentScansDB.objects.filter(MD5=checksum).first()",
            "        if db_obj:",
            "            url = f'/{db_obj.ANALYZER}/{db_obj.MD5}/'",
            "            if api:",
            "                return {'checksum': db_obj.MD5}",
            "            else:",
            "                return HttpResponseRedirect(url)",
            "",
            "    msg = 'You can search by MD5, app name, package name, or file name.'",
            "    return print_n_send_error_response(request, msg, api, 'Scan not found')",
            "",
            "",
            "def find_checksum(query):",
            "    \"\"\"Get the first matching checksum from the database.\"\"\"",
            "    search_fields = ['FILE_NAME', 'PACKAGE_NAME', 'APP_NAME']",
            "",
            "    for field in search_fields:",
            "        result = RecentScansDB.objects.filter(",
            "            **{f'{field}__icontains': query}).first()",
            "        if result:",
            "            return result.MD5",
            "",
            "    return None",
            "",
            "# AJAX",
            "",
            "",
            "@login_required",
            "@require_http_methods(['POST'])",
            "def scan_status(request, api=False):",
            "    \"\"\"Get Current Status of a scan in progress.\"\"\"",
            "    try:",
            "        scan_hash = request.POST['hash']",
            "        if not is_md5(scan_hash):",
            "            return invalid_params(api)",
            "        robj = RecentScansDB.objects.filter(MD5=scan_hash)",
            "        if not robj.exists():",
            "            data = {'status': 'failed', 'error': 'scan hash not found'}",
            "            return send_response(data, api)",
            "        data = {'status': 'ok', 'logs': python_dict(robj[0].SCAN_LOGS)}",
            "    except Exception as exp:",
            "        logger.exception('Fetching Scan Status')",
            "        data = {'status': 'failed', 'message': str(exp)}",
            "    return send_response(data, api)",
            "",
            "",
            "def file_download(dwd_file, filename, content_type):",
            "    \"\"\"HTTP file download response.\"\"\"",
            "    with open(dwd_file, 'rb') as file:",
            "        wrapper = FileWrapper(file)",
            "        response = HttpResponse(wrapper, content_type=content_type)",
            "        response['Content-Length'] = dwd_file.stat().st_size",
            "        if filename:",
            "            val = f'attachment; filename=\"{filename}\"'",
            "            response['Content-Disposition'] = val",
            "        return response",
            "",
            "",
            "@login_required",
            "@require_http_methods(['GET'])",
            "def download_binary(request, checksum, api=False):",
            "    \"\"\"Download binary from uploads directory.\"\"\"",
            "    try:",
            "        allowed_exts = settings.ALLOWED_EXTENSIONS",
            "        if not is_md5(checksum):",
            "            return HttpResponse(",
            "                'Invalid MD5 Hash',",
            "                status=HTTP_STATUS_404)",
            "        robj = RecentScansDB.objects.filter(MD5=checksum).first()",
            "        if not robj:",
            "            return HttpResponse(",
            "                'Scan hash not found',",
            "                status=HTTP_STATUS_404)",
            "        file_ext = f'.{robj.SCAN_TYPE}'",
            "        if file_ext not in allowed_exts.keys():",
            "            return HttpResponse(",
            "                'Invalid Scan Type',",
            "                status=HTTP_STATUS_404)",
            "        filename = f'{checksum}{file_ext}'",
            "        dwd_file = Path(settings.UPLD_DIR) / checksum / filename",
            "        if not dwd_file.exists():",
            "            return HttpResponse(",
            "                'File not found',",
            "                status=HTTP_STATUS_404)",
            "        return file_download(",
            "            dwd_file,",
            "            sanitize_filename(robj.FILE_NAME),",
            "            allowed_exts[file_ext])",
            "    except Exception:",
            "        logger.exception('Download Binary Failed')",
            "        return HttpResponse(",
            "            'Failed to download file due to an error',",
            "            status=HTTP_SERVER_ERROR)",
            "",
            "",
            "@login_required",
            "@require_http_methods(['GET'])",
            "def download(request):",
            "    \"\"\"Download from mobsf downloads directory.\"\"\"",
            "    root = settings.DWD_DIR",
            "    filename = request.path.replace('/download/', '', 1)",
            "    dwd_file = Path(root) / filename",
            "",
            "    # Security Checks",
            "    if '../' in filename or not is_safe_path(root, dwd_file):",
            "        msg = 'Path Traversal Attack Detected'",
            "        return print_n_send_error_response(request, msg)",
            "",
            "    # File and Extension Check",
            "    ext = dwd_file.suffix",
            "    allowed_exts = settings.ALLOWED_EXTENSIONS",
            "    if ext in allowed_exts and dwd_file.is_file():",
            "        return file_download(",
            "            dwd_file,",
            "            None,",
            "            allowed_exts[ext])",
            "",
            "    # Special Case for Certain Image Files",
            "    if filename.endswith(('screen/screen.png', '-icon.png')):",
            "        return HttpResponse('')",
            "",
            "    return HttpResponse(status=HTTP_STATUS_404)",
            "",
            "",
            "@login_required",
            "def generate_download(request):",
            "    \"\"\"Generate downloads for smali/java zip.\"\"\"",
            "    try:",
            "        logger.info('Generating Downloads')",
            "        md5 = request.GET['hash']",
            "        file_type = request.GET['file_type']",
            "        if (not is_md5(md5)",
            "                or file_type not in ('smali', 'java')):",
            "            msg = 'Invalid download type or hash'",
            "            logger.exception(msg)",
            "            return print_n_send_error_response(request, msg)",
            "        app_dir = Path(settings.UPLD_DIR) / md5",
            "        dwd_dir = Path(settings.DWD_DIR)",
            "        file_name = ''",
            "        if file_type == 'java':",
            "            # For Java zipped source code",
            "            directory = app_dir / 'java_source'",
            "            dwd_file = dwd_dir / f'{md5}-java'",
            "            shutil.make_archive(",
            "                dwd_file.as_posix(), 'zip', directory.as_posix())",
            "            file_name = f'{md5}-java.zip'",
            "        elif file_type == 'smali':",
            "            # For Smali zipped source code",
            "            directory = app_dir / 'smali_source'",
            "            dwd_file = dwd_dir / f'{md5}-smali'",
            "            shutil.make_archive(",
            "                dwd_file.as_posix(), 'zip', directory.as_posix())",
            "            file_name = f'{md5}-smali.zip'",
            "        return redirect(f'/download/{file_name}')",
            "    except Exception:",
            "        msg = 'Generating Downloads'",
            "        logger.exception(msg)",
            "        return print_n_send_error_response(request, msg)",
            "",
            "",
            "@login_required",
            "@permission_required(Permissions.DELETE)",
            "@require_http_methods(['POST'])",
            "def delete_scan(request, api=False):",
            "    \"\"\"Delete Scan from DB and remove the scan related files.\"\"\"",
            "    try:",
            "        if api:",
            "            md5_hash = request.POST['hash']",
            "        else:",
            "            md5_hash = request.POST['md5']",
            "",
            "        if not re.match(MD5_REGEX, md5_hash):",
            "            return send_response({'deleted': 'Invalid scan hash'}, api)",
            "",
            "        # Delete DB Entries",
            "        scan = RecentScansDB.objects.filter(MD5=md5_hash)",
            "        if not scan.exists():",
            "            return send_response({'deleted': 'Scan not found in Database'}, api)",
            "        if settings.ASYNC_ANALYSIS:",
            "            # Handle Async Tasks",
            "            et = EnqueuedTask.objects.filter(checksum=md5_hash).first()",
            "            if et:",
            "                max_time_passed = now() - et.created_at > timedelta(",
            "                    minutes=settings.ASYNC_ANALYSIS_TIMEOUT)",
            "                if not (et.completed_at or max_time_passed):",
            "                    # Queue is in progress, cannot delete the task",
            "                    return send_response(",
            "                        {'deleted': 'A scan can only be deleted after it is completed'},",
            "                        api)",
            "        # Delete all related DB entries",
            "        EnqueuedTask.objects.filter(checksum=md5_hash).all().delete()",
            "        RecentScansDB.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerAndroid.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerIOS.objects.filter(MD5=md5_hash).delete()",
            "        StaticAnalyzerWindows.objects.filter(MD5=md5_hash).delete()",
            "        # Delete Upload Dir Contents",
            "        app_upload_dir = os.path.join(settings.UPLD_DIR, md5_hash)",
            "        if is_dir_exists(app_upload_dir):",
            "            shutil.rmtree(app_upload_dir)",
            "        # Delete Download Dir Contents",
            "        dw_dir = settings.DWD_DIR",
            "        for item in os.listdir(dw_dir):",
            "            item_path = os.path.join(dw_dir, item)",
            "            valid_item = item.startswith(md5_hash + '-')",
            "            # Delete all related files",
            "            if is_file_exists(item_path) and valid_item:",
            "                os.remove(item_path)",
            "            # Delete related directories",
            "            if is_dir_exists(item_path) and valid_item:",
            "                shutil.rmtree(item_path, ignore_errors=True)",
            "        return send_response({'deleted': 'yes'}, api)",
            "    except Exception as exp:",
            "        msg = str(exp)",
            "        exp_doc = exp.__doc__",
            "        return print_n_send_error_response(request, msg, api, exp_doc)",
            "",
            "",
            "class RecentScans(object):",
            "",
            "    def __init__(self, request):",
            "        self.request = request",
            "",
            "    def recent_scans(self):",
            "        page = self.request.GET.get('page', 1)",
            "        page_size = self.request.GET.get('page_size', 10)",
            "        result = RecentScansDB.objects.all().values().order_by('-TIMESTAMP')",
            "        try:",
            "            paginator = Paginator(result, page_size)",
            "            content = paginator.page(page)",
            "            data = {",
            "                'content': list(content),",
            "                'count': paginator.count,",
            "                'num_pages': paginator.num_pages,",
            "            }",
            "        except Exception as exp:",
            "            data = {'error': str(exp)}",
            "        return data",
            "",
            "",
            "def update_scan_timestamp(scan_hash):",
            "    # Update the last scan time.",
            "    tms = timezone.now()",
            "    RecentScansDB.objects.filter(MD5=scan_hash).update(TIMESTAMP=tms)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "166": [
                "Upload",
                "upload"
            ]
        },
        "addLocation": []
    },
    "mobsf/MobSF/views/scanning.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.utils import timezone"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from mobsf.StaticAnalyzer.models import RecentScansDB"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from mobsf.MobSF.security import sanitize_filename"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def __init__(self, request):"
            },
            "9": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         self.file = request.FILES['file']"
            },
            "10": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.file_name = request.FILES['file'].name"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        self.file_name = sanitize_filename("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            request.FILES['file'].name)"
            },
            "13": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         self.data = {"
            },
            "14": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             'analyzer': 'static_analyzer',"
            },
            "15": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             'status': 'success',"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf_8 -*-",
            "import hashlib",
            "import logging",
            "import io",
            "import os",
            "",
            "from django.conf import settings",
            "from django.utils import timezone",
            "",
            "from mobsf.StaticAnalyzer.models import RecentScansDB",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def add_to_recent_scan(data):",
            "    \"\"\"Add Entry to Database under Recent Scan.\"\"\"",
            "    try:",
            "        db_obj = RecentScansDB.objects.filter(MD5=data['hash'])",
            "        if not db_obj.exists():",
            "            new_db_obj = RecentScansDB(",
            "                ANALYZER=data['analyzer'],",
            "                SCAN_TYPE=data['scan_type'],",
            "                FILE_NAME=data['file_name'],",
            "                APP_NAME='',",
            "                PACKAGE_NAME='',",
            "                VERSION_NAME='',",
            "                MD5=data['hash'],",
            "                TIMESTAMP=timezone.now())",
            "            new_db_obj.save()",
            "    except Exception:",
            "        logger.exception('Adding Scan URL to Database')",
            "",
            "",
            "def handle_uploaded_file(content, extension):",
            "    \"\"\"Write Uploaded File.\"\"\"",
            "    md5 = hashlib.md5()",
            "    bfr = isinstance(content, io.BufferedReader)",
            "    if bfr:",
            "        # Not File upload",
            "        while chunk := content.read(8192):",
            "            md5.update(chunk)",
            "    else:",
            "        # File upload",
            "        for chunk in content.chunks():",
            "            md5.update(chunk)",
            "    md5sum = md5.hexdigest()",
            "    anal_dir = os.path.join(settings.UPLD_DIR, md5sum + '/')",
            "    if not os.path.exists(anal_dir):",
            "        os.makedirs(anal_dir)",
            "    with open(f'{anal_dir}{md5sum}{extension}', 'wb+') as destination:",
            "        if bfr:",
            "            content.seek(0, 0)",
            "            while chunk := content.read(8192):",
            "                destination.write(chunk)",
            "        else:",
            "            for chunk in content.chunks():",
            "                destination.write(chunk)",
            "    return md5sum",
            "",
            "",
            "class Scanning(object):",
            "",
            "    def __init__(self, request):",
            "        self.file = request.FILES['file']",
            "        self.file_name = request.FILES['file'].name",
            "        self.data = {",
            "            'analyzer': 'static_analyzer',",
            "            'status': 'success',",
            "            'hash': '',",
            "            'scan_type': '',",
            "            'file_name': self.file_name,",
            "        }",
            "",
            "    def scan_apk(self):",
            "        \"\"\"Android APK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.apk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'apk'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android APK uploaded')",
            "        return self.data",
            "",
            "    def scan_xapk(self):",
            "        \"\"\"Android XAPK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.xapk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'xapk'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android XAPK uploaded')",
            "        return self.data",
            "",
            "    def scan_apks(self):",
            "        \"\"\"Android Split APK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.apk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'apks'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android Split APK uploaded')",
            "        return self.data",
            "",
            "    def scan_aab(self):",
            "        \"\"\"Android App Bundle.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.aab')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'aab'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android App Bundle uploaded')",
            "        return self.data",
            "",
            "    def scan_jar(self):",
            "        \"\"\"Java JAR file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.jar')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'jar'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Java JAR uploaded')",
            "        return self.data",
            "",
            "    def scan_aar(self):",
            "        \"\"\"Android AAR file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.aar')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'aar'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android AAR uploaded')",
            "        return self.data",
            "",
            "    def scan_so(self):",
            "        \"\"\"Shared object file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.so')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'so'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Shared Object Library uploaded')",
            "        return self.data",
            "",
            "    def scan_zip(self):",
            "        \"\"\"Android /iOS Zipped Source.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.zip')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'zip'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android/iOS Source code ZIP uploaded')",
            "        return self.data",
            "",
            "    def scan_ipa(self):",
            "        \"\"\"IOS Binary.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.ipa')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'ipa'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('iOS IPA uploaded')",
            "        return self.data",
            "",
            "    def scan_dylib(self):",
            "        \"\"\"IOS Dylib.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.dylib')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'dylib'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('iOS dylib uploaded')",
            "        return self.data",
            "",
            "    def scan_a(self):",
            "        \"\"\"Scan static library.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.a')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'a'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Static Library uploaded')",
            "        return self.data",
            "",
            "    def scan_appx(self):",
            "        \"\"\"Windows appx.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.appx')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'appx'",
            "        self.data['analyzer'] = 'static_analyzer_windows'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Windows APPX uploaded')",
            "        return self.data"
        ],
        "afterPatchFile": [
            "# -*- coding: utf_8 -*-",
            "import hashlib",
            "import logging",
            "import io",
            "import os",
            "",
            "from django.conf import settings",
            "from django.utils import timezone",
            "",
            "from mobsf.StaticAnalyzer.models import RecentScansDB",
            "from mobsf.MobSF.security import sanitize_filename",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def add_to_recent_scan(data):",
            "    \"\"\"Add Entry to Database under Recent Scan.\"\"\"",
            "    try:",
            "        db_obj = RecentScansDB.objects.filter(MD5=data['hash'])",
            "        if not db_obj.exists():",
            "            new_db_obj = RecentScansDB(",
            "                ANALYZER=data['analyzer'],",
            "                SCAN_TYPE=data['scan_type'],",
            "                FILE_NAME=data['file_name'],",
            "                APP_NAME='',",
            "                PACKAGE_NAME='',",
            "                VERSION_NAME='',",
            "                MD5=data['hash'],",
            "                TIMESTAMP=timezone.now())",
            "            new_db_obj.save()",
            "    except Exception:",
            "        logger.exception('Adding Scan URL to Database')",
            "",
            "",
            "def handle_uploaded_file(content, extension):",
            "    \"\"\"Write Uploaded File.\"\"\"",
            "    md5 = hashlib.md5()",
            "    bfr = isinstance(content, io.BufferedReader)",
            "    if bfr:",
            "        # Not File upload",
            "        while chunk := content.read(8192):",
            "            md5.update(chunk)",
            "    else:",
            "        # File upload",
            "        for chunk in content.chunks():",
            "            md5.update(chunk)",
            "    md5sum = md5.hexdigest()",
            "    anal_dir = os.path.join(settings.UPLD_DIR, md5sum + '/')",
            "    if not os.path.exists(anal_dir):",
            "        os.makedirs(anal_dir)",
            "    with open(f'{anal_dir}{md5sum}{extension}', 'wb+') as destination:",
            "        if bfr:",
            "            content.seek(0, 0)",
            "            while chunk := content.read(8192):",
            "                destination.write(chunk)",
            "        else:",
            "            for chunk in content.chunks():",
            "                destination.write(chunk)",
            "    return md5sum",
            "",
            "",
            "class Scanning(object):",
            "",
            "    def __init__(self, request):",
            "        self.file = request.FILES['file']",
            "        self.file_name = sanitize_filename(",
            "            request.FILES['file'].name)",
            "        self.data = {",
            "            'analyzer': 'static_analyzer',",
            "            'status': 'success',",
            "            'hash': '',",
            "            'scan_type': '',",
            "            'file_name': self.file_name,",
            "        }",
            "",
            "    def scan_apk(self):",
            "        \"\"\"Android APK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.apk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'apk'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android APK uploaded')",
            "        return self.data",
            "",
            "    def scan_xapk(self):",
            "        \"\"\"Android XAPK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.xapk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'xapk'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android XAPK uploaded')",
            "        return self.data",
            "",
            "    def scan_apks(self):",
            "        \"\"\"Android Split APK.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.apk')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'apks'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android Split APK uploaded')",
            "        return self.data",
            "",
            "    def scan_aab(self):",
            "        \"\"\"Android App Bundle.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.aab')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'aab'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android App Bundle uploaded')",
            "        return self.data",
            "",
            "    def scan_jar(self):",
            "        \"\"\"Java JAR file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.jar')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'jar'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Java JAR uploaded')",
            "        return self.data",
            "",
            "    def scan_aar(self):",
            "        \"\"\"Android AAR file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.aar')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'aar'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android AAR uploaded')",
            "        return self.data",
            "",
            "    def scan_so(self):",
            "        \"\"\"Shared object file.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.so')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'so'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Shared Object Library uploaded')",
            "        return self.data",
            "",
            "    def scan_zip(self):",
            "        \"\"\"Android /iOS Zipped Source.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.zip')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'zip'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Android/iOS Source code ZIP uploaded')",
            "        return self.data",
            "",
            "    def scan_ipa(self):",
            "        \"\"\"IOS Binary.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.ipa')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'ipa'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('iOS IPA uploaded')",
            "        return self.data",
            "",
            "    def scan_dylib(self):",
            "        \"\"\"IOS Dylib.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.dylib')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'dylib'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('iOS dylib uploaded')",
            "        return self.data",
            "",
            "    def scan_a(self):",
            "        \"\"\"Scan static library.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.a')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'a'",
            "        self.data['analyzer'] = 'static_analyzer_ios'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Static Library uploaded')",
            "        return self.data",
            "",
            "    def scan_appx(self):",
            "        \"\"\"Windows appx.\"\"\"",
            "        md5 = handle_uploaded_file(self.file, '.appx')",
            "        self.data['hash'] = md5",
            "        self.data['scan_type'] = 'appx'",
            "        self.data['analyzer'] = 'static_analyzer_windows'",
            "        add_to_recent_scan(self.data)",
            "        logger.info('Windows APPX uploaded')",
            "        return self.data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "65": [
                "Scanning",
                "__init__"
            ]
        },
        "addLocation": []
    }
}