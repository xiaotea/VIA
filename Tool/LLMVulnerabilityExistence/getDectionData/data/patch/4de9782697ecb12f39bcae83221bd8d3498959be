{
    "nvflare/lighter/provision.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import webbrowser"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import yaml"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from nvflare.fuel.utils.class_utils import instantiate_class"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from nvflare.lighter.spec import Participant, Project, Provisioner"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from nvflare.lighter.utils import load_yaml"
            },
            "8": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " def main():"
            },
            "11": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     project_full_path = os.path.join(current_path, project_file)"
            },
            "12": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     print(f\"Project yaml file: {project_full_path}.\")"
            },
            "13": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    project_dict = yaml.load(open(project_full_path, \"r\"), Loader=yaml.Loader)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    project_dict = load_yaml(project_full_path)"
            },
            "16": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     api_version = project_dict.get(\"api_version\")"
            },
            "17": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     if api_version not in [3]:"
            },
            "18": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         raise ValueError(f\"API version expected 3 but found {api_version}\")"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import absolute_import",
            "",
            "import argparse",
            "import os",
            "import pathlib",
            "import shutil",
            "import sys",
            "import webbrowser",
            "",
            "import yaml",
            "",
            "from nvflare.fuel.utils.class_utils import instantiate_class",
            "from nvflare.lighter.spec import Participant, Project, Provisioner",
            "",
            "",
            "def main():",
            "    parser = argparse.ArgumentParser()",
            "    parser.add_argument(\"-p\", \"--project_file\", type=str, default=\"project.yml\", help=\"file to describe FL project\")",
            "    parser.add_argument(\"-w\", \"--workspace\", type=str, default=\"workspace\", help=\"directory used by provision\")",
            "    parser.add_argument(\"-c\", \"--custom_folder\", type=str, default=\".\", help=\"additional folder to load python codes\")",
            "    parser.add_argument(",
            "        \"-u\",",
            "        \"--ui_tool\",",
            "        action=\"store_true\",",
            "        help=\"Run provisioning UI tool to generate project.yml file\",",
            "    )",
            "",
            "    args = parser.parse_args()",
            "",
            "    file_path = pathlib.Path(__file__).parent.absolute()",
            "    current_path = os.getcwd()",
            "    custom_folder_path = os.path.join(current_path, args.custom_folder)",
            "    sys.path.append(custom_folder_path)",
            "    print(\"Path list (sys.path) for python codes loading: {}\".format(sys.path))",
            "",
            "    # main project file",
            "    project_file = args.project_file",
            "    current_project_yml = os.path.join(current_path, \"project.yml\")",
            "    if len(sys.argv) == 1 and not os.path.exists(current_project_yml):",
            "        answer = input(",
            "            f\"No project.yml found in current folder.  Is it OK to generate one at {current_project_yml} for you? (y/N) \"",
            "        )",
            "        if answer.strip().upper() == \"Y\":",
            "            shutil.copyfile(os.path.join(file_path, \"project.yml\"), current_project_yml)",
            "            print(f\"{current_project_yml} was created.  Please edit it to fit your FL configuration.\")",
            "        exit(0)",
            "",
            "    if args.ui_tool:",
            "        ui_helper_path = os.path.join(file_path, \"provision_helper.html\")",
            "        ui_helper_url = f\"file://{ui_helper_path}\"",
            "        webbrowser.open_new_tab(ui_helper_url)",
            "        print(",
            "            \"\\n******\\n\"",
            "            \"Now launching provisioning UI tool.\\n\"",
            "            \"After generating project.yml in the browser and saving it to your local folder,\\n\"",
            "            \"please re-run provision with -p option, pointing to the generated project.yml, to generate all packages.\\n******\\n\"",
            "        )",
            "        exit(0)",
            "",
            "    workspace = args.workspace",
            "    workspace_full_path = os.path.join(current_path, workspace)",
            "",
            "    project_full_path = os.path.join(current_path, project_file)",
            "    print(f\"Project yaml file: {project_full_path}.\")",
            "",
            "    project_dict = yaml.load(open(project_full_path, \"r\"), Loader=yaml.Loader)",
            "    api_version = project_dict.get(\"api_version\")",
            "    if api_version not in [3]:",
            "        raise ValueError(f\"API version expected 3 but found {api_version}\")",
            "",
            "    project_name = project_dict.get(\"name\")",
            "    project_description = project_dict.get(\"description\", \"\")",
            "    participants = list()",
            "    for p in project_dict.get(\"participants\"):",
            "        participants.append(Participant(**p))",
            "    project = Project(name=project_name, description=project_description, participants=participants)",
            "",
            "    builders = list()",
            "    for b in project_dict.get(\"builders\"):",
            "        path = b.get(\"path\")",
            "        args = b.get(\"args\")",
            "        builders.append(instantiate_class(path, args))",
            "",
            "    provisioner = Provisioner(workspace_full_path, builders)",
            "",
            "    provisioner.provision(project)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from __future__ import absolute_import",
            "",
            "import argparse",
            "import os",
            "import pathlib",
            "import shutil",
            "import sys",
            "import webbrowser",
            "",
            "from nvflare.fuel.utils.class_utils import instantiate_class",
            "from nvflare.lighter.spec import Participant, Project, Provisioner",
            "from nvflare.lighter.utils import load_yaml",
            "",
            "",
            "def main():",
            "    parser = argparse.ArgumentParser()",
            "    parser.add_argument(\"-p\", \"--project_file\", type=str, default=\"project.yml\", help=\"file to describe FL project\")",
            "    parser.add_argument(\"-w\", \"--workspace\", type=str, default=\"workspace\", help=\"directory used by provision\")",
            "    parser.add_argument(\"-c\", \"--custom_folder\", type=str, default=\".\", help=\"additional folder to load python codes\")",
            "    parser.add_argument(",
            "        \"-u\",",
            "        \"--ui_tool\",",
            "        action=\"store_true\",",
            "        help=\"Run provisioning UI tool to generate project.yml file\",",
            "    )",
            "",
            "    args = parser.parse_args()",
            "",
            "    file_path = pathlib.Path(__file__).parent.absolute()",
            "    current_path = os.getcwd()",
            "    custom_folder_path = os.path.join(current_path, args.custom_folder)",
            "    sys.path.append(custom_folder_path)",
            "    print(\"Path list (sys.path) for python codes loading: {}\".format(sys.path))",
            "",
            "    # main project file",
            "    project_file = args.project_file",
            "    current_project_yml = os.path.join(current_path, \"project.yml\")",
            "    if len(sys.argv) == 1 and not os.path.exists(current_project_yml):",
            "        answer = input(",
            "            f\"No project.yml found in current folder.  Is it OK to generate one at {current_project_yml} for you? (y/N) \"",
            "        )",
            "        if answer.strip().upper() == \"Y\":",
            "            shutil.copyfile(os.path.join(file_path, \"project.yml\"), current_project_yml)",
            "            print(f\"{current_project_yml} was created.  Please edit it to fit your FL configuration.\")",
            "        exit(0)",
            "",
            "    if args.ui_tool:",
            "        ui_helper_path = os.path.join(file_path, \"provision_helper.html\")",
            "        ui_helper_url = f\"file://{ui_helper_path}\"",
            "        webbrowser.open_new_tab(ui_helper_url)",
            "        print(",
            "            \"\\n******\\n\"",
            "            \"Now launching provisioning UI tool.\\n\"",
            "            \"After generating project.yml in the browser and saving it to your local folder,\\n\"",
            "            \"please re-run provision with -p option, pointing to the generated project.yml, to generate all packages.\\n******\\n\"",
            "        )",
            "        exit(0)",
            "",
            "    workspace = args.workspace",
            "    workspace_full_path = os.path.join(current_path, workspace)",
            "",
            "    project_full_path = os.path.join(current_path, project_file)",
            "    print(f\"Project yaml file: {project_full_path}.\")",
            "",
            "    project_dict = load_yaml(project_full_path)",
            "    api_version = project_dict.get(\"api_version\")",
            "    if api_version not in [3]:",
            "        raise ValueError(f\"API version expected 3 but found {api_version}\")",
            "",
            "    project_name = project_dict.get(\"name\")",
            "    project_description = project_dict.get(\"description\", \"\")",
            "    participants = list()",
            "    for p in project_dict.get(\"participants\"):",
            "        participants.append(Participant(**p))",
            "    project = Project(name=project_name, description=project_description, participants=participants)",
            "",
            "    builders = list()",
            "    for b in project_dict.get(\"builders\"):",
            "        path = b.get(\"path\")",
            "        args = b.get(\"args\")",
            "        builders.append(instantiate_class(path, args))",
            "",
            "    provisioner = Provisioner(workspace_full_path, builders)",
            "",
            "    provisioner.provision(project)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [],
            "25": [],
            "80": [
                "main"
            ]
        },
        "addLocation": []
    },
    "nvflare/lighter/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " def load_yaml(file_name):"
            },
            "3": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return yaml.load(open(file_name, \"r\"), Loader=yaml.Loader)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    return yaml.safe_load(open(file_name, \"r\"))"
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " def sh_replace(src, mapping_dict):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "import random",
            "from base64 import b64encode",
            "",
            "import yaml",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import padding",
            "",
            "",
            "def generate_password():",
            "    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
            "    passlen = 16",
            "    p = \"\".join(random.sample(s, passlen))",
            "    return p",
            "",
            "",
            "def sign_all(content_folder, signing_pri_key):",
            "    signatures = dict()",
            "    for f in os.listdir(content_folder):",
            "        path = os.path.join(content_folder, f)",
            "        if os.path.isfile(path):",
            "            signature = signing_pri_key.sign(",
            "                data=open(path, \"rb\").read(),",
            "                padding=padding.PSS(",
            "                    mgf=padding.MGF1(hashes.SHA256()),",
            "                    salt_length=padding.PSS.MAX_LENGTH,",
            "                ),",
            "                algorithm=hashes.SHA256(),",
            "            )",
            "            signatures[f] = b64encode(signature).decode(\"utf-8\")",
            "    return signatures",
            "",
            "",
            "def load_yaml(file_name):",
            "    return yaml.load(open(file_name, \"r\"), Loader=yaml.Loader)",
            "",
            "",
            "def sh_replace(src, mapping_dict):",
            "    result = src",
            "    for k, v in mapping_dict.items():",
            "        result = result.replace(\"{~~\" + k + \"~~}\", str(v))",
            "    return result"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "import random",
            "from base64 import b64encode",
            "",
            "import yaml",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import padding",
            "",
            "",
            "def generate_password():",
            "    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
            "    passlen = 16",
            "    p = \"\".join(random.sample(s, passlen))",
            "    return p",
            "",
            "",
            "def sign_all(content_folder, signing_pri_key):",
            "    signatures = dict()",
            "    for f in os.listdir(content_folder):",
            "        path = os.path.join(content_folder, f)",
            "        if os.path.isfile(path):",
            "            signature = signing_pri_key.sign(",
            "                data=open(path, \"rb\").read(),",
            "                padding=padding.PSS(",
            "                    mgf=padding.MGF1(hashes.SHA256()),",
            "                    salt_length=padding.PSS.MAX_LENGTH,",
            "                ),",
            "                algorithm=hashes.SHA256(),",
            "            )",
            "            signatures[f] = b64encode(signature).decode(\"utf-8\")",
            "    return signatures",
            "",
            "",
            "def load_yaml(file_name):",
            "    return yaml.safe_load(open(file_name, \"r\"))",
            "",
            "",
            "def sh_replace(src, mapping_dict):",
            "    result = src",
            "    for k, v in mapping_dict.items():",
            "        result = result.replace(\"{~~\" + k + \"~~}\", str(v))",
            "    return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "49": [
                "load_yaml"
            ]
        },
        "addLocation": []
    }
}