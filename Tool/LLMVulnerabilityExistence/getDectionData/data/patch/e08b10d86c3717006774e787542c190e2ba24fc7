{
    "keylime/registrar_client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " logger = keylime_logging.init_logging(\"registrar_client\")"
            },
            "1": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " api_version = keylime_api_version.current_version()"
            },
            "2": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+MANDATORY_FIELDS = [\"aik_tpm\", \"regcount\", \"ek_tpm\", \"ip\", \"port\"]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+def check_mandatory_fields(results: Dict[str, Any]) -> bool:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    for field in MANDATORY_FIELDS:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        if field not in results:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            logger.critical(\"Error: did not receive %s from Registrar Server.\", field)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            return False"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    return True"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " def getData("
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     registrar_ip: str, registrar_port: str, agent_id: str, tls_context: Optional[ssl.SSLContext]"
            },
            "16": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             logger.critical(\"Error: unexpected http response body from Registrar Server: %s\", response.status_code)"
            },
            "17": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             return None"
            },
            "18": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"aik_tpm\" not in response_body[\"results\"]:"
            },
            "20": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.critical(\"Error: did not receive AIK from Registrar Server.\")"
            },
            "21": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "22": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "23": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"regcount\" not in response_body[\"results\"]:"
            },
            "24": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.critical(\"Error: did not receive regcount from Registrar Server.\")"
            },
            "25": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "26": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "27": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"ek_tpm\" not in response_body[\"results\"]:"
            },
            "28": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.critical(\"Error: did not receive EK from Registrar Server.\")"
            },
            "29": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "30": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"ip\" not in response_body[\"results\"]:"
            },
            "32": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.critical(\"Error: did not receive IP from Registrar Server.\")"
            },
            "33": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "34": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "35": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"port\" not in response_body[\"results\"]:"
            },
            "36": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.critical(\"Error: did not receive port from Registrar Server.\")"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        if not check_mandatory_fields(response_body[\"results\"]):"
            },
            "38": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             return None"
            },
            "39": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         r = response_body[\"results\"]"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import ssl",
            "import sys",
            "from typing import Any, Dict, Optional",
            "",
            "from keylime import api_version as keylime_api_version",
            "from keylime import keylime_logging",
            "from keylime.ip_util import bracketize_ipv6",
            "from keylime.requests_client import RequestsClient",
            "",
            "if sys.version_info >= (3, 8):",
            "    from typing import TypedDict",
            "else:",
            "    from typing_extensions import TypedDict",
            "",
            "if sys.version_info >= (3, 11):",
            "    from typing import NotRequired",
            "else:",
            "    from typing_extensions import NotRequired",
            "",
            "",
            "class RegistrarData(TypedDict):",
            "    ip: Optional[str]",
            "    port: Optional[str]",
            "    regcount: int",
            "    mtls_cert: Optional[str]",
            "    aik_tpm: str",
            "    ek_tpm: str",
            "    ekcert: Optional[str]",
            "    provider_keys: NotRequired[Dict[str, str]]",
            "",
            "",
            "logger = keylime_logging.init_logging(\"registrar_client\")",
            "api_version = keylime_api_version.current_version()",
            "",
            "",
            "def getData(",
            "    registrar_ip: str, registrar_port: str, agent_id: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Optional[RegistrarData]:",
            "    \"\"\"",
            "    Get the agent data from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: JSON structure containing the agent data",
            "    \"\"\"",
            "    # make absolutely sure you don't ask for data that contains AIK keys unauthenticated",
            "    if not tls_context:",
            "        raise Exception(\"It is unsafe to use this interface to query AIKs without server-authenticated TLS.\")",
            "",
            "    response = None",
            "    try:",
            "        client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "        response = client.get(f\"/v{api_version}/agents/{agent_id}\")",
            "        response_body = response.json()",
            "",
            "        if response.status_code == 404:",
            "            logger.critical(",
            "                \"Error: could not get agent %s data from Registrar Server: %s\", agent_id, response.status_code",
            "            )",
            "            keylime_logging.log_http_response(logger, logging.CRITICAL, response_body)",
            "            return None",
            "",
            "        if response.status_code != 200:",
            "            logger.critical(\"Error: unexpected http response code from Registrar Server: %s\", response.status_code)",
            "            keylime_logging.log_http_response(logger, logging.CRITICAL, response_body)",
            "            return None",
            "",
            "        # Check for all values that are consumed by other parts of Keylime",
            "        if \"results\" not in response_body:",
            "            logger.critical(\"Error: unexpected http response body from Registrar Server: %s\", response.status_code)",
            "            return None",
            "",
            "        if \"aik_tpm\" not in response_body[\"results\"]:",
            "            logger.critical(\"Error: did not receive AIK from Registrar Server.\")",
            "            return None",
            "",
            "        if \"regcount\" not in response_body[\"results\"]:",
            "            logger.critical(\"Error: did not receive regcount from Registrar Server.\")",
            "            return None",
            "",
            "        if \"ek_tpm\" not in response_body[\"results\"]:",
            "            logger.critical(\"Error: did not receive EK from Registrar Server.\")",
            "            return None",
            "",
            "        if \"ip\" not in response_body[\"results\"]:",
            "            logger.critical(\"Error: did not receive IP from Registrar Server.\")",
            "            return None",
            "",
            "        if \"port\" not in response_body[\"results\"]:",
            "            logger.critical(\"Error: did not receive port from Registrar Server.\")",
            "            return None",
            "",
            "        r = response_body[\"results\"]",
            "        res: RegistrarData = {",
            "            \"aik_tpm\": r[\"aik_tpm\"],",
            "            \"regcount\": r[\"regcount\"],",
            "            \"ek_tpm\": r[\"ek_tpm\"],",
            "            \"ip\": r[\"ip\"],",
            "            \"port\": r[\"port\"],",
            "            \"mtls_cert\": r.get(\"mtls_cert\"),",
            "            \"ekcert\": r.get(\"ekcert\"),",
            "        }",
            "        if \"provider_keys\" in r:",
            "            res[\"provider_keys\"] = r[\"provider_keys\"]",
            "",
            "        return res",
            "",
            "    except AttributeError as e:",
            "        if response and response.status_code == 503:",
            "            logger.critical(\"Error: the registrar is not available at %s:%s\", registrar_ip, registrar_port)",
            "        else:",
            "            logger.exception(e)",
            "",
            "    except Exception as e:",
            "        logger.exception(e)",
            "",
            "    return None",
            "",
            "",
            "def doRegistrarDelete(",
            "    registrar_ip: str, registrar_port: str, agent_id: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Dict[str, Any]:",
            "    \"\"\"",
            "    Delete the given agent from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: The request response body",
            "    \"\"\"",
            "",
            "    client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "    response = client.delete(f\"/v{api_version}/agents/{agent_id}\")",
            "    response_body: Dict[str, Any] = response.json()",
            "",
            "    if response.status_code == 200:",
            "        logger.debug(\"Registrar deleted.\")",
            "    else:",
            "        logger.warning(\"Status command response: %s Unexpected response from registrar.\", response.status_code)",
            "        keylime_logging.log_http_response(logger, logging.WARNING, response_body)",
            "",
            "    return response_body",
            "",
            "",
            "def doRegistrarList(",
            "    registrar_ip: str, registrar_port: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Optional[Dict[str, Any]]:",
            "    \"\"\"",
            "    Get the list of registered agents from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: The request response body",
            "    \"\"\"",
            "    client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "    response = client.get(f\"/v{api_version}/agents/\")",
            "    response_body: Dict[str, Any] = response.json()",
            "",
            "    if response.status_code != 200:",
            "        logger.warning(\"Registrar returned: %s Unexpected response from registrar.\", response.status_code)",
            "        keylime_logging.log_http_response(logger, logging.WARNING, response_body)",
            "        return None",
            "",
            "    return response_body"
        ],
        "afterPatchFile": [
            "import logging",
            "import ssl",
            "import sys",
            "from typing import Any, Dict, Optional",
            "",
            "from keylime import api_version as keylime_api_version",
            "from keylime import keylime_logging",
            "from keylime.ip_util import bracketize_ipv6",
            "from keylime.requests_client import RequestsClient",
            "",
            "if sys.version_info >= (3, 8):",
            "    from typing import TypedDict",
            "else:",
            "    from typing_extensions import TypedDict",
            "",
            "if sys.version_info >= (3, 11):",
            "    from typing import NotRequired",
            "else:",
            "    from typing_extensions import NotRequired",
            "",
            "",
            "class RegistrarData(TypedDict):",
            "    ip: Optional[str]",
            "    port: Optional[str]",
            "    regcount: int",
            "    mtls_cert: Optional[str]",
            "    aik_tpm: str",
            "    ek_tpm: str",
            "    ekcert: Optional[str]",
            "    provider_keys: NotRequired[Dict[str, str]]",
            "",
            "",
            "logger = keylime_logging.init_logging(\"registrar_client\")",
            "api_version = keylime_api_version.current_version()",
            "",
            "MANDATORY_FIELDS = [\"aik_tpm\", \"regcount\", \"ek_tpm\", \"ip\", \"port\"]",
            "",
            "",
            "def check_mandatory_fields(results: Dict[str, Any]) -> bool:",
            "    for field in MANDATORY_FIELDS:",
            "        if field not in results:",
            "            logger.critical(\"Error: did not receive %s from Registrar Server.\", field)",
            "            return False",
            "    return True",
            "",
            "",
            "def getData(",
            "    registrar_ip: str, registrar_port: str, agent_id: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Optional[RegistrarData]:",
            "    \"\"\"",
            "    Get the agent data from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: JSON structure containing the agent data",
            "    \"\"\"",
            "    # make absolutely sure you don't ask for data that contains AIK keys unauthenticated",
            "    if not tls_context:",
            "        raise Exception(\"It is unsafe to use this interface to query AIKs without server-authenticated TLS.\")",
            "",
            "    response = None",
            "    try:",
            "        client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "        response = client.get(f\"/v{api_version}/agents/{agent_id}\")",
            "        response_body = response.json()",
            "",
            "        if response.status_code == 404:",
            "            logger.critical(",
            "                \"Error: could not get agent %s data from Registrar Server: %s\", agent_id, response.status_code",
            "            )",
            "            keylime_logging.log_http_response(logger, logging.CRITICAL, response_body)",
            "            return None",
            "",
            "        if response.status_code != 200:",
            "            logger.critical(\"Error: unexpected http response code from Registrar Server: %s\", response.status_code)",
            "            keylime_logging.log_http_response(logger, logging.CRITICAL, response_body)",
            "            return None",
            "",
            "        # Check for all values that are consumed by other parts of Keylime",
            "        if \"results\" not in response_body:",
            "            logger.critical(\"Error: unexpected http response body from Registrar Server: %s\", response.status_code)",
            "            return None",
            "",
            "        if not check_mandatory_fields(response_body[\"results\"]):",
            "            return None",
            "",
            "        r = response_body[\"results\"]",
            "        res: RegistrarData = {",
            "            \"aik_tpm\": r[\"aik_tpm\"],",
            "            \"regcount\": r[\"regcount\"],",
            "            \"ek_tpm\": r[\"ek_tpm\"],",
            "            \"ip\": r[\"ip\"],",
            "            \"port\": r[\"port\"],",
            "            \"mtls_cert\": r.get(\"mtls_cert\"),",
            "            \"ekcert\": r.get(\"ekcert\"),",
            "        }",
            "        if \"provider_keys\" in r:",
            "            res[\"provider_keys\"] = r[\"provider_keys\"]",
            "",
            "        return res",
            "",
            "    except AttributeError as e:",
            "        if response and response.status_code == 503:",
            "            logger.critical(\"Error: the registrar is not available at %s:%s\", registrar_ip, registrar_port)",
            "        else:",
            "            logger.exception(e)",
            "",
            "    except Exception as e:",
            "        logger.exception(e)",
            "",
            "    return None",
            "",
            "",
            "def doRegistrarDelete(",
            "    registrar_ip: str, registrar_port: str, agent_id: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Dict[str, Any]:",
            "    \"\"\"",
            "    Delete the given agent from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: The request response body",
            "    \"\"\"",
            "",
            "    client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "    response = client.delete(f\"/v{api_version}/agents/{agent_id}\")",
            "    response_body: Dict[str, Any] = response.json()",
            "",
            "    if response.status_code == 200:",
            "        logger.debug(\"Registrar deleted.\")",
            "    else:",
            "        logger.warning(\"Status command response: %s Unexpected response from registrar.\", response.status_code)",
            "        keylime_logging.log_http_response(logger, logging.WARNING, response_body)",
            "",
            "    return response_body",
            "",
            "",
            "def doRegistrarList(",
            "    registrar_ip: str, registrar_port: str, tls_context: Optional[ssl.SSLContext]",
            ") -> Optional[Dict[str, Any]]:",
            "    \"\"\"",
            "    Get the list of registered agents from the registrar.",
            "",
            "    This is called by the tenant code",
            "",
            "    :returns: The request response body",
            "    \"\"\"",
            "    client = RequestsClient(f\"{bracketize_ipv6(registrar_ip)}:{registrar_port}\", True, tls_context=tls_context)",
            "    response = client.get(f\"/v{api_version}/agents/\")",
            "    response_body: Dict[str, Any] = response.json()",
            "",
            "    if response.status_code != 200:",
            "        logger.warning(\"Registrar returned: %s Unexpected response from registrar.\", response.status_code)",
            "        keylime_logging.log_http_response(logger, logging.WARNING, response_body)",
            "        return None",
            "",
            "    return response_body"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "74": [
                "getData"
            ],
            "75": [
                "getData"
            ],
            "76": [
                "getData"
            ],
            "77": [
                "getData"
            ],
            "78": [
                "getData"
            ],
            "79": [
                "getData"
            ],
            "80": [
                "getData"
            ],
            "81": [
                "getData"
            ],
            "82": [
                "getData"
            ],
            "83": [
                "getData"
            ],
            "84": [
                "getData"
            ],
            "85": [
                "getData"
            ],
            "86": [
                "getData"
            ],
            "87": [
                "getData"
            ],
            "88": [
                "getData"
            ],
            "89": [
                "getData"
            ],
            "90": [
                "getData"
            ],
            "91": [
                "getData"
            ]
        },
        "addLocation": [
            "keylime.registrar_client.getData",
            "flask_appbuilder.api"
        ]
    }
}