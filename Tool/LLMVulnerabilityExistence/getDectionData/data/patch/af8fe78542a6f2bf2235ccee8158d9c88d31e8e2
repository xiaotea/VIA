{
    "src/twisted/web/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import warnings"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import zlib"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from functools import wraps"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from typing import Iterable"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from urllib.parse import urldefrag, urljoin, urlunparse as _urlunparse"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from zope.interface import implementer"
            },
            "7": {
                "beforePatchRowNumber": 2110,
                "afterPatchRowNumber": 2111,
                "PatchRowcode": "         return response"
            },
            "8": {
                "beforePatchRowNumber": 2111,
                "afterPatchRowNumber": 2112,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 2112,
                "afterPatchRowNumber": 2113,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2114,
                "PatchRowcode": "+_canonicalHeaderName = Headers()._canonicalNameCaps"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2115,
                "PatchRowcode": "+_defaultSensitiveHeaders = frozenset("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2116,
                "PatchRowcode": "+    ["
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2117,
                "PatchRowcode": "+        b\"Authorization\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2118,
                "PatchRowcode": "+        b\"Cookie\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2119,
                "PatchRowcode": "+        b\"Cookie2\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2120,
                "PatchRowcode": "+        b\"Proxy-Authorization\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2121,
                "PatchRowcode": "+        b\"WWW-Authenticate\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2122,
                "PatchRowcode": "+    ]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2123,
                "PatchRowcode": "+)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2124,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2125,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 2113,
                "afterPatchRowNumber": 2126,
                "PatchRowcode": " @implementer(IAgent)"
            },
            "23": {
                "beforePatchRowNumber": 2114,
                "afterPatchRowNumber": 2127,
                "PatchRowcode": " class RedirectAgent:"
            },
            "24": {
                "beforePatchRowNumber": 2115,
                "afterPatchRowNumber": 2128,
                "PatchRowcode": "     \"\"\""
            },
            "25": {
                "beforePatchRowNumber": 2124,
                "afterPatchRowNumber": 2137,
                "PatchRowcode": "     @param redirectLimit: The maximum number of times the agent is allowed to"
            },
            "26": {
                "beforePatchRowNumber": 2125,
                "afterPatchRowNumber": 2138,
                "PatchRowcode": "         follow redirects before failing with a L{error.InfiniteRedirection}."
            },
            "27": {
                "beforePatchRowNumber": 2126,
                "afterPatchRowNumber": 2139,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2140,
                "PatchRowcode": "+    @param sensitiveHeaderNames: An iterable of C{bytes} enumerating the names"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2141,
                "PatchRowcode": "+        of headers that must not be transmitted when redirecting to a different"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2142,
                "PatchRowcode": "+        origins.  These will be consulted in addition to the protocol-specified"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2143,
                "PatchRowcode": "+        set of headers that contain sensitive information."
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2144,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 2127,
                "afterPatchRowNumber": 2145,
                "PatchRowcode": "     @cvar _redirectResponses: A L{list} of HTTP status codes to be redirected"
            },
            "34": {
                "beforePatchRowNumber": 2128,
                "afterPatchRowNumber": 2146,
                "PatchRowcode": "         for I{GET} and I{HEAD} methods."
            },
            "35": {
                "beforePatchRowNumber": 2129,
                "afterPatchRowNumber": 2147,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 2141,
                "afterPatchRowNumber": 2159,
                "PatchRowcode": "     ]"
            },
            "37": {
                "beforePatchRowNumber": 2142,
                "afterPatchRowNumber": 2160,
                "PatchRowcode": "     _seeOtherResponses = [http.SEE_OTHER]"
            },
            "38": {
                "beforePatchRowNumber": 2143,
                "afterPatchRowNumber": 2161,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 2144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, agent, redirectLimit=20):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2162,
                "PatchRowcode": "+    def __init__("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2163,
                "PatchRowcode": "+        self,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2164,
                "PatchRowcode": "+        agent: IAgent,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2165,
                "PatchRowcode": "+        redirectLimit: int = 20,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2166,
                "PatchRowcode": "+        sensitiveHeaderNames: Iterable[bytes] = (),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2167,
                "PatchRowcode": "+    ):"
            },
            "46": {
                "beforePatchRowNumber": 2145,
                "afterPatchRowNumber": 2168,
                "PatchRowcode": "         self._agent = agent"
            },
            "47": {
                "beforePatchRowNumber": 2146,
                "afterPatchRowNumber": 2169,
                "PatchRowcode": "         self._redirectLimit = redirectLimit"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2170,
                "PatchRowcode": "+        sensitive = {_canonicalHeaderName(each) for each in sensitiveHeaderNames}"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2171,
                "PatchRowcode": "+        sensitive.update(_defaultSensitiveHeaders)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2172,
                "PatchRowcode": "+        self._sensitiveHeaderNames = sensitive"
            },
            "51": {
                "beforePatchRowNumber": 2147,
                "afterPatchRowNumber": 2173,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 2148,
                "afterPatchRowNumber": 2174,
                "PatchRowcode": "     def request(self, method, uri, headers=None, bodyProducer=None):"
            },
            "53": {
                "beforePatchRowNumber": 2149,
                "afterPatchRowNumber": 2175,
                "PatchRowcode": "         \"\"\""
            },
            "54": {
                "beforePatchRowNumber": 2186,
                "afterPatchRowNumber": 2212,
                "PatchRowcode": "             )"
            },
            "55": {
                "beforePatchRowNumber": 2187,
                "afterPatchRowNumber": 2213,
                "PatchRowcode": "             raise ResponseFailed([Failure(err)], response)"
            },
            "56": {
                "beforePatchRowNumber": 2188,
                "afterPatchRowNumber": 2214,
                "PatchRowcode": "         location = self._resolveLocation(uri, locationHeaders[0])"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2215,
                "PatchRowcode": "+        if headers:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2216,
                "PatchRowcode": "+            parsedURI = URI.fromBytes(uri)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2217,
                "PatchRowcode": "+            parsedLocation = URI.fromBytes(location)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2218,
                "PatchRowcode": "+            sameOrigin = ("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2219,
                "PatchRowcode": "+                (parsedURI.scheme == parsedLocation.scheme)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2220,
                "PatchRowcode": "+                and (parsedURI.host == parsedLocation.host)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2221,
                "PatchRowcode": "+                and (parsedURI.port == parsedLocation.port)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2222,
                "PatchRowcode": "+            )"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2223,
                "PatchRowcode": "+            if not sameOrigin:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2224,
                "PatchRowcode": "+                headers = Headers("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2225,
                "PatchRowcode": "+                    {"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2226,
                "PatchRowcode": "+                        rawName: rawValue"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2227,
                "PatchRowcode": "+                        for rawName, rawValue in headers.getAllRawHeaders()"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2228,
                "PatchRowcode": "+                        if rawName not in self._sensitiveHeaderNames"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2229,
                "PatchRowcode": "+                    }"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2230,
                "PatchRowcode": "+                )"
            },
            "73": {
                "beforePatchRowNumber": 2189,
                "afterPatchRowNumber": 2231,
                "PatchRowcode": "         deferred = self._agent.request(method, location, headers)"
            },
            "74": {
                "beforePatchRowNumber": 2190,
                "afterPatchRowNumber": 2232,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 2191,
                "afterPatchRowNumber": 2233,
                "PatchRowcode": "         def _chainResponse(newResponse):"
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_webclient,twisted.web.test.test_agent -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HTTP client.",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import os",
            "import warnings",
            "import zlib",
            "from functools import wraps",
            "from urllib.parse import urldefrag, urljoin, urlunparse as _urlunparse",
            "",
            "from zope.interface import implementer",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import defer, protocol, task",
            "from twisted.internet.abstract import isIPv6Address",
            "from twisted.internet.endpoints import HostnameEndpoint, wrapClientTLS",
            "from twisted.internet.interfaces import IOpenSSLContextFactory, IProtocol",
            "from twisted.logger import Logger",
            "from twisted.python.compat import nativeString, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import (",
            "    deprecated,",
            "    deprecatedModuleAttribute,",
            "    getDeprecationWarningString,",
            ")",
            "from twisted.python.failure import Failure",
            "from twisted.python.util import InsensitiveDict",
            "from twisted.web import error, http",
            "from twisted.web._newclient import _ensureValidMethod, _ensureValidURI",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IAgentEndpointFactory,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "",
            "",
            "def urlunparse(parts):",
            "    result = _urlunparse(tuple(p.decode(\"charmap\") for p in parts))",
            "    return result.encode(\"charmap\")",
            "",
            "",
            "class PartialDownloadError(error.Error):",
            "    \"\"\"",
            "    Page was only partially downloaded, we got disconnected in middle.",
            "",
            "    @ivar response: All of the response body which was downloaded.",
            "    \"\"\"",
            "",
            "",
            "class HTTPPageGetter(http.HTTPClient):",
            "    \"\"\"",
            "    Gets a resource via HTTP, then quits.",
            "",
            "    Typically used with L{HTTPClientFactory}.  Note that this class does not, by",
            "    itself, do anything with the response.  If you want to download a resource",
            "    into a file, use L{HTTPPageDownloader} instead.",
            "",
            "    @ivar _completelyDone: A boolean indicating whether any further requests are",
            "        necessary after this one completes in order to provide a result to",
            "        C{self.factory.deferred}.  If it is C{False}, then a redirect is going",
            "        to be followed.  Otherwise, this protocol's connection is the last one",
            "        before firing the result Deferred.  This is used to make sure the result",
            "        Deferred is only fired after the connection is cleaned up.",
            "    \"\"\"",
            "",
            "    quietLoss = 0",
            "    followRedirect = True",
            "    failed = 0",
            "",
            "    _completelyDone = True",
            "",
            "    _specialHeaders = {b\"host\", b\"user-agent\", b\"cookie\", b\"content-length\"}",
            "",
            "    def connectionMade(self):",
            "        method = _ensureValidMethod(getattr(self.factory, \"method\", b\"GET\"))",
            "        self.sendCommand(method, _ensureValidURI(self.factory.path))",
            "        if self.factory.scheme == b\"http\" and self.factory.port != 80:",
            "            host = b\"%b:%d\" % (self.factory.host, self.factory.port)",
            "        elif self.factory.scheme == b\"https\" and self.factory.port != 443:",
            "            host = b\"%b:%d\" % (self.factory.host, self.factory.port)",
            "        else:",
            "            host = self.factory.host",
            "        self.sendHeader(b\"Host\", self.factory.headers.get(b\"host\", host))",
            "        self.sendHeader(b\"User-Agent\", self.factory.agent)",
            "        data = getattr(self.factory, \"postdata\", None)",
            "        if data is not None:",
            "            self.sendHeader(b\"Content-Length\", b\"%d\" % (len(data),))",
            "",
            "        cookieData = []",
            "        for (key, value) in self.factory.headers.items():",
            "            if key.lower() not in self._specialHeaders:",
            "                # we calculated it on our own",
            "                self.sendHeader(key, value)",
            "            if key.lower() == b\"cookie\":",
            "                cookieData.append(value)",
            "        for cookie, cookval in self.factory.cookies.items():",
            "            cookieData.append(cookie + b\"=\" + cookval)",
            "        if cookieData:",
            "            self.sendHeader(b\"Cookie\", b\"; \".join(cookieData))",
            "        self.endHeaders()",
            "        self.headers = {}",
            "",
            "        if data is not None:",
            "            self.transport.write(data)",
            "",
            "    def handleHeader(self, key, value):",
            "        \"\"\"",
            "        Called every time a header is received. Stores the header information",
            "        as key-value pairs in the C{headers} attribute.",
            "",
            "        @type key: C{str}",
            "        @param key: An HTTP header field name.",
            "",
            "        @type value: C{str}",
            "        @param value: An HTTP header field value.",
            "        \"\"\"",
            "        key = key.lower()",
            "        l = self.headers.setdefault(key, [])",
            "        l.append(value)",
            "",
            "    def handleStatus(self, version, status, message):",
            "        \"\"\"",
            "        Handle the HTTP status line.",
            "",
            "        @param version: The HTTP version.",
            "        @type version: L{bytes}",
            "        @param status: The HTTP status code, an integer represented as a",
            "            bytestring.",
            "        @type status: L{bytes}",
            "        @param message: The HTTP status message.",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.version, self.status, self.message = version, status, message",
            "        self.factory.gotStatus(version, status, message)",
            "",
            "    def handleEndHeaders(self):",
            "        self.factory.gotHeaders(self.headers)",
            "        m = getattr(",
            "            self, \"handleStatus_\" + nativeString(self.status), self.handleStatusDefault",
            "        )",
            "        m()",
            "",
            "    def handleStatus_200(self):",
            "        pass",
            "",
            "    handleStatus_201 = lambda self: self.handleStatus_200()",
            "    handleStatus_202 = lambda self: self.handleStatus_200()",
            "",
            "    def handleStatusDefault(self):",
            "        self.failed = 1",
            "",
            "    def handleStatus_301(self):",
            "        l = self.headers.get(b\"location\")",
            "        if not l:",
            "            self.handleStatusDefault()",
            "            return",
            "        url = l[0]",
            "        if self.followRedirect:",
            "            self.factory._redirectCount += 1",
            "            if self.factory._redirectCount >= self.factory.redirectLimit:",
            "                err = error.InfiniteRedirection(",
            "                    self.status, b\"Infinite redirection detected\", location=url",
            "                )",
            "                self.factory.noPage(Failure(err))",
            "                self.quietLoss = True",
            "                self.transport.loseConnection()",
            "                return",
            "",
            "            self._completelyDone = False",
            "            self.factory.setURL(url)",
            "",
            "            from twisted.internet import reactor",
            "",
            "            if self.factory.scheme == b\"https\":",
            "                from twisted.internet import ssl",
            "",
            "                contextFactory = ssl.ClientContextFactory()",
            "                reactor.connectSSL(",
            "                    nativeString(self.factory.host),",
            "                    self.factory.port,",
            "                    self.factory,",
            "                    contextFactory,",
            "                )",
            "            else:",
            "                reactor.connectTCP(",
            "                    nativeString(self.factory.host), self.factory.port, self.factory",
            "                )",
            "        else:",
            "            self.handleStatusDefault()",
            "            self.factory.noPage(",
            "                Failure(error.PageRedirect(self.status, self.message, location=url))",
            "            )",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "",
            "    def handleStatus_302(self):",
            "        if self.afterFoundGet:",
            "            self.handleStatus_303()",
            "        else:",
            "            self.handleStatus_301()",
            "",
            "    def handleStatus_303(self):",
            "        self.factory.method = b\"GET\"",
            "        self.handleStatus_301()",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the connection used to issue the HTTP request is closed, notify the",
            "        factory if we have not already, so it can produce a result.",
            "        \"\"\"",
            "        if not self.quietLoss:",
            "            http.HTTPClient.connectionLost(self, reason)",
            "            self.factory.noPage(reason)",
            "        if self._completelyDone:",
            "            # Only if we think we're completely done do we tell the factory that",
            "            # we're \"disconnected\".  This way when we're following redirects,",
            "            # only the last protocol used will fire the _disconnectedDeferred.",
            "            self.factory._disconnectedDeferred.callback(None)",
            "",
            "    def handleResponse(self, response):",
            "        if self.quietLoss:",
            "            return",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                Failure(error.Error(self.status, self.message, response))",
            "            )",
            "        if self.factory.method == b\"HEAD\":",
            "            # Callback with empty string, since there is never a response",
            "            # body for HEAD requests.",
            "            self.factory.page(b\"\")",
            "        elif self.length != None and self.length != 0:",
            "            self.factory.noPage(",
            "                Failure(PartialDownloadError(self.status, self.message, response))",
            "            )",
            "        else:",
            "            self.factory.page(response)",
            "        # server might be stupid and not close connection. admittedly",
            "        # the fact we do only one request per connection is also",
            "        # stupid...",
            "        self.transport.loseConnection()",
            "",
            "    def timeout(self):",
            "        self.quietLoss = True",
            "        self.transport.abortConnection()",
            "        self.factory.noPage(",
            "            defer.TimeoutError(",
            "                \"Getting %s took longer than %s seconds.\"",
            "                % (self.factory.url, self.factory.timeout)",
            "            )",
            "        )",
            "",
            "",
            "class HTTPPageDownloader(HTTPPageGetter):",
            "",
            "    transmittingPage = 0",
            "",
            "    def handleStatus_200(self, partialContent=0):",
            "        HTTPPageGetter.handleStatus_200(self)",
            "        self.transmittingPage = 1",
            "        self.factory.pageStart(partialContent)",
            "",
            "    def handleStatus_206(self):",
            "        self.handleStatus_200(partialContent=1)",
            "",
            "    def handleResponsePart(self, data):",
            "        if self.transmittingPage:",
            "            self.factory.pagePart(data)",
            "",
            "    def handleResponseEnd(self):",
            "        if self.length:",
            "            self.transmittingPage = 0",
            "            self.factory.noPage(Failure(PartialDownloadError(self.status)))",
            "        if self.transmittingPage:",
            "            self.factory.pageEnd()",
            "            self.transmittingPage = 0",
            "        if self.failed:",
            "            self.factory.noPage(Failure(error.Error(self.status, self.message, None)))",
            "            self.transport.loseConnection()",
            "",
            "",
            "class HTTPClientFactory(protocol.ClientFactory):",
            "    \"\"\"Download a given URL.",
            "",
            "    @type deferred: Deferred",
            "    @ivar deferred: A Deferred that will fire when the content has",
            "          been retrieved. Once this is fired, the ivars `status', `version',",
            "          and `message' will be set.",
            "",
            "    @type status: bytes",
            "    @ivar status: The status of the response.",
            "",
            "    @type version: bytes",
            "    @ivar version: The version of the response.",
            "",
            "    @type message: bytes",
            "    @ivar message: The text message returned with the status.",
            "",
            "    @type response_headers: dict",
            "    @ivar response_headers: The headers that were specified in the",
            "          response from the server.",
            "",
            "    @type method: bytes",
            "    @ivar method: The HTTP method to use in the request.  This should be one of",
            "        OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT (case",
            "        matters).  Other values may be specified if the server being contacted",
            "        supports them.",
            "",
            "    @type redirectLimit: int",
            "    @ivar redirectLimit: The maximum number of HTTP redirects that can occur",
            "          before it is assumed that the redirection is endless.",
            "",
            "    @type afterFoundGet: C{bool}",
            "    @ivar afterFoundGet: Deviate from the HTTP 1.1 RFC by handling redirects",
            "        the same way as most web browsers; if the request method is POST and a",
            "        302 status is encountered, the redirect is followed with a GET method",
            "",
            "    @type _redirectCount: int",
            "    @ivar _redirectCount: The current number of HTTP redirects encountered.",
            "",
            "    @ivar _disconnectedDeferred: A L{Deferred} which only fires after the last",
            "        connection associated with the request (redirects may cause multiple",
            "        connections to be required) has closed.  The result Deferred will only",
            "        fire after this Deferred, so that callers can be assured that there are",
            "        no more event sources in the reactor once they get the result.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageGetter",
            "",
            "    url = None",
            "    scheme = None",
            "    host = b\"\"",
            "    port = None",
            "    path = None",
            "",
            "    def __init__(",
            "        self,",
            "        url,",
            "        method=b\"GET\",",
            "        postdata=None,",
            "        headers=None,",
            "        agent=b\"Twisted PageGetter\",",
            "        timeout=0,",
            "        cookies=None,",
            "        followRedirect=True,",
            "        redirectLimit=20,",
            "        afterFoundGet=False,",
            "    ):",
            "        self.followRedirect = followRedirect",
            "        self.redirectLimit = redirectLimit",
            "        self._redirectCount = 0",
            "        self.timeout = timeout",
            "        self.agent = agent",
            "        self.afterFoundGet = afterFoundGet",
            "        if cookies is None:",
            "            cookies = {}",
            "        self.cookies = cookies",
            "        if headers is not None:",
            "            self.headers = InsensitiveDict(headers)",
            "        else:",
            "            self.headers = InsensitiveDict()",
            "        if postdata is not None:",
            "            self.headers.setdefault(b\"Content-Length\", b\"%d\" % (len(postdata),))",
            "            # just in case a broken http/1.1 decides to keep connection alive",
            "            self.headers.setdefault(b\"connection\", b\"close\")",
            "        self.postdata = postdata",
            "        self.method = _ensureValidMethod(method)",
            "",
            "        self.setURL(url)",
            "",
            "        self.waiting = 1",
            "        self._disconnectedDeferred = defer.Deferred()",
            "        self.deferred = defer.Deferred()",
            "        # Make sure the first callback on the result Deferred pauses the",
            "        # callback chain until the request connection is closed.",
            "        self.deferred.addBoth(self._waitForDisconnect)",
            "        self.response_headers = None",
            "",
            "    def _waitForDisconnect(self, passthrough):",
            "        \"\"\"",
            "        Chain onto the _disconnectedDeferred, preserving C{passthrough}, so that",
            "        the result is only available after the associated connection has been",
            "        closed.",
            "        \"\"\"",
            "        self._disconnectedDeferred.addCallback(lambda ignored: passthrough)",
            "        return self._disconnectedDeferred",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"<{self.__class__.__name__}: {self.url}>\"",
            "",
            "    def setURL(self, url):",
            "        _ensureValidURI(url.strip())",
            "        self.url = url",
            "        uri = URI.fromBytes(url)",
            "        if uri.scheme and uri.host:",
            "            self.scheme = uri.scheme",
            "            self.host = uri.host",
            "            self.port = uri.port",
            "        self.path = uri.originForm",
            "",
            "    def buildProtocol(self, addr):",
            "        p = protocol.ClientFactory.buildProtocol(self, addr)",
            "        p.followRedirect = self.followRedirect",
            "        p.afterFoundGet = self.afterFoundGet",
            "        if self.timeout:",
            "            from twisted.internet import reactor",
            "",
            "            timeoutCall = reactor.callLater(self.timeout, p.timeout)",
            "            self.deferred.addBoth(self._cancelTimeout, timeoutCall)",
            "        return p",
            "",
            "    def _cancelTimeout(self, result, timeoutCall):",
            "        if timeoutCall.active():",
            "            timeoutCall.cancel()",
            "        return result",
            "",
            "    def gotHeaders(self, headers):",
            "        \"\"\"",
            "        Parse the response HTTP headers.",
            "",
            "        @param headers: The response HTTP headers.",
            "        @type headers: L{dict}",
            "        \"\"\"",
            "        self.response_headers = headers",
            "        if b\"set-cookie\" in headers:",
            "            for cookie in headers[b\"set-cookie\"]:",
            "                if b\"=\" in cookie:",
            "                    cookparts = cookie.split(b\";\")",
            "                    cook = cookparts[0]",
            "                    cook.lstrip()",
            "                    k, v = cook.split(b\"=\", 1)",
            "                    self.cookies[k.lstrip()] = v.lstrip()",
            "",
            "    def gotStatus(self, version, status, message):",
            "        \"\"\"",
            "        Set the status of the request on us.",
            "",
            "        @param version: The HTTP version.",
            "        @type version: L{bytes}",
            "        @param status: The HTTP status code, an integer represented as a",
            "            bytestring.",
            "        @type status: L{bytes}",
            "        @param message: The HTTP status message.",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.version, self.status, self.message = version, status, message",
            "",
            "    def page(self, page):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.callback(page)",
            "",
            "    def noPage(self, reason):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.errback(reason)",
            "",
            "    def clientConnectionFailed(self, _, reason):",
            "        \"\"\"",
            "        When a connection attempt fails, the request cannot be issued.  If no",
            "        result has yet been provided to the result Deferred, provide the",
            "        connection failure reason as an error result.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            # If the connection attempt failed, there is nothing more to",
            "            # disconnect, so just fire that Deferred now.",
            "            self._disconnectedDeferred.callback(None)",
            "            self.deferred.errback(reason)",
            "",
            "",
            "class HTTPDownloader(HTTPClientFactory):",
            "    \"\"\"",
            "    Download to a file.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageDownloader",
            "    value = None",
            "    _log = Logger()",
            "",
            "    def __init__(",
            "        self,",
            "        url,",
            "        fileOrName,",
            "        method=b\"GET\",",
            "        postdata=None,",
            "        headers=None,",
            "        agent=b\"Twisted client\",",
            "        supportPartial=False,",
            "        timeout=0,",
            "        cookies=None,",
            "        followRedirect=True,",
            "        redirectLimit=20,",
            "        afterFoundGet=False,",
            "    ):",
            "        self.requestedPartial = 0",
            "        if isinstance(fileOrName, str):",
            "            self.fileName = fileOrName",
            "            self.file = None",
            "            if supportPartial and os.path.exists(self.fileName):",
            "                fileLength = os.path.getsize(self.fileName)",
            "                if fileLength:",
            "                    self.requestedPartial = fileLength",
            "                    if headers is None:",
            "                        headers = {}",
            "                    headers[b\"range\"] = b\"bytes=%d-\" % (fileLength,)",
            "        else:",
            "            self.file = fileOrName",
            "        HTTPClientFactory.__init__(",
            "            self,",
            "            url,",
            "            method=method,",
            "            postdata=postdata,",
            "            headers=headers,",
            "            agent=agent,",
            "            timeout=timeout,",
            "            cookies=cookies,",
            "            followRedirect=followRedirect,",
            "            redirectLimit=redirectLimit,",
            "            afterFoundGet=afterFoundGet,",
            "        )",
            "",
            "    def gotHeaders(self, headers):",
            "        HTTPClientFactory.gotHeaders(self, headers)",
            "        if self.requestedPartial:",
            "            contentRange = headers.get(b\"content-range\", None)",
            "            if not contentRange:",
            "                # server doesn't support partial requests, oh well",
            "                self.requestedPartial = 0",
            "                return",
            "            start, end, realLength = http.parseContentRange(contentRange[0])",
            "            if start != self.requestedPartial:",
            "                # server is acting weirdly",
            "                self.requestedPartial = 0",
            "",
            "    def openFile(self, partialContent):",
            "        if partialContent:",
            "            file = open(self.fileName, \"rb+\")",
            "            file.seek(0, 2)",
            "        else:",
            "            file = open(self.fileName, \"wb\")",
            "        return file",
            "",
            "    def pageStart(self, partialContent):",
            "        \"\"\"Called on page download start.",
            "",
            "        @param partialContent: tells us if the download is partial download we requested.",
            "        \"\"\"",
            "        if partialContent and not self.requestedPartial:",
            "            raise ValueError(",
            "                \"we shouldn't get partial content response if we didn't want it!\"",
            "            )",
            "        if self.waiting:",
            "            try:",
            "                if not self.file:",
            "                    self.file = self.openFile(partialContent)",
            "            except OSError:",
            "                # raise",
            "                self.deferred.errback(Failure())",
            "",
            "    def pagePart(self, data):",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.write(data)",
            "        except OSError:",
            "            # raise",
            "            self.file = None",
            "            self.deferred.errback(Failure())",
            "",
            "    def noPage(self, reason):",
            "        \"\"\"",
            "        Close the storage file and errback the waiting L{Deferred} with the",
            "        given reason.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            if self.file:",
            "                try:",
            "                    self.file.close()",
            "                except BaseException:",
            "                    self._log.failure(\"Error closing HTTPDownloader file\")",
            "            self.deferred.errback(reason)",
            "",
            "    def pageEnd(self):",
            "        self.waiting = 0",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.close()",
            "        except OSError:",
            "            self.deferred.errback(Failure())",
            "            return",
            "        self.deferred.callback(self.value)",
            "",
            "",
            "class URI:",
            "    \"\"\"",
            "    A URI object.",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21}",
            "    \"\"\"",
            "",
            "    def __init__(self, scheme, netloc, host, port, path, params, query, fragment):",
            "        \"\"\"",
            "        @type scheme: L{bytes}",
            "        @param scheme: URI scheme specifier.",
            "",
            "        @type netloc: L{bytes}",
            "        @param netloc: Network location component.",
            "",
            "        @type host: L{bytes}",
            "        @param host: Host name. For IPv6 address literals the brackets are",
            "            stripped.",
            "",
            "        @type port: L{int}",
            "        @param port: Port number.",
            "",
            "        @type path: L{bytes}",
            "        @param path: Hierarchical path.",
            "",
            "        @type params: L{bytes}",
            "        @param params: Parameters for last path segment.",
            "",
            "        @type query: L{bytes}",
            "        @param query: Query string.",
            "",
            "        @type fragment: L{bytes}",
            "        @param fragment: Fragment identifier.",
            "        \"\"\"",
            "        self.scheme = scheme",
            "        self.netloc = netloc",
            "        self.host = host.strip(b\"[]\")",
            "        self.port = port",
            "        self.path = path",
            "        self.params = params",
            "        self.query = query",
            "        self.fragment = fragment",
            "",
            "    @classmethod",
            "    def fromBytes(cls, uri, defaultPort=None):",
            "        \"\"\"",
            "        Parse the given URI into a L{URI}.",
            "",
            "        @type uri: C{bytes}",
            "        @param uri: URI to parse.",
            "",
            "        @type defaultPort: C{int} or L{None}",
            "        @param defaultPort: An alternate value to use as the port if the URI",
            "            does not include one.",
            "",
            "        @rtype: L{URI}",
            "        @return: Parsed URI instance.",
            "        \"\"\"",
            "        uri = uri.strip()",
            "        scheme, netloc, path, params, query, fragment = http.urlparse(uri)",
            "",
            "        if defaultPort is None:",
            "            if scheme == b\"https\":",
            "                defaultPort = 443",
            "            else:",
            "                defaultPort = 80",
            "",
            "        if b\":\" in netloc:",
            "            host, port = netloc.rsplit(b\":\", 1)",
            "            try:",
            "                port = int(port)",
            "            except ValueError:",
            "                host, port = netloc, defaultPort",
            "        else:",
            "            host, port = netloc, defaultPort",
            "        return cls(scheme, netloc, host, port, path, params, query, fragment)",
            "",
            "    def toBytes(self):",
            "        \"\"\"",
            "        Assemble the individual parts of the I{URI} into a fully formed I{URI}.",
            "",
            "        @rtype: C{bytes}",
            "        @return: A fully formed I{URI}.",
            "        \"\"\"",
            "        return urlunparse(",
            "            (",
            "                self.scheme,",
            "                self.netloc,",
            "                self.path,",
            "                self.params,",
            "                self.query,",
            "                self.fragment,",
            "            )",
            "        )",
            "",
            "    @property",
            "    def originForm(self):",
            "        \"\"\"",
            "        The absolute I{URI} path including I{URI} parameters, query string and",
            "        fragment identifier.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21#section-5.3}",
            "",
            "        @return: The absolute path in original form.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        # The HTTP bis draft says the origin form should not include the",
            "        # fragment.",
            "        path = urlunparse((b\"\", b\"\", self.path, self.params, self.query, b\"\"))",
            "        if path == b\"\":",
            "            path = b\"/\"",
            "        return path",
            "",
            "",
            "def _urljoin(base, url):",
            "    \"\"\"",
            "    Construct a full (\"absolute\") URL by combining a \"base URL\" with another",
            "    URL. Informally, this uses components of the base URL, in particular the",
            "    addressing scheme, the network location and (part of) the path, to provide",
            "    missing components in the relative URL.",
            "",
            "    Additionally, the fragment identifier is preserved according to the HTTP",
            "    1.1 bis draft.",
            "",
            "    @type base: C{bytes}",
            "    @param base: Base URL.",
            "",
            "    @type url: C{bytes}",
            "    @param url: URL to combine with C{base}.",
            "",
            "    @return: An absolute URL resulting from the combination of C{base} and",
            "        C{url}.",
            "",
            "    @see: L{urllib.parse.urljoin()}",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "    \"\"\"",
            "    base, baseFrag = urldefrag(base)",
            "    url, urlFrag = urldefrag(urljoin(base, url))",
            "    return urljoin(url, b\"#\" + (urlFrag or baseFrag))",
            "",
            "",
            "def _makeGetterFactory(url, factoryFactory, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Create and connect an HTTP page getting factory.",
            "",
            "    Any additional positional or keyword arguments are used when calling",
            "    C{factoryFactory}.",
            "",
            "    @param factoryFactory: Factory factory that is called with C{url}, C{args}",
            "        and C{kwargs} to produce the getter",
            "",
            "    @param contextFactory: Context factory to use when creating a secure",
            "        connection, defaulting to L{None}",
            "",
            "    @return: The factory created by C{factoryFactory}",
            "    \"\"\"",
            "    uri = URI.fromBytes(_ensureValidURI(url.strip()))",
            "    factory = factoryFactory(url, *args, **kwargs)",
            "    from twisted.internet import reactor",
            "",
            "    if uri.scheme == b\"https\":",
            "        from twisted.internet import ssl",
            "",
            "        if contextFactory is None:",
            "            contextFactory = ssl.ClientContextFactory()",
            "        reactor.connectSSL(nativeString(uri.host), uri.port, factory, contextFactory)",
            "    else:",
            "        reactor.connectTCP(nativeString(uri.host), uri.port, factory)",
            "    return factory",
            "",
            "",
            "_GETPAGE_REPLACEMENT_TEXT = \"https://pypi.org/project/treq/ or twisted.web.client.Agent\"",
            "",
            "",
            "def _deprecateGetPageClasses():",
            "    \"\"\"",
            "    Mark the protocols and factories associated with L{getPage} and",
            "    L{downloadPage} as deprecated.",
            "    \"\"\"",
            "    for klass in [",
            "        HTTPPageGetter,",
            "        HTTPPageDownloader,",
            "        HTTPClientFactory,",
            "        HTTPDownloader,",
            "    ]:",
            "        deprecatedModuleAttribute(",
            "            Version(\"Twisted\", 16, 7, 0),",
            "            getDeprecationWarningString(",
            "                klass,",
            "                Version(\"Twisted\", 16, 7, 0),",
            "                replacement=_GETPAGE_REPLACEMENT_TEXT,",
            "            ).split(\"; \")[1],",
            "            klass.__module__,",
            "            klass.__name__,",
            "        )",
            "",
            "",
            "_deprecateGetPageClasses()",
            "",
            "",
            "@deprecated(Version(\"Twisted\", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)",
            "def getPage(url, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page as a string.",
            "",
            "    Download a page. Return a deferred, which will callback with a",
            "    page (as a string) or errback with a description of the error.",
            "",
            "    See L{HTTPClientFactory} to see what extra arguments can be passed.",
            "    \"\"\"",
            "    return _makeGetterFactory(",
            "        url, HTTPClientFactory, contextFactory=contextFactory, *args, **kwargs",
            "    ).deferred",
            "",
            "",
            "@deprecated(Version(\"Twisted\", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)",
            "def downloadPage(url, file, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page to a file.",
            "",
            "    @param file: path to file on filesystem, or file-like object.",
            "",
            "    See HTTPDownloader to see what extra args can be passed.",
            "    \"\"\"",
            "    factoryFactory = lambda url, *a, **kw: HTTPDownloader(url, file, *a, **kw)",
            "    return _makeGetterFactory(",
            "        url, factoryFactory, contextFactory=contextFactory, *args, **kwargs",
            "    ).deferred",
            "",
            "",
            "# The code which follows is based on the new HTTP client implementation.  It",
            "# should be significantly better than anything above, though it is not yet",
            "# feature equivalent.",
            "",
            "from twisted.web._newclient import (",
            "    HTTP11ClientProtocol,",
            "    PotentialDataLoss,",
            "    Request,",
            "    RequestGenerationFailed,",
            "    RequestNotSent,",
            "    RequestTransmissionFailed,",
            "    Response,",
            "    ResponseDone,",
            "    ResponseFailed,",
            "    ResponseNeverReceived,",
            "    _WrapperException,",
            ")",
            "from twisted.web.error import SchemeNotSupported",
            "",
            "try:",
            "    from OpenSSL import SSL",
            "except ImportError:",
            "    SSL = None  # type: ignore[assignment]",
            "else:",
            "    from twisted.internet.ssl import (",
            "        CertificateOptions,",
            "        optionsForClientTLS,",
            "        platformTrust,",
            "    )",
            "",
            "",
            "def _requireSSL(decoratee):",
            "    \"\"\"",
            "    The decorated method requires pyOpenSSL to be present, or it raises",
            "    L{NotImplementedError}.",
            "",
            "    @param decoratee: A function which requires pyOpenSSL.",
            "    @type decoratee: L{callable}",
            "",
            "    @return: A function which raises L{NotImplementedError} if pyOpenSSL is not",
            "        installed; otherwise, if it is installed, simply return C{decoratee}.",
            "    @rtype: L{callable}",
            "    \"\"\"",
            "    if SSL is None:",
            "",
            "        @wraps(decoratee)",
            "        def raiseNotImplemented(*a, **kw):",
            "            \"\"\"",
            "            pyOpenSSL is not available.",
            "",
            "            @param a: The positional arguments for C{decoratee}.",
            "",
            "            @param kw: The keyword arguments for C{decoratee}.",
            "",
            "            @raise NotImplementedError: Always.",
            "            \"\"\"",
            "            raise NotImplementedError(\"SSL support unavailable\")",
            "",
            "        return raiseNotImplemented",
            "    return decoratee",
            "",
            "",
            "class WebClientContextFactory:",
            "    \"\"\"",
            "    This class is deprecated.  Please simply use L{Agent} as-is, or if you want",
            "    to customize something, use L{BrowserLikePolicyForHTTPS}.",
            "",
            "    A L{WebClientContextFactory} is an HTTPS policy which totally ignores the",
            "    hostname and port.  It performs basic certificate verification, however the",
            "    lack of validation of service identity (e.g.  hostname validation) means it",
            "    is still vulnerable to man-in-the-middle attacks.  Don't use it any more.",
            "    \"\"\"",
            "",
            "    def _getCertificateOptions(self, hostname, port):",
            "        \"\"\"",
            "        Return a L{CertificateOptions}.",
            "",
            "        @param hostname: ignored",
            "",
            "        @param port: ignored",
            "",
            "        @return: A new CertificateOptions instance.",
            "        @rtype: L{CertificateOptions}",
            "        \"\"\"",
            "        return CertificateOptions(method=SSL.SSLv23_METHOD, trustRoot=platformTrust())",
            "",
            "    @_requireSSL",
            "    def getContext(self, hostname, port):",
            "        \"\"\"",
            "        Return an L{OpenSSL.SSL.Context}.",
            "",
            "        @param hostname: ignored",
            "        @param port: ignored",
            "",
            "        @return: A new SSL context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._getCertificateOptions(hostname, port).getContext()",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class BrowserLikePolicyForHTTPS:",
            "    \"\"\"",
            "    SSL connection creator for web clients.",
            "    \"\"\"",
            "",
            "    def __init__(self, trustRoot=None):",
            "        self._trustRoot = trustRoot",
            "",
            "    @_requireSSL",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        return optionsForClientTLS(hostname.decode(\"ascii\"), trustRoot=self._trustRoot)",
            "",
            "",
            "deprecatedModuleAttribute(",
            "    Version(\"Twisted\", 14, 0, 0),",
            "    getDeprecationWarningString(",
            "        WebClientContextFactory,",
            "        Version(\"Twisted\", 14, 0, 0),",
            "        replacement=BrowserLikePolicyForHTTPS,",
            "    ).split(\"; \")[1],",
            "    WebClientContextFactory.__module__,",
            "    WebClientContextFactory.__name__,",
            ")",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class HostnameCachingHTTPSPolicy:",
            "    \"\"\"",
            "    IPolicyForHTTPS that wraps a L{IPolicyForHTTPS} and caches the created",
            "    L{IOpenSSLClientConnectionCreator}.",
            "",
            "    This policy will cache up to C{cacheSize}",
            "    L{client connection creators <twisted.internet.interfaces.",
            "    IOpenSSLClientConnectionCreator>} for reuse in subsequent requests to",
            "    the same hostname.",
            "",
            "    @ivar _policyForHTTPS: See C{policyforHTTPS} parameter of L{__init__}.",
            "",
            "    @ivar _cache: A cache associating hostnames to their",
            "        L{client connection creators <twisted.internet.interfaces.",
            "        IOpenSSLClientConnectionCreator>}.",
            "    @type _cache: L{collections.OrderedDict}",
            "",
            "    @ivar _cacheSize: See C{cacheSize} parameter of L{__init__}.",
            "",
            "    @since: Twisted 19.2.0",
            "    \"\"\"",
            "",
            "    def __init__(self, policyforHTTPS, cacheSize=20):",
            "        \"\"\"",
            "        @param policyforHTTPS: The IPolicyForHTTPS to wrap.",
            "        @type policyforHTTPS: L{IPolicyForHTTPS}",
            "",
            "        @param cacheSize: The maximum size of the hostname cache.",
            "        @type cacheSize: L{int}",
            "        \"\"\"",
            "        self._policyForHTTPS = policyforHTTPS",
            "        self._cache = collections.OrderedDict()",
            "        self._cacheSize = cacheSize",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location and cache it for future use.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        host = hostname.decode(\"ascii\")",
            "        try:",
            "            creator = self._cache.pop(host)",
            "        except KeyError:",
            "            creator = self._policyForHTTPS.creatorForNetloc(hostname, port)",
            "",
            "        self._cache[host] = creator",
            "        if len(self._cache) > self._cacheSize:",
            "            self._cache.popitem(last=False)",
            "",
            "        return creator",
            "",
            "",
            "@implementer(IOpenSSLContextFactory)",
            "class _ContextFactoryWithContext:",
            "    \"\"\"",
            "    A L{_ContextFactoryWithContext} is like a",
            "    L{twisted.internet.ssl.ContextFactory} with a pre-created context.",
            "",
            "    @ivar _context: A Context.",
            "    @type _context: L{OpenSSL.SSL.Context}",
            "    \"\"\"",
            "",
            "    def __init__(self, context):",
            "        \"\"\"",
            "        Initialize a L{_ContextFactoryWithContext} with a context.",
            "",
            "        @param context: An SSL context.",
            "        @type context: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        self._context = context",
            "",
            "    def getContext(self):",
            "        \"\"\"",
            "        Return the context created by",
            "        L{_DeprecatedToCurrentPolicyForHTTPS._webContextFactory}.",
            "",
            "        @return: A context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._context",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class _DeprecatedToCurrentPolicyForHTTPS:",
            "    \"\"\"",
            "    Adapt a web context factory to a normal context factory.",
            "",
            "    @ivar _webContextFactory: An object providing a getContext method with",
            "        C{hostname} and C{port} arguments.",
            "    @type _webContextFactory: L{WebClientContextFactory} (or object with a",
            "        similar C{getContext} method).",
            "    \"\"\"",
            "",
            "    def __init__(self, webContextFactory):",
            "        \"\"\"",
            "        Wrap a web context factory in an L{IPolicyForHTTPS}.",
            "",
            "        @param webContextFactory: An object providing a getContext method with",
            "            C{hostname} and C{port} arguments.",
            "        @type webContextFactory: L{WebClientContextFactory} (or object with a",
            "            similar C{getContext} method).",
            "        \"\"\"",
            "        self._webContextFactory = webContextFactory",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Called the wrapped web context factory's C{getContext} method with a",
            "        hostname and port number and return the resulting context object.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: A context factory.",
            "        @rtype: L{IOpenSSLContextFactory}",
            "        \"\"\"",
            "        context = self._webContextFactory.getContext(hostname, port)",
            "        return _ContextFactoryWithContext(context)",
            "",
            "",
            "@implementer(IBodyProducer)",
            "class FileBodyProducer:",
            "    \"\"\"",
            "    L{FileBodyProducer} produces bytes from an input file object incrementally",
            "    and writes them to a consumer.",
            "",
            "    Since file-like objects cannot be read from in an event-driven manner,",
            "    L{FileBodyProducer} uses a L{Cooperator} instance to schedule reads from",
            "    the file.  This process is also paused and resumed based on notifications",
            "    from the L{IConsumer} provider being written to.",
            "",
            "    The file is closed after it has been read, or if the producer is stopped",
            "    early.",
            "",
            "    @ivar _inputFile: Any file-like object, bytes read from which will be",
            "        written to a consumer.",
            "",
            "    @ivar _cooperate: A method like L{Cooperator.cooperate} which is used to",
            "        schedule all reads.",
            "",
            "    @ivar _readSize: The number of bytes to read from C{_inputFile} at a time.",
            "    \"\"\"",
            "",
            "    def __init__(self, inputFile, cooperator=task, readSize=2 ** 16):",
            "        self._inputFile = inputFile",
            "        self._cooperate = cooperator.cooperate",
            "        self._readSize = readSize",
            "        self.length = self._determineLength(inputFile)",
            "",
            "    def _determineLength(self, fObj):",
            "        \"\"\"",
            "        Determine how many bytes can be read out of C{fObj} (assuming it is not",
            "        modified from this point on).  If the determination cannot be made,",
            "        return C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        try:",
            "            seek = fObj.seek",
            "            tell = fObj.tell",
            "        except AttributeError:",
            "            return UNKNOWN_LENGTH",
            "        originalPosition = tell()",
            "        seek(0, os.SEEK_END)",
            "        end = tell()",
            "        seek(originalPosition, os.SEEK_SET)",
            "        return end - originalPosition",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Permanently stop writing bytes from the file to the consumer by",
            "        stopping the underlying L{CooperativeTask}.",
            "        \"\"\"",
            "        self._inputFile.close()",
            "        try:",
            "            self._task.stop()",
            "        except task.TaskFinished:",
            "            pass",
            "",
            "    def startProducing(self, consumer):",
            "        \"\"\"",
            "        Start a cooperative task which will read bytes from the input file and",
            "        write them to C{consumer}.  Return a L{Deferred} which fires after all",
            "        bytes have been written.  If this L{Deferred} is cancelled before it is",
            "        fired, stop reading and writing bytes.",
            "",
            "        @param consumer: Any L{IConsumer} provider",
            "        \"\"\"",
            "        self._task = self._cooperate(self._writeloop(consumer))",
            "        d = self._task.whenDone()",
            "",
            "        def maybeStopped(reason):",
            "            if reason.check(defer.CancelledError):",
            "                self.stopProducing()",
            "            elif reason.check(task.TaskStopped):",
            "                pass",
            "            else:",
            "                return reason",
            "            # IBodyProducer.startProducing's Deferred isn't supposed to fire if",
            "            # stopProducing is called.",
            "            return defer.Deferred()",
            "",
            "        d.addCallbacks(lambda ignored: None, maybeStopped)",
            "        return d",
            "",
            "    def _writeloop(self, consumer):",
            "        \"\"\"",
            "        Return an iterator which reads one chunk of bytes from the input file",
            "        and writes them to the consumer for each time it is iterated.",
            "        \"\"\"",
            "        while True:",
            "            bytes = self._inputFile.read(self._readSize)",
            "            if not bytes:",
            "                self._inputFile.close()",
            "                break",
            "            consumer.write(bytes)",
            "            yield None",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Temporarily suspend copying bytes from the input file to the consumer",
            "        by pausing the L{CooperativeTask} which drives that activity.",
            "        \"\"\"",
            "        self._task.pause()",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Undo the effects of a previous C{pauseProducing} and resume copying",
            "        bytes to the consumer by resuming the L{CooperativeTask} which drives",
            "        the write activity.",
            "        \"\"\"",
            "        self._task.resume()",
            "",
            "",
            "class _HTTP11ClientFactory(protocol.Factory):",
            "    \"\"\"",
            "    A factory for L{HTTP11ClientProtocol}, used by L{HTTPConnectionPool}.",
            "",
            "    @ivar _quiescentCallback: The quiescent callback to be passed to protocol",
            "        instances, used to return them to the connection pool.",
            "",
            "    @ivar _metadata: Metadata about the low-level connection details,",
            "        used to make the repr more useful.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, quiescentCallback, metadata):",
            "        self._quiescentCallback = quiescentCallback",
            "        self._metadata = metadata",
            "",
            "    def __repr__(self) -> str:",
            "        return \"_HTTP11ClientFactory({}, {})\".format(",
            "            self._quiescentCallback, self._metadata",
            "        )",
            "",
            "    def buildProtocol(self, addr):",
            "        return HTTP11ClientProtocol(self._quiescentCallback)",
            "",
            "",
            "class _RetryingHTTP11ClientProtocol:",
            "    \"\"\"",
            "    A wrapper for L{HTTP11ClientProtocol} that automatically retries requests.",
            "",
            "    @ivar _clientProtocol: The underlying L{HTTP11ClientProtocol}.",
            "",
            "    @ivar _newConnection: A callable that creates a new connection for a",
            "        retry.",
            "    \"\"\"",
            "",
            "    def __init__(self, clientProtocol, newConnection):",
            "        self._clientProtocol = clientProtocol",
            "        self._newConnection = newConnection",
            "",
            "    def _shouldRetry(self, method, exception, bodyProducer):",
            "        \"\"\"",
            "        Indicate whether request should be retried.",
            "",
            "        Only returns C{True} if method is idempotent, no response was",
            "        received, the reason for the failed request was not due to",
            "        user-requested cancellation, and no body was sent. The latter",
            "        requirement may be relaxed in the future, and PUT added to approved",
            "        method list.",
            "",
            "        @param method: The method of the request.",
            "        @type method: L{bytes}",
            "        \"\"\"",
            "        if method not in (b\"GET\", b\"HEAD\", b\"OPTIONS\", b\"DELETE\", b\"TRACE\"):",
            "            return False",
            "        if not isinstance(",
            "            exception,",
            "            (RequestNotSent, RequestTransmissionFailed, ResponseNeverReceived),",
            "        ):",
            "            return False",
            "        if isinstance(exception, _WrapperException):",
            "            for aFailure in exception.reasons:",
            "                if aFailure.check(defer.CancelledError):",
            "                    return False",
            "        if bodyProducer is not None:",
            "            return False",
            "        return True",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Do a request, and retry once (with a new connection) if it fails in",
            "        a retryable manner.",
            "",
            "        @param request: A L{Request} instance that will be requested using the",
            "            wrapped protocol.",
            "        \"\"\"",
            "        d = self._clientProtocol.request(request)",
            "",
            "        def failed(reason):",
            "            if self._shouldRetry(request.method, reason.value, request.bodyProducer):",
            "                return self._newConnection().addCallback(",
            "                    lambda connection: connection.request(request)",
            "                )",
            "            else:",
            "                return reason",
            "",
            "        d.addErrback(failed)",
            "        return d",
            "",
            "",
            "class HTTPConnectionPool:",
            "    \"\"\"",
            "    A pool of persistent HTTP connections.",
            "",
            "    Features:",
            "     - Cached connections will eventually time out.",
            "     - Limits on maximum number of persistent connections.",
            "",
            "    Connections are stored using keys, which should be chosen such that any",
            "    connections stored under a given key can be used interchangeably.",
            "",
            "    Failed requests done using previously cached connections will be retried",
            "    once if they use an idempotent method (e.g. GET), in case the HTTP server",
            "    timed them out.",
            "",
            "    @ivar persistent: Boolean indicating whether connections should be",
            "        persistent. Connections are persistent by default.",
            "",
            "    @ivar maxPersistentPerHost: The maximum number of cached persistent",
            "        connections for a C{host:port} destination.",
            "    @type maxPersistentPerHost: C{int}",
            "",
            "    @ivar cachedConnectionTimeout: Number of seconds a cached persistent",
            "        connection will stay open before disconnecting.",
            "",
            "    @ivar retryAutomatically: C{boolean} indicating whether idempotent",
            "        requests should be retried once if no response was received.",
            "",
            "    @ivar _factory: The factory used to connect to the proxy.",
            "",
            "    @ivar _connections: Map (scheme, host, port) to lists of",
            "        L{HTTP11ClientProtocol} instances.",
            "",
            "    @ivar _timeouts: Map L{HTTP11ClientProtocol} instances to a",
            "        C{IDelayedCall} instance of their timeout.",
            "",
            "    @since: 12.1",
            "    \"\"\"",
            "",
            "    _factory = _HTTP11ClientFactory",
            "    maxPersistentPerHost = 2",
            "    cachedConnectionTimeout = 240",
            "    retryAutomatically = True",
            "    _log = Logger()",
            "",
            "    def __init__(self, reactor, persistent=True):",
            "        self._reactor = reactor",
            "        self.persistent = persistent",
            "        self._connections = {}",
            "        self._timeouts = {}",
            "",
            "    def getConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Supply a connection, newly created or retrieved from the pool, to be",
            "        used for one HTTP request.",
            "",
            "        The connection will remain out of the pool (not available to be",
            "        returned from future calls to this method) until one HTTP request has",
            "        been completed over it.",
            "",
            "        Afterwards, if the connection is still open, it will automatically be",
            "        added to the pool.",
            "",
            "        @param key: A unique key identifying connections that can be used",
            "            interchangeably.",
            "",
            "        @param endpoint: An endpoint that can be used to open a new connection",
            "            if no cached connection is available.",
            "",
            "        @return: A C{Deferred} that will fire with a L{HTTP11ClientProtocol}",
            "           (or a wrapper) that can be used to send a single HTTP request.",
            "        \"\"\"",
            "        # Try to get cached version:",
            "        connections = self._connections.get(key)",
            "        while connections:",
            "            connection = connections.pop(0)",
            "            # Cancel timeout:",
            "            self._timeouts[connection].cancel()",
            "            del self._timeouts[connection]",
            "            if connection.state == \"QUIESCENT\":",
            "                if self.retryAutomatically:",
            "                    newConnection = lambda: self._newConnection(key, endpoint)",
            "                    connection = _RetryingHTTP11ClientProtocol(",
            "                        connection, newConnection",
            "                    )",
            "                return defer.succeed(connection)",
            "",
            "        return self._newConnection(key, endpoint)",
            "",
            "    def _newConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Create a new connection.",
            "",
            "        This implements the new connection code path for L{getConnection}.",
            "        \"\"\"",
            "",
            "        def quiescentCallback(protocol):",
            "            self._putConnection(key, protocol)",
            "",
            "        factory = self._factory(quiescentCallback, repr(endpoint))",
            "        return endpoint.connect(factory)",
            "",
            "    def _removeConnection(self, key, connection):",
            "        \"\"\"",
            "        Remove a connection from the cache and disconnect it.",
            "        \"\"\"",
            "        connection.transport.loseConnection()",
            "        self._connections[key].remove(connection)",
            "        del self._timeouts[connection]",
            "",
            "    def _putConnection(self, key, connection):",
            "        \"\"\"",
            "        Return a persistent connection to the pool. This will be called by",
            "        L{HTTP11ClientProtocol} when the connection becomes quiescent.",
            "        \"\"\"",
            "        if connection.state != \"QUIESCENT\":",
            "            # Log with traceback for debugging purposes:",
            "            try:",
            "                raise RuntimeError(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\"",
            "                )",
            "            except BaseException:",
            "                self._log.failure(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\"",
            "                )",
            "            return",
            "        connections = self._connections.setdefault(key, [])",
            "        if len(connections) == self.maxPersistentPerHost:",
            "            dropped = connections.pop(0)",
            "            dropped.transport.loseConnection()",
            "            self._timeouts[dropped].cancel()",
            "            del self._timeouts[dropped]",
            "        connections.append(connection)",
            "        cid = self._reactor.callLater(",
            "            self.cachedConnectionTimeout, self._removeConnection, key, connection",
            "        )",
            "        self._timeouts[connection] = cid",
            "",
            "    def closeCachedConnections(self):",
            "        \"\"\"",
            "        Close all persistent connections and remove them from the pool.",
            "",
            "        @return: L{defer.Deferred} that fires when all connections have been",
            "            closed.",
            "        \"\"\"",
            "        results = []",
            "        for protocols in self._connections.values():",
            "            for p in protocols:",
            "                results.append(p.abort())",
            "        self._connections = {}",
            "        for dc in self._timeouts.values():",
            "            dc.cancel()",
            "        self._timeouts = {}",
            "        return defer.gatherResults(results).addCallback(lambda ign: None)",
            "",
            "",
            "class _AgentBase:",
            "    \"\"\"",
            "    Base class offering common facilities for L{Agent}-type classes.",
            "",
            "    @ivar _reactor: The C{IReactorTime} implementation which will be used by",
            "        the pool, and perhaps by subclasses as well.",
            "",
            "    @ivar _pool: The L{HTTPConnectionPool} used to manage HTTP connections.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, pool):",
            "        if pool is None:",
            "            pool = HTTPConnectionPool(reactor, False)",
            "        self._reactor = reactor",
            "        self._pool = pool",
            "",
            "    def _computeHostValue(self, scheme, host, port):",
            "        \"\"\"",
            "        Compute the string to use for the value of the I{Host} header, based on",
            "        the given scheme, host name, and port number.",
            "        \"\"\"",
            "        if isIPv6Address(nativeString(host)):",
            "            host = b\"[\" + host + b\"]\"",
            "        if (scheme, port) in ((b\"http\", 80), (b\"https\", 443)):",
            "            return host",
            "        return b\"%b:%d\" % (host, port)",
            "",
            "    def _requestWithEndpoint(",
            "        self, key, endpoint, method, parsedURI, headers, bodyProducer, requestPath",
            "    ):",
            "        \"\"\"",
            "        Issue a new request, given the endpoint and the path sent as part of",
            "        the request.",
            "        \"\"\"",
            "        if not isinstance(method, bytes):",
            "            raise TypeError(f\"method={method!r} is {type(method)}, but must be bytes\")",
            "",
            "        method = _ensureValidMethod(method)",
            "",
            "        # Create minimal headers, if necessary:",
            "        if headers is None:",
            "            headers = Headers()",
            "        if not headers.hasHeader(b\"host\"):",
            "            headers = headers.copy()",
            "            headers.addRawHeader(",
            "                b\"host\",",
            "                self._computeHostValue(",
            "                    parsedURI.scheme, parsedURI.host, parsedURI.port",
            "                ),",
            "            )",
            "",
            "        d = self._pool.getConnection(key, endpoint)",
            "",
            "        def cbConnected(proto):",
            "            return proto.request(",
            "                Request._construct(",
            "                    method,",
            "                    requestPath,",
            "                    headers,",
            "                    bodyProducer,",
            "                    persistent=self._pool.persistent,",
            "                    parsedURI=parsedURI,",
            "                )",
            "            )",
            "",
            "        d.addCallback(cbConnected)",
            "        return d",
            "",
            "",
            "@implementer(IAgentEndpointFactory)",
            "class _StandardEndpointFactory:",
            "    \"\"\"",
            "    Standard HTTP endpoint destinations - TCP for HTTP, TCP+TLS for HTTPS.",
            "",
            "    @ivar _policyForHTTPS: A web context factory which will be used to create",
            "        SSL context objects for any SSL connections the agent needs to make.",
            "",
            "    @ivar _connectTimeout: If not L{None}, the timeout passed to",
            "        L{HostnameEndpoint} for specifying the connection timeout.",
            "",
            "    @ivar _bindAddress: If not L{None}, the address passed to",
            "        L{HostnameEndpoint} for specifying the local address to bind to.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, contextFactory, connectTimeout, bindAddress):",
            "        \"\"\"",
            "        @param reactor: A provider to use to create endpoints.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float} or L{None}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes} or L{None}",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._policyForHTTPS = contextFactory",
            "        self._connectTimeout = connectTimeout",
            "        self._bindAddress = bindAddress",
            "",
            "    def endpointForURI(self, uri):",
            "        \"\"\"",
            "        Connect directly over TCP for C{b'http'} scheme, and TLS for",
            "        C{b'https'}.",
            "",
            "        @param uri: L{URI} to connect to.",
            "",
            "        @return: Endpoint to connect to.",
            "        @rtype: L{IStreamClientEndpoint}",
            "        \"\"\"",
            "        kwargs = {}",
            "        if self._connectTimeout is not None:",
            "            kwargs[\"timeout\"] = self._connectTimeout",
            "        kwargs[\"bindAddress\"] = self._bindAddress",
            "",
            "        try:",
            "            host = nativeString(uri.host)",
            "        except UnicodeDecodeError:",
            "            raise ValueError(",
            "                (",
            "                    \"The host of the provided URI ({uri.host!r}) \"",
            "                    \"contains non-ASCII octets, it should be ASCII \"",
            "                    \"decodable.\"",
            "                ).format(uri=uri)",
            "            )",
            "",
            "        endpoint = HostnameEndpoint(self._reactor, host, uri.port, **kwargs)",
            "        if uri.scheme == b\"http\":",
            "            return endpoint",
            "        elif uri.scheme == b\"https\":",
            "            connectionCreator = self._policyForHTTPS.creatorForNetloc(",
            "                uri.host, uri.port",
            "            )",
            "            return wrapClientTLS(connectionCreator, endpoint)",
            "        else:",
            "            raise SchemeNotSupported(f\"Unsupported scheme: {uri.scheme!r}\")",
            "",
            "",
            "@implementer(IAgent)",
            "class Agent(_AgentBase):",
            "    \"\"\"",
            "    L{Agent} is a very basic HTTP client.  It supports I{HTTP} and I{HTTPS}",
            "    scheme URIs.",
            "",
            "    @ivar _pool: An L{HTTPConnectionPool} instance.",
            "",
            "    @ivar _endpointFactory: The L{IAgentEndpointFactory} which will",
            "        be used to create endpoints for outgoing connections.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor,",
            "        contextFactory=BrowserLikePolicyForHTTPS(),",
            "        connectTimeout=None,",
            "        bindAddress=None,",
            "        pool=None,",
            "    ):",
            "        \"\"\"",
            "        Create an L{Agent}.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.  The default is to use a",
            "            L{BrowserLikePolicyForHTTPS}, so unless you have special",
            "            requirements you can leave this as-is.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes}",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "        \"\"\"",
            "        if not IPolicyForHTTPS.providedBy(contextFactory):",
            "            warnings.warn(",
            "                repr(contextFactory)",
            "                + \" was passed as the HTTPS policy for an Agent, but it does \"",
            "                \"not provide IPolicyForHTTPS.  Since Twisted 14.0, you must \"",
            "                \"pass a provider of IPolicyForHTTPS.\",",
            "                stacklevel=2,",
            "                category=DeprecationWarning,",
            "            )",
            "            contextFactory = _DeprecatedToCurrentPolicyForHTTPS(contextFactory)",
            "        endpointFactory = _StandardEndpointFactory(",
            "            reactor, contextFactory, connectTimeout, bindAddress",
            "        )",
            "        self._init(reactor, endpointFactory, pool)",
            "",
            "    @classmethod",
            "    def usingEndpointFactory(cls, reactor, endpointFactory, pool=None):",
            "        \"\"\"",
            "        Create a new L{Agent} that will use the endpoint factory to figure",
            "        out how to connect to the server.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param endpointFactory: Used to construct endpoints which the",
            "            HTTP client will connect with.",
            "        @type endpointFactory: an L{IAgentEndpointFactory} provider.",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "",
            "        @return: A new L{Agent}.",
            "        \"\"\"",
            "        agent = cls.__new__(cls)",
            "        agent._init(reactor, endpointFactory, pool)",
            "        return agent",
            "",
            "    def _init(self, reactor, endpointFactory, pool):",
            "        \"\"\"",
            "        Initialize a new L{Agent}.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param endpointFactory: Used to construct endpoints which the",
            "            HTTP client will connect with.",
            "        @type endpointFactory: an L{IAgentEndpointFactory} provider.",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "",
            "        @return: A new L{Agent}.",
            "        \"\"\"",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._endpointFactory = endpointFactory",
            "",
            "    def _getEndpoint(self, uri):",
            "        \"\"\"",
            "        Get an endpoint for the given URI, using C{self._endpointFactory}.",
            "",
            "        @param uri: The URI of the request.",
            "        @type uri: L{URI}",
            "",
            "        @return: An endpoint which can be used to connect to given address.",
            "        \"\"\"",
            "        return self._endpointFactory.endpointForURI(uri)",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a request to the server indicated by the given C{uri}.",
            "",
            "        An existing connection from the connection pool may be used or a new",
            "        one may be created.",
            "",
            "        I{HTTP} and I{HTTPS} schemes are supported in C{uri}.",
            "",
            "        @see: L{twisted.web.iweb.IAgent.request}",
            "        \"\"\"",
            "        uri = _ensureValidURI(uri.strip())",
            "        parsedURI = URI.fromBytes(uri)",
            "        try:",
            "            endpoint = self._getEndpoint(parsedURI)",
            "        except SchemeNotSupported:",
            "            return defer.fail(Failure())",
            "        key = (parsedURI.scheme, parsedURI.host, parsedURI.port)",
            "        return self._requestWithEndpoint(",
            "            key,",
            "            endpoint,",
            "            method,",
            "            parsedURI,",
            "            headers,",
            "            bodyProducer,",
            "            parsedURI.originForm,",
            "        )",
            "",
            "",
            "@implementer(IAgent)",
            "class ProxyAgent(_AgentBase):",
            "    \"\"\"",
            "    An HTTP agent able to cross HTTP proxies.",
            "",
            "    @ivar _proxyEndpoint: The endpoint used to connect to the proxy.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, endpoint, reactor=None, pool=None):",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._proxyEndpoint = endpoint",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request via the configured proxy.",
            "        \"\"\"",
            "        uri = _ensureValidURI(uri.strip())",
            "",
            "        # Cache *all* connections under the same key, since we are only",
            "        # connecting to a single destination, the proxy:",
            "        key = (\"http-proxy\", self._proxyEndpoint)",
            "",
            "        # To support proxying HTTPS via CONNECT, we will use key",
            "        # (\"http-proxy-CONNECT\", scheme, host, port), and an endpoint that",
            "        # wraps _proxyEndpoint with an additional callback to do the CONNECT.",
            "        return self._requestWithEndpoint(",
            "            key,",
            "            self._proxyEndpoint,",
            "            method,",
            "            URI.fromBytes(uri),",
            "            headers,",
            "            bodyProducer,",
            "            uri,",
            "        )",
            "",
            "",
            "class _FakeUrllib2Request:",
            "    \"\"\"",
            "    A fake C{urllib2.Request} object for C{cookielib} to work with.",
            "",
            "    @see: U{http://docs.python.org/library/urllib2.html#request-objects}",
            "",
            "    @type uri: native L{str}",
            "    @ivar uri: Request URI.",
            "",
            "    @type headers: L{twisted.web.http_headers.Headers}",
            "    @ivar headers: Request headers.",
            "",
            "    @type type: native L{str}",
            "    @ivar type: The scheme of the URI.",
            "",
            "    @type host: native L{str}",
            "    @ivar host: The host[:port] of the URI.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, uri):",
            "        \"\"\"",
            "        Create a fake Urllib2 request.",
            "",
            "        @param uri: Request URI.",
            "        @type uri: L{bytes}",
            "        \"\"\"",
            "        self.uri = nativeString(uri)",
            "        self.headers = Headers()",
            "",
            "        _uri = URI.fromBytes(uri)",
            "        self.type = nativeString(_uri.scheme)",
            "        self.host = nativeString(_uri.host)",
            "",
            "        if (_uri.scheme, _uri.port) not in ((b\"http\", 80), (b\"https\", 443)):",
            "            # If it's not a schema on the regular port, add the port.",
            "            self.host += \":\" + str(_uri.port)",
            "",
            "        self.origin_req_host = nativeString(_uri.host)",
            "        self.unverifiable = lambda _: False",
            "",
            "    def has_header(self, header):",
            "        return self.headers.hasHeader(networkString(header))",
            "",
            "    def add_unredirected_header(self, name, value):",
            "        self.headers.addRawHeader(networkString(name), networkString(value))",
            "",
            "    def get_full_url(self):",
            "        return self.uri",
            "",
            "    def get_header(self, name, default=None):",
            "        headers = self.headers.getRawHeaders(networkString(name), default)",
            "        if headers is not None:",
            "            headers = [nativeString(x) for x in headers]",
            "            return headers[0]",
            "        return None",
            "",
            "    def get_host(self):",
            "        return self.host",
            "",
            "    def get_type(self):",
            "        return self.type",
            "",
            "    def is_unverifiable(self):",
            "        # In theory this shouldn't be hardcoded.",
            "        return False",
            "",
            "",
            "class _FakeUrllib2Response:",
            "    \"\"\"",
            "    A fake C{urllib2.Response} object for C{cookielib} to work with.",
            "",
            "    @type response: C{twisted.web.iweb.IResponse}",
            "    @ivar response: Underlying Twisted Web response.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.response = response",
            "",
            "    def info(self):",
            "        class _Meta:",
            "            def getheaders(zelf, name):",
            "                # PY2",
            "                headers = self.response.headers.getRawHeaders(name, [])",
            "                return headers",
            "",
            "            def get_all(zelf, name, default):",
            "                # PY3",
            "                headers = self.response.headers.getRawHeaders(",
            "                    networkString(name), default",
            "                )",
            "                h = [nativeString(x) for x in headers]",
            "                return h",
            "",
            "        return _Meta()",
            "",
            "",
            "@implementer(IAgent)",
            "class CookieAgent:",
            "    \"\"\"",
            "    L{CookieAgent} extends the basic L{Agent} to add RFC-compliant",
            "    handling of HTTP cookies.  Cookies are written to and extracted",
            "    from a C{cookielib.CookieJar} instance.",
            "",
            "    The same cookie jar instance will be used for any requests through this",
            "    agent, mutating it whenever a I{Set-Cookie} header appears in a response.",
            "",
            "    @type _agent: L{twisted.web.client.Agent}",
            "    @ivar _agent: Underlying Twisted Web agent to issue requests through.",
            "",
            "    @type cookieJar: C{cookielib.CookieJar}",
            "    @ivar cookieJar: Initialized cookie jar to read cookies from and store",
            "        cookies to.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, cookieJar):",
            "        self._agent = agent",
            "        self.cookieJar = cookieJar",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request to the wrapped L{Agent}.",
            "",
            "        Send a I{Cookie} header if a cookie for C{uri} is stored in",
            "        L{CookieAgent.cookieJar}. Cookies are automatically extracted and",
            "        stored from requests.",
            "",
            "        If a C{'cookie'} header appears in C{headers} it will override the",
            "        automatic cookie header obtained from the cookie jar.",
            "",
            "        @see: L{Agent.request}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        lastRequest = _FakeUrllib2Request(uri)",
            "        # Setting a cookie header explicitly will disable automatic request",
            "        # cookies.",
            "        if not headers.hasHeader(b\"cookie\"):",
            "            self.cookieJar.add_cookie_header(lastRequest)",
            "            cookieHeader = lastRequest.get_header(\"Cookie\", None)",
            "            if cookieHeader is not None:",
            "                headers = headers.copy()",
            "                headers.addRawHeader(b\"cookie\", networkString(cookieHeader))",
            "",
            "        d = self._agent.request(method, uri, headers, bodyProducer)",
            "        d.addCallback(self._extractCookies, lastRequest)",
            "        return d",
            "",
            "    def _extractCookies(self, response, request):",
            "        \"\"\"",
            "        Extract response cookies and store them in the cookie jar.",
            "",
            "        @type response: L{twisted.web.iweb.IResponse}",
            "        @param response: Twisted Web response.",
            "",
            "        @param request: A urllib2 compatible request object.",
            "        \"\"\"",
            "        resp = _FakeUrllib2Response(response)",
            "        self.cookieJar.extract_cookies(resp, request)",
            "        return response",
            "",
            "",
            "class GzipDecoder(proxyForInterface(IResponse)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A wrapper for a L{Response} instance which handles gzip'ed body.",
            "",
            "    @ivar original: The original L{Response} object.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.original = response",
            "        self.length = UNKNOWN_LENGTH",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Override C{deliverBody} to wrap the given C{protocol} with",
            "        L{_GzipProtocol}.",
            "        \"\"\"",
            "        self.original.deliverBody(_GzipProtocol(protocol, self.original))",
            "",
            "",
            "class _GzipProtocol(proxyForInterface(IProtocol)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A L{Protocol} implementation which wraps another one, transparently",
            "    decompressing received data.",
            "",
            "    @ivar _zlibDecompress: A zlib decompress object used to decompress the data",
            "        stream.",
            "",
            "    @ivar _response: A reference to the original response, in case of errors.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, protocol, response):",
            "        self.original = protocol",
            "        self._response = response",
            "        self._zlibDecompress = zlib.decompressobj(16 + zlib.MAX_WBITS)",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Decompress C{data} with the zlib decompressor, forwarding the raw data",
            "        to the original protocol.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.decompress(data)",
            "        except zlib.error:",
            "            raise ResponseFailed([Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Forward the connection lost event, flushing remaining data from the",
            "        decompressor if any.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.flush()",
            "        except zlib.error:",
            "            raise ResponseFailed([reason, Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "        self.original.connectionLost(reason)",
            "",
            "",
            "@implementer(IAgent)",
            "class ContentDecoderAgent:",
            "    \"\"\"",
            "    An L{Agent} wrapper to handle encoded content.",
            "",
            "    It takes care of declaring the support for content in the",
            "    I{Accept-Encoding} header and automatically decompresses the received data",
            "    if the I{Content-Encoding} header indicates a supported encoding.",
            "",
            "    For example::",
            "",
            "        agent = ContentDecoderAgent(Agent(reactor),",
            "                                    [(b'gzip', GzipDecoder)])",
            "",
            "    @param agent: The agent to wrap",
            "    @type agent: L{IAgent}",
            "",
            "    @param decoders: A sequence of (name, decoder) objects. The name",
            "        declares which encoding the decoder supports. The decoder must accept",
            "        an L{IResponse} and return an L{IResponse} when called. The order",
            "        determines how the decoders are advertised to the server. Names must",
            "        be unique.not be duplicated.",
            "    @type decoders: sequence of (L{bytes}, L{callable}) tuples",
            "",
            "    @since: 11.1",
            "",
            "    @see: L{GzipDecoder}",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, decoders):",
            "        self._agent = agent",
            "        self._decoders = dict(decoders)",
            "        self._supported = b\",\".join([decoder[0] for decoder in decoders])",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request which declares supporting compressed content.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        else:",
            "            headers = headers.copy()",
            "        headers.addRawHeader(b\"accept-encoding\", self._supported)",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse)",
            "",
            "    def _handleResponse(self, response):",
            "        \"\"\"",
            "        Check if the response is encoded, and wrap it to handle decompression.",
            "        \"\"\"",
            "        contentEncodingHeaders = response.headers.getRawHeaders(b\"content-encoding\", [])",
            "        contentEncodingHeaders = b\",\".join(contentEncodingHeaders).split(b\",\")",
            "        while contentEncodingHeaders:",
            "            name = contentEncodingHeaders.pop().strip()",
            "            decoder = self._decoders.get(name)",
            "            if decoder is not None:",
            "                response = decoder(response)",
            "            else:",
            "                # Add it back",
            "                contentEncodingHeaders.append(name)",
            "                break",
            "        if contentEncodingHeaders:",
            "            response.headers.setRawHeaders(",
            "                b\"content-encoding\", [b\",\".join(contentEncodingHeaders)]",
            "            )",
            "        else:",
            "            response.headers.removeHeader(b\"content-encoding\")",
            "        return response",
            "",
            "",
            "@implementer(IAgent)",
            "class RedirectAgent:",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects.",
            "",
            "    The implementation is rather strict: 301 and 302 behaves like 307, not",
            "    redirecting automatically on methods different from I{GET} and I{HEAD}.",
            "",
            "    See L{BrowserLikeRedirectAgent} for a redirecting Agent that behaves more",
            "    like a web browser.",
            "",
            "    @param redirectLimit: The maximum number of times the agent is allowed to",
            "        follow redirects before failing with a L{error.InfiniteRedirection}.",
            "",
            "    @cvar _redirectResponses: A L{list} of HTTP status codes to be redirected",
            "        for I{GET} and I{HEAD} methods.",
            "",
            "    @cvar _seeOtherResponses: A L{list} of HTTP status codes to be redirected",
            "        for any method and the method altered to I{GET}.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [",
            "        http.MOVED_PERMANENTLY,",
            "        http.FOUND,",
            "        http.TEMPORARY_REDIRECT,",
            "        http.PERMANENT_REDIRECT,",
            "    ]",
            "    _seeOtherResponses = [http.SEE_OTHER]",
            "",
            "    def __init__(self, agent, redirectLimit=20):",
            "        self._agent = agent",
            "        self._redirectLimit = redirectLimit",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request following HTTP redirects.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse, method, uri, headers, 0)",
            "",
            "    def _resolveLocation(self, requestURI, location):",
            "        \"\"\"",
            "        Resolve the redirect location against the request I{URI}.",
            "",
            "        @type requestURI: C{bytes}",
            "        @param requestURI: The request I{URI}.",
            "",
            "        @type location: C{bytes}",
            "        @param location: The redirect location.",
            "",
            "        @rtype: C{bytes}",
            "        @return: Final resolved I{URI}.",
            "        \"\"\"",
            "        return _urljoin(requestURI, location)",
            "",
            "    def _handleRedirect(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle a redirect response, checking the number of redirects already",
            "        followed, and extracting the location header fields.",
            "        \"\"\"",
            "        if redirectCount >= self._redirectLimit:",
            "            err = error.InfiniteRedirection(",
            "                response.code, b\"Infinite redirection detected\", location=uri",
            "            )",
            "            raise ResponseFailed([Failure(err)], response)",
            "        locationHeaders = response.headers.getRawHeaders(b\"location\", [])",
            "        if not locationHeaders:",
            "            err = error.RedirectWithNoLocation(",
            "                response.code, b\"No location header field\", uri",
            "            )",
            "            raise ResponseFailed([Failure(err)], response)",
            "        location = self._resolveLocation(uri, locationHeaders[0])",
            "        deferred = self._agent.request(method, location, headers)",
            "",
            "        def _chainResponse(newResponse):",
            "            newResponse.setPreviousResponse(response)",
            "            return newResponse",
            "",
            "        deferred.addCallback(_chainResponse)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, redirectCount + 1",
            "        )",
            "",
            "    def _handleResponse(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle the response, making another request if it indicates a redirect.",
            "        \"\"\"",
            "        if response.code in self._redirectResponses:",
            "            if method not in (b\"GET\", b\"HEAD\"):",
            "                err = error.PageRedirect(response.code, location=uri)",
            "                raise ResponseFailed([Failure(err)], response)",
            "            return self._handleRedirect(response, method, uri, headers, redirectCount)",
            "        elif response.code in self._seeOtherResponses:",
            "            return self._handleRedirect(response, b\"GET\", uri, headers, redirectCount)",
            "        return response",
            "",
            "",
            "class BrowserLikeRedirectAgent(RedirectAgent):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects in the same fashion as web",
            "    browsers.",
            "",
            "    Unlike L{RedirectAgent}, the implementation is more relaxed: 301 and 302",
            "    behave like 303, redirecting automatically on any method and altering the",
            "    redirect request to a I{GET}.",
            "",
            "    @see: L{RedirectAgent}",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [",
            "        http.MOVED_PERMANENTLY,",
            "        http.FOUND,",
            "        http.SEE_OTHER,",
            "        http.PERMANENT_REDIRECT,",
            "    ]",
            "",
            "",
            "class _ReadBodyProtocol(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol that collects data sent to it.",
            "",
            "    This is a helper for L{IResponse.deliverBody}, which collects the body and",
            "    fires a deferred with it.",
            "",
            "    @ivar deferred: See L{__init__}.",
            "    @ivar status: See L{__init__}.",
            "    @ivar message: See L{__init__}.",
            "",
            "    @ivar dataBuffer: list of byte-strings received",
            "    @type dataBuffer: L{list} of L{bytes}",
            "    \"\"\"",
            "",
            "    def __init__(self, status, message, deferred):",
            "        \"\"\"",
            "        @param status: Status of L{IResponse}",
            "        @ivar status: L{int}",
            "",
            "        @param message: Message of L{IResponse}",
            "        @type message: L{bytes}",
            "",
            "        @param deferred: deferred to fire when response is complete",
            "        @type deferred: L{Deferred} firing with L{bytes}",
            "        \"\"\"",
            "        self.deferred = deferred",
            "        self.status = status",
            "        self.message = message",
            "        self.dataBuffer = []",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Accumulate some more bytes from the response.",
            "        \"\"\"",
            "        self.dataBuffer.append(data)",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Deliver the accumulated response bytes to the waiting L{Deferred}, if",
            "        the response body has been completely received without error.",
            "        \"\"\"",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(b\"\".join(self.dataBuffer))",
            "        elif reason.check(PotentialDataLoss):",
            "            self.deferred.errback(",
            "                PartialDownloadError(",
            "                    self.status, self.message, b\"\".join(self.dataBuffer)",
            "                )",
            "            )",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def readBody(response: IResponse) -> defer.Deferred[bytes]:",
            "    \"\"\"",
            "    Get the body of an L{IResponse} and return it as a byte string.",
            "",
            "    This is a helper function for clients that don't want to incrementally",
            "    receive the body of an HTTP response.",
            "",
            "    @param response: The HTTP response for which the body will be read.",
            "    @type response: L{IResponse} provider",
            "",
            "    @return: A L{Deferred} which will fire with the body of the response.",
            "        Cancelling it will close the connection to the server immediately.",
            "    \"\"\"",
            "",
            "    def cancel(deferred: defer.Deferred) -> None:",
            "        \"\"\"",
            "        Cancel a L{readBody} call, close the connection to the HTTP server",
            "        immediately, if it is still open.",
            "",
            "        @param deferred: The cancelled L{defer.Deferred}.",
            "        \"\"\"",
            "        abort = getAbort()",
            "        if abort is not None:",
            "            abort()",
            "",
            "    d: defer.Deferred[bytes] = defer.Deferred(cancel)",
            "    protocol = _ReadBodyProtocol(response.code, response.phrase, d)",
            "",
            "    def getAbort():",
            "        return getattr(protocol.transport, \"abortConnection\", None)",
            "",
            "    response.deliverBody(protocol)",
            "",
            "    if protocol.transport is not None and getAbort() is None:",
            "        warnings.warn(",
            "            \"Using readBody with a transport that does not have an \"",
            "            \"abortConnection method\",",
            "            category=DeprecationWarning,",
            "            stacklevel=2,",
            "        )",
            "",
            "    return d",
            "",
            "",
            "__all__ = [",
            "    \"Agent\",",
            "    \"BrowserLikePolicyForHTTPS\",",
            "    \"BrowserLikeRedirectAgent\",",
            "    \"ContentDecoderAgent\",",
            "    \"CookieAgent\",",
            "    \"downloadPage\",",
            "    \"getPage\",",
            "    \"GzipDecoder\",",
            "    \"HTTPClientFactory\",",
            "    \"HTTPConnectionPool\",",
            "    \"HTTPDownloader\",",
            "    \"HTTPPageDownloader\",",
            "    \"HTTPPageGetter\",",
            "    \"PartialDownloadError\",",
            "    \"ProxyAgent\",",
            "    \"readBody\",",
            "    \"RedirectAgent\",",
            "    \"RequestGenerationFailed\",",
            "    \"RequestTransmissionFailed\",",
            "    \"Response\",",
            "    \"ResponseDone\",",
            "    \"ResponseFailed\",",
            "    \"ResponseNeverReceived\",",
            "    \"URI\",",
            "]"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: twisted.web.test.test_webclient,twisted.web.test.test_agent -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "HTTP client.",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import os",
            "import warnings",
            "import zlib",
            "from functools import wraps",
            "from typing import Iterable",
            "from urllib.parse import urldefrag, urljoin, urlunparse as _urlunparse",
            "",
            "from zope.interface import implementer",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import defer, protocol, task",
            "from twisted.internet.abstract import isIPv6Address",
            "from twisted.internet.endpoints import HostnameEndpoint, wrapClientTLS",
            "from twisted.internet.interfaces import IOpenSSLContextFactory, IProtocol",
            "from twisted.logger import Logger",
            "from twisted.python.compat import nativeString, networkString",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import (",
            "    deprecated,",
            "    deprecatedModuleAttribute,",
            "    getDeprecationWarningString,",
            ")",
            "from twisted.python.failure import Failure",
            "from twisted.python.util import InsensitiveDict",
            "from twisted.web import error, http",
            "from twisted.web._newclient import _ensureValidMethod, _ensureValidURI",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IAgentEndpointFactory,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "",
            "",
            "def urlunparse(parts):",
            "    result = _urlunparse(tuple(p.decode(\"charmap\") for p in parts))",
            "    return result.encode(\"charmap\")",
            "",
            "",
            "class PartialDownloadError(error.Error):",
            "    \"\"\"",
            "    Page was only partially downloaded, we got disconnected in middle.",
            "",
            "    @ivar response: All of the response body which was downloaded.",
            "    \"\"\"",
            "",
            "",
            "class HTTPPageGetter(http.HTTPClient):",
            "    \"\"\"",
            "    Gets a resource via HTTP, then quits.",
            "",
            "    Typically used with L{HTTPClientFactory}.  Note that this class does not, by",
            "    itself, do anything with the response.  If you want to download a resource",
            "    into a file, use L{HTTPPageDownloader} instead.",
            "",
            "    @ivar _completelyDone: A boolean indicating whether any further requests are",
            "        necessary after this one completes in order to provide a result to",
            "        C{self.factory.deferred}.  If it is C{False}, then a redirect is going",
            "        to be followed.  Otherwise, this protocol's connection is the last one",
            "        before firing the result Deferred.  This is used to make sure the result",
            "        Deferred is only fired after the connection is cleaned up.",
            "    \"\"\"",
            "",
            "    quietLoss = 0",
            "    followRedirect = True",
            "    failed = 0",
            "",
            "    _completelyDone = True",
            "",
            "    _specialHeaders = {b\"host\", b\"user-agent\", b\"cookie\", b\"content-length\"}",
            "",
            "    def connectionMade(self):",
            "        method = _ensureValidMethod(getattr(self.factory, \"method\", b\"GET\"))",
            "        self.sendCommand(method, _ensureValidURI(self.factory.path))",
            "        if self.factory.scheme == b\"http\" and self.factory.port != 80:",
            "            host = b\"%b:%d\" % (self.factory.host, self.factory.port)",
            "        elif self.factory.scheme == b\"https\" and self.factory.port != 443:",
            "            host = b\"%b:%d\" % (self.factory.host, self.factory.port)",
            "        else:",
            "            host = self.factory.host",
            "        self.sendHeader(b\"Host\", self.factory.headers.get(b\"host\", host))",
            "        self.sendHeader(b\"User-Agent\", self.factory.agent)",
            "        data = getattr(self.factory, \"postdata\", None)",
            "        if data is not None:",
            "            self.sendHeader(b\"Content-Length\", b\"%d\" % (len(data),))",
            "",
            "        cookieData = []",
            "        for (key, value) in self.factory.headers.items():",
            "            if key.lower() not in self._specialHeaders:",
            "                # we calculated it on our own",
            "                self.sendHeader(key, value)",
            "            if key.lower() == b\"cookie\":",
            "                cookieData.append(value)",
            "        for cookie, cookval in self.factory.cookies.items():",
            "            cookieData.append(cookie + b\"=\" + cookval)",
            "        if cookieData:",
            "            self.sendHeader(b\"Cookie\", b\"; \".join(cookieData))",
            "        self.endHeaders()",
            "        self.headers = {}",
            "",
            "        if data is not None:",
            "            self.transport.write(data)",
            "",
            "    def handleHeader(self, key, value):",
            "        \"\"\"",
            "        Called every time a header is received. Stores the header information",
            "        as key-value pairs in the C{headers} attribute.",
            "",
            "        @type key: C{str}",
            "        @param key: An HTTP header field name.",
            "",
            "        @type value: C{str}",
            "        @param value: An HTTP header field value.",
            "        \"\"\"",
            "        key = key.lower()",
            "        l = self.headers.setdefault(key, [])",
            "        l.append(value)",
            "",
            "    def handleStatus(self, version, status, message):",
            "        \"\"\"",
            "        Handle the HTTP status line.",
            "",
            "        @param version: The HTTP version.",
            "        @type version: L{bytes}",
            "        @param status: The HTTP status code, an integer represented as a",
            "            bytestring.",
            "        @type status: L{bytes}",
            "        @param message: The HTTP status message.",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.version, self.status, self.message = version, status, message",
            "        self.factory.gotStatus(version, status, message)",
            "",
            "    def handleEndHeaders(self):",
            "        self.factory.gotHeaders(self.headers)",
            "        m = getattr(",
            "            self, \"handleStatus_\" + nativeString(self.status), self.handleStatusDefault",
            "        )",
            "        m()",
            "",
            "    def handleStatus_200(self):",
            "        pass",
            "",
            "    handleStatus_201 = lambda self: self.handleStatus_200()",
            "    handleStatus_202 = lambda self: self.handleStatus_200()",
            "",
            "    def handleStatusDefault(self):",
            "        self.failed = 1",
            "",
            "    def handleStatus_301(self):",
            "        l = self.headers.get(b\"location\")",
            "        if not l:",
            "            self.handleStatusDefault()",
            "            return",
            "        url = l[0]",
            "        if self.followRedirect:",
            "            self.factory._redirectCount += 1",
            "            if self.factory._redirectCount >= self.factory.redirectLimit:",
            "                err = error.InfiniteRedirection(",
            "                    self.status, b\"Infinite redirection detected\", location=url",
            "                )",
            "                self.factory.noPage(Failure(err))",
            "                self.quietLoss = True",
            "                self.transport.loseConnection()",
            "                return",
            "",
            "            self._completelyDone = False",
            "            self.factory.setURL(url)",
            "",
            "            from twisted.internet import reactor",
            "",
            "            if self.factory.scheme == b\"https\":",
            "                from twisted.internet import ssl",
            "",
            "                contextFactory = ssl.ClientContextFactory()",
            "                reactor.connectSSL(",
            "                    nativeString(self.factory.host),",
            "                    self.factory.port,",
            "                    self.factory,",
            "                    contextFactory,",
            "                )",
            "            else:",
            "                reactor.connectTCP(",
            "                    nativeString(self.factory.host), self.factory.port, self.factory",
            "                )",
            "        else:",
            "            self.handleStatusDefault()",
            "            self.factory.noPage(",
            "                Failure(error.PageRedirect(self.status, self.message, location=url))",
            "            )",
            "        self.quietLoss = True",
            "        self.transport.loseConnection()",
            "",
            "    def handleStatus_302(self):",
            "        if self.afterFoundGet:",
            "            self.handleStatus_303()",
            "        else:",
            "            self.handleStatus_301()",
            "",
            "    def handleStatus_303(self):",
            "        self.factory.method = b\"GET\"",
            "        self.handleStatus_301()",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the connection used to issue the HTTP request is closed, notify the",
            "        factory if we have not already, so it can produce a result.",
            "        \"\"\"",
            "        if not self.quietLoss:",
            "            http.HTTPClient.connectionLost(self, reason)",
            "            self.factory.noPage(reason)",
            "        if self._completelyDone:",
            "            # Only if we think we're completely done do we tell the factory that",
            "            # we're \"disconnected\".  This way when we're following redirects,",
            "            # only the last protocol used will fire the _disconnectedDeferred.",
            "            self.factory._disconnectedDeferred.callback(None)",
            "",
            "    def handleResponse(self, response):",
            "        if self.quietLoss:",
            "            return",
            "        if self.failed:",
            "            self.factory.noPage(",
            "                Failure(error.Error(self.status, self.message, response))",
            "            )",
            "        if self.factory.method == b\"HEAD\":",
            "            # Callback with empty string, since there is never a response",
            "            # body for HEAD requests.",
            "            self.factory.page(b\"\")",
            "        elif self.length != None and self.length != 0:",
            "            self.factory.noPage(",
            "                Failure(PartialDownloadError(self.status, self.message, response))",
            "            )",
            "        else:",
            "            self.factory.page(response)",
            "        # server might be stupid and not close connection. admittedly",
            "        # the fact we do only one request per connection is also",
            "        # stupid...",
            "        self.transport.loseConnection()",
            "",
            "    def timeout(self):",
            "        self.quietLoss = True",
            "        self.transport.abortConnection()",
            "        self.factory.noPage(",
            "            defer.TimeoutError(",
            "                \"Getting %s took longer than %s seconds.\"",
            "                % (self.factory.url, self.factory.timeout)",
            "            )",
            "        )",
            "",
            "",
            "class HTTPPageDownloader(HTTPPageGetter):",
            "",
            "    transmittingPage = 0",
            "",
            "    def handleStatus_200(self, partialContent=0):",
            "        HTTPPageGetter.handleStatus_200(self)",
            "        self.transmittingPage = 1",
            "        self.factory.pageStart(partialContent)",
            "",
            "    def handleStatus_206(self):",
            "        self.handleStatus_200(partialContent=1)",
            "",
            "    def handleResponsePart(self, data):",
            "        if self.transmittingPage:",
            "            self.factory.pagePart(data)",
            "",
            "    def handleResponseEnd(self):",
            "        if self.length:",
            "            self.transmittingPage = 0",
            "            self.factory.noPage(Failure(PartialDownloadError(self.status)))",
            "        if self.transmittingPage:",
            "            self.factory.pageEnd()",
            "            self.transmittingPage = 0",
            "        if self.failed:",
            "            self.factory.noPage(Failure(error.Error(self.status, self.message, None)))",
            "            self.transport.loseConnection()",
            "",
            "",
            "class HTTPClientFactory(protocol.ClientFactory):",
            "    \"\"\"Download a given URL.",
            "",
            "    @type deferred: Deferred",
            "    @ivar deferred: A Deferred that will fire when the content has",
            "          been retrieved. Once this is fired, the ivars `status', `version',",
            "          and `message' will be set.",
            "",
            "    @type status: bytes",
            "    @ivar status: The status of the response.",
            "",
            "    @type version: bytes",
            "    @ivar version: The version of the response.",
            "",
            "    @type message: bytes",
            "    @ivar message: The text message returned with the status.",
            "",
            "    @type response_headers: dict",
            "    @ivar response_headers: The headers that were specified in the",
            "          response from the server.",
            "",
            "    @type method: bytes",
            "    @ivar method: The HTTP method to use in the request.  This should be one of",
            "        OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT (case",
            "        matters).  Other values may be specified if the server being contacted",
            "        supports them.",
            "",
            "    @type redirectLimit: int",
            "    @ivar redirectLimit: The maximum number of HTTP redirects that can occur",
            "          before it is assumed that the redirection is endless.",
            "",
            "    @type afterFoundGet: C{bool}",
            "    @ivar afterFoundGet: Deviate from the HTTP 1.1 RFC by handling redirects",
            "        the same way as most web browsers; if the request method is POST and a",
            "        302 status is encountered, the redirect is followed with a GET method",
            "",
            "    @type _redirectCount: int",
            "    @ivar _redirectCount: The current number of HTTP redirects encountered.",
            "",
            "    @ivar _disconnectedDeferred: A L{Deferred} which only fires after the last",
            "        connection associated with the request (redirects may cause multiple",
            "        connections to be required) has closed.  The result Deferred will only",
            "        fire after this Deferred, so that callers can be assured that there are",
            "        no more event sources in the reactor once they get the result.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageGetter",
            "",
            "    url = None",
            "    scheme = None",
            "    host = b\"\"",
            "    port = None",
            "    path = None",
            "",
            "    def __init__(",
            "        self,",
            "        url,",
            "        method=b\"GET\",",
            "        postdata=None,",
            "        headers=None,",
            "        agent=b\"Twisted PageGetter\",",
            "        timeout=0,",
            "        cookies=None,",
            "        followRedirect=True,",
            "        redirectLimit=20,",
            "        afterFoundGet=False,",
            "    ):",
            "        self.followRedirect = followRedirect",
            "        self.redirectLimit = redirectLimit",
            "        self._redirectCount = 0",
            "        self.timeout = timeout",
            "        self.agent = agent",
            "        self.afterFoundGet = afterFoundGet",
            "        if cookies is None:",
            "            cookies = {}",
            "        self.cookies = cookies",
            "        if headers is not None:",
            "            self.headers = InsensitiveDict(headers)",
            "        else:",
            "            self.headers = InsensitiveDict()",
            "        if postdata is not None:",
            "            self.headers.setdefault(b\"Content-Length\", b\"%d\" % (len(postdata),))",
            "            # just in case a broken http/1.1 decides to keep connection alive",
            "            self.headers.setdefault(b\"connection\", b\"close\")",
            "        self.postdata = postdata",
            "        self.method = _ensureValidMethod(method)",
            "",
            "        self.setURL(url)",
            "",
            "        self.waiting = 1",
            "        self._disconnectedDeferred = defer.Deferred()",
            "        self.deferred = defer.Deferred()",
            "        # Make sure the first callback on the result Deferred pauses the",
            "        # callback chain until the request connection is closed.",
            "        self.deferred.addBoth(self._waitForDisconnect)",
            "        self.response_headers = None",
            "",
            "    def _waitForDisconnect(self, passthrough):",
            "        \"\"\"",
            "        Chain onto the _disconnectedDeferred, preserving C{passthrough}, so that",
            "        the result is only available after the associated connection has been",
            "        closed.",
            "        \"\"\"",
            "        self._disconnectedDeferred.addCallback(lambda ignored: passthrough)",
            "        return self._disconnectedDeferred",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"<{self.__class__.__name__}: {self.url}>\"",
            "",
            "    def setURL(self, url):",
            "        _ensureValidURI(url.strip())",
            "        self.url = url",
            "        uri = URI.fromBytes(url)",
            "        if uri.scheme and uri.host:",
            "            self.scheme = uri.scheme",
            "            self.host = uri.host",
            "            self.port = uri.port",
            "        self.path = uri.originForm",
            "",
            "    def buildProtocol(self, addr):",
            "        p = protocol.ClientFactory.buildProtocol(self, addr)",
            "        p.followRedirect = self.followRedirect",
            "        p.afterFoundGet = self.afterFoundGet",
            "        if self.timeout:",
            "            from twisted.internet import reactor",
            "",
            "            timeoutCall = reactor.callLater(self.timeout, p.timeout)",
            "            self.deferred.addBoth(self._cancelTimeout, timeoutCall)",
            "        return p",
            "",
            "    def _cancelTimeout(self, result, timeoutCall):",
            "        if timeoutCall.active():",
            "            timeoutCall.cancel()",
            "        return result",
            "",
            "    def gotHeaders(self, headers):",
            "        \"\"\"",
            "        Parse the response HTTP headers.",
            "",
            "        @param headers: The response HTTP headers.",
            "        @type headers: L{dict}",
            "        \"\"\"",
            "        self.response_headers = headers",
            "        if b\"set-cookie\" in headers:",
            "            for cookie in headers[b\"set-cookie\"]:",
            "                if b\"=\" in cookie:",
            "                    cookparts = cookie.split(b\";\")",
            "                    cook = cookparts[0]",
            "                    cook.lstrip()",
            "                    k, v = cook.split(b\"=\", 1)",
            "                    self.cookies[k.lstrip()] = v.lstrip()",
            "",
            "    def gotStatus(self, version, status, message):",
            "        \"\"\"",
            "        Set the status of the request on us.",
            "",
            "        @param version: The HTTP version.",
            "        @type version: L{bytes}",
            "        @param status: The HTTP status code, an integer represented as a",
            "            bytestring.",
            "        @type status: L{bytes}",
            "        @param message: The HTTP status message.",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "        self.version, self.status, self.message = version, status, message",
            "",
            "    def page(self, page):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.callback(page)",
            "",
            "    def noPage(self, reason):",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            self.deferred.errback(reason)",
            "",
            "    def clientConnectionFailed(self, _, reason):",
            "        \"\"\"",
            "        When a connection attempt fails, the request cannot be issued.  If no",
            "        result has yet been provided to the result Deferred, provide the",
            "        connection failure reason as an error result.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            # If the connection attempt failed, there is nothing more to",
            "            # disconnect, so just fire that Deferred now.",
            "            self._disconnectedDeferred.callback(None)",
            "            self.deferred.errback(reason)",
            "",
            "",
            "class HTTPDownloader(HTTPClientFactory):",
            "    \"\"\"",
            "    Download to a file.",
            "    \"\"\"",
            "",
            "    protocol = HTTPPageDownloader",
            "    value = None",
            "    _log = Logger()",
            "",
            "    def __init__(",
            "        self,",
            "        url,",
            "        fileOrName,",
            "        method=b\"GET\",",
            "        postdata=None,",
            "        headers=None,",
            "        agent=b\"Twisted client\",",
            "        supportPartial=False,",
            "        timeout=0,",
            "        cookies=None,",
            "        followRedirect=True,",
            "        redirectLimit=20,",
            "        afterFoundGet=False,",
            "    ):",
            "        self.requestedPartial = 0",
            "        if isinstance(fileOrName, str):",
            "            self.fileName = fileOrName",
            "            self.file = None",
            "            if supportPartial and os.path.exists(self.fileName):",
            "                fileLength = os.path.getsize(self.fileName)",
            "                if fileLength:",
            "                    self.requestedPartial = fileLength",
            "                    if headers is None:",
            "                        headers = {}",
            "                    headers[b\"range\"] = b\"bytes=%d-\" % (fileLength,)",
            "        else:",
            "            self.file = fileOrName",
            "        HTTPClientFactory.__init__(",
            "            self,",
            "            url,",
            "            method=method,",
            "            postdata=postdata,",
            "            headers=headers,",
            "            agent=agent,",
            "            timeout=timeout,",
            "            cookies=cookies,",
            "            followRedirect=followRedirect,",
            "            redirectLimit=redirectLimit,",
            "            afterFoundGet=afterFoundGet,",
            "        )",
            "",
            "    def gotHeaders(self, headers):",
            "        HTTPClientFactory.gotHeaders(self, headers)",
            "        if self.requestedPartial:",
            "            contentRange = headers.get(b\"content-range\", None)",
            "            if not contentRange:",
            "                # server doesn't support partial requests, oh well",
            "                self.requestedPartial = 0",
            "                return",
            "            start, end, realLength = http.parseContentRange(contentRange[0])",
            "            if start != self.requestedPartial:",
            "                # server is acting weirdly",
            "                self.requestedPartial = 0",
            "",
            "    def openFile(self, partialContent):",
            "        if partialContent:",
            "            file = open(self.fileName, \"rb+\")",
            "            file.seek(0, 2)",
            "        else:",
            "            file = open(self.fileName, \"wb\")",
            "        return file",
            "",
            "    def pageStart(self, partialContent):",
            "        \"\"\"Called on page download start.",
            "",
            "        @param partialContent: tells us if the download is partial download we requested.",
            "        \"\"\"",
            "        if partialContent and not self.requestedPartial:",
            "            raise ValueError(",
            "                \"we shouldn't get partial content response if we didn't want it!\"",
            "            )",
            "        if self.waiting:",
            "            try:",
            "                if not self.file:",
            "                    self.file = self.openFile(partialContent)",
            "            except OSError:",
            "                # raise",
            "                self.deferred.errback(Failure())",
            "",
            "    def pagePart(self, data):",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.write(data)",
            "        except OSError:",
            "            # raise",
            "            self.file = None",
            "            self.deferred.errback(Failure())",
            "",
            "    def noPage(self, reason):",
            "        \"\"\"",
            "        Close the storage file and errback the waiting L{Deferred} with the",
            "        given reason.",
            "        \"\"\"",
            "        if self.waiting:",
            "            self.waiting = 0",
            "            if self.file:",
            "                try:",
            "                    self.file.close()",
            "                except BaseException:",
            "                    self._log.failure(\"Error closing HTTPDownloader file\")",
            "            self.deferred.errback(reason)",
            "",
            "    def pageEnd(self):",
            "        self.waiting = 0",
            "        if not self.file:",
            "            return",
            "        try:",
            "            self.file.close()",
            "        except OSError:",
            "            self.deferred.errback(Failure())",
            "            return",
            "        self.deferred.callback(self.value)",
            "",
            "",
            "class URI:",
            "    \"\"\"",
            "    A URI object.",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21}",
            "    \"\"\"",
            "",
            "    def __init__(self, scheme, netloc, host, port, path, params, query, fragment):",
            "        \"\"\"",
            "        @type scheme: L{bytes}",
            "        @param scheme: URI scheme specifier.",
            "",
            "        @type netloc: L{bytes}",
            "        @param netloc: Network location component.",
            "",
            "        @type host: L{bytes}",
            "        @param host: Host name. For IPv6 address literals the brackets are",
            "            stripped.",
            "",
            "        @type port: L{int}",
            "        @param port: Port number.",
            "",
            "        @type path: L{bytes}",
            "        @param path: Hierarchical path.",
            "",
            "        @type params: L{bytes}",
            "        @param params: Parameters for last path segment.",
            "",
            "        @type query: L{bytes}",
            "        @param query: Query string.",
            "",
            "        @type fragment: L{bytes}",
            "        @param fragment: Fragment identifier.",
            "        \"\"\"",
            "        self.scheme = scheme",
            "        self.netloc = netloc",
            "        self.host = host.strip(b\"[]\")",
            "        self.port = port",
            "        self.path = path",
            "        self.params = params",
            "        self.query = query",
            "        self.fragment = fragment",
            "",
            "    @classmethod",
            "    def fromBytes(cls, uri, defaultPort=None):",
            "        \"\"\"",
            "        Parse the given URI into a L{URI}.",
            "",
            "        @type uri: C{bytes}",
            "        @param uri: URI to parse.",
            "",
            "        @type defaultPort: C{int} or L{None}",
            "        @param defaultPort: An alternate value to use as the port if the URI",
            "            does not include one.",
            "",
            "        @rtype: L{URI}",
            "        @return: Parsed URI instance.",
            "        \"\"\"",
            "        uri = uri.strip()",
            "        scheme, netloc, path, params, query, fragment = http.urlparse(uri)",
            "",
            "        if defaultPort is None:",
            "            if scheme == b\"https\":",
            "                defaultPort = 443",
            "            else:",
            "                defaultPort = 80",
            "",
            "        if b\":\" in netloc:",
            "            host, port = netloc.rsplit(b\":\", 1)",
            "            try:",
            "                port = int(port)",
            "            except ValueError:",
            "                host, port = netloc, defaultPort",
            "        else:",
            "            host, port = netloc, defaultPort",
            "        return cls(scheme, netloc, host, port, path, params, query, fragment)",
            "",
            "    def toBytes(self):",
            "        \"\"\"",
            "        Assemble the individual parts of the I{URI} into a fully formed I{URI}.",
            "",
            "        @rtype: C{bytes}",
            "        @return: A fully formed I{URI}.",
            "        \"\"\"",
            "        return urlunparse(",
            "            (",
            "                self.scheme,",
            "                self.netloc,",
            "                self.path,",
            "                self.params,",
            "                self.query,",
            "                self.fragment,",
            "            )",
            "        )",
            "",
            "    @property",
            "    def originForm(self):",
            "        \"\"\"",
            "        The absolute I{URI} path including I{URI} parameters, query string and",
            "        fragment identifier.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21#section-5.3}",
            "",
            "        @return: The absolute path in original form.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        # The HTTP bis draft says the origin form should not include the",
            "        # fragment.",
            "        path = urlunparse((b\"\", b\"\", self.path, self.params, self.query, b\"\"))",
            "        if path == b\"\":",
            "            path = b\"/\"",
            "        return path",
            "",
            "",
            "def _urljoin(base, url):",
            "    \"\"\"",
            "    Construct a full (\"absolute\") URL by combining a \"base URL\" with another",
            "    URL. Informally, this uses components of the base URL, in particular the",
            "    addressing scheme, the network location and (part of) the path, to provide",
            "    missing components in the relative URL.",
            "",
            "    Additionally, the fragment identifier is preserved according to the HTTP",
            "    1.1 bis draft.",
            "",
            "    @type base: C{bytes}",
            "    @param base: Base URL.",
            "",
            "    @type url: C{bytes}",
            "    @param url: URL to combine with C{base}.",
            "",
            "    @return: An absolute URL resulting from the combination of C{base} and",
            "        C{url}.",
            "",
            "    @see: L{urllib.parse.urljoin()}",
            "",
            "    @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "    \"\"\"",
            "    base, baseFrag = urldefrag(base)",
            "    url, urlFrag = urldefrag(urljoin(base, url))",
            "    return urljoin(url, b\"#\" + (urlFrag or baseFrag))",
            "",
            "",
            "def _makeGetterFactory(url, factoryFactory, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Create and connect an HTTP page getting factory.",
            "",
            "    Any additional positional or keyword arguments are used when calling",
            "    C{factoryFactory}.",
            "",
            "    @param factoryFactory: Factory factory that is called with C{url}, C{args}",
            "        and C{kwargs} to produce the getter",
            "",
            "    @param contextFactory: Context factory to use when creating a secure",
            "        connection, defaulting to L{None}",
            "",
            "    @return: The factory created by C{factoryFactory}",
            "    \"\"\"",
            "    uri = URI.fromBytes(_ensureValidURI(url.strip()))",
            "    factory = factoryFactory(url, *args, **kwargs)",
            "    from twisted.internet import reactor",
            "",
            "    if uri.scheme == b\"https\":",
            "        from twisted.internet import ssl",
            "",
            "        if contextFactory is None:",
            "            contextFactory = ssl.ClientContextFactory()",
            "        reactor.connectSSL(nativeString(uri.host), uri.port, factory, contextFactory)",
            "    else:",
            "        reactor.connectTCP(nativeString(uri.host), uri.port, factory)",
            "    return factory",
            "",
            "",
            "_GETPAGE_REPLACEMENT_TEXT = \"https://pypi.org/project/treq/ or twisted.web.client.Agent\"",
            "",
            "",
            "def _deprecateGetPageClasses():",
            "    \"\"\"",
            "    Mark the protocols and factories associated with L{getPage} and",
            "    L{downloadPage} as deprecated.",
            "    \"\"\"",
            "    for klass in [",
            "        HTTPPageGetter,",
            "        HTTPPageDownloader,",
            "        HTTPClientFactory,",
            "        HTTPDownloader,",
            "    ]:",
            "        deprecatedModuleAttribute(",
            "            Version(\"Twisted\", 16, 7, 0),",
            "            getDeprecationWarningString(",
            "                klass,",
            "                Version(\"Twisted\", 16, 7, 0),",
            "                replacement=_GETPAGE_REPLACEMENT_TEXT,",
            "            ).split(\"; \")[1],",
            "            klass.__module__,",
            "            klass.__name__,",
            "        )",
            "",
            "",
            "_deprecateGetPageClasses()",
            "",
            "",
            "@deprecated(Version(\"Twisted\", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)",
            "def getPage(url, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page as a string.",
            "",
            "    Download a page. Return a deferred, which will callback with a",
            "    page (as a string) or errback with a description of the error.",
            "",
            "    See L{HTTPClientFactory} to see what extra arguments can be passed.",
            "    \"\"\"",
            "    return _makeGetterFactory(",
            "        url, HTTPClientFactory, contextFactory=contextFactory, *args, **kwargs",
            "    ).deferred",
            "",
            "",
            "@deprecated(Version(\"Twisted\", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)",
            "def downloadPage(url, file, contextFactory=None, *args, **kwargs):",
            "    \"\"\"",
            "    Download a web page to a file.",
            "",
            "    @param file: path to file on filesystem, or file-like object.",
            "",
            "    See HTTPDownloader to see what extra args can be passed.",
            "    \"\"\"",
            "    factoryFactory = lambda url, *a, **kw: HTTPDownloader(url, file, *a, **kw)",
            "    return _makeGetterFactory(",
            "        url, factoryFactory, contextFactory=contextFactory, *args, **kwargs",
            "    ).deferred",
            "",
            "",
            "# The code which follows is based on the new HTTP client implementation.  It",
            "# should be significantly better than anything above, though it is not yet",
            "# feature equivalent.",
            "",
            "from twisted.web._newclient import (",
            "    HTTP11ClientProtocol,",
            "    PotentialDataLoss,",
            "    Request,",
            "    RequestGenerationFailed,",
            "    RequestNotSent,",
            "    RequestTransmissionFailed,",
            "    Response,",
            "    ResponseDone,",
            "    ResponseFailed,",
            "    ResponseNeverReceived,",
            "    _WrapperException,",
            ")",
            "from twisted.web.error import SchemeNotSupported",
            "",
            "try:",
            "    from OpenSSL import SSL",
            "except ImportError:",
            "    SSL = None  # type: ignore[assignment]",
            "else:",
            "    from twisted.internet.ssl import (",
            "        CertificateOptions,",
            "        optionsForClientTLS,",
            "        platformTrust,",
            "    )",
            "",
            "",
            "def _requireSSL(decoratee):",
            "    \"\"\"",
            "    The decorated method requires pyOpenSSL to be present, or it raises",
            "    L{NotImplementedError}.",
            "",
            "    @param decoratee: A function which requires pyOpenSSL.",
            "    @type decoratee: L{callable}",
            "",
            "    @return: A function which raises L{NotImplementedError} if pyOpenSSL is not",
            "        installed; otherwise, if it is installed, simply return C{decoratee}.",
            "    @rtype: L{callable}",
            "    \"\"\"",
            "    if SSL is None:",
            "",
            "        @wraps(decoratee)",
            "        def raiseNotImplemented(*a, **kw):",
            "            \"\"\"",
            "            pyOpenSSL is not available.",
            "",
            "            @param a: The positional arguments for C{decoratee}.",
            "",
            "            @param kw: The keyword arguments for C{decoratee}.",
            "",
            "            @raise NotImplementedError: Always.",
            "            \"\"\"",
            "            raise NotImplementedError(\"SSL support unavailable\")",
            "",
            "        return raiseNotImplemented",
            "    return decoratee",
            "",
            "",
            "class WebClientContextFactory:",
            "    \"\"\"",
            "    This class is deprecated.  Please simply use L{Agent} as-is, or if you want",
            "    to customize something, use L{BrowserLikePolicyForHTTPS}.",
            "",
            "    A L{WebClientContextFactory} is an HTTPS policy which totally ignores the",
            "    hostname and port.  It performs basic certificate verification, however the",
            "    lack of validation of service identity (e.g.  hostname validation) means it",
            "    is still vulnerable to man-in-the-middle attacks.  Don't use it any more.",
            "    \"\"\"",
            "",
            "    def _getCertificateOptions(self, hostname, port):",
            "        \"\"\"",
            "        Return a L{CertificateOptions}.",
            "",
            "        @param hostname: ignored",
            "",
            "        @param port: ignored",
            "",
            "        @return: A new CertificateOptions instance.",
            "        @rtype: L{CertificateOptions}",
            "        \"\"\"",
            "        return CertificateOptions(method=SSL.SSLv23_METHOD, trustRoot=platformTrust())",
            "",
            "    @_requireSSL",
            "    def getContext(self, hostname, port):",
            "        \"\"\"",
            "        Return an L{OpenSSL.SSL.Context}.",
            "",
            "        @param hostname: ignored",
            "        @param port: ignored",
            "",
            "        @return: A new SSL context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._getCertificateOptions(hostname, port).getContext()",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class BrowserLikePolicyForHTTPS:",
            "    \"\"\"",
            "    SSL connection creator for web clients.",
            "    \"\"\"",
            "",
            "    def __init__(self, trustRoot=None):",
            "        self._trustRoot = trustRoot",
            "",
            "    @_requireSSL",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        return optionsForClientTLS(hostname.decode(\"ascii\"), trustRoot=self._trustRoot)",
            "",
            "",
            "deprecatedModuleAttribute(",
            "    Version(\"Twisted\", 14, 0, 0),",
            "    getDeprecationWarningString(",
            "        WebClientContextFactory,",
            "        Version(\"Twisted\", 14, 0, 0),",
            "        replacement=BrowserLikePolicyForHTTPS,",
            "    ).split(\"; \")[1],",
            "    WebClientContextFactory.__module__,",
            "    WebClientContextFactory.__name__,",
            ")",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class HostnameCachingHTTPSPolicy:",
            "    \"\"\"",
            "    IPolicyForHTTPS that wraps a L{IPolicyForHTTPS} and caches the created",
            "    L{IOpenSSLClientConnectionCreator}.",
            "",
            "    This policy will cache up to C{cacheSize}",
            "    L{client connection creators <twisted.internet.interfaces.",
            "    IOpenSSLClientConnectionCreator>} for reuse in subsequent requests to",
            "    the same hostname.",
            "",
            "    @ivar _policyForHTTPS: See C{policyforHTTPS} parameter of L{__init__}.",
            "",
            "    @ivar _cache: A cache associating hostnames to their",
            "        L{client connection creators <twisted.internet.interfaces.",
            "        IOpenSSLClientConnectionCreator>}.",
            "    @type _cache: L{collections.OrderedDict}",
            "",
            "    @ivar _cacheSize: See C{cacheSize} parameter of L{__init__}.",
            "",
            "    @since: Twisted 19.2.0",
            "    \"\"\"",
            "",
            "    def __init__(self, policyforHTTPS, cacheSize=20):",
            "        \"\"\"",
            "        @param policyforHTTPS: The IPolicyForHTTPS to wrap.",
            "        @type policyforHTTPS: L{IPolicyForHTTPS}",
            "",
            "        @param cacheSize: The maximum size of the hostname cache.",
            "        @type cacheSize: L{int}",
            "        \"\"\"",
            "        self._policyForHTTPS = policyforHTTPS",
            "        self._cache = collections.OrderedDict()",
            "        self._cacheSize = cacheSize",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} for a",
            "        given network location and cache it for future use.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: a connection creator with appropriate verification",
            "            restrictions set",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "        host = hostname.decode(\"ascii\")",
            "        try:",
            "            creator = self._cache.pop(host)",
            "        except KeyError:",
            "            creator = self._policyForHTTPS.creatorForNetloc(hostname, port)",
            "",
            "        self._cache[host] = creator",
            "        if len(self._cache) > self._cacheSize:",
            "            self._cache.popitem(last=False)",
            "",
            "        return creator",
            "",
            "",
            "@implementer(IOpenSSLContextFactory)",
            "class _ContextFactoryWithContext:",
            "    \"\"\"",
            "    A L{_ContextFactoryWithContext} is like a",
            "    L{twisted.internet.ssl.ContextFactory} with a pre-created context.",
            "",
            "    @ivar _context: A Context.",
            "    @type _context: L{OpenSSL.SSL.Context}",
            "    \"\"\"",
            "",
            "    def __init__(self, context):",
            "        \"\"\"",
            "        Initialize a L{_ContextFactoryWithContext} with a context.",
            "",
            "        @param context: An SSL context.",
            "        @type context: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        self._context = context",
            "",
            "    def getContext(self):",
            "        \"\"\"",
            "        Return the context created by",
            "        L{_DeprecatedToCurrentPolicyForHTTPS._webContextFactory}.",
            "",
            "        @return: A context.",
            "        @rtype: L{OpenSSL.SSL.Context}",
            "        \"\"\"",
            "        return self._context",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class _DeprecatedToCurrentPolicyForHTTPS:",
            "    \"\"\"",
            "    Adapt a web context factory to a normal context factory.",
            "",
            "    @ivar _webContextFactory: An object providing a getContext method with",
            "        C{hostname} and C{port} arguments.",
            "    @type _webContextFactory: L{WebClientContextFactory} (or object with a",
            "        similar C{getContext} method).",
            "    \"\"\"",
            "",
            "    def __init__(self, webContextFactory):",
            "        \"\"\"",
            "        Wrap a web context factory in an L{IPolicyForHTTPS}.",
            "",
            "        @param webContextFactory: An object providing a getContext method with",
            "            C{hostname} and C{port} arguments.",
            "        @type webContextFactory: L{WebClientContextFactory} (or object with a",
            "            similar C{getContext} method).",
            "        \"\"\"",
            "        self._webContextFactory = webContextFactory",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        \"\"\"",
            "        Called the wrapped web context factory's C{getContext} method with a",
            "        hostname and port number and return the resulting context object.",
            "",
            "        @param hostname: The hostname part of the URI.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The port part of the URI.",
            "        @type port: L{int}",
            "",
            "        @return: A context factory.",
            "        @rtype: L{IOpenSSLContextFactory}",
            "        \"\"\"",
            "        context = self._webContextFactory.getContext(hostname, port)",
            "        return _ContextFactoryWithContext(context)",
            "",
            "",
            "@implementer(IBodyProducer)",
            "class FileBodyProducer:",
            "    \"\"\"",
            "    L{FileBodyProducer} produces bytes from an input file object incrementally",
            "    and writes them to a consumer.",
            "",
            "    Since file-like objects cannot be read from in an event-driven manner,",
            "    L{FileBodyProducer} uses a L{Cooperator} instance to schedule reads from",
            "    the file.  This process is also paused and resumed based on notifications",
            "    from the L{IConsumer} provider being written to.",
            "",
            "    The file is closed after it has been read, or if the producer is stopped",
            "    early.",
            "",
            "    @ivar _inputFile: Any file-like object, bytes read from which will be",
            "        written to a consumer.",
            "",
            "    @ivar _cooperate: A method like L{Cooperator.cooperate} which is used to",
            "        schedule all reads.",
            "",
            "    @ivar _readSize: The number of bytes to read from C{_inputFile} at a time.",
            "    \"\"\"",
            "",
            "    def __init__(self, inputFile, cooperator=task, readSize=2 ** 16):",
            "        self._inputFile = inputFile",
            "        self._cooperate = cooperator.cooperate",
            "        self._readSize = readSize",
            "        self.length = self._determineLength(inputFile)",
            "",
            "    def _determineLength(self, fObj):",
            "        \"\"\"",
            "        Determine how many bytes can be read out of C{fObj} (assuming it is not",
            "        modified from this point on).  If the determination cannot be made,",
            "        return C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "        try:",
            "            seek = fObj.seek",
            "            tell = fObj.tell",
            "        except AttributeError:",
            "            return UNKNOWN_LENGTH",
            "        originalPosition = tell()",
            "        seek(0, os.SEEK_END)",
            "        end = tell()",
            "        seek(originalPosition, os.SEEK_SET)",
            "        return end - originalPosition",
            "",
            "    def stopProducing(self):",
            "        \"\"\"",
            "        Permanently stop writing bytes from the file to the consumer by",
            "        stopping the underlying L{CooperativeTask}.",
            "        \"\"\"",
            "        self._inputFile.close()",
            "        try:",
            "            self._task.stop()",
            "        except task.TaskFinished:",
            "            pass",
            "",
            "    def startProducing(self, consumer):",
            "        \"\"\"",
            "        Start a cooperative task which will read bytes from the input file and",
            "        write them to C{consumer}.  Return a L{Deferred} which fires after all",
            "        bytes have been written.  If this L{Deferred} is cancelled before it is",
            "        fired, stop reading and writing bytes.",
            "",
            "        @param consumer: Any L{IConsumer} provider",
            "        \"\"\"",
            "        self._task = self._cooperate(self._writeloop(consumer))",
            "        d = self._task.whenDone()",
            "",
            "        def maybeStopped(reason):",
            "            if reason.check(defer.CancelledError):",
            "                self.stopProducing()",
            "            elif reason.check(task.TaskStopped):",
            "                pass",
            "            else:",
            "                return reason",
            "            # IBodyProducer.startProducing's Deferred isn't supposed to fire if",
            "            # stopProducing is called.",
            "            return defer.Deferred()",
            "",
            "        d.addCallbacks(lambda ignored: None, maybeStopped)",
            "        return d",
            "",
            "    def _writeloop(self, consumer):",
            "        \"\"\"",
            "        Return an iterator which reads one chunk of bytes from the input file",
            "        and writes them to the consumer for each time it is iterated.",
            "        \"\"\"",
            "        while True:",
            "            bytes = self._inputFile.read(self._readSize)",
            "            if not bytes:",
            "                self._inputFile.close()",
            "                break",
            "            consumer.write(bytes)",
            "            yield None",
            "",
            "    def pauseProducing(self):",
            "        \"\"\"",
            "        Temporarily suspend copying bytes from the input file to the consumer",
            "        by pausing the L{CooperativeTask} which drives that activity.",
            "        \"\"\"",
            "        self._task.pause()",
            "",
            "    def resumeProducing(self):",
            "        \"\"\"",
            "        Undo the effects of a previous C{pauseProducing} and resume copying",
            "        bytes to the consumer by resuming the L{CooperativeTask} which drives",
            "        the write activity.",
            "        \"\"\"",
            "        self._task.resume()",
            "",
            "",
            "class _HTTP11ClientFactory(protocol.Factory):",
            "    \"\"\"",
            "    A factory for L{HTTP11ClientProtocol}, used by L{HTTPConnectionPool}.",
            "",
            "    @ivar _quiescentCallback: The quiescent callback to be passed to protocol",
            "        instances, used to return them to the connection pool.",
            "",
            "    @ivar _metadata: Metadata about the low-level connection details,",
            "        used to make the repr more useful.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, quiescentCallback, metadata):",
            "        self._quiescentCallback = quiescentCallback",
            "        self._metadata = metadata",
            "",
            "    def __repr__(self) -> str:",
            "        return \"_HTTP11ClientFactory({}, {})\".format(",
            "            self._quiescentCallback, self._metadata",
            "        )",
            "",
            "    def buildProtocol(self, addr):",
            "        return HTTP11ClientProtocol(self._quiescentCallback)",
            "",
            "",
            "class _RetryingHTTP11ClientProtocol:",
            "    \"\"\"",
            "    A wrapper for L{HTTP11ClientProtocol} that automatically retries requests.",
            "",
            "    @ivar _clientProtocol: The underlying L{HTTP11ClientProtocol}.",
            "",
            "    @ivar _newConnection: A callable that creates a new connection for a",
            "        retry.",
            "    \"\"\"",
            "",
            "    def __init__(self, clientProtocol, newConnection):",
            "        self._clientProtocol = clientProtocol",
            "        self._newConnection = newConnection",
            "",
            "    def _shouldRetry(self, method, exception, bodyProducer):",
            "        \"\"\"",
            "        Indicate whether request should be retried.",
            "",
            "        Only returns C{True} if method is idempotent, no response was",
            "        received, the reason for the failed request was not due to",
            "        user-requested cancellation, and no body was sent. The latter",
            "        requirement may be relaxed in the future, and PUT added to approved",
            "        method list.",
            "",
            "        @param method: The method of the request.",
            "        @type method: L{bytes}",
            "        \"\"\"",
            "        if method not in (b\"GET\", b\"HEAD\", b\"OPTIONS\", b\"DELETE\", b\"TRACE\"):",
            "            return False",
            "        if not isinstance(",
            "            exception,",
            "            (RequestNotSent, RequestTransmissionFailed, ResponseNeverReceived),",
            "        ):",
            "            return False",
            "        if isinstance(exception, _WrapperException):",
            "            for aFailure in exception.reasons:",
            "                if aFailure.check(defer.CancelledError):",
            "                    return False",
            "        if bodyProducer is not None:",
            "            return False",
            "        return True",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Do a request, and retry once (with a new connection) if it fails in",
            "        a retryable manner.",
            "",
            "        @param request: A L{Request} instance that will be requested using the",
            "            wrapped protocol.",
            "        \"\"\"",
            "        d = self._clientProtocol.request(request)",
            "",
            "        def failed(reason):",
            "            if self._shouldRetry(request.method, reason.value, request.bodyProducer):",
            "                return self._newConnection().addCallback(",
            "                    lambda connection: connection.request(request)",
            "                )",
            "            else:",
            "                return reason",
            "",
            "        d.addErrback(failed)",
            "        return d",
            "",
            "",
            "class HTTPConnectionPool:",
            "    \"\"\"",
            "    A pool of persistent HTTP connections.",
            "",
            "    Features:",
            "     - Cached connections will eventually time out.",
            "     - Limits on maximum number of persistent connections.",
            "",
            "    Connections are stored using keys, which should be chosen such that any",
            "    connections stored under a given key can be used interchangeably.",
            "",
            "    Failed requests done using previously cached connections will be retried",
            "    once if they use an idempotent method (e.g. GET), in case the HTTP server",
            "    timed them out.",
            "",
            "    @ivar persistent: Boolean indicating whether connections should be",
            "        persistent. Connections are persistent by default.",
            "",
            "    @ivar maxPersistentPerHost: The maximum number of cached persistent",
            "        connections for a C{host:port} destination.",
            "    @type maxPersistentPerHost: C{int}",
            "",
            "    @ivar cachedConnectionTimeout: Number of seconds a cached persistent",
            "        connection will stay open before disconnecting.",
            "",
            "    @ivar retryAutomatically: C{boolean} indicating whether idempotent",
            "        requests should be retried once if no response was received.",
            "",
            "    @ivar _factory: The factory used to connect to the proxy.",
            "",
            "    @ivar _connections: Map (scheme, host, port) to lists of",
            "        L{HTTP11ClientProtocol} instances.",
            "",
            "    @ivar _timeouts: Map L{HTTP11ClientProtocol} instances to a",
            "        C{IDelayedCall} instance of their timeout.",
            "",
            "    @since: 12.1",
            "    \"\"\"",
            "",
            "    _factory = _HTTP11ClientFactory",
            "    maxPersistentPerHost = 2",
            "    cachedConnectionTimeout = 240",
            "    retryAutomatically = True",
            "    _log = Logger()",
            "",
            "    def __init__(self, reactor, persistent=True):",
            "        self._reactor = reactor",
            "        self.persistent = persistent",
            "        self._connections = {}",
            "        self._timeouts = {}",
            "",
            "    def getConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Supply a connection, newly created or retrieved from the pool, to be",
            "        used for one HTTP request.",
            "",
            "        The connection will remain out of the pool (not available to be",
            "        returned from future calls to this method) until one HTTP request has",
            "        been completed over it.",
            "",
            "        Afterwards, if the connection is still open, it will automatically be",
            "        added to the pool.",
            "",
            "        @param key: A unique key identifying connections that can be used",
            "            interchangeably.",
            "",
            "        @param endpoint: An endpoint that can be used to open a new connection",
            "            if no cached connection is available.",
            "",
            "        @return: A C{Deferred} that will fire with a L{HTTP11ClientProtocol}",
            "           (or a wrapper) that can be used to send a single HTTP request.",
            "        \"\"\"",
            "        # Try to get cached version:",
            "        connections = self._connections.get(key)",
            "        while connections:",
            "            connection = connections.pop(0)",
            "            # Cancel timeout:",
            "            self._timeouts[connection].cancel()",
            "            del self._timeouts[connection]",
            "            if connection.state == \"QUIESCENT\":",
            "                if self.retryAutomatically:",
            "                    newConnection = lambda: self._newConnection(key, endpoint)",
            "                    connection = _RetryingHTTP11ClientProtocol(",
            "                        connection, newConnection",
            "                    )",
            "                return defer.succeed(connection)",
            "",
            "        return self._newConnection(key, endpoint)",
            "",
            "    def _newConnection(self, key, endpoint):",
            "        \"\"\"",
            "        Create a new connection.",
            "",
            "        This implements the new connection code path for L{getConnection}.",
            "        \"\"\"",
            "",
            "        def quiescentCallback(protocol):",
            "            self._putConnection(key, protocol)",
            "",
            "        factory = self._factory(quiescentCallback, repr(endpoint))",
            "        return endpoint.connect(factory)",
            "",
            "    def _removeConnection(self, key, connection):",
            "        \"\"\"",
            "        Remove a connection from the cache and disconnect it.",
            "        \"\"\"",
            "        connection.transport.loseConnection()",
            "        self._connections[key].remove(connection)",
            "        del self._timeouts[connection]",
            "",
            "    def _putConnection(self, key, connection):",
            "        \"\"\"",
            "        Return a persistent connection to the pool. This will be called by",
            "        L{HTTP11ClientProtocol} when the connection becomes quiescent.",
            "        \"\"\"",
            "        if connection.state != \"QUIESCENT\":",
            "            # Log with traceback for debugging purposes:",
            "            try:",
            "                raise RuntimeError(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\"",
            "                )",
            "            except BaseException:",
            "                self._log.failure(",
            "                    \"BUG: Non-quiescent protocol added to connection pool.\"",
            "                )",
            "            return",
            "        connections = self._connections.setdefault(key, [])",
            "        if len(connections) == self.maxPersistentPerHost:",
            "            dropped = connections.pop(0)",
            "            dropped.transport.loseConnection()",
            "            self._timeouts[dropped].cancel()",
            "            del self._timeouts[dropped]",
            "        connections.append(connection)",
            "        cid = self._reactor.callLater(",
            "            self.cachedConnectionTimeout, self._removeConnection, key, connection",
            "        )",
            "        self._timeouts[connection] = cid",
            "",
            "    def closeCachedConnections(self):",
            "        \"\"\"",
            "        Close all persistent connections and remove them from the pool.",
            "",
            "        @return: L{defer.Deferred} that fires when all connections have been",
            "            closed.",
            "        \"\"\"",
            "        results = []",
            "        for protocols in self._connections.values():",
            "            for p in protocols:",
            "                results.append(p.abort())",
            "        self._connections = {}",
            "        for dc in self._timeouts.values():",
            "            dc.cancel()",
            "        self._timeouts = {}",
            "        return defer.gatherResults(results).addCallback(lambda ign: None)",
            "",
            "",
            "class _AgentBase:",
            "    \"\"\"",
            "    Base class offering common facilities for L{Agent}-type classes.",
            "",
            "    @ivar _reactor: The C{IReactorTime} implementation which will be used by",
            "        the pool, and perhaps by subclasses as well.",
            "",
            "    @ivar _pool: The L{HTTPConnectionPool} used to manage HTTP connections.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, pool):",
            "        if pool is None:",
            "            pool = HTTPConnectionPool(reactor, False)",
            "        self._reactor = reactor",
            "        self._pool = pool",
            "",
            "    def _computeHostValue(self, scheme, host, port):",
            "        \"\"\"",
            "        Compute the string to use for the value of the I{Host} header, based on",
            "        the given scheme, host name, and port number.",
            "        \"\"\"",
            "        if isIPv6Address(nativeString(host)):",
            "            host = b\"[\" + host + b\"]\"",
            "        if (scheme, port) in ((b\"http\", 80), (b\"https\", 443)):",
            "            return host",
            "        return b\"%b:%d\" % (host, port)",
            "",
            "    def _requestWithEndpoint(",
            "        self, key, endpoint, method, parsedURI, headers, bodyProducer, requestPath",
            "    ):",
            "        \"\"\"",
            "        Issue a new request, given the endpoint and the path sent as part of",
            "        the request.",
            "        \"\"\"",
            "        if not isinstance(method, bytes):",
            "            raise TypeError(f\"method={method!r} is {type(method)}, but must be bytes\")",
            "",
            "        method = _ensureValidMethod(method)",
            "",
            "        # Create minimal headers, if necessary:",
            "        if headers is None:",
            "            headers = Headers()",
            "        if not headers.hasHeader(b\"host\"):",
            "            headers = headers.copy()",
            "            headers.addRawHeader(",
            "                b\"host\",",
            "                self._computeHostValue(",
            "                    parsedURI.scheme, parsedURI.host, parsedURI.port",
            "                ),",
            "            )",
            "",
            "        d = self._pool.getConnection(key, endpoint)",
            "",
            "        def cbConnected(proto):",
            "            return proto.request(",
            "                Request._construct(",
            "                    method,",
            "                    requestPath,",
            "                    headers,",
            "                    bodyProducer,",
            "                    persistent=self._pool.persistent,",
            "                    parsedURI=parsedURI,",
            "                )",
            "            )",
            "",
            "        d.addCallback(cbConnected)",
            "        return d",
            "",
            "",
            "@implementer(IAgentEndpointFactory)",
            "class _StandardEndpointFactory:",
            "    \"\"\"",
            "    Standard HTTP endpoint destinations - TCP for HTTP, TCP+TLS for HTTPS.",
            "",
            "    @ivar _policyForHTTPS: A web context factory which will be used to create",
            "        SSL context objects for any SSL connections the agent needs to make.",
            "",
            "    @ivar _connectTimeout: If not L{None}, the timeout passed to",
            "        L{HostnameEndpoint} for specifying the connection timeout.",
            "",
            "    @ivar _bindAddress: If not L{None}, the address passed to",
            "        L{HostnameEndpoint} for specifying the local address to bind to.",
            "    \"\"\"",
            "",
            "    def __init__(self, reactor, contextFactory, connectTimeout, bindAddress):",
            "        \"\"\"",
            "        @param reactor: A provider to use to create endpoints.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float} or L{None}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes} or L{None}",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._policyForHTTPS = contextFactory",
            "        self._connectTimeout = connectTimeout",
            "        self._bindAddress = bindAddress",
            "",
            "    def endpointForURI(self, uri):",
            "        \"\"\"",
            "        Connect directly over TCP for C{b'http'} scheme, and TLS for",
            "        C{b'https'}.",
            "",
            "        @param uri: L{URI} to connect to.",
            "",
            "        @return: Endpoint to connect to.",
            "        @rtype: L{IStreamClientEndpoint}",
            "        \"\"\"",
            "        kwargs = {}",
            "        if self._connectTimeout is not None:",
            "            kwargs[\"timeout\"] = self._connectTimeout",
            "        kwargs[\"bindAddress\"] = self._bindAddress",
            "",
            "        try:",
            "            host = nativeString(uri.host)",
            "        except UnicodeDecodeError:",
            "            raise ValueError(",
            "                (",
            "                    \"The host of the provided URI ({uri.host!r}) \"",
            "                    \"contains non-ASCII octets, it should be ASCII \"",
            "                    \"decodable.\"",
            "                ).format(uri=uri)",
            "            )",
            "",
            "        endpoint = HostnameEndpoint(self._reactor, host, uri.port, **kwargs)",
            "        if uri.scheme == b\"http\":",
            "            return endpoint",
            "        elif uri.scheme == b\"https\":",
            "            connectionCreator = self._policyForHTTPS.creatorForNetloc(",
            "                uri.host, uri.port",
            "            )",
            "            return wrapClientTLS(connectionCreator, endpoint)",
            "        else:",
            "            raise SchemeNotSupported(f\"Unsupported scheme: {uri.scheme!r}\")",
            "",
            "",
            "@implementer(IAgent)",
            "class Agent(_AgentBase):",
            "    \"\"\"",
            "    L{Agent} is a very basic HTTP client.  It supports I{HTTP} and I{HTTPS}",
            "    scheme URIs.",
            "",
            "    @ivar _pool: An L{HTTPConnectionPool} instance.",
            "",
            "    @ivar _endpointFactory: The L{IAgentEndpointFactory} which will",
            "        be used to create endpoints for outgoing connections.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor,",
            "        contextFactory=BrowserLikePolicyForHTTPS(),",
            "        connectTimeout=None,",
            "        bindAddress=None,",
            "        pool=None,",
            "    ):",
            "        \"\"\"",
            "        Create an L{Agent}.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param contextFactory: A factory for TLS contexts, to control the",
            "            verification parameters of OpenSSL.  The default is to use a",
            "            L{BrowserLikePolicyForHTTPS}, so unless you have special",
            "            requirements you can leave this as-is.",
            "        @type contextFactory: L{IPolicyForHTTPS}.",
            "",
            "        @param connectTimeout: The amount of time that this L{Agent} will wait",
            "            for the peer to accept a connection.",
            "        @type connectTimeout: L{float}",
            "",
            "        @param bindAddress: The local address for client sockets to bind to.",
            "        @type bindAddress: L{bytes}",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "        \"\"\"",
            "        if not IPolicyForHTTPS.providedBy(contextFactory):",
            "            warnings.warn(",
            "                repr(contextFactory)",
            "                + \" was passed as the HTTPS policy for an Agent, but it does \"",
            "                \"not provide IPolicyForHTTPS.  Since Twisted 14.0, you must \"",
            "                \"pass a provider of IPolicyForHTTPS.\",",
            "                stacklevel=2,",
            "                category=DeprecationWarning,",
            "            )",
            "            contextFactory = _DeprecatedToCurrentPolicyForHTTPS(contextFactory)",
            "        endpointFactory = _StandardEndpointFactory(",
            "            reactor, contextFactory, connectTimeout, bindAddress",
            "        )",
            "        self._init(reactor, endpointFactory, pool)",
            "",
            "    @classmethod",
            "    def usingEndpointFactory(cls, reactor, endpointFactory, pool=None):",
            "        \"\"\"",
            "        Create a new L{Agent} that will use the endpoint factory to figure",
            "        out how to connect to the server.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param endpointFactory: Used to construct endpoints which the",
            "            HTTP client will connect with.",
            "        @type endpointFactory: an L{IAgentEndpointFactory} provider.",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "",
            "        @return: A new L{Agent}.",
            "        \"\"\"",
            "        agent = cls.__new__(cls)",
            "        agent._init(reactor, endpointFactory, pool)",
            "        return agent",
            "",
            "    def _init(self, reactor, endpointFactory, pool):",
            "        \"\"\"",
            "        Initialize a new L{Agent}.",
            "",
            "        @param reactor: A reactor for this L{Agent} to place outgoing",
            "            connections.",
            "        @type reactor: see L{HostnameEndpoint.__init__} for acceptable reactor",
            "            types.",
            "",
            "        @param endpointFactory: Used to construct endpoints which the",
            "            HTTP client will connect with.",
            "        @type endpointFactory: an L{IAgentEndpointFactory} provider.",
            "",
            "        @param pool: An L{HTTPConnectionPool} instance, or L{None}, in which",
            "            case a non-persistent L{HTTPConnectionPool} instance will be",
            "            created.",
            "        @type pool: L{HTTPConnectionPool}",
            "",
            "        @return: A new L{Agent}.",
            "        \"\"\"",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._endpointFactory = endpointFactory",
            "",
            "    def _getEndpoint(self, uri):",
            "        \"\"\"",
            "        Get an endpoint for the given URI, using C{self._endpointFactory}.",
            "",
            "        @param uri: The URI of the request.",
            "        @type uri: L{URI}",
            "",
            "        @return: An endpoint which can be used to connect to given address.",
            "        \"\"\"",
            "        return self._endpointFactory.endpointForURI(uri)",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a request to the server indicated by the given C{uri}.",
            "",
            "        An existing connection from the connection pool may be used or a new",
            "        one may be created.",
            "",
            "        I{HTTP} and I{HTTPS} schemes are supported in C{uri}.",
            "",
            "        @see: L{twisted.web.iweb.IAgent.request}",
            "        \"\"\"",
            "        uri = _ensureValidURI(uri.strip())",
            "        parsedURI = URI.fromBytes(uri)",
            "        try:",
            "            endpoint = self._getEndpoint(parsedURI)",
            "        except SchemeNotSupported:",
            "            return defer.fail(Failure())",
            "        key = (parsedURI.scheme, parsedURI.host, parsedURI.port)",
            "        return self._requestWithEndpoint(",
            "            key,",
            "            endpoint,",
            "            method,",
            "            parsedURI,",
            "            headers,",
            "            bodyProducer,",
            "            parsedURI.originForm,",
            "        )",
            "",
            "",
            "@implementer(IAgent)",
            "class ProxyAgent(_AgentBase):",
            "    \"\"\"",
            "    An HTTP agent able to cross HTTP proxies.",
            "",
            "    @ivar _proxyEndpoint: The endpoint used to connect to the proxy.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, endpoint, reactor=None, pool=None):",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        _AgentBase.__init__(self, reactor, pool)",
            "        self._proxyEndpoint = endpoint",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request via the configured proxy.",
            "        \"\"\"",
            "        uri = _ensureValidURI(uri.strip())",
            "",
            "        # Cache *all* connections under the same key, since we are only",
            "        # connecting to a single destination, the proxy:",
            "        key = (\"http-proxy\", self._proxyEndpoint)",
            "",
            "        # To support proxying HTTPS via CONNECT, we will use key",
            "        # (\"http-proxy-CONNECT\", scheme, host, port), and an endpoint that",
            "        # wraps _proxyEndpoint with an additional callback to do the CONNECT.",
            "        return self._requestWithEndpoint(",
            "            key,",
            "            self._proxyEndpoint,",
            "            method,",
            "            URI.fromBytes(uri),",
            "            headers,",
            "            bodyProducer,",
            "            uri,",
            "        )",
            "",
            "",
            "class _FakeUrllib2Request:",
            "    \"\"\"",
            "    A fake C{urllib2.Request} object for C{cookielib} to work with.",
            "",
            "    @see: U{http://docs.python.org/library/urllib2.html#request-objects}",
            "",
            "    @type uri: native L{str}",
            "    @ivar uri: Request URI.",
            "",
            "    @type headers: L{twisted.web.http_headers.Headers}",
            "    @ivar headers: Request headers.",
            "",
            "    @type type: native L{str}",
            "    @ivar type: The scheme of the URI.",
            "",
            "    @type host: native L{str}",
            "    @ivar host: The host[:port] of the URI.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, uri):",
            "        \"\"\"",
            "        Create a fake Urllib2 request.",
            "",
            "        @param uri: Request URI.",
            "        @type uri: L{bytes}",
            "        \"\"\"",
            "        self.uri = nativeString(uri)",
            "        self.headers = Headers()",
            "",
            "        _uri = URI.fromBytes(uri)",
            "        self.type = nativeString(_uri.scheme)",
            "        self.host = nativeString(_uri.host)",
            "",
            "        if (_uri.scheme, _uri.port) not in ((b\"http\", 80), (b\"https\", 443)):",
            "            # If it's not a schema on the regular port, add the port.",
            "            self.host += \":\" + str(_uri.port)",
            "",
            "        self.origin_req_host = nativeString(_uri.host)",
            "        self.unverifiable = lambda _: False",
            "",
            "    def has_header(self, header):",
            "        return self.headers.hasHeader(networkString(header))",
            "",
            "    def add_unredirected_header(self, name, value):",
            "        self.headers.addRawHeader(networkString(name), networkString(value))",
            "",
            "    def get_full_url(self):",
            "        return self.uri",
            "",
            "    def get_header(self, name, default=None):",
            "        headers = self.headers.getRawHeaders(networkString(name), default)",
            "        if headers is not None:",
            "            headers = [nativeString(x) for x in headers]",
            "            return headers[0]",
            "        return None",
            "",
            "    def get_host(self):",
            "        return self.host",
            "",
            "    def get_type(self):",
            "        return self.type",
            "",
            "    def is_unverifiable(self):",
            "        # In theory this shouldn't be hardcoded.",
            "        return False",
            "",
            "",
            "class _FakeUrllib2Response:",
            "    \"\"\"",
            "    A fake C{urllib2.Response} object for C{cookielib} to work with.",
            "",
            "    @type response: C{twisted.web.iweb.IResponse}",
            "    @ivar response: Underlying Twisted Web response.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.response = response",
            "",
            "    def info(self):",
            "        class _Meta:",
            "            def getheaders(zelf, name):",
            "                # PY2",
            "                headers = self.response.headers.getRawHeaders(name, [])",
            "                return headers",
            "",
            "            def get_all(zelf, name, default):",
            "                # PY3",
            "                headers = self.response.headers.getRawHeaders(",
            "                    networkString(name), default",
            "                )",
            "                h = [nativeString(x) for x in headers]",
            "                return h",
            "",
            "        return _Meta()",
            "",
            "",
            "@implementer(IAgent)",
            "class CookieAgent:",
            "    \"\"\"",
            "    L{CookieAgent} extends the basic L{Agent} to add RFC-compliant",
            "    handling of HTTP cookies.  Cookies are written to and extracted",
            "    from a C{cookielib.CookieJar} instance.",
            "",
            "    The same cookie jar instance will be used for any requests through this",
            "    agent, mutating it whenever a I{Set-Cookie} header appears in a response.",
            "",
            "    @type _agent: L{twisted.web.client.Agent}",
            "    @ivar _agent: Underlying Twisted Web agent to issue requests through.",
            "",
            "    @type cookieJar: C{cookielib.CookieJar}",
            "    @ivar cookieJar: Initialized cookie jar to read cookies from and store",
            "        cookies to.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, cookieJar):",
            "        self._agent = agent",
            "        self.cookieJar = cookieJar",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Issue a new request to the wrapped L{Agent}.",
            "",
            "        Send a I{Cookie} header if a cookie for C{uri} is stored in",
            "        L{CookieAgent.cookieJar}. Cookies are automatically extracted and",
            "        stored from requests.",
            "",
            "        If a C{'cookie'} header appears in C{headers} it will override the",
            "        automatic cookie header obtained from the cookie jar.",
            "",
            "        @see: L{Agent.request}",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        lastRequest = _FakeUrllib2Request(uri)",
            "        # Setting a cookie header explicitly will disable automatic request",
            "        # cookies.",
            "        if not headers.hasHeader(b\"cookie\"):",
            "            self.cookieJar.add_cookie_header(lastRequest)",
            "            cookieHeader = lastRequest.get_header(\"Cookie\", None)",
            "            if cookieHeader is not None:",
            "                headers = headers.copy()",
            "                headers.addRawHeader(b\"cookie\", networkString(cookieHeader))",
            "",
            "        d = self._agent.request(method, uri, headers, bodyProducer)",
            "        d.addCallback(self._extractCookies, lastRequest)",
            "        return d",
            "",
            "    def _extractCookies(self, response, request):",
            "        \"\"\"",
            "        Extract response cookies and store them in the cookie jar.",
            "",
            "        @type response: L{twisted.web.iweb.IResponse}",
            "        @param response: Twisted Web response.",
            "",
            "        @param request: A urllib2 compatible request object.",
            "        \"\"\"",
            "        resp = _FakeUrllib2Response(response)",
            "        self.cookieJar.extract_cookies(resp, request)",
            "        return response",
            "",
            "",
            "class GzipDecoder(proxyForInterface(IResponse)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A wrapper for a L{Response} instance which handles gzip'ed body.",
            "",
            "    @ivar original: The original L{Response} object.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, response):",
            "        self.original = response",
            "        self.length = UNKNOWN_LENGTH",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Override C{deliverBody} to wrap the given C{protocol} with",
            "        L{_GzipProtocol}.",
            "        \"\"\"",
            "        self.original.deliverBody(_GzipProtocol(protocol, self.original))",
            "",
            "",
            "class _GzipProtocol(proxyForInterface(IProtocol)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A L{Protocol} implementation which wraps another one, transparently",
            "    decompressing received data.",
            "",
            "    @ivar _zlibDecompress: A zlib decompress object used to decompress the data",
            "        stream.",
            "",
            "    @ivar _response: A reference to the original response, in case of errors.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    def __init__(self, protocol, response):",
            "        self.original = protocol",
            "        self._response = response",
            "        self._zlibDecompress = zlib.decompressobj(16 + zlib.MAX_WBITS)",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Decompress C{data} with the zlib decompressor, forwarding the raw data",
            "        to the original protocol.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.decompress(data)",
            "        except zlib.error:",
            "            raise ResponseFailed([Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Forward the connection lost event, flushing remaining data from the",
            "        decompressor if any.",
            "        \"\"\"",
            "        try:",
            "            rawData = self._zlibDecompress.flush()",
            "        except zlib.error:",
            "            raise ResponseFailed([reason, Failure()], self._response)",
            "        if rawData:",
            "            self.original.dataReceived(rawData)",
            "        self.original.connectionLost(reason)",
            "",
            "",
            "@implementer(IAgent)",
            "class ContentDecoderAgent:",
            "    \"\"\"",
            "    An L{Agent} wrapper to handle encoded content.",
            "",
            "    It takes care of declaring the support for content in the",
            "    I{Accept-Encoding} header and automatically decompresses the received data",
            "    if the I{Content-Encoding} header indicates a supported encoding.",
            "",
            "    For example::",
            "",
            "        agent = ContentDecoderAgent(Agent(reactor),",
            "                                    [(b'gzip', GzipDecoder)])",
            "",
            "    @param agent: The agent to wrap",
            "    @type agent: L{IAgent}",
            "",
            "    @param decoders: A sequence of (name, decoder) objects. The name",
            "        declares which encoding the decoder supports. The decoder must accept",
            "        an L{IResponse} and return an L{IResponse} when called. The order",
            "        determines how the decoders are advertised to the server. Names must",
            "        be unique.not be duplicated.",
            "    @type decoders: sequence of (L{bytes}, L{callable}) tuples",
            "",
            "    @since: 11.1",
            "",
            "    @see: L{GzipDecoder}",
            "    \"\"\"",
            "",
            "    def __init__(self, agent, decoders):",
            "        self._agent = agent",
            "        self._decoders = dict(decoders)",
            "        self._supported = b\",\".join([decoder[0] for decoder in decoders])",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request which declares supporting compressed content.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        else:",
            "            headers = headers.copy()",
            "        headers.addRawHeader(b\"accept-encoding\", self._supported)",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse)",
            "",
            "    def _handleResponse(self, response):",
            "        \"\"\"",
            "        Check if the response is encoded, and wrap it to handle decompression.",
            "        \"\"\"",
            "        contentEncodingHeaders = response.headers.getRawHeaders(b\"content-encoding\", [])",
            "        contentEncodingHeaders = b\",\".join(contentEncodingHeaders).split(b\",\")",
            "        while contentEncodingHeaders:",
            "            name = contentEncodingHeaders.pop().strip()",
            "            decoder = self._decoders.get(name)",
            "            if decoder is not None:",
            "                response = decoder(response)",
            "            else:",
            "                # Add it back",
            "                contentEncodingHeaders.append(name)",
            "                break",
            "        if contentEncodingHeaders:",
            "            response.headers.setRawHeaders(",
            "                b\"content-encoding\", [b\",\".join(contentEncodingHeaders)]",
            "            )",
            "        else:",
            "            response.headers.removeHeader(b\"content-encoding\")",
            "        return response",
            "",
            "",
            "_canonicalHeaderName = Headers()._canonicalNameCaps",
            "_defaultSensitiveHeaders = frozenset(",
            "    [",
            "        b\"Authorization\",",
            "        b\"Cookie\",",
            "        b\"Cookie2\",",
            "        b\"Proxy-Authorization\",",
            "        b\"WWW-Authenticate\",",
            "    ]",
            ")",
            "",
            "",
            "@implementer(IAgent)",
            "class RedirectAgent:",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects.",
            "",
            "    The implementation is rather strict: 301 and 302 behaves like 307, not",
            "    redirecting automatically on methods different from I{GET} and I{HEAD}.",
            "",
            "    See L{BrowserLikeRedirectAgent} for a redirecting Agent that behaves more",
            "    like a web browser.",
            "",
            "    @param redirectLimit: The maximum number of times the agent is allowed to",
            "        follow redirects before failing with a L{error.InfiniteRedirection}.",
            "",
            "    @param sensitiveHeaderNames: An iterable of C{bytes} enumerating the names",
            "        of headers that must not be transmitted when redirecting to a different",
            "        origins.  These will be consulted in addition to the protocol-specified",
            "        set of headers that contain sensitive information.",
            "",
            "    @cvar _redirectResponses: A L{list} of HTTP status codes to be redirected",
            "        for I{GET} and I{HEAD} methods.",
            "",
            "    @cvar _seeOtherResponses: A L{list} of HTTP status codes to be redirected",
            "        for any method and the method altered to I{GET}.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [",
            "        http.MOVED_PERMANENTLY,",
            "        http.FOUND,",
            "        http.TEMPORARY_REDIRECT,",
            "        http.PERMANENT_REDIRECT,",
            "    ]",
            "    _seeOtherResponses = [http.SEE_OTHER]",
            "",
            "    def __init__(",
            "        self,",
            "        agent: IAgent,",
            "        redirectLimit: int = 20,",
            "        sensitiveHeaderNames: Iterable[bytes] = (),",
            "    ):",
            "        self._agent = agent",
            "        self._redirectLimit = redirectLimit",
            "        sensitive = {_canonicalHeaderName(each) for each in sensitiveHeaderNames}",
            "        sensitive.update(_defaultSensitiveHeaders)",
            "        self._sensitiveHeaderNames = sensitive",
            "",
            "    def request(self, method, uri, headers=None, bodyProducer=None):",
            "        \"\"\"",
            "        Send a client request following HTTP redirects.",
            "",
            "        @see: L{Agent.request}.",
            "        \"\"\"",
            "        deferred = self._agent.request(method, uri, headers, bodyProducer)",
            "        return deferred.addCallback(self._handleResponse, method, uri, headers, 0)",
            "",
            "    def _resolveLocation(self, requestURI, location):",
            "        \"\"\"",
            "        Resolve the redirect location against the request I{URI}.",
            "",
            "        @type requestURI: C{bytes}",
            "        @param requestURI: The request I{URI}.",
            "",
            "        @type location: C{bytes}",
            "        @param location: The redirect location.",
            "",
            "        @rtype: C{bytes}",
            "        @return: Final resolved I{URI}.",
            "        \"\"\"",
            "        return _urljoin(requestURI, location)",
            "",
            "    def _handleRedirect(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle a redirect response, checking the number of redirects already",
            "        followed, and extracting the location header fields.",
            "        \"\"\"",
            "        if redirectCount >= self._redirectLimit:",
            "            err = error.InfiniteRedirection(",
            "                response.code, b\"Infinite redirection detected\", location=uri",
            "            )",
            "            raise ResponseFailed([Failure(err)], response)",
            "        locationHeaders = response.headers.getRawHeaders(b\"location\", [])",
            "        if not locationHeaders:",
            "            err = error.RedirectWithNoLocation(",
            "                response.code, b\"No location header field\", uri",
            "            )",
            "            raise ResponseFailed([Failure(err)], response)",
            "        location = self._resolveLocation(uri, locationHeaders[0])",
            "        if headers:",
            "            parsedURI = URI.fromBytes(uri)",
            "            parsedLocation = URI.fromBytes(location)",
            "            sameOrigin = (",
            "                (parsedURI.scheme == parsedLocation.scheme)",
            "                and (parsedURI.host == parsedLocation.host)",
            "                and (parsedURI.port == parsedLocation.port)",
            "            )",
            "            if not sameOrigin:",
            "                headers = Headers(",
            "                    {",
            "                        rawName: rawValue",
            "                        for rawName, rawValue in headers.getAllRawHeaders()",
            "                        if rawName not in self._sensitiveHeaderNames",
            "                    }",
            "                )",
            "        deferred = self._agent.request(method, location, headers)",
            "",
            "        def _chainResponse(newResponse):",
            "            newResponse.setPreviousResponse(response)",
            "            return newResponse",
            "",
            "        deferred.addCallback(_chainResponse)",
            "        return deferred.addCallback(",
            "            self._handleResponse, method, uri, headers, redirectCount + 1",
            "        )",
            "",
            "    def _handleResponse(self, response, method, uri, headers, redirectCount):",
            "        \"\"\"",
            "        Handle the response, making another request if it indicates a redirect.",
            "        \"\"\"",
            "        if response.code in self._redirectResponses:",
            "            if method not in (b\"GET\", b\"HEAD\"):",
            "                err = error.PageRedirect(response.code, location=uri)",
            "                raise ResponseFailed([Failure(err)], response)",
            "            return self._handleRedirect(response, method, uri, headers, redirectCount)",
            "        elif response.code in self._seeOtherResponses:",
            "            return self._handleRedirect(response, b\"GET\", uri, headers, redirectCount)",
            "        return response",
            "",
            "",
            "class BrowserLikeRedirectAgent(RedirectAgent):",
            "    \"\"\"",
            "    An L{Agent} wrapper which handles HTTP redirects in the same fashion as web",
            "    browsers.",
            "",
            "    Unlike L{RedirectAgent}, the implementation is more relaxed: 301 and 302",
            "    behave like 303, redirecting automatically on any method and altering the",
            "    redirect request to a I{GET}.",
            "",
            "    @see: L{RedirectAgent}",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "",
            "    _redirectResponses = [http.TEMPORARY_REDIRECT]",
            "    _seeOtherResponses = [",
            "        http.MOVED_PERMANENTLY,",
            "        http.FOUND,",
            "        http.SEE_OTHER,",
            "        http.PERMANENT_REDIRECT,",
            "    ]",
            "",
            "",
            "class _ReadBodyProtocol(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol that collects data sent to it.",
            "",
            "    This is a helper for L{IResponse.deliverBody}, which collects the body and",
            "    fires a deferred with it.",
            "",
            "    @ivar deferred: See L{__init__}.",
            "    @ivar status: See L{__init__}.",
            "    @ivar message: See L{__init__}.",
            "",
            "    @ivar dataBuffer: list of byte-strings received",
            "    @type dataBuffer: L{list} of L{bytes}",
            "    \"\"\"",
            "",
            "    def __init__(self, status, message, deferred):",
            "        \"\"\"",
            "        @param status: Status of L{IResponse}",
            "        @ivar status: L{int}",
            "",
            "        @param message: Message of L{IResponse}",
            "        @type message: L{bytes}",
            "",
            "        @param deferred: deferred to fire when response is complete",
            "        @type deferred: L{Deferred} firing with L{bytes}",
            "        \"\"\"",
            "        self.deferred = deferred",
            "        self.status = status",
            "        self.message = message",
            "        self.dataBuffer = []",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        Accumulate some more bytes from the response.",
            "        \"\"\"",
            "        self.dataBuffer.append(data)",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        Deliver the accumulated response bytes to the waiting L{Deferred}, if",
            "        the response body has been completely received without error.",
            "        \"\"\"",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(b\"\".join(self.dataBuffer))",
            "        elif reason.check(PotentialDataLoss):",
            "            self.deferred.errback(",
            "                PartialDownloadError(",
            "                    self.status, self.message, b\"\".join(self.dataBuffer)",
            "                )",
            "            )",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def readBody(response: IResponse) -> defer.Deferred[bytes]:",
            "    \"\"\"",
            "    Get the body of an L{IResponse} and return it as a byte string.",
            "",
            "    This is a helper function for clients that don't want to incrementally",
            "    receive the body of an HTTP response.",
            "",
            "    @param response: The HTTP response for which the body will be read.",
            "    @type response: L{IResponse} provider",
            "",
            "    @return: A L{Deferred} which will fire with the body of the response.",
            "        Cancelling it will close the connection to the server immediately.",
            "    \"\"\"",
            "",
            "    def cancel(deferred: defer.Deferred) -> None:",
            "        \"\"\"",
            "        Cancel a L{readBody} call, close the connection to the HTTP server",
            "        immediately, if it is still open.",
            "",
            "        @param deferred: The cancelled L{defer.Deferred}.",
            "        \"\"\"",
            "        abort = getAbort()",
            "        if abort is not None:",
            "            abort()",
            "",
            "    d: defer.Deferred[bytes] = defer.Deferred(cancel)",
            "    protocol = _ReadBodyProtocol(response.code, response.phrase, d)",
            "",
            "    def getAbort():",
            "        return getattr(protocol.transport, \"abortConnection\", None)",
            "",
            "    response.deliverBody(protocol)",
            "",
            "    if protocol.transport is not None and getAbort() is None:",
            "        warnings.warn(",
            "            \"Using readBody with a transport that does not have an \"",
            "            \"abortConnection method\",",
            "            category=DeprecationWarning,",
            "            stacklevel=2,",
            "        )",
            "",
            "    return d",
            "",
            "",
            "__all__ = [",
            "    \"Agent\",",
            "    \"BrowserLikePolicyForHTTPS\",",
            "    \"BrowserLikeRedirectAgent\",",
            "    \"ContentDecoderAgent\",",
            "    \"CookieAgent\",",
            "    \"downloadPage\",",
            "    \"getPage\",",
            "    \"GzipDecoder\",",
            "    \"HTTPClientFactory\",",
            "    \"HTTPConnectionPool\",",
            "    \"HTTPDownloader\",",
            "    \"HTTPPageDownloader\",",
            "    \"HTTPPageGetter\",",
            "    \"PartialDownloadError\",",
            "    \"ProxyAgent\",",
            "    \"readBody\",",
            "    \"RedirectAgent\",",
            "    \"RequestGenerationFailed\",",
            "    \"RequestTransmissionFailed\",",
            "    \"Response\",",
            "    \"ResponseDone\",",
            "    \"ResponseFailed\",",
            "    \"ResponseNeverReceived\",",
            "    \"URI\",",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2144": [
                "RedirectAgent",
                "__init__"
            ]
        },
        "addLocation": [
            "src.twisted.web.client.RedirectAgent._seeOtherResponses",
            "src.twisted.web.client.RedirectAgent.self",
            "src.twisted.web.client.RedirectAgent._redirectResponses"
        ]
    },
    "src/twisted/web/iweb.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 713,
                "afterPatchRowNumber": 713,
                "PatchRowcode": "     obtained by combining a number of (hypothetical) implementations::"
            },
            "1": {
                "beforePatchRowNumber": 714,
                "afterPatchRowNumber": 714,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 715,
                "afterPatchRowNumber": 715,
                "PatchRowcode": "         baseAgent = Agent(reactor)"
            },
            "3": {
                "beforePatchRowNumber": 716,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        redirect = BrowserLikeRedirectAgent(baseAgent, limit=10)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 716,
                "PatchRowcode": "+        decode = ContentDecoderAgent(baseAgent, [(b\"gzip\", GzipDecoder())])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 717,
                "PatchRowcode": "+        cookie = CookieAgent(decode, diskStore.cookie)"
            },
            "6": {
                "beforePatchRowNumber": 717,
                "afterPatchRowNumber": 718,
                "PatchRowcode": "         authenticate = AuthenticateAgent("
            },
            "7": {
                "beforePatchRowNumber": 718,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            redirect, [diskStore.credentials, GtkAuthInterface()])"
            },
            "8": {
                "beforePatchRowNumber": 719,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cookie = CookieAgent(authenticate, diskStore.cookie)"
            },
            "9": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        decode = ContentDecoderAgent(cookie, [(b\"gzip\", GzipDecoder())])"
            },
            "10": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cache = CacheAgent(decode, diskStore.cache)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 719,
                "PatchRowcode": "+            cookie, [diskStore.credentials, GtkAuthInterface()])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 720,
                "PatchRowcode": "+        cache = CacheAgent(authenticate, diskStore.cache)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 721,
                "PatchRowcode": "+        redirect = BrowserLikeRedirectAgent(cache, limit=10)"
            },
            "14": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 722,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 723,
                "PatchRowcode": "         doSomeRequests(cache)"
            },
            "16": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 724,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: twisted.web.test -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Interface definitions for L{twisted.web}.",
            "",
            "@var UNKNOWN_LENGTH: An opaque object which may be used as the value of",
            "    L{IBodyProducer.length} to indicate that the length of the entity",
            "    body is not known in advance.",
            "\"\"\"",
            "from typing import TYPE_CHECKING, Callable, List, Optional",
            "",
            "from zope.interface import Attribute, Interface",
            "",
            "from twisted.cred.credentials import IUsernameDigestHash",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.interfaces import IPushProducer",
            "from twisted.web.http_headers import Headers",
            "",
            "if TYPE_CHECKING:",
            "    from twisted.web.template import Flattenable, Tag",
            "",
            "",
            "class IRequest(Interface):",
            "    \"\"\"",
            "    An HTTP request.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    method = Attribute(\"A L{bytes} giving the HTTP method that was used.\")",
            "    uri = Attribute(",
            "        \"A L{bytes} giving the full encoded URI which was requested (including\"",
            "        \" query arguments).\"",
            "    )",
            "    path = Attribute(",
            "        \"A L{bytes} giving the encoded query path of the request URI (not \"",
            "        \"including query arguments).\"",
            "    )",
            "    args = Attribute(",
            "        \"A mapping of decoded query argument names as L{bytes} to \"",
            "        \"corresponding query argument values as L{list}s of L{bytes}.  \"",
            "        \"For example, for a URI with C{foo=bar&foo=baz&quux=spam} \"",
            "        \"for its query part, C{args} will be C{{b'foo': [b'bar', b'baz'], \"",
            "        \"b'quux': [b'spam']}}.\"",
            "    )",
            "",
            "    prepath = Attribute(",
            "        \"The URL path segments which have been processed during resource \"",
            "        \"traversal, as a list of L{bytes}.\"",
            "    )",
            "",
            "    postpath = Attribute(",
            "        \"The URL path segments which have not (yet) been processed \"",
            "        \"during resource traversal, as a list of L{bytes}.\"",
            "    )",
            "",
            "    requestHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance giving all received HTTP request \"",
            "        \"headers.\"",
            "    )",
            "",
            "    content = Attribute(",
            "        \"A file-like object giving the request body.  This may be a file on \"",
            "        \"disk, an L{io.BytesIO}, or some other type.  The implementation is \"",
            "        \"free to decide on a per-request basis.\"",
            "    )",
            "",
            "    responseHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance holding all HTTP response \"",
            "        \"headers to be sent.\"",
            "    )",
            "",
            "    def getHeader(key):",
            "        \"\"\"",
            "        Get an HTTP request header.",
            "",
            "        @type key: L{bytes} or L{str}",
            "        @param key: The name of the header to get the value of.",
            "",
            "        @rtype: L{bytes} or L{str} or L{None}",
            "        @return: The value of the specified header, or L{None} if that header",
            "            was not present in the request. The string type of the result",
            "            matches the type of C{key}.",
            "        \"\"\"",
            "",
            "    def getCookie(key):",
            "        \"\"\"",
            "        Get a cookie that was sent from the network.",
            "",
            "        @type key: L{bytes}",
            "        @param key: The name of the cookie to get.",
            "",
            "        @rtype: L{bytes} or L{None}",
            "        @returns: The value of the specified cookie, or L{None} if that cookie",
            "            was not present in the request.",
            "        \"\"\"",
            "",
            "    def getAllHeaders():",
            "        \"\"\"",
            "        Return dictionary mapping the names of all received headers to the last",
            "        value received for each.",
            "",
            "        Since this method does not return all header information,",
            "        C{requestHeaders.getAllRawHeaders()} may be preferred.",
            "        \"\"\"",
            "",
            "    def getRequestHostname():",
            "        \"\"\"",
            "        Get the hostname that the HTTP client passed in to the request.",
            "",
            "        This will either use the C{Host:} header (if it is available; which,",
            "        for a spec-compliant request, it will be) or the IP address of the host",
            "        we are listening on if the header is unavailable.",
            "",
            "        @note: This is the I{host portion} of the requested resource, which",
            "            means that:",
            "",
            "                1. it might be an IPv4 or IPv6 address, not just a DNS host",
            "                   name,",
            "",
            "                2. there's no guarantee it's even a I{valid} host name or IP",
            "                   address, since the C{Host:} header may be malformed,",
            "",
            "                3. it does not include the port number.",
            "",
            "        @returns: the requested hostname",
            "",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    def getHost():",
            "        \"\"\"",
            "        Get my originally requesting transport's host.",
            "",
            "        @return: An L{IAddress<twisted.internet.interfaces.IAddress>}.",
            "        \"\"\"",
            "",
            "    def getClientAddress():",
            "        \"\"\"",
            "        Return the address of the client who submitted this request.",
            "",
            "        The address may not be a network address.  Callers must check",
            "        its type before using it.",
            "",
            "        @since: 18.4",
            "",
            "        @return: the client's address.",
            "        @rtype: an L{IAddress} provider.",
            "        \"\"\"",
            "",
            "    def getClientIP():",
            "        \"\"\"",
            "        Return the IP address of the client who submitted this request.",
            "",
            "        This method is B{deprecated}.  See L{getClientAddress} instead.",
            "",
            "        @returns: the client IP address or L{None} if the request was submitted",
            "            over a transport where IP addresses do not make sense.",
            "        @rtype: L{str} or L{None}",
            "        \"\"\"",
            "",
            "    def getUser():",
            "        \"\"\"",
            "        Return the HTTP user sent with this request, if any.",
            "",
            "        If no user was supplied, return the empty string.",
            "",
            "        @returns: the HTTP user, if any",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def getPassword():",
            "        \"\"\"",
            "        Return the HTTP password sent with this request, if any.",
            "",
            "        If no password was supplied, return the empty string.",
            "",
            "        @returns: the HTTP password, if any",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def isSecure():",
            "        \"\"\"",
            "        Return True if this request is using a secure transport.",
            "",
            "        Normally this method returns True if this request's HTTPChannel",
            "        instance is using a transport that implements ISSLTransport.",
            "",
            "        This will also return True if setHost() has been called",
            "        with ssl=True.",
            "",
            "        @returns: True if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "",
            "    def getSession(sessionInterface=None):",
            "        \"\"\"",
            "        Look up the session associated with this request or create a new one if",
            "        there is not one.",
            "",
            "        @return: The L{Session} instance identified by the session cookie in",
            "            the request, or the C{sessionInterface} component of that session",
            "            if C{sessionInterface} is specified.",
            "        \"\"\"",
            "",
            "    def URLPath():",
            "        \"\"\"",
            "        @return: A L{URLPath<twisted.python.urlpath.URLPath>} instance",
            "            which identifies the URL for which this request is.",
            "        \"\"\"",
            "",
            "    def prePathURL():",
            "        \"\"\"",
            "        At any time during resource traversal or resource rendering,",
            "        returns an absolute URL to the most nested resource which has",
            "        yet been reached.",
            "",
            "        @see: {twisted.web.server.Request.prepath}",
            "",
            "        @return: An absolute URL.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    def rememberRootURL():",
            "        \"\"\"",
            "        Remember the currently-processed part of the URL for later",
            "        recalling.",
            "        \"\"\"",
            "",
            "    def getRootURL():",
            "        \"\"\"",
            "        Get a previously-remembered URL.",
            "",
            "        @return: An absolute URL.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    # Methods for outgoing response",
            "    def finish():",
            "        \"\"\"",
            "        Indicate that the response to this request is complete.",
            "        \"\"\"",
            "",
            "    def write(data):",
            "        \"\"\"",
            "        Write some data to the body of the response to this request.  Response",
            "        headers are written the first time this method is called, after which",
            "        new response headers may not be added.",
            "",
            "        @param data: Bytes of the response body.",
            "        @type data: L{bytes}",
            "        \"\"\"",
            "",
            "    def addCookie(",
            "        k,",
            "        v,",
            "        expires=None,",
            "        domain=None,",
            "        path=None,",
            "        max_age=None,",
            "        comment=None,",
            "        secure=None,",
            "    ):",
            "        \"\"\"",
            "        Set an outgoing HTTP cookie.",
            "",
            "        In general, you should consider using sessions instead of cookies, see",
            "        L{twisted.web.server.Request.getSession} and the",
            "        L{twisted.web.server.Session} class for details.",
            "        \"\"\"",
            "",
            "    def setResponseCode(code, message=None):",
            "        \"\"\"",
            "        Set the HTTP response code.",
            "",
            "        @type code: L{int}",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "",
            "    def setHeader(k, v):",
            "        \"\"\"",
            "        Set an HTTP response header.  Overrides any previously set values for",
            "        this header.",
            "",
            "        @type k: L{bytes} or L{str}",
            "        @param k: The name of the header for which to set the value.",
            "",
            "        @type v: L{bytes} or L{str}",
            "        @param v: The value to set for the named header. A L{str} will be",
            "            UTF-8 encoded, which may not interoperable with other",
            "            implementations. Avoid passing non-ASCII characters if possible.",
            "        \"\"\"",
            "",
            "    def redirect(url):",
            "        \"\"\"",
            "        Utility function that does a redirect.",
            "",
            "        The request should have finish() called after this.",
            "        \"\"\"",
            "",
            "    def setLastModified(when):",
            "        \"\"\"",
            "        Set the C{Last-Modified} time for the response to this request.",
            "",
            "        If I am called more than once, I ignore attempts to set Last-Modified",
            "        earlier, only replacing the Last-Modified time if it is to a later",
            "        value.",
            "",
            "        If I am a conditional request, I may modify my response code to",
            "        L{NOT_MODIFIED<http.NOT_MODIFIED>} if appropriate for the time given.",
            "",
            "        @param when: The last time the resource being returned was modified, in",
            "            seconds since the epoch.",
            "        @type when: L{int} or L{float}",
            "",
            "        @return: If I am a C{If-Modified-Since} conditional request and the time",
            "            given is not newer than the condition, I return",
            "            L{CACHED<http.CACHED>} to indicate that you should write no body.",
            "            Otherwise, I return a false value.",
            "        \"\"\"",
            "",
            "    def setETag(etag):",
            "        \"\"\"",
            "        Set an C{entity tag} for the outgoing response.",
            "",
            "        That's \"entity tag\" as in the HTTP/1.1 I{ETag} header, \"used for",
            "        comparing two or more entities from the same requested resource.\"",
            "",
            "        If I am a conditional request, I may modify my response code to",
            "        L{NOT_MODIFIED<http.NOT_MODIFIED>} or",
            "        L{PRECONDITION_FAILED<http.PRECONDITION_FAILED>}, if appropriate for the",
            "        tag given.",
            "",
            "        @param etag: The entity tag for the resource being returned.",
            "        @type etag: L{str}",
            "",
            "        @return: If I am a C{If-None-Match} conditional request and the tag",
            "            matches one in the request, I return L{CACHED<http.CACHED>} to",
            "            indicate that you should write no body.  Otherwise, I return a",
            "            false value.",
            "        \"\"\"",
            "",
            "    def setHost(host, port, ssl=0):",
            "        \"\"\"",
            "        Change the host and port the request thinks it's using.",
            "",
            "        This method is useful for working with reverse HTTP proxies (e.g.  both",
            "        Squid and Apache's mod_proxy can do this), when the address the HTTP",
            "        client is using is different than the one we're listening on.",
            "",
            "        For example, Apache may be listening on https://www.example.com, and",
            "        then forwarding requests to http://localhost:8080, but we don't want",
            "        HTML produced by Twisted to say 'http://localhost:8080', they should",
            "        say 'https://www.example.com', so we do::",
            "",
            "           request.setHost('www.example.com', 443, ssl=1)",
            "        \"\"\"",
            "",
            "",
            "class INonQueuedRequestFactory(Interface):",
            "    \"\"\"",
            "    A factory of L{IRequest} objects that does not take a ``queued`` parameter.",
            "    \"\"\"",
            "",
            "    def __call__(channel):",
            "        \"\"\"",
            "        Create an L{IRequest} that is operating on the given channel. There",
            "        must only be one L{IRequest} object processing at any given time on a",
            "        channel.",
            "",
            "        @param channel: A L{twisted.web.http.HTTPChannel} object.",
            "        @type channel: L{twisted.web.http.HTTPChannel}",
            "",
            "        @return: A request object.",
            "        @rtype: L{IRequest}",
            "        \"\"\"",
            "",
            "",
            "class IAccessLogFormatter(Interface):",
            "    \"\"\"",
            "    An object which can represent an HTTP request as a line of text for",
            "    inclusion in an access log file.",
            "    \"\"\"",
            "",
            "    def __call__(timestamp, request):",
            "        \"\"\"",
            "        Generate a line for the access log.",
            "",
            "        @param timestamp: The time at which the request was completed in the",
            "            standard format for access logs.",
            "        @type timestamp: L{unicode}",
            "",
            "        @param request: The request object about which to log.",
            "        @type request: L{twisted.web.server.Request}",
            "",
            "        @return: One line describing the request without a trailing newline.",
            "        @rtype: L{unicode}",
            "        \"\"\"",
            "",
            "",
            "class ICredentialFactory(Interface):",
            "    \"\"\"",
            "    A credential factory defines a way to generate a particular kind of",
            "    authentication challenge and a way to interpret the responses to these",
            "    challenges.  It creates",
            "    L{ICredentials<twisted.cred.credentials.ICredentials>} providers from",
            "    responses.  These objects will be used with L{twisted.cred} to authenticate",
            "    an authorize requests.",
            "    \"\"\"",
            "",
            "    scheme = Attribute(",
            "        \"A L{str} giving the name of the authentication scheme with which \"",
            "        \"this factory is associated.  For example, C{'basic'} or C{'digest'}.\"",
            "    )",
            "",
            "    def getChallenge(request):",
            "        \"\"\"",
            "        Generate a new challenge to be sent to a client.",
            "",
            "        @type request: L{twisted.web.http.Request}",
            "        @param request: The request the response to which this challenge will",
            "            be included.",
            "",
            "        @rtype: L{dict}",
            "        @return: A mapping from L{str} challenge fields to associated L{str}",
            "            values.",
            "        \"\"\"",
            "",
            "    def decode(response, request):",
            "        \"\"\"",
            "        Create a credentials object from the given response.",
            "",
            "        @type response: L{str}",
            "        @param response: scheme specific response string",
            "",
            "        @type request: L{twisted.web.http.Request}",
            "        @param request: The request being processed (from which the response",
            "            was taken).",
            "",
            "        @raise twisted.cred.error.LoginFailed: If the response is invalid.",
            "",
            "        @rtype: L{twisted.cred.credentials.ICredentials} provider",
            "        @return: The credentials represented by the given response.",
            "        \"\"\"",
            "",
            "",
            "class IBodyProducer(IPushProducer):",
            "    \"\"\"",
            "    Objects which provide L{IBodyProducer} write bytes to an object which",
            "    provides L{IConsumer<twisted.internet.interfaces.IConsumer>} by calling its",
            "    C{write} method repeatedly.",
            "",
            "    L{IBodyProducer} providers may start producing as soon as they have an",
            "    L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.  That is, they",
            "    should not wait for a C{resumeProducing} call to begin writing data.",
            "",
            "    L{IConsumer.unregisterProducer<twisted.internet.interfaces.IConsumer.unregisterProducer>}",
            "    must not be called.  Instead, the",
            "    L{Deferred<twisted.internet.defer.Deferred>} returned from C{startProducing}",
            "    must be fired when all bytes have been written.",
            "",
            "    L{IConsumer.write<twisted.internet.interfaces.IConsumer.write>} may",
            "    synchronously invoke any of C{pauseProducing}, C{resumeProducing}, or",
            "    C{stopProducing}.  These methods must be implemented with this in mind.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    # Despite the restrictions above and the additional requirements of",
            "    # stopProducing documented below, this interface still needs to be an",
            "    # IPushProducer subclass.  Providers of it will be passed to IConsumer",
            "    # providers which only know about IPushProducer and IPullProducer, not",
            "    # about this interface.  This interface needs to remain close enough to one",
            "    # of those interfaces for consumers to work with it.",
            "",
            "    length = Attribute(",
            "        \"\"\"",
            "        C{length} is a L{int} indicating how many bytes in total this",
            "        L{IBodyProducer} will write to the consumer or L{UNKNOWN_LENGTH}",
            "        if this is not known in advance.",
            "        \"\"\"",
            "    )",
            "",
            "    def startProducing(consumer):",
            "        \"\"\"",
            "        Start producing to the given",
            "        L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.",
            "",
            "        @return: A L{Deferred<twisted.internet.defer.Deferred>} which stops",
            "            production of data when L{Deferred.cancel} is called, and which",
            "            fires with L{None} when all bytes have been produced or with a",
            "            L{Failure<twisted.python.failure.Failure>} if there is any problem",
            "            before all bytes have been produced.",
            "        \"\"\"",
            "",
            "    def stopProducing():",
            "        \"\"\"",
            "        In addition to the standard behavior of",
            "        L{IProducer.stopProducing<twisted.internet.interfaces.IProducer.stopProducing>}",
            "        (stop producing data), make sure the",
            "        L{Deferred<twisted.internet.defer.Deferred>} returned by",
            "        C{startProducing} is never fired.",
            "        \"\"\"",
            "",
            "",
            "class IRenderable(Interface):",
            "    \"\"\"",
            "    An L{IRenderable} is an object that may be rendered by the",
            "    L{twisted.web.template} templating system.",
            "    \"\"\"",
            "",
            "    def lookupRenderMethod(",
            "        name: str,",
            "    ) -> Callable[[Optional[IRequest], \"Tag\"], \"Flattenable\"]:",
            "        \"\"\"",
            "        Look up and return the render method associated with the given name.",
            "",
            "        @param name: The value of a render directive encountered in the",
            "            document returned by a call to L{IRenderable.render}.",
            "",
            "        @return: A two-argument callable which will be invoked with the request",
            "            being responded to and the tag object on which the render directive",
            "            was encountered.",
            "        \"\"\"",
            "",
            "    def render(request: Optional[IRequest]) -> \"Flattenable\":",
            "        \"\"\"",
            "        Get the document for this L{IRenderable}.",
            "",
            "        @param request: The request in response to which this method is being",
            "            invoked.",
            "",
            "        @return: An object which can be flattened.",
            "        \"\"\"",
            "",
            "",
            "class ITemplateLoader(Interface):",
            "    \"\"\"",
            "    A loader for templates; something usable as a value for",
            "    L{twisted.web.template.Element}'s C{loader} attribute.",
            "    \"\"\"",
            "",
            "    def load() -> List[\"Flattenable\"]:",
            "        \"\"\"",
            "        Load a template suitable for rendering.",
            "",
            "        @return: a L{list} of flattenable objects, such as byte and unicode",
            "            strings, L{twisted.web.template.Element}s and L{IRenderable} providers.",
            "        \"\"\"",
            "",
            "",
            "class IResponse(Interface):",
            "    \"\"\"",
            "    An object representing an HTTP response received from an HTTP server.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    version = Attribute(",
            "        \"A three-tuple describing the protocol and protocol version \"",
            "        \"of the response.  The first element is of type L{str}, the second \"",
            "        \"and third are of type L{int}.  For example, C{(b'HTTP', 1, 1)}.\"",
            "    )",
            "",
            "    code = Attribute(\"The HTTP status code of this response, as a L{int}.\")",
            "",
            "    phrase = Attribute(\"The HTTP reason phrase of this response, as a L{str}.\")",
            "",
            "    headers = Attribute(\"The HTTP response L{Headers} of this response.\")",
            "",
            "    length = Attribute(",
            "        \"The L{int} number of bytes expected to be in the body of this \"",
            "        \"response or L{UNKNOWN_LENGTH} if the server did not indicate how \"",
            "        \"many bytes to expect.  For I{HEAD} responses, this will be 0; if \"",
            "        \"the response includes a I{Content-Length} header, it will be \"",
            "        \"available in C{headers}.\"",
            "    )",
            "",
            "    request = Attribute(\"The L{IClientRequest} that resulted in this response.\")",
            "",
            "    previousResponse = Attribute(",
            "        \"The previous L{IResponse} from a redirect, or L{None} if there was no \"",
            "        \"previous response. This can be used to walk the response or request \"",
            "        \"history for redirections.\"",
            "    )",
            "",
            "    def deliverBody(protocol):",
            "        \"\"\"",
            "        Register an L{IProtocol<twisted.internet.interfaces.IProtocol>} provider",
            "        to receive the response body.",
            "",
            "        The protocol will be connected to a transport which provides",
            "        L{IPushProducer}.  The protocol's C{connectionLost} method will be",
            "        called with:",
            "",
            "            - ResponseDone, which indicates that all bytes from the response",
            "              have been successfully delivered.",
            "",
            "            - PotentialDataLoss, which indicates that it cannot be determined",
            "              if the entire response body has been delivered.  This only occurs",
            "              when making requests to HTTP servers which do not set",
            "              I{Content-Length} or a I{Transfer-Encoding} in the response.",
            "",
            "            - ResponseFailed, which indicates that some bytes from the response",
            "              were lost.  The C{reasons} attribute of the exception may provide",
            "              more specific indications as to why.",
            "        \"\"\"",
            "",
            "    def setPreviousResponse(response):",
            "        \"\"\"",
            "        Set the reference to the previous L{IResponse}.",
            "",
            "        The value of the previous response can be read via",
            "        L{IResponse.previousResponse}.",
            "        \"\"\"",
            "",
            "",
            "class _IRequestEncoder(Interface):",
            "    \"\"\"",
            "    An object encoding data passed to L{IRequest.write}, for example for",
            "    compression purpose.",
            "",
            "    @since: 12.3",
            "    \"\"\"",
            "",
            "    def encode(data):",
            "        \"\"\"",
            "        Encode the data given and return the result.",
            "",
            "        @param data: The content to encode.",
            "        @type data: L{str}",
            "",
            "        @return: The encoded data.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def finish():",
            "        \"\"\"",
            "        Callback called when the request is closing.",
            "",
            "        @return: If necessary, the pending data accumulated from previous",
            "            C{encode} calls.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "",
            "class _IRequestEncoderFactory(Interface):",
            "    \"\"\"",
            "    A factory for returing L{_IRequestEncoder} instances.",
            "",
            "    @since: 12.3",
            "    \"\"\"",
            "",
            "    def encoderForRequest(request):",
            "        \"\"\"",
            "        If applicable, returns a L{_IRequestEncoder} instance which will encode",
            "        the request.",
            "        \"\"\"",
            "",
            "",
            "class IClientRequest(Interface):",
            "    \"\"\"",
            "    An object representing an HTTP request to make to an HTTP server.",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "",
            "    method = Attribute(",
            "        \"The HTTP method for this request, as L{bytes}. For example: \"",
            "        \"C{b'GET'}, C{b'HEAD'}, C{b'POST'}, etc.\"",
            "    )",
            "",
            "    absoluteURI = Attribute(",
            "        \"The absolute URI of the requested resource, as L{bytes}; or L{None} \"",
            "        \"if the absolute URI cannot be determined.\"",
            "    )",
            "",
            "    headers = Attribute(",
            "        \"Headers to be sent to the server, as \"",
            "        \"a L{twisted.web.http_headers.Headers} instance.\"",
            "    )",
            "",
            "",
            "class IAgent(Interface):",
            "    \"\"\"",
            "    An agent makes HTTP requests.",
            "",
            "    The way in which requests are issued is left up to each implementation.",
            "    Some may issue them directly to the server indicated by the net location",
            "    portion of the request URL.  Others may use a proxy specified by system",
            "    configuration.",
            "",
            "    Processing of responses is also left very widely specified.  An",
            "    implementation may perform no special handling of responses, or it may",
            "    implement redirect following or content negotiation, it may implement a",
            "    cookie store or automatically respond to authentication challenges.  It may",
            "    implement many other unforeseen behaviors as well.",
            "",
            "    It is also intended that L{IAgent} implementations be composable.  An",
            "    implementation which provides cookie handling features should re-use an",
            "    implementation that provides connection pooling and this combination could",
            "    be used by an implementation which adds content negotiation functionality.",
            "    Some implementations will be completely self-contained, such as those which",
            "    actually perform the network operations to send and receive requests, but",
            "    most or all other implementations should implement a small number of new",
            "    features (perhaps one new feature) and delegate the rest of the",
            "    request/response machinery to another implementation.",
            "",
            "    This allows for great flexibility in the behavior an L{IAgent} will",
            "    provide.  For example, an L{IAgent} with web browser-like behavior could be",
            "    obtained by combining a number of (hypothetical) implementations::",
            "",
            "        baseAgent = Agent(reactor)",
            "        redirect = BrowserLikeRedirectAgent(baseAgent, limit=10)",
            "        authenticate = AuthenticateAgent(",
            "            redirect, [diskStore.credentials, GtkAuthInterface()])",
            "        cookie = CookieAgent(authenticate, diskStore.cookie)",
            "        decode = ContentDecoderAgent(cookie, [(b\"gzip\", GzipDecoder())])",
            "        cache = CacheAgent(decode, diskStore.cache)",
            "",
            "        doSomeRequests(cache)",
            "    \"\"\"",
            "",
            "    def request(",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> Deferred[IResponse]:",
            "        \"\"\"",
            "        Request the resource at the given location.",
            "",
            "        @param method: The request method to use, such as C{b\"GET\"}, C{b\"HEAD\"},",
            "            C{b\"PUT\"}, C{b\"POST\"}, etc.",
            "",
            "        @param uri: The location of the resource to request.  This should be an",
            "            absolute URI but some implementations may support relative URIs",
            "            (with absolute or relative paths).  I{HTTP} and I{HTTPS} are the",
            "            schemes most likely to be supported but others may be as well.",
            "",
            "        @param headers: The headers to send with the request (or L{None} to",
            "            send no extra headers).  An implementation may add its own headers",
            "            to this (for example for client identification or content",
            "            negotiation).",
            "",
            "        @param bodyProducer: An object which can generate bytes to make up the",
            "            body of this request (for example, the properly encoded contents of",
            "            a file for a file upload).  Or, L{None} if the request is to have",
            "            no body.",
            "",
            "        @return: A L{Deferred} that fires with an L{IResponse} provider when",
            "            the header of the response has been received (regardless of the",
            "            response status code) or with a L{Failure} if there is any problem",
            "            which prevents that response from being received (including",
            "            problems that prevent the request from being sent).",
            "        \"\"\"",
            "",
            "",
            "class IPolicyForHTTPS(Interface):",
            "    \"\"\"",
            "    An L{IPolicyForHTTPS} provides a policy for verifying the certificates of",
            "    HTTPS connections, in the form of a L{client connection creator",
            "    <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} per network",
            "    location.",
            "",
            "    @since: 14.0",
            "    \"\"\"",
            "",
            "    def creatorForNetloc(hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        appropriate for the given URL \"netloc\"; i.e. hostname and port number",
            "        pair.",
            "",
            "        @param hostname: The name of the requested remote host.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The number of the requested remote port.",
            "        @type port: L{int}",
            "",
            "        @return: A client connection creator expressing the security",
            "            requirements for the given remote host.",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "",
            "",
            "class IAgentEndpointFactory(Interface):",
            "    \"\"\"",
            "    An L{IAgentEndpointFactory} provides a way of constructing an endpoint",
            "    used for outgoing Agent requests. This is useful in the case of needing to",
            "    proxy outgoing connections, or to otherwise vary the transport used.",
            "",
            "    @since: 15.0",
            "    \"\"\"",
            "",
            "    def endpointForURI(uri):",
            "        \"\"\"",
            "        Construct and return an L{IStreamClientEndpoint} for the outgoing",
            "        request's connection.",
            "",
            "        @param uri: The URI of the request.",
            "        @type uri: L{twisted.web.client.URI}",
            "",
            "        @return: An endpoint which will have its C{connect} method called to",
            "            issue the request.",
            "        @rtype: an L{IStreamClientEndpoint} provider",
            "",
            "        @raises twisted.internet.error.SchemeNotSupported: If the given",
            "            URI's scheme cannot be handled by this factory.",
            "        \"\"\"",
            "",
            "",
            "UNKNOWN_LENGTH = \"twisted.web.iweb.UNKNOWN_LENGTH\"",
            "",
            "__all__ = [",
            "    \"IUsernameDigestHash\",",
            "    \"ICredentialFactory\",",
            "    \"IRequest\",",
            "    \"IBodyProducer\",",
            "    \"IRenderable\",",
            "    \"IResponse\",",
            "    \"_IRequestEncoder\",",
            "    \"_IRequestEncoderFactory\",",
            "    \"IClientRequest\",",
            "    \"UNKNOWN_LENGTH\",",
            "]"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: twisted.web.test -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Interface definitions for L{twisted.web}.",
            "",
            "@var UNKNOWN_LENGTH: An opaque object which may be used as the value of",
            "    L{IBodyProducer.length} to indicate that the length of the entity",
            "    body is not known in advance.",
            "\"\"\"",
            "from typing import TYPE_CHECKING, Callable, List, Optional",
            "",
            "from zope.interface import Attribute, Interface",
            "",
            "from twisted.cred.credentials import IUsernameDigestHash",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.interfaces import IPushProducer",
            "from twisted.web.http_headers import Headers",
            "",
            "if TYPE_CHECKING:",
            "    from twisted.web.template import Flattenable, Tag",
            "",
            "",
            "class IRequest(Interface):",
            "    \"\"\"",
            "    An HTTP request.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    method = Attribute(\"A L{bytes} giving the HTTP method that was used.\")",
            "    uri = Attribute(",
            "        \"A L{bytes} giving the full encoded URI which was requested (including\"",
            "        \" query arguments).\"",
            "    )",
            "    path = Attribute(",
            "        \"A L{bytes} giving the encoded query path of the request URI (not \"",
            "        \"including query arguments).\"",
            "    )",
            "    args = Attribute(",
            "        \"A mapping of decoded query argument names as L{bytes} to \"",
            "        \"corresponding query argument values as L{list}s of L{bytes}.  \"",
            "        \"For example, for a URI with C{foo=bar&foo=baz&quux=spam} \"",
            "        \"for its query part, C{args} will be C{{b'foo': [b'bar', b'baz'], \"",
            "        \"b'quux': [b'spam']}}.\"",
            "    )",
            "",
            "    prepath = Attribute(",
            "        \"The URL path segments which have been processed during resource \"",
            "        \"traversal, as a list of L{bytes}.\"",
            "    )",
            "",
            "    postpath = Attribute(",
            "        \"The URL path segments which have not (yet) been processed \"",
            "        \"during resource traversal, as a list of L{bytes}.\"",
            "    )",
            "",
            "    requestHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance giving all received HTTP request \"",
            "        \"headers.\"",
            "    )",
            "",
            "    content = Attribute(",
            "        \"A file-like object giving the request body.  This may be a file on \"",
            "        \"disk, an L{io.BytesIO}, or some other type.  The implementation is \"",
            "        \"free to decide on a per-request basis.\"",
            "    )",
            "",
            "    responseHeaders = Attribute(",
            "        \"A L{http_headers.Headers} instance holding all HTTP response \"",
            "        \"headers to be sent.\"",
            "    )",
            "",
            "    def getHeader(key):",
            "        \"\"\"",
            "        Get an HTTP request header.",
            "",
            "        @type key: L{bytes} or L{str}",
            "        @param key: The name of the header to get the value of.",
            "",
            "        @rtype: L{bytes} or L{str} or L{None}",
            "        @return: The value of the specified header, or L{None} if that header",
            "            was not present in the request. The string type of the result",
            "            matches the type of C{key}.",
            "        \"\"\"",
            "",
            "    def getCookie(key):",
            "        \"\"\"",
            "        Get a cookie that was sent from the network.",
            "",
            "        @type key: L{bytes}",
            "        @param key: The name of the cookie to get.",
            "",
            "        @rtype: L{bytes} or L{None}",
            "        @returns: The value of the specified cookie, or L{None} if that cookie",
            "            was not present in the request.",
            "        \"\"\"",
            "",
            "    def getAllHeaders():",
            "        \"\"\"",
            "        Return dictionary mapping the names of all received headers to the last",
            "        value received for each.",
            "",
            "        Since this method does not return all header information,",
            "        C{requestHeaders.getAllRawHeaders()} may be preferred.",
            "        \"\"\"",
            "",
            "    def getRequestHostname():",
            "        \"\"\"",
            "        Get the hostname that the HTTP client passed in to the request.",
            "",
            "        This will either use the C{Host:} header (if it is available; which,",
            "        for a spec-compliant request, it will be) or the IP address of the host",
            "        we are listening on if the header is unavailable.",
            "",
            "        @note: This is the I{host portion} of the requested resource, which",
            "            means that:",
            "",
            "                1. it might be an IPv4 or IPv6 address, not just a DNS host",
            "                   name,",
            "",
            "                2. there's no guarantee it's even a I{valid} host name or IP",
            "                   address, since the C{Host:} header may be malformed,",
            "",
            "                3. it does not include the port number.",
            "",
            "        @returns: the requested hostname",
            "",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    def getHost():",
            "        \"\"\"",
            "        Get my originally requesting transport's host.",
            "",
            "        @return: An L{IAddress<twisted.internet.interfaces.IAddress>}.",
            "        \"\"\"",
            "",
            "    def getClientAddress():",
            "        \"\"\"",
            "        Return the address of the client who submitted this request.",
            "",
            "        The address may not be a network address.  Callers must check",
            "        its type before using it.",
            "",
            "        @since: 18.4",
            "",
            "        @return: the client's address.",
            "        @rtype: an L{IAddress} provider.",
            "        \"\"\"",
            "",
            "    def getClientIP():",
            "        \"\"\"",
            "        Return the IP address of the client who submitted this request.",
            "",
            "        This method is B{deprecated}.  See L{getClientAddress} instead.",
            "",
            "        @returns: the client IP address or L{None} if the request was submitted",
            "            over a transport where IP addresses do not make sense.",
            "        @rtype: L{str} or L{None}",
            "        \"\"\"",
            "",
            "    def getUser():",
            "        \"\"\"",
            "        Return the HTTP user sent with this request, if any.",
            "",
            "        If no user was supplied, return the empty string.",
            "",
            "        @returns: the HTTP user, if any",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def getPassword():",
            "        \"\"\"",
            "        Return the HTTP password sent with this request, if any.",
            "",
            "        If no password was supplied, return the empty string.",
            "",
            "        @returns: the HTTP password, if any",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def isSecure():",
            "        \"\"\"",
            "        Return True if this request is using a secure transport.",
            "",
            "        Normally this method returns True if this request's HTTPChannel",
            "        instance is using a transport that implements ISSLTransport.",
            "",
            "        This will also return True if setHost() has been called",
            "        with ssl=True.",
            "",
            "        @returns: True if this request is secure",
            "        @rtype: C{bool}",
            "        \"\"\"",
            "",
            "    def getSession(sessionInterface=None):",
            "        \"\"\"",
            "        Look up the session associated with this request or create a new one if",
            "        there is not one.",
            "",
            "        @return: The L{Session} instance identified by the session cookie in",
            "            the request, or the C{sessionInterface} component of that session",
            "            if C{sessionInterface} is specified.",
            "        \"\"\"",
            "",
            "    def URLPath():",
            "        \"\"\"",
            "        @return: A L{URLPath<twisted.python.urlpath.URLPath>} instance",
            "            which identifies the URL for which this request is.",
            "        \"\"\"",
            "",
            "    def prePathURL():",
            "        \"\"\"",
            "        At any time during resource traversal or resource rendering,",
            "        returns an absolute URL to the most nested resource which has",
            "        yet been reached.",
            "",
            "        @see: {twisted.web.server.Request.prepath}",
            "",
            "        @return: An absolute URL.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    def rememberRootURL():",
            "        \"\"\"",
            "        Remember the currently-processed part of the URL for later",
            "        recalling.",
            "        \"\"\"",
            "",
            "    def getRootURL():",
            "        \"\"\"",
            "        Get a previously-remembered URL.",
            "",
            "        @return: An absolute URL.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "",
            "    # Methods for outgoing response",
            "    def finish():",
            "        \"\"\"",
            "        Indicate that the response to this request is complete.",
            "        \"\"\"",
            "",
            "    def write(data):",
            "        \"\"\"",
            "        Write some data to the body of the response to this request.  Response",
            "        headers are written the first time this method is called, after which",
            "        new response headers may not be added.",
            "",
            "        @param data: Bytes of the response body.",
            "        @type data: L{bytes}",
            "        \"\"\"",
            "",
            "    def addCookie(",
            "        k,",
            "        v,",
            "        expires=None,",
            "        domain=None,",
            "        path=None,",
            "        max_age=None,",
            "        comment=None,",
            "        secure=None,",
            "    ):",
            "        \"\"\"",
            "        Set an outgoing HTTP cookie.",
            "",
            "        In general, you should consider using sessions instead of cookies, see",
            "        L{twisted.web.server.Request.getSession} and the",
            "        L{twisted.web.server.Session} class for details.",
            "        \"\"\"",
            "",
            "    def setResponseCode(code, message=None):",
            "        \"\"\"",
            "        Set the HTTP response code.",
            "",
            "        @type code: L{int}",
            "        @type message: L{bytes}",
            "        \"\"\"",
            "",
            "    def setHeader(k, v):",
            "        \"\"\"",
            "        Set an HTTP response header.  Overrides any previously set values for",
            "        this header.",
            "",
            "        @type k: L{bytes} or L{str}",
            "        @param k: The name of the header for which to set the value.",
            "",
            "        @type v: L{bytes} or L{str}",
            "        @param v: The value to set for the named header. A L{str} will be",
            "            UTF-8 encoded, which may not interoperable with other",
            "            implementations. Avoid passing non-ASCII characters if possible.",
            "        \"\"\"",
            "",
            "    def redirect(url):",
            "        \"\"\"",
            "        Utility function that does a redirect.",
            "",
            "        The request should have finish() called after this.",
            "        \"\"\"",
            "",
            "    def setLastModified(when):",
            "        \"\"\"",
            "        Set the C{Last-Modified} time for the response to this request.",
            "",
            "        If I am called more than once, I ignore attempts to set Last-Modified",
            "        earlier, only replacing the Last-Modified time if it is to a later",
            "        value.",
            "",
            "        If I am a conditional request, I may modify my response code to",
            "        L{NOT_MODIFIED<http.NOT_MODIFIED>} if appropriate for the time given.",
            "",
            "        @param when: The last time the resource being returned was modified, in",
            "            seconds since the epoch.",
            "        @type when: L{int} or L{float}",
            "",
            "        @return: If I am a C{If-Modified-Since} conditional request and the time",
            "            given is not newer than the condition, I return",
            "            L{CACHED<http.CACHED>} to indicate that you should write no body.",
            "            Otherwise, I return a false value.",
            "        \"\"\"",
            "",
            "    def setETag(etag):",
            "        \"\"\"",
            "        Set an C{entity tag} for the outgoing response.",
            "",
            "        That's \"entity tag\" as in the HTTP/1.1 I{ETag} header, \"used for",
            "        comparing two or more entities from the same requested resource.\"",
            "",
            "        If I am a conditional request, I may modify my response code to",
            "        L{NOT_MODIFIED<http.NOT_MODIFIED>} or",
            "        L{PRECONDITION_FAILED<http.PRECONDITION_FAILED>}, if appropriate for the",
            "        tag given.",
            "",
            "        @param etag: The entity tag for the resource being returned.",
            "        @type etag: L{str}",
            "",
            "        @return: If I am a C{If-None-Match} conditional request and the tag",
            "            matches one in the request, I return L{CACHED<http.CACHED>} to",
            "            indicate that you should write no body.  Otherwise, I return a",
            "            false value.",
            "        \"\"\"",
            "",
            "    def setHost(host, port, ssl=0):",
            "        \"\"\"",
            "        Change the host and port the request thinks it's using.",
            "",
            "        This method is useful for working with reverse HTTP proxies (e.g.  both",
            "        Squid and Apache's mod_proxy can do this), when the address the HTTP",
            "        client is using is different than the one we're listening on.",
            "",
            "        For example, Apache may be listening on https://www.example.com, and",
            "        then forwarding requests to http://localhost:8080, but we don't want",
            "        HTML produced by Twisted to say 'http://localhost:8080', they should",
            "        say 'https://www.example.com', so we do::",
            "",
            "           request.setHost('www.example.com', 443, ssl=1)",
            "        \"\"\"",
            "",
            "",
            "class INonQueuedRequestFactory(Interface):",
            "    \"\"\"",
            "    A factory of L{IRequest} objects that does not take a ``queued`` parameter.",
            "    \"\"\"",
            "",
            "    def __call__(channel):",
            "        \"\"\"",
            "        Create an L{IRequest} that is operating on the given channel. There",
            "        must only be one L{IRequest} object processing at any given time on a",
            "        channel.",
            "",
            "        @param channel: A L{twisted.web.http.HTTPChannel} object.",
            "        @type channel: L{twisted.web.http.HTTPChannel}",
            "",
            "        @return: A request object.",
            "        @rtype: L{IRequest}",
            "        \"\"\"",
            "",
            "",
            "class IAccessLogFormatter(Interface):",
            "    \"\"\"",
            "    An object which can represent an HTTP request as a line of text for",
            "    inclusion in an access log file.",
            "    \"\"\"",
            "",
            "    def __call__(timestamp, request):",
            "        \"\"\"",
            "        Generate a line for the access log.",
            "",
            "        @param timestamp: The time at which the request was completed in the",
            "            standard format for access logs.",
            "        @type timestamp: L{unicode}",
            "",
            "        @param request: The request object about which to log.",
            "        @type request: L{twisted.web.server.Request}",
            "",
            "        @return: One line describing the request without a trailing newline.",
            "        @rtype: L{unicode}",
            "        \"\"\"",
            "",
            "",
            "class ICredentialFactory(Interface):",
            "    \"\"\"",
            "    A credential factory defines a way to generate a particular kind of",
            "    authentication challenge and a way to interpret the responses to these",
            "    challenges.  It creates",
            "    L{ICredentials<twisted.cred.credentials.ICredentials>} providers from",
            "    responses.  These objects will be used with L{twisted.cred} to authenticate",
            "    an authorize requests.",
            "    \"\"\"",
            "",
            "    scheme = Attribute(",
            "        \"A L{str} giving the name of the authentication scheme with which \"",
            "        \"this factory is associated.  For example, C{'basic'} or C{'digest'}.\"",
            "    )",
            "",
            "    def getChallenge(request):",
            "        \"\"\"",
            "        Generate a new challenge to be sent to a client.",
            "",
            "        @type request: L{twisted.web.http.Request}",
            "        @param request: The request the response to which this challenge will",
            "            be included.",
            "",
            "        @rtype: L{dict}",
            "        @return: A mapping from L{str} challenge fields to associated L{str}",
            "            values.",
            "        \"\"\"",
            "",
            "    def decode(response, request):",
            "        \"\"\"",
            "        Create a credentials object from the given response.",
            "",
            "        @type response: L{str}",
            "        @param response: scheme specific response string",
            "",
            "        @type request: L{twisted.web.http.Request}",
            "        @param request: The request being processed (from which the response",
            "            was taken).",
            "",
            "        @raise twisted.cred.error.LoginFailed: If the response is invalid.",
            "",
            "        @rtype: L{twisted.cred.credentials.ICredentials} provider",
            "        @return: The credentials represented by the given response.",
            "        \"\"\"",
            "",
            "",
            "class IBodyProducer(IPushProducer):",
            "    \"\"\"",
            "    Objects which provide L{IBodyProducer} write bytes to an object which",
            "    provides L{IConsumer<twisted.internet.interfaces.IConsumer>} by calling its",
            "    C{write} method repeatedly.",
            "",
            "    L{IBodyProducer} providers may start producing as soon as they have an",
            "    L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.  That is, they",
            "    should not wait for a C{resumeProducing} call to begin writing data.",
            "",
            "    L{IConsumer.unregisterProducer<twisted.internet.interfaces.IConsumer.unregisterProducer>}",
            "    must not be called.  Instead, the",
            "    L{Deferred<twisted.internet.defer.Deferred>} returned from C{startProducing}",
            "    must be fired when all bytes have been written.",
            "",
            "    L{IConsumer.write<twisted.internet.interfaces.IConsumer.write>} may",
            "    synchronously invoke any of C{pauseProducing}, C{resumeProducing}, or",
            "    C{stopProducing}.  These methods must be implemented with this in mind.",
            "",
            "    @since: 9.0",
            "    \"\"\"",
            "",
            "    # Despite the restrictions above and the additional requirements of",
            "    # stopProducing documented below, this interface still needs to be an",
            "    # IPushProducer subclass.  Providers of it will be passed to IConsumer",
            "    # providers which only know about IPushProducer and IPullProducer, not",
            "    # about this interface.  This interface needs to remain close enough to one",
            "    # of those interfaces for consumers to work with it.",
            "",
            "    length = Attribute(",
            "        \"\"\"",
            "        C{length} is a L{int} indicating how many bytes in total this",
            "        L{IBodyProducer} will write to the consumer or L{UNKNOWN_LENGTH}",
            "        if this is not known in advance.",
            "        \"\"\"",
            "    )",
            "",
            "    def startProducing(consumer):",
            "        \"\"\"",
            "        Start producing to the given",
            "        L{IConsumer<twisted.internet.interfaces.IConsumer>} provider.",
            "",
            "        @return: A L{Deferred<twisted.internet.defer.Deferred>} which stops",
            "            production of data when L{Deferred.cancel} is called, and which",
            "            fires with L{None} when all bytes have been produced or with a",
            "            L{Failure<twisted.python.failure.Failure>} if there is any problem",
            "            before all bytes have been produced.",
            "        \"\"\"",
            "",
            "    def stopProducing():",
            "        \"\"\"",
            "        In addition to the standard behavior of",
            "        L{IProducer.stopProducing<twisted.internet.interfaces.IProducer.stopProducing>}",
            "        (stop producing data), make sure the",
            "        L{Deferred<twisted.internet.defer.Deferred>} returned by",
            "        C{startProducing} is never fired.",
            "        \"\"\"",
            "",
            "",
            "class IRenderable(Interface):",
            "    \"\"\"",
            "    An L{IRenderable} is an object that may be rendered by the",
            "    L{twisted.web.template} templating system.",
            "    \"\"\"",
            "",
            "    def lookupRenderMethod(",
            "        name: str,",
            "    ) -> Callable[[Optional[IRequest], \"Tag\"], \"Flattenable\"]:",
            "        \"\"\"",
            "        Look up and return the render method associated with the given name.",
            "",
            "        @param name: The value of a render directive encountered in the",
            "            document returned by a call to L{IRenderable.render}.",
            "",
            "        @return: A two-argument callable which will be invoked with the request",
            "            being responded to and the tag object on which the render directive",
            "            was encountered.",
            "        \"\"\"",
            "",
            "    def render(request: Optional[IRequest]) -> \"Flattenable\":",
            "        \"\"\"",
            "        Get the document for this L{IRenderable}.",
            "",
            "        @param request: The request in response to which this method is being",
            "            invoked.",
            "",
            "        @return: An object which can be flattened.",
            "        \"\"\"",
            "",
            "",
            "class ITemplateLoader(Interface):",
            "    \"\"\"",
            "    A loader for templates; something usable as a value for",
            "    L{twisted.web.template.Element}'s C{loader} attribute.",
            "    \"\"\"",
            "",
            "    def load() -> List[\"Flattenable\"]:",
            "        \"\"\"",
            "        Load a template suitable for rendering.",
            "",
            "        @return: a L{list} of flattenable objects, such as byte and unicode",
            "            strings, L{twisted.web.template.Element}s and L{IRenderable} providers.",
            "        \"\"\"",
            "",
            "",
            "class IResponse(Interface):",
            "    \"\"\"",
            "    An object representing an HTTP response received from an HTTP server.",
            "",
            "    @since: 11.1",
            "    \"\"\"",
            "",
            "    version = Attribute(",
            "        \"A three-tuple describing the protocol and protocol version \"",
            "        \"of the response.  The first element is of type L{str}, the second \"",
            "        \"and third are of type L{int}.  For example, C{(b'HTTP', 1, 1)}.\"",
            "    )",
            "",
            "    code = Attribute(\"The HTTP status code of this response, as a L{int}.\")",
            "",
            "    phrase = Attribute(\"The HTTP reason phrase of this response, as a L{str}.\")",
            "",
            "    headers = Attribute(\"The HTTP response L{Headers} of this response.\")",
            "",
            "    length = Attribute(",
            "        \"The L{int} number of bytes expected to be in the body of this \"",
            "        \"response or L{UNKNOWN_LENGTH} if the server did not indicate how \"",
            "        \"many bytes to expect.  For I{HEAD} responses, this will be 0; if \"",
            "        \"the response includes a I{Content-Length} header, it will be \"",
            "        \"available in C{headers}.\"",
            "    )",
            "",
            "    request = Attribute(\"The L{IClientRequest} that resulted in this response.\")",
            "",
            "    previousResponse = Attribute(",
            "        \"The previous L{IResponse} from a redirect, or L{None} if there was no \"",
            "        \"previous response. This can be used to walk the response or request \"",
            "        \"history for redirections.\"",
            "    )",
            "",
            "    def deliverBody(protocol):",
            "        \"\"\"",
            "        Register an L{IProtocol<twisted.internet.interfaces.IProtocol>} provider",
            "        to receive the response body.",
            "",
            "        The protocol will be connected to a transport which provides",
            "        L{IPushProducer}.  The protocol's C{connectionLost} method will be",
            "        called with:",
            "",
            "            - ResponseDone, which indicates that all bytes from the response",
            "              have been successfully delivered.",
            "",
            "            - PotentialDataLoss, which indicates that it cannot be determined",
            "              if the entire response body has been delivered.  This only occurs",
            "              when making requests to HTTP servers which do not set",
            "              I{Content-Length} or a I{Transfer-Encoding} in the response.",
            "",
            "            - ResponseFailed, which indicates that some bytes from the response",
            "              were lost.  The C{reasons} attribute of the exception may provide",
            "              more specific indications as to why.",
            "        \"\"\"",
            "",
            "    def setPreviousResponse(response):",
            "        \"\"\"",
            "        Set the reference to the previous L{IResponse}.",
            "",
            "        The value of the previous response can be read via",
            "        L{IResponse.previousResponse}.",
            "        \"\"\"",
            "",
            "",
            "class _IRequestEncoder(Interface):",
            "    \"\"\"",
            "    An object encoding data passed to L{IRequest.write}, for example for",
            "    compression purpose.",
            "",
            "    @since: 12.3",
            "    \"\"\"",
            "",
            "    def encode(data):",
            "        \"\"\"",
            "        Encode the data given and return the result.",
            "",
            "        @param data: The content to encode.",
            "        @type data: L{str}",
            "",
            "        @return: The encoded data.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "    def finish():",
            "        \"\"\"",
            "        Callback called when the request is closing.",
            "",
            "        @return: If necessary, the pending data accumulated from previous",
            "            C{encode} calls.",
            "        @rtype: L{str}",
            "        \"\"\"",
            "",
            "",
            "class _IRequestEncoderFactory(Interface):",
            "    \"\"\"",
            "    A factory for returing L{_IRequestEncoder} instances.",
            "",
            "    @since: 12.3",
            "    \"\"\"",
            "",
            "    def encoderForRequest(request):",
            "        \"\"\"",
            "        If applicable, returns a L{_IRequestEncoder} instance which will encode",
            "        the request.",
            "        \"\"\"",
            "",
            "",
            "class IClientRequest(Interface):",
            "    \"\"\"",
            "    An object representing an HTTP request to make to an HTTP server.",
            "",
            "    @since: 13.1",
            "    \"\"\"",
            "",
            "    method = Attribute(",
            "        \"The HTTP method for this request, as L{bytes}. For example: \"",
            "        \"C{b'GET'}, C{b'HEAD'}, C{b'POST'}, etc.\"",
            "    )",
            "",
            "    absoluteURI = Attribute(",
            "        \"The absolute URI of the requested resource, as L{bytes}; or L{None} \"",
            "        \"if the absolute URI cannot be determined.\"",
            "    )",
            "",
            "    headers = Attribute(",
            "        \"Headers to be sent to the server, as \"",
            "        \"a L{twisted.web.http_headers.Headers} instance.\"",
            "    )",
            "",
            "",
            "class IAgent(Interface):",
            "    \"\"\"",
            "    An agent makes HTTP requests.",
            "",
            "    The way in which requests are issued is left up to each implementation.",
            "    Some may issue them directly to the server indicated by the net location",
            "    portion of the request URL.  Others may use a proxy specified by system",
            "    configuration.",
            "",
            "    Processing of responses is also left very widely specified.  An",
            "    implementation may perform no special handling of responses, or it may",
            "    implement redirect following or content negotiation, it may implement a",
            "    cookie store or automatically respond to authentication challenges.  It may",
            "    implement many other unforeseen behaviors as well.",
            "",
            "    It is also intended that L{IAgent} implementations be composable.  An",
            "    implementation which provides cookie handling features should re-use an",
            "    implementation that provides connection pooling and this combination could",
            "    be used by an implementation which adds content negotiation functionality.",
            "    Some implementations will be completely self-contained, such as those which",
            "    actually perform the network operations to send and receive requests, but",
            "    most or all other implementations should implement a small number of new",
            "    features (perhaps one new feature) and delegate the rest of the",
            "    request/response machinery to another implementation.",
            "",
            "    This allows for great flexibility in the behavior an L{IAgent} will",
            "    provide.  For example, an L{IAgent} with web browser-like behavior could be",
            "    obtained by combining a number of (hypothetical) implementations::",
            "",
            "        baseAgent = Agent(reactor)",
            "        decode = ContentDecoderAgent(baseAgent, [(b\"gzip\", GzipDecoder())])",
            "        cookie = CookieAgent(decode, diskStore.cookie)",
            "        authenticate = AuthenticateAgent(",
            "            cookie, [diskStore.credentials, GtkAuthInterface()])",
            "        cache = CacheAgent(authenticate, diskStore.cache)",
            "        redirect = BrowserLikeRedirectAgent(cache, limit=10)",
            "",
            "        doSomeRequests(cache)",
            "    \"\"\"",
            "",
            "    def request(",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> Deferred[IResponse]:",
            "        \"\"\"",
            "        Request the resource at the given location.",
            "",
            "        @param method: The request method to use, such as C{b\"GET\"}, C{b\"HEAD\"},",
            "            C{b\"PUT\"}, C{b\"POST\"}, etc.",
            "",
            "        @param uri: The location of the resource to request.  This should be an",
            "            absolute URI but some implementations may support relative URIs",
            "            (with absolute or relative paths).  I{HTTP} and I{HTTPS} are the",
            "            schemes most likely to be supported but others may be as well.",
            "",
            "        @param headers: The headers to send with the request (or L{None} to",
            "            send no extra headers).  An implementation may add its own headers",
            "            to this (for example for client identification or content",
            "            negotiation).",
            "",
            "        @param bodyProducer: An object which can generate bytes to make up the",
            "            body of this request (for example, the properly encoded contents of",
            "            a file for a file upload).  Or, L{None} if the request is to have",
            "            no body.",
            "",
            "        @return: A L{Deferred} that fires with an L{IResponse} provider when",
            "            the header of the response has been received (regardless of the",
            "            response status code) or with a L{Failure} if there is any problem",
            "            which prevents that response from being received (including",
            "            problems that prevent the request from being sent).",
            "        \"\"\"",
            "",
            "",
            "class IPolicyForHTTPS(Interface):",
            "    \"\"\"",
            "    An L{IPolicyForHTTPS} provides a policy for verifying the certificates of",
            "    HTTPS connections, in the form of a L{client connection creator",
            "    <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>} per network",
            "    location.",
            "",
            "    @since: 14.0",
            "    \"\"\"",
            "",
            "    def creatorForNetloc(hostname, port):",
            "        \"\"\"",
            "        Create a L{client connection creator",
            "        <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        appropriate for the given URL \"netloc\"; i.e. hostname and port number",
            "        pair.",
            "",
            "        @param hostname: The name of the requested remote host.",
            "        @type hostname: L{bytes}",
            "",
            "        @param port: The number of the requested remote port.",
            "        @type port: L{int}",
            "",
            "        @return: A client connection creator expressing the security",
            "            requirements for the given remote host.",
            "        @rtype: L{client connection creator",
            "            <twisted.internet.interfaces.IOpenSSLClientConnectionCreator>}",
            "        \"\"\"",
            "",
            "",
            "class IAgentEndpointFactory(Interface):",
            "    \"\"\"",
            "    An L{IAgentEndpointFactory} provides a way of constructing an endpoint",
            "    used for outgoing Agent requests. This is useful in the case of needing to",
            "    proxy outgoing connections, or to otherwise vary the transport used.",
            "",
            "    @since: 15.0",
            "    \"\"\"",
            "",
            "    def endpointForURI(uri):",
            "        \"\"\"",
            "        Construct and return an L{IStreamClientEndpoint} for the outgoing",
            "        request's connection.",
            "",
            "        @param uri: The URI of the request.",
            "        @type uri: L{twisted.web.client.URI}",
            "",
            "        @return: An endpoint which will have its C{connect} method called to",
            "            issue the request.",
            "        @rtype: an L{IStreamClientEndpoint} provider",
            "",
            "        @raises twisted.internet.error.SchemeNotSupported: If the given",
            "            URI's scheme cannot be handled by this factory.",
            "        \"\"\"",
            "",
            "",
            "UNKNOWN_LENGTH = \"twisted.web.iweb.UNKNOWN_LENGTH\"",
            "",
            "__all__ = [",
            "    \"IUsernameDigestHash\",",
            "    \"ICredentialFactory\",",
            "    \"IRequest\",",
            "    \"IBodyProducer\",",
            "    \"IRenderable\",",
            "    \"IResponse\",",
            "    \"_IRequestEncoder\",",
            "    \"_IRequestEncoderFactory\",",
            "    \"IClientRequest\",",
            "    \"UNKNOWN_LENGTH\",",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "716": [
                "IAgent"
            ],
            "718": [
                "IAgent"
            ],
            "719": [
                "IAgent"
            ],
            "720": [
                "IAgent"
            ],
            "721": [
                "IAgent"
            ]
        },
        "addLocation": []
    },
    "src/twisted/web/test/test_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import zlib"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from http.cookiejar import CookieJar"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from io import BytesIO"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from unittest import skipIf"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from typing import TYPE_CHECKING, List, Optional, Tuple"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from unittest import SkipTest, skipIf"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from zope.interface.declarations import implementer"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from zope.interface.verify import verifyObject"
            },
            "9": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     URIInjectionTestsMixin,"
            },
            "10": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " )"
            },
            "11": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+# Creatively lie to mypy about the nature of inheritance, since dealing with"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+# expectations of a mixin class is basically impossible (don't use mixins)."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+if TYPE_CHECKING:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    testMixinClass = TestCase"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    runtimeTestCase = object"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+else:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    testMixinClass = object"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+    runtimeTestCase = TestCase"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " try:"
            },
            "22": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     from twisted.internet import ssl as _ssl"
            },
            "23": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " except ImportError:"
            },
            "24": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         request method is appended to this list."
            },
            "25": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     \"\"\""
            },
            "26": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self):"
            },
            "28": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.requests = []"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    def __init__(self) -> None:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        self.requests: List[Tuple[Request, Deferred[IResponse]]] = []"
            },
            "31": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         self.state = \"QUIESCENT\""
            },
            "32": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     def request(self, request):"
            },
            "34": {
                "beforePatchRowNumber": 2587,
                "afterPatchRowNumber": 2597,
                "PatchRowcode": "         self.assertEqual(agent._pool.connected, True)"
            },
            "35": {
                "beforePatchRowNumber": 2588,
                "afterPatchRowNumber": 2598,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 2589,
                "afterPatchRowNumber": 2599,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 2590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class _RedirectAgentTestsMixin:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2600,
                "PatchRowcode": "+SENSITIVE_HEADERS = ["
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2601,
                "PatchRowcode": "+    b\"authorization\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2602,
                "PatchRowcode": "+    b\"cookie\","
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2603,
                "PatchRowcode": "+    b\"cookie2\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2604,
                "PatchRowcode": "+    b\"proxy-authorization\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2605,
                "PatchRowcode": "+    b\"www-authenticate\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2606,
                "PatchRowcode": "+]"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2607,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2608,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2609,
                "PatchRowcode": "+class _RedirectAgentTestsMixin(testMixinClass):"
            },
            "48": {
                "beforePatchRowNumber": 2591,
                "afterPatchRowNumber": 2610,
                "PatchRowcode": "     \"\"\""
            },
            "49": {
                "beforePatchRowNumber": 2592,
                "afterPatchRowNumber": 2611,
                "PatchRowcode": "     Test cases mixin for L{RedirectAgentTests} and"
            },
            "50": {
                "beforePatchRowNumber": 2593,
                "afterPatchRowNumber": 2612,
                "PatchRowcode": "     L{BrowserLikeRedirectAgentTests}."
            },
            "51": {
                "beforePatchRowNumber": 2594,
                "afterPatchRowNumber": 2613,
                "PatchRowcode": "     \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 2595,
                "afterPatchRowNumber": 2614,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2615,
                "PatchRowcode": "+    agent: IAgent"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2616,
                "PatchRowcode": "+    reactor: MemoryReactorClock"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2617,
                "PatchRowcode": "+    protocol: StubHTTPProtocol"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2618,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": 2596,
                "afterPatchRowNumber": 2619,
                "PatchRowcode": "     def test_noRedirect(self):"
            },
            "58": {
                "beforePatchRowNumber": 2597,
                "afterPatchRowNumber": 2620,
                "PatchRowcode": "         \"\"\""
            },
            "59": {
                "beforePatchRowNumber": 2598,
                "afterPatchRowNumber": 2621,
                "PatchRowcode": "         L{client.RedirectAgent} behaves like L{client.Agent} if the response"
            },
            "60": {
                "beforePatchRowNumber": 2611,
                "afterPatchRowNumber": 2634,
                "PatchRowcode": "         self.assertIdentical(response, result)"
            },
            "61": {
                "beforePatchRowNumber": 2612,
                "afterPatchRowNumber": 2635,
                "PatchRowcode": "         self.assertIdentical(result.previousResponse, None)"
            },
            "62": {
                "beforePatchRowNumber": 2613,
                "afterPatchRowNumber": 2636,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 2614,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _testRedirectDefault(self, code):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2637,
                "PatchRowcode": "+    def _testRedirectDefault("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2638,
                "PatchRowcode": "+        self,"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2639,
                "PatchRowcode": "+        code: int,"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2640,
                "PatchRowcode": "+        crossScheme: bool = False,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2641,
                "PatchRowcode": "+        crossDomain: bool = False,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2642,
                "PatchRowcode": "+        crossPort: bool = False,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2643,
                "PatchRowcode": "+        requestHeaders: Optional[Headers] = None,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2644,
                "PatchRowcode": "+    ) -> Request:"
            },
            "72": {
                "beforePatchRowNumber": 2615,
                "afterPatchRowNumber": 2645,
                "PatchRowcode": "         \"\"\""
            },
            "73": {
                "beforePatchRowNumber": 2616,
                "afterPatchRowNumber": 2646,
                "PatchRowcode": "         When getting a redirect, L{client.RedirectAgent} follows the URL"
            },
            "74": {
                "beforePatchRowNumber": 2617,
                "afterPatchRowNumber": 2647,
                "PatchRowcode": "         specified in the L{Location} header field and make a new request."
            },
            "75": {
                "beforePatchRowNumber": 2618,
                "afterPatchRowNumber": 2648,
                "PatchRowcode": " "
            },
            "76": {
                "beforePatchRowNumber": 2619,
                "afterPatchRowNumber": 2649,
                "PatchRowcode": "         @param code: HTTP status code."
            },
            "77": {
                "beforePatchRowNumber": 2620,
                "afterPatchRowNumber": 2650,
                "PatchRowcode": "         \"\"\""
            },
            "78": {
                "beforePatchRowNumber": 2621,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.agent.request(b\"GET\", b\"http://example.com/foo\")"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2651,
                "PatchRowcode": "+        startDomain = b\"example.com\""
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2652,
                "PatchRowcode": "+        startScheme = b\"https\" if ssl is not None else b\"http\""
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2653,
                "PatchRowcode": "+        startPort = 80 if startScheme == b\"http\" else 443"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2654,
                "PatchRowcode": "+        self.agent.request("
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2655,
                "PatchRowcode": "+            b\"GET\", startScheme + b\"://\" + startDomain + b\"/foo\", headers=requestHeaders"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2656,
                "PatchRowcode": "+        )"
            },
            "85": {
                "beforePatchRowNumber": 2622,
                "afterPatchRowNumber": 2657,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 2623,
                "afterPatchRowNumber": 2658,
                "PatchRowcode": "         host, port = self.reactor.tcpClients.pop()[:2]"
            },
            "87": {
                "beforePatchRowNumber": 2624,
                "afterPatchRowNumber": 2659,
                "PatchRowcode": "         self.assertEqual(EXAMPLE_COM_IP, host)"
            },
            "88": {
                "beforePatchRowNumber": 2625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(80, port)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2660,
                "PatchRowcode": "+        self.assertEqual(startPort, port)"
            },
            "90": {
                "beforePatchRowNumber": 2626,
                "afterPatchRowNumber": 2661,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 2627,
                "afterPatchRowNumber": 2662,
                "PatchRowcode": "         req, res = self.protocol.requests.pop()"
            },
            "92": {
                "beforePatchRowNumber": 2628,
                "afterPatchRowNumber": 2663,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 2629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If possible (i.e.: SSL support is present), run the test with a"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2664,
                "PatchRowcode": "+        # If possible (i.e.: TLS support is present), run the test with a"
            },
            "95": {
                "beforePatchRowNumber": 2630,
                "afterPatchRowNumber": 2665,
                "PatchRowcode": "         # cross-scheme redirect to verify that the scheme is honored; if not,"
            },
            "96": {
                "beforePatchRowNumber": 2631,
                "afterPatchRowNumber": 2666,
                "PatchRowcode": "         # let's just make sure it works at all."
            },
            "97": {
                "beforePatchRowNumber": 2632,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if ssl is None:"
            },
            "98": {
                "beforePatchRowNumber": 2633,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            scheme = b\"http\""
            },
            "99": {
                "beforePatchRowNumber": 2634,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            expectedPort = 80"
            },
            "100": {
                "beforePatchRowNumber": 2635,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "101": {
                "beforePatchRowNumber": 2636,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            scheme = b\"https\""
            },
            "102": {
                "beforePatchRowNumber": 2637,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            expectedPort = 443"
            },
            "103": {
                "beforePatchRowNumber": 2638,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "104": {
                "beforePatchRowNumber": 2639,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        headers = http_headers.Headers({b\"location\": [scheme + b\"://example.com/bar\"]})"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2667,
                "PatchRowcode": "+"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2668,
                "PatchRowcode": "+        targetScheme = startScheme"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2669,
                "PatchRowcode": "+        targetDomain = startDomain"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2670,
                "PatchRowcode": "+        targetPort = startPort"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2671,
                "PatchRowcode": "+"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2672,
                "PatchRowcode": "+        if crossScheme:"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2673,
                "PatchRowcode": "+            if ssl is None:"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2674,
                "PatchRowcode": "+                raise SkipTest("
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2675,
                "PatchRowcode": "+                    \"Cross-scheme redirects can't be tested without TLS support.\""
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2676,
                "PatchRowcode": "+                )"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2677,
                "PatchRowcode": "+            targetScheme = b\"https\" if startScheme == b\"http\" else b\"http\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2678,
                "PatchRowcode": "+            targetPort = 443 if startPort == 80 else 80"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2679,
                "PatchRowcode": "+"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2680,
                "PatchRowcode": "+        portSyntax = b\"\""
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2681,
                "PatchRowcode": "+        if crossPort:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2682,
                "PatchRowcode": "+            targetPort = 8443"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2683,
                "PatchRowcode": "+            portSyntax = b\":8443\""
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2684,
                "PatchRowcode": "+        targetDomain = b\"example.net\" if crossDomain else startDomain"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2685,
                "PatchRowcode": "+        locationValue = targetScheme + b\"://\" + targetDomain + portSyntax + b\"/bar\""
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2686,
                "PatchRowcode": "+        headers = http_headers.Headers({b\"location\": [locationValue]})"
            },
            "125": {
                "beforePatchRowNumber": 2640,
                "afterPatchRowNumber": 2687,
                "PatchRowcode": "         response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)"
            },
            "126": {
                "beforePatchRowNumber": 2641,
                "afterPatchRowNumber": 2688,
                "PatchRowcode": "         res.callback(response)"
            },
            "127": {
                "beforePatchRowNumber": 2642,
                "afterPatchRowNumber": 2689,
                "PatchRowcode": " "
            },
            "128": {
                "beforePatchRowNumber": 2645,
                "afterPatchRowNumber": 2692,
                "PatchRowcode": "         self.assertEqual(b\"/bar\", req2.uri)"
            },
            "129": {
                "beforePatchRowNumber": 2646,
                "afterPatchRowNumber": 2693,
                "PatchRowcode": " "
            },
            "130": {
                "beforePatchRowNumber": 2647,
                "afterPatchRowNumber": 2694,
                "PatchRowcode": "         host, port = self.reactor.tcpClients.pop()[:2]"
            },
            "131": {
                "beforePatchRowNumber": 2648,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(EXAMPLE_COM_IP, host)"
            },
            "132": {
                "beforePatchRowNumber": 2649,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(expectedPort, port)"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2695,
                "PatchRowcode": "+        self.assertEqual(EXAMPLE_NET_IP if crossDomain else EXAMPLE_COM_IP, host)"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2696,
                "PatchRowcode": "+        self.assertEqual(targetPort, port)"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2697,
                "PatchRowcode": "+        return req2"
            },
            "136": {
                "beforePatchRowNumber": 2650,
                "afterPatchRowNumber": 2698,
                "PatchRowcode": " "
            },
            "137": {
                "beforePatchRowNumber": 2651,
                "afterPatchRowNumber": 2699,
                "PatchRowcode": "     def test_redirect301(self):"
            },
            "138": {
                "beforePatchRowNumber": 2652,
                "afterPatchRowNumber": 2700,
                "PatchRowcode": "         \"\"\""
            },
            "139": {
                "beforePatchRowNumber": 2653,
                "afterPatchRowNumber": 2701,
                "PatchRowcode": "         L{client.RedirectAgent} follows redirects on status code 301."
            },
            "140": {
                "beforePatchRowNumber": 2654,
                "afterPatchRowNumber": 2702,
                "PatchRowcode": "         \"\"\""
            },
            "141": {
                "beforePatchRowNumber": 2655,
                "afterPatchRowNumber": 2703,
                "PatchRowcode": "         self._testRedirectDefault(301)"
            },
            "142": {
                "beforePatchRowNumber": 2656,
                "afterPatchRowNumber": 2704,
                "PatchRowcode": " "
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2705,
                "PatchRowcode": "+    def test_redirect301Scheme(self):"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2706,
                "PatchRowcode": "+        \"\"\""
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2707,
                "PatchRowcode": "+        L{client.RedirectAgent} follows cross-scheme redirects."
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2708,
                "PatchRowcode": "+        \"\"\""
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2709,
                "PatchRowcode": "+        self._testRedirectDefault("
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2710,
                "PatchRowcode": "+            301,"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2711,
                "PatchRowcode": "+            crossScheme=True,"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2712,
                "PatchRowcode": "+        )"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2713,
                "PatchRowcode": "+"
            },
            "152": {
                "beforePatchRowNumber": 2657,
                "afterPatchRowNumber": 2714,
                "PatchRowcode": "     def test_redirect302(self):"
            },
            "153": {
                "beforePatchRowNumber": 2658,
                "afterPatchRowNumber": 2715,
                "PatchRowcode": "         \"\"\""
            },
            "154": {
                "beforePatchRowNumber": 2659,
                "afterPatchRowNumber": 2716,
                "PatchRowcode": "         L{client.RedirectAgent} follows redirects on status code 302."
            },
            "155": {
                "beforePatchRowNumber": 2672,
                "afterPatchRowNumber": 2729,
                "PatchRowcode": "         \"\"\""
            },
            "156": {
                "beforePatchRowNumber": 2673,
                "afterPatchRowNumber": 2730,
                "PatchRowcode": "         self._testRedirectDefault(308)"
            },
            "157": {
                "beforePatchRowNumber": 2674,
                "afterPatchRowNumber": 2731,
                "PatchRowcode": " "
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2732,
                "PatchRowcode": "+    def _sensitiveHeadersTest("
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2733,
                "PatchRowcode": "+        self, expectedHostHeader: bytes = b\"example.com\", **crossKwargs: bool"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2734,
                "PatchRowcode": "+    ) -> None:"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2735,
                "PatchRowcode": "+        \"\"\""
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2736,
                "PatchRowcode": "+        L{client.RedirectAgent} scrubs sensitive headers when redirecting"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2737,
                "PatchRowcode": "+        between differing origins."
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2738,
                "PatchRowcode": "+        \"\"\""
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2739,
                "PatchRowcode": "+        sensitiveHeaderValues = {"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2740,
                "PatchRowcode": "+            b\"authorization\": [b\"sensitive-authnz\"],"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2741,
                "PatchRowcode": "+            b\"cookie\": [b\"sensitive-cookie-data\"],"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2742,
                "PatchRowcode": "+            b\"cookie2\": [b\"sensitive-cookie2-data\"],"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2743,
                "PatchRowcode": "+            b\"proxy-authorization\": [b\"sensitive-proxy-auth\"],"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2744,
                "PatchRowcode": "+            b\"wWw-auThentiCate\": [b\"sensitive-authn\"],"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2745,
                "PatchRowcode": "+            b\"x-custom-sensitive\": [b\"sensitive-custom\"],"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2746,
                "PatchRowcode": "+        }"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2747,
                "PatchRowcode": "+        otherHeaderValues = {b\"x-random-header\": [b\"x-random-value\"]}"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2748,
                "PatchRowcode": "+        allHeaders = Headers({**sensitiveHeaderValues, **otherHeaderValues})"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2749,
                "PatchRowcode": "+        redirected = self._testRedirectDefault(301, requestHeaders=allHeaders)"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2750,
                "PatchRowcode": "+"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2751,
                "PatchRowcode": "+        def normHeaders(headers: Headers) -> dict:"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2752,
                "PatchRowcode": "+            return {k.lower(): v for (k, v) in headers.getAllRawHeaders()}"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2753,
                "PatchRowcode": "+"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2754,
                "PatchRowcode": "+        sameOriginHeaders = normHeaders(redirected.headers)"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2755,
                "PatchRowcode": "+        self.assertEquals("
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2756,
                "PatchRowcode": "+            sameOriginHeaders,"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2757,
                "PatchRowcode": "+            {"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2758,
                "PatchRowcode": "+                b\"host\": [b\"example.com\"],"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2759,
                "PatchRowcode": "+                **normHeaders(allHeaders),"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2760,
                "PatchRowcode": "+            },"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2761,
                "PatchRowcode": "+        )"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2762,
                "PatchRowcode": "+"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2763,
                "PatchRowcode": "+        redirectedElsewhere = self._testRedirectDefault("
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2764,
                "PatchRowcode": "+            301,"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2765,
                "PatchRowcode": "+            **crossKwargs,"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2766,
                "PatchRowcode": "+            requestHeaders=Headers({**sensitiveHeaderValues, **otherHeaderValues}),"
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2767,
                "PatchRowcode": "+        )"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2768,
                "PatchRowcode": "+        otherOriginHeaders = normHeaders(redirectedElsewhere.headers)"
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2769,
                "PatchRowcode": "+        self.assertEquals("
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2770,
                "PatchRowcode": "+            otherOriginHeaders,"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2771,
                "PatchRowcode": "+            {"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2772,
                "PatchRowcode": "+                b\"host\": [expectedHostHeader],"
            },
            "199": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2773,
                "PatchRowcode": "+                **normHeaders(Headers(otherHeaderValues)),"
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2774,
                "PatchRowcode": "+            },"
            },
            "201": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2775,
                "PatchRowcode": "+        )"
            },
            "202": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2776,
                "PatchRowcode": "+"
            },
            "203": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2777,
                "PatchRowcode": "+    def test_crossDomainHeaders(self) -> None:"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2778,
                "PatchRowcode": "+        \"\"\""
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2779,
                "PatchRowcode": "+        L{client.RedirectAgent} scrubs sensitive headers when redirecting"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2780,
                "PatchRowcode": "+        between differing domains."
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2781,
                "PatchRowcode": "+        \"\"\""
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2782,
                "PatchRowcode": "+        self._sensitiveHeadersTest(crossDomain=True, expectedHostHeader=b\"example.net\")"
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2783,
                "PatchRowcode": "+"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2784,
                "PatchRowcode": "+    def test_crossPortHeaders(self) -> None:"
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2785,
                "PatchRowcode": "+        \"\"\""
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2786,
                "PatchRowcode": "+        L{client.RedirectAgent} scrubs sensitive headers when redirecting"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2787,
                "PatchRowcode": "+        between differing ports."
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2788,
                "PatchRowcode": "+        \"\"\""
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2789,
                "PatchRowcode": "+        self._sensitiveHeadersTest("
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2790,
                "PatchRowcode": "+            crossPort=True, expectedHostHeader=b\"example.com:8443\""
            },
            "217": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2791,
                "PatchRowcode": "+        )"
            },
            "218": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2792,
                "PatchRowcode": "+"
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2793,
                "PatchRowcode": "+    def test_crossSchemeHeaders(self) -> None:"
            },
            "220": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2794,
                "PatchRowcode": "+        \"\"\""
            },
            "221": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2795,
                "PatchRowcode": "+        L{client.RedirectAgent} scrubs sensitive headers when redirecting"
            },
            "222": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2796,
                "PatchRowcode": "+        between differing schemes."
            },
            "223": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2797,
                "PatchRowcode": "+        \"\"\""
            },
            "224": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2798,
                "PatchRowcode": "+        self._sensitiveHeadersTest(crossScheme=True)"
            },
            "225": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2799,
                "PatchRowcode": "+"
            },
            "226": {
                "beforePatchRowNumber": 2675,
                "afterPatchRowNumber": 2800,
                "PatchRowcode": "     def _testRedirectToGet(self, code, method):"
            },
            "227": {
                "beforePatchRowNumber": 2676,
                "afterPatchRowNumber": 2801,
                "PatchRowcode": "         \"\"\""
            },
            "228": {
                "beforePatchRowNumber": 2677,
                "afterPatchRowNumber": 2802,
                "PatchRowcode": "         L{client.RedirectAgent} changes the method to I{GET} when getting"
            },
            "229": {
                "beforePatchRowNumber": 2878,
                "afterPatchRowNumber": 3003,
                "PatchRowcode": " "
            },
            "230": {
                "beforePatchRowNumber": 2879,
                "afterPatchRowNumber": 3004,
                "PatchRowcode": " "
            },
            "231": {
                "beforePatchRowNumber": 2880,
                "afterPatchRowNumber": 3005,
                "PatchRowcode": " class RedirectAgentTests("
            },
            "232": {
                "beforePatchRowNumber": 2881,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TestCase, FakeReactorAndConnectMixin, _RedirectAgentTestsMixin, AgentTestsMixin"
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3006,
                "PatchRowcode": "+    FakeReactorAndConnectMixin,"
            },
            "234": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3007,
                "PatchRowcode": "+    _RedirectAgentTestsMixin,"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3008,
                "PatchRowcode": "+    AgentTestsMixin,"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3009,
                "PatchRowcode": "+    runtimeTestCase,"
            },
            "237": {
                "beforePatchRowNumber": 2882,
                "afterPatchRowNumber": 3010,
                "PatchRowcode": " ):"
            },
            "238": {
                "beforePatchRowNumber": 2883,
                "afterPatchRowNumber": 3011,
                "PatchRowcode": "     \"\"\""
            },
            "239": {
                "beforePatchRowNumber": 2884,
                "afterPatchRowNumber": 3012,
                "PatchRowcode": "     Tests for L{client.RedirectAgent}."
            },
            "240": {
                "beforePatchRowNumber": 2888,
                "afterPatchRowNumber": 3016,
                "PatchRowcode": "         \"\"\""
            },
            "241": {
                "beforePatchRowNumber": 2889,
                "afterPatchRowNumber": 3017,
                "PatchRowcode": "         @return: a new L{twisted.web.client.RedirectAgent}"
            },
            "242": {
                "beforePatchRowNumber": 2890,
                "afterPatchRowNumber": 3018,
                "PatchRowcode": "         \"\"\""
            },
            "243": {
                "beforePatchRowNumber": 2891,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return client.RedirectAgent(self.buildAgentForWrapperTest(self.reactor))"
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3019,
                "PatchRowcode": "+        return client.RedirectAgent("
            },
            "245": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3020,
                "PatchRowcode": "+            self.buildAgentForWrapperTest(self.reactor),"
            },
            "246": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3021,
                "PatchRowcode": "+            sensitiveHeaderNames=[b\"X-Custom-sensitive\"],"
            },
            "247": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3022,
                "PatchRowcode": "+        )"
            },
            "248": {
                "beforePatchRowNumber": 2892,
                "afterPatchRowNumber": 3023,
                "PatchRowcode": " "
            },
            "249": {
                "beforePatchRowNumber": 2893,
                "afterPatchRowNumber": 3024,
                "PatchRowcode": "     def setUp(self):"
            },
            "250": {
                "beforePatchRowNumber": 2894,
                "afterPatchRowNumber": 3025,
                "PatchRowcode": "         self.reactor = self.createReactor()"
            },
            "251": {
                "beforePatchRowNumber": 2912,
                "afterPatchRowNumber": 3043,
                "PatchRowcode": " "
            },
            "252": {
                "beforePatchRowNumber": 2913,
                "afterPatchRowNumber": 3044,
                "PatchRowcode": " "
            },
            "253": {
                "beforePatchRowNumber": 2914,
                "afterPatchRowNumber": 3045,
                "PatchRowcode": " class BrowserLikeRedirectAgentTests("
            },
            "254": {
                "beforePatchRowNumber": 2915,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TestCase, FakeReactorAndConnectMixin, _RedirectAgentTestsMixin, AgentTestsMixin"
            },
            "255": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3046,
                "PatchRowcode": "+    FakeReactorAndConnectMixin,"
            },
            "256": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3047,
                "PatchRowcode": "+    _RedirectAgentTestsMixin,"
            },
            "257": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3048,
                "PatchRowcode": "+    AgentTestsMixin,"
            },
            "258": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3049,
                "PatchRowcode": "+    runtimeTestCase,"
            },
            "259": {
                "beforePatchRowNumber": 2916,
                "afterPatchRowNumber": 3050,
                "PatchRowcode": " ):"
            },
            "260": {
                "beforePatchRowNumber": 2917,
                "afterPatchRowNumber": 3051,
                "PatchRowcode": "     \"\"\""
            },
            "261": {
                "beforePatchRowNumber": 2918,
                "afterPatchRowNumber": 3052,
                "PatchRowcode": "     Tests for L{client.BrowserLikeRedirectAgent}."
            },
            "262": {
                "beforePatchRowNumber": 2923,
                "afterPatchRowNumber": 3057,
                "PatchRowcode": "         @return: a new L{twisted.web.client.BrowserLikeRedirectAgent}"
            },
            "263": {
                "beforePatchRowNumber": 2924,
                "afterPatchRowNumber": 3058,
                "PatchRowcode": "         \"\"\""
            },
            "264": {
                "beforePatchRowNumber": 2925,
                "afterPatchRowNumber": 3059,
                "PatchRowcode": "         return client.BrowserLikeRedirectAgent("
            },
            "265": {
                "beforePatchRowNumber": 2926,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.buildAgentForWrapperTest(self.reactor)"
            },
            "266": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3060,
                "PatchRowcode": "+            self.buildAgentForWrapperTest(self.reactor),"
            },
            "267": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3061,
                "PatchRowcode": "+            sensitiveHeaderNames=[b\"x-Custom-sensitive\"],"
            },
            "268": {
                "beforePatchRowNumber": 2927,
                "afterPatchRowNumber": 3062,
                "PatchRowcode": "         )"
            },
            "269": {
                "beforePatchRowNumber": 2928,
                "afterPatchRowNumber": 3063,
                "PatchRowcode": " "
            },
            "270": {
                "beforePatchRowNumber": 2929,
                "afterPatchRowNumber": 3064,
                "PatchRowcode": "     def setUp(self):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for L{twisted.web.client.Agent} and related new client APIs.",
            "\"\"\"",
            "",
            "import zlib",
            "from http.cookiejar import CookieJar",
            "from io import BytesIO",
            "from unittest import skipIf",
            "",
            "from zope.interface.declarations import implementer",
            "from zope.interface.verify import verifyObject",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import defer, task",
            "from twisted.internet.address import IPv4Address, IPv6Address",
            "from twisted.internet.defer import CancelledError, Deferred, succeed",
            "from twisted.internet.endpoints import HostnameEndpoint, TCP4ClientEndpoint",
            "from twisted.internet.error import (",
            "    ConnectionDone,",
            "    ConnectionLost,",
            "    ConnectionRefusedError,",
            ")",
            "from twisted.internet.interfaces import IOpenSSLClientConnectionCreator",
            "from twisted.internet.protocol import Factory, Protocol",
            "from twisted.internet.task import Clock",
            "from twisted.internet.test.test_endpoints import deterministicResolvingReactor",
            "from twisted.logger import globalLogPublisher",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.python.failure import Failure",
            "from twisted.test.iosim import FakeTransport, IOPump",
            "from twisted.test.proto_helpers import (",
            "    AccumulatingProtocol,",
            "    EventLoggingObserver,",
            "    MemoryReactorClock,",
            "    StringTransport,",
            ")",
            "from twisted.test.test_sslverify import certificatesForAuthorityAndServer",
            "from twisted.trial.unittest import SynchronousTestCase, TestCase",
            "from twisted.web import client, error, http_headers",
            "from twisted.web._newclient import (",
            "    HTTP11ClientProtocol,",
            "    PotentialDataLoss,",
            "    RequestNotSent,",
            "    RequestTransmissionFailed,",
            "    Response,",
            "    ResponseFailed,",
            "    ResponseNeverReceived,",
            ")",
            "from twisted.web.client import (",
            "    URI,",
            "    BrowserLikePolicyForHTTPS,",
            "    FileBodyProducer,",
            "    HostnameCachingHTTPSPolicy,",
            "    HTTPConnectionPool,",
            "    Request,",
            "    ResponseDone,",
            "    _HTTP11ClientFactory,",
            ")",
            "from twisted.web.error import SchemeNotSupported",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IAgentEndpointFactory,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "from twisted.web.test.injectionhelpers import (",
            "    MethodInjectionTestsMixin,",
            "    URIInjectionTestsMixin,",
            ")",
            "",
            "try:",
            "    from twisted.internet import ssl as _ssl",
            "except ImportError:",
            "    ssl = None",
            "    sslPresent = False",
            "else:",
            "    ssl = _ssl",
            "    sslPresent = True",
            "    from twisted.internet._sslverify import ClientTLSOptions, IOpenSSLTrustRoot",
            "    from twisted.internet.ssl import optionsForClientTLS",
            "    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol",
            "",
            "    @implementer(IOpenSSLTrustRoot)",
            "    class CustomOpenSSLTrustRoot:",
            "        called = False",
            "        context = None",
            "",
            "        def _addCACertsToContext(self, context):",
            "            self.called = True",
            "            self.context = context",
            "",
            "",
            "class StubHTTPProtocol(Protocol):",
            "    \"\"\"",
            "    A protocol like L{HTTP11ClientProtocol} but which does not actually know",
            "    HTTP/1.1 and only collects requests in a list.",
            "",
            "    @ivar requests: A C{list} of two-tuples.  Each time a request is made, a",
            "        tuple consisting of the request and the L{Deferred} returned from the",
            "        request method is appended to this list.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.requests = []",
            "        self.state = \"QUIESCENT\"",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Capture the given request for later inspection.",
            "",
            "        @return: A L{Deferred} which this code will never fire.",
            "        \"\"\"",
            "        result = Deferred()",
            "        self.requests.append((request, result))",
            "        return result",
            "",
            "",
            "class FileConsumer:",
            "    def __init__(self, outputFile):",
            "        self.outputFile = outputFile",
            "",
            "    def write(self, bytes):",
            "        self.outputFile.write(bytes)",
            "",
            "",
            "class FileBodyProducerTests(TestCase):",
            "    \"\"\"",
            "    Tests for the L{FileBodyProducer} which reads bytes from a file and writes",
            "    them to an L{IConsumer}.",
            "    \"\"\"",
            "",
            "    def _termination(self):",
            "        \"\"\"",
            "        This method can be used as the C{terminationPredicateFactory} for a",
            "        L{Cooperator}.  It returns a predicate which immediately returns",
            "        C{False}, indicating that no more work should be done this iteration.",
            "        This has the result of only allowing one iteration of a cooperative",
            "        task to be run per L{Cooperator} iteration.",
            "        \"\"\"",
            "        return lambda: True",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create a L{Cooperator} hooked up to an easily controlled, deterministic",
            "        scheduler to use with L{FileBodyProducer}.",
            "        \"\"\"",
            "        self._scheduled = []",
            "        self.cooperator = task.Cooperator(self._termination, self._scheduled.append)",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        L{FileBodyProducer} instances provide L{IBodyProducer}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IBodyProducer, FileBodyProducer(BytesIO(b\"\"))))",
            "",
            "    def test_unknownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object",
            "        without either a C{seek} or C{tell} method, its C{length} attribute is",
            "        set to C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "",
            "        class HasSeek:",
            "            def seek(self, offset, whence):",
            "                pass",
            "",
            "        class HasTell:",
            "            def tell(self):",
            "                pass",
            "",
            "        producer = FileBodyProducer(HasSeek())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "        producer = FileBodyProducer(HasTell())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "",
            "    def test_knownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object with",
            "        both C{seek} and C{tell} methods, its C{length} attribute is set to the",
            "        size of the file as determined by those methods.",
            "        \"\"\"",
            "        inputBytes = b\"here are some bytes\"",
            "        inputFile = BytesIO(inputBytes)",
            "        inputFile.seek(5)",
            "        producer = FileBodyProducer(inputFile)",
            "        self.assertEqual(len(inputBytes) - 5, producer.length)",
            "        self.assertEqual(inputFile.tell(), 5)",
            "",
            "    def test_defaultCooperator(self):",
            "        \"\"\"",
            "        If no L{Cooperator} instance is passed to L{FileBodyProducer}, the",
            "        global cooperator is used.",
            "        \"\"\"",
            "        producer = FileBodyProducer(BytesIO(b\"\"))",
            "        self.assertEqual(task.cooperate, producer._cooperate)",
            "",
            "    def test_startProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.startProducing} starts writing bytes from the input",
            "        file to the given L{IConsumer} and returns a L{Deferred} which fires",
            "        when they have all been written.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        for i in range(len(expectedResult) // readSize + 1):",
            "            self._scheduled.pop(0)()",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertEqual(expectedResult, output.getvalue())",
            "        self.assertEqual(None, self.successResultOf(complete))",
            "",
            "    def test_inputClosedAtEOF(self):",
            "        \"\"\"",
            "        When L{FileBodyProducer} reaches end-of-file on the input file given to",
            "        it, the input file is closed.",
            "        \"\"\"",
            "        readSize = 4",
            "        inputBytes = b\"some friendly bytes\"",
            "        inputFile = BytesIO(inputBytes)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        consumer = FileConsumer(BytesIO())",
            "        producer.startProducing(consumer)",
            "        for i in range(len(inputBytes) // readSize + 2):",
            "            self._scheduled.pop(0)()",
            "        self.assertTrue(inputFile.closed)",
            "",
            "    def test_failedReadWhileProducing(self):",
            "        \"\"\"",
            "        If a read from the input file fails while producing bytes to the",
            "        consumer, the L{Deferred} returned by",
            "        L{FileBodyProducer.startProducing} fires with a L{Failure} wrapping",
            "        that exception.",
            "        \"\"\"",
            "",
            "        class BrokenFile:",
            "            def read(self, count):",
            "                raise OSError(\"Simulated bad thing\")",
            "",
            "        producer = FileBodyProducer(BrokenFile(), self.cooperator)",
            "        complete = producer.startProducing(FileConsumer(BytesIO()))",
            "        self._scheduled.pop(0)()",
            "        self.failureResultOf(complete).trap(IOError)",
            "",
            "    def test_cancelWhileProducing(self):",
            "        \"\"\"",
            "        When the L{Deferred} returned by L{FileBodyProducer.startProducing} is",
            "        cancelled, the input file is closed and the task is stopped.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        complete.cancel()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "    def test_stopProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} stops the underlying L{IPullProducer}",
            "        and the cooperative task responsible for calling C{resumeProducing} and",
            "        closes the input file but does not cause the L{Deferred} returned by",
            "        C{startProducing} to fire.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "    def test_pauseProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.pauseProducing} temporarily suspends writing bytes",
            "        from the input file to the given L{IConsumer}.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 5",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        producer.pauseProducing()",
            "",
            "        # Sort of depends on an implementation detail of Cooperator: even",
            "        # though the only task is paused, there's still a scheduled call.  If",
            "        # this were to go away because Cooperator became smart enough to cancel",
            "        # this call in this case, that would be fine.",
            "        self._scheduled.pop(0)()",
            "",
            "        # Since the producer is paused, no new data should be here.",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertNoResult(complete)",
            "",
            "    def test_resumeProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.resumeProducing} re-commences writing bytes from the",
            "        input file to the given L{IConsumer} after it was previously paused",
            "        with L{FileBodyProducer.pauseProducing}.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 5",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize], output.getvalue())",
            "        producer.pauseProducing()",
            "        producer.resumeProducing()",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[: readSize * 2], output.getvalue())",
            "",
            "    def test_multipleStop(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} can be called more than once without",
            "        raising an exception.",
            "        \"\"\"",
            "        expectedResult = b\"test\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "",
            "EXAMPLE_COM_IP = \"127.0.0.7\"",
            "EXAMPLE_COM_V6_IP = \"::7\"",
            "EXAMPLE_NET_IP = \"127.0.0.8\"",
            "EXAMPLE_ORG_IP = \"127.0.0.9\"",
            "FOO_LOCAL_IP = \"127.0.0.10\"",
            "FOO_COM_IP = \"127.0.0.11\"",
            "",
            "",
            "class FakeReactorAndConnectMixin:",
            "    \"\"\"",
            "    A test mixin providing a testable C{Reactor} class and a dummy C{connect}",
            "    method which allows instances to pretend to be endpoints.",
            "    \"\"\"",
            "",
            "    def createReactor(self):",
            "        \"\"\"",
            "        Create a L{MemoryReactorClock} and give it some hostnames it can",
            "        resolve.",
            "",
            "        @return: a L{MemoryReactorClock}-like object with a slightly limited",
            "            interface (only C{advance} and C{tcpClients} in addition to its",
            "            formally-declared reactor interfaces), which can resolve a fixed",
            "            set of domains.",
            "        \"\"\"",
            "        mrc = MemoryReactorClock()",
            "        drr = deterministicResolvingReactor(",
            "            mrc,",
            "            hostMap={",
            "                \"example.com\": [EXAMPLE_COM_IP],",
            "                \"ipv6.example.com\": [EXAMPLE_COM_V6_IP],",
            "                \"example.net\": [EXAMPLE_NET_IP],",
            "                \"example.org\": [EXAMPLE_ORG_IP],",
            "                \"foo\": [FOO_LOCAL_IP],",
            "                \"foo.com\": [FOO_COM_IP],",
            "                \"127.0.0.7\": [\"127.0.0.7\"],",
            "                \"::7\": [\"::7\"],",
            "            },",
            "        )",
            "",
            "        # Lots of tests were written expecting MemoryReactorClock and the",
            "        # reactor seen by the SUT to be the same object.",
            "        drr.tcpClients = mrc.tcpClients",
            "        drr.advance = mrc.advance",
            "        return drr",
            "",
            "    class StubEndpoint:",
            "        \"\"\"",
            "        Endpoint that wraps existing endpoint, substitutes StubHTTPProtocol, and",
            "        resulting protocol instances are attached to the given test case.",
            "        \"\"\"",
            "",
            "        def __init__(self, endpoint, testCase):",
            "            self.endpoint = endpoint",
            "            self.testCase = testCase",
            "",
            "            def nothing():",
            "                \"\"\"this function does nothing\"\"\"",
            "",
            "            self.factory = _HTTP11ClientFactory(nothing, repr(self.endpoint))",
            "            self.protocol = StubHTTPProtocol()",
            "            self.factory.buildProtocol = lambda addr: self.protocol",
            "",
            "        def connect(self, ignoredFactory):",
            "            self.testCase.protocol = self.protocol",
            "            self.endpoint.connect(self.factory)",
            "            return succeed(self.protocol)",
            "",
            "    def buildAgentForWrapperTest(self, reactor):",
            "        \"\"\"",
            "        Return an Agent suitable for use in tests that wrap the Agent and want",
            "        both a fake reactor and StubHTTPProtocol.",
            "        \"\"\"",
            "        agent = client.Agent(reactor)",
            "        _oldGetEndpoint = agent._getEndpoint",
            "        agent._getEndpoint = lambda *args: (",
            "            self.StubEndpoint(_oldGetEndpoint(*args), self)",
            "        )",
            "        return agent",
            "",
            "    def connect(self, factory):",
            "        \"\"\"",
            "        Fake implementation of an endpoint which synchronously",
            "        succeeds with an instance of L{StubHTTPProtocol} for ease of",
            "        testing.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(None)",
            "        self.protocol = protocol",
            "        return succeed(protocol)",
            "",
            "",
            "class DummyEndpoint:",
            "    \"\"\"",
            "    An endpoint that uses a fake transport.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        protocol = factory.buildProtocol(None)",
            "        protocol.makeConnection(StringTransport())",
            "        return succeed(protocol)",
            "",
            "",
            "class BadEndpoint:",
            "    \"\"\"",
            "    An endpoint that shouldn't be called.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        raise RuntimeError(\"This endpoint should not have been used.\")",
            "",
            "",
            "class DummyFactory(Factory):",
            "    \"\"\"",
            "    Create C{StubHTTPProtocol} instances.",
            "    \"\"\"",
            "",
            "    def __init__(self, quiescentCallback, metadata):",
            "        pass",
            "",
            "    protocol = StubHTTPProtocol",
            "",
            "",
            "class HTTPConnectionPoolTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the L{HTTPConnectionPool} class.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.fakeReactor = self.createReactor()",
            "        self.pool = HTTPConnectionPool(self.fakeReactor)",
            "        self.pool._factory = DummyFactory",
            "        # The retry code path is tested in HTTPConnectionPoolRetryTests:",
            "        self.pool.retryAutomatically = False",
            "",
            "    def test_getReturnsNewIfCacheEmpty(self):",
            "        \"\"\"",
            "        If there are no cached connections,",
            "        L{HTTPConnectionPool.getConnection} returns a new connection.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "",
            "        def gotConnection(conn):",
            "            self.assertIsInstance(conn, StubHTTPProtocol)",
            "            # The new connection is not stored in the pool:",
            "            self.assertNotIn(conn, self.pool._connections.values())",
            "",
            "        unknownKey = 12245",
            "        d = self.pool.getConnection(unknownKey, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_putStartsTimeout(self):",
            "        \"\"\"",
            "        If a connection is put back to the pool, a 240-sec timeout is started.",
            "",
            "        When the timeout hits, the connection is closed and removed from the",
            "        pool.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "",
            "        # Connection is in pool, still not closed:",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "",
            "        # Advance 239 seconds, still not closed:",
            "        self.fakeReactor.advance(239)",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "        self.assertIn(protocol, self.pool._timeouts)",
            "",
            "        # Advance past 240 seconds, connection will be closed:",
            "        self.fakeReactor.advance(1.1)",
            "        self.assertEqual(protocol.transport.disconnecting, True)",
            "        self.assertNotIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "        self.assertNotIn(protocol, self.pool._timeouts)",
            "",
            "    def test_putExceedsMaxPersistent(self):",
            "        \"\"\"",
            "        If an idle connection is put back in the cache and the max number of",
            "        persistent connections has been exceeded, one of the connections is",
            "        closed and removed from the cache.",
            "        \"\"\"",
            "        pool = self.pool",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection((\"http\", b\"example.com\", 80), p)",
            "        self.assertEqual(pool._connections[(\"http\", b\"example.com\", 80)], origCached)",
            "        timeouts = pool._timeouts.copy()",
            "",
            "        # Now we add another one:",
            "        newProtocol = StubHTTPProtocol()",
            "        newProtocol.makeConnection(StringTransport())",
            "        pool._putConnection((\"http\", b\"example.com\", 80), newProtocol)",
            "",
            "        # The oldest cached connections will be removed and disconnected:",
            "        newCached = pool._connections[(\"http\", b\"example.com\", 80)]",
            "        self.assertEqual(len(newCached), 2)",
            "        self.assertEqual(newCached, [origCached[1], newProtocol])",
            "        self.assertEqual([p.transport.disconnecting for p in newCached], [False, False])",
            "        self.assertEqual(origCached[0].transport.disconnecting, True)",
            "        self.assertTrue(timeouts[origCached[0]].cancelled)",
            "        self.assertNotIn(origCached[0], pool._timeouts)",
            "",
            "    def test_maxPersistentPerHost(self):",
            "        \"\"\"",
            "        C{maxPersistentPerHost} is enforced per C{(scheme, host, port)}:",
            "        different keys have different max connections.",
            "        \"\"\"",
            "",
            "        def addProtocol(scheme, host, port):",
            "            p = StubHTTPProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            return p",
            "",
            "        persistent = []",
            "        persistent.append(addProtocol(\"http\", b\"example.com\", 80))",
            "        persistent.append(addProtocol(\"http\", b\"example.com\", 80))",
            "        addProtocol(\"https\", b\"example.com\", 443)",
            "        addProtocol(\"http\", b\"www2.example.com\", 80)",
            "",
            "        self.assertEqual(",
            "            self.pool._connections[(\"http\", b\"example.com\", 80)], persistent",
            "        )",
            "        self.assertEqual(len(self.pool._connections[(\"https\", b\"example.com\", 443)]), 1)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"http\", b\"www2.example.com\", 80)]), 1",
            "        )",
            "",
            "    def test_getCachedConnection(self):",
            "        \"\"\"",
            "        Getting an address which has a cached connection returns the cached",
            "        connection, removes it from the cache and cancels its timeout.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "",
            "        def gotConnection(conn):",
            "            # We got the cached connection:",
            "            self.assertIdentical(protocol, conn)",
            "            self.assertNotIn(conn, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "            # And the timeout was cancelled:",
            "            self.fakeReactor.advance(241)",
            "            self.assertEqual(conn.transport.disconnecting, False)",
            "            self.assertNotIn(conn, self.pool._timeouts)",
            "",
            "        return self.pool.getConnection(",
            "            (\"http\", b\"example.com\", 80),",
            "            BadEndpoint(),",
            "        ).addCallback(gotConnection)",
            "",
            "    def test_newConnection(self):",
            "        \"\"\"",
            "        The pool's C{_newConnection} method constructs a new connection.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        key = 12245",
            "        self.pool._putConnection(key, protocol)",
            "",
            "        def gotConnection(newConnection):",
            "            # We got a new connection:",
            "            self.assertNotIdentical(protocol, newConnection)",
            "            # And the old connection is still there:",
            "            self.assertIn(protocol, self.pool._connections[key])",
            "            # While the new connection is not:",
            "            self.assertNotIn(newConnection, self.pool._connections.values())",
            "",
            "        d = self.pool._newConnection(key, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_getSkipsDisconnected(self):",
            "        \"\"\"",
            "        When getting connections out of the cache, disconnected connections",
            "        are removed and not returned.",
            "        \"\"\"",
            "        pool = self.pool",
            "        key = (\"http\", b\"example.com\", 80)",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection(key, p)",
            "        self.assertEqual(pool._connections[key], origCached)",
            "",
            "        # We close the first one:",
            "        origCached[0].state = \"DISCONNECTED\"",
            "",
            "        # Now, when we retrive connections we should get the *second* one:",
            "        result = []",
            "        self.pool.getConnection(key, BadEndpoint()).addCallback(result.append)",
            "        self.assertIdentical(result[0], origCached[1])",
            "",
            "        # And both the disconnected and removed connections should be out of",
            "        # the cache:",
            "        self.assertEqual(pool._connections[key], [])",
            "        self.assertEqual(pool._timeouts, {})",
            "",
            "    def test_putNotQuiescent(self):",
            "        \"\"\"",
            "        If a non-quiescent connection is put back in the cache, an error is",
            "        logged.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        # By default state is QUIESCENT",
            "        self.assertEqual(protocol.state, \"QUIESCENT\")",
            "",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "",
            "        protocol.state = \"NOTQUIESCENT\"",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "        self.assertEquals(1, len(logObserver))",
            "",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "",
            "        self.assertIsInstance(f.value, RuntimeError)",
            "        self.assertEqual(",
            "            f.getErrorMessage(), \"BUG: Non-quiescent protocol added to connection pool.\"",
            "        )",
            "        self.assertIdentical(",
            "            None, self.pool._connections.get((\"http\", b\"example.com\", 80))",
            "        )",
            "        self.flushLoggedErrors(RuntimeError)",
            "",
            "    def test_getUsesQuiescentCallback(self):",
            "        \"\"\"",
            "        When L{HTTPConnectionPool.getConnection} connects, it returns a",
            "        C{Deferred} that fires with an instance of L{HTTP11ClientProtocol}",
            "        that has the correct quiescent callback attached. When this callback",
            "        is called the protocol is returned to the cache correctly, using the",
            "        right key.",
            "        \"\"\"",
            "",
            "        class StringEndpoint:",
            "            def connect(self, factory):",
            "                p = factory.buildProtocol(None)",
            "                p.makeConnection(StringTransport())",
            "                return succeed(p)",
            "",
            "        pool = HTTPConnectionPool(self.fakeReactor, True)",
            "        pool.retryAutomatically = False",
            "        result = []",
            "        key = \"a key\"",
            "        pool.getConnection(key, StringEndpoint()).addCallback(result.append)",
            "        protocol = result[0]",
            "        self.assertIsInstance(protocol, HTTP11ClientProtocol)",
            "",
            "        # Now that we have protocol instance, lets try to put it back in the",
            "        # pool:",
            "        protocol._state = \"QUIESCENT\"",
            "        protocol._quiescentCallback(protocol)",
            "",
            "        # If we try to retrive a connection to same destination again, we",
            "        # should get the same protocol, because it should've been added back",
            "        # to the pool:",
            "        result2 = []",
            "        pool.getConnection(key, StringEndpoint()).addCallback(result2.append)",
            "        self.assertIdentical(result2[0], protocol)",
            "",
            "    def test_closeCachedConnections(self):",
            "        \"\"\"",
            "        L{HTTPConnectionPool.closeCachedConnections} closes all cached",
            "        connections and removes them from the cache. It returns a Deferred",
            "        that fires when they have all lost their connections.",
            "        \"\"\"",
            "        persistent = []",
            "",
            "        def addProtocol(scheme, host, port):",
            "            p = HTTP11ClientProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            persistent.append(p)",
            "",
            "        addProtocol(\"http\", b\"example.com\", 80)",
            "        addProtocol(\"http\", b\"www2.example.com\", 80)",
            "        doneDeferred = self.pool.closeCachedConnections()",
            "",
            "        # Connections have begun disconnecting:",
            "        for p in persistent:",
            "            self.assertEqual(p.transport.disconnecting, True)",
            "        self.assertEqual(self.pool._connections, {})",
            "        # All timeouts were cancelled and removed:",
            "        for dc in self.fakeReactor.getDelayedCalls():",
            "            self.assertEqual(dc.cancelled, True)",
            "        self.assertEqual(self.pool._timeouts, {})",
            "",
            "        # Returned Deferred fires when all connections have been closed:",
            "        result = []",
            "        doneDeferred.addCallback(result.append)",
            "        self.assertEqual(result, [])",
            "        persistent[0].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [])",
            "        persistent[1].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_cancelGetConnectionCancelsEndpointConnect(self):",
            "        \"\"\"",
            "        Cancelling the C{Deferred} returned from",
            "        L{HTTPConnectionPool.getConnection} cancels the C{Deferred} returned",
            "        by opening a new connection with the given endpoint.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "        connectionResult = Deferred()",
            "",
            "        class Endpoint:",
            "            def connect(self, factory):",
            "                return connectionResult",
            "",
            "        d = self.pool.getConnection(12345, Endpoint())",
            "        d.cancel()",
            "        self.assertEqual(self.failureResultOf(connectionResult).type, CancelledError)",
            "",
            "",
            "class AgentTestsMixin:",
            "    \"\"\"",
            "    Tests for any L{IAgent} implementation.",
            "    \"\"\"",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        The agent object provides L{IAgent}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IAgent, self.makeAgent()))",
            "",
            "",
            "class IntegrationTestingMixin:",
            "    \"\"\"",
            "    Transport-to-Agent integration tests for both HTTP and HTTPS.",
            "    \"\"\"",
            "",
            "    def test_integrationTestIPv4(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv4.",
            "        \"\"\"",
            "        self.integrationTest(b\"example.com\", EXAMPLE_COM_IP, IPv4Address)",
            "",
            "    def test_integrationTestIPv4Address(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv4 when hostname is an IPv4 address.",
            "        \"\"\"",
            "        self.integrationTest(b\"127.0.0.7\", \"127.0.0.7\", IPv4Address)",
            "",
            "    def test_integrationTestIPv6(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv6.",
            "        \"\"\"",
            "        self.integrationTest(b\"ipv6.example.com\", EXAMPLE_COM_V6_IP, IPv6Address)",
            "",
            "    def test_integrationTestIPv6Address(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv6 when hostname is an IPv6 address.",
            "        \"\"\"",
            "        self.integrationTest(b\"[::7]\", \"::7\", IPv6Address)",
            "",
            "    def integrationTest(",
            "        self,",
            "        hostName,",
            "        expectedAddress,",
            "        addressType,",
            "        serverWrapper=lambda server: server,",
            "        createAgent=client.Agent,",
            "        scheme=b\"http\",",
            "    ):",
            "        \"\"\"",
            "        L{Agent} will make a TCP connection, send an HTTP request, and return a",
            "        L{Deferred} that fires when the response has been received.",
            "",
            "        @param hostName: The hostname to interpolate into the URL to be",
            "            requested.",
            "        @type hostName: L{bytes}",
            "",
            "        @param expectedAddress: The expected address string.",
            "        @type expectedAddress: L{bytes}",
            "",
            "        @param addressType: The class to construct an address out of.",
            "        @type addressType: L{type}",
            "",
            "        @param serverWrapper: A callable that takes a protocol factory and",
            "            returns a protocol factory; used to wrap the server / responder",
            "            side in a TLS server.",
            "        @type serverWrapper:",
            "            serverWrapper(L{twisted.internet.interfaces.IProtocolFactory}) ->",
            "            L{twisted.internet.interfaces.IProtocolFactory}",
            "",
            "        @param createAgent: A callable that takes a reactor and produces an",
            "            L{IAgent}; used to construct an agent with an appropriate trust",
            "            root for TLS.",
            "        @type createAgent: createAgent(reactor) -> L{IAgent}",
            "",
            "        @param scheme: The scheme to test, C{http} or C{https}",
            "        @type scheme: L{bytes}",
            "        \"\"\"",
            "        reactor = self.createReactor()",
            "        agent = createAgent(reactor)",
            "        deferred = agent.request(b\"GET\", scheme + b\"://\" + hostName + b\"/\")",
            "        host, port, factory, timeout, bind = reactor.tcpClients[0]",
            "        self.assertEqual(host, expectedAddress)",
            "        peerAddress = addressType(\"TCP\", host, port)",
            "        clientProtocol = factory.buildProtocol(peerAddress)",
            "        clientTransport = FakeTransport(clientProtocol, False, peerAddress=peerAddress)",
            "        clientProtocol.makeConnection(clientTransport)",
            "",
            "        @Factory.forProtocol",
            "        def accumulator():",
            "            ap = AccumulatingProtocol()",
            "            accumulator.currentProtocol = ap",
            "            return ap",
            "",
            "        accumulator.currentProtocol = None",
            "        accumulator.protocolConnectionMade = None",
            "        wrapper = serverWrapper(accumulator).buildProtocol(None)",
            "        serverTransport = FakeTransport(wrapper, True)",
            "        wrapper.makeConnection(serverTransport)",
            "        pump = IOPump(clientProtocol, wrapper, clientTransport, serverTransport, False)",
            "        pump.flush()",
            "        self.assertNoResult(deferred)",
            "        lines = accumulator.currentProtocol.data.split(b\"\\r\\n\")",
            "        self.assertTrue(lines[0].startswith(b\"GET / HTTP\"), lines[0])",
            "        headers = dict([line.split(b\": \", 1) for line in lines[1:] if line])",
            "        self.assertEqual(headers[b\"Host\"], hostName)",
            "        self.assertNoResult(deferred)",
            "        accumulator.currentProtocol.transport.write(",
            "            b\"HTTP/1.1 200 OK\"",
            "            b\"\\r\\nX-An-Header: an-value\\r\\n\"",
            "            b\"\\r\\nContent-length: 12\\r\\n\\r\\n\"",
            "            b\"hello world!\"",
            "        )",
            "        pump.flush()",
            "        response = self.successResultOf(deferred)",
            "        self.assertEquals(",
            "            response.headers.getRawHeaders(b\"x-an-header\")[0], b\"an-value\"",
            "        )",
            "",
            "",
            "@implementer(IAgentEndpointFactory)",
            "class StubEndpointFactory:",
            "    \"\"\"",
            "    A stub L{IAgentEndpointFactory} for use in testing.",
            "    \"\"\"",
            "",
            "    def endpointForURI(self, uri):",
            "        \"\"\"",
            "        Testing implementation.",
            "",
            "        @param uri: A L{URI}.",
            "",
            "        @return: C{(scheme, host, port)} of passed in URI; violation of",
            "            interface but useful for testing.",
            "        @rtype: L{tuple}",
            "        \"\"\"",
            "        return (uri.scheme, uri.host, uri.port)",
            "",
            "",
            "class AgentTests(",
            "    TestCase, FakeReactorAndConnectMixin, AgentTestsMixin, IntegrationTestingMixin",
            "):",
            "    \"\"\"",
            "    Tests for the new HTTP client API provided by L{Agent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.Agent} instance",
            "        \"\"\"",
            "        return client.Agent(self.reactor)",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_defaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in, the L{Agent} creates a non-persistent pool.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor)",
            "        self.assertIsInstance(agent._pool, HTTPConnectionPool)",
            "        self.assertEqual(agent._pool.persistent, False)",
            "        self.assertIdentical(agent._reactor, agent._pool._reactor)",
            "",
            "    def test_persistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{True} on the L{HTTPConnectionPool} (the",
            "        default), C{Request}s are created with their C{persistent} flag set to",
            "        C{True}.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(b\"GET\", b\"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, True)",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{False} when creating the",
            "        L{HTTPConnectionPool}, C{Request}s are created with their",
            "        C{persistent} flag set to C{False}.",
            "",
            "        Elsewhere in the tests for the underlying HTTP code we ensure that",
            "        this will result in the disconnection of the HTTP protocol once the",
            "        request is done, so that the connection will not be returned to the",
            "        pool.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor, persistent=False)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(b\"GET\", b\"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, False)",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the Agent, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint returned by",
            "        C{self._getEndpoint}. The key used is C{(scheme, host, port)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "",
            "        class MyAgent(client.Agent):",
            "            def _getEndpoint(this, uri):",
            "                self.assertEqual(",
            "                    (uri.scheme, uri.host, uri.port), (b\"http\", b\"foo\", 80)",
            "                )",
            "                return endpoint",
            "",
            "        class DummyPool:",
            "            connected = False",
            "            persistent = False",
            "",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertEqual(ep, endpoint)",
            "                # This is the key the default Agent uses, others will have",
            "                # different keys:",
            "                self.assertEqual(key, (b\"http\", b\"foo\", 80))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = MyAgent(self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        headers = http_headers.Headers()",
            "        headers.addRawHeader(b\"host\", b\"foo\")",
            "        bodyProducer = object()",
            "        agent.request(",
            "            b\"GET\", b\"http://foo/\", bodyProducer=bodyProducer, headers=headers",
            "        )",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "    def test_nonBytesMethod(self):",
            "        \"\"\"",
            "        L{Agent.request} raises L{TypeError} when the C{method} argument isn't",
            "        L{bytes}.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, self.agent.request, \"GET\", b\"http://foo.example/\")",
            "",
            "    def test_unsupportedScheme(self):",
            "        \"\"\"",
            "        L{Agent.request} returns a L{Deferred} which fails with",
            "        L{SchemeNotSupported} if the scheme of the URI passed to it is not",
            "        C{'http'}.",
            "        \"\"\"",
            "        return self.assertFailure(",
            "            self.agent.request(b\"GET\", b\"mailto:alice@example.com\"), SchemeNotSupported",
            "        )",
            "",
            "    def test_connectionFailed(self):",
            "        \"\"\"",
            "        The L{Deferred} returned by L{Agent.request} fires with a L{Failure} if",
            "        the TCP connection attempt fails.",
            "        \"\"\"",
            "        result = self.agent.request(b\"GET\", b\"http://foo/\")",
            "        # Cause the connection to be refused",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        factory.clientConnectionFailed(None, Failure(ConnectionRefusedError()))",
            "        self.reactor.advance(10)",
            "        # ^ https://twistedmatrix.com/trac/ticket/8202",
            "        self.failureResultOf(result, ConnectionRefusedError)",
            "",
            "    def test_connectHTTP(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a C{HostnameEndpoint} when passed a scheme",
            "        of C{'http'}.",
            "        \"\"\"",
            "        expectedHost = b\"example.com\"",
            "        expectedPort = 1234",
            "        endpoint = self.agent._getEndpoint(",
            "            URI.fromBytes(b\"http://%b:%d\" % (expectedHost, expectedPort))",
            "        )",
            "        self.assertEqual(endpoint._hostStr, \"example.com\")",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "        self.assertIsInstance(endpoint, HostnameEndpoint)",
            "",
            "    def test_nonDecodableURI(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} when given a non-ASCII decodable URI will raise a",
            "        L{ValueError} saying such.",
            "        \"\"\"",
            "        uri = URI.fromBytes(b\"http://example.com:80\")",
            "        uri.host = \"\\u2603.com\".encode()",
            "",
            "        with self.assertRaises(ValueError) as e:",
            "            self.agent._getEndpoint(uri)",
            "",
            "        self.assertEqual(",
            "            e.exception.args[0],",
            "            (",
            "                \"The host of the provided URI ({reprout}) contains \"",
            "                \"non-ASCII octets, it should be ASCII \"",
            "                \"decodable.\"",
            "            ).format(reprout=repr(uri.host)),",
            "        )",
            "",
            "    def test_hostProvided(self):",
            "        \"\"\"",
            "        If L{None} is passed to L{Agent.request} for the C{headers} parameter,",
            "        a L{Headers} instance is created for the request and a I{Host} header",
            "        added to it.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo?bar\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_hostIPv6Bracketed(self):",
            "        \"\"\"",
            "        If an IPv6 address is used in the C{uri} passed to L{Agent.request},",
            "        the computed I{Host} header needs to be bracketed.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://[::1]/\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"[::1]\"])",
            "",
            "    def test_hostOverride(self):",
            "        \"\"\"",
            "        If the headers passed to L{Agent.request} includes a value for the",
            "        I{Host} header, that value takes precedence over the one which would",
            "        otherwise be automatically provided.",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"quux\"]})",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo?bar\", headers)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"quux\"])",
            "",
            "    def test_headersUnmodified(self):",
            "        \"\"\"",
            "        If a I{Host} header must be added to the request, the L{Headers}",
            "        instance passed to L{Agent.request} is not modified.",
            "        \"\"\"",
            "        headers = http_headers.Headers()",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo\", headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should have been issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        # And the headers object passed in should not have changed.",
            "        self.assertEqual(headers, http_headers.Headers())",
            "",
            "    def test_hostValueStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port of C{80},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"http\", b\"example.com\", 80), b\"example.com\"",
            "        )",
            "",
            "    def test_hostValueNonStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port other than C{80},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"http\", b\"example.com\", 54321),",
            "            b\"example.com:54321\",",
            "        )",
            "",
            "    def test_hostValueStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port of C{443},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"https\", b\"example.com\", 443), b\"example.com\"",
            "        )",
            "",
            "    def test_hostValueNonStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port other than C{443},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"https\", b\"example.com\", 54321),",
            "            b\"example.com:54321\",",
            "        )",
            "",
            "    def test_request(self):",
            "        \"\"\"",
            "        L{Agent.request} establishes a new connection to the host indicated by",
            "        the host part of the URI passed to it and issues a request using the",
            "        method, the path portion of the URI, the headers, and the body producer",
            "        passed to it.  It returns a L{Deferred} which fires with an",
            "        L{IResponse} from the server.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"]})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(b\"GET\", b\"http://example.com:1234/foo?bar\", headers, body)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, b\"GET\")",
            "        self.assertEqual(req.uri, b\"/foo?bar\")",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"example.com:1234\"]}),",
            "        )",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "    def test_connectTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} agent.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_connectTimeoutHTTPS(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request(b\"GET\", b\"https://foo/\")",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "    def test_bindAddress(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress=\"192.168.0.1\")",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual(\"192.168.0.1\", address)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_bindAddressSSL(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress=\"192.168.0.1\")",
            "        agent.request(b\"GET\", b\"https://foo/\")",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual(\"192.168.0.1\", address)",
            "",
            "    def test_responseIncludesRequest(self):",
            "        \"\"\"",
            "        L{Response}s returned by L{Agent.request} have a reference to the",
            "        L{Request} that was originally issued.",
            "        \"\"\"",
            "        uri = b\"http://example.com/\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        d = agent.request(b\"GET\", uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "",
            "        resp = client.Response._construct(",
            "            (b\"HTTP\", 1, 1), 200, b\"OK\", client.Headers({}), None, req",
            "        )",
            "        res.callback(resp)",
            "",
            "        response = self.successResultOf(d)",
            "        self.assertEqual(",
            "            (",
            "                response.request.method,",
            "                response.request.absoluteURI,",
            "                response.request.headers,",
            "            ),",
            "            (req.method, req.absoluteURI, req.headers),",
            "        )",
            "",
            "    def test_requestAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is the absolute URI of the request.",
            "        \"\"\"",
            "        uri = b\"http://example.com/foo;1234?bar#frag\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        agent.request(b\"GET\", uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.absoluteURI, uri)",
            "",
            "    def test_requestMissingAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is L{None} if L{Request._parsedURI} is L{None}.",
            "        \"\"\"",
            "        request = client.Request(b\"FOO\", b\"/\", client.Headers(), None)",
            "        self.assertIdentical(request.absoluteURI, None)",
            "",
            "    def test_endpointFactory(self):",
            "        \"\"\"",
            "        L{Agent.usingEndpointFactory} creates an L{Agent} that uses the given",
            "        factory to create endpoints.",
            "        \"\"\"",
            "        factory = StubEndpointFactory()",
            "        agent = client.Agent.usingEndpointFactory(None, endpointFactory=factory)",
            "        uri = URI.fromBytes(b\"http://example.com/\")",
            "        returnedEndpoint = agent._getEndpoint(uri)",
            "        self.assertEqual(returnedEndpoint, (b\"http\", b\"example.com\", 80))",
            "",
            "    def test_endpointFactoryDefaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in to L{Agent.usingEndpointFactory}, a default",
            "        pool is constructed with no persistent connections.",
            "        \"\"\"",
            "        agent = client.Agent.usingEndpointFactory(self.reactor, StubEndpointFactory())",
            "        pool = agent._pool",
            "        self.assertEqual(",
            "            (pool.__class__, pool.persistent, pool._reactor),",
            "            (HTTPConnectionPool, False, agent._reactor),",
            "        )",
            "",
            "    def test_endpointFactoryPool(self):",
            "        \"\"\"",
            "        If a pool is passed in to L{Agent.usingEndpointFactory} it is used as",
            "        the L{Agent} pool.",
            "        \"\"\"",
            "        pool = object()",
            "        agent = client.Agent.usingEndpointFactory(",
            "            self.reactor, StubEndpointFactory(), pool",
            "        )",
            "        self.assertIs(pool, agent._pool)",
            "",
            "",
            "class AgentMethodInjectionTests(",
            "    FakeReactorAndConnectMixin,",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Agent} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        agent = client.Agent(self.createReactor())",
            "        uri = b\"http://twisted.invalid\"",
            "        agent.request(method, uri, client.Headers(), None)",
            "",
            "",
            "class AgentURIInjectionTests(",
            "    FakeReactorAndConnectMixin,",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Agent} against URI injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param uri: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        agent = client.Agent(self.createReactor())",
            "        method = b\"GET\"",
            "        agent.request(method, uri, client.Headers(), None)",
            "",
            "",
            "@skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "class AgentHTTPSTests(TestCase, FakeReactorAndConnectMixin, IntegrationTestingMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API that depends on SSL.",
            "    \"\"\"",
            "",
            "    def makeEndpoint(self, host=b\"example.com\", port=443):",
            "        \"\"\"",
            "        Create an L{Agent} with an https scheme and return its endpoint",
            "        created according to the arguments.",
            "",
            "        @param host: The host for the endpoint.",
            "        @type host: L{bytes}",
            "",
            "        @param port: The port for the endpoint.",
            "        @type port: L{int}",
            "",
            "        @return: An endpoint of an L{Agent} constructed according to args.",
            "        @rtype: L{SSL4ClientEndpoint}",
            "        \"\"\"",
            "        return client.Agent(self.createReactor())._getEndpoint(",
            "            URI.fromBytes(b\"https://%b:%d/\" % (host, port))",
            "        )",
            "",
            "    def test_endpointType(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a L{SSL4ClientEndpoint} when passed a",
            "        scheme of C{'https'}.",
            "        \"\"\"",
            "        from twisted.internet.endpoints import _WrapperEndpoint",
            "",
            "        endpoint = self.makeEndpoint()",
            "        self.assertIsInstance(endpoint, _WrapperEndpoint)",
            "        self.assertIsInstance(endpoint._wrappedEndpoint, HostnameEndpoint)",
            "",
            "    def test_hostArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a host is passed, the endpoint respects it.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint(host=b\"example.com\")",
            "        self.assertEqual(endpoint._wrappedEndpoint._hostStr, \"example.com\")",
            "",
            "    def test_portArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a port is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedPort = 4321",
            "        endpoint = self.makeEndpoint(port=expectedPort)",
            "        self.assertEqual(endpoint._wrappedEndpoint._port, expectedPort)",
            "",
            "    def test_contextFactoryType(self):",
            "        \"\"\"",
            "        L{Agent} wraps its connection creator creator and uses modern TLS APIs.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint()",
            "        contextFactory = endpoint._wrapperFactory(None)._connectionCreator",
            "        self.assertIsInstance(contextFactory, ClientTLSOptions)",
            "        self.assertEqual(contextFactory._hostname, \"example.com\")",
            "",
            "    def test_connectHTTPSCustomConnectionCreator(self):",
            "        \"\"\"",
            "        If a custom L{WebClientConnectionCreator}-like object is passed to",
            "        L{Agent.__init__} it will be used to determine the SSL parameters for",
            "        HTTPS requests.  When an HTTPS request is made, the hostname and port",
            "        number of the request URL will be passed to the connection creator's",
            "        C{creatorForNetloc} method.  The resulting context object will be used",
            "        to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = b\"example.org\"",
            "        expectedPort = 20443",
            "",
            "        class JustEnoughConnection:",
            "            handshakeStarted = False",
            "            connectState = False",
            "",
            "            def do_handshake(self):",
            "                \"\"\"",
            "                The handshake started.  Record that fact.",
            "                \"\"\"",
            "                self.handshakeStarted = True",
            "",
            "            def set_connect_state(self):",
            "                \"\"\"",
            "                The connection started.  Record that fact.",
            "                \"\"\"",
            "                self.connectState = True",
            "",
            "        contextArgs = []",
            "",
            "        @implementer(IOpenSSLClientConnectionCreator)",
            "        class JustEnoughCreator:",
            "            def __init__(self, hostname, port):",
            "                self.hostname = hostname",
            "                self.port = port",
            "",
            "            def clientConnectionForTLS(self, tlsProtocol):",
            "                \"\"\"",
            "                Implement L{IOpenSSLClientConnectionCreator}.",
            "",
            "                @param tlsProtocol: The TLS protocol.",
            "                @type tlsProtocol: L{TLSMemoryBIOProtocol}",
            "",
            "                @return: C{expectedConnection}",
            "                \"\"\"",
            "                contextArgs.append((tlsProtocol, self.hostname, self.port))",
            "                return expectedConnection",
            "",
            "        expectedConnection = JustEnoughConnection()",
            "",
            "        @implementer(IPolicyForHTTPS)",
            "        class StubBrowserLikePolicyForHTTPS:",
            "            def creatorForNetloc(self, hostname, port):",
            "                \"\"\"",
            "                Emulate L{BrowserLikePolicyForHTTPS}.",
            "",
            "                @param hostname: The hostname to verify.",
            "                @type hostname: L{bytes}",
            "",
            "                @param port: The port number.",
            "                @type port: L{int}",
            "",
            "                @return: a stub L{IOpenSSLClientConnectionCreator}",
            "                @rtype: L{JustEnoughCreator}",
            "                \"\"\"",
            "                return JustEnoughCreator(hostname, port)",
            "",
            "        expectedCreatorCreator = StubBrowserLikePolicyForHTTPS()",
            "        reactor = self.createReactor()",
            "        agent = client.Agent(reactor, expectedCreatorCreator)",
            "        endpoint = agent._getEndpoint(",
            "            URI.fromBytes(b\"https://%b:%d\" % (expectedHost, expectedPort))",
            "        )",
            "        endpoint.connect(Factory.forProtocol(Protocol))",
            "        tlsFactory = reactor.tcpClients[-1][2]",
            "        tlsProtocol = tlsFactory.buildProtocol(None)",
            "        tlsProtocol.makeConnection(StringTransport())",
            "        tls = contextArgs[0][0]",
            "        self.assertIsInstance(tls, TLSMemoryBIOProtocol)",
            "        self.assertEqual(contextArgs[0][1:], (expectedHost, expectedPort))",
            "        self.assertTrue(expectedConnection.handshakeStarted)",
            "        self.assertTrue(expectedConnection.connectState)",
            "",
            "    def test_deprecatedDuckPolicy(self):",
            "        \"\"\"",
            "        Passing something that duck-types I{like} a L{web client context",
            "        factory <twisted.web.client.WebClientContextFactory>} - something that",
            "        does not provide L{IPolicyForHTTPS} - to L{Agent} emits a",
            "        L{DeprecationWarning} even if you don't actually C{import",
            "        WebClientContextFactory} to do it.",
            "        \"\"\"",
            "",
            "        def warnMe():",
            "            client.Agent(",
            "                deterministicResolvingReactor(MemoryReactorClock()),",
            "                \"does-not-provide-IPolicyForHTTPS\",",
            "            )",
            "",
            "        warnMe()",
            "        warnings = self.flushWarnings([warnMe])",
            "        self.assertEqual(len(warnings), 1)",
            "        [warning] = warnings",
            "        self.assertEqual(warning[\"category\"], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning[\"message\"],",
            "            \"'does-not-provide-IPolicyForHTTPS' was passed as the HTTPS \"",
            "            \"policy for an Agent, but it does not provide IPolicyForHTTPS.  \"",
            "            \"Since Twisted 14.0, you must pass a provider of IPolicyForHTTPS.\",",
            "        )",
            "",
            "    def test_alternateTrustRoot(self):",
            "        \"\"\"",
            "        L{BrowserLikePolicyForHTTPS.creatorForNetloc} returns an",
            "        L{IOpenSSLClientConnectionCreator} provider which will add certificates",
            "        from the given trust root.",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        policy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        creator = policy.creatorForNetloc(b\"thingy\", 4321)",
            "        self.assertTrue(trustRoot.called)",
            "        connection = creator.clientConnectionForTLS(None)",
            "        self.assertIs(trustRoot.context, connection.get_context())",
            "",
            "    def integrationTest(self, hostName, expectedAddress, addressType):",
            "        \"\"\"",
            "        Wrap L{AgentTestsMixin.integrationTest} with TLS.",
            "        \"\"\"",
            "        certHostName = hostName.strip(b\"[]\")",
            "        authority, server = certificatesForAuthorityAndServer(",
            "            certHostName.decode(\"ascii\")",
            "        )",
            "",
            "        def tlsify(serverFactory):",
            "            return TLSMemoryBIOFactory(server.options(), False, serverFactory)",
            "",
            "        def tlsagent(reactor):",
            "            from zope.interface import implementer",
            "",
            "            from twisted.web.iweb import IPolicyForHTTPS",
            "",
            "            @implementer(IPolicyForHTTPS)",
            "            class Policy:",
            "                def creatorForNetloc(self, hostname, port):",
            "                    return optionsForClientTLS(",
            "                        hostname.decode(\"ascii\"), trustRoot=authority",
            "                    )",
            "",
            "            return client.Agent(reactor, contextFactory=Policy())",
            "",
            "        (",
            "            super().integrationTest(",
            "                hostName,",
            "                expectedAddress,",
            "                addressType,",
            "                serverWrapper=tlsify,",
            "                createAgent=tlsagent,",
            "                scheme=b\"https\",",
            "            )",
            "        )",
            "",
            "",
            "class WebClientContextFactoryTests(TestCase):",
            "    \"\"\"",
            "    Tests for the context factory wrapper for web clients",
            "    L{twisted.web.client.WebClientContextFactory}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Get WebClientContextFactory while quashing its deprecation warning.",
            "        \"\"\"",
            "        from twisted.web.client import WebClientContextFactory",
            "",
            "        self.warned = self.flushWarnings([WebClientContextFactoryTests.setUp])",
            "        self.webClientContextFactory = WebClientContextFactory",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        L{twisted.web.client.WebClientContextFactory} is deprecated.  Importing",
            "        it displays a warning.",
            "        \"\"\"",
            "        self.assertEqual(len(self.warned), 1)",
            "        [warning] = self.warned",
            "        self.assertEqual(warning[\"category\"], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning[\"message\"],",
            "            getDeprecationWarningString(",
            "                self.webClientContextFactory,",
            "                Version(\"Twisted\", 14, 0, 0),",
            "                replacement=BrowserLikePolicyForHTTPS,",
            "            )",
            "            # See https://twistedmatrix.com/trac/ticket/7242",
            "            .replace(\";\", \":\"),",
            "        )",
            "",
            "    @skipIf(sslPresent, \"SSL Present.\")",
            "    def test_missingSSL(self):",
            "        \"\"\"",
            "        If C{getContext} is called and SSL is not available, raise",
            "        L{NotImplementedError}.",
            "        \"\"\"",
            "        self.assertRaises(",
            "            NotImplementedError,",
            "            self.webClientContextFactory().getContext,",
            "            b\"example.com\",",
            "            443,",
            "        )",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_returnsContext(self):",
            "        \"\"\"",
            "        If SSL is present, C{getContext} returns a L{OpenSSL.SSL.Context}.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory().getContext(\"example.com\", 443)",
            "        self.assertIsInstance(ctx, ssl.SSL.Context)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_setsTrustRootOnContextToDefaultTrustRoot(self):",
            "        \"\"\"",
            "        The L{CertificateOptions} has C{trustRoot} set to the default trust",
            "        roots.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory()",
            "        certificateOptions = ctx._getCertificateOptions(\"example.com\", 443)",
            "        self.assertIsInstance(certificateOptions.trustRoot, ssl.OpenSSLDefaultPaths)",
            "",
            "",
            "class HTTPConnectionPoolRetryTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    L{client.HTTPConnectionPool}, by using",
            "    L{client._RetryingHTTP11ClientProtocol}, supports retrying requests done",
            "    against previously cached connections.",
            "    \"\"\"",
            "",
            "    def test_onlyRetryIdempotentMethods(self):",
            "        \"\"\"",
            "        Only GET, HEAD, OPTIONS, TRACE, DELETE methods cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"HEAD\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"OPTIONS\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"TRACE\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"DELETE\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"POST\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"MYMETHOD\", RequestNotSent(), None))",
            "        # This will be covered by a different ticket, since we need support",
            "        # for resettable body producers:",
            "        # self.assertTrue(connection._doRetry(\"PUT\", RequestNotSent(), None))",
            "",
            "    def test_onlyRetryIfNoResponseReceived(self):",
            "        \"\"\"",
            "        Only L{RequestNotSent}, L{RequestTransmissionFailed} and",
            "        L{ResponseNeverReceived} exceptions cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(",
            "            connection._shouldRetry(b\"GET\", RequestTransmissionFailed([]), None)",
            "        )",
            "        self.assertTrue(",
            "            connection._shouldRetry(b\"GET\", ResponseNeverReceived([]), None)",
            "        )",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", ResponseFailed([]), None))",
            "        self.assertFalse(",
            "            connection._shouldRetry(b\"GET\", ConnectionRefusedError(), None)",
            "        )",
            "",
            "    def test_dontRetryIfFailedDueToCancel(self):",
            "        \"\"\"",
            "        If a request failed due to the operation being cancelled,",
            "        C{_shouldRetry} returns C{False} to indicate the request should not be",
            "        retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        exception = ResponseNeverReceived([Failure(defer.CancelledError())])",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", exception, None))",
            "",
            "    def test_retryIfFailedDueToNonCancelException(self):",
            "        \"\"\"",
            "        If a request failed with L{ResponseNeverReceived} due to some",
            "        arbitrary exception, C{_shouldRetry} returns C{True} to indicate the",
            "        request should be retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(",
            "            connection._shouldRetry(",
            "                b\"GET\", ResponseNeverReceived([Failure(Exception())]), None",
            "            )",
            "        )",
            "",
            "    def test_wrappedOnPersistentReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a previously",
            "        cached connection, it will get wrapped in a",
            "        L{client._RetryingHTTP11ClientProtocol}.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection, client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_notWrappedOnNewReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a new",
            "        connection, it will be returned as is.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            # Don't want to use isinstance since potentially the wrapper might",
            "            # subclass it at some point:",
            "            self.assertIdentical(connection.__class__, HTTP11ClientProtocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def retryAttempt(self, willWeRetry):",
            "        \"\"\"",
            "        Fail a first request, possibly retrying depending on argument.",
            "        \"\"\"",
            "        protocols = []",
            "",
            "        def newProtocol():",
            "            protocol = StubHTTPProtocol()",
            "            protocols.append(protocol)",
            "            return defer.succeed(protocol)",
            "",
            "        bodyProducer = object()",
            "        request = client.Request(",
            "            b\"FOO\", b\"/\", client.Headers(), bodyProducer, persistent=True",
            "        )",
            "        newProtocol()",
            "        protocol = protocols[0]",
            "        retrier = client._RetryingHTTP11ClientProtocol(protocol, newProtocol)",
            "",
            "        def _shouldRetry(m, e, bp):",
            "            self.assertEqual(m, b\"FOO\")",
            "            self.assertIdentical(bp, bodyProducer)",
            "            self.assertIsInstance(e, (RequestNotSent, ResponseNeverReceived))",
            "            return willWeRetry",
            "",
            "        retrier._shouldRetry = _shouldRetry",
            "",
            "        d = retrier.request(request)",
            "",
            "        # So far, one request made:",
            "        self.assertEqual(len(protocols), 1)",
            "        self.assertEqual(len(protocols[0].requests), 1)",
            "",
            "        # Fail the first request:",
            "        protocol.requests[0][1].errback(RequestNotSent())",
            "        return d, protocols",
            "",
            "    def test_retryIfShouldRetryReturnsTrue(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} retries when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{True}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        # We retried!",
            "        self.assertEqual(len(protocols), 2)",
            "        response = object()",
            "        protocols[1].requests[0][1].callback(response)",
            "        return d.addCallback(self.assertIdentical, response)",
            "",
            "    def test_dontRetryIfShouldRetryReturnsFalse(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} does not retry when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{False}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(False)",
            "        # We did not retry:",
            "        self.assertEqual(len(protocols), 1)",
            "        return self.assertFailure(d, RequestNotSent)",
            "",
            "    def test_onlyRetryWithoutBody(self):",
            "        \"\"\"",
            "        L{_RetryingHTTP11ClientProtocol} only retries queries that don't have",
            "        a body.",
            "",
            "        This is an implementation restriction; if the restriction is fixed,",
            "        this test should be removed and PUT added to list of methods that",
            "        support retries.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", RequestNotSent(), object()))",
            "",
            "    def test_onlyRetryOnce(self):",
            "        \"\"\"",
            "        If a L{client._RetryingHTTP11ClientProtocol} fails more than once on",
            "        an idempotent query before a response is received, it will not retry.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        self.assertEqual(len(protocols), 2)",
            "        # Fail the second request too:",
            "        protocols[1].requests[0][1].errback(ResponseNeverReceived([]))",
            "        # We didn't retry again:",
            "        self.assertEqual(len(protocols), 2)",
            "        return self.assertFailure(d, ResponseNeverReceived)",
            "",
            "    def test_dontRetryIfRetryAutomaticallyFalse(self):",
            "        \"\"\"",
            "        If L{HTTPConnectionPool.retryAutomatically} is set to C{False}, don't",
            "        wrap connections with retrying logic.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        pool.retryAutomatically = False",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back unwrapped:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIdentical(connection, protocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_retryWithNewConnection(self):",
            "        \"\"\"",
            "        L{client.HTTPConnectionPool} creates",
            "        {client._RetryingHTTP11ClientProtocol} with a new connection factory",
            "        method that creates a new connection using the same key and endpoint",
            "        as the wrapped connection.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        key = 123",
            "        endpoint = DummyEndpoint()",
            "        newConnections = []",
            "",
            "        # Override the pool's _newConnection:",
            "        def newConnection(k, e):",
            "            newConnections.append((k, e))",
            "",
            "        pool._newConnection = newConnection",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(key, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(key, endpoint)",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection, client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "            # Verify that the _newConnection method on retrying connection",
            "            # calls _newConnection on the pool:",
            "            self.assertEqual(newConnections, [])",
            "            connection._newConnection()",
            "            self.assertEqual(len(newConnections), 1)",
            "            self.assertEqual(newConnections[0][0], key)",
            "            self.assertIdentical(newConnections[0][1], endpoint)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "class CookieTestsMixin:",
            "    \"\"\"",
            "    Mixin for unit tests dealing with cookies.",
            "    \"\"\"",
            "",
            "    def addCookies(self, cookieJar, uri, cookies):",
            "        \"\"\"",
            "        Add a cookie to a cookie jar.",
            "        \"\"\"",
            "        response = client._FakeUrllib2Response(",
            "            client.Response(",
            "                (b\"HTTP\", 1, 1),",
            "                200,",
            "                b\"OK\",",
            "                client.Headers({b\"Set-Cookie\": cookies}),",
            "                None,",
            "            )",
            "        )",
            "        request = client._FakeUrllib2Request(uri)",
            "        cookieJar.extract_cookies(response, request)",
            "        return request, response",
            "",
            "",
            "class CookieJarTests(TestCase, CookieTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client._FakeUrllib2Response} and",
            "    L{twisted.web.client._FakeUrllib2Request}'s interactions with",
            "    L{CookieJar} instances.",
            "    \"\"\"",
            "",
            "    def makeCookieJar(self):",
            "        \"\"\"",
            "        @return: a L{CookieJar} with some sample cookies",
            "        \"\"\"",
            "        cookieJar = CookieJar()",
            "        reqres = self.addCookies(",
            "            cookieJar,",
            "            b\"http://example.com:1234/foo?bar\",",
            "            [b\"foo=1; cow=moo; Path=/foo; Comment=hello\", b\"bar=2; Comment=goodbye\"],",
            "        )",
            "        return cookieJar, reqres",
            "",
            "    def test_extractCookies(self):",
            "        \"\"\"",
            "        L{CookieJar.extract_cookies} extracts cookie information from",
            "        fake urllib2 response instances.",
            "        \"\"\"",
            "        jar = self.makeCookieJar()[0]",
            "        cookies = {c.name: c for c in jar}",
            "",
            "        cookie = cookies[\"foo\"]",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, \"foo\")",
            "        self.assertEqual(cookie.value, \"1\")",
            "        self.assertEqual(cookie.path, \"/foo\")",
            "        self.assertEqual(cookie.comment, \"hello\")",
            "        self.assertEqual(cookie.get_nonstandard_attr(\"cow\"), \"moo\")",
            "",
            "        cookie = cookies[\"bar\"]",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, \"bar\")",
            "        self.assertEqual(cookie.value, \"2\")",
            "        self.assertEqual(cookie.path, \"/\")",
            "        self.assertEqual(cookie.comment, \"goodbye\")",
            "        self.assertIdentical(cookie.get_nonstandard_attr(\"cow\"), None)",
            "",
            "    def test_sendCookie(self):",
            "        \"\"\"",
            "        L{CookieJar.add_cookie_header} adds a cookie header to a fake",
            "        urllib2 request instance.",
            "        \"\"\"",
            "        jar, (request, response) = self.makeCookieJar()",
            "",
            "        self.assertIdentical(request.get_header(\"Cookie\", None), None)",
            "",
            "        jar.add_cookie_header(request)",
            "        self.assertEqual(request.get_header(\"Cookie\", None), \"foo=1; bar=2\")",
            "",
            "",
            "class CookieAgentTests(",
            "    TestCase, CookieTestsMixin, FakeReactorAndConnectMixin, AgentTestsMixin",
            "):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client.CookieAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.CookieAgent}",
            "        \"\"\"",
            "        return client.CookieAgent(",
            "            self.buildAgentForWrapperTest(self.reactor), CookieJar()",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "",
            "    def test_emptyCookieJarRequest(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} does not insert any C{'Cookie'} header into the",
            "        L{Request} object if there is no cookie in the cookie jar for the URI",
            "        being requested. Cookies are extracted from the response and stored in",
            "        the cookie jar.",
            "        \"\"\"",
            "        cookieJar = CookieJar()",
            "        self.assertEqual(list(cookieJar), [])",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        d = cookieAgent.request(b\"GET\", b\"http://example.com:1234/foo?bar\")",
            "",
            "        def _checkCookie(ignored):",
            "            cookies = list(cookieJar)",
            "            self.assertEqual(len(cookies), 1)",
            "            self.assertEqual(cookies[0].name, \"foo\")",
            "            self.assertEqual(cookies[0].value, \"1\")",
            "",
            "        d.addCallback(_checkCookie)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(req.headers.getRawHeaders(b\"cookie\"), None)",
            "",
            "        resp = client.Response(",
            "            (b\"HTTP\", 1, 1),",
            "            200,",
            "            b\"OK\",",
            "            client.Headers(",
            "                {",
            "                    b\"Set-Cookie\": [",
            "                        b\"foo=1\",",
            "                    ]",
            "                }",
            "            ),",
            "            None,",
            "        )",
            "        res.callback(resp)",
            "",
            "        return d",
            "",
            "    def test_requestWithCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} inserts a C{'Cookie'} header into the L{Request}",
            "        object when there is a cookie matching the request URI in the cookie",
            "        jar.",
            "        \"\"\"",
            "        uri = b\"http://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [cookie])",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_secureCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} is able to handle secure cookies, ie cookies which",
            "        should only be handled over https.",
            "        \"\"\"",
            "        uri = b\"https://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1;secure\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [b\"foo=1\"])",
            "",
            "    def test_secureCookieOnInsecureConnection(self):",
            "        \"\"\"",
            "        If a cookie is setup as secure, it won't be sent with the request if",
            "        it's not over HTTPS.",
            "        \"\"\"",
            "        uri = b\"http://example.com/foo?bar\"",
            "        cookie = b\"foo=1;secure\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(None, req.headers.getRawHeaders(b\"cookie\"))",
            "",
            "    def test_portCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} supports cookies which enforces the port number they",
            "        need to be transferred upon.",
            "        \"\"\"",
            "        uri = b\"http://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1;port=1234\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [b\"foo=1\"])",
            "",
            "    def test_portCookieOnWrongPort(self):",
            "        \"\"\"",
            "        When creating a cookie with a port directive, it won't be added to the",
            "        L{cookie.CookieJar} if the URI is on a different port.",
            "        \"\"\"",
            "        uri = b\"http://example.com:4567/foo?bar\"",
            "        cookie = b\"foo=1;port=1234\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 0)",
            "",
            "",
            "class Decoder1(proxyForInterface(IResponse)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "class Decoder2(Decoder1):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "class ContentDecoderAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ContentDecoderAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ContentDecoderAgent}",
            "        \"\"\"",
            "        return client.ContentDecoderAgent(self.agent, [])",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.buildAgentForWrapperTest(self.reactor)",
            "",
            "    def test_acceptHeaders(self):",
            "        \"\"\"",
            "        L{client.ContentDecoderAgent} sets the I{Accept-Encoding} header to the",
            "        names of the available decoder objects.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "",
            "        agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            req.headers.getRawHeaders(b\"accept-encoding\"), [b\"decoder1,decoder2\"]",
            "        )",
            "",
            "    def test_existingHeaders(self):",
            "        \"\"\"",
            "        If there are existing I{Accept-Encoding} fields,",
            "        L{client.ContentDecoderAgent} creates a new field for the decoders it",
            "        knows about.",
            "        \"\"\"",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"accept-encoding\": [b\"fizz\"]}",
            "        )",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        agent.request(b\"GET\", b\"http://example.com/foo\", headers=headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            list(sorted(req.headers.getAllRawHeaders())),",
            "            [",
            "                (b\"Accept-Encoding\", [b\"fizz\", b\"decoder1,decoder2\"]),",
            "                (b\"Foo\", [b\"bar\"]),",
            "                (b\"Host\", [b\"example.com\"]),",
            "            ],",
            "        )",
            "",
            "    def test_plainEncodingResponse(self):",
            "        \"\"\"",
            "        If the response is not encoded despited the request I{Accept-Encoding}",
            "        headers, L{client.ContentDecoderAgent} simply forwards the response.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", http_headers.Headers(), None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "    def test_unsupportedEncoding(self):",
            "        \"\"\"",
            "        If an encoding unknown to the L{client.ContentDecoderAgent} is found,",
            "        the response is unchanged.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"fizz\"]}",
            "        )",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "    def test_unknownEncoding(self):",
            "        \"\"\"",
            "        When L{client.ContentDecoderAgent} encounters a decoder it doesn't know",
            "        about, it stops decoding even if another encoding is known afterwards.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"decoder1,fizz,decoder2\"]}",
            "        )",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        def check(result):",
            "            self.assertNotIdentical(response, result)",
            "            self.assertIsInstance(result, Decoder2)",
            "            self.assertEqual(",
            "                [b\"decoder1,fizz\"], result.headers.getRawHeaders(b\"content-encoding\")",
            "            )",
            "",
            "        return deferred.addCallback(check)",
            "",
            "",
            "class SimpleAgentProtocol(Protocol):",
            "    \"\"\"",
            "    A L{Protocol} to be used with an L{client.Agent} to receive data.",
            "",
            "    @ivar finished: L{Deferred} firing when C{connectionLost} is called.",
            "",
            "    @ivar made: L{Deferred} firing when C{connectionMade} is called.",
            "",
            "    @ivar received: C{list} of received data.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.made = Deferred()",
            "        self.finished = Deferred()",
            "        self.received = []",
            "",
            "    def connectionMade(self):",
            "        self.made.callback(None)",
            "",
            "    def connectionLost(self, reason):",
            "        self.finished.callback(None)",
            "",
            "    def dataReceived(self, data):",
            "        self.received.append(data)",
            "",
            "",
            "class ContentDecoderAgentWithGzipTests(TestCase, FakeReactorAndConnectMixin):",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        self.agent = client.ContentDecoderAgent(agent, [(b\"gzip\", client.GzipDecoder)])",
            "",
            "    def test_gzipEncodingResponse(self):",
            "        \"\"\"",
            "        If the response has a C{gzip} I{Content-Encoding} header,",
            "        L{GzipDecoder} wraps the response to return uncompressed data to the",
            "        user.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"gzip\"]}",
            "        )",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        compressor = zlib.compressobj(2, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "        data = (",
            "            compressor.compress(b\"x\" * 6)",
            "            + compressor.compress(b\"y\" * 4)",
            "            + compressor.flush()",
            "        )",
            "",
            "        def checkResponse(result):",
            "            self.assertNotIdentical(result, response)",
            "            self.assertEqual(result.version, (b\"HTTP\", 1, 1))",
            "            self.assertEqual(result.code, 200)",
            "            self.assertEqual(result.phrase, b\"OK\")",
            "            self.assertEqual(",
            "                list(result.headers.getAllRawHeaders()), [(b\"Foo\", [b\"bar\"])]",
            "            )",
            "            self.assertEqual(result.length, UNKNOWN_LENGTH)",
            "            self.assertRaises(AttributeError, getattr, result, \"unknown\")",
            "",
            "            response._bodyDataReceived(data[:5])",
            "            response._bodyDataReceived(data[5:])",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\" * 6 + b\"y\" * 4])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "    def test_brokenContent(self):",
            "        \"\"\"",
            "        If the data received by the L{GzipDecoder} isn't valid gzip-compressed",
            "        data, the call to C{deliverBody} fails with a C{zlib.error}.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"gzip\"]}",
            "        )",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        data = b\"not gzipped content\"",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(data)",
            "",
            "            result.deliverBody(Protocol())",
            "",
            "        deferred.addCallback(checkResponse)",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[0].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "    def test_flushData(self):",
            "        \"\"\"",
            "        When the connection with the server is lost, the gzip protocol calls",
            "        C{flush} on the zlib decompressor object to get uncompressed data which",
            "        may have been buffered.",
            "        \"\"\"",
            "",
            "        class decompressobj:",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return b\"x\"",
            "",
            "            def flush(self):",
            "                return b\"y\"",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, \"decompressobj\", oldDecompressObj)",
            "",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"content-encoding\": [b\"gzip\"]})",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(b\"data\")",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\", b\"y\"])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "    def test_flushError(self):",
            "        \"\"\"",
            "        If the C{flush} call in C{connectionLost} fails, the C{zlib.error}",
            "        exception is caught and turned into a L{ResponseFailed}.",
            "        \"\"\"",
            "",
            "        class decompressobj:",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return b\"x\"",
            "",
            "            def flush(self):",
            "                raise zlib.error()",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, \"decompressobj\", oldDecompressObj)",
            "",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"content-encoding\": [b\"gzip\"]})",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(b\"data\")",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\", b\"y\"])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[1].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "class ProxyAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ProxyAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ProxyAgent}",
            "        \"\"\"",
            "        return client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"127.0.0.1\", 1234), self.reactor",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"bar\", 5678), self.reactor",
            "        )",
            "        oldEndpoint = self.agent._proxyEndpoint",
            "        self.agent._proxyEndpoint = self.StubEndpoint(oldEndpoint, self)",
            "",
            "    def test_nonBytesMethod(self):",
            "        \"\"\"",
            "        L{ProxyAgent.request} raises L{TypeError} when the C{method} argument",
            "        isn't L{bytes}.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, self.agent.request, \"GET\", b\"http://foo.example/\")",
            "",
            "    def test_proxyRequest(self):",
            "        \"\"\"",
            "        L{client.ProxyAgent} issues an HTTP request against the proxy, with the",
            "        full URI as path, when C{request} is called.",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"]})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(b\"GET\", b\"http://example.com:1234/foo?bar\", headers, body)",
            "",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        self.assertEqual(host, \"bar\")",
            "        self.assertEqual(port, 5678)",
            "",
            "        self.assertIsInstance(factory._wrappedFactory, client._HTTP11ClientFactory)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, b\"GET\")",
            "        self.assertEqual(req.uri, b\"http://example.com:1234/foo?bar\")",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"example.com:1234\"]}),",
            "        )",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        C{ProxyAgent} connections are not persistent by default.",
            "        \"\"\"",
            "        self.assertEqual(self.agent._pool.persistent, False)",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the C{ProxyAgent}, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint it was constructed",
            "        with and a key of C{(\"http-proxy\", endpoint)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "",
            "        class DummyPool:",
            "            connected = False",
            "            persistent = False",
            "",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertIdentical(ep, endpoint)",
            "                # The key is *not* tied to the final destination, but only to",
            "                # the address of the proxy, since that's where *we* are",
            "                # connecting:",
            "                self.assertEqual(key, (\"http-proxy\", endpoint))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = client.ProxyAgent(endpoint, self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "class _RedirectAgentTestsMixin:",
            "    \"\"\"",
            "    Test cases mixin for L{RedirectAgentTests} and",
            "    L{BrowserLikeRedirectAgentTests}.",
            "    \"\"\"",
            "",
            "    def test_noRedirect(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} behaves like L{client.Agent} if the response",
            "        doesn't contain a redirect.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        self.assertEqual(0, len(self.protocol.requests))",
            "        result = self.successResultOf(deferred)",
            "        self.assertIdentical(response, result)",
            "        self.assertIdentical(result.previousResponse, None)",
            "",
            "    def _testRedirectDefault(self, code):",
            "        \"\"\"",
            "        When getting a redirect, L{client.RedirectAgent} follows the URL",
            "        specified in the L{Location} header field and make a new request.",
            "",
            "        @param code: HTTP status code.",
            "        \"\"\"",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(EXAMPLE_COM_IP, host)",
            "        self.assertEqual(80, port)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        # If possible (i.e.: SSL support is present), run the test with a",
            "        # cross-scheme redirect to verify that the scheme is honored; if not,",
            "        # let's just make sure it works at all.",
            "        if ssl is None:",
            "            scheme = b\"http\"",
            "            expectedPort = 80",
            "        else:",
            "            scheme = b\"https\"",
            "            expectedPort = 443",
            "",
            "        headers = http_headers.Headers({b\"location\": [scheme + b\"://example.com/bar\"]})",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(b\"/bar\", req2.uri)",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(EXAMPLE_COM_IP, host)",
            "        self.assertEqual(expectedPort, port)",
            "",
            "    def test_redirect301(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 301.",
            "        \"\"\"",
            "        self._testRedirectDefault(301)",
            "",
            "    def test_redirect302(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 302.",
            "        \"\"\"",
            "        self._testRedirectDefault(302)",
            "",
            "    def test_redirect307(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 307.",
            "        \"\"\"",
            "        self._testRedirectDefault(307)",
            "",
            "    def test_redirect308(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 308.",
            "        \"\"\"",
            "        self._testRedirectDefault(308)",
            "",
            "    def _testRedirectToGet(self, code, method):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting",
            "        a redirect on a non-I{GET} request.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        self.agent.request(method, b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(b\"/bar\", req2.uri)",
            "",
            "    def test_redirect303(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting a 303",
            "        redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(303, b\"POST\")",
            "",
            "    def test_noLocationField(self):",
            "        \"\"\"",
            "        If no L{Location} header field is found when getting a redirect,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping a",
            "        L{error.RedirectWithNoLocation} exception.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), 301, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.RedirectWithNoLocation)",
            "        self.assertEqual(b\"http://example.com/foo\", fail.value.reasons[0].value.uri)",
            "        self.assertEqual(301, fail.value.response.code)",
            "",
            "    def _testPageRedirectFailure(self, code, method):",
            "        \"\"\"",
            "        When getting a redirect on an unsupported request method,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        deferred = self.agent.request(method, b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.PageRedirect)",
            "        self.assertEqual(",
            "            b\"http://example.com/foo\", fail.value.reasons[0].value.location",
            "        )",
            "        self.assertEqual(code, fail.value.response.code)",
            "",
            "    def test_307OnPost(self):",
            "        \"\"\"",
            "        When getting a 307 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(307, b\"POST\")",
            "",
            "    def test_redirectLimit(self):",
            "        \"\"\"",
            "        If the limit of redirects specified to L{client.RedirectAgent} is",
            "        reached, the deferred fires with L{ResponseFailed} error wrapping",
            "        a L{InfiniteRedirection} exception.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent, 1)",
            "",
            "        deferred = redirectAgent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        response = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "",
            "        response2 = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res2.callback(response2)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "",
            "        fail.value.reasons[0].trap(error.InfiniteRedirection)",
            "        self.assertEqual(",
            "            b\"http://example.com/foo\", fail.value.reasons[0].value.location",
            "        )",
            "        self.assertEqual(302, fail.value.response.code)",
            "",
            "    def _testRedirectURI(self, uri, location, finalURI):",
            "        \"\"\"",
            "        When L{client.RedirectAgent} encounters a relative redirect I{URI}, it",
            "        is resolved against the request I{URI} before following the redirect.",
            "",
            "        @param uri: Request URI.",
            "",
            "        @param location: I{Location} header redirect URI.",
            "",
            "        @param finalURI: Expected final URI.",
            "        \"\"\"",
            "        self.agent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [location]})",
            "        response = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(finalURI, req2.absoluteURI)",
            "",
            "    def test_relativeURI(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving query strings.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"baz\", b\"http://example.com/foo/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"/baz\", b\"http://example.com/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"/baz?a\", b\"http://example.com/baz?a\"",
            "        )",
            "",
            "    def test_relativeURIPreserveFragments(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving fragments in way that complies with the HTTP 1.1",
            "        bis draft.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar#frag\",",
            "            b\"/baz?a\",",
            "            b\"http://example.com/baz?a#frag\",",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\",",
            "            b\"/baz?a#frag2\",",
            "            b\"http://example.com/baz?a#frag2\",",
            "        )",
            "",
            "    def test_relativeURISchemeRelative(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows scheme relative I{URI}s in",
            "        redirects, replacing the hostname and port when required.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"//foo.com/baz\", b\"http://foo.com/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"//foo.com:81/baz\", b\"http://foo.com:81/baz\"",
            "        )",
            "",
            "    def test_responseHistory(self):",
            "        \"\"\"",
            "        L{Response.response} references the previous L{Response} from",
            "        a redirect, or L{None} if there was no previous response.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent)",
            "",
            "        deferred = redirectAgent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        redirectReq, redirectRes = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        redirectResponse = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        redirectRes.callback(redirectResponse)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        finalResponse = self.successResultOf(deferred)",
            "        self.assertIdentical(finalResponse.previousResponse, redirectResponse)",
            "        self.assertIdentical(redirectResponse.previousResponse, None)",
            "",
            "",
            "class RedirectAgentTests(",
            "    TestCase, FakeReactorAndConnectMixin, _RedirectAgentTestsMixin, AgentTestsMixin",
            "):",
            "    \"\"\"",
            "    Tests for L{client.RedirectAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.RedirectAgent}",
            "        \"\"\"",
            "        return client.RedirectAgent(self.buildAgentForWrapperTest(self.reactor))",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_301OnPost(self):",
            "        \"\"\"",
            "        When getting a 301 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(301, b\"POST\")",
            "",
            "    def test_302OnPost(self):",
            "        \"\"\"",
            "        When getting a 302 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(302, b\"POST\")",
            "",
            "",
            "class BrowserLikeRedirectAgentTests(",
            "    TestCase, FakeReactorAndConnectMixin, _RedirectAgentTestsMixin, AgentTestsMixin",
            "):",
            "    \"\"\"",
            "    Tests for L{client.BrowserLikeRedirectAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.BrowserLikeRedirectAgent}",
            "        \"\"\"",
            "        return client.BrowserLikeRedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor)",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_redirectToGet301(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(301, b\"POST\")",
            "",
            "    def test_redirectToGet302(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(302, b\"POST\")",
            "",
            "",
            "class AbortableStringTransport(StringTransport):",
            "    \"\"\"",
            "    A version of L{StringTransport} that supports C{abortConnection}.",
            "    \"\"\"",
            "",
            "    # This should be replaced by a common version in #6530.",
            "    aborting = False",
            "",
            "    def abortConnection(self):",
            "        \"\"\"",
            "        A testable version of the C{ITCPTransport.abortConnection} method.",
            "",
            "        Since this is a special case of closing the connection,",
            "        C{loseConnection} is also called.",
            "        \"\"\"",
            "        self.aborting = True",
            "        self.loseConnection()",
            "",
            "",
            "class DummyResponse:",
            "    \"\"\"",
            "    Fake L{IResponse} for testing readBody that captures the protocol passed to",
            "    deliverBody and uses it to make a connection with a transport.",
            "",
            "    @ivar protocol: After C{deliverBody} is called, the protocol it was called",
            "        with.",
            "",
            "    @ivar transport: An instance created by calling C{transportFactory} which",
            "        is used by L{DummyResponse.protocol} to make a connection.",
            "    \"\"\"",
            "",
            "    code = 200",
            "    phrase = b\"OK\"",
            "",
            "    def __init__(self, headers=None, transportFactory=AbortableStringTransport):",
            "        \"\"\"",
            "        @param headers: The headers for this response.  If L{None}, an empty",
            "            L{Headers} instance will be used.",
            "        @type headers: L{Headers}",
            "",
            "        @param transportFactory: A callable used to construct the transport.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        self.headers = headers",
            "        self.transport = transportFactory()",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Record the given protocol and use it to make a connection with",
            "        L{DummyResponse.transport}.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "        self.protocol.makeConnection(self.transport)",
            "",
            "",
            "class AlreadyCompletedDummyResponse(DummyResponse):",
            "    \"\"\"",
            "    A dummy response that has already had its transport closed.",
            "    \"\"\"",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Make the connection, then remove the transport.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "        self.protocol.makeConnection(self.transport)",
            "        self.protocol.transport = None",
            "",
            "",
            "class ReadBodyTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{client.readBody}",
            "    \"\"\"",
            "",
            "    def test_success(self):",
            "        \"\"\"",
            "        L{client.readBody} returns a L{Deferred} which fires with the complete",
            "        body of the L{IResponse} provider passed to it.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.dataReceived(b\"second\")",
            "        response.protocol.connectionLost(Failure(ResponseDone()))",
            "        self.assertEqual(self.successResultOf(d), b\"firstsecond\")",
            "",
            "    def test_cancel(self):",
            "        \"\"\"",
            "        When cancelling the L{Deferred} returned by L{client.readBody}, the",
            "        connection to the server will be aborted.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        deferred = client.readBody(response)",
            "        deferred.cancel()",
            "        self.failureResultOf(deferred, defer.CancelledError)",
            "        self.assertTrue(response.transport.aborting)",
            "",
            "    def test_withPotentialDataLoss(self):",
            "        \"\"\"",
            "        If the full body of the L{IResponse} passed to L{client.readBody} is",
            "        not definitely received, the L{Deferred} returned by L{client.readBody}",
            "        fires with a L{Failure} wrapping L{client.PartialDownloadError} with",
            "        the content that was received.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.dataReceived(b\"second\")",
            "        response.protocol.connectionLost(Failure(PotentialDataLoss()))",
            "        failure = self.failureResultOf(d)",
            "        failure.trap(client.PartialDownloadError)",
            "        self.assertEqual(",
            "            {",
            "                \"status\": failure.value.status,",
            "                \"message\": failure.value.message,",
            "                \"body\": failure.value.response,",
            "            },",
            "            {",
            "                \"status\": b\"200\",",
            "                \"message\": b\"OK\",",
            "                \"body\": b\"firstsecond\",",
            "            },",
            "        )",
            "",
            "    def test_otherErrors(self):",
            "        \"\"\"",
            "        If there is an exception other than L{client.PotentialDataLoss} while",
            "        L{client.readBody} is collecting the response body, the L{Deferred}",
            "        returned by {client.readBody} fires with that exception.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.connectionLost(Failure(ConnectionLost(\"mystery problem\")))",
            "        reason = self.failureResultOf(d)",
            "        reason.trap(ConnectionLost)",
            "        self.assertEqual(reason.value.args, (\"mystery problem\",))",
            "",
            "    def test_deprecatedTransport(self):",
            "        \"\"\"",
            "        Calling L{client.readBody} with a transport that does not implement",
            "        L{twisted.internet.interfaces.ITCPTransport} produces a deprecation",
            "        warning, but no exception when cancelling.",
            "        \"\"\"",
            "        response = DummyResponse(transportFactory=StringTransport)",
            "        response.transport.abortConnection = None",
            "        d = self.assertWarns(",
            "            DeprecationWarning,",
            "            \"Using readBody with a transport that does not have an \"",
            "            \"abortConnection method\",",
            "            __file__,",
            "            lambda: client.readBody(response),",
            "        )",
            "        d.cancel()",
            "        self.failureResultOf(d, defer.CancelledError)",
            "",
            "    def test_deprecatedTransportNoWarning(self):",
            "        \"\"\"",
            "        Calling L{client.readBody} with a response that has already had its",
            "        transport closed (eg. for a very small request) will not trigger a",
            "        deprecation warning.",
            "        \"\"\"",
            "        response = AlreadyCompletedDummyResponse()",
            "        client.readBody(response)",
            "",
            "        warnings = self.flushWarnings()",
            "        self.assertEqual(len(warnings), 0)",
            "",
            "",
            "@skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "class HostnameCachingHTTPSPolicyTests(TestCase):",
            "    def test_cacheIsUsed(self):",
            "        \"\"\"",
            "        Verify that the connection creator is added to the",
            "        policy's cache, and that it is reused on subsequent calls",
            "        to creatorForNetLoc.",
            "",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy)",
            "        creator = policy.creatorForNetloc(b\"foo\", 1589)",
            "        self.assertTrue(trustRoot.called)",
            "        trustRoot.called = False",
            "        self.assertEquals(1, len(policy._cache))",
            "        connection = creator.clientConnectionForTLS(None)",
            "        self.assertIs(trustRoot.context, connection.get_context())",
            "",
            "        policy.creatorForNetloc(b\"foo\", 1589)",
            "        self.assertFalse(trustRoot.called)",
            "",
            "    def test_cacheRemovesOldest(self):",
            "        \"\"\"",
            "        Verify that when the cache is full, and a new entry is added,",
            "        the oldest entry is removed.",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy)",
            "        for i in range(0, 20):",
            "            hostname = \"host\" + str(i)",
            "            policy.creatorForNetloc(hostname.encode(\"ascii\"), 8675)",
            "",
            "        # Force host0, which was the first, to be the most recently used",
            "        host0 = \"host0\"",
            "        policy.creatorForNetloc(host0.encode(\"ascii\"), 309)",
            "        self.assertIn(host0, policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        hostn = \"new\"",
            "        policy.creatorForNetloc(hostn.encode(\"ascii\"), 309)",
            "",
            "        host1 = \"host1\"",
            "        self.assertNotIn(host1, policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        self.assertIn(hostn, policy._cache)",
            "        self.assertIn(host0, policy._cache)",
            "",
            "        # Accessing an item repeatedly does not corrupt the LRU.",
            "        for _ in range(20):",
            "            policy.creatorForNetloc(host0.encode(\"ascii\"), 8675)",
            "",
            "        hostNPlus1 = \"new1\"",
            "",
            "        policy.creatorForNetloc(hostNPlus1.encode(\"ascii\"), 800)",
            "",
            "        self.assertNotIn(\"host2\", policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        self.assertIn(hostNPlus1, policy._cache)",
            "        self.assertIn(hostn, policy._cache)",
            "        self.assertIn(host0, policy._cache)",
            "",
            "    def test_changeCacheSize(self):",
            "        \"\"\"",
            "        Verify that changing the cache size results in a policy that",
            "        respects the new cache size and not the default.",
            "",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy, cacheSize=5)",
            "        for i in range(0, 5):",
            "            hostname = \"host\" + str(i)",
            "            policy.creatorForNetloc(hostname.encode(\"ascii\"), 8675)",
            "",
            "        first = \"host0\"",
            "        self.assertIn(first, policy._cache)",
            "        self.assertEquals(5, len(policy._cache))",
            "",
            "        hostn = \"new\"",
            "        policy.creatorForNetloc(hostn.encode(\"ascii\"), 309)",
            "        self.assertNotIn(first, policy._cache)",
            "        self.assertEquals(5, len(policy._cache))",
            "",
            "        self.assertIn(hostn, policy._cache)",
            "",
            "",
            "class RequestMethodInjectionTests(",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        client.Request(",
            "            method=method,",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=http_headers.Headers(),",
            "            bodyProducer=None,",
            "        )",
            "",
            "",
            "class RequestWriteToMethodInjectionTests(",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request.writeTo} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"Host\": [b\"twisted.invalid\"]})",
            "        req = client.Request(",
            "            method=b\"GET\",",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=headers,",
            "            bodyProducer=None,",
            "        )",
            "        req.method = method",
            "        req.writeTo(StringTransport())",
            "",
            "",
            "class RequestURIInjectionTests(",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request} against HTTP URI injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided URI.",
            "",
            "        @param method: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        client.Request(",
            "            method=b\"GET\",",
            "            uri=uri,",
            "            headers=http_headers.Headers(),",
            "            bodyProducer=None,",
            "        )",
            "",
            "",
            "class RequestWriteToURIInjectionTests(",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request.writeTo} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"Host\": [b\"twisted.invalid\"]})",
            "        req = client.Request(",
            "            method=b\"GET\",",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=headers,",
            "            bodyProducer=None,",
            "        )",
            "        req.uri = uri",
            "        req.writeTo(StringTransport())"
        ],
        "afterPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for L{twisted.web.client.Agent} and related new client APIs.",
            "\"\"\"",
            "",
            "import zlib",
            "from http.cookiejar import CookieJar",
            "from io import BytesIO",
            "from typing import TYPE_CHECKING, List, Optional, Tuple",
            "from unittest import SkipTest, skipIf",
            "",
            "from zope.interface.declarations import implementer",
            "from zope.interface.verify import verifyObject",
            "",
            "from incremental import Version",
            "",
            "from twisted.internet import defer, task",
            "from twisted.internet.address import IPv4Address, IPv6Address",
            "from twisted.internet.defer import CancelledError, Deferred, succeed",
            "from twisted.internet.endpoints import HostnameEndpoint, TCP4ClientEndpoint",
            "from twisted.internet.error import (",
            "    ConnectionDone,",
            "    ConnectionLost,",
            "    ConnectionRefusedError,",
            ")",
            "from twisted.internet.interfaces import IOpenSSLClientConnectionCreator",
            "from twisted.internet.protocol import Factory, Protocol",
            "from twisted.internet.task import Clock",
            "from twisted.internet.test.test_endpoints import deterministicResolvingReactor",
            "from twisted.logger import globalLogPublisher",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.deprecate import getDeprecationWarningString",
            "from twisted.python.failure import Failure",
            "from twisted.test.iosim import FakeTransport, IOPump",
            "from twisted.test.proto_helpers import (",
            "    AccumulatingProtocol,",
            "    EventLoggingObserver,",
            "    MemoryReactorClock,",
            "    StringTransport,",
            ")",
            "from twisted.test.test_sslverify import certificatesForAuthorityAndServer",
            "from twisted.trial.unittest import SynchronousTestCase, TestCase",
            "from twisted.web import client, error, http_headers",
            "from twisted.web._newclient import (",
            "    HTTP11ClientProtocol,",
            "    PotentialDataLoss,",
            "    RequestNotSent,",
            "    RequestTransmissionFailed,",
            "    Response,",
            "    ResponseFailed,",
            "    ResponseNeverReceived,",
            ")",
            "from twisted.web.client import (",
            "    URI,",
            "    BrowserLikePolicyForHTTPS,",
            "    FileBodyProducer,",
            "    HostnameCachingHTTPSPolicy,",
            "    HTTPConnectionPool,",
            "    Request,",
            "    ResponseDone,",
            "    _HTTP11ClientFactory,",
            ")",
            "from twisted.web.error import SchemeNotSupported",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IAgentEndpointFactory,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "from twisted.web.test.injectionhelpers import (",
            "    MethodInjectionTestsMixin,",
            "    URIInjectionTestsMixin,",
            ")",
            "",
            "# Creatively lie to mypy about the nature of inheritance, since dealing with",
            "# expectations of a mixin class is basically impossible (don't use mixins).",
            "if TYPE_CHECKING:",
            "    testMixinClass = TestCase",
            "    runtimeTestCase = object",
            "else:",
            "    testMixinClass = object",
            "    runtimeTestCase = TestCase",
            "",
            "try:",
            "    from twisted.internet import ssl as _ssl",
            "except ImportError:",
            "    ssl = None",
            "    sslPresent = False",
            "else:",
            "    ssl = _ssl",
            "    sslPresent = True",
            "    from twisted.internet._sslverify import ClientTLSOptions, IOpenSSLTrustRoot",
            "    from twisted.internet.ssl import optionsForClientTLS",
            "    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol",
            "",
            "    @implementer(IOpenSSLTrustRoot)",
            "    class CustomOpenSSLTrustRoot:",
            "        called = False",
            "        context = None",
            "",
            "        def _addCACertsToContext(self, context):",
            "            self.called = True",
            "            self.context = context",
            "",
            "",
            "class StubHTTPProtocol(Protocol):",
            "    \"\"\"",
            "    A protocol like L{HTTP11ClientProtocol} but which does not actually know",
            "    HTTP/1.1 and only collects requests in a list.",
            "",
            "    @ivar requests: A C{list} of two-tuples.  Each time a request is made, a",
            "        tuple consisting of the request and the L{Deferred} returned from the",
            "        request method is appended to this list.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        self.requests: List[Tuple[Request, Deferred[IResponse]]] = []",
            "        self.state = \"QUIESCENT\"",
            "",
            "    def request(self, request):",
            "        \"\"\"",
            "        Capture the given request for later inspection.",
            "",
            "        @return: A L{Deferred} which this code will never fire.",
            "        \"\"\"",
            "        result = Deferred()",
            "        self.requests.append((request, result))",
            "        return result",
            "",
            "",
            "class FileConsumer:",
            "    def __init__(self, outputFile):",
            "        self.outputFile = outputFile",
            "",
            "    def write(self, bytes):",
            "        self.outputFile.write(bytes)",
            "",
            "",
            "class FileBodyProducerTests(TestCase):",
            "    \"\"\"",
            "    Tests for the L{FileBodyProducer} which reads bytes from a file and writes",
            "    them to an L{IConsumer}.",
            "    \"\"\"",
            "",
            "    def _termination(self):",
            "        \"\"\"",
            "        This method can be used as the C{terminationPredicateFactory} for a",
            "        L{Cooperator}.  It returns a predicate which immediately returns",
            "        C{False}, indicating that no more work should be done this iteration.",
            "        This has the result of only allowing one iteration of a cooperative",
            "        task to be run per L{Cooperator} iteration.",
            "        \"\"\"",
            "        return lambda: True",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create a L{Cooperator} hooked up to an easily controlled, deterministic",
            "        scheduler to use with L{FileBodyProducer}.",
            "        \"\"\"",
            "        self._scheduled = []",
            "        self.cooperator = task.Cooperator(self._termination, self._scheduled.append)",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        L{FileBodyProducer} instances provide L{IBodyProducer}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IBodyProducer, FileBodyProducer(BytesIO(b\"\"))))",
            "",
            "    def test_unknownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object",
            "        without either a C{seek} or C{tell} method, its C{length} attribute is",
            "        set to C{UNKNOWN_LENGTH}.",
            "        \"\"\"",
            "",
            "        class HasSeek:",
            "            def seek(self, offset, whence):",
            "                pass",
            "",
            "        class HasTell:",
            "            def tell(self):",
            "                pass",
            "",
            "        producer = FileBodyProducer(HasSeek())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "        producer = FileBodyProducer(HasTell())",
            "        self.assertEqual(UNKNOWN_LENGTH, producer.length)",
            "",
            "    def test_knownLength(self):",
            "        \"\"\"",
            "        If the L{FileBodyProducer} is constructed with a file-like object with",
            "        both C{seek} and C{tell} methods, its C{length} attribute is set to the",
            "        size of the file as determined by those methods.",
            "        \"\"\"",
            "        inputBytes = b\"here are some bytes\"",
            "        inputFile = BytesIO(inputBytes)",
            "        inputFile.seek(5)",
            "        producer = FileBodyProducer(inputFile)",
            "        self.assertEqual(len(inputBytes) - 5, producer.length)",
            "        self.assertEqual(inputFile.tell(), 5)",
            "",
            "    def test_defaultCooperator(self):",
            "        \"\"\"",
            "        If no L{Cooperator} instance is passed to L{FileBodyProducer}, the",
            "        global cooperator is used.",
            "        \"\"\"",
            "        producer = FileBodyProducer(BytesIO(b\"\"))",
            "        self.assertEqual(task.cooperate, producer._cooperate)",
            "",
            "    def test_startProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.startProducing} starts writing bytes from the input",
            "        file to the given L{IConsumer} and returns a L{Deferred} which fires",
            "        when they have all been written.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        for i in range(len(expectedResult) // readSize + 1):",
            "            self._scheduled.pop(0)()",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertEqual(expectedResult, output.getvalue())",
            "        self.assertEqual(None, self.successResultOf(complete))",
            "",
            "    def test_inputClosedAtEOF(self):",
            "        \"\"\"",
            "        When L{FileBodyProducer} reaches end-of-file on the input file given to",
            "        it, the input file is closed.",
            "        \"\"\"",
            "        readSize = 4",
            "        inputBytes = b\"some friendly bytes\"",
            "        inputFile = BytesIO(inputBytes)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        consumer = FileConsumer(BytesIO())",
            "        producer.startProducing(consumer)",
            "        for i in range(len(inputBytes) // readSize + 2):",
            "            self._scheduled.pop(0)()",
            "        self.assertTrue(inputFile.closed)",
            "",
            "    def test_failedReadWhileProducing(self):",
            "        \"\"\"",
            "        If a read from the input file fails while producing bytes to the",
            "        consumer, the L{Deferred} returned by",
            "        L{FileBodyProducer.startProducing} fires with a L{Failure} wrapping",
            "        that exception.",
            "        \"\"\"",
            "",
            "        class BrokenFile:",
            "            def read(self, count):",
            "                raise OSError(\"Simulated bad thing\")",
            "",
            "        producer = FileBodyProducer(BrokenFile(), self.cooperator)",
            "        complete = producer.startProducing(FileConsumer(BytesIO()))",
            "        self._scheduled.pop(0)()",
            "        self.failureResultOf(complete).trap(IOError)",
            "",
            "    def test_cancelWhileProducing(self):",
            "        \"\"\"",
            "        When the L{Deferred} returned by L{FileBodyProducer.startProducing} is",
            "        cancelled, the input file is closed and the task is stopped.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        complete.cancel()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "    def test_stopProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} stops the underlying L{IPullProducer}",
            "        and the cooperative task responsible for calling C{resumeProducing} and",
            "        closes the input file but does not cause the L{Deferred} returned by",
            "        C{startProducing} to fire.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "    def test_pauseProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.pauseProducing} temporarily suspends writing bytes",
            "        from the input file to the given L{IConsumer}.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 5",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        producer.pauseProducing()",
            "",
            "        # Sort of depends on an implementation detail of Cooperator: even",
            "        # though the only task is paused, there's still a scheduled call.  If",
            "        # this were to go away because Cooperator became smart enough to cancel",
            "        # this call in this case, that would be fine.",
            "        self._scheduled.pop(0)()",
            "",
            "        # Since the producer is paused, no new data should be here.",
            "        self.assertEqual(output.getvalue(), expectedResult[:5])",
            "        self.assertEqual([], self._scheduled)",
            "        self.assertNoResult(complete)",
            "",
            "    def test_resumeProducing(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.resumeProducing} re-commences writing bytes from the",
            "        input file to the given L{IConsumer} after it was previously paused",
            "        with L{FileBodyProducer.pauseProducing}.",
            "        \"\"\"",
            "        expectedResult = b\"hello, world\"",
            "        readSize = 5",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        producer = FileBodyProducer(BytesIO(expectedResult), self.cooperator, readSize)",
            "        producer.startProducing(consumer)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[:readSize], output.getvalue())",
            "        producer.pauseProducing()",
            "        producer.resumeProducing()",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(expectedResult[: readSize * 2], output.getvalue())",
            "",
            "    def test_multipleStop(self):",
            "        \"\"\"",
            "        L{FileBodyProducer.stopProducing} can be called more than once without",
            "        raising an exception.",
            "        \"\"\"",
            "        expectedResult = b\"test\"",
            "        readSize = 3",
            "        output = BytesIO()",
            "        consumer = FileConsumer(output)",
            "        inputFile = BytesIO(expectedResult)",
            "        producer = FileBodyProducer(inputFile, self.cooperator, readSize)",
            "        complete = producer.startProducing(consumer)",
            "        producer.stopProducing()",
            "        producer.stopProducing()",
            "        self.assertTrue(inputFile.closed)",
            "        self._scheduled.pop(0)()",
            "        self.assertEqual(b\"\", output.getvalue())",
            "        self.assertNoResult(complete)",
            "",
            "",
            "EXAMPLE_COM_IP = \"127.0.0.7\"",
            "EXAMPLE_COM_V6_IP = \"::7\"",
            "EXAMPLE_NET_IP = \"127.0.0.8\"",
            "EXAMPLE_ORG_IP = \"127.0.0.9\"",
            "FOO_LOCAL_IP = \"127.0.0.10\"",
            "FOO_COM_IP = \"127.0.0.11\"",
            "",
            "",
            "class FakeReactorAndConnectMixin:",
            "    \"\"\"",
            "    A test mixin providing a testable C{Reactor} class and a dummy C{connect}",
            "    method which allows instances to pretend to be endpoints.",
            "    \"\"\"",
            "",
            "    def createReactor(self):",
            "        \"\"\"",
            "        Create a L{MemoryReactorClock} and give it some hostnames it can",
            "        resolve.",
            "",
            "        @return: a L{MemoryReactorClock}-like object with a slightly limited",
            "            interface (only C{advance} and C{tcpClients} in addition to its",
            "            formally-declared reactor interfaces), which can resolve a fixed",
            "            set of domains.",
            "        \"\"\"",
            "        mrc = MemoryReactorClock()",
            "        drr = deterministicResolvingReactor(",
            "            mrc,",
            "            hostMap={",
            "                \"example.com\": [EXAMPLE_COM_IP],",
            "                \"ipv6.example.com\": [EXAMPLE_COM_V6_IP],",
            "                \"example.net\": [EXAMPLE_NET_IP],",
            "                \"example.org\": [EXAMPLE_ORG_IP],",
            "                \"foo\": [FOO_LOCAL_IP],",
            "                \"foo.com\": [FOO_COM_IP],",
            "                \"127.0.0.7\": [\"127.0.0.7\"],",
            "                \"::7\": [\"::7\"],",
            "            },",
            "        )",
            "",
            "        # Lots of tests were written expecting MemoryReactorClock and the",
            "        # reactor seen by the SUT to be the same object.",
            "        drr.tcpClients = mrc.tcpClients",
            "        drr.advance = mrc.advance",
            "        return drr",
            "",
            "    class StubEndpoint:",
            "        \"\"\"",
            "        Endpoint that wraps existing endpoint, substitutes StubHTTPProtocol, and",
            "        resulting protocol instances are attached to the given test case.",
            "        \"\"\"",
            "",
            "        def __init__(self, endpoint, testCase):",
            "            self.endpoint = endpoint",
            "            self.testCase = testCase",
            "",
            "            def nothing():",
            "                \"\"\"this function does nothing\"\"\"",
            "",
            "            self.factory = _HTTP11ClientFactory(nothing, repr(self.endpoint))",
            "            self.protocol = StubHTTPProtocol()",
            "            self.factory.buildProtocol = lambda addr: self.protocol",
            "",
            "        def connect(self, ignoredFactory):",
            "            self.testCase.protocol = self.protocol",
            "            self.endpoint.connect(self.factory)",
            "            return succeed(self.protocol)",
            "",
            "    def buildAgentForWrapperTest(self, reactor):",
            "        \"\"\"",
            "        Return an Agent suitable for use in tests that wrap the Agent and want",
            "        both a fake reactor and StubHTTPProtocol.",
            "        \"\"\"",
            "        agent = client.Agent(reactor)",
            "        _oldGetEndpoint = agent._getEndpoint",
            "        agent._getEndpoint = lambda *args: (",
            "            self.StubEndpoint(_oldGetEndpoint(*args), self)",
            "        )",
            "        return agent",
            "",
            "    def connect(self, factory):",
            "        \"\"\"",
            "        Fake implementation of an endpoint which synchronously",
            "        succeeds with an instance of L{StubHTTPProtocol} for ease of",
            "        testing.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(None)",
            "        self.protocol = protocol",
            "        return succeed(protocol)",
            "",
            "",
            "class DummyEndpoint:",
            "    \"\"\"",
            "    An endpoint that uses a fake transport.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        protocol = factory.buildProtocol(None)",
            "        protocol.makeConnection(StringTransport())",
            "        return succeed(protocol)",
            "",
            "",
            "class BadEndpoint:",
            "    \"\"\"",
            "    An endpoint that shouldn't be called.",
            "    \"\"\"",
            "",
            "    def connect(self, factory):",
            "        raise RuntimeError(\"This endpoint should not have been used.\")",
            "",
            "",
            "class DummyFactory(Factory):",
            "    \"\"\"",
            "    Create C{StubHTTPProtocol} instances.",
            "    \"\"\"",
            "",
            "    def __init__(self, quiescentCallback, metadata):",
            "        pass",
            "",
            "    protocol = StubHTTPProtocol",
            "",
            "",
            "class HTTPConnectionPoolTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    Tests for the L{HTTPConnectionPool} class.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self.fakeReactor = self.createReactor()",
            "        self.pool = HTTPConnectionPool(self.fakeReactor)",
            "        self.pool._factory = DummyFactory",
            "        # The retry code path is tested in HTTPConnectionPoolRetryTests:",
            "        self.pool.retryAutomatically = False",
            "",
            "    def test_getReturnsNewIfCacheEmpty(self):",
            "        \"\"\"",
            "        If there are no cached connections,",
            "        L{HTTPConnectionPool.getConnection} returns a new connection.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "",
            "        def gotConnection(conn):",
            "            self.assertIsInstance(conn, StubHTTPProtocol)",
            "            # The new connection is not stored in the pool:",
            "            self.assertNotIn(conn, self.pool._connections.values())",
            "",
            "        unknownKey = 12245",
            "        d = self.pool.getConnection(unknownKey, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_putStartsTimeout(self):",
            "        \"\"\"",
            "        If a connection is put back to the pool, a 240-sec timeout is started.",
            "",
            "        When the timeout hits, the connection is closed and removed from the",
            "        pool.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "",
            "        # Connection is in pool, still not closed:",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "",
            "        # Advance 239 seconds, still not closed:",
            "        self.fakeReactor.advance(239)",
            "        self.assertEqual(protocol.transport.disconnecting, False)",
            "        self.assertIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "        self.assertIn(protocol, self.pool._timeouts)",
            "",
            "        # Advance past 240 seconds, connection will be closed:",
            "        self.fakeReactor.advance(1.1)",
            "        self.assertEqual(protocol.transport.disconnecting, True)",
            "        self.assertNotIn(protocol, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "        self.assertNotIn(protocol, self.pool._timeouts)",
            "",
            "    def test_putExceedsMaxPersistent(self):",
            "        \"\"\"",
            "        If an idle connection is put back in the cache and the max number of",
            "        persistent connections has been exceeded, one of the connections is",
            "        closed and removed from the cache.",
            "        \"\"\"",
            "        pool = self.pool",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection((\"http\", b\"example.com\", 80), p)",
            "        self.assertEqual(pool._connections[(\"http\", b\"example.com\", 80)], origCached)",
            "        timeouts = pool._timeouts.copy()",
            "",
            "        # Now we add another one:",
            "        newProtocol = StubHTTPProtocol()",
            "        newProtocol.makeConnection(StringTransport())",
            "        pool._putConnection((\"http\", b\"example.com\", 80), newProtocol)",
            "",
            "        # The oldest cached connections will be removed and disconnected:",
            "        newCached = pool._connections[(\"http\", b\"example.com\", 80)]",
            "        self.assertEqual(len(newCached), 2)",
            "        self.assertEqual(newCached, [origCached[1], newProtocol])",
            "        self.assertEqual([p.transport.disconnecting for p in newCached], [False, False])",
            "        self.assertEqual(origCached[0].transport.disconnecting, True)",
            "        self.assertTrue(timeouts[origCached[0]].cancelled)",
            "        self.assertNotIn(origCached[0], pool._timeouts)",
            "",
            "    def test_maxPersistentPerHost(self):",
            "        \"\"\"",
            "        C{maxPersistentPerHost} is enforced per C{(scheme, host, port)}:",
            "        different keys have different max connections.",
            "        \"\"\"",
            "",
            "        def addProtocol(scheme, host, port):",
            "            p = StubHTTPProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            return p",
            "",
            "        persistent = []",
            "        persistent.append(addProtocol(\"http\", b\"example.com\", 80))",
            "        persistent.append(addProtocol(\"http\", b\"example.com\", 80))",
            "        addProtocol(\"https\", b\"example.com\", 443)",
            "        addProtocol(\"http\", b\"www2.example.com\", 80)",
            "",
            "        self.assertEqual(",
            "            self.pool._connections[(\"http\", b\"example.com\", 80)], persistent",
            "        )",
            "        self.assertEqual(len(self.pool._connections[(\"https\", b\"example.com\", 443)]), 1)",
            "        self.assertEqual(",
            "            len(self.pool._connections[(\"http\", b\"www2.example.com\", 80)]), 1",
            "        )",
            "",
            "    def test_getCachedConnection(self):",
            "        \"\"\"",
            "        Getting an address which has a cached connection returns the cached",
            "        connection, removes it from the cache and cancels its timeout.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "",
            "        def gotConnection(conn):",
            "            # We got the cached connection:",
            "            self.assertIdentical(protocol, conn)",
            "            self.assertNotIn(conn, self.pool._connections[(\"http\", b\"example.com\", 80)])",
            "            # And the timeout was cancelled:",
            "            self.fakeReactor.advance(241)",
            "            self.assertEqual(conn.transport.disconnecting, False)",
            "            self.assertNotIn(conn, self.pool._timeouts)",
            "",
            "        return self.pool.getConnection(",
            "            (\"http\", b\"example.com\", 80),",
            "            BadEndpoint(),",
            "        ).addCallback(gotConnection)",
            "",
            "    def test_newConnection(self):",
            "        \"\"\"",
            "        The pool's C{_newConnection} method constructs a new connection.",
            "        \"\"\"",
            "        # We start out with one cached connection:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        key = 12245",
            "        self.pool._putConnection(key, protocol)",
            "",
            "        def gotConnection(newConnection):",
            "            # We got a new connection:",
            "            self.assertNotIdentical(protocol, newConnection)",
            "            # And the old connection is still there:",
            "            self.assertIn(protocol, self.pool._connections[key])",
            "            # While the new connection is not:",
            "            self.assertNotIn(newConnection, self.pool._connections.values())",
            "",
            "        d = self.pool._newConnection(key, DummyEndpoint())",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_getSkipsDisconnected(self):",
            "        \"\"\"",
            "        When getting connections out of the cache, disconnected connections",
            "        are removed and not returned.",
            "        \"\"\"",
            "        pool = self.pool",
            "        key = (\"http\", b\"example.com\", 80)",
            "",
            "        # We start out with two cached connection, the max:",
            "        origCached = [StubHTTPProtocol(), StubHTTPProtocol()]",
            "        for p in origCached:",
            "            p.makeConnection(StringTransport())",
            "            pool._putConnection(key, p)",
            "        self.assertEqual(pool._connections[key], origCached)",
            "",
            "        # We close the first one:",
            "        origCached[0].state = \"DISCONNECTED\"",
            "",
            "        # Now, when we retrive connections we should get the *second* one:",
            "        result = []",
            "        self.pool.getConnection(key, BadEndpoint()).addCallback(result.append)",
            "        self.assertIdentical(result[0], origCached[1])",
            "",
            "        # And both the disconnected and removed connections should be out of",
            "        # the cache:",
            "        self.assertEqual(pool._connections[key], [])",
            "        self.assertEqual(pool._timeouts, {})",
            "",
            "    def test_putNotQuiescent(self):",
            "        \"\"\"",
            "        If a non-quiescent connection is put back in the cache, an error is",
            "        logged.",
            "        \"\"\"",
            "        protocol = StubHTTPProtocol()",
            "        # By default state is QUIESCENT",
            "        self.assertEqual(protocol.state, \"QUIESCENT\")",
            "",
            "        logObserver = EventLoggingObserver.createWithCleanup(self, globalLogPublisher)",
            "",
            "        protocol.state = \"NOTQUIESCENT\"",
            "        self.pool._putConnection((\"http\", b\"example.com\", 80), protocol)",
            "        self.assertEquals(1, len(logObserver))",
            "",
            "        event = logObserver[0]",
            "        f = event[\"log_failure\"]",
            "",
            "        self.assertIsInstance(f.value, RuntimeError)",
            "        self.assertEqual(",
            "            f.getErrorMessage(), \"BUG: Non-quiescent protocol added to connection pool.\"",
            "        )",
            "        self.assertIdentical(",
            "            None, self.pool._connections.get((\"http\", b\"example.com\", 80))",
            "        )",
            "        self.flushLoggedErrors(RuntimeError)",
            "",
            "    def test_getUsesQuiescentCallback(self):",
            "        \"\"\"",
            "        When L{HTTPConnectionPool.getConnection} connects, it returns a",
            "        C{Deferred} that fires with an instance of L{HTTP11ClientProtocol}",
            "        that has the correct quiescent callback attached. When this callback",
            "        is called the protocol is returned to the cache correctly, using the",
            "        right key.",
            "        \"\"\"",
            "",
            "        class StringEndpoint:",
            "            def connect(self, factory):",
            "                p = factory.buildProtocol(None)",
            "                p.makeConnection(StringTransport())",
            "                return succeed(p)",
            "",
            "        pool = HTTPConnectionPool(self.fakeReactor, True)",
            "        pool.retryAutomatically = False",
            "        result = []",
            "        key = \"a key\"",
            "        pool.getConnection(key, StringEndpoint()).addCallback(result.append)",
            "        protocol = result[0]",
            "        self.assertIsInstance(protocol, HTTP11ClientProtocol)",
            "",
            "        # Now that we have protocol instance, lets try to put it back in the",
            "        # pool:",
            "        protocol._state = \"QUIESCENT\"",
            "        protocol._quiescentCallback(protocol)",
            "",
            "        # If we try to retrive a connection to same destination again, we",
            "        # should get the same protocol, because it should've been added back",
            "        # to the pool:",
            "        result2 = []",
            "        pool.getConnection(key, StringEndpoint()).addCallback(result2.append)",
            "        self.assertIdentical(result2[0], protocol)",
            "",
            "    def test_closeCachedConnections(self):",
            "        \"\"\"",
            "        L{HTTPConnectionPool.closeCachedConnections} closes all cached",
            "        connections and removes them from the cache. It returns a Deferred",
            "        that fires when they have all lost their connections.",
            "        \"\"\"",
            "        persistent = []",
            "",
            "        def addProtocol(scheme, host, port):",
            "            p = HTTP11ClientProtocol()",
            "            p.makeConnection(StringTransport())",
            "            self.pool._putConnection((scheme, host, port), p)",
            "            persistent.append(p)",
            "",
            "        addProtocol(\"http\", b\"example.com\", 80)",
            "        addProtocol(\"http\", b\"www2.example.com\", 80)",
            "        doneDeferred = self.pool.closeCachedConnections()",
            "",
            "        # Connections have begun disconnecting:",
            "        for p in persistent:",
            "            self.assertEqual(p.transport.disconnecting, True)",
            "        self.assertEqual(self.pool._connections, {})",
            "        # All timeouts were cancelled and removed:",
            "        for dc in self.fakeReactor.getDelayedCalls():",
            "            self.assertEqual(dc.cancelled, True)",
            "        self.assertEqual(self.pool._timeouts, {})",
            "",
            "        # Returned Deferred fires when all connections have been closed:",
            "        result = []",
            "        doneDeferred.addCallback(result.append)",
            "        self.assertEqual(result, [])",
            "        persistent[0].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [])",
            "        persistent[1].connectionLost(Failure(ConnectionDone()))",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_cancelGetConnectionCancelsEndpointConnect(self):",
            "        \"\"\"",
            "        Cancelling the C{Deferred} returned from",
            "        L{HTTPConnectionPool.getConnection} cancels the C{Deferred} returned",
            "        by opening a new connection with the given endpoint.",
            "        \"\"\"",
            "        self.assertEqual(self.pool._connections, {})",
            "        connectionResult = Deferred()",
            "",
            "        class Endpoint:",
            "            def connect(self, factory):",
            "                return connectionResult",
            "",
            "        d = self.pool.getConnection(12345, Endpoint())",
            "        d.cancel()",
            "        self.assertEqual(self.failureResultOf(connectionResult).type, CancelledError)",
            "",
            "",
            "class AgentTestsMixin:",
            "    \"\"\"",
            "    Tests for any L{IAgent} implementation.",
            "    \"\"\"",
            "",
            "    def test_interface(self):",
            "        \"\"\"",
            "        The agent object provides L{IAgent}.",
            "        \"\"\"",
            "        self.assertTrue(verifyObject(IAgent, self.makeAgent()))",
            "",
            "",
            "class IntegrationTestingMixin:",
            "    \"\"\"",
            "    Transport-to-Agent integration tests for both HTTP and HTTPS.",
            "    \"\"\"",
            "",
            "    def test_integrationTestIPv4(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv4.",
            "        \"\"\"",
            "        self.integrationTest(b\"example.com\", EXAMPLE_COM_IP, IPv4Address)",
            "",
            "    def test_integrationTestIPv4Address(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv4 when hostname is an IPv4 address.",
            "        \"\"\"",
            "        self.integrationTest(b\"127.0.0.7\", \"127.0.0.7\", IPv4Address)",
            "",
            "    def test_integrationTestIPv6(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv6.",
            "        \"\"\"",
            "        self.integrationTest(b\"ipv6.example.com\", EXAMPLE_COM_V6_IP, IPv6Address)",
            "",
            "    def test_integrationTestIPv6Address(self):",
            "        \"\"\"",
            "        L{Agent} works over IPv6 when hostname is an IPv6 address.",
            "        \"\"\"",
            "        self.integrationTest(b\"[::7]\", \"::7\", IPv6Address)",
            "",
            "    def integrationTest(",
            "        self,",
            "        hostName,",
            "        expectedAddress,",
            "        addressType,",
            "        serverWrapper=lambda server: server,",
            "        createAgent=client.Agent,",
            "        scheme=b\"http\",",
            "    ):",
            "        \"\"\"",
            "        L{Agent} will make a TCP connection, send an HTTP request, and return a",
            "        L{Deferred} that fires when the response has been received.",
            "",
            "        @param hostName: The hostname to interpolate into the URL to be",
            "            requested.",
            "        @type hostName: L{bytes}",
            "",
            "        @param expectedAddress: The expected address string.",
            "        @type expectedAddress: L{bytes}",
            "",
            "        @param addressType: The class to construct an address out of.",
            "        @type addressType: L{type}",
            "",
            "        @param serverWrapper: A callable that takes a protocol factory and",
            "            returns a protocol factory; used to wrap the server / responder",
            "            side in a TLS server.",
            "        @type serverWrapper:",
            "            serverWrapper(L{twisted.internet.interfaces.IProtocolFactory}) ->",
            "            L{twisted.internet.interfaces.IProtocolFactory}",
            "",
            "        @param createAgent: A callable that takes a reactor and produces an",
            "            L{IAgent}; used to construct an agent with an appropriate trust",
            "            root for TLS.",
            "        @type createAgent: createAgent(reactor) -> L{IAgent}",
            "",
            "        @param scheme: The scheme to test, C{http} or C{https}",
            "        @type scheme: L{bytes}",
            "        \"\"\"",
            "        reactor = self.createReactor()",
            "        agent = createAgent(reactor)",
            "        deferred = agent.request(b\"GET\", scheme + b\"://\" + hostName + b\"/\")",
            "        host, port, factory, timeout, bind = reactor.tcpClients[0]",
            "        self.assertEqual(host, expectedAddress)",
            "        peerAddress = addressType(\"TCP\", host, port)",
            "        clientProtocol = factory.buildProtocol(peerAddress)",
            "        clientTransport = FakeTransport(clientProtocol, False, peerAddress=peerAddress)",
            "        clientProtocol.makeConnection(clientTransport)",
            "",
            "        @Factory.forProtocol",
            "        def accumulator():",
            "            ap = AccumulatingProtocol()",
            "            accumulator.currentProtocol = ap",
            "            return ap",
            "",
            "        accumulator.currentProtocol = None",
            "        accumulator.protocolConnectionMade = None",
            "        wrapper = serverWrapper(accumulator).buildProtocol(None)",
            "        serverTransport = FakeTransport(wrapper, True)",
            "        wrapper.makeConnection(serverTransport)",
            "        pump = IOPump(clientProtocol, wrapper, clientTransport, serverTransport, False)",
            "        pump.flush()",
            "        self.assertNoResult(deferred)",
            "        lines = accumulator.currentProtocol.data.split(b\"\\r\\n\")",
            "        self.assertTrue(lines[0].startswith(b\"GET / HTTP\"), lines[0])",
            "        headers = dict([line.split(b\": \", 1) for line in lines[1:] if line])",
            "        self.assertEqual(headers[b\"Host\"], hostName)",
            "        self.assertNoResult(deferred)",
            "        accumulator.currentProtocol.transport.write(",
            "            b\"HTTP/1.1 200 OK\"",
            "            b\"\\r\\nX-An-Header: an-value\\r\\n\"",
            "            b\"\\r\\nContent-length: 12\\r\\n\\r\\n\"",
            "            b\"hello world!\"",
            "        )",
            "        pump.flush()",
            "        response = self.successResultOf(deferred)",
            "        self.assertEquals(",
            "            response.headers.getRawHeaders(b\"x-an-header\")[0], b\"an-value\"",
            "        )",
            "",
            "",
            "@implementer(IAgentEndpointFactory)",
            "class StubEndpointFactory:",
            "    \"\"\"",
            "    A stub L{IAgentEndpointFactory} for use in testing.",
            "    \"\"\"",
            "",
            "    def endpointForURI(self, uri):",
            "        \"\"\"",
            "        Testing implementation.",
            "",
            "        @param uri: A L{URI}.",
            "",
            "        @return: C{(scheme, host, port)} of passed in URI; violation of",
            "            interface but useful for testing.",
            "        @rtype: L{tuple}",
            "        \"\"\"",
            "        return (uri.scheme, uri.host, uri.port)",
            "",
            "",
            "class AgentTests(",
            "    TestCase, FakeReactorAndConnectMixin, AgentTestsMixin, IntegrationTestingMixin",
            "):",
            "    \"\"\"",
            "    Tests for the new HTTP client API provided by L{Agent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.Agent} instance",
            "        \"\"\"",
            "        return client.Agent(self.reactor)",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_defaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in, the L{Agent} creates a non-persistent pool.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor)",
            "        self.assertIsInstance(agent._pool, HTTPConnectionPool)",
            "        self.assertEqual(agent._pool.persistent, False)",
            "        self.assertIdentical(agent._reactor, agent._pool._reactor)",
            "",
            "    def test_persistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{True} on the L{HTTPConnectionPool} (the",
            "        default), C{Request}s are created with their C{persistent} flag set to",
            "        C{True}.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(b\"GET\", b\"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, True)",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        If C{persistent} is set to C{False} when creating the",
            "        L{HTTPConnectionPool}, C{Request}s are created with their",
            "        C{persistent} flag set to C{False}.",
            "",
            "        Elsewhere in the tests for the underlying HTTP code we ensure that",
            "        this will result in the disconnection of the HTTP protocol once the",
            "        request is done, so that the connection will not be returned to the",
            "        pool.",
            "        \"\"\"",
            "        pool = HTTPConnectionPool(self.reactor, persistent=False)",
            "        agent = client.Agent(self.reactor, pool=pool)",
            "        agent._getEndpoint = lambda *args: self",
            "        agent.request(b\"GET\", b\"http://127.0.0.1\")",
            "        self.assertEqual(self.protocol.requests[0][0].persistent, False)",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the Agent, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint returned by",
            "        C{self._getEndpoint}. The key used is C{(scheme, host, port)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "",
            "        class MyAgent(client.Agent):",
            "            def _getEndpoint(this, uri):",
            "                self.assertEqual(",
            "                    (uri.scheme, uri.host, uri.port), (b\"http\", b\"foo\", 80)",
            "                )",
            "                return endpoint",
            "",
            "        class DummyPool:",
            "            connected = False",
            "            persistent = False",
            "",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertEqual(ep, endpoint)",
            "                # This is the key the default Agent uses, others will have",
            "                # different keys:",
            "                self.assertEqual(key, (b\"http\", b\"foo\", 80))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = MyAgent(self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        headers = http_headers.Headers()",
            "        headers.addRawHeader(b\"host\", b\"foo\")",
            "        bodyProducer = object()",
            "        agent.request(",
            "            b\"GET\", b\"http://foo/\", bodyProducer=bodyProducer, headers=headers",
            "        )",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "    def test_nonBytesMethod(self):",
            "        \"\"\"",
            "        L{Agent.request} raises L{TypeError} when the C{method} argument isn't",
            "        L{bytes}.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, self.agent.request, \"GET\", b\"http://foo.example/\")",
            "",
            "    def test_unsupportedScheme(self):",
            "        \"\"\"",
            "        L{Agent.request} returns a L{Deferred} which fails with",
            "        L{SchemeNotSupported} if the scheme of the URI passed to it is not",
            "        C{'http'}.",
            "        \"\"\"",
            "        return self.assertFailure(",
            "            self.agent.request(b\"GET\", b\"mailto:alice@example.com\"), SchemeNotSupported",
            "        )",
            "",
            "    def test_connectionFailed(self):",
            "        \"\"\"",
            "        The L{Deferred} returned by L{Agent.request} fires with a L{Failure} if",
            "        the TCP connection attempt fails.",
            "        \"\"\"",
            "        result = self.agent.request(b\"GET\", b\"http://foo/\")",
            "        # Cause the connection to be refused",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        factory.clientConnectionFailed(None, Failure(ConnectionRefusedError()))",
            "        self.reactor.advance(10)",
            "        # ^ https://twistedmatrix.com/trac/ticket/8202",
            "        self.failureResultOf(result, ConnectionRefusedError)",
            "",
            "    def test_connectHTTP(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a C{HostnameEndpoint} when passed a scheme",
            "        of C{'http'}.",
            "        \"\"\"",
            "        expectedHost = b\"example.com\"",
            "        expectedPort = 1234",
            "        endpoint = self.agent._getEndpoint(",
            "            URI.fromBytes(b\"http://%b:%d\" % (expectedHost, expectedPort))",
            "        )",
            "        self.assertEqual(endpoint._hostStr, \"example.com\")",
            "        self.assertEqual(endpoint._port, expectedPort)",
            "        self.assertIsInstance(endpoint, HostnameEndpoint)",
            "",
            "    def test_nonDecodableURI(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} when given a non-ASCII decodable URI will raise a",
            "        L{ValueError} saying such.",
            "        \"\"\"",
            "        uri = URI.fromBytes(b\"http://example.com:80\")",
            "        uri.host = \"\\u2603.com\".encode()",
            "",
            "        with self.assertRaises(ValueError) as e:",
            "            self.agent._getEndpoint(uri)",
            "",
            "        self.assertEqual(",
            "            e.exception.args[0],",
            "            (",
            "                \"The host of the provided URI ({reprout}) contains \"",
            "                \"non-ASCII octets, it should be ASCII \"",
            "                \"decodable.\"",
            "            ).format(reprout=repr(uri.host)),",
            "        )",
            "",
            "    def test_hostProvided(self):",
            "        \"\"\"",
            "        If L{None} is passed to L{Agent.request} for the C{headers} parameter,",
            "        a L{Headers} instance is created for the request and a I{Host} header",
            "        added to it.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo?bar\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"example.com\"])",
            "",
            "    def test_hostIPv6Bracketed(self):",
            "        \"\"\"",
            "        If an IPv6 address is used in the C{uri} passed to L{Agent.request},",
            "        the computed I{Host} header needs to be bracketed.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://[::1]/\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"[::1]\"])",
            "",
            "    def test_hostOverride(self):",
            "        \"\"\"",
            "        If the headers passed to L{Agent.request} includes a value for the",
            "        I{Host} header, that value takes precedence over the one which would",
            "        otherwise be automatically provided.",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"quux\"]})",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo?bar\", headers)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"host\"), [b\"quux\"])",
            "",
            "    def test_headersUnmodified(self):",
            "        \"\"\"",
            "        If a I{Host} header must be added to the request, the L{Headers}",
            "        instance passed to L{Agent.request} is not modified.",
            "        \"\"\"",
            "        headers = http_headers.Headers()",
            "        self.agent._getEndpoint = lambda *args: self",
            "        self.agent.request(b\"GET\", b\"http://example.com/foo\", headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should have been issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        # And the headers object passed in should not have changed.",
            "        self.assertEqual(headers, http_headers.Headers())",
            "",
            "    def test_hostValueStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port of C{80},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"http\", b\"example.com\", 80), b\"example.com\"",
            "        )",
            "",
            "    def test_hostValueNonStandardHTTP(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'http'} and a port other than C{80},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"http\", b\"example.com\", 54321),",
            "            b\"example.com:54321\",",
            "        )",
            "",
            "    def test_hostValueStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port of C{443},",
            "        L{Agent._computeHostValue} returns a string giving just",
            "        the host name passed to it.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"https\", b\"example.com\", 443), b\"example.com\"",
            "        )",
            "",
            "    def test_hostValueNonStandardHTTPS(self):",
            "        \"\"\"",
            "        When passed a scheme of C{'https'} and a port other than C{443},",
            "        L{Agent._computeHostValue} returns a string giving the",
            "        host passed to it joined together with the port number by C{\":\"}.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.agent._computeHostValue(b\"https\", b\"example.com\", 54321),",
            "            b\"example.com:54321\",",
            "        )",
            "",
            "    def test_request(self):",
            "        \"\"\"",
            "        L{Agent.request} establishes a new connection to the host indicated by",
            "        the host part of the URI passed to it and issues a request using the",
            "        method, the path portion of the URI, the headers, and the body producer",
            "        passed to it.  It returns a L{Deferred} which fires with an",
            "        L{IResponse} from the server.",
            "        \"\"\"",
            "        self.agent._getEndpoint = lambda *args: self",
            "",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"]})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(b\"GET\", b\"http://example.com:1234/foo?bar\", headers, body)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, b\"GET\")",
            "        self.assertEqual(req.uri, b\"/foo?bar\")",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"example.com:1234\"]}),",
            "        )",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "    def test_connectTimeout(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} agent.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_connectTimeoutHTTPS(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{connectTimeout} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, connectTimeout=5)",
            "        agent.request(b\"GET\", b\"https://foo/\")",
            "        timeout = self.reactor.tcpClients.pop()[3]",
            "        self.assertEqual(5, timeout)",
            "",
            "    def test_bindAddress(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectTCP} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress=\"192.168.0.1\")",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual(\"192.168.0.1\", address)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_bindAddressSSL(self):",
            "        \"\"\"",
            "        L{Agent} takes a C{bindAddress} argument which is forwarded to the",
            "        following C{connectSSL} call.",
            "        \"\"\"",
            "        agent = client.Agent(self.reactor, bindAddress=\"192.168.0.1\")",
            "        agent.request(b\"GET\", b\"https://foo/\")",
            "        address = self.reactor.tcpClients.pop()[4]",
            "        self.assertEqual(\"192.168.0.1\", address)",
            "",
            "    def test_responseIncludesRequest(self):",
            "        \"\"\"",
            "        L{Response}s returned by L{Agent.request} have a reference to the",
            "        L{Request} that was originally issued.",
            "        \"\"\"",
            "        uri = b\"http://example.com/\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        d = agent.request(b\"GET\", uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "",
            "        resp = client.Response._construct(",
            "            (b\"HTTP\", 1, 1), 200, b\"OK\", client.Headers({}), None, req",
            "        )",
            "        res.callback(resp)",
            "",
            "        response = self.successResultOf(d)",
            "        self.assertEqual(",
            "            (",
            "                response.request.method,",
            "                response.request.absoluteURI,",
            "                response.request.headers,",
            "            ),",
            "            (req.method, req.absoluteURI, req.headers),",
            "        )",
            "",
            "    def test_requestAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is the absolute URI of the request.",
            "        \"\"\"",
            "        uri = b\"http://example.com/foo;1234?bar#frag\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        agent.request(b\"GET\", uri)",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(self.protocol.requests), 1)",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.absoluteURI, uri)",
            "",
            "    def test_requestMissingAbsoluteURI(self):",
            "        \"\"\"",
            "        L{Request.absoluteURI} is L{None} if L{Request._parsedURI} is L{None}.",
            "        \"\"\"",
            "        request = client.Request(b\"FOO\", b\"/\", client.Headers(), None)",
            "        self.assertIdentical(request.absoluteURI, None)",
            "",
            "    def test_endpointFactory(self):",
            "        \"\"\"",
            "        L{Agent.usingEndpointFactory} creates an L{Agent} that uses the given",
            "        factory to create endpoints.",
            "        \"\"\"",
            "        factory = StubEndpointFactory()",
            "        agent = client.Agent.usingEndpointFactory(None, endpointFactory=factory)",
            "        uri = URI.fromBytes(b\"http://example.com/\")",
            "        returnedEndpoint = agent._getEndpoint(uri)",
            "        self.assertEqual(returnedEndpoint, (b\"http\", b\"example.com\", 80))",
            "",
            "    def test_endpointFactoryDefaultPool(self):",
            "        \"\"\"",
            "        If no pool is passed in to L{Agent.usingEndpointFactory}, a default",
            "        pool is constructed with no persistent connections.",
            "        \"\"\"",
            "        agent = client.Agent.usingEndpointFactory(self.reactor, StubEndpointFactory())",
            "        pool = agent._pool",
            "        self.assertEqual(",
            "            (pool.__class__, pool.persistent, pool._reactor),",
            "            (HTTPConnectionPool, False, agent._reactor),",
            "        )",
            "",
            "    def test_endpointFactoryPool(self):",
            "        \"\"\"",
            "        If a pool is passed in to L{Agent.usingEndpointFactory} it is used as",
            "        the L{Agent} pool.",
            "        \"\"\"",
            "        pool = object()",
            "        agent = client.Agent.usingEndpointFactory(",
            "            self.reactor, StubEndpointFactory(), pool",
            "        )",
            "        self.assertIs(pool, agent._pool)",
            "",
            "",
            "class AgentMethodInjectionTests(",
            "    FakeReactorAndConnectMixin,",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Agent} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        agent = client.Agent(self.createReactor())",
            "        uri = b\"http://twisted.invalid\"",
            "        agent.request(method, uri, client.Headers(), None)",
            "",
            "",
            "class AgentURIInjectionTests(",
            "    FakeReactorAndConnectMixin,",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Agent} against URI injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param uri: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        agent = client.Agent(self.createReactor())",
            "        method = b\"GET\"",
            "        agent.request(method, uri, client.Headers(), None)",
            "",
            "",
            "@skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "class AgentHTTPSTests(TestCase, FakeReactorAndConnectMixin, IntegrationTestingMixin):",
            "    \"\"\"",
            "    Tests for the new HTTP client API that depends on SSL.",
            "    \"\"\"",
            "",
            "    def makeEndpoint(self, host=b\"example.com\", port=443):",
            "        \"\"\"",
            "        Create an L{Agent} with an https scheme and return its endpoint",
            "        created according to the arguments.",
            "",
            "        @param host: The host for the endpoint.",
            "        @type host: L{bytes}",
            "",
            "        @param port: The port for the endpoint.",
            "        @type port: L{int}",
            "",
            "        @return: An endpoint of an L{Agent} constructed according to args.",
            "        @rtype: L{SSL4ClientEndpoint}",
            "        \"\"\"",
            "        return client.Agent(self.createReactor())._getEndpoint(",
            "            URI.fromBytes(b\"https://%b:%d/\" % (host, port))",
            "        )",
            "",
            "    def test_endpointType(self):",
            "        \"\"\"",
            "        L{Agent._getEndpoint} return a L{SSL4ClientEndpoint} when passed a",
            "        scheme of C{'https'}.",
            "        \"\"\"",
            "        from twisted.internet.endpoints import _WrapperEndpoint",
            "",
            "        endpoint = self.makeEndpoint()",
            "        self.assertIsInstance(endpoint, _WrapperEndpoint)",
            "        self.assertIsInstance(endpoint._wrappedEndpoint, HostnameEndpoint)",
            "",
            "    def test_hostArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a host is passed, the endpoint respects it.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint(host=b\"example.com\")",
            "        self.assertEqual(endpoint._wrappedEndpoint._hostStr, \"example.com\")",
            "",
            "    def test_portArgumentIsRespected(self):",
            "        \"\"\"",
            "        If a port is passed, the endpoint respects it.",
            "        \"\"\"",
            "        expectedPort = 4321",
            "        endpoint = self.makeEndpoint(port=expectedPort)",
            "        self.assertEqual(endpoint._wrappedEndpoint._port, expectedPort)",
            "",
            "    def test_contextFactoryType(self):",
            "        \"\"\"",
            "        L{Agent} wraps its connection creator creator and uses modern TLS APIs.",
            "        \"\"\"",
            "        endpoint = self.makeEndpoint()",
            "        contextFactory = endpoint._wrapperFactory(None)._connectionCreator",
            "        self.assertIsInstance(contextFactory, ClientTLSOptions)",
            "        self.assertEqual(contextFactory._hostname, \"example.com\")",
            "",
            "    def test_connectHTTPSCustomConnectionCreator(self):",
            "        \"\"\"",
            "        If a custom L{WebClientConnectionCreator}-like object is passed to",
            "        L{Agent.__init__} it will be used to determine the SSL parameters for",
            "        HTTPS requests.  When an HTTPS request is made, the hostname and port",
            "        number of the request URL will be passed to the connection creator's",
            "        C{creatorForNetloc} method.  The resulting context object will be used",
            "        to establish the SSL connection.",
            "        \"\"\"",
            "        expectedHost = b\"example.org\"",
            "        expectedPort = 20443",
            "",
            "        class JustEnoughConnection:",
            "            handshakeStarted = False",
            "            connectState = False",
            "",
            "            def do_handshake(self):",
            "                \"\"\"",
            "                The handshake started.  Record that fact.",
            "                \"\"\"",
            "                self.handshakeStarted = True",
            "",
            "            def set_connect_state(self):",
            "                \"\"\"",
            "                The connection started.  Record that fact.",
            "                \"\"\"",
            "                self.connectState = True",
            "",
            "        contextArgs = []",
            "",
            "        @implementer(IOpenSSLClientConnectionCreator)",
            "        class JustEnoughCreator:",
            "            def __init__(self, hostname, port):",
            "                self.hostname = hostname",
            "                self.port = port",
            "",
            "            def clientConnectionForTLS(self, tlsProtocol):",
            "                \"\"\"",
            "                Implement L{IOpenSSLClientConnectionCreator}.",
            "",
            "                @param tlsProtocol: The TLS protocol.",
            "                @type tlsProtocol: L{TLSMemoryBIOProtocol}",
            "",
            "                @return: C{expectedConnection}",
            "                \"\"\"",
            "                contextArgs.append((tlsProtocol, self.hostname, self.port))",
            "                return expectedConnection",
            "",
            "        expectedConnection = JustEnoughConnection()",
            "",
            "        @implementer(IPolicyForHTTPS)",
            "        class StubBrowserLikePolicyForHTTPS:",
            "            def creatorForNetloc(self, hostname, port):",
            "                \"\"\"",
            "                Emulate L{BrowserLikePolicyForHTTPS}.",
            "",
            "                @param hostname: The hostname to verify.",
            "                @type hostname: L{bytes}",
            "",
            "                @param port: The port number.",
            "                @type port: L{int}",
            "",
            "                @return: a stub L{IOpenSSLClientConnectionCreator}",
            "                @rtype: L{JustEnoughCreator}",
            "                \"\"\"",
            "                return JustEnoughCreator(hostname, port)",
            "",
            "        expectedCreatorCreator = StubBrowserLikePolicyForHTTPS()",
            "        reactor = self.createReactor()",
            "        agent = client.Agent(reactor, expectedCreatorCreator)",
            "        endpoint = agent._getEndpoint(",
            "            URI.fromBytes(b\"https://%b:%d\" % (expectedHost, expectedPort))",
            "        )",
            "        endpoint.connect(Factory.forProtocol(Protocol))",
            "        tlsFactory = reactor.tcpClients[-1][2]",
            "        tlsProtocol = tlsFactory.buildProtocol(None)",
            "        tlsProtocol.makeConnection(StringTransport())",
            "        tls = contextArgs[0][0]",
            "        self.assertIsInstance(tls, TLSMemoryBIOProtocol)",
            "        self.assertEqual(contextArgs[0][1:], (expectedHost, expectedPort))",
            "        self.assertTrue(expectedConnection.handshakeStarted)",
            "        self.assertTrue(expectedConnection.connectState)",
            "",
            "    def test_deprecatedDuckPolicy(self):",
            "        \"\"\"",
            "        Passing something that duck-types I{like} a L{web client context",
            "        factory <twisted.web.client.WebClientContextFactory>} - something that",
            "        does not provide L{IPolicyForHTTPS} - to L{Agent} emits a",
            "        L{DeprecationWarning} even if you don't actually C{import",
            "        WebClientContextFactory} to do it.",
            "        \"\"\"",
            "",
            "        def warnMe():",
            "            client.Agent(",
            "                deterministicResolvingReactor(MemoryReactorClock()),",
            "                \"does-not-provide-IPolicyForHTTPS\",",
            "            )",
            "",
            "        warnMe()",
            "        warnings = self.flushWarnings([warnMe])",
            "        self.assertEqual(len(warnings), 1)",
            "        [warning] = warnings",
            "        self.assertEqual(warning[\"category\"], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning[\"message\"],",
            "            \"'does-not-provide-IPolicyForHTTPS' was passed as the HTTPS \"",
            "            \"policy for an Agent, but it does not provide IPolicyForHTTPS.  \"",
            "            \"Since Twisted 14.0, you must pass a provider of IPolicyForHTTPS.\",",
            "        )",
            "",
            "    def test_alternateTrustRoot(self):",
            "        \"\"\"",
            "        L{BrowserLikePolicyForHTTPS.creatorForNetloc} returns an",
            "        L{IOpenSSLClientConnectionCreator} provider which will add certificates",
            "        from the given trust root.",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        policy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        creator = policy.creatorForNetloc(b\"thingy\", 4321)",
            "        self.assertTrue(trustRoot.called)",
            "        connection = creator.clientConnectionForTLS(None)",
            "        self.assertIs(trustRoot.context, connection.get_context())",
            "",
            "    def integrationTest(self, hostName, expectedAddress, addressType):",
            "        \"\"\"",
            "        Wrap L{AgentTestsMixin.integrationTest} with TLS.",
            "        \"\"\"",
            "        certHostName = hostName.strip(b\"[]\")",
            "        authority, server = certificatesForAuthorityAndServer(",
            "            certHostName.decode(\"ascii\")",
            "        )",
            "",
            "        def tlsify(serverFactory):",
            "            return TLSMemoryBIOFactory(server.options(), False, serverFactory)",
            "",
            "        def tlsagent(reactor):",
            "            from zope.interface import implementer",
            "",
            "            from twisted.web.iweb import IPolicyForHTTPS",
            "",
            "            @implementer(IPolicyForHTTPS)",
            "            class Policy:",
            "                def creatorForNetloc(self, hostname, port):",
            "                    return optionsForClientTLS(",
            "                        hostname.decode(\"ascii\"), trustRoot=authority",
            "                    )",
            "",
            "            return client.Agent(reactor, contextFactory=Policy())",
            "",
            "        (",
            "            super().integrationTest(",
            "                hostName,",
            "                expectedAddress,",
            "                addressType,",
            "                serverWrapper=tlsify,",
            "                createAgent=tlsagent,",
            "                scheme=b\"https\",",
            "            )",
            "        )",
            "",
            "",
            "class WebClientContextFactoryTests(TestCase):",
            "    \"\"\"",
            "    Tests for the context factory wrapper for web clients",
            "    L{twisted.web.client.WebClientContextFactory}.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Get WebClientContextFactory while quashing its deprecation warning.",
            "        \"\"\"",
            "        from twisted.web.client import WebClientContextFactory",
            "",
            "        self.warned = self.flushWarnings([WebClientContextFactoryTests.setUp])",
            "        self.webClientContextFactory = WebClientContextFactory",
            "",
            "    def test_deprecated(self):",
            "        \"\"\"",
            "        L{twisted.web.client.WebClientContextFactory} is deprecated.  Importing",
            "        it displays a warning.",
            "        \"\"\"",
            "        self.assertEqual(len(self.warned), 1)",
            "        [warning] = self.warned",
            "        self.assertEqual(warning[\"category\"], DeprecationWarning)",
            "        self.assertEqual(",
            "            warning[\"message\"],",
            "            getDeprecationWarningString(",
            "                self.webClientContextFactory,",
            "                Version(\"Twisted\", 14, 0, 0),",
            "                replacement=BrowserLikePolicyForHTTPS,",
            "            )",
            "            # See https://twistedmatrix.com/trac/ticket/7242",
            "            .replace(\";\", \":\"),",
            "        )",
            "",
            "    @skipIf(sslPresent, \"SSL Present.\")",
            "    def test_missingSSL(self):",
            "        \"\"\"",
            "        If C{getContext} is called and SSL is not available, raise",
            "        L{NotImplementedError}.",
            "        \"\"\"",
            "        self.assertRaises(",
            "            NotImplementedError,",
            "            self.webClientContextFactory().getContext,",
            "            b\"example.com\",",
            "            443,",
            "        )",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_returnsContext(self):",
            "        \"\"\"",
            "        If SSL is present, C{getContext} returns a L{OpenSSL.SSL.Context}.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory().getContext(\"example.com\", 443)",
            "        self.assertIsInstance(ctx, ssl.SSL.Context)",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_setsTrustRootOnContextToDefaultTrustRoot(self):",
            "        \"\"\"",
            "        The L{CertificateOptions} has C{trustRoot} set to the default trust",
            "        roots.",
            "        \"\"\"",
            "        ctx = self.webClientContextFactory()",
            "        certificateOptions = ctx._getCertificateOptions(\"example.com\", 443)",
            "        self.assertIsInstance(certificateOptions.trustRoot, ssl.OpenSSLDefaultPaths)",
            "",
            "",
            "class HTTPConnectionPoolRetryTests(TestCase, FakeReactorAndConnectMixin):",
            "    \"\"\"",
            "    L{client.HTTPConnectionPool}, by using",
            "    L{client._RetryingHTTP11ClientProtocol}, supports retrying requests done",
            "    against previously cached connections.",
            "    \"\"\"",
            "",
            "    def test_onlyRetryIdempotentMethods(self):",
            "        \"\"\"",
            "        Only GET, HEAD, OPTIONS, TRACE, DELETE methods cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"HEAD\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"OPTIONS\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"TRACE\", RequestNotSent(), None))",
            "        self.assertTrue(connection._shouldRetry(b\"DELETE\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"POST\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"MYMETHOD\", RequestNotSent(), None))",
            "        # This will be covered by a different ticket, since we need support",
            "        # for resettable body producers:",
            "        # self.assertTrue(connection._doRetry(\"PUT\", RequestNotSent(), None))",
            "",
            "    def test_onlyRetryIfNoResponseReceived(self):",
            "        \"\"\"",
            "        Only L{RequestNotSent}, L{RequestTransmissionFailed} and",
            "        L{ResponseNeverReceived} exceptions cause a retry.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertTrue(",
            "            connection._shouldRetry(b\"GET\", RequestTransmissionFailed([]), None)",
            "        )",
            "        self.assertTrue(",
            "            connection._shouldRetry(b\"GET\", ResponseNeverReceived([]), None)",
            "        )",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", ResponseFailed([]), None))",
            "        self.assertFalse(",
            "            connection._shouldRetry(b\"GET\", ConnectionRefusedError(), None)",
            "        )",
            "",
            "    def test_dontRetryIfFailedDueToCancel(self):",
            "        \"\"\"",
            "        If a request failed due to the operation being cancelled,",
            "        C{_shouldRetry} returns C{False} to indicate the request should not be",
            "        retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        exception = ResponseNeverReceived([Failure(defer.CancelledError())])",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", exception, None))",
            "",
            "    def test_retryIfFailedDueToNonCancelException(self):",
            "        \"\"\"",
            "        If a request failed with L{ResponseNeverReceived} due to some",
            "        arbitrary exception, C{_shouldRetry} returns C{True} to indicate the",
            "        request should be retried.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(",
            "            connection._shouldRetry(",
            "                b\"GET\", ResponseNeverReceived([Failure(Exception())]), None",
            "            )",
            "        )",
            "",
            "    def test_wrappedOnPersistentReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a previously",
            "        cached connection, it will get wrapped in a",
            "        L{client._RetryingHTTP11ClientProtocol}.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection, client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_notWrappedOnNewReturned(self):",
            "        \"\"\"",
            "        If L{client.HTTPConnectionPool.getConnection} returns a new",
            "        connection, it will be returned as is.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            # Don't want to use isinstance since potentially the wrapper might",
            "            # subclass it at some point:",
            "            self.assertIdentical(connection.__class__, HTTP11ClientProtocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def retryAttempt(self, willWeRetry):",
            "        \"\"\"",
            "        Fail a first request, possibly retrying depending on argument.",
            "        \"\"\"",
            "        protocols = []",
            "",
            "        def newProtocol():",
            "            protocol = StubHTTPProtocol()",
            "            protocols.append(protocol)",
            "            return defer.succeed(protocol)",
            "",
            "        bodyProducer = object()",
            "        request = client.Request(",
            "            b\"FOO\", b\"/\", client.Headers(), bodyProducer, persistent=True",
            "        )",
            "        newProtocol()",
            "        protocol = protocols[0]",
            "        retrier = client._RetryingHTTP11ClientProtocol(protocol, newProtocol)",
            "",
            "        def _shouldRetry(m, e, bp):",
            "            self.assertEqual(m, b\"FOO\")",
            "            self.assertIdentical(bp, bodyProducer)",
            "            self.assertIsInstance(e, (RequestNotSent, ResponseNeverReceived))",
            "            return willWeRetry",
            "",
            "        retrier._shouldRetry = _shouldRetry",
            "",
            "        d = retrier.request(request)",
            "",
            "        # So far, one request made:",
            "        self.assertEqual(len(protocols), 1)",
            "        self.assertEqual(len(protocols[0].requests), 1)",
            "",
            "        # Fail the first request:",
            "        protocol.requests[0][1].errback(RequestNotSent())",
            "        return d, protocols",
            "",
            "    def test_retryIfShouldRetryReturnsTrue(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} retries when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{True}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        # We retried!",
            "        self.assertEqual(len(protocols), 2)",
            "        response = object()",
            "        protocols[1].requests[0][1].callback(response)",
            "        return d.addCallback(self.assertIdentical, response)",
            "",
            "    def test_dontRetryIfShouldRetryReturnsFalse(self):",
            "        \"\"\"",
            "        L{client._RetryingHTTP11ClientProtocol} does not retry when",
            "        L{client._RetryingHTTP11ClientProtocol._shouldRetry} returns C{False}.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(False)",
            "        # We did not retry:",
            "        self.assertEqual(len(protocols), 1)",
            "        return self.assertFailure(d, RequestNotSent)",
            "",
            "    def test_onlyRetryWithoutBody(self):",
            "        \"\"\"",
            "        L{_RetryingHTTP11ClientProtocol} only retries queries that don't have",
            "        a body.",
            "",
            "        This is an implementation restriction; if the restriction is fixed,",
            "        this test should be removed and PUT added to list of methods that",
            "        support retries.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(None)",
            "        connection = client._RetryingHTTP11ClientProtocol(None, pool)",
            "        self.assertTrue(connection._shouldRetry(b\"GET\", RequestNotSent(), None))",
            "        self.assertFalse(connection._shouldRetry(b\"GET\", RequestNotSent(), object()))",
            "",
            "    def test_onlyRetryOnce(self):",
            "        \"\"\"",
            "        If a L{client._RetryingHTTP11ClientProtocol} fails more than once on",
            "        an idempotent query before a response is received, it will not retry.",
            "        \"\"\"",
            "        d, protocols = self.retryAttempt(True)",
            "        self.assertEqual(len(protocols), 2)",
            "        # Fail the second request too:",
            "        protocols[1].requests[0][1].errback(ResponseNeverReceived([]))",
            "        # We didn't retry again:",
            "        self.assertEqual(len(protocols), 2)",
            "        return self.assertFailure(d, ResponseNeverReceived)",
            "",
            "    def test_dontRetryIfRetryAutomaticallyFalse(self):",
            "        \"\"\"",
            "        If L{HTTPConnectionPool.retryAutomatically} is set to C{False}, don't",
            "        wrap connections with retrying logic.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        pool.retryAutomatically = False",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(123, protocol)",
            "",
            "        # Retrieve it, it should come back unwrapped:",
            "        d = pool.getConnection(123, DummyEndpoint())",
            "",
            "        def gotConnection(connection):",
            "            self.assertIdentical(connection, protocol)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "    def test_retryWithNewConnection(self):",
            "        \"\"\"",
            "        L{client.HTTPConnectionPool} creates",
            "        {client._RetryingHTTP11ClientProtocol} with a new connection factory",
            "        method that creates a new connection using the same key and endpoint",
            "        as the wrapped connection.",
            "        \"\"\"",
            "        pool = client.HTTPConnectionPool(Clock())",
            "        key = 123",
            "        endpoint = DummyEndpoint()",
            "        newConnections = []",
            "",
            "        # Override the pool's _newConnection:",
            "        def newConnection(k, e):",
            "            newConnections.append((k, e))",
            "",
            "        pool._newConnection = newConnection",
            "",
            "        # Add a connection to the cache:",
            "        protocol = StubHTTPProtocol()",
            "        protocol.makeConnection(StringTransport())",
            "        pool._putConnection(key, protocol)",
            "",
            "        # Retrieve it, it should come back wrapped in a",
            "        # _RetryingHTTP11ClientProtocol:",
            "        d = pool.getConnection(key, endpoint)",
            "",
            "        def gotConnection(connection):",
            "            self.assertIsInstance(connection, client._RetryingHTTP11ClientProtocol)",
            "            self.assertIdentical(connection._clientProtocol, protocol)",
            "            # Verify that the _newConnection method on retrying connection",
            "            # calls _newConnection on the pool:",
            "            self.assertEqual(newConnections, [])",
            "            connection._newConnection()",
            "            self.assertEqual(len(newConnections), 1)",
            "            self.assertEqual(newConnections[0][0], key)",
            "            self.assertIdentical(newConnections[0][1], endpoint)",
            "",
            "        return d.addCallback(gotConnection)",
            "",
            "",
            "class CookieTestsMixin:",
            "    \"\"\"",
            "    Mixin for unit tests dealing with cookies.",
            "    \"\"\"",
            "",
            "    def addCookies(self, cookieJar, uri, cookies):",
            "        \"\"\"",
            "        Add a cookie to a cookie jar.",
            "        \"\"\"",
            "        response = client._FakeUrllib2Response(",
            "            client.Response(",
            "                (b\"HTTP\", 1, 1),",
            "                200,",
            "                b\"OK\",",
            "                client.Headers({b\"Set-Cookie\": cookies}),",
            "                None,",
            "            )",
            "        )",
            "        request = client._FakeUrllib2Request(uri)",
            "        cookieJar.extract_cookies(response, request)",
            "        return request, response",
            "",
            "",
            "class CookieJarTests(TestCase, CookieTestsMixin):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client._FakeUrllib2Response} and",
            "    L{twisted.web.client._FakeUrllib2Request}'s interactions with",
            "    L{CookieJar} instances.",
            "    \"\"\"",
            "",
            "    def makeCookieJar(self):",
            "        \"\"\"",
            "        @return: a L{CookieJar} with some sample cookies",
            "        \"\"\"",
            "        cookieJar = CookieJar()",
            "        reqres = self.addCookies(",
            "            cookieJar,",
            "            b\"http://example.com:1234/foo?bar\",",
            "            [b\"foo=1; cow=moo; Path=/foo; Comment=hello\", b\"bar=2; Comment=goodbye\"],",
            "        )",
            "        return cookieJar, reqres",
            "",
            "    def test_extractCookies(self):",
            "        \"\"\"",
            "        L{CookieJar.extract_cookies} extracts cookie information from",
            "        fake urllib2 response instances.",
            "        \"\"\"",
            "        jar = self.makeCookieJar()[0]",
            "        cookies = {c.name: c for c in jar}",
            "",
            "        cookie = cookies[\"foo\"]",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, \"foo\")",
            "        self.assertEqual(cookie.value, \"1\")",
            "        self.assertEqual(cookie.path, \"/foo\")",
            "        self.assertEqual(cookie.comment, \"hello\")",
            "        self.assertEqual(cookie.get_nonstandard_attr(\"cow\"), \"moo\")",
            "",
            "        cookie = cookies[\"bar\"]",
            "        self.assertEqual(cookie.version, 0)",
            "        self.assertEqual(cookie.name, \"bar\")",
            "        self.assertEqual(cookie.value, \"2\")",
            "        self.assertEqual(cookie.path, \"/\")",
            "        self.assertEqual(cookie.comment, \"goodbye\")",
            "        self.assertIdentical(cookie.get_nonstandard_attr(\"cow\"), None)",
            "",
            "    def test_sendCookie(self):",
            "        \"\"\"",
            "        L{CookieJar.add_cookie_header} adds a cookie header to a fake",
            "        urllib2 request instance.",
            "        \"\"\"",
            "        jar, (request, response) = self.makeCookieJar()",
            "",
            "        self.assertIdentical(request.get_header(\"Cookie\", None), None)",
            "",
            "        jar.add_cookie_header(request)",
            "        self.assertEqual(request.get_header(\"Cookie\", None), \"foo=1; bar=2\")",
            "",
            "",
            "class CookieAgentTests(",
            "    TestCase, CookieTestsMixin, FakeReactorAndConnectMixin, AgentTestsMixin",
            "):",
            "    \"\"\"",
            "    Tests for L{twisted.web.client.CookieAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.CookieAgent}",
            "        \"\"\"",
            "        return client.CookieAgent(",
            "            self.buildAgentForWrapperTest(self.reactor), CookieJar()",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "",
            "    def test_emptyCookieJarRequest(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} does not insert any C{'Cookie'} header into the",
            "        L{Request} object if there is no cookie in the cookie jar for the URI",
            "        being requested. Cookies are extracted from the response and stored in",
            "        the cookie jar.",
            "        \"\"\"",
            "        cookieJar = CookieJar()",
            "        self.assertEqual(list(cookieJar), [])",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        d = cookieAgent.request(b\"GET\", b\"http://example.com:1234/foo?bar\")",
            "",
            "        def _checkCookie(ignored):",
            "            cookies = list(cookieJar)",
            "            self.assertEqual(len(cookies), 1)",
            "            self.assertEqual(cookies[0].name, \"foo\")",
            "            self.assertEqual(cookies[0].value, \"1\")",
            "",
            "        d.addCallback(_checkCookie)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(req.headers.getRawHeaders(b\"cookie\"), None)",
            "",
            "        resp = client.Response(",
            "            (b\"HTTP\", 1, 1),",
            "            200,",
            "            b\"OK\",",
            "            client.Headers(",
            "                {",
            "                    b\"Set-Cookie\": [",
            "                        b\"foo=1\",",
            "                    ]",
            "                }",
            "            ),",
            "            None,",
            "        )",
            "        res.callback(resp)",
            "",
            "        return d",
            "",
            "    def test_requestWithCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent.request} inserts a C{'Cookie'} header into the L{Request}",
            "        object when there is a cookie matching the request URI in the cookie",
            "        jar.",
            "        \"\"\"",
            "        uri = b\"http://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [cookie])",
            "",
            "    @skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "    def test_secureCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} is able to handle secure cookies, ie cookies which",
            "        should only be handled over https.",
            "        \"\"\"",
            "        uri = b\"https://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1;secure\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [b\"foo=1\"])",
            "",
            "    def test_secureCookieOnInsecureConnection(self):",
            "        \"\"\"",
            "        If a cookie is setup as secure, it won't be sent with the request if",
            "        it's not over HTTPS.",
            "        \"\"\"",
            "        uri = b\"http://example.com/foo?bar\"",
            "        cookie = b\"foo=1;secure\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertIdentical(None, req.headers.getRawHeaders(b\"cookie\"))",
            "",
            "    def test_portCookie(self):",
            "        \"\"\"",
            "        L{CookieAgent} supports cookies which enforces the port number they",
            "        need to be transferred upon.",
            "        \"\"\"",
            "        uri = b\"http://example.com:1234/foo?bar\"",
            "        cookie = b\"foo=1;port=1234\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 1)",
            "",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        cookieAgent = client.CookieAgent(agent, cookieJar)",
            "        cookieAgent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "        self.assertEqual(req.headers.getRawHeaders(b\"cookie\"), [b\"foo=1\"])",
            "",
            "    def test_portCookieOnWrongPort(self):",
            "        \"\"\"",
            "        When creating a cookie with a port directive, it won't be added to the",
            "        L{cookie.CookieJar} if the URI is on a different port.",
            "        \"\"\"",
            "        uri = b\"http://example.com:4567/foo?bar\"",
            "        cookie = b\"foo=1;port=1234\"",
            "",
            "        cookieJar = CookieJar()",
            "        self.addCookies(cookieJar, uri, [cookie])",
            "        self.assertEqual(len(list(cookieJar)), 0)",
            "",
            "",
            "class Decoder1(proxyForInterface(IResponse)):  # type: ignore[misc]",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "class Decoder2(Decoder1):",
            "    \"\"\"",
            "    A test decoder to be used by L{client.ContentDecoderAgent} tests.",
            "    \"\"\"",
            "",
            "",
            "class ContentDecoderAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ContentDecoderAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ContentDecoderAgent}",
            "        \"\"\"",
            "        return client.ContentDecoderAgent(self.agent, [])",
            "",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.buildAgentForWrapperTest(self.reactor)",
            "",
            "    def test_acceptHeaders(self):",
            "        \"\"\"",
            "        L{client.ContentDecoderAgent} sets the I{Accept-Encoding} header to the",
            "        names of the available decoder objects.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "",
            "        agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            req.headers.getRawHeaders(b\"accept-encoding\"), [b\"decoder1,decoder2\"]",
            "        )",
            "",
            "    def test_existingHeaders(self):",
            "        \"\"\"",
            "        If there are existing I{Accept-Encoding} fields,",
            "        L{client.ContentDecoderAgent} creates a new field for the decoders it",
            "        knows about.",
            "        \"\"\"",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"accept-encoding\": [b\"fizz\"]}",
            "        )",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        agent.request(b\"GET\", b\"http://example.com/foo\", headers=headers)",
            "",
            "        protocol = self.protocol",
            "",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertEqual(",
            "            list(sorted(req.headers.getAllRawHeaders())),",
            "            [",
            "                (b\"Accept-Encoding\", [b\"fizz\", b\"decoder1,decoder2\"]),",
            "                (b\"Foo\", [b\"bar\"]),",
            "                (b\"Host\", [b\"example.com\"]),",
            "            ],",
            "        )",
            "",
            "    def test_plainEncodingResponse(self):",
            "        \"\"\"",
            "        If the response is not encoded despited the request I{Accept-Encoding}",
            "        headers, L{client.ContentDecoderAgent} simply forwards the response.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", http_headers.Headers(), None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "    def test_unsupportedEncoding(self):",
            "        \"\"\"",
            "        If an encoding unknown to the L{client.ContentDecoderAgent} is found,",
            "        the response is unchanged.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"fizz\"]}",
            "        )",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        return deferred.addCallback(self.assertIdentical, response)",
            "",
            "    def test_unknownEncoding(self):",
            "        \"\"\"",
            "        When L{client.ContentDecoderAgent} encounters a decoder it doesn't know",
            "        about, it stops decoding even if another encoding is known afterwards.",
            "        \"\"\"",
            "        agent = client.ContentDecoderAgent(",
            "            self.agent, [(b\"decoder1\", Decoder1), (b\"decoder2\", Decoder2)]",
            "        )",
            "        deferred = agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"decoder1,fizz,decoder2\"]}",
            "        )",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        def check(result):",
            "            self.assertNotIdentical(response, result)",
            "            self.assertIsInstance(result, Decoder2)",
            "            self.assertEqual(",
            "                [b\"decoder1,fizz\"], result.headers.getRawHeaders(b\"content-encoding\")",
            "            )",
            "",
            "        return deferred.addCallback(check)",
            "",
            "",
            "class SimpleAgentProtocol(Protocol):",
            "    \"\"\"",
            "    A L{Protocol} to be used with an L{client.Agent} to receive data.",
            "",
            "    @ivar finished: L{Deferred} firing when C{connectionLost} is called.",
            "",
            "    @ivar made: L{Deferred} firing when C{connectionMade} is called.",
            "",
            "    @ivar received: C{list} of received data.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.made = Deferred()",
            "        self.finished = Deferred()",
            "        self.received = []",
            "",
            "    def connectionMade(self):",
            "        self.made.callback(None)",
            "",
            "    def connectionLost(self, reason):",
            "        self.finished.callback(None)",
            "",
            "    def dataReceived(self, data):",
            "        self.received.append(data)",
            "",
            "",
            "class ContentDecoderAgentWithGzipTests(TestCase, FakeReactorAndConnectMixin):",
            "    def setUp(self):",
            "        \"\"\"",
            "        Create an L{Agent} wrapped around a fake reactor.",
            "        \"\"\"",
            "        self.reactor = self.createReactor()",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        self.agent = client.ContentDecoderAgent(agent, [(b\"gzip\", client.GzipDecoder)])",
            "",
            "    def test_gzipEncodingResponse(self):",
            "        \"\"\"",
            "        If the response has a C{gzip} I{Content-Encoding} header,",
            "        L{GzipDecoder} wraps the response to return uncompressed data to the",
            "        user.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"gzip\"]}",
            "        )",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        compressor = zlib.compressobj(2, zlib.DEFLATED, 16 + zlib.MAX_WBITS)",
            "        data = (",
            "            compressor.compress(b\"x\" * 6)",
            "            + compressor.compress(b\"y\" * 4)",
            "            + compressor.flush()",
            "        )",
            "",
            "        def checkResponse(result):",
            "            self.assertNotIdentical(result, response)",
            "            self.assertEqual(result.version, (b\"HTTP\", 1, 1))",
            "            self.assertEqual(result.code, 200)",
            "            self.assertEqual(result.phrase, b\"OK\")",
            "            self.assertEqual(",
            "                list(result.headers.getAllRawHeaders()), [(b\"Foo\", [b\"bar\"])]",
            "            )",
            "            self.assertEqual(result.length, UNKNOWN_LENGTH)",
            "            self.assertRaises(AttributeError, getattr, result, \"unknown\")",
            "",
            "            response._bodyDataReceived(data[:5])",
            "            response._bodyDataReceived(data[5:])",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\" * 6 + b\"y\" * 4])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "    def test_brokenContent(self):",
            "        \"\"\"",
            "        If the data received by the L{GzipDecoder} isn't valid gzip-compressed",
            "        data, the call to C{deliverBody} fails with a C{zlib.error}.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers(",
            "            {b\"foo\": [b\"bar\"], b\"content-encoding\": [b\"gzip\"]}",
            "        )",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        response.length = 12",
            "        res.callback(response)",
            "",
            "        data = b\"not gzipped content\"",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(data)",
            "",
            "            result.deliverBody(Protocol())",
            "",
            "        deferred.addCallback(checkResponse)",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[0].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "    def test_flushData(self):",
            "        \"\"\"",
            "        When the connection with the server is lost, the gzip protocol calls",
            "        C{flush} on the zlib decompressor object to get uncompressed data which",
            "        may have been buffered.",
            "        \"\"\"",
            "",
            "        class decompressobj:",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return b\"x\"",
            "",
            "            def flush(self):",
            "                return b\"y\"",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, \"decompressobj\", oldDecompressObj)",
            "",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"content-encoding\": [b\"gzip\"]})",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(b\"data\")",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\", b\"y\"])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        return deferred",
            "",
            "    def test_flushError(self):",
            "        \"\"\"",
            "        If the C{flush} call in C{connectionLost} fails, the C{zlib.error}",
            "        exception is caught and turned into a L{ResponseFailed}.",
            "        \"\"\"",
            "",
            "        class decompressobj:",
            "            def __init__(self, wbits):",
            "                pass",
            "",
            "            def decompress(self, data):",
            "                return b\"x\"",
            "",
            "            def flush(self):",
            "                raise zlib.error()",
            "",
            "        oldDecompressObj = zlib.decompressobj",
            "        zlib.decompressobj = decompressobj",
            "        self.addCleanup(setattr, zlib, \"decompressobj\", oldDecompressObj)",
            "",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"content-encoding\": [b\"gzip\"]})",
            "        transport = StringTransport()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, transport)",
            "        res.callback(response)",
            "",
            "        def checkResponse(result):",
            "            response._bodyDataReceived(b\"data\")",
            "            response._bodyDataFinished()",
            "",
            "            protocol = SimpleAgentProtocol()",
            "            result.deliverBody(protocol)",
            "",
            "            self.assertEqual(protocol.received, [b\"x\", b\"y\"])",
            "            return defer.gatherResults([protocol.made, protocol.finished])",
            "",
            "        deferred.addCallback(checkResponse)",
            "",
            "        self.assertFailure(deferred, client.ResponseFailed)",
            "",
            "        def checkFailure(error):",
            "            error.reasons[1].trap(zlib.error)",
            "            self.assertIsInstance(error.response, Response)",
            "",
            "        return deferred.addCallback(checkFailure)",
            "",
            "",
            "class ProxyAgentTests(TestCase, FakeReactorAndConnectMixin, AgentTestsMixin):",
            "    \"\"\"",
            "    Tests for L{client.ProxyAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.ProxyAgent}",
            "        \"\"\"",
            "        return client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"127.0.0.1\", 1234), self.reactor",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = client.ProxyAgent(",
            "            TCP4ClientEndpoint(self.reactor, \"bar\", 5678), self.reactor",
            "        )",
            "        oldEndpoint = self.agent._proxyEndpoint",
            "        self.agent._proxyEndpoint = self.StubEndpoint(oldEndpoint, self)",
            "",
            "    def test_nonBytesMethod(self):",
            "        \"\"\"",
            "        L{ProxyAgent.request} raises L{TypeError} when the C{method} argument",
            "        isn't L{bytes}.",
            "        \"\"\"",
            "        self.assertRaises(TypeError, self.agent.request, \"GET\", b\"http://foo.example/\")",
            "",
            "    def test_proxyRequest(self):",
            "        \"\"\"",
            "        L{client.ProxyAgent} issues an HTTP request against the proxy, with the",
            "        full URI as path, when C{request} is called.",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"foo\": [b\"bar\"]})",
            "        # Just going to check the body for identity, so it doesn't need to be",
            "        # real.",
            "        body = object()",
            "        self.agent.request(b\"GET\", b\"http://example.com:1234/foo?bar\", headers, body)",
            "",
            "        host, port, factory = self.reactor.tcpClients.pop()[:3]",
            "        self.assertEqual(host, \"bar\")",
            "        self.assertEqual(port, 5678)",
            "",
            "        self.assertIsInstance(factory._wrappedFactory, client._HTTP11ClientFactory)",
            "",
            "        protocol = self.protocol",
            "",
            "        # The request should be issued.",
            "        self.assertEqual(len(protocol.requests), 1)",
            "        req, res = protocol.requests.pop()",
            "        self.assertIsInstance(req, Request)",
            "        self.assertEqual(req.method, b\"GET\")",
            "        self.assertEqual(req.uri, b\"http://example.com:1234/foo?bar\")",
            "        self.assertEqual(",
            "            req.headers,",
            "            http_headers.Headers({b\"foo\": [b\"bar\"], b\"host\": [b\"example.com:1234\"]}),",
            "        )",
            "        self.assertIdentical(req.bodyProducer, body)",
            "",
            "    def test_nonPersistent(self):",
            "        \"\"\"",
            "        C{ProxyAgent} connections are not persistent by default.",
            "        \"\"\"",
            "        self.assertEqual(self.agent._pool.persistent, False)",
            "",
            "    def test_connectUsesConnectionPool(self):",
            "        \"\"\"",
            "        When a connection is made by the C{ProxyAgent}, it uses its pool's",
            "        C{getConnection} method to do so, with the endpoint it was constructed",
            "        with and a key of C{(\"http-proxy\", endpoint)}.",
            "        \"\"\"",
            "        endpoint = DummyEndpoint()",
            "",
            "        class DummyPool:",
            "            connected = False",
            "            persistent = False",
            "",
            "            def getConnection(this, key, ep):",
            "                this.connected = True",
            "                self.assertIdentical(ep, endpoint)",
            "                # The key is *not* tied to the final destination, but only to",
            "                # the address of the proxy, since that's where *we* are",
            "                # connecting:",
            "                self.assertEqual(key, (\"http-proxy\", endpoint))",
            "                return defer.succeed(StubHTTPProtocol())",
            "",
            "        pool = DummyPool()",
            "        agent = client.ProxyAgent(endpoint, self.reactor, pool=pool)",
            "        self.assertIdentical(pool, agent._pool)",
            "",
            "        agent.request(b\"GET\", b\"http://foo/\")",
            "        self.assertEqual(agent._pool.connected, True)",
            "",
            "",
            "SENSITIVE_HEADERS = [",
            "    b\"authorization\",",
            "    b\"cookie\",",
            "    b\"cookie2\",",
            "    b\"proxy-authorization\",",
            "    b\"www-authenticate\",",
            "]",
            "",
            "",
            "class _RedirectAgentTestsMixin(testMixinClass):",
            "    \"\"\"",
            "    Test cases mixin for L{RedirectAgentTests} and",
            "    L{BrowserLikeRedirectAgentTests}.",
            "    \"\"\"",
            "",
            "    agent: IAgent",
            "    reactor: MemoryReactorClock",
            "    protocol: StubHTTPProtocol",
            "",
            "    def test_noRedirect(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} behaves like L{client.Agent} if the response",
            "        doesn't contain a redirect.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        self.assertEqual(0, len(self.protocol.requests))",
            "        result = self.successResultOf(deferred)",
            "        self.assertIdentical(response, result)",
            "        self.assertIdentical(result.previousResponse, None)",
            "",
            "    def _testRedirectDefault(",
            "        self,",
            "        code: int,",
            "        crossScheme: bool = False,",
            "        crossDomain: bool = False,",
            "        crossPort: bool = False,",
            "        requestHeaders: Optional[Headers] = None,",
            "    ) -> Request:",
            "        \"\"\"",
            "        When getting a redirect, L{client.RedirectAgent} follows the URL",
            "        specified in the L{Location} header field and make a new request.",
            "",
            "        @param code: HTTP status code.",
            "        \"\"\"",
            "        startDomain = b\"example.com\"",
            "        startScheme = b\"https\" if ssl is not None else b\"http\"",
            "        startPort = 80 if startScheme == b\"http\" else 443",
            "        self.agent.request(",
            "            b\"GET\", startScheme + b\"://\" + startDomain + b\"/foo\", headers=requestHeaders",
            "        )",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(EXAMPLE_COM_IP, host)",
            "        self.assertEqual(startPort, port)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        # If possible (i.e.: TLS support is present), run the test with a",
            "        # cross-scheme redirect to verify that the scheme is honored; if not,",
            "        # let's just make sure it works at all.",
            "",
            "        targetScheme = startScheme",
            "        targetDomain = startDomain",
            "        targetPort = startPort",
            "",
            "        if crossScheme:",
            "            if ssl is None:",
            "                raise SkipTest(",
            "                    \"Cross-scheme redirects can't be tested without TLS support.\"",
            "                )",
            "            targetScheme = b\"https\" if startScheme == b\"http\" else b\"http\"",
            "            targetPort = 443 if startPort == 80 else 80",
            "",
            "        portSyntax = b\"\"",
            "        if crossPort:",
            "            targetPort = 8443",
            "            portSyntax = b\":8443\"",
            "        targetDomain = b\"example.net\" if crossDomain else startDomain",
            "        locationValue = targetScheme + b\"://\" + targetDomain + portSyntax + b\"/bar\"",
            "        headers = http_headers.Headers({b\"location\": [locationValue]})",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(b\"/bar\", req2.uri)",
            "",
            "        host, port = self.reactor.tcpClients.pop()[:2]",
            "        self.assertEqual(EXAMPLE_NET_IP if crossDomain else EXAMPLE_COM_IP, host)",
            "        self.assertEqual(targetPort, port)",
            "        return req2",
            "",
            "    def test_redirect301(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 301.",
            "        \"\"\"",
            "        self._testRedirectDefault(301)",
            "",
            "    def test_redirect301Scheme(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows cross-scheme redirects.",
            "        \"\"\"",
            "        self._testRedirectDefault(",
            "            301,",
            "            crossScheme=True,",
            "        )",
            "",
            "    def test_redirect302(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 302.",
            "        \"\"\"",
            "        self._testRedirectDefault(302)",
            "",
            "    def test_redirect307(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 307.",
            "        \"\"\"",
            "        self._testRedirectDefault(307)",
            "",
            "    def test_redirect308(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} follows redirects on status code 308.",
            "        \"\"\"",
            "        self._testRedirectDefault(308)",
            "",
            "    def _sensitiveHeadersTest(",
            "        self, expectedHostHeader: bytes = b\"example.com\", **crossKwargs: bool",
            "    ) -> None:",
            "        \"\"\"",
            "        L{client.RedirectAgent} scrubs sensitive headers when redirecting",
            "        between differing origins.",
            "        \"\"\"",
            "        sensitiveHeaderValues = {",
            "            b\"authorization\": [b\"sensitive-authnz\"],",
            "            b\"cookie\": [b\"sensitive-cookie-data\"],",
            "            b\"cookie2\": [b\"sensitive-cookie2-data\"],",
            "            b\"proxy-authorization\": [b\"sensitive-proxy-auth\"],",
            "            b\"wWw-auThentiCate\": [b\"sensitive-authn\"],",
            "            b\"x-custom-sensitive\": [b\"sensitive-custom\"],",
            "        }",
            "        otherHeaderValues = {b\"x-random-header\": [b\"x-random-value\"]}",
            "        allHeaders = Headers({**sensitiveHeaderValues, **otherHeaderValues})",
            "        redirected = self._testRedirectDefault(301, requestHeaders=allHeaders)",
            "",
            "        def normHeaders(headers: Headers) -> dict:",
            "            return {k.lower(): v for (k, v) in headers.getAllRawHeaders()}",
            "",
            "        sameOriginHeaders = normHeaders(redirected.headers)",
            "        self.assertEquals(",
            "            sameOriginHeaders,",
            "            {",
            "                b\"host\": [b\"example.com\"],",
            "                **normHeaders(allHeaders),",
            "            },",
            "        )",
            "",
            "        redirectedElsewhere = self._testRedirectDefault(",
            "            301,",
            "            **crossKwargs,",
            "            requestHeaders=Headers({**sensitiveHeaderValues, **otherHeaderValues}),",
            "        )",
            "        otherOriginHeaders = normHeaders(redirectedElsewhere.headers)",
            "        self.assertEquals(",
            "            otherOriginHeaders,",
            "            {",
            "                b\"host\": [expectedHostHeader],",
            "                **normHeaders(Headers(otherHeaderValues)),",
            "            },",
            "        )",
            "",
            "    def test_crossDomainHeaders(self) -> None:",
            "        \"\"\"",
            "        L{client.RedirectAgent} scrubs sensitive headers when redirecting",
            "        between differing domains.",
            "        \"\"\"",
            "        self._sensitiveHeadersTest(crossDomain=True, expectedHostHeader=b\"example.net\")",
            "",
            "    def test_crossPortHeaders(self) -> None:",
            "        \"\"\"",
            "        L{client.RedirectAgent} scrubs sensitive headers when redirecting",
            "        between differing ports.",
            "        \"\"\"",
            "        self._sensitiveHeadersTest(",
            "            crossPort=True, expectedHostHeader=b\"example.com:8443\"",
            "        )",
            "",
            "    def test_crossSchemeHeaders(self) -> None:",
            "        \"\"\"",
            "        L{client.RedirectAgent} scrubs sensitive headers when redirecting",
            "        between differing schemes.",
            "        \"\"\"",
            "        self._sensitiveHeadersTest(crossScheme=True)",
            "",
            "    def _testRedirectToGet(self, code, method):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting",
            "        a redirect on a non-I{GET} request.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        self.agent.request(method, b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(b\"/bar\", req2.uri)",
            "",
            "    def test_redirect303(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} changes the method to I{GET} when getting a 303",
            "        redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(303, b\"POST\")",
            "",
            "    def test_noLocationField(self):",
            "        \"\"\"",
            "        If no L{Location} header field is found when getting a redirect,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping a",
            "        L{error.RedirectWithNoLocation} exception.",
            "        \"\"\"",
            "        deferred = self.agent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), 301, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.RedirectWithNoLocation)",
            "        self.assertEqual(b\"http://example.com/foo\", fail.value.reasons[0].value.uri)",
            "        self.assertEqual(301, fail.value.response.code)",
            "",
            "    def _testPageRedirectFailure(self, code, method):",
            "        \"\"\"",
            "        When getting a redirect on an unsupported request method,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "",
            "        @param code: HTTP status code.",
            "",
            "        @param method: HTTP request method.",
            "        \"\"\"",
            "        deferred = self.agent.request(method, b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers()",
            "        response = Response((b\"HTTP\", 1, 1), code, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "        fail.value.reasons[0].trap(error.PageRedirect)",
            "        self.assertEqual(",
            "            b\"http://example.com/foo\", fail.value.reasons[0].value.location",
            "        )",
            "        self.assertEqual(code, fail.value.response.code)",
            "",
            "    def test_307OnPost(self):",
            "        \"\"\"",
            "        When getting a 307 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(307, b\"POST\")",
            "",
            "    def test_redirectLimit(self):",
            "        \"\"\"",
            "        If the limit of redirects specified to L{client.RedirectAgent} is",
            "        reached, the deferred fires with L{ResponseFailed} error wrapping",
            "        a L{InfiniteRedirection} exception.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent, 1)",
            "",
            "        deferred = redirectAgent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        response = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "",
            "        response2 = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res2.callback(response2)",
            "",
            "        fail = self.failureResultOf(deferred, client.ResponseFailed)",
            "",
            "        fail.value.reasons[0].trap(error.InfiniteRedirection)",
            "        self.assertEqual(",
            "            b\"http://example.com/foo\", fail.value.reasons[0].value.location",
            "        )",
            "        self.assertEqual(302, fail.value.response.code)",
            "",
            "    def _testRedirectURI(self, uri, location, finalURI):",
            "        \"\"\"",
            "        When L{client.RedirectAgent} encounters a relative redirect I{URI}, it",
            "        is resolved against the request I{URI} before following the redirect.",
            "",
            "        @param uri: Request URI.",
            "",
            "        @param location: I{Location} header redirect URI.",
            "",
            "        @param finalURI: Expected final URI.",
            "        \"\"\"",
            "        self.agent.request(b\"GET\", uri)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [location]})",
            "        response = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        req2, res2 = self.protocol.requests.pop()",
            "        self.assertEqual(b\"GET\", req2.method)",
            "        self.assertEqual(finalURI, req2.absoluteURI)",
            "",
            "    def test_relativeURI(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving query strings.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"baz\", b\"http://example.com/foo/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"/baz\", b\"http://example.com/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"/baz?a\", b\"http://example.com/baz?a\"",
            "        )",
            "",
            "    def test_relativeURIPreserveFragments(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows relative I{URI}s in",
            "        redirects, preserving fragments in way that complies with the HTTP 1.1",
            "        bis draft.",
            "",
            "        @see: U{https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-22#section-7.1.2}",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar#frag\",",
            "            b\"/baz?a\",",
            "            b\"http://example.com/baz?a#frag\",",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\",",
            "            b\"/baz?a#frag2\",",
            "            b\"http://example.com/baz?a#frag2\",",
            "        )",
            "",
            "    def test_relativeURISchemeRelative(self):",
            "        \"\"\"",
            "        L{client.RedirectAgent} resolves and follows scheme relative I{URI}s in",
            "        redirects, replacing the hostname and port when required.",
            "        \"\"\"",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"//foo.com/baz\", b\"http://foo.com/baz\"",
            "        )",
            "        self._testRedirectURI(",
            "            b\"http://example.com/foo/bar\", b\"//foo.com:81/baz\", b\"http://foo.com:81/baz\"",
            "        )",
            "",
            "    def test_responseHistory(self):",
            "        \"\"\"",
            "        L{Response.response} references the previous L{Response} from",
            "        a redirect, or L{None} if there was no previous response.",
            "        \"\"\"",
            "        agent = self.buildAgentForWrapperTest(self.reactor)",
            "        redirectAgent = client.RedirectAgent(agent)",
            "",
            "        deferred = redirectAgent.request(b\"GET\", b\"http://example.com/foo\")",
            "",
            "        redirectReq, redirectRes = self.protocol.requests.pop()",
            "",
            "        headers = http_headers.Headers({b\"location\": [b\"http://example.com/bar\"]})",
            "        redirectResponse = Response((b\"HTTP\", 1, 1), 302, b\"OK\", headers, None)",
            "        redirectRes.callback(redirectResponse)",
            "",
            "        req, res = self.protocol.requests.pop()",
            "",
            "        response = Response((b\"HTTP\", 1, 1), 200, b\"OK\", headers, None)",
            "        res.callback(response)",
            "",
            "        finalResponse = self.successResultOf(deferred)",
            "        self.assertIdentical(finalResponse.previousResponse, redirectResponse)",
            "        self.assertIdentical(redirectResponse.previousResponse, None)",
            "",
            "",
            "class RedirectAgentTests(",
            "    FakeReactorAndConnectMixin,",
            "    _RedirectAgentTestsMixin,",
            "    AgentTestsMixin,",
            "    runtimeTestCase,",
            "):",
            "    \"\"\"",
            "    Tests for L{client.RedirectAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.RedirectAgent}",
            "        \"\"\"",
            "        return client.RedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor),",
            "            sensitiveHeaderNames=[b\"X-Custom-sensitive\"],",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_301OnPost(self):",
            "        \"\"\"",
            "        When getting a 301 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(301, b\"POST\")",
            "",
            "    def test_302OnPost(self):",
            "        \"\"\"",
            "        When getting a 302 redirect on a I{POST} request,",
            "        L{client.RedirectAgent} fails with a L{ResponseFailed} error wrapping",
            "        a L{error.PageRedirect} exception.",
            "        \"\"\"",
            "        self._testPageRedirectFailure(302, b\"POST\")",
            "",
            "",
            "class BrowserLikeRedirectAgentTests(",
            "    FakeReactorAndConnectMixin,",
            "    _RedirectAgentTestsMixin,",
            "    AgentTestsMixin,",
            "    runtimeTestCase,",
            "):",
            "    \"\"\"",
            "    Tests for L{client.BrowserLikeRedirectAgent}.",
            "    \"\"\"",
            "",
            "    def makeAgent(self):",
            "        \"\"\"",
            "        @return: a new L{twisted.web.client.BrowserLikeRedirectAgent}",
            "        \"\"\"",
            "        return client.BrowserLikeRedirectAgent(",
            "            self.buildAgentForWrapperTest(self.reactor),",
            "            sensitiveHeaderNames=[b\"x-Custom-sensitive\"],",
            "        )",
            "",
            "    def setUp(self):",
            "        self.reactor = self.createReactor()",
            "        self.agent = self.makeAgent()",
            "",
            "    def test_redirectToGet301(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(301, b\"POST\")",
            "",
            "    def test_redirectToGet302(self):",
            "        \"\"\"",
            "        L{client.BrowserLikeRedirectAgent} changes the method to I{GET} when",
            "        getting a 302 redirect on a I{POST} request.",
            "        \"\"\"",
            "        self._testRedirectToGet(302, b\"POST\")",
            "",
            "",
            "class AbortableStringTransport(StringTransport):",
            "    \"\"\"",
            "    A version of L{StringTransport} that supports C{abortConnection}.",
            "    \"\"\"",
            "",
            "    # This should be replaced by a common version in #6530.",
            "    aborting = False",
            "",
            "    def abortConnection(self):",
            "        \"\"\"",
            "        A testable version of the C{ITCPTransport.abortConnection} method.",
            "",
            "        Since this is a special case of closing the connection,",
            "        C{loseConnection} is also called.",
            "        \"\"\"",
            "        self.aborting = True",
            "        self.loseConnection()",
            "",
            "",
            "class DummyResponse:",
            "    \"\"\"",
            "    Fake L{IResponse} for testing readBody that captures the protocol passed to",
            "    deliverBody and uses it to make a connection with a transport.",
            "",
            "    @ivar protocol: After C{deliverBody} is called, the protocol it was called",
            "        with.",
            "",
            "    @ivar transport: An instance created by calling C{transportFactory} which",
            "        is used by L{DummyResponse.protocol} to make a connection.",
            "    \"\"\"",
            "",
            "    code = 200",
            "    phrase = b\"OK\"",
            "",
            "    def __init__(self, headers=None, transportFactory=AbortableStringTransport):",
            "        \"\"\"",
            "        @param headers: The headers for this response.  If L{None}, an empty",
            "            L{Headers} instance will be used.",
            "        @type headers: L{Headers}",
            "",
            "        @param transportFactory: A callable used to construct the transport.",
            "        \"\"\"",
            "        if headers is None:",
            "            headers = Headers()",
            "        self.headers = headers",
            "        self.transport = transportFactory()",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Record the given protocol and use it to make a connection with",
            "        L{DummyResponse.transport}.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "        self.protocol.makeConnection(self.transport)",
            "",
            "",
            "class AlreadyCompletedDummyResponse(DummyResponse):",
            "    \"\"\"",
            "    A dummy response that has already had its transport closed.",
            "    \"\"\"",
            "",
            "    def deliverBody(self, protocol):",
            "        \"\"\"",
            "        Make the connection, then remove the transport.",
            "        \"\"\"",
            "        self.protocol = protocol",
            "        self.protocol.makeConnection(self.transport)",
            "        self.protocol.transport = None",
            "",
            "",
            "class ReadBodyTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{client.readBody}",
            "    \"\"\"",
            "",
            "    def test_success(self):",
            "        \"\"\"",
            "        L{client.readBody} returns a L{Deferred} which fires with the complete",
            "        body of the L{IResponse} provider passed to it.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.dataReceived(b\"second\")",
            "        response.protocol.connectionLost(Failure(ResponseDone()))",
            "        self.assertEqual(self.successResultOf(d), b\"firstsecond\")",
            "",
            "    def test_cancel(self):",
            "        \"\"\"",
            "        When cancelling the L{Deferred} returned by L{client.readBody}, the",
            "        connection to the server will be aborted.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        deferred = client.readBody(response)",
            "        deferred.cancel()",
            "        self.failureResultOf(deferred, defer.CancelledError)",
            "        self.assertTrue(response.transport.aborting)",
            "",
            "    def test_withPotentialDataLoss(self):",
            "        \"\"\"",
            "        If the full body of the L{IResponse} passed to L{client.readBody} is",
            "        not definitely received, the L{Deferred} returned by L{client.readBody}",
            "        fires with a L{Failure} wrapping L{client.PartialDownloadError} with",
            "        the content that was received.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.dataReceived(b\"second\")",
            "        response.protocol.connectionLost(Failure(PotentialDataLoss()))",
            "        failure = self.failureResultOf(d)",
            "        failure.trap(client.PartialDownloadError)",
            "        self.assertEqual(",
            "            {",
            "                \"status\": failure.value.status,",
            "                \"message\": failure.value.message,",
            "                \"body\": failure.value.response,",
            "            },",
            "            {",
            "                \"status\": b\"200\",",
            "                \"message\": b\"OK\",",
            "                \"body\": b\"firstsecond\",",
            "            },",
            "        )",
            "",
            "    def test_otherErrors(self):",
            "        \"\"\"",
            "        If there is an exception other than L{client.PotentialDataLoss} while",
            "        L{client.readBody} is collecting the response body, the L{Deferred}",
            "        returned by {client.readBody} fires with that exception.",
            "        \"\"\"",
            "        response = DummyResponse()",
            "        d = client.readBody(response)",
            "        response.protocol.dataReceived(b\"first\")",
            "        response.protocol.connectionLost(Failure(ConnectionLost(\"mystery problem\")))",
            "        reason = self.failureResultOf(d)",
            "        reason.trap(ConnectionLost)",
            "        self.assertEqual(reason.value.args, (\"mystery problem\",))",
            "",
            "    def test_deprecatedTransport(self):",
            "        \"\"\"",
            "        Calling L{client.readBody} with a transport that does not implement",
            "        L{twisted.internet.interfaces.ITCPTransport} produces a deprecation",
            "        warning, but no exception when cancelling.",
            "        \"\"\"",
            "        response = DummyResponse(transportFactory=StringTransport)",
            "        response.transport.abortConnection = None",
            "        d = self.assertWarns(",
            "            DeprecationWarning,",
            "            \"Using readBody with a transport that does not have an \"",
            "            \"abortConnection method\",",
            "            __file__,",
            "            lambda: client.readBody(response),",
            "        )",
            "        d.cancel()",
            "        self.failureResultOf(d, defer.CancelledError)",
            "",
            "    def test_deprecatedTransportNoWarning(self):",
            "        \"\"\"",
            "        Calling L{client.readBody} with a response that has already had its",
            "        transport closed (eg. for a very small request) will not trigger a",
            "        deprecation warning.",
            "        \"\"\"",
            "        response = AlreadyCompletedDummyResponse()",
            "        client.readBody(response)",
            "",
            "        warnings = self.flushWarnings()",
            "        self.assertEqual(len(warnings), 0)",
            "",
            "",
            "@skipIf(not sslPresent, \"SSL not present, cannot run SSL tests.\")",
            "class HostnameCachingHTTPSPolicyTests(TestCase):",
            "    def test_cacheIsUsed(self):",
            "        \"\"\"",
            "        Verify that the connection creator is added to the",
            "        policy's cache, and that it is reused on subsequent calls",
            "        to creatorForNetLoc.",
            "",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy)",
            "        creator = policy.creatorForNetloc(b\"foo\", 1589)",
            "        self.assertTrue(trustRoot.called)",
            "        trustRoot.called = False",
            "        self.assertEquals(1, len(policy._cache))",
            "        connection = creator.clientConnectionForTLS(None)",
            "        self.assertIs(trustRoot.context, connection.get_context())",
            "",
            "        policy.creatorForNetloc(b\"foo\", 1589)",
            "        self.assertFalse(trustRoot.called)",
            "",
            "    def test_cacheRemovesOldest(self):",
            "        \"\"\"",
            "        Verify that when the cache is full, and a new entry is added,",
            "        the oldest entry is removed.",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy)",
            "        for i in range(0, 20):",
            "            hostname = \"host\" + str(i)",
            "            policy.creatorForNetloc(hostname.encode(\"ascii\"), 8675)",
            "",
            "        # Force host0, which was the first, to be the most recently used",
            "        host0 = \"host0\"",
            "        policy.creatorForNetloc(host0.encode(\"ascii\"), 309)",
            "        self.assertIn(host0, policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        hostn = \"new\"",
            "        policy.creatorForNetloc(hostn.encode(\"ascii\"), 309)",
            "",
            "        host1 = \"host1\"",
            "        self.assertNotIn(host1, policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        self.assertIn(hostn, policy._cache)",
            "        self.assertIn(host0, policy._cache)",
            "",
            "        # Accessing an item repeatedly does not corrupt the LRU.",
            "        for _ in range(20):",
            "            policy.creatorForNetloc(host0.encode(\"ascii\"), 8675)",
            "",
            "        hostNPlus1 = \"new1\"",
            "",
            "        policy.creatorForNetloc(hostNPlus1.encode(\"ascii\"), 800)",
            "",
            "        self.assertNotIn(\"host2\", policy._cache)",
            "        self.assertEquals(20, len(policy._cache))",
            "",
            "        self.assertIn(hostNPlus1, policy._cache)",
            "        self.assertIn(hostn, policy._cache)",
            "        self.assertIn(host0, policy._cache)",
            "",
            "    def test_changeCacheSize(self):",
            "        \"\"\"",
            "        Verify that changing the cache size results in a policy that",
            "        respects the new cache size and not the default.",
            "",
            "        \"\"\"",
            "        trustRoot = CustomOpenSSLTrustRoot()",
            "        wrappedPolicy = BrowserLikePolicyForHTTPS(trustRoot=trustRoot)",
            "        policy = HostnameCachingHTTPSPolicy(wrappedPolicy, cacheSize=5)",
            "        for i in range(0, 5):",
            "            hostname = \"host\" + str(i)",
            "            policy.creatorForNetloc(hostname.encode(\"ascii\"), 8675)",
            "",
            "        first = \"host0\"",
            "        self.assertIn(first, policy._cache)",
            "        self.assertEquals(5, len(policy._cache))",
            "",
            "        hostn = \"new\"",
            "        policy.creatorForNetloc(hostn.encode(\"ascii\"), 309)",
            "        self.assertNotIn(first, policy._cache)",
            "        self.assertEquals(5, len(policy._cache))",
            "",
            "        self.assertIn(hostn, policy._cache)",
            "",
            "",
            "class RequestMethodInjectionTests(",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        client.Request(",
            "            method=method,",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=http_headers.Headers(),",
            "            bodyProducer=None,",
            "        )",
            "",
            "",
            "class RequestWriteToMethodInjectionTests(",
            "    MethodInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request.writeTo} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousMethod(self, method):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{MethodInjectionTestsMixin}",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"Host\": [b\"twisted.invalid\"]})",
            "        req = client.Request(",
            "            method=b\"GET\",",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=headers,",
            "            bodyProducer=None,",
            "        )",
            "        req.method = method",
            "        req.writeTo(StringTransport())",
            "",
            "",
            "class RequestURIInjectionTests(",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request} against HTTP URI injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided URI.",
            "",
            "        @param method: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        client.Request(",
            "            method=b\"GET\",",
            "            uri=uri,",
            "            headers=http_headers.Headers(),",
            "            bodyProducer=None,",
            "        )",
            "",
            "",
            "class RequestWriteToURIInjectionTests(",
            "    URIInjectionTestsMixin,",
            "    SynchronousTestCase,",
            "):",
            "    \"\"\"",
            "    Test L{client.Request.writeTo} against HTTP method injections.",
            "    \"\"\"",
            "",
            "    def attemptRequestWithMaliciousURI(self, uri):",
            "        \"\"\"",
            "        Attempt a request with the provided method.",
            "",
            "        @param method: see L{URIInjectionTestsMixin}",
            "        \"\"\"",
            "        headers = http_headers.Headers({b\"Host\": [b\"twisted.invalid\"]})",
            "        req = client.Request(",
            "            method=b\"GET\",",
            "            uri=b\"http://twisted.invalid\",",
            "            headers=headers,",
            "            bodyProducer=None,",
            "        )",
            "        req.uri = uri",
            "        req.writeTo(StringTransport())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "111": [
                "StubHTTPProtocol",
                "__init__"
            ],
            "112": [
                "StubHTTPProtocol",
                "__init__"
            ],
            "2590": [
                "_RedirectAgentTestsMixin"
            ],
            "2614": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2621": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2625": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2629": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2632": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2633": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2634": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2635": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2636": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2637": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2638": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2639": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2648": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2649": [
                "_RedirectAgentTestsMixin",
                "_testRedirectDefault"
            ],
            "2881": [
                "RedirectAgentTests"
            ],
            "2891": [
                "RedirectAgentTests",
                "makeAgent"
            ],
            "2915": [
                "BrowserLikeRedirectAgentTests"
            ],
            "2926": [
                "BrowserLikeRedirectAgentTests",
                "makeAgent"
            ]
        },
        "addLocation": []
    }
}