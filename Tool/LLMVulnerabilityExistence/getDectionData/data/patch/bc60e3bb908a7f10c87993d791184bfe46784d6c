{
    "openstackclient/identity/common.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         raise exceptions.CommandError(msg % name_type_or_id)"
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+def get_resource_by_id(manager, resource_id):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    \"\"\"Get resource by ID"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    Raises CommandError if the resource is not found"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    try:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        return manager.get(resource_id)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+    except identity_exc.NotFound:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        msg = _(\"Resource with id {} not found\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        raise exceptions.CommandError(msg.format(resource_id))"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " def _get_token_resource(client, resource, parsed_name, parsed_domain=None):"
            },
            "16": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     \"\"\"Peek into the user's auth token to get resource IDs"
            },
            "17": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#   Copyright 2012-2013 OpenStack Foundation",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "\"\"\"Common identity code\"\"\"",
            "",
            "from keystoneclient import exceptions as identity_exc",
            "from keystoneclient.v3 import domains",
            "from keystoneclient.v3 import groups",
            "from keystoneclient.v3 import projects",
            "from keystoneclient.v3 import users",
            "from osc_lib import exceptions",
            "from osc_lib import utils",
            "",
            "from openstackclient.i18n import _",
            "",
            "",
            "def find_service_in_list(service_list, service_id):",
            "    \"\"\"Find a service by id in service list.\"\"\"",
            "",
            "    for service in service_list:",
            "        if service.id == service_id:",
            "            return service",
            "    raise exceptions.CommandError(",
            "        \"No service with a type, name or ID of '%s' exists.\" % service_id",
            "    )",
            "",
            "",
            "def find_service(identity_client, name_type_or_id):",
            "    \"\"\"Find a service by id, name or type.\"\"\"",
            "",
            "    try:",
            "        # search for service id",
            "        return identity_client.services.get(name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        # ignore NotFound exception, raise others",
            "        pass",
            "",
            "    try:",
            "        # search for service name",
            "        return identity_client.services.find(name=name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        pass",
            "    except identity_exc.NoUniqueMatch:",
            "        msg = _(",
            "            \"Multiple service matches found for '%s', \"",
            "            \"use an ID to be more specific.\"",
            "        )",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "    try:",
            "        # search for service type",
            "        return identity_client.services.find(type=name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        msg = _(\"No service with a type, name or ID of '%s' exists.\")",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "    except identity_exc.NoUniqueMatch:",
            "        msg = _(",
            "            \"Multiple service matches found for '%s', \"",
            "            \"use an ID to be more specific.\"",
            "        )",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "",
            "def get_resource(manager, name_type_or_id):",
            "    # NOTE (vishakha): Due to bug #1799153 and for any another related case",
            "    # where GET resource API does not support the filter by name,",
            "    # osc_lib.utils.find_resource() method cannot be used because that method",
            "    # try to fall back to list all the resource if requested resource cannot",
            "    # be get via name. Which ends up with NoUniqueMatch error.",
            "    # This new function is the replacement for osc_lib.utils.find_resource()",
            "    # for resources does not support GET by name.",
            "    # For example: identity GET /regions.",
            "    \"\"\"Find a resource by id or name.\"\"\"",
            "",
            "    try:",
            "        return manager.get(name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        # raise NotFound exception",
            "        msg = _(\"No resource with name or id of '%s' exists\")",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "",
            "def _get_token_resource(client, resource, parsed_name, parsed_domain=None):",
            "    \"\"\"Peek into the user's auth token to get resource IDs",
            "",
            "    Look into a user's token to try and find the ID of a domain, project or",
            "    user, when given the name. Typically non-admin users will interact with",
            "    the CLI using names. However, by default, keystone does not allow look up",
            "    by name since it would involve listing all entities. Instead opt to use",
            "    the correct ID (from the token) instead.",
            "    :param client: An identity client",
            "    :param resource: A resource to look at in the token, this may be `domain`,",
            "                     `project_domain`, `user_domain`, `project`, or `user`.",
            "    :param parsed_name: This is input from parsed_args that the user is hoping",
            "                        to find in the token.",
            "    :param parsed_domain: This is domain filter from parsed_args that used to",
            "                          filter the results.",
            "",
            "    :returns: The ID of the resource from the token, or the original value from",
            "              parsed_args if it does not match.",
            "    \"\"\"",
            "",
            "    try:",
            "        token = client.auth.client.get_token()",
            "        token_data = client.tokens.get_token_data(token)",
            "        token_dict = token_data['token']",
            "",
            "        # NOTE(stevemar): If domain is passed, just look at the project domain.",
            "        if resource == 'domain':",
            "            token_dict = token_dict['project']",
            "        obj = token_dict[resource]",
            "",
            "        # user/project under different domain may has a same name",
            "        if parsed_domain and parsed_domain not in obj['domain'].values():",
            "            return parsed_name",
            "        if isinstance(obj, list):",
            "            for item in obj:",
            "                if item['name'] == parsed_name:",
            "                    return item['id']",
            "                if item['id'] == parsed_name:",
            "                    return parsed_name",
            "            return parsed_name",
            "        return obj['id'] if obj['name'] == parsed_name else parsed_name",
            "    # diaper defense in case parsing the token fails",
            "    except Exception:  # noqa",
            "        return parsed_name",
            "",
            "",
            "def _get_domain_id_if_requested(identity_client, domain_name_or_id):",
            "    if not domain_name_or_id:",
            "        return None",
            "    domain = find_domain(identity_client, domain_name_or_id)",
            "    return domain.id",
            "",
            "",
            "def find_domain(identity_client, name_or_id):",
            "    return _find_identity_resource(",
            "        identity_client.domains, name_or_id, domains.Domain",
            "    )",
            "",
            "",
            "def find_group(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.groups, name_or_id, groups.Group",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.groups,",
            "            name_or_id,",
            "            groups.Group,",
            "            domain_id=domain_id,",
            "        )",
            "",
            "",
            "def find_project(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.projects, name_or_id, projects.Project",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.projects,",
            "            name_or_id,",
            "            projects.Project,",
            "            domain_id=domain_id,",
            "        )",
            "",
            "",
            "def find_user(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.users, name_or_id, users.User",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.users, name_or_id, users.User, domain_id=domain_id",
            "        )",
            "",
            "",
            "def _find_identity_resource(",
            "    identity_client_manager, name_or_id, resource_type, **kwargs",
            "):",
            "    \"\"\"Find a specific identity resource.",
            "",
            "    Using keystoneclient's manager, attempt to find a specific resource by its",
            "    name or ID. If Forbidden to find the resource (a common case if the user",
            "    does not have permission), then return the resource by creating a local",
            "    instance of keystoneclient's Resource.",
            "",
            "    The parameter identity_client_manager is a keystoneclient manager,",
            "    for example: keystoneclient.v3.users or keystoneclient.v3.projects.",
            "",
            "    The parameter resource_type is a keystoneclient resource, for example:",
            "    keystoneclient.v3.users.User or keystoneclient.v3.projects.Project.",
            "",
            "    :param identity_client_manager: the manager that contains the resource",
            "    :type identity_client_manager: `keystoneclient.base.CrudManager`",
            "    :param name_or_id: the resources's name or ID",
            "    :type name_or_id: string",
            "    :param resource_type: class that represents the resource type",
            "    :type resource_type: `keystoneclient.base.Resource`",
            "",
            "    :returns: the resource in question",
            "    :rtype: `keystoneclient.base.Resource`",
            "",
            "    \"\"\"",
            "",
            "    try:",
            "        identity_resource = utils.find_resource(",
            "            identity_client_manager, name_or_id, **kwargs",
            "        )",
            "        if identity_resource is not None:",
            "            return identity_resource",
            "    except (exceptions.Forbidden, identity_exc.Forbidden):",
            "        pass",
            "",
            "    return resource_type(None, {'id': name_or_id, 'name': name_or_id})",
            "",
            "",
            "def get_immutable_options(parsed_args):",
            "    options = {}",
            "    if parsed_args.immutable:",
            "        options['immutable'] = True",
            "    if parsed_args.no_immutable:",
            "        options['immutable'] = False",
            "    return options",
            "",
            "",
            "def add_user_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--user-domain',",
            "        metavar='<user-domain>',",
            "        help=_(",
            "            'Domain the user belongs to (name or ID). '",
            "            'This can be used in case collisions between user names '",
            "            'exist.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_group_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--group-domain',",
            "        metavar='<group-domain>',",
            "        help=_(",
            "            'Domain the group belongs to (name or ID). '",
            "            'This can be used in case collisions between group names '",
            "            'exist.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_project_domain_option_to_parser(parser, enhance_help=lambda _h: _h):",
            "    parser.add_argument(",
            "        '--project-domain',",
            "        metavar='<project-domain>',",
            "        help=enhance_help(",
            "            _(",
            "                'Domain the project belongs to (name or ID). This '",
            "                'can be used in case collisions between project '",
            "                'names exist.'",
            "            )",
            "        ),",
            "    )",
            "",
            "",
            "def add_role_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--role-domain',",
            "        metavar='<role-domain>',",
            "        help=_(",
            "            'Domain the role belongs to (name or ID). '",
            "            'This must be specified when the name of a domain specific '",
            "            'role is used.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_inherited_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--inherited',",
            "        action='store_true',",
            "        default=False,",
            "        help=_(",
            "            'Specifies if the role grant is inheritable to the sub ' 'projects'",
            "        ),",
            "    )",
            "",
            "",
            "def add_resource_option_to_parser(parser):",
            "    enable_group = parser.add_mutually_exclusive_group()",
            "    enable_group.add_argument(",
            "        '--immutable',",
            "        action='store_true',",
            "        help=_(",
            "            'Make resource immutable. An immutable project may not '",
            "            'be deleted or modified except to remove the immutable flag'",
            "        ),",
            "    )",
            "    enable_group.add_argument(",
            "        '--no-immutable',",
            "        action='store_true',",
            "        help=_('Make resource mutable (default)'),",
            "    )"
        ],
        "afterPatchFile": [
            "#   Copyright 2012-2013 OpenStack Foundation",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "\"\"\"Common identity code\"\"\"",
            "",
            "from keystoneclient import exceptions as identity_exc",
            "from keystoneclient.v3 import domains",
            "from keystoneclient.v3 import groups",
            "from keystoneclient.v3 import projects",
            "from keystoneclient.v3 import users",
            "from osc_lib import exceptions",
            "from osc_lib import utils",
            "",
            "from openstackclient.i18n import _",
            "",
            "",
            "def find_service_in_list(service_list, service_id):",
            "    \"\"\"Find a service by id in service list.\"\"\"",
            "",
            "    for service in service_list:",
            "        if service.id == service_id:",
            "            return service",
            "    raise exceptions.CommandError(",
            "        \"No service with a type, name or ID of '%s' exists.\" % service_id",
            "    )",
            "",
            "",
            "def find_service(identity_client, name_type_or_id):",
            "    \"\"\"Find a service by id, name or type.\"\"\"",
            "",
            "    try:",
            "        # search for service id",
            "        return identity_client.services.get(name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        # ignore NotFound exception, raise others",
            "        pass",
            "",
            "    try:",
            "        # search for service name",
            "        return identity_client.services.find(name=name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        pass",
            "    except identity_exc.NoUniqueMatch:",
            "        msg = _(",
            "            \"Multiple service matches found for '%s', \"",
            "            \"use an ID to be more specific.\"",
            "        )",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "    try:",
            "        # search for service type",
            "        return identity_client.services.find(type=name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        msg = _(\"No service with a type, name or ID of '%s' exists.\")",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "    except identity_exc.NoUniqueMatch:",
            "        msg = _(",
            "            \"Multiple service matches found for '%s', \"",
            "            \"use an ID to be more specific.\"",
            "        )",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "",
            "def get_resource(manager, name_type_or_id):",
            "    # NOTE (vishakha): Due to bug #1799153 and for any another related case",
            "    # where GET resource API does not support the filter by name,",
            "    # osc_lib.utils.find_resource() method cannot be used because that method",
            "    # try to fall back to list all the resource if requested resource cannot",
            "    # be get via name. Which ends up with NoUniqueMatch error.",
            "    # This new function is the replacement for osc_lib.utils.find_resource()",
            "    # for resources does not support GET by name.",
            "    # For example: identity GET /regions.",
            "    \"\"\"Find a resource by id or name.\"\"\"",
            "",
            "    try:",
            "        return manager.get(name_type_or_id)",
            "    except identity_exc.NotFound:",
            "        # raise NotFound exception",
            "        msg = _(\"No resource with name or id of '%s' exists\")",
            "        raise exceptions.CommandError(msg % name_type_or_id)",
            "",
            "",
            "def get_resource_by_id(manager, resource_id):",
            "    \"\"\"Get resource by ID",
            "",
            "    Raises CommandError if the resource is not found",
            "    \"\"\"",
            "    try:",
            "        return manager.get(resource_id)",
            "    except identity_exc.NotFound:",
            "        msg = _(\"Resource with id {} not found\")",
            "        raise exceptions.CommandError(msg.format(resource_id))",
            "",
            "",
            "def _get_token_resource(client, resource, parsed_name, parsed_domain=None):",
            "    \"\"\"Peek into the user's auth token to get resource IDs",
            "",
            "    Look into a user's token to try and find the ID of a domain, project or",
            "    user, when given the name. Typically non-admin users will interact with",
            "    the CLI using names. However, by default, keystone does not allow look up",
            "    by name since it would involve listing all entities. Instead opt to use",
            "    the correct ID (from the token) instead.",
            "    :param client: An identity client",
            "    :param resource: A resource to look at in the token, this may be `domain`,",
            "                     `project_domain`, `user_domain`, `project`, or `user`.",
            "    :param parsed_name: This is input from parsed_args that the user is hoping",
            "                        to find in the token.",
            "    :param parsed_domain: This is domain filter from parsed_args that used to",
            "                          filter the results.",
            "",
            "    :returns: The ID of the resource from the token, or the original value from",
            "              parsed_args if it does not match.",
            "    \"\"\"",
            "",
            "    try:",
            "        token = client.auth.client.get_token()",
            "        token_data = client.tokens.get_token_data(token)",
            "        token_dict = token_data['token']",
            "",
            "        # NOTE(stevemar): If domain is passed, just look at the project domain.",
            "        if resource == 'domain':",
            "            token_dict = token_dict['project']",
            "        obj = token_dict[resource]",
            "",
            "        # user/project under different domain may has a same name",
            "        if parsed_domain and parsed_domain not in obj['domain'].values():",
            "            return parsed_name",
            "        if isinstance(obj, list):",
            "            for item in obj:",
            "                if item['name'] == parsed_name:",
            "                    return item['id']",
            "                if item['id'] == parsed_name:",
            "                    return parsed_name",
            "            return parsed_name",
            "        return obj['id'] if obj['name'] == parsed_name else parsed_name",
            "    # diaper defense in case parsing the token fails",
            "    except Exception:  # noqa",
            "        return parsed_name",
            "",
            "",
            "def _get_domain_id_if_requested(identity_client, domain_name_or_id):",
            "    if not domain_name_or_id:",
            "        return None",
            "    domain = find_domain(identity_client, domain_name_or_id)",
            "    return domain.id",
            "",
            "",
            "def find_domain(identity_client, name_or_id):",
            "    return _find_identity_resource(",
            "        identity_client.domains, name_or_id, domains.Domain",
            "    )",
            "",
            "",
            "def find_group(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.groups, name_or_id, groups.Group",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.groups,",
            "            name_or_id,",
            "            groups.Group,",
            "            domain_id=domain_id,",
            "        )",
            "",
            "",
            "def find_project(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.projects, name_or_id, projects.Project",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.projects,",
            "            name_or_id,",
            "            projects.Project,",
            "            domain_id=domain_id,",
            "        )",
            "",
            "",
            "def find_user(identity_client, name_or_id, domain_name_or_id=None):",
            "    domain_id = _get_domain_id_if_requested(identity_client, domain_name_or_id)",
            "    if not domain_id:",
            "        return _find_identity_resource(",
            "            identity_client.users, name_or_id, users.User",
            "        )",
            "    else:",
            "        return _find_identity_resource(",
            "            identity_client.users, name_or_id, users.User, domain_id=domain_id",
            "        )",
            "",
            "",
            "def _find_identity_resource(",
            "    identity_client_manager, name_or_id, resource_type, **kwargs",
            "):",
            "    \"\"\"Find a specific identity resource.",
            "",
            "    Using keystoneclient's manager, attempt to find a specific resource by its",
            "    name or ID. If Forbidden to find the resource (a common case if the user",
            "    does not have permission), then return the resource by creating a local",
            "    instance of keystoneclient's Resource.",
            "",
            "    The parameter identity_client_manager is a keystoneclient manager,",
            "    for example: keystoneclient.v3.users or keystoneclient.v3.projects.",
            "",
            "    The parameter resource_type is a keystoneclient resource, for example:",
            "    keystoneclient.v3.users.User or keystoneclient.v3.projects.Project.",
            "",
            "    :param identity_client_manager: the manager that contains the resource",
            "    :type identity_client_manager: `keystoneclient.base.CrudManager`",
            "    :param name_or_id: the resources's name or ID",
            "    :type name_or_id: string",
            "    :param resource_type: class that represents the resource type",
            "    :type resource_type: `keystoneclient.base.Resource`",
            "",
            "    :returns: the resource in question",
            "    :rtype: `keystoneclient.base.Resource`",
            "",
            "    \"\"\"",
            "",
            "    try:",
            "        identity_resource = utils.find_resource(",
            "            identity_client_manager, name_or_id, **kwargs",
            "        )",
            "        if identity_resource is not None:",
            "            return identity_resource",
            "    except (exceptions.Forbidden, identity_exc.Forbidden):",
            "        pass",
            "",
            "    return resource_type(None, {'id': name_or_id, 'name': name_or_id})",
            "",
            "",
            "def get_immutable_options(parsed_args):",
            "    options = {}",
            "    if parsed_args.immutable:",
            "        options['immutable'] = True",
            "    if parsed_args.no_immutable:",
            "        options['immutable'] = False",
            "    return options",
            "",
            "",
            "def add_user_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--user-domain',",
            "        metavar='<user-domain>',",
            "        help=_(",
            "            'Domain the user belongs to (name or ID). '",
            "            'This can be used in case collisions between user names '",
            "            'exist.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_group_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--group-domain',",
            "        metavar='<group-domain>',",
            "        help=_(",
            "            'Domain the group belongs to (name or ID). '",
            "            'This can be used in case collisions between group names '",
            "            'exist.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_project_domain_option_to_parser(parser, enhance_help=lambda _h: _h):",
            "    parser.add_argument(",
            "        '--project-domain',",
            "        metavar='<project-domain>',",
            "        help=enhance_help(",
            "            _(",
            "                'Domain the project belongs to (name or ID). This '",
            "                'can be used in case collisions between project '",
            "                'names exist.'",
            "            )",
            "        ),",
            "    )",
            "",
            "",
            "def add_role_domain_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--role-domain',",
            "        metavar='<role-domain>',",
            "        help=_(",
            "            'Domain the role belongs to (name or ID). '",
            "            'This must be specified when the name of a domain specific '",
            "            'role is used.'",
            "        ),",
            "    )",
            "",
            "",
            "def add_inherited_option_to_parser(parser):",
            "    parser.add_argument(",
            "        '--inherited',",
            "        action='store_true',",
            "        default=False,",
            "        help=_(",
            "            'Specifies if the role grant is inheritable to the sub ' 'projects'",
            "        ),",
            "    )",
            "",
            "",
            "def add_resource_option_to_parser(parser):",
            "    enable_group = parser.add_mutually_exclusive_group()",
            "    enable_group.add_argument(",
            "        '--immutable',",
            "        action='store_true',",
            "        help=_(",
            "            'Make resource immutable. An immutable project may not '",
            "            'be deleted or modified except to remove the immutable flag'",
            "        ),",
            "    )",
            "    enable_group.add_argument(",
            "        '--no-immutable',",
            "        action='store_true',",
            "        help=_('Make resource mutable (default)'),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "git.cmd.Git"
        ]
    },
    "openstackclient/identity/v3/access_rule.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "             'access_rule',"
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "             metavar='<access-rule>',"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "             nargs=\"+\","
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            help=_('Access rule(s) to delete (name or ID)'),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            help=_('Access rule ID(s) to delete'),"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         )"
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         return parser"
            },
            "7": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         errors = 0"
            },
            "9": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         for ac in parsed_args.access_rule:"
            },
            "10": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             try:"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                access_rule = utils.find_resource("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                access_rule = common.get_resource_by_id("
            },
            "13": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                     identity_client.access_rules, ac"
            },
            "14": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 )"
            },
            "15": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                 identity_client.access_rules.delete(access_rule.id)"
            },
            "16": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         parser.add_argument("
            },
            "17": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             'access_rule',"
            },
            "18": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             metavar='<access-rule>',"
            },
            "19": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            help=_('Access rule to display (name or ID)'),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            help=_('Access rule ID to display'),"
            },
            "21": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         )"
            },
            "22": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         return parser"
            },
            "23": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def take_action(self, parsed_args):"
            },
            "25": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         identity_client = self.app.client_manager.identity"
            },
            "26": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        access_rule = utils.find_resource("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        access_rule = common.get_resource_by_id("
            },
            "28": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             identity_client.access_rules, parsed_args.access_rule"
            },
            "29": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         )"
            },
            "30": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#   Copyright 2019 SUSE LLC",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "\"\"\"Identity v3 Access Rule action implementations\"\"\"",
            "",
            "import logging",
            "",
            "from osc_lib.command import command",
            "from osc_lib import exceptions",
            "from osc_lib import utils",
            "",
            "from openstackclient.i18n import _",
            "from openstackclient.identity import common",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class DeleteAccessRule(command.Command):",
            "    _description = _(\"Delete access rule(s)\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(DeleteAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            'access_rule',",
            "            metavar='<access-rule>',",
            "            nargs=\"+\",",
            "            help=_('Access rule(s) to delete (name or ID)'),",
            "        )",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "",
            "        errors = 0",
            "        for ac in parsed_args.access_rule:",
            "            try:",
            "                access_rule = utils.find_resource(",
            "                    identity_client.access_rules, ac",
            "                )",
            "                identity_client.access_rules.delete(access_rule.id)",
            "            except Exception as e:",
            "                errors += 1",
            "                LOG.error(",
            "                    _(",
            "                        \"Failed to delete access rule with \"",
            "                        \"ID '%(ac)s': %(e)s\"",
            "                    ),",
            "                    {'ac': ac, 'e': e},",
            "                )",
            "",
            "        if errors > 0:",
            "            total = len(parsed_args.access_rule)",
            "            msg = _(",
            "                \"%(errors)s of %(total)s access rules failed \" \"to delete.\"",
            "            ) % {'errors': errors, 'total': total}",
            "            raise exceptions.CommandError(msg)",
            "",
            "",
            "class ListAccessRule(command.Lister):",
            "    _description = _(\"List access rules\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(ListAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            '--user',",
            "            metavar='<user>',",
            "            help=_('User whose access rules to list (name or ID)'),",
            "        )",
            "        common.add_user_domain_option_to_parser(parser)",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "        if parsed_args.user:",
            "            user_id = common.find_user(",
            "                identity_client, parsed_args.user, parsed_args.user_domain",
            "            ).id",
            "        else:",
            "            user_id = None",
            "",
            "        columns = ('ID', 'Service', 'Method', 'Path')",
            "        data = identity_client.access_rules.list(user=user_id)",
            "        return (",
            "            columns,",
            "            (",
            "                utils.get_item_properties(",
            "                    s,",
            "                    columns,",
            "                    formatters={},",
            "                )",
            "                for s in data",
            "            ),",
            "        )",
            "",
            "",
            "class ShowAccessRule(command.ShowOne):",
            "    _description = _(\"Display access rule details\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(ShowAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            'access_rule',",
            "            metavar='<access-rule>',",
            "            help=_('Access rule to display (name or ID)'),",
            "        )",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "        access_rule = utils.find_resource(",
            "            identity_client.access_rules, parsed_args.access_rule",
            "        )",
            "",
            "        access_rule._info.pop('links', None)",
            "",
            "        return zip(*sorted(access_rule._info.items()))"
        ],
        "afterPatchFile": [
            "#   Copyright 2019 SUSE LLC",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "\"\"\"Identity v3 Access Rule action implementations\"\"\"",
            "",
            "import logging",
            "",
            "from osc_lib.command import command",
            "from osc_lib import exceptions",
            "from osc_lib import utils",
            "",
            "from openstackclient.i18n import _",
            "from openstackclient.identity import common",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class DeleteAccessRule(command.Command):",
            "    _description = _(\"Delete access rule(s)\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(DeleteAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            'access_rule',",
            "            metavar='<access-rule>',",
            "            nargs=\"+\",",
            "            help=_('Access rule ID(s) to delete'),",
            "        )",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "",
            "        errors = 0",
            "        for ac in parsed_args.access_rule:",
            "            try:",
            "                access_rule = common.get_resource_by_id(",
            "                    identity_client.access_rules, ac",
            "                )",
            "                identity_client.access_rules.delete(access_rule.id)",
            "            except Exception as e:",
            "                errors += 1",
            "                LOG.error(",
            "                    _(",
            "                        \"Failed to delete access rule with \"",
            "                        \"ID '%(ac)s': %(e)s\"",
            "                    ),",
            "                    {'ac': ac, 'e': e},",
            "                )",
            "",
            "        if errors > 0:",
            "            total = len(parsed_args.access_rule)",
            "            msg = _(",
            "                \"%(errors)s of %(total)s access rules failed \" \"to delete.\"",
            "            ) % {'errors': errors, 'total': total}",
            "            raise exceptions.CommandError(msg)",
            "",
            "",
            "class ListAccessRule(command.Lister):",
            "    _description = _(\"List access rules\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(ListAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            '--user',",
            "            metavar='<user>',",
            "            help=_('User whose access rules to list (name or ID)'),",
            "        )",
            "        common.add_user_domain_option_to_parser(parser)",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "        if parsed_args.user:",
            "            user_id = common.find_user(",
            "                identity_client, parsed_args.user, parsed_args.user_domain",
            "            ).id",
            "        else:",
            "            user_id = None",
            "",
            "        columns = ('ID', 'Service', 'Method', 'Path')",
            "        data = identity_client.access_rules.list(user=user_id)",
            "        return (",
            "            columns,",
            "            (",
            "                utils.get_item_properties(",
            "                    s,",
            "                    columns,",
            "                    formatters={},",
            "                )",
            "                for s in data",
            "            ),",
            "        )",
            "",
            "",
            "class ShowAccessRule(command.ShowOne):",
            "    _description = _(\"Display access rule details\")",
            "",
            "    def get_parser(self, prog_name):",
            "        parser = super(ShowAccessRule, self).get_parser(prog_name)",
            "        parser.add_argument(",
            "            'access_rule',",
            "            metavar='<access-rule>',",
            "            help=_('Access rule ID to display'),",
            "        )",
            "        return parser",
            "",
            "    def take_action(self, parsed_args):",
            "        identity_client = self.app.client_manager.identity",
            "        access_rule = common.get_resource_by_id(",
            "            identity_client.access_rules, parsed_args.access_rule",
            "        )",
            "",
            "        access_rule._info.pop('links', None)",
            "",
            "        return zip(*sorted(access_rule._info.items()))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [
                "DeleteAccessRule",
                "get_parser"
            ],
            "50": [
                "DeleteAccessRule",
                "take_action"
            ],
            "117": [
                "ShowAccessRule",
                "get_parser"
            ],
            "123": [
                "ShowAccessRule",
                "take_action"
            ]
        },
        "addLocation": []
    },
    "openstackclient/tests/unit/identity/v3/test_access_rule.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " #"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import copy"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from unittest import mock"
            },
            "4": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from keystoneclient import exceptions as identity_exc"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from osc_lib import exceptions"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from osc_lib import utils"
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from openstackclient.identity.v3 import access_rule"
            },
            "10": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from openstackclient.tests.unit import fakes"
            },
            "11": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         )"
            },
            "12": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         self.assertIsNone(result)"
            },
            "13": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch.object(utils, 'find_resource')"
            },
            "15": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_delete_multi_access_rules_with_exception(self, find_mock):"
            },
            "16": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        find_mock.side_effect = ["
            },
            "17": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.access_rules_mock.get.return_value,"
            },
            "18": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            exceptions.CommandError,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    def test_delete_multi_access_rules_with_exception(self):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        # mock returns for common.get_resource_by_id"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        mock_get = self.access_rules_mock.get"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        mock_get.side_effect = ["
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            mock_get.return_value,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            identity_exc.NotFound,"
            },
            "25": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         ]"
            },
            "26": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         arglist = ["
            },
            "27": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             identity_fakes.access_rule_id,"
            },
            "28": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 '1 of 2 access rules failed to' ' delete.', str(e)"
            },
            "29": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             )"
            },
            "30": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        find_mock.assert_any_call("
            },
            "32": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.access_rules_mock, identity_fakes.access_rule_id"
            },
            "33": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "34": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        find_mock.assert_any_call("
            },
            "35": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.access_rules_mock, 'nonexistent_access_rule'"
            },
            "36": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        mock_get.assert_any_call(identity_fakes.access_rule_id)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        mock_get.assert_any_call('nonexistent_access_rule')"
            },
            "39": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(2, find_mock.call_count)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        self.assertEqual(2, mock_get.call_count)"
            },
            "42": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         self.access_rules_mock.delete.assert_called_once_with("
            },
            "43": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             identity_fakes.access_rule_id"
            },
            "44": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "#   Copyright 2019 SUSE LLC",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "import copy",
            "from unittest import mock",
            "",
            "from osc_lib import exceptions",
            "from osc_lib import utils",
            "",
            "from openstackclient.identity.v3 import access_rule",
            "from openstackclient.tests.unit import fakes",
            "from openstackclient.tests.unit.identity.v3 import fakes as identity_fakes",
            "",
            "",
            "class TestAccessRule(identity_fakes.TestIdentityv3):",
            "    def setUp(self):",
            "        super(TestAccessRule, self).setUp()",
            "",
            "        identity_manager = self.app.client_manager.identity",
            "        self.access_rules_mock = identity_manager.access_rules",
            "        self.access_rules_mock.reset_mock()",
            "        self.roles_mock = identity_manager.roles",
            "        self.roles_mock.reset_mock()",
            "",
            "",
            "class TestAccessRuleDelete(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleDelete, self).setUp()",
            "",
            "        # This is the return value for utils.find_resource()",
            "        self.access_rules_mock.get.return_value = fakes.FakeResource(",
            "            None,",
            "            copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "            loaded=True,",
            "        )",
            "        self.access_rules_mock.delete.return_value = None",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.DeleteAccessRule(self.app, None)",
            "",
            "    def test_access_rule_delete(self):",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "        ]",
            "        verifylist = [('access_rule', [identity_fakes.access_rule_id])]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        result = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.delete.assert_called_with(",
            "            identity_fakes.access_rule_id,",
            "        )",
            "        self.assertIsNone(result)",
            "",
            "    @mock.patch.object(utils, 'find_resource')",
            "    def test_delete_multi_access_rules_with_exception(self, find_mock):",
            "        find_mock.side_effect = [",
            "            self.access_rules_mock.get.return_value,",
            "            exceptions.CommandError,",
            "        ]",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "            'nonexistent_access_rule',",
            "        ]",
            "        verifylist = [",
            "            ('access_rule', arglist),",
            "        ]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        try:",
            "            self.cmd.take_action(parsed_args)",
            "            self.fail('CommandError should be raised.')",
            "        except exceptions.CommandError as e:",
            "            self.assertEqual(",
            "                '1 of 2 access rules failed to' ' delete.', str(e)",
            "            )",
            "",
            "        find_mock.assert_any_call(",
            "            self.access_rules_mock, identity_fakes.access_rule_id",
            "        )",
            "        find_mock.assert_any_call(",
            "            self.access_rules_mock, 'nonexistent_access_rule'",
            "        )",
            "",
            "        self.assertEqual(2, find_mock.call_count)",
            "        self.access_rules_mock.delete.assert_called_once_with(",
            "            identity_fakes.access_rule_id",
            "        )",
            "",
            "",
            "class TestAccessRuleList(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleList, self).setUp()",
            "",
            "        self.access_rules_mock.list.return_value = [",
            "            fakes.FakeResource(",
            "                None,",
            "                copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "                loaded=True,",
            "            ),",
            "        ]",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.ListAccessRule(self.app, None)",
            "",
            "    def test_access_rule_list(self):",
            "        arglist = []",
            "        verifylist = []",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        columns, data = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.list.assert_called_with(user=None)",
            "",
            "        collist = ('ID', 'Service', 'Method', 'Path')",
            "        self.assertEqual(collist, columns)",
            "        datalist = (",
            "            (",
            "                identity_fakes.access_rule_id,",
            "                identity_fakes.access_rule_service,",
            "                identity_fakes.access_rule_method,",
            "                identity_fakes.access_rule_path,",
            "            ),",
            "        )",
            "        self.assertEqual(datalist, tuple(data))",
            "",
            "",
            "class TestAccessRuleShow(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleShow, self).setUp()",
            "",
            "        self.access_rules_mock.get.return_value = fakes.FakeResource(",
            "            None,",
            "            copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "            loaded=True,",
            "        )",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.ShowAccessRule(self.app, None)",
            "",
            "    def test_access_rule_show(self):",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "        ]",
            "        verifylist = [",
            "            ('access_rule', identity_fakes.access_rule_id),",
            "        ]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        columns, data = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.get.assert_called_with(",
            "            identity_fakes.access_rule_id",
            "        )",
            "",
            "        collist = ('id', 'method', 'path', 'service')",
            "        self.assertEqual(collist, columns)",
            "        datalist = (",
            "            identity_fakes.access_rule_id,",
            "            identity_fakes.access_rule_method,",
            "            identity_fakes.access_rule_path,",
            "            identity_fakes.access_rule_service,",
            "        )",
            "        self.assertEqual(datalist, data)"
        ],
        "afterPatchFile": [
            "#   Copyright 2019 SUSE LLC",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "#",
            "",
            "import copy",
            "",
            "from keystoneclient import exceptions as identity_exc",
            "from osc_lib import exceptions",
            "",
            "from openstackclient.identity.v3 import access_rule",
            "from openstackclient.tests.unit import fakes",
            "from openstackclient.tests.unit.identity.v3 import fakes as identity_fakes",
            "",
            "",
            "class TestAccessRule(identity_fakes.TestIdentityv3):",
            "    def setUp(self):",
            "        super(TestAccessRule, self).setUp()",
            "",
            "        identity_manager = self.app.client_manager.identity",
            "        self.access_rules_mock = identity_manager.access_rules",
            "        self.access_rules_mock.reset_mock()",
            "        self.roles_mock = identity_manager.roles",
            "        self.roles_mock.reset_mock()",
            "",
            "",
            "class TestAccessRuleDelete(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleDelete, self).setUp()",
            "",
            "        # This is the return value for utils.find_resource()",
            "        self.access_rules_mock.get.return_value = fakes.FakeResource(",
            "            None,",
            "            copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "            loaded=True,",
            "        )",
            "        self.access_rules_mock.delete.return_value = None",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.DeleteAccessRule(self.app, None)",
            "",
            "    def test_access_rule_delete(self):",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "        ]",
            "        verifylist = [('access_rule', [identity_fakes.access_rule_id])]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        result = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.delete.assert_called_with(",
            "            identity_fakes.access_rule_id,",
            "        )",
            "        self.assertIsNone(result)",
            "",
            "    def test_delete_multi_access_rules_with_exception(self):",
            "        # mock returns for common.get_resource_by_id",
            "        mock_get = self.access_rules_mock.get",
            "        mock_get.side_effect = [",
            "            mock_get.return_value,",
            "            identity_exc.NotFound,",
            "        ]",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "            'nonexistent_access_rule',",
            "        ]",
            "        verifylist = [",
            "            ('access_rule', arglist),",
            "        ]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        try:",
            "            self.cmd.take_action(parsed_args)",
            "            self.fail('CommandError should be raised.')",
            "        except exceptions.CommandError as e:",
            "            self.assertEqual(",
            "                '1 of 2 access rules failed to' ' delete.', str(e)",
            "            )",
            "",
            "        mock_get.assert_any_call(identity_fakes.access_rule_id)",
            "        mock_get.assert_any_call('nonexistent_access_rule')",
            "",
            "        self.assertEqual(2, mock_get.call_count)",
            "        self.access_rules_mock.delete.assert_called_once_with(",
            "            identity_fakes.access_rule_id",
            "        )",
            "",
            "",
            "class TestAccessRuleList(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleList, self).setUp()",
            "",
            "        self.access_rules_mock.list.return_value = [",
            "            fakes.FakeResource(",
            "                None,",
            "                copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "                loaded=True,",
            "            ),",
            "        ]",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.ListAccessRule(self.app, None)",
            "",
            "    def test_access_rule_list(self):",
            "        arglist = []",
            "        verifylist = []",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        columns, data = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.list.assert_called_with(user=None)",
            "",
            "        collist = ('ID', 'Service', 'Method', 'Path')",
            "        self.assertEqual(collist, columns)",
            "        datalist = (",
            "            (",
            "                identity_fakes.access_rule_id,",
            "                identity_fakes.access_rule_service,",
            "                identity_fakes.access_rule_method,",
            "                identity_fakes.access_rule_path,",
            "            ),",
            "        )",
            "        self.assertEqual(datalist, tuple(data))",
            "",
            "",
            "class TestAccessRuleShow(TestAccessRule):",
            "    def setUp(self):",
            "        super(TestAccessRuleShow, self).setUp()",
            "",
            "        self.access_rules_mock.get.return_value = fakes.FakeResource(",
            "            None,",
            "            copy.deepcopy(identity_fakes.ACCESS_RULE),",
            "            loaded=True,",
            "        )",
            "",
            "        # Get the command object to test",
            "        self.cmd = access_rule.ShowAccessRule(self.app, None)",
            "",
            "    def test_access_rule_show(self):",
            "        arglist = [",
            "            identity_fakes.access_rule_id,",
            "        ]",
            "        verifylist = [",
            "            ('access_rule', identity_fakes.access_rule_id),",
            "        ]",
            "        parsed_args = self.check_parser(self.cmd, arglist, verifylist)",
            "",
            "        columns, data = self.cmd.take_action(parsed_args)",
            "",
            "        self.access_rules_mock.get.assert_called_with(",
            "            identity_fakes.access_rule_id",
            "        )",
            "",
            "        collist = ('id', 'method', 'path', 'service')",
            "        self.assertEqual(collist, columns)",
            "        datalist = (",
            "            identity_fakes.access_rule_id,",
            "            identity_fakes.access_rule_method,",
            "            identity_fakes.access_rule_path,",
            "            identity_fakes.access_rule_service,",
            "        )",
            "        self.assertEqual(datalist, data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [],
            "20": [],
            "67": [
                "TestAccessRuleDelete"
            ],
            "68": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "69": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "70": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "71": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "90": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "91": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "92": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "93": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "94": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "95": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ],
            "97": [
                "TestAccessRuleDelete",
                "test_delete_multi_access_rules_with_exception"
            ]
        },
        "addLocation": []
    }
}