{
    "ltiauthenticator/lti13/handlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         validator = LTI13LaunchValidator()"
            },
            "1": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         args = convert_request_to_dict(self.request.arguments)"
            },
            "2": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         self.log.debug(f\"Initial login request args are {args}\")"
            },
            "3": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if validator.validate_login_request(args):"
            },
            "4": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            login_hint = args[\"login_hint\"]"
            },
            "5": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.log.debug(f\"login_hint is {login_hint}\")"
            },
            "6": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            lti_message_hint = args[\"lti_message_hint\"]"
            },
            "7": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.log.debug(f\"lti_message_hint is {lti_message_hint}\")"
            },
            "8": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            client_id = args[\"client_id\"]"
            },
            "9": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.log.debug(f\"client_id is {client_id}\")"
            },
            "10": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            redirect_uri = guess_callback_uri("
            },
            "11": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"https\", self.request.host, self.hub.server.base_url"
            },
            "12": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "13": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.log.info(f\"redirect_uri: {redirect_uri}\")"
            },
            "14": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            state = self.get_state()"
            },
            "15": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.set_state_cookie(state)"
            },
            "16": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # TODO: validate that received nonces haven't been received before"
            },
            "17": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # and that they are within the time-based tolerance window"
            },
            "18": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            nonce_raw = hashlib.sha256(state.encode())"
            },
            "19": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            nonce = nonce_raw.hexdigest()"
            },
            "20": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.log.debug(f\"nonce value: {nonce}\")"
            },
            "21": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.authorize_redirect("
            },
            "22": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                client_id=client_id,"
            },
            "23": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                login_hint=login_hint,"
            },
            "24": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                lti_message_hint=lti_message_hint,"
            },
            "25": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nonce=nonce,"
            },
            "26": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                redirect_uri=redirect_uri,"
            },
            "27": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                state=state,"
            },
            "28": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                extra_params={\"state\": state},"
            },
            "29": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        # Raises HTTP 400 if login request arguments are not valid"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        validator.validate_login_request(args)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        login_hint = args[\"login_hint\"]"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        self.log.debug(f\"login_hint is {login_hint}\")"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        lti_message_hint = args[\"lti_message_hint\"]"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        self.log.debug(f\"lti_message_hint is {lti_message_hint}\")"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        client_id = args[\"client_id\"]"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        self.log.debug(f\"client_id is {client_id}\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        redirect_uri = guess_callback_uri("
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            \"https\", self.request.host, self.hub.server.base_url"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        )"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        self.log.info(f\"redirect_uri: {redirect_uri}\")"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        state = self.get_state()"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        self.set_state_cookie(state)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        # TODO: validate that received nonces haven't been received before"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        # and that they are within the time-based tolerance window"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        nonce_raw = hashlib.sha256(state.encode())"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        nonce = nonce_raw.hexdigest()"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        self.log.debug(f\"nonce value: {nonce}\")"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        self.authorize_redirect("
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+            client_id=client_id,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+            login_hint=login_hint,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+            lti_message_hint=lti_message_hint,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+            nonce=nonce,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+            redirect_uri=redirect_uri,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+            state=state,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+            extra_params={\"state\": state},"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+        )"
            },
            "62": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " class LTI13CallbackHandler(OAuthCallbackHandler):"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "import json",
            "import os",
            "import re",
            "import uuid",
            "from typing import Any, Dict, List, Optional, cast",
            "from urllib.parse import quote, unquote, urlparse",
            "",
            "import pem",
            "from Crypto.PublicKey import RSA",
            "from jupyterhub.handlers import BaseHandler",
            "from oauthenticator.oauth2 import (",
            "    OAuthCallbackHandler,",
            "    OAuthLoginHandler,",
            "    _serialize_state,",
            "    guess_callback_uri,",
            ")",
            "from tornado.httputil import url_concat",
            "from tornado.web import HTTPError, RequestHandler",
            "",
            "from ..utils import convert_request_to_dict, get_client_protocol, get_jwk",
            "from .validator import LTI13LaunchValidator",
            "",
            "",
            "class LTI13ConfigHandler(BaseHandler):",
            "    \"\"\"",
            "    Handles JSON configuration file for LTI 1.3.",
            "    \"\"\"",
            "",
            "    async def get(self) -> None:",
            "        \"\"\"",
            "        Gets the JSON config which is used by LTI platforms",
            "        to install the external tool.",
            "",
            "        - The extensions key contains settings for specific vendors, such as canvas,",
            "        moodle, edx, among others.",
            "        - The tool uses public settings by default. Users that wish to install the tool with",
            "        private settings should either copy/paste the json or toggle the application to private",
            "        after it is installed with the platform.",
            "        - Usernames are obtained by first attempting to get and normalize values sent when",
            "        tools are installed with public settings. If private, the username is set using the",
            "        anonumized user data when requests are sent with private installation settings.",
            "        \"\"\"",
            "        self.set_header(\"Content-Type\", \"application/json\")",
            "",
            "        # get the origin protocol",
            "        protocol = get_client_protocol(self)",
            "        self.log.debug(f\"Origin protocol is: {protocol}\")",
            "        # build the full target link url value required for the jwks endpoint",
            "        target_link_url = f\"{protocol}://{self.request.host}\"",
            "        self.log.debug(f\"Target link url is: {target_link_url}\")",
            "        keys = {",
            "            \"title\": self.authenticator.tool_name,",
            "            \"scopes\": [",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem.readonly\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/score\",",
            "                \"https://purl.imsglobal.org/spec/lti-nrps/scope/contextmembership.readonly\",",
            "                \"https://canvas.instructure.com/lti/public_jwk/scope/update\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/create\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/show\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/update\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/list\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/destroy\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/list_event_types\",",
            "                \"https://canvas.instructure.com/lti/feature_flags/scope/show\",",
            "                \"https://canvas.instructure.com/lti/account_lookup/scope/show\",",
            "            ],",
            "            \"extensions\": [",
            "                {",
            "                    \"platform\": \"canvas.instructure.com\",",
            "                    \"settings\": {",
            "                        \"platform\": \"canvas.instructure.com\",",
            "                        \"placements\": [",
            "                            {",
            "                                \"placement\": \"course_navigation\",",
            "                                \"message_type\": \"LtiResourceLinkRequest\",",
            "                                \"windowTarget\": \"_blank\",",
            "                                \"target_link_uri\": target_link_url,",
            "                                \"custom_fields\": {",
            "                                    \"email\": \"$Person.email.primary\",",
            "                                    \"lms_user_id\": \"$User.id\",",
            "                                },",
            "                            },",
            "                            {",
            "                                \"placement\": \"assignment_selection\",",
            "                                \"message_type\": \"LtiResourceLinkRequest\",",
            "                                \"target_link_uri\": target_link_url,",
            "                            },",
            "                        ],",
            "                    },",
            "                    \"privacy_level\": \"public\",",
            "                }",
            "            ],",
            "            \"description\": self.authenticator.tool_description,",
            "            \"custom_fields\": {",
            "                \"email\": \"$Person.email.primary\",",
            "                \"lms_user_id\": \"$User.id\",",
            "            },",
            "            \"public_jwk_url\": f\"{target_link_url}{self.base_url}hub/lti13/jwks\",",
            "            \"target_link_uri\": target_link_url,",
            "            \"oidc_initiation_url\": f\"{target_link_url}{self.base_url}hub/oauth_login\",",
            "        }",
            "        self.write(json.dumps(keys))",
            "",
            "",
            "class LTI13LoginHandler(OAuthLoginHandler):",
            "    \"\"\"",
            "    Handles JupyterHub authentication requests according to the",
            "    LTI 1.3 standard.",
            "    \"\"\"",
            "",
            "    def authorize_redirect(",
            "        self,",
            "        redirect_uri: Optional[str] = None,",
            "        client_id: Optional[str] = None,",
            "        login_hint: Optional[str] = None,",
            "        lti_message_hint: Optional[str] = None,",
            "        nonce: Optional[str] = None,",
            "        state: Optional[str] = None,",
            "        extra_params: Optional[Dict[str, Any]] = None,",
            "        response_type: Optional[str] = \"id_token\",",
            "        scope: Optional[List[str]] = [\"openid\"],",
            "    ) -> None:",
            "        \"\"\"",
            "        Overrides the OAuth2Mixin.authorize_redirect method to to initiate the LTI 1.3 / OIDC",
            "        login flow with the required `login_hint` and optional `lti_message_hint` arguments.",
            "",
            "        Arguments are redirected to the platform's authorization url for further",
            "        processing.",
            "",
            "        References:",
            "        https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest",
            "        http://www.imsglobal.org/spec/lti/v1p3/#additional-login-parameters-0",
            "",
            "        Args:",
            "          client_id: used to identify the tool's installation with a platform",
            "          redirect_uri: redirect url specified during tool installation (callback url)",
            "          login_hint: opaque value used by the platform for user identity",
            "          lti_message_hint: signed JWT which contains information needed to perform the",
            "            launch including issuer, user and context information",
            "          nonce: unique value sent to allow recipients to protect themselves against replay attacks",
            "          state: opaque value for the platform to maintain state between the request and",
            "            callback and provide Cross-Site Request Forgery (CSRF) mitigation.",
            "        \"\"\"",
            "        handler = cast(RequestHandler, self)",
            "        args = {\"response_type\": response_type}",
            "        args[\"scope\"] = \" \".join(scope)",
            "        if client_id is not None:",
            "            args[\"client_id\"] = client_id",
            "        if redirect_uri is not None:",
            "            args[\"redirect_uri\"] = redirect_uri",
            "        if response_type is not None:",
            "            args[\"response_type\"] = response_type",
            "        if login_hint is not None:",
            "            extra_params[\"login_hint\"] = login_hint",
            "        if lti_message_hint is not None:",
            "            extra_params[\"lti_message_hint\"] = lti_message_hint",
            "        if nonce is not None:",
            "            extra_params[\"nonce\"] = nonce",
            "        if state is not None:",
            "            extra_params[\"state\"] = state",
            "        extra_params[\"response_mode\"] = \"form_post\"",
            "        extra_params[\"prompt\"] = \"none\"",
            "        if extra_params:",
            "            args.update(extra_params)",
            "        url = self.authenticator.authorize_url",
            "        handler.redirect(url_concat(url, args))",
            "",
            "    def get_state(self):",
            "        next_url = original_next_url = self.get_argument(\"next\", None)",
            "        if not next_url:",
            "            # try with the target_link_uri arg",
            "            target_link = self.get_argument(\"target_link_uri\", \"\")",
            "            if \"next\" in target_link:",
            "                self.log.debug(",
            "                    f\"Trying to get the next-url from target_link_uri: {target_link}\"",
            "                )",
            "                next_search = re.search(\"next=(.*)\", target_link, re.IGNORECASE)",
            "                if next_search:",
            "                    next_url = next_search.group(1)",
            "                    # decode the some characters obtained with the link builder",
            "                    next_url = unquote(next_url)",
            "            elif not target_link.endswith(\"/hub\"):",
            "                next_url = target_link",
            "        if next_url:",
            "            # avoid browsers treating \\ as /",
            "            next_url = next_url.replace(\"\\\\\", quote(\"\\\\\"))",
            "            # disallow hostname-having urls,",
            "            # force absolute path redirect",
            "            urlinfo = urlparse(next_url)",
            "            next_url = urlinfo._replace(",
            "                scheme=\"\", netloc=\"\", path=\"/\" + urlinfo.path.lstrip(\"/\")",
            "            ).geturl()",
            "            if next_url != original_next_url:",
            "                self.log.warning(",
            "                    \"Ignoring next_url %r, using %r\", original_next_url, next_url",
            "                )",
            "        if self._state is None:",
            "            self._state = _serialize_state(",
            "                {\"state_id\": uuid.uuid4().hex, \"next_url\": next_url}",
            "            )",
            "        return self._state",
            "",
            "    def post(self):",
            "        \"\"\"",
            "        Validates required login arguments sent from platform and then uses the authorize_redirect() method",
            "        to redirect users to the authorization url.",
            "        \"\"\"",
            "        validator = LTI13LaunchValidator()",
            "        args = convert_request_to_dict(self.request.arguments)",
            "        self.log.debug(f\"Initial login request args are {args}\")",
            "        if validator.validate_login_request(args):",
            "            login_hint = args[\"login_hint\"]",
            "            self.log.debug(f\"login_hint is {login_hint}\")",
            "            lti_message_hint = args[\"lti_message_hint\"]",
            "            self.log.debug(f\"lti_message_hint is {lti_message_hint}\")",
            "            client_id = args[\"client_id\"]",
            "            self.log.debug(f\"client_id is {client_id}\")",
            "            redirect_uri = guess_callback_uri(",
            "                \"https\", self.request.host, self.hub.server.base_url",
            "            )",
            "            self.log.info(f\"redirect_uri: {redirect_uri}\")",
            "            state = self.get_state()",
            "            self.set_state_cookie(state)",
            "            # TODO: validate that received nonces haven't been received before",
            "            # and that they are within the time-based tolerance window",
            "            nonce_raw = hashlib.sha256(state.encode())",
            "            nonce = nonce_raw.hexdigest()",
            "            self.log.debug(f\"nonce value: {nonce}\")",
            "            self.authorize_redirect(",
            "                client_id=client_id,",
            "                login_hint=login_hint,",
            "                lti_message_hint=lti_message_hint,",
            "                nonce=nonce,",
            "                redirect_uri=redirect_uri,",
            "                state=state,",
            "                extra_params={\"state\": state},",
            "            )",
            "",
            "",
            "class LTI13CallbackHandler(OAuthCallbackHandler):",
            "    \"\"\"",
            "    LTI 1.3 call back handler",
            "    \"\"\"",
            "",
            "    async def post(self):",
            "        \"\"\"",
            "        Overrides the upstream get handler with it's standard implementation.",
            "        \"\"\"",
            "        self.check_state()",
            "        user = await self.login_user()",
            "        self.log.debug(f\"user logged in: {user}\")",
            "        if user is None:",
            "            raise HTTPError(403, \"User missing or null\")",
            "        self.redirect(self.get_next_url(user))",
            "        self.log.debug(f\"Redirecting user {user.id} to {self.get_next_url(user)}\")",
            "",
            "",
            "class LTI13JWKSHandler(BaseHandler):",
            "    \"\"\"",
            "    Handler to serve the JSON Web Key Set (JWKS) used to verify the JSON Web Token (JWT)",
            "    issued by the authorization server (a.k.a Platform, such as an LMS).",
            "    \"\"\"",
            "",
            "    def get(self) -> None:",
            "        \"\"\"",
            "        This method requires that the LTI13_PRIVATE_KEY environment variable",
            "        is set with the full path to the RSA private key in PEM format.",
            "        \"\"\"",
            "        if not os.environ.get(\"LTI13_PRIVATE_KEY\"):",
            "            raise OSError(\"LTI13_PRIVATE_KEY environment variable not set\")",
            "        key_path = os.environ.get(\"LTI13_PRIVATE_KEY\")",
            "        # ensure pem permissions are correctly set",
            "        if not os.access(key_path, os.R_OK):",
            "            self.log.error(f\"Unable to access {key_path}\")",
            "            raise PermissionError()",
            "        private_key = pem.parse_file(key_path)",
            "        public_key = RSA.import_key(private_key[0].as_text()).publickey().exportKey()",
            "        self.log.debug(f\"public_key is {public_key}\")",
            "",
            "        jwk = get_jwk(public_key)",
            "        self.log.debug(f\"The jwks is {jwk}\")",
            "        keys_obj = {\"keys\": []}",
            "        keys_obj[\"keys\"].append(jwk)",
            "        # we do not need to use json.dumps because tornado is converting our dict automatically and adding the content-type as json",
            "        # https://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write",
            "        self.write(keys_obj)"
        ],
        "afterPatchFile": [
            "import hashlib",
            "import json",
            "import os",
            "import re",
            "import uuid",
            "from typing import Any, Dict, List, Optional, cast",
            "from urllib.parse import quote, unquote, urlparse",
            "",
            "import pem",
            "from Crypto.PublicKey import RSA",
            "from jupyterhub.handlers import BaseHandler",
            "from oauthenticator.oauth2 import (",
            "    OAuthCallbackHandler,",
            "    OAuthLoginHandler,",
            "    _serialize_state,",
            "    guess_callback_uri,",
            ")",
            "from tornado.httputil import url_concat",
            "from tornado.web import HTTPError, RequestHandler",
            "",
            "from ..utils import convert_request_to_dict, get_client_protocol, get_jwk",
            "from .validator import LTI13LaunchValidator",
            "",
            "",
            "class LTI13ConfigHandler(BaseHandler):",
            "    \"\"\"",
            "    Handles JSON configuration file for LTI 1.3.",
            "    \"\"\"",
            "",
            "    async def get(self) -> None:",
            "        \"\"\"",
            "        Gets the JSON config which is used by LTI platforms",
            "        to install the external tool.",
            "",
            "        - The extensions key contains settings for specific vendors, such as canvas,",
            "        moodle, edx, among others.",
            "        - The tool uses public settings by default. Users that wish to install the tool with",
            "        private settings should either copy/paste the json or toggle the application to private",
            "        after it is installed with the platform.",
            "        - Usernames are obtained by first attempting to get and normalize values sent when",
            "        tools are installed with public settings. If private, the username is set using the",
            "        anonumized user data when requests are sent with private installation settings.",
            "        \"\"\"",
            "        self.set_header(\"Content-Type\", \"application/json\")",
            "",
            "        # get the origin protocol",
            "        protocol = get_client_protocol(self)",
            "        self.log.debug(f\"Origin protocol is: {protocol}\")",
            "        # build the full target link url value required for the jwks endpoint",
            "        target_link_url = f\"{protocol}://{self.request.host}\"",
            "        self.log.debug(f\"Target link url is: {target_link_url}\")",
            "        keys = {",
            "            \"title\": self.authenticator.tool_name,",
            "            \"scopes\": [",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem.readonly\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\",",
            "                \"https://purl.imsglobal.org/spec/lti-ags/scope/score\",",
            "                \"https://purl.imsglobal.org/spec/lti-nrps/scope/contextmembership.readonly\",",
            "                \"https://canvas.instructure.com/lti/public_jwk/scope/update\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/create\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/show\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/update\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/list\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/destroy\",",
            "                \"https://canvas.instructure.com/lti/data_services/scope/list_event_types\",",
            "                \"https://canvas.instructure.com/lti/feature_flags/scope/show\",",
            "                \"https://canvas.instructure.com/lti/account_lookup/scope/show\",",
            "            ],",
            "            \"extensions\": [",
            "                {",
            "                    \"platform\": \"canvas.instructure.com\",",
            "                    \"settings\": {",
            "                        \"platform\": \"canvas.instructure.com\",",
            "                        \"placements\": [",
            "                            {",
            "                                \"placement\": \"course_navigation\",",
            "                                \"message_type\": \"LtiResourceLinkRequest\",",
            "                                \"windowTarget\": \"_blank\",",
            "                                \"target_link_uri\": target_link_url,",
            "                                \"custom_fields\": {",
            "                                    \"email\": \"$Person.email.primary\",",
            "                                    \"lms_user_id\": \"$User.id\",",
            "                                },",
            "                            },",
            "                            {",
            "                                \"placement\": \"assignment_selection\",",
            "                                \"message_type\": \"LtiResourceLinkRequest\",",
            "                                \"target_link_uri\": target_link_url,",
            "                            },",
            "                        ],",
            "                    },",
            "                    \"privacy_level\": \"public\",",
            "                }",
            "            ],",
            "            \"description\": self.authenticator.tool_description,",
            "            \"custom_fields\": {",
            "                \"email\": \"$Person.email.primary\",",
            "                \"lms_user_id\": \"$User.id\",",
            "            },",
            "            \"public_jwk_url\": f\"{target_link_url}{self.base_url}hub/lti13/jwks\",",
            "            \"target_link_uri\": target_link_url,",
            "            \"oidc_initiation_url\": f\"{target_link_url}{self.base_url}hub/oauth_login\",",
            "        }",
            "        self.write(json.dumps(keys))",
            "",
            "",
            "class LTI13LoginHandler(OAuthLoginHandler):",
            "    \"\"\"",
            "    Handles JupyterHub authentication requests according to the",
            "    LTI 1.3 standard.",
            "    \"\"\"",
            "",
            "    def authorize_redirect(",
            "        self,",
            "        redirect_uri: Optional[str] = None,",
            "        client_id: Optional[str] = None,",
            "        login_hint: Optional[str] = None,",
            "        lti_message_hint: Optional[str] = None,",
            "        nonce: Optional[str] = None,",
            "        state: Optional[str] = None,",
            "        extra_params: Optional[Dict[str, Any]] = None,",
            "        response_type: Optional[str] = \"id_token\",",
            "        scope: Optional[List[str]] = [\"openid\"],",
            "    ) -> None:",
            "        \"\"\"",
            "        Overrides the OAuth2Mixin.authorize_redirect method to to initiate the LTI 1.3 / OIDC",
            "        login flow with the required `login_hint` and optional `lti_message_hint` arguments.",
            "",
            "        Arguments are redirected to the platform's authorization url for further",
            "        processing.",
            "",
            "        References:",
            "        https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest",
            "        http://www.imsglobal.org/spec/lti/v1p3/#additional-login-parameters-0",
            "",
            "        Args:",
            "          client_id: used to identify the tool's installation with a platform",
            "          redirect_uri: redirect url specified during tool installation (callback url)",
            "          login_hint: opaque value used by the platform for user identity",
            "          lti_message_hint: signed JWT which contains information needed to perform the",
            "            launch including issuer, user and context information",
            "          nonce: unique value sent to allow recipients to protect themselves against replay attacks",
            "          state: opaque value for the platform to maintain state between the request and",
            "            callback and provide Cross-Site Request Forgery (CSRF) mitigation.",
            "        \"\"\"",
            "        handler = cast(RequestHandler, self)",
            "        args = {\"response_type\": response_type}",
            "        args[\"scope\"] = \" \".join(scope)",
            "        if client_id is not None:",
            "            args[\"client_id\"] = client_id",
            "        if redirect_uri is not None:",
            "            args[\"redirect_uri\"] = redirect_uri",
            "        if response_type is not None:",
            "            args[\"response_type\"] = response_type",
            "        if login_hint is not None:",
            "            extra_params[\"login_hint\"] = login_hint",
            "        if lti_message_hint is not None:",
            "            extra_params[\"lti_message_hint\"] = lti_message_hint",
            "        if nonce is not None:",
            "            extra_params[\"nonce\"] = nonce",
            "        if state is not None:",
            "            extra_params[\"state\"] = state",
            "        extra_params[\"response_mode\"] = \"form_post\"",
            "        extra_params[\"prompt\"] = \"none\"",
            "        if extra_params:",
            "            args.update(extra_params)",
            "        url = self.authenticator.authorize_url",
            "        handler.redirect(url_concat(url, args))",
            "",
            "    def get_state(self):",
            "        next_url = original_next_url = self.get_argument(\"next\", None)",
            "        if not next_url:",
            "            # try with the target_link_uri arg",
            "            target_link = self.get_argument(\"target_link_uri\", \"\")",
            "            if \"next\" in target_link:",
            "                self.log.debug(",
            "                    f\"Trying to get the next-url from target_link_uri: {target_link}\"",
            "                )",
            "                next_search = re.search(\"next=(.*)\", target_link, re.IGNORECASE)",
            "                if next_search:",
            "                    next_url = next_search.group(1)",
            "                    # decode the some characters obtained with the link builder",
            "                    next_url = unquote(next_url)",
            "            elif not target_link.endswith(\"/hub\"):",
            "                next_url = target_link",
            "        if next_url:",
            "            # avoid browsers treating \\ as /",
            "            next_url = next_url.replace(\"\\\\\", quote(\"\\\\\"))",
            "            # disallow hostname-having urls,",
            "            # force absolute path redirect",
            "            urlinfo = urlparse(next_url)",
            "            next_url = urlinfo._replace(",
            "                scheme=\"\", netloc=\"\", path=\"/\" + urlinfo.path.lstrip(\"/\")",
            "            ).geturl()",
            "            if next_url != original_next_url:",
            "                self.log.warning(",
            "                    \"Ignoring next_url %r, using %r\", original_next_url, next_url",
            "                )",
            "        if self._state is None:",
            "            self._state = _serialize_state(",
            "                {\"state_id\": uuid.uuid4().hex, \"next_url\": next_url}",
            "            )",
            "        return self._state",
            "",
            "    def post(self):",
            "        \"\"\"",
            "        Validates required login arguments sent from platform and then uses the authorize_redirect() method",
            "        to redirect users to the authorization url.",
            "        \"\"\"",
            "        validator = LTI13LaunchValidator()",
            "        args = convert_request_to_dict(self.request.arguments)",
            "        self.log.debug(f\"Initial login request args are {args}\")",
            "",
            "        # Raises HTTP 400 if login request arguments are not valid",
            "        validator.validate_login_request(args)",
            "",
            "        login_hint = args[\"login_hint\"]",
            "        self.log.debug(f\"login_hint is {login_hint}\")",
            "",
            "        lti_message_hint = args[\"lti_message_hint\"]",
            "        self.log.debug(f\"lti_message_hint is {lti_message_hint}\")",
            "",
            "        client_id = args[\"client_id\"]",
            "        self.log.debug(f\"client_id is {client_id}\")",
            "        redirect_uri = guess_callback_uri(",
            "            \"https\", self.request.host, self.hub.server.base_url",
            "        )",
            "        self.log.info(f\"redirect_uri: {redirect_uri}\")",
            "        state = self.get_state()",
            "        self.set_state_cookie(state)",
            "        # TODO: validate that received nonces haven't been received before",
            "        # and that they are within the time-based tolerance window",
            "        nonce_raw = hashlib.sha256(state.encode())",
            "        nonce = nonce_raw.hexdigest()",
            "        self.log.debug(f\"nonce value: {nonce}\")",
            "        self.authorize_redirect(",
            "            client_id=client_id,",
            "            login_hint=login_hint,",
            "            lti_message_hint=lti_message_hint,",
            "            nonce=nonce,",
            "            redirect_uri=redirect_uri,",
            "            state=state,",
            "            extra_params={\"state\": state},",
            "        )",
            "",
            "",
            "class LTI13CallbackHandler(OAuthCallbackHandler):",
            "    \"\"\"",
            "    LTI 1.3 call back handler",
            "    \"\"\"",
            "",
            "    async def post(self):",
            "        \"\"\"",
            "        Overrides the upstream get handler with it's standard implementation.",
            "        \"\"\"",
            "        self.check_state()",
            "        user = await self.login_user()",
            "        self.log.debug(f\"user logged in: {user}\")",
            "        if user is None:",
            "            raise HTTPError(403, \"User missing or null\")",
            "        self.redirect(self.get_next_url(user))",
            "        self.log.debug(f\"Redirecting user {user.id} to {self.get_next_url(user)}\")",
            "",
            "",
            "class LTI13JWKSHandler(BaseHandler):",
            "    \"\"\"",
            "    Handler to serve the JSON Web Key Set (JWKS) used to verify the JSON Web Token (JWT)",
            "    issued by the authorization server (a.k.a Platform, such as an LMS).",
            "    \"\"\"",
            "",
            "    def get(self) -> None:",
            "        \"\"\"",
            "        This method requires that the LTI13_PRIVATE_KEY environment variable",
            "        is set with the full path to the RSA private key in PEM format.",
            "        \"\"\"",
            "        if not os.environ.get(\"LTI13_PRIVATE_KEY\"):",
            "            raise OSError(\"LTI13_PRIVATE_KEY environment variable not set\")",
            "        key_path = os.environ.get(\"LTI13_PRIVATE_KEY\")",
            "        # ensure pem permissions are correctly set",
            "        if not os.access(key_path, os.R_OK):",
            "            self.log.error(f\"Unable to access {key_path}\")",
            "            raise PermissionError()",
            "        private_key = pem.parse_file(key_path)",
            "        public_key = RSA.import_key(private_key[0].as_text()).publickey().exportKey()",
            "        self.log.debug(f\"public_key is {public_key}\")",
            "",
            "        jwk = get_jwk(public_key)",
            "        self.log.debug(f\"The jwks is {jwk}\")",
            "        keys_obj = {\"keys\": []}",
            "        keys_obj[\"keys\"].append(jwk)",
            "        # we do not need to use json.dumps because tornado is converting our dict automatically and adding the content-type as json",
            "        # https://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write",
            "        self.write(keys_obj)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "214": [
                "LTI13LoginHandler",
                "post"
            ],
            "215": [
                "LTI13LoginHandler",
                "post"
            ],
            "216": [
                "LTI13LoginHandler",
                "post"
            ],
            "217": [
                "LTI13LoginHandler",
                "post"
            ],
            "218": [
                "LTI13LoginHandler",
                "post"
            ],
            "219": [
                "LTI13LoginHandler",
                "post"
            ],
            "220": [
                "LTI13LoginHandler",
                "post"
            ],
            "221": [
                "LTI13LoginHandler",
                "post"
            ],
            "222": [
                "LTI13LoginHandler",
                "post"
            ],
            "223": [
                "LTI13LoginHandler",
                "post"
            ],
            "224": [
                "LTI13LoginHandler",
                "post"
            ],
            "225": [
                "LTI13LoginHandler",
                "post"
            ],
            "226": [
                "LTI13LoginHandler",
                "post"
            ],
            "227": [
                "LTI13LoginHandler",
                "post"
            ],
            "228": [
                "LTI13LoginHandler",
                "post"
            ],
            "229": [
                "LTI13LoginHandler",
                "post"
            ],
            "230": [
                "LTI13LoginHandler",
                "post"
            ],
            "231": [
                "LTI13LoginHandler",
                "post"
            ],
            "232": [
                "LTI13LoginHandler",
                "post"
            ],
            "233": [
                "LTI13LoginHandler",
                "post"
            ],
            "234": [
                "LTI13LoginHandler",
                "post"
            ],
            "235": [
                "LTI13LoginHandler",
                "post"
            ],
            "236": [
                "LTI13LoginHandler",
                "post"
            ],
            "237": [
                "LTI13LoginHandler",
                "post"
            ],
            "238": [
                "LTI13LoginHandler",
                "post"
            ],
            "239": [
                "LTI13LoginHandler",
                "post"
            ],
            "240": [
                "LTI13LoginHandler",
                "post"
            ]
        },
        "addLocation": []
    }
}