{
    "glance/async_/flows/plugins/image_conversion.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from taskflow import task"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from glance.async_ import utils"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from glance.common import format_inspector"
            },
            "4": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from glance.i18n import _, _LI"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " LOG = logging.getLogger(__name__)"
            },
            "7": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                                              'target': target_format}"
            },
            "8": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         self.dest_path = dest_path"
            },
            "9": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        source_format = action.image_disk_format"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        inspector_cls = format_inspector.get_inspector(source_format)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        if not inspector_cls:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            # We cannot convert from disk_format types that qemu-img doesn't"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            # support (like iso, ploop, etc). The ones it supports overlaps"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            # with the ones we have inspectors for, so reject conversion for"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            # any format we don't have an inspector for."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            raise RuntimeError("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                'Unable to convert from format %s' % source_format)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        # Use our own cautious inspector module (if we have one for this"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        # format) to make sure a file is the format the submitter claimed"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        # it is and that it passes some basic safety checks _before_ we run"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        # qemu-img on it."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        # See https://bugs.launchpad.net/nova/+bug/2059809 for details."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        try:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            inspector = inspector_cls.from_file(src_path)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            if not inspector.safety_check():"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                LOG.error('Image failed %s safety check; aborting conversion',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                          source_format)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                raise RuntimeError('Image has disallowed configuration')"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        except RuntimeError:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            raise"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        except format_inspector.ImageFormatError as e:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+            LOG.error('Image claimed to be %s format failed format '"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                      'inspection: %s', source_format, e)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            raise RuntimeError('Image format detection failed')"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        except Exception as e:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            LOG.exception('Unknown error inspecting image format: %s', e)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            raise RuntimeError('Unable to inspect image')"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         try:"
            },
            "42": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             stdout, stderr = putils.trycmd(\"qemu-img\", \"info\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+                                           \"-f\", source_format,"
            },
            "44": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                                            \"--output=json\","
            },
            "45": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "                                            src_path,"
            },
            "46": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "                                            prlimit=utils.QEMU_IMG_PROC_LIMITS,"
            },
            "47": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             raise RuntimeError(stderr)"
            },
            "48": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         metadata = json.loads(stdout)"
            },
            "50": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "51": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            source_format = metadata['format']"
            },
            "52": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except KeyError:"
            },
            "53": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = (\"Failed to do introspection as part of image \""
            },
            "54": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                   \"conversion for %(iid)s: Source format not reported\")"
            },
            "55": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            LOG.error(msg, {'iid': self.image_id})"
            },
            "56": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise RuntimeError(msg)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        if metadata.get('format') != source_format:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            LOG.error('Image claiming to be %s reported as %s by qemu-img',"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+                      source_format, metadata.get('format', 'unknown'))"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            raise RuntimeError('Image metadata disagrees about format')"
            },
            "61": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         virtual_size = metadata.get('virtual-size', 0)"
            },
            "63": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         action.set_image_attribute(virtual_size=virtual_size)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2018 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import json",
            "import os",
            "",
            "from oslo_concurrency import processutils as putils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "from oslo_utils import excutils",
            "from taskflow.patterns import linear_flow as lf",
            "from taskflow import task",
            "",
            "from glance.async_ import utils",
            "from glance.i18n import _, _LI",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "conversion_plugin_opts = [",
            "    cfg.StrOpt('output_format',",
            "               default='raw',",
            "               choices=('qcow2', 'raw', 'vmdk'),",
            "               help=_(\"\"\"",
            "Desired output format for image conversion plugin.",
            "",
            "Provide a valid image format to which the conversion plugin",
            "will convert the image before storing it to the back-end.",
            "",
            "Note, if the Image Conversion plugin for image import is defined, users",
            "should only upload disk formats that are supported by `quemu-img` otherwise",
            "the conversion and import will fail.",
            "",
            "Possible values:",
            "    * qcow2",
            "    * raw",
            "    * vmdk",
            "",
            "Related Options:",
            "    * disk_formats",
            "\"\"\")),",
            "]",
            "",
            "CONF = cfg.CONF",
            "",
            "CONF.register_opts(conversion_plugin_opts, group='image_conversion')",
            "",
            "",
            "class _ConvertImage(task.Task):",
            "",
            "    default_provides = 'file_path'",
            "",
            "    def __init__(self, context, task_id, task_type, action_wrapper):",
            "        self.context = context",
            "        self.task_id = task_id",
            "        self.task_type = task_type",
            "        self.action_wrapper = action_wrapper",
            "        self.image_id = action_wrapper.image_id",
            "        self.dest_path = \"\"",
            "        self.python = CONF.wsgi.python_interpreter",
            "        super(_ConvertImage, self).__init__(",
            "            name='%s-Convert_Image-%s' % (task_type, task_id))",
            "",
            "    def execute(self, file_path, **kwargs):",
            "        with self.action_wrapper as action:",
            "            return self._execute(action, file_path, **kwargs)",
            "",
            "    def _execute(self, action, file_path, **kwargs):",
            "",
            "        target_format = CONF.image_conversion.output_format",
            "        # TODO(jokke): Once we support other schemas we need to take them into",
            "        # account and handle the paths here.",
            "        src_path = file_path.split('file://')[-1]",
            "        dest_path = \"%(path)s.%(target)s\" % {'path': src_path,",
            "                                             'target': target_format}",
            "        self.dest_path = dest_path",
            "",
            "        try:",
            "            stdout, stderr = putils.trycmd(\"qemu-img\", \"info\",",
            "                                           \"--output=json\",",
            "                                           src_path,",
            "                                           prlimit=utils.QEMU_IMG_PROC_LIMITS,",
            "                                           python_exec=self.python,",
            "                                           log_errors=putils.LOG_ALL_ERRORS,)",
            "        except OSError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                exc_message = encodeutils.exception_to_unicode(exc)",
            "                msg = (\"Failed to do introspection as part of image \"",
            "                       \"conversion for %(iid)s: %(err)s\")",
            "                LOG.error(msg, {'iid': self.image_id, 'err': exc_message})",
            "",
            "        if stderr:",
            "            raise RuntimeError(stderr)",
            "",
            "        metadata = json.loads(stdout)",
            "        try:",
            "            source_format = metadata['format']",
            "        except KeyError:",
            "            msg = (\"Failed to do introspection as part of image \"",
            "                   \"conversion for %(iid)s: Source format not reported\")",
            "            LOG.error(msg, {'iid': self.image_id})",
            "            raise RuntimeError(msg)",
            "",
            "        virtual_size = metadata.get('virtual-size', 0)",
            "        action.set_image_attribute(virtual_size=virtual_size)",
            "",
            "        if 'backing-filename' in metadata:",
            "            LOG.warning('Refusing to process QCOW image with a backing file')",
            "            raise RuntimeError(",
            "                'QCOW images with backing files are not allowed')",
            "",
            "        try:",
            "            data_file = metadata['format-specific']['data']['data-file']",
            "        except KeyError:",
            "            data_file = None",
            "        if data_file is not None:",
            "            raise RuntimeError(",
            "                'QCOW images with data-file set are not allowed')",
            "",
            "        if metadata.get('format') == 'vmdk':",
            "            create_type = metadata.get(",
            "                'format-specific', {}).get(",
            "                    'data', {}).get('create-type')",
            "            allowed = CONF.image_format.vmdk_allowed_types",
            "            if not create_type:",
            "                raise RuntimeError(_('Unable to determine VMDK create-type'))",
            "            if not len(allowed):",
            "                LOG.warning(_('Refusing to process VMDK file as '",
            "                              'vmdk_allowed_types is empty'))",
            "                raise RuntimeError(_('Image is a VMDK, but no VMDK createType '",
            "                                     'is specified'))",
            "            if create_type not in allowed:",
            "                LOG.warning(_('Refusing to process VMDK file with create-type '",
            "                              'of %r which is not in allowed set of: %s'),",
            "                            create_type, ','.join(allowed))",
            "                raise RuntimeError(_('Invalid VMDK create-type specified'))",
            "",
            "        if source_format == target_format:",
            "            LOG.debug(\"Source is already in target format, \"",
            "                      \"not doing conversion for %s\", self.image_id)",
            "            return file_path",
            "",
            "        try:",
            "            stdout, stderr = putils.trycmd('qemu-img', 'convert',",
            "                                           '-f', source_format,",
            "                                           '-O', target_format,",
            "                                           src_path, dest_path,",
            "                                           log_errors=putils.LOG_ALL_ERRORS)",
            "        except OSError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                exc_message = encodeutils.exception_to_unicode(exc)",
            "                msg = \"Failed to do image conversion for %(iid)s: %(err)s\"",
            "                LOG.error(msg, {'iid': self.image_id, 'err': exc_message})",
            "",
            "        if stderr:",
            "            raise RuntimeError(stderr)",
            "",
            "        action.set_image_attribute(disk_format=target_format,",
            "                                   container_format='bare')",
            "        new_size = os.stat(dest_path).st_size",
            "        action.set_image_attribute(size=new_size)",
            "        LOG.info(_LI('Updated image %s size=%i disk_format=%s'),",
            "                 self.image_id, new_size, target_format)",
            "",
            "        os.remove(src_path)",
            "",
            "        return \"file://%s\" % dest_path",
            "",
            "    def revert(self, result=None, **kwargs):",
            "        # NOTE(flaper87): If result is None, it probably",
            "        # means this task failed. Otherwise, we would have",
            "        # a result from its execution.",
            "        if result is not None:",
            "            LOG.debug(\"Image conversion failed.\")",
            "            if os.path.exists(self.dest_path):",
            "                os.remove(self.dest_path)",
            "",
            "",
            "def get_flow(**kwargs):",
            "    \"\"\"Return task flow for no-op.",
            "",
            "    :param context: request context",
            "    :param task_id: Task ID.",
            "    :param task_type: Type of the task.",
            "    :param image_repo: Image repository used.",
            "    :param image_id: Image ID",
            "    :param action_wrapper: An api_image_import.ActionWrapper.",
            "    \"\"\"",
            "    context = kwargs.get('context')",
            "    task_id = kwargs.get('task_id')",
            "    task_type = kwargs.get('task_type')",
            "    action_wrapper = kwargs.get('action_wrapper')",
            "",
            "    return lf.Flow(task_type).add(",
            "        _ConvertImage(context, task_id, task_type, action_wrapper)",
            "    )"
        ],
        "afterPatchFile": [
            "# Copyright 2018 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import json",
            "import os",
            "",
            "from oslo_concurrency import processutils as putils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "from oslo_utils import excutils",
            "from taskflow.patterns import linear_flow as lf",
            "from taskflow import task",
            "",
            "from glance.async_ import utils",
            "from glance.common import format_inspector",
            "from glance.i18n import _, _LI",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "conversion_plugin_opts = [",
            "    cfg.StrOpt('output_format',",
            "               default='raw',",
            "               choices=('qcow2', 'raw', 'vmdk'),",
            "               help=_(\"\"\"",
            "Desired output format for image conversion plugin.",
            "",
            "Provide a valid image format to which the conversion plugin",
            "will convert the image before storing it to the back-end.",
            "",
            "Note, if the Image Conversion plugin for image import is defined, users",
            "should only upload disk formats that are supported by `quemu-img` otherwise",
            "the conversion and import will fail.",
            "",
            "Possible values:",
            "    * qcow2",
            "    * raw",
            "    * vmdk",
            "",
            "Related Options:",
            "    * disk_formats",
            "\"\"\")),",
            "]",
            "",
            "CONF = cfg.CONF",
            "",
            "CONF.register_opts(conversion_plugin_opts, group='image_conversion')",
            "",
            "",
            "class _ConvertImage(task.Task):",
            "",
            "    default_provides = 'file_path'",
            "",
            "    def __init__(self, context, task_id, task_type, action_wrapper):",
            "        self.context = context",
            "        self.task_id = task_id",
            "        self.task_type = task_type",
            "        self.action_wrapper = action_wrapper",
            "        self.image_id = action_wrapper.image_id",
            "        self.dest_path = \"\"",
            "        self.python = CONF.wsgi.python_interpreter",
            "        super(_ConvertImage, self).__init__(",
            "            name='%s-Convert_Image-%s' % (task_type, task_id))",
            "",
            "    def execute(self, file_path, **kwargs):",
            "        with self.action_wrapper as action:",
            "            return self._execute(action, file_path, **kwargs)",
            "",
            "    def _execute(self, action, file_path, **kwargs):",
            "",
            "        target_format = CONF.image_conversion.output_format",
            "        # TODO(jokke): Once we support other schemas we need to take them into",
            "        # account and handle the paths here.",
            "        src_path = file_path.split('file://')[-1]",
            "        dest_path = \"%(path)s.%(target)s\" % {'path': src_path,",
            "                                             'target': target_format}",
            "        self.dest_path = dest_path",
            "",
            "        source_format = action.image_disk_format",
            "        inspector_cls = format_inspector.get_inspector(source_format)",
            "        if not inspector_cls:",
            "            # We cannot convert from disk_format types that qemu-img doesn't",
            "            # support (like iso, ploop, etc). The ones it supports overlaps",
            "            # with the ones we have inspectors for, so reject conversion for",
            "            # any format we don't have an inspector for.",
            "            raise RuntimeError(",
            "                'Unable to convert from format %s' % source_format)",
            "",
            "        # Use our own cautious inspector module (if we have one for this",
            "        # format) to make sure a file is the format the submitter claimed",
            "        # it is and that it passes some basic safety checks _before_ we run",
            "        # qemu-img on it.",
            "        # See https://bugs.launchpad.net/nova/+bug/2059809 for details.",
            "        try:",
            "            inspector = inspector_cls.from_file(src_path)",
            "            if not inspector.safety_check():",
            "                LOG.error('Image failed %s safety check; aborting conversion',",
            "                          source_format)",
            "                raise RuntimeError('Image has disallowed configuration')",
            "        except RuntimeError:",
            "            raise",
            "        except format_inspector.ImageFormatError as e:",
            "            LOG.error('Image claimed to be %s format failed format '",
            "                      'inspection: %s', source_format, e)",
            "            raise RuntimeError('Image format detection failed')",
            "        except Exception as e:",
            "            LOG.exception('Unknown error inspecting image format: %s', e)",
            "            raise RuntimeError('Unable to inspect image')",
            "",
            "        try:",
            "            stdout, stderr = putils.trycmd(\"qemu-img\", \"info\",",
            "                                           \"-f\", source_format,",
            "                                           \"--output=json\",",
            "                                           src_path,",
            "                                           prlimit=utils.QEMU_IMG_PROC_LIMITS,",
            "                                           python_exec=self.python,",
            "                                           log_errors=putils.LOG_ALL_ERRORS,)",
            "        except OSError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                exc_message = encodeutils.exception_to_unicode(exc)",
            "                msg = (\"Failed to do introspection as part of image \"",
            "                       \"conversion for %(iid)s: %(err)s\")",
            "                LOG.error(msg, {'iid': self.image_id, 'err': exc_message})",
            "",
            "        if stderr:",
            "            raise RuntimeError(stderr)",
            "",
            "        metadata = json.loads(stdout)",
            "        if metadata.get('format') != source_format:",
            "            LOG.error('Image claiming to be %s reported as %s by qemu-img',",
            "                      source_format, metadata.get('format', 'unknown'))",
            "            raise RuntimeError('Image metadata disagrees about format')",
            "",
            "        virtual_size = metadata.get('virtual-size', 0)",
            "        action.set_image_attribute(virtual_size=virtual_size)",
            "",
            "        if 'backing-filename' in metadata:",
            "            LOG.warning('Refusing to process QCOW image with a backing file')",
            "            raise RuntimeError(",
            "                'QCOW images with backing files are not allowed')",
            "",
            "        try:",
            "            data_file = metadata['format-specific']['data']['data-file']",
            "        except KeyError:",
            "            data_file = None",
            "        if data_file is not None:",
            "            raise RuntimeError(",
            "                'QCOW images with data-file set are not allowed')",
            "",
            "        if metadata.get('format') == 'vmdk':",
            "            create_type = metadata.get(",
            "                'format-specific', {}).get(",
            "                    'data', {}).get('create-type')",
            "            allowed = CONF.image_format.vmdk_allowed_types",
            "            if not create_type:",
            "                raise RuntimeError(_('Unable to determine VMDK create-type'))",
            "            if not len(allowed):",
            "                LOG.warning(_('Refusing to process VMDK file as '",
            "                              'vmdk_allowed_types is empty'))",
            "                raise RuntimeError(_('Image is a VMDK, but no VMDK createType '",
            "                                     'is specified'))",
            "            if create_type not in allowed:",
            "                LOG.warning(_('Refusing to process VMDK file with create-type '",
            "                              'of %r which is not in allowed set of: %s'),",
            "                            create_type, ','.join(allowed))",
            "                raise RuntimeError(_('Invalid VMDK create-type specified'))",
            "",
            "        if source_format == target_format:",
            "            LOG.debug(\"Source is already in target format, \"",
            "                      \"not doing conversion for %s\", self.image_id)",
            "            return file_path",
            "",
            "        try:",
            "            stdout, stderr = putils.trycmd('qemu-img', 'convert',",
            "                                           '-f', source_format,",
            "                                           '-O', target_format,",
            "                                           src_path, dest_path,",
            "                                           log_errors=putils.LOG_ALL_ERRORS)",
            "        except OSError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                exc_message = encodeutils.exception_to_unicode(exc)",
            "                msg = \"Failed to do image conversion for %(iid)s: %(err)s\"",
            "                LOG.error(msg, {'iid': self.image_id, 'err': exc_message})",
            "",
            "        if stderr:",
            "            raise RuntimeError(stderr)",
            "",
            "        action.set_image_attribute(disk_format=target_format,",
            "                                   container_format='bare')",
            "        new_size = os.stat(dest_path).st_size",
            "        action.set_image_attribute(size=new_size)",
            "        LOG.info(_LI('Updated image %s size=%i disk_format=%s'),",
            "                 self.image_id, new_size, target_format)",
            "",
            "        os.remove(src_path)",
            "",
            "        return \"file://%s\" % dest_path",
            "",
            "    def revert(self, result=None, **kwargs):",
            "        # NOTE(flaper87): If result is None, it probably",
            "        # means this task failed. Otherwise, we would have",
            "        # a result from its execution.",
            "        if result is not None:",
            "            LOG.debug(\"Image conversion failed.\")",
            "            if os.path.exists(self.dest_path):",
            "                os.remove(self.dest_path)",
            "",
            "",
            "def get_flow(**kwargs):",
            "    \"\"\"Return task flow for no-op.",
            "",
            "    :param context: request context",
            "    :param task_id: Task ID.",
            "    :param task_type: Type of the task.",
            "    :param image_repo: Image repository used.",
            "    :param image_id: Image ID",
            "    :param action_wrapper: An api_image_import.ActionWrapper.",
            "    \"\"\"",
            "    context = kwargs.get('context')",
            "    task_id = kwargs.get('task_id')",
            "    task_type = kwargs.get('task_type')",
            "    action_wrapper = kwargs.get('action_wrapper')",
            "",
            "    return lf.Flow(task_type).add(",
            "        _ConvertImage(context, task_id, task_type, action_wrapper)",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "108": [
                "_ConvertImage",
                "_execute"
            ],
            "109": [
                "_ConvertImage",
                "_execute"
            ],
            "110": [
                "_ConvertImage",
                "_execute"
            ],
            "111": [
                "_ConvertImage",
                "_execute"
            ],
            "112": [
                "_ConvertImage",
                "_execute"
            ],
            "113": [
                "_ConvertImage",
                "_execute"
            ],
            "114": [
                "_ConvertImage",
                "_execute"
            ]
        },
        "addLocation": [
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.write_snap_yaml",
            "glance.async_.flows.plugins.image_conversion._ConvertImage.execute"
        ]
    },
    "glance/tests/unit/async_/flows/plugins/test_image_conversion.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " #    License for the specific language governing permissions and limitations"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " #    under the License."
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import fixtures"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import json"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import os"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from unittest import mock"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import glance.async_.flows.api_image_import as import_flow"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import glance.async_.flows.plugins.image_conversion as image_conversion"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from glance.async_ import utils as async_utils"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from glance.common import format_inspector"
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from glance.common import utils"
            },
            "12": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from glance import domain"
            },
            "13": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from glance import gateway"
            },
            "14": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                                                        self.image_id,"
            },
            "15": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "                                                        self.task.task_id)"
            },
            "16": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        self.inspector_mock = mock.MagicMock()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        self.useFixture(fixtures.MockPatch('glance.common.format_inspector.'"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                                           'get_inspector',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                                           self.inspector_mock))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     @mock.patch.object(os, 'stat')"
            },
            "23": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     @mock.patch.object(os, 'remove')"
            },
            "24": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def test_image_convert_success(self, mock_os_remove, mock_os_stat):"
            },
            "25": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         image = mock.MagicMock(image_id=self.image_id, virtual_size=None,"
            },
            "26": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                                extra_properties={"
            },
            "27": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                                    'os_glance_import_task': self.task.task_id},"
            },
            "28": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               disk_format='qcow2')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                               disk_format='raw')"
            },
            "30": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self.img_repo.get.return_value = image"
            },
            "31": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         with mock.patch.object(processutils, 'execute') as exc_mock:"
            },
            "33": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         self.assertEqual(456, image.virtual_size)"
            },
            "34": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         self.assertEqual(123, image.size)"
            },
            "35": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _setup_image_convert_info_fail(self):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    def _setup_image_convert_info_fail(self, disk_format='qcow2'):"
            },
            "38": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         image_convert = image_conversion._ConvertImage(self.context,"
            },
            "39": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "                                                        self.task.task_id,"
            },
            "40": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                                                        self.task_type,"
            },
            "41": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         image = mock.MagicMock(image_id=self.image_id, virtual_size=None,"
            },
            "42": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                                extra_properties={"
            },
            "43": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                                    'os_glance_import_task': self.task.task_id},"
            },
            "44": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               disk_format='qcow2')"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                               disk_format=disk_format)"
            },
            "46": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         self.img_repo.get.return_value = image"
            },
            "47": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         return image_convert"
            },
            "48": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "                               convert.execute, 'file:///test/path.raw')"
            },
            "50": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             exc_mock.assert_called_once_with("
            },
            "51": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "                 'qemu-img', 'info',"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                '-f', 'qcow2',"
            },
            "53": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                 '--output=json',"
            },
            "54": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                 '/test/path.raw',"
            },
            "55": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                 prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            },
            "56": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                               convert.execute, 'file:///test/path.raw')"
            },
            "57": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             exc_mock.assert_called_once_with("
            },
            "58": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                 'qemu-img', 'info',"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+                '-f', 'qcow2',"
            },
            "60": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "                 '--output=json',"
            },
            "61": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "                 '/test/path.raw',"
            },
            "62": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                 prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            },
            "63": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "             self.assertEqual('QCOW images with data-file set are not allowed',"
            },
            "64": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "                              str(e))"
            },
            "65": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 211,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+    def test_image_convert_no_inspector_match(self):"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail()"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        self.inspector_mock.return_value = None"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        self.assertRaisesRegex(RuntimeError,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                               'Unable to convert from format',"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+                               convert.execute, 'file:///test/path.hpfs')"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    def test_image_convert_fails_inspection_safety_check(self):"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail()"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        inspector = self.inspector_mock.return_value.from_file.return_value"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        inspector.safety_check.return_value = False"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        self.assertRaisesRegex(RuntimeError,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                               'Image has disallowed configuration',"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                               convert.execute, 'file:///test/path.qcow')"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    def test_image_convert_fails_inspection_format_check(self):"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail()"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        self.inspector_mock.return_value.from_file.side_effect = ("
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+            format_inspector.ImageFormatError())"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        self.assertRaisesRegex(RuntimeError,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+                               'Image format detection failed',"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                               convert.execute, 'file:///test/path.qcow')"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+    def test_image_convert_fails_inspection_error(self):"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail()"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        self.inspector_mock.return_value.from_file.side_effect = ValueError"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        self.assertRaisesRegex(RuntimeError,"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                               'Unable to inspect image',"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+                               convert.execute, 'file:///test/path.qcow')"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+"
            },
            "96": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "     def _test_image_convert_invalid_vmdk(self):"
            },
            "97": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         data = {'format': 'vmdk',"
            },
            "98": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "                 'format-specific': {"
            },
            "99": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "                     'data': {"
            },
            "100": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "                         'create-type': 'monolithicFlat',"
            },
            "101": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "                     }}}"
            },
            "102": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert = self._setup_image_convert_info_fail()"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail(disk_format='vmdk')"
            },
            "105": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         with mock.patch.object(processutils, 'execute') as exc_mock:"
            },
            "106": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             exc_mock.return_value = json.dumps(data), ''"
            },
            "107": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "             convert.execute('file:///test/path.vmdk')"
            },
            "108": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "                               self._test_image_convert_invalid_vmdk)"
            },
            "109": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 276,
                "PatchRowcode": " "
            },
            "110": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "     def test_image_convert_fails(self):"
            },
            "111": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert = self._setup_image_convert_info_fail()"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail(disk_format='raw')"
            },
            "113": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         with mock.patch.object(processutils, 'execute') as exc_mock:"
            },
            "114": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "             exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),"
            },
            "115": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "                                     OSError('convert_fail')]"
            },
            "116": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             self.assertRaises(OSError,"
            },
            "117": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "                               convert.execute, 'file:///test/path.raw')"
            },
            "118": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "             exc_mock.assert_has_calls("
            },
            "119": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "                 [mock.call('qemu-img', 'info',"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                           '-f', 'raw',"
            },
            "121": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "                            '--output=json',"
            },
            "122": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "                            '/test/path.raw',"
            },
            "123": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "                            prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            },
            "124": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         self.img_repo.save.assert_not_called()"
            },
            "125": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 297,
                "PatchRowcode": " "
            },
            "126": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "     def test_image_convert_reports_fail(self):"
            },
            "127": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert = self._setup_image_convert_info_fail()"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        convert = self._setup_image_convert_info_fail(disk_format='raw')"
            },
            "129": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         with mock.patch.object(processutils, 'execute') as exc_mock:"
            },
            "130": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),"
            },
            "131": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "                                     ('', 'some error')]"
            },
            "132": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "             self.assertRaises(RuntimeError,"
            },
            "133": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "                               convert.execute, 'file:///test/path.raw')"
            },
            "134": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "             exc_mock.assert_has_calls("
            },
            "135": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "                 [mock.call('qemu-img', 'info',"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+                           '-f', 'raw',"
            },
            "137": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "                            '--output=json',"
            },
            "138": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "                            '/test/path.raw',"
            },
            "139": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "                            prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            },
            "140": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "             exc_mock.return_value = ('{}', '')"
            },
            "141": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "             exc = self.assertRaises(RuntimeError,"
            },
            "142": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "                                     convert.execute, 'file:///test/path.raw')"
            },
            "143": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertIn('Source format not reported', str(exc))"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+            self.assertIn('Image metadata disagrees about format', str(exc))"
            },
            "145": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "             exc_mock.assert_called_once_with("
            },
            "146": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "                 'qemu-img', 'info',"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+                '-f', 'qcow2',"
            },
            "148": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "                 '--output=json',"
            },
            "149": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                 '/test/path.raw',"
            },
            "150": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "                 prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            },
            "151": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "             # Make sure we only called qemu-img for inspection, not conversion"
            },
            "152": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "             exc_mock.assert_called_once_with("
            },
            "153": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "                 'qemu-img', 'info',"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+                '-f', 'qcow2',"
            },
            "155": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "                 '--output=json',"
            },
            "156": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "                 '/test/path.qcow',"
            },
            "157": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "                 prlimit=async_utils.QEMU_IMG_PROC_LIMITS,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2018 RedHat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import json",
            "import os",
            "from unittest import mock",
            "",
            "import glance_store",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "",
            "import glance.async_.flows.api_image_import as import_flow",
            "import glance.async_.flows.plugins.image_conversion as image_conversion",
            "from glance.async_ import utils as async_utils",
            "from glance.common import utils",
            "from glance import domain",
            "from glance import gateway",
            "import glance.tests.utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class TestConvertImageTask(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestConvertImageTask, self).setUp()",
            "",
            "        glance_store.register_opts(CONF)",
            "        self.config(default_store='file',",
            "                    stores=['file', 'http'],",
            "                    filesystem_store_datadir=self.test_dir,",
            "                    group=\"glance_store\")",
            "        self.config(output_format='qcow2',",
            "                    group='image_conversion')",
            "        glance_store.create_stores(CONF)",
            "",
            "        self.work_dir = os.path.join(self.test_dir, 'work_dir')",
            "        utils.safe_mkdirs(self.work_dir)",
            "        self.config(work_dir=self.work_dir, group='task')",
            "",
            "        self.context = mock.MagicMock()",
            "        self.img_repo = mock.MagicMock()",
            "        self.task_repo = mock.MagicMock()",
            "        self.image_id = UUID1",
            "",
            "        self.gateway = gateway.Gateway()",
            "        self.task_factory = domain.TaskFactory()",
            "        self.img_factory = self.gateway.get_image_factory(self.context)",
            "        self.image = self.img_factory.new_image(image_id=self.image_id,",
            "                                                disk_format='raw',",
            "                                                container_format='bare')",
            "",
            "        task_input = {",
            "            \"import_from\": \"http://cloud.foo/image.raw\",",
            "            \"import_from_format\": \"raw\",",
            "            \"image_properties\": {'disk_format': 'raw',",
            "                                 'container_format': 'bare'}",
            "        }",
            "",
            "        task_ttl = CONF.task.task_time_to_live",
            "",
            "        self.task_type = 'import'",
            "        request_id = 'fake_request_id'",
            "        user_id = 'fake_user'",
            "        self.task = self.task_factory.new_task(self.task_type, TENANT1,",
            "                                               self.image_id, user_id,",
            "                                               request_id,",
            "                                               task_time_to_live=task_ttl,",
            "                                               task_input=task_input)",
            "",
            "        self.image.extra_properties = {",
            "            'os_glance_import_task': self.task.task_id}",
            "        self.wrapper = import_flow.ImportActionWrapper(self.img_repo,",
            "                                                       self.image_id,",
            "                                                       self.task.task_id)",
            "",
            "    @mock.patch.object(os, 'stat')",
            "    @mock.patch.object(os, 'remove')",
            "    def test_image_convert_success(self, mock_os_remove, mock_os_stat):",
            "        mock_os_remove.return_value = None",
            "        mock_os_stat.return_value.st_size = 123",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "        image = mock.MagicMock(image_id=self.image_id, virtual_size=None,",
            "                               extra_properties={",
            "                                   'os_glance_import_task': self.task.task_id},",
            "                               disk_format='qcow2')",
            "        self.img_repo.get.return_value = image",
            "",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (\"\", None)",
            "            with mock.patch.object(json, 'loads') as jloads_mock:",
            "                jloads_mock.return_value = {'format': 'raw',",
            "                                            'virtual-size': 456}",
            "                image_convert.execute('file:///test/path.raw')",
            "",
            "                # NOTE(hemanthm): Asserting that the source format is passed",
            "                # to qemu-utis to avoid inferring the image format. This",
            "                # shields us from an attack vector described at",
            "                # https://bugs.launchpad.net/glance/+bug/1449062/comments/72",
            "                self.assertIn('-f', exc_mock.call_args[0])",
            "                self.assertEqual(\"qcow2\", image.disk_format)",
            "",
            "        self.assertEqual('bare', image.container_format)",
            "        self.assertEqual('qcow2', image.disk_format)",
            "        self.assertEqual(456, image.virtual_size)",
            "        self.assertEqual(123, image.size)",
            "",
            "    def _setup_image_convert_info_fail(self):",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "        image = mock.MagicMock(image_id=self.image_id, virtual_size=None,",
            "                               extra_properties={",
            "                                   'os_glance_import_task': self.task.task_id},",
            "                               disk_format='qcow2')",
            "        self.img_repo.get.return_value = image",
            "        return image_convert",
            "",
            "    def test_image_convert_fails_inspection(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = OSError('fail')",
            "            self.assertRaises(OSError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_inspection_reports_error(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = '', 'some error'",
            "            self.assertRaises(RuntimeError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_invalid_qcow(self):",
            "        data = {'format': 'qcow2',",
            "                'backing-filename': '/etc/hosts'}",
            "",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            e = self.assertRaises(RuntimeError,",
            "                                  convert.execute, 'file:///test/path.qcow')",
            "            self.assertEqual('QCOW images with backing files are not allowed',",
            "                             str(e))",
            "",
            "    def test_image_convert_invalid_qcow_data_file(self):",
            "        data = {'format': 'qcow2',",
            "                'format-specific': {",
            "                    'data': {",
            "                        'data-file': '/etc/hosts',",
            "                    },",
            "                }}",
            "",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            e = self.assertRaises(RuntimeError,",
            "                                  convert.execute, 'file:///test/path.qcow')",
            "            self.assertEqual('QCOW images with data-file set are not allowed',",
            "                             str(e))",
            "",
            "    def _test_image_convert_invalid_vmdk(self):",
            "        data = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                    }}}",
            "",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            convert.execute('file:///test/path.vmdk')",
            "",
            "    def test_image_convert_invalid_vmdk(self):",
            "        e = self.assertRaises(RuntimeError,",
            "                              self._test_image_convert_invalid_vmdk)",
            "        self.assertEqual('Invalid VMDK create-type specified', str(e))",
            "",
            "    def test_image_convert_valid_vmdk_no_types(self):",
            "        with mock.patch.object(CONF.image_format, 'vmdk_allowed_types',",
            "                               new=[]):",
            "            # We make it past the VMDK check and fail because our file",
            "            # does not exist",
            "            e = self.assertRaises(RuntimeError,",
            "                                  self._test_image_convert_invalid_vmdk)",
            "            self.assertEqual('Image is a VMDK, but no VMDK createType is '",
            "                             'specified', str(e))",
            "",
            "    def test_image_convert_valid_vmdk(self):",
            "        with mock.patch.object(CONF.image_format, 'vmdk_allowed_types',",
            "                               new=['monolithicSparse', 'monolithicFlat']):",
            "            # We make it past the VMDK check and fail because our file",
            "            # does not exist",
            "            self.assertRaises(FileNotFoundError,",
            "                              self._test_image_convert_invalid_vmdk)",
            "",
            "    def test_image_convert_fails(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),",
            "                                    OSError('convert_fail')]",
            "            self.assertRaises(OSError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_has_calls(",
            "                [mock.call('qemu-img', 'info',",
            "                           '--output=json',",
            "                           '/test/path.raw',",
            "                           prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                           python_exec=convert.python,",
            "                           log_errors=processutils.LOG_ALL_ERRORS),",
            "                 mock.call('qemu-img', 'convert', '-f', 'raw', '-O', 'qcow2',",
            "                           '/test/path.raw', '/test/path.raw.qcow2',",
            "                           log_errors=processutils.LOG_ALL_ERRORS)])",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_reports_fail(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),",
            "                                    ('', 'some error')]",
            "            self.assertRaises(RuntimeError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_has_calls(",
            "                [mock.call('qemu-img', 'info',",
            "                           '--output=json',",
            "                           '/test/path.raw',",
            "                           prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                           python_exec=convert.python,",
            "                           log_errors=processutils.LOG_ALL_ERRORS),",
            "                 mock.call('qemu-img', 'convert', '-f', 'raw', '-O', 'qcow2',",
            "                           '/test/path.raw', '/test/path.raw.qcow2',",
            "                           log_errors=processutils.LOG_ALL_ERRORS)])",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_fails_source_format(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = ('{}', '')",
            "            exc = self.assertRaises(RuntimeError,",
            "                                    convert.execute, 'file:///test/path.raw')",
            "            self.assertIn('Source format not reported', str(exc))",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_same_format_does_nothing(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (",
            "                '{\"format\": \"qcow2\", \"virtual-size\": 123}', '')",
            "            convert.execute('file:///test/path.qcow')",
            "            # Make sure we only called qemu-img for inspection, not conversion",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '--output=json',",
            "                '/test/path.qcow',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "",
            "        # Make sure we set the virtual_size before we exited",
            "        image = self.img_repo.get.return_value",
            "        self.assertEqual(123, image.virtual_size)",
            "",
            "    @mock.patch.object(os, 'remove')",
            "    def test_image_convert_revert_success(self, mock_os_remove):",
            "        mock_os_remove.return_value = None",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (\"\", None)",
            "            with mock.patch.object(os.path, 'exists') as os_exists_mock:",
            "                os_exists_mock.return_value = True",
            "                image_convert.revert(result=mock.MagicMock())",
            "                self.assertEqual(1, mock_os_remove.call_count)",
            "",
            "    def test_image_convert_interpreter_configured(self):",
            "        # By default, wsgi.python_interpreter is None; if it is",
            "        # overridden, we should take the interpreter from config.",
            "        fake_interpreter = '/usr/bin/python2.7'",
            "        self.config(python_interpreter=fake_interpreter,",
            "                    group='wsgi')",
            "        convert = image_conversion._ConvertImage(self.context,",
            "                                                 self.task.task_id,",
            "                                                 self.task_type,",
            "                                                 self.wrapper)",
            "        self.assertEqual(fake_interpreter, convert.python)"
        ],
        "afterPatchFile": [
            "# Copyright 2018 RedHat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import fixtures",
            "import json",
            "import os",
            "from unittest import mock",
            "",
            "import glance_store",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "",
            "import glance.async_.flows.api_image_import as import_flow",
            "import glance.async_.flows.plugins.image_conversion as image_conversion",
            "from glance.async_ import utils as async_utils",
            "from glance.common import format_inspector",
            "from glance.common import utils",
            "from glance import domain",
            "from glance import gateway",
            "import glance.tests.utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class TestConvertImageTask(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestConvertImageTask, self).setUp()",
            "",
            "        glance_store.register_opts(CONF)",
            "        self.config(default_store='file',",
            "                    stores=['file', 'http'],",
            "                    filesystem_store_datadir=self.test_dir,",
            "                    group=\"glance_store\")",
            "        self.config(output_format='qcow2',",
            "                    group='image_conversion')",
            "        glance_store.create_stores(CONF)",
            "",
            "        self.work_dir = os.path.join(self.test_dir, 'work_dir')",
            "        utils.safe_mkdirs(self.work_dir)",
            "        self.config(work_dir=self.work_dir, group='task')",
            "",
            "        self.context = mock.MagicMock()",
            "        self.img_repo = mock.MagicMock()",
            "        self.task_repo = mock.MagicMock()",
            "        self.image_id = UUID1",
            "",
            "        self.gateway = gateway.Gateway()",
            "        self.task_factory = domain.TaskFactory()",
            "        self.img_factory = self.gateway.get_image_factory(self.context)",
            "        self.image = self.img_factory.new_image(image_id=self.image_id,",
            "                                                disk_format='raw',",
            "                                                container_format='bare')",
            "",
            "        task_input = {",
            "            \"import_from\": \"http://cloud.foo/image.raw\",",
            "            \"import_from_format\": \"raw\",",
            "            \"image_properties\": {'disk_format': 'raw',",
            "                                 'container_format': 'bare'}",
            "        }",
            "",
            "        task_ttl = CONF.task.task_time_to_live",
            "",
            "        self.task_type = 'import'",
            "        request_id = 'fake_request_id'",
            "        user_id = 'fake_user'",
            "        self.task = self.task_factory.new_task(self.task_type, TENANT1,",
            "                                               self.image_id, user_id,",
            "                                               request_id,",
            "                                               task_time_to_live=task_ttl,",
            "                                               task_input=task_input)",
            "",
            "        self.image.extra_properties = {",
            "            'os_glance_import_task': self.task.task_id}",
            "        self.wrapper = import_flow.ImportActionWrapper(self.img_repo,",
            "                                                       self.image_id,",
            "                                                       self.task.task_id)",
            "",
            "        self.inspector_mock = mock.MagicMock()",
            "        self.useFixture(fixtures.MockPatch('glance.common.format_inspector.'",
            "                                           'get_inspector',",
            "                                           self.inspector_mock))",
            "",
            "    @mock.patch.object(os, 'stat')",
            "    @mock.patch.object(os, 'remove')",
            "    def test_image_convert_success(self, mock_os_remove, mock_os_stat):",
            "        mock_os_remove.return_value = None",
            "        mock_os_stat.return_value.st_size = 123",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "        image = mock.MagicMock(image_id=self.image_id, virtual_size=None,",
            "                               extra_properties={",
            "                                   'os_glance_import_task': self.task.task_id},",
            "                               disk_format='raw')",
            "        self.img_repo.get.return_value = image",
            "",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (\"\", None)",
            "            with mock.patch.object(json, 'loads') as jloads_mock:",
            "                jloads_mock.return_value = {'format': 'raw',",
            "                                            'virtual-size': 456}",
            "                image_convert.execute('file:///test/path.raw')",
            "",
            "                # NOTE(hemanthm): Asserting that the source format is passed",
            "                # to qemu-utis to avoid inferring the image format. This",
            "                # shields us from an attack vector described at",
            "                # https://bugs.launchpad.net/glance/+bug/1449062/comments/72",
            "                self.assertIn('-f', exc_mock.call_args[0])",
            "                self.assertEqual(\"qcow2\", image.disk_format)",
            "",
            "        self.assertEqual('bare', image.container_format)",
            "        self.assertEqual('qcow2', image.disk_format)",
            "        self.assertEqual(456, image.virtual_size)",
            "        self.assertEqual(123, image.size)",
            "",
            "    def _setup_image_convert_info_fail(self, disk_format='qcow2'):",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "        image = mock.MagicMock(image_id=self.image_id, virtual_size=None,",
            "                               extra_properties={",
            "                                   'os_glance_import_task': self.task.task_id},",
            "                               disk_format=disk_format)",
            "        self.img_repo.get.return_value = image",
            "        return image_convert",
            "",
            "    def test_image_convert_fails_inspection(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = OSError('fail')",
            "            self.assertRaises(OSError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '-f', 'qcow2',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_inspection_reports_error(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = '', 'some error'",
            "            self.assertRaises(RuntimeError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '-f', 'qcow2',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_invalid_qcow(self):",
            "        data = {'format': 'qcow2',",
            "                'backing-filename': '/etc/hosts'}",
            "",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            e = self.assertRaises(RuntimeError,",
            "                                  convert.execute, 'file:///test/path.qcow')",
            "            self.assertEqual('QCOW images with backing files are not allowed',",
            "                             str(e))",
            "",
            "    def test_image_convert_invalid_qcow_data_file(self):",
            "        data = {'format': 'qcow2',",
            "                'format-specific': {",
            "                    'data': {",
            "                        'data-file': '/etc/hosts',",
            "                    },",
            "                }}",
            "",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            e = self.assertRaises(RuntimeError,",
            "                                  convert.execute, 'file:///test/path.qcow')",
            "            self.assertEqual('QCOW images with data-file set are not allowed',",
            "                             str(e))",
            "",
            "    def test_image_convert_no_inspector_match(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        self.inspector_mock.return_value = None",
            "        self.assertRaisesRegex(RuntimeError,",
            "                               'Unable to convert from format',",
            "                               convert.execute, 'file:///test/path.hpfs')",
            "",
            "    def test_image_convert_fails_inspection_safety_check(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        inspector = self.inspector_mock.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = False",
            "        self.assertRaisesRegex(RuntimeError,",
            "                               'Image has disallowed configuration',",
            "                               convert.execute, 'file:///test/path.qcow')",
            "",
            "    def test_image_convert_fails_inspection_format_check(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        self.inspector_mock.return_value.from_file.side_effect = (",
            "            format_inspector.ImageFormatError())",
            "        self.assertRaisesRegex(RuntimeError,",
            "                               'Image format detection failed',",
            "                               convert.execute, 'file:///test/path.qcow')",
            "",
            "    def test_image_convert_fails_inspection_error(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        self.inspector_mock.return_value.from_file.side_effect = ValueError",
            "        self.assertRaisesRegex(RuntimeError,",
            "                               'Unable to inspect image',",
            "                               convert.execute, 'file:///test/path.qcow')",
            "",
            "    def _test_image_convert_invalid_vmdk(self):",
            "        data = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                    }}}",
            "",
            "        convert = self._setup_image_convert_info_fail(disk_format='vmdk')",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = json.dumps(data), ''",
            "            convert.execute('file:///test/path.vmdk')",
            "",
            "    def test_image_convert_invalid_vmdk(self):",
            "        e = self.assertRaises(RuntimeError,",
            "                              self._test_image_convert_invalid_vmdk)",
            "        self.assertEqual('Invalid VMDK create-type specified', str(e))",
            "",
            "    def test_image_convert_valid_vmdk_no_types(self):",
            "        with mock.patch.object(CONF.image_format, 'vmdk_allowed_types',",
            "                               new=[]):",
            "            # We make it past the VMDK check and fail because our file",
            "            # does not exist",
            "            e = self.assertRaises(RuntimeError,",
            "                                  self._test_image_convert_invalid_vmdk)",
            "            self.assertEqual('Image is a VMDK, but no VMDK createType is '",
            "                             'specified', str(e))",
            "",
            "    def test_image_convert_valid_vmdk(self):",
            "        with mock.patch.object(CONF.image_format, 'vmdk_allowed_types',",
            "                               new=['monolithicSparse', 'monolithicFlat']):",
            "            # We make it past the VMDK check and fail because our file",
            "            # does not exist",
            "            self.assertRaises(FileNotFoundError,",
            "                              self._test_image_convert_invalid_vmdk)",
            "",
            "    def test_image_convert_fails(self):",
            "        convert = self._setup_image_convert_info_fail(disk_format='raw')",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),",
            "                                    OSError('convert_fail')]",
            "            self.assertRaises(OSError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_has_calls(",
            "                [mock.call('qemu-img', 'info',",
            "                           '-f', 'raw',",
            "                           '--output=json',",
            "                           '/test/path.raw',",
            "                           prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                           python_exec=convert.python,",
            "                           log_errors=processutils.LOG_ALL_ERRORS),",
            "                 mock.call('qemu-img', 'convert', '-f', 'raw', '-O', 'qcow2',",
            "                           '/test/path.raw', '/test/path.raw.qcow2',",
            "                           log_errors=processutils.LOG_ALL_ERRORS)])",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_reports_fail(self):",
            "        convert = self._setup_image_convert_info_fail(disk_format='raw')",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.side_effect = [('{\"format\":\"raw\"}', ''),",
            "                                    ('', 'some error')]",
            "            self.assertRaises(RuntimeError,",
            "                              convert.execute, 'file:///test/path.raw')",
            "            exc_mock.assert_has_calls(",
            "                [mock.call('qemu-img', 'info',",
            "                           '-f', 'raw',",
            "                           '--output=json',",
            "                           '/test/path.raw',",
            "                           prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                           python_exec=convert.python,",
            "                           log_errors=processutils.LOG_ALL_ERRORS),",
            "                 mock.call('qemu-img', 'convert', '-f', 'raw', '-O', 'qcow2',",
            "                           '/test/path.raw', '/test/path.raw.qcow2',",
            "                           log_errors=processutils.LOG_ALL_ERRORS)])",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_fails_source_format(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = ('{}', '')",
            "            exc = self.assertRaises(RuntimeError,",
            "                                    convert.execute, 'file:///test/path.raw')",
            "            self.assertIn('Image metadata disagrees about format', str(exc))",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '-f', 'qcow2',",
            "                '--output=json',",
            "                '/test/path.raw',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "        # Make sure we did not update the image",
            "        self.img_repo.save.assert_not_called()",
            "",
            "    def test_image_convert_same_format_does_nothing(self):",
            "        convert = self._setup_image_convert_info_fail()",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (",
            "                '{\"format\": \"qcow2\", \"virtual-size\": 123}', '')",
            "            convert.execute('file:///test/path.qcow')",
            "            # Make sure we only called qemu-img for inspection, not conversion",
            "            exc_mock.assert_called_once_with(",
            "                'qemu-img', 'info',",
            "                '-f', 'qcow2',",
            "                '--output=json',",
            "                '/test/path.qcow',",
            "                prlimit=async_utils.QEMU_IMG_PROC_LIMITS,",
            "                python_exec=convert.python,",
            "                log_errors=processutils.LOG_ALL_ERRORS)",
            "",
            "        # Make sure we set the virtual_size before we exited",
            "        image = self.img_repo.get.return_value",
            "        self.assertEqual(123, image.virtual_size)",
            "",
            "    @mock.patch.object(os, 'remove')",
            "    def test_image_convert_revert_success(self, mock_os_remove):",
            "        mock_os_remove.return_value = None",
            "        image_convert = image_conversion._ConvertImage(self.context,",
            "                                                       self.task.task_id,",
            "                                                       self.task_type,",
            "                                                       self.wrapper)",
            "",
            "        self.task_repo.get.return_value = self.task",
            "",
            "        with mock.patch.object(processutils, 'execute') as exc_mock:",
            "            exc_mock.return_value = (\"\", None)",
            "            with mock.patch.object(os.path, 'exists') as os_exists_mock:",
            "                os_exists_mock.return_value = True",
            "                image_convert.revert(result=mock.MagicMock())",
            "                self.assertEqual(1, mock_os_remove.call_count)",
            "",
            "    def test_image_convert_interpreter_configured(self):",
            "        # By default, wsgi.python_interpreter is None; if it is",
            "        # overridden, we should take the interpreter from config.",
            "        fake_interpreter = '/usr/bin/python2.7'",
            "        self.config(python_interpreter=fake_interpreter,",
            "                    group='wsgi')",
            "        convert = image_conversion._ConvertImage(self.context,",
            "                                                 self.task.task_id,",
            "                                                 self.task_type,",
            "                                                 self.wrapper)",
            "        self.assertEqual(fake_interpreter, convert.python)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "107": [
                "TestConvertImageTask",
                "test_image_convert_success"
            ],
            "129": [
                "TestConvertImageTask",
                "_setup_image_convert_info_fail"
            ],
            "139": [
                "TestConvertImageTask",
                "_setup_image_convert_info_fail"
            ],
            "210": [
                "TestConvertImageTask",
                "_test_image_convert_invalid_vmdk"
            ],
            "239": [
                "TestConvertImageTask",
                "test_image_convert_fails"
            ],
            "259": [
                "TestConvertImageTask",
                "test_image_convert_reports_fail"
            ],
            "284": [
                "TestConvertImageTask",
                "test_image_convert_fails_source_format"
            ]
        },
        "addLocation": [
            "glance.tests.unit.async_.flows.plugins.test_image_conversion.TestConvertImageTask.setUp.task_input",
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.write_snap_yaml",
            "glance.tests.unit.async_.flows.plugins.test_image_conversion.TestConvertImageTask.self"
        ]
    }
}