{
    "cinder/tests/test_volume.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1439,
                "afterPatchRowNumber": 1439,
                "PatchRowcode": "         self.stubs.Set(self.volume.driver, '_volume_not_present',"
            },
            "1": {
                "beforePatchRowNumber": 1440,
                "afterPatchRowNumber": 1440,
                "PatchRowcode": "                        lambda x: False)"
            },
            "2": {
                "beforePatchRowNumber": 1441,
                "afterPatchRowNumber": 1441,
                "PatchRowcode": "         self.stubs.Set(self.volume.driver, '_delete_volume',"
            },
            "3": {
                "beforePatchRowNumber": 1442,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       lambda x, y: False)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1442,
                "PatchRowcode": "+                       lambda x: False)"
            },
            "5": {
                "beforePatchRowNumber": 1443,
                "afterPatchRowNumber": 1443,
                "PatchRowcode": "         # Want DriverTestCase._fake_execute to return 'o' so that"
            },
            "6": {
                "beforePatchRowNumber": 1444,
                "afterPatchRowNumber": 1444,
                "PatchRowcode": "         # volume.driver.delete_volume() raises the VolumeIsBusy exception."
            },
            "7": {
                "beforePatchRowNumber": 1445,
                "afterPatchRowNumber": 1445,
                "PatchRowcode": "         self.output = 'o'"
            },
            "8": {
                "beforePatchRowNumber": 1490,
                "afterPatchRowNumber": 1490,
                "PatchRowcode": "         self.assertEquals(bs, '1M')"
            },
            "9": {
                "beforePatchRowNumber": 1491,
                "afterPatchRowNumber": 1491,
                "PatchRowcode": "         self.assertEquals(count, 1024)"
            },
            "10": {
                "beforePatchRowNumber": 1492,
                "afterPatchRowNumber": 1492,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1493,
                "PatchRowcode": "+    def test_clear_volume(self):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1494,
                "PatchRowcode": "+        configuration = conf.Configuration(fake_opt, 'fake_group')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1495,
                "PatchRowcode": "+        configuration.volume_clear = 'zero'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1496,
                "PatchRowcode": "+        configuration.volume_clear_size = 0"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1497,
                "PatchRowcode": "+        lvm_driver = lvm.LVMVolumeDriver(configuration=configuration)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1498,
                "PatchRowcode": "+        self.stubs.Set(lvm_driver, '_copy_volume', lambda *a, **kw: True)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1499,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1500,
                "PatchRowcode": "+        fake_volume = {'name': 'test1',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1501,
                "PatchRowcode": "+                       'volume_name': 'test1',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1502,
                "PatchRowcode": "+                       'id': 'test1'}"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1503,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1504,
                "PatchRowcode": "+        # Test volume has 'size' field"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1505,
                "PatchRowcode": "+        volume = dict(fake_volume, size='123')"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1506,
                "PatchRowcode": "+        self.assertEquals(True, lvm_driver.clear_volume(volume))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1507,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1508,
                "PatchRowcode": "+        # Test volume has 'volume_size' field"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1509,
                "PatchRowcode": "+        volume = dict(fake_volume, volume_size='123')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1510,
                "PatchRowcode": "+        self.assertEquals(True, lvm_driver.clear_volume(volume))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1511,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1512,
                "PatchRowcode": "+        # Test volume without 'size' field and 'volume_size' field"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1513,
                "PatchRowcode": "+        volume = dict(fake_volume)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1514,
                "PatchRowcode": "+        self.assertEquals(None, lvm_driver.clear_volume(volume))"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1515,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 1493,
                "afterPatchRowNumber": 1516,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 1494,
                "afterPatchRowNumber": 1517,
                "PatchRowcode": " class ISCSITestCase(DriverTestCase):"
            },
            "36": {
                "beforePatchRowNumber": 1495,
                "afterPatchRowNumber": 1518,
                "PatchRowcode": "     \"\"\"Test Case for ISCSIDriver\"\"\""
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Tests for Volume Code.",
            "",
            "\"\"\"",
            "",
            "import datetime",
            "import os",
            "import re",
            "import shutil",
            "import tempfile",
            "",
            "import mox",
            "from oslo.config import cfg",
            "",
            "from cinder.brick.iscsi import iscsi",
            "from cinder import context",
            "from cinder import db",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import importutils",
            "from cinder.openstack.common.notifier import api as notifier_api",
            "from cinder.openstack.common.notifier import test_notifier",
            "from cinder.openstack.common import rpc",
            "import cinder.policy",
            "from cinder import quota",
            "from cinder import test",
            "from cinder.tests import conf_fixture",
            "from cinder.tests.image import fake as fake_image",
            "from cinder.volume import configuration as conf",
            "from cinder.volume import driver",
            "from cinder.volume.drivers import lvm",
            "",
            "",
            "QUOTAS = quota.QUOTAS",
            "",
            "CONF = cfg.CONF",
            "",
            "fake_opt = [",
            "    cfg.StrOpt('fake_opt', default='fake', help='fake opts')",
            "]",
            "",
            "",
            "class VolumeTestCase(test.TestCase):",
            "    \"\"\"Test Case for volumes.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VolumeTestCase, self).setUp()",
            "        vol_tmpdir = tempfile.mkdtemp()",
            "        self.flags(connection_type='fake',",
            "                   volumes_dir=vol_tmpdir,",
            "                   notification_driver=[test_notifier.__name__])",
            "        self.volume = importutils.import_object(CONF.volume_manager)",
            "        self.context = context.get_admin_context()",
            "        self.stubs.Set(iscsi.TgtAdm, '_get_target', self.fake_get_target)",
            "        fake_image.stub_out_image_service(self.stubs)",
            "        test_notifier.NOTIFICATIONS = []",
            "",
            "    def tearDown(self):",
            "        try:",
            "            shutil.rmtree(CONF.volumes_dir)",
            "        except OSError:",
            "            pass",
            "        notifier_api._reset_drivers()",
            "        super(VolumeTestCase, self).tearDown()",
            "",
            "    def fake_get_target(obj, iqn):",
            "        return 1",
            "",
            "    @staticmethod",
            "    def _create_volume(size=0, snapshot_id=None, image_id=None,",
            "                       source_volid=None, metadata=None, status=\"creating\"):",
            "        \"\"\"Create a volume object.\"\"\"",
            "        vol = {}",
            "        vol['size'] = size",
            "        vol['snapshot_id'] = snapshot_id",
            "        vol['image_id'] = image_id",
            "        vol['source_volid'] = source_volid",
            "        vol['user_id'] = 'fake'",
            "        vol['project_id'] = 'fake'",
            "        vol['availability_zone'] = CONF.storage_availability_zone",
            "        vol['status'] = status",
            "        vol['attach_status'] = \"detached\"",
            "        vol['host'] = CONF.host",
            "        if metadata is not None:",
            "            vol['metadata'] = metadata",
            "        return db.volume_create(context.get_admin_context(), vol)",
            "",
            "    def test_init_host_clears_downloads(self):",
            "        \"\"\"Test that init_host will unwedge a volume stuck in downloading.\"\"\"",
            "        volume = self._create_volume(status='downloading')",
            "        volume_id = volume['id']",
            "        self.volume.init_host()",
            "        volume = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEquals(volume['status'], \"error\")",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_create_delete_volume(self):",
            "        \"\"\"Test volume can be created and deleted.\"\"\"",
            "        # Need to stub out reserve, commit, and rollback",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 0)",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 2)",
            "        msg = test_notifier.NOTIFICATIONS[0]",
            "        self.assertEqual(msg['event_type'], 'volume.create.start')",
            "        expected = {",
            "            'status': 'creating',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': '',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[1]",
            "        self.assertEqual(msg['event_type'], 'volume.create.end')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': '',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        self.assertEqual(volume_id, db.volume_get(context.get_admin_context(),",
            "                         volume_id).id)",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        vol = db.volume_get(context.get_admin_context(read_deleted='yes'),",
            "                            volume_id)",
            "        self.assertEquals(vol['status'], 'deleted')",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 4)",
            "        msg = test_notifier.NOTIFICATIONS[2]",
            "        self.assertEqual(msg['event_type'], 'volume.delete.start')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': 'DONTCARE',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[3]",
            "        self.assertEqual(msg['event_type'], 'volume.delete.end')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': 'DONTCARE',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        self.assertRaises(exception.NotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_create_delete_volume_with_metadata(self):",
            "        \"\"\"Test volume can be created with metadata and deleted.\"\"\"",
            "        test_meta = {'fake_key': 'fake_value'}",
            "        volume = self._create_volume(0, None, metadata=test_meta)",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        result_meta = {",
            "            volume.volume_metadata[0].key: volume.volume_metadata[0].value}",
            "        self.assertEqual(result_meta, test_meta)",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.NotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_create_volume_with_invalid_metadata(self):",
            "        \"\"\"Test volume create with too much metadata fails.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        test_meta = {'fake_key': 'fake_value' * 256}",
            "        self.assertRaises(exception.InvalidVolumeMetadataSize,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          1,",
            "                          'name',",
            "                          'description',",
            "                          None,",
            "                          None,",
            "                          None,",
            "                          test_meta)",
            "",
            "    def test_create_volume_with_volume_type(self):",
            "        \"\"\"Test volume creation with default volume type.\"\"\"",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # Create volume with default volume type while default",
            "        # volume type doesn't exist, volume_type_id should be NULL",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['volume_type_id'], None)",
            "",
            "        # Create default volume type",
            "        vol_type = conf_fixture.def_vol_type",
            "        db.volume_type_create(context.get_admin_context(),",
            "                              dict(name=vol_type, extra_specs={}))",
            "",
            "        db_vol_type = db.volume_type_get_by_name(context.get_admin_context(),",
            "                                                 vol_type)",
            "",
            "        # Create volume with default volume type",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['volume_type_id'], db_vol_type.get('id'))",
            "",
            "        # Create volume with specific volume type",
            "        vol_type = 'test'",
            "        db.volume_type_create(context.get_admin_context(),",
            "                              dict(name=vol_type, extra_specs={}))",
            "        db_vol_type = db.volume_type_get_by_name(context.get_admin_context(),",
            "                                                 vol_type)",
            "",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description',",
            "                                   volume_type=db_vol_type)",
            "        self.assertEquals(volume['volume_type_id'], db_vol_type.get('id'))",
            "",
            "    def test_delete_busy_volume(self):",
            "        \"\"\"Test volume survives deletion if driver reports it as busy.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "",
            "        self.mox.StubOutWithMock(self.volume.driver, 'delete_volume')",
            "        self.volume.driver.delete_volume(",
            "            mox.IgnoreArg()).AndRaise(exception.VolumeIsBusy(",
            "                                      volume_name='fake'))",
            "        self.mox.ReplayAll()",
            "        res = self.volume.delete_volume(self.context, volume_id)",
            "        self.assertEqual(True, res)",
            "        volume_ref = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(volume_id, volume_ref.id)",
            "        self.assertEqual(\"available\", volume_ref.status)",
            "",
            "        self.mox.UnsetStubs()",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_create_volume_from_snapshot(self):",
            "        \"\"\"Test volume can be created from a snapshot.\"\"\"",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        snapshot_id = self._create_snapshot(volume_src['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume_src['id'],",
            "                                    snapshot_id)",
            "        volume_dst = self._create_volume(0, snapshot_id)",
            "        self.volume.create_volume(self.context, volume_dst['id'], snapshot_id)",
            "        self.assertEqual(volume_dst['id'],",
            "                         db.volume_get(",
            "                             context.get_admin_context(),",
            "                             volume_dst['id']).id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).snapshot_id)",
            "",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_create_volume_from_snapshot_fail_bad_size(self):",
            "        \"\"\"Test volume can't be created from snapshot with bad volume size.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        snapshot = dict(id=1234,",
            "                        status='available',",
            "                        volume_size=10)",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          size=1,",
            "                          name='fake_name',",
            "                          description='fake_desc',",
            "                          snapshot=snapshot)",
            "",
            "    def test_create_volume_with_invalid_exclusive_options(self):",
            "        \"\"\"Test volume create with multiple exclusive options fails.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          1,",
            "                          'name',",
            "                          'description',",
            "                          snapshot='fake_id',",
            "                          image_id='fake_id',",
            "                          source_volume='fake_id')",
            "",
            "    def test_too_big_volume(self):",
            "        \"\"\"Ensure failure if a too large of a volume is requested.\"\"\"",
            "        # FIXME(vish): validation needs to move into the data layer in",
            "        #              volume_create",
            "        return True",
            "        try:",
            "            volume = self._create_volume(1001)",
            "            self.volume.create_volume(self.context, volume)",
            "            self.fail(\"Should have thrown TypeError\")",
            "        except TypeError:",
            "            pass",
            "",
            "    def test_run_attach_detach_volume(self):",
            "        \"\"\"Make sure volume can be attached and detached from instance.\"\"\"",
            "        mountpoint = \"/dev/sdf\"",
            "        # attach volume to the instance then to detach",
            "        instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.volume.attach_volume(self.context, volume_id, instance_uuid,",
            "                                  None, mountpoint)",
            "        vol = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(vol['status'], \"in-use\")",
            "        self.assertEqual(vol['attach_status'], \"attached\")",
            "        self.assertEqual(vol['mountpoint'], mountpoint)",
            "        self.assertEqual(vol['instance_uuid'], instance_uuid)",
            "        self.assertEqual(vol['attached_host'], None)",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          self.volume.delete_volume,",
            "                          self.context,",
            "                          volume_id)",
            "        self.volume.detach_volume(self.context, volume_id)",
            "        vol = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(vol['status'], \"available\")",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.VolumeNotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "        # attach volume to the host then to detach",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.volume.attach_volume(self.context, volume_id, None,",
            "                                  'fake_host', mountpoint)",
            "        vol = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(vol['status'], \"in-use\")",
            "        self.assertEqual(vol['attach_status'], \"attached\")",
            "        self.assertEqual(vol['mountpoint'], mountpoint)",
            "        self.assertEqual(vol['instance_uuid'], None)",
            "        # sanitized, conforms to RFC-952 and RFC-1123 specs.",
            "        self.assertEqual(vol['attached_host'], 'fake-host')",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          self.volume.delete_volume,",
            "                          self.context,",
            "                          volume_id)",
            "        self.volume.detach_volume(self.context, volume_id)",
            "        vol = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(vol['status'], \"available\")",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.VolumeNotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_concurrent_volumes_get_different_targets(self):",
            "        \"\"\"Ensure multiple concurrent volumes get different targets.\"\"\"",
            "        volume_ids = []",
            "        targets = []",
            "",
            "        def _check(volume_id):",
            "            \"\"\"Make sure targets aren't duplicated.\"\"\"",
            "            volume_ids.append(volume_id)",
            "            admin_context = context.get_admin_context()",
            "            iscsi_target = db.volume_get_iscsi_target_num(admin_context,",
            "                                                          volume_id)",
            "            self.assert_(iscsi_target not in targets)",
            "            targets.append(iscsi_target)",
            "",
            "        total_slots = CONF.iscsi_num_targets",
            "        for _index in xrange(total_slots):",
            "            self._create_volume()",
            "        for volume_id in volume_ids:",
            "            self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_multi_node(self):",
            "        # TODO(termie): Figure out how to test with two nodes,",
            "        # each of them having a different FLAG for storage_node",
            "        # This will allow us to test cross-node interactions",
            "        pass",
            "",
            "    @staticmethod",
            "    def _create_snapshot(volume_id, size='0'):",
            "        \"\"\"Create a snapshot object.\"\"\"",
            "        snap = {}",
            "        snap['volume_size'] = size",
            "        snap['user_id'] = 'fake'",
            "        snap['project_id'] = 'fake'",
            "        snap['volume_id'] = volume_id",
            "        snap['status'] = \"creating\"",
            "        return db.snapshot_create(context.get_admin_context(), snap)",
            "",
            "    def test_create_delete_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 0)",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 2)",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.snapshot_get(context.get_admin_context(),",
            "                                         snapshot_id).id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 4)",
            "        msg = test_notifier.NOTIFICATIONS[2]",
            "        self.assertEquals(msg['event_type'], 'snapshot.create.start')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'creating',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[3]",
            "        self.assertEquals(msg['event_type'], 'snapshot.create.end')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'creating',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 6)",
            "        msg = test_notifier.NOTIFICATIONS[4]",
            "        self.assertEquals(msg['event_type'], 'snapshot.delete.start')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'available',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[5]",
            "        self.assertEquals(msg['event_type'], 'snapshot.delete.end')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'available',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "",
            "        snap = db.snapshot_get(context.get_admin_context(read_deleted='yes'),",
            "                               snapshot_id)",
            "        self.assertEquals(snap['status'], 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          db.snapshot_get,",
            "                          self.context,",
            "                          snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_delete_volume_in_use(self):",
            "        \"\"\"Test volume can't be deleted in invalid stats.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'in-use'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # 'in-use' status raises InvalidVolume",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_force_delete_volume(self):",
            "        \"\"\"Test volume can be forced to delete.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'error_deleting'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # 'error_deleting' volumes can't be deleted",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "",
            "        # delete with force",
            "        volume_api.delete(self.context, volume, force=True)",
            "",
            "        # status is deleting",
            "        volume = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(volume['status'], 'deleting')",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_force_delete_attached_volume(self):",
            "        \"\"\"Test volume can't be force delete in attached state\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'in-use'",
            "        volume['attach_status'] = 'attached'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume,",
            "                          force=True)",
            "",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_delete_volume_with_snapshots(self):",
            "        \"\"\"Test volume can't be deleted with dependent snapshots.\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.snapshot_get(context.get_admin_context(),",
            "                                         snapshot_id).id)",
            "",
            "        volume['status'] = 'available'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_can_delete_errored_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        snapshot = db.snapshot_get(context.get_admin_context(),",
            "                                   snapshot_id)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        snapshot['status'] = 'badstatus'",
            "        self.assertRaises(exception.InvalidSnapshot,",
            "                          volume_api.delete_snapshot,",
            "                          self.context,",
            "                          snapshot)",
            "",
            "        snapshot['status'] = 'error'",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_snapshot_force(self):",
            "        \"\"\"Test snapshot in use can be created forcibly.\"\"\"",
            "",
            "        def fake_cast(ctxt, topic, msg):",
            "            pass",
            "        self.stubs.Set(rpc, 'cast', fake_cast)",
            "        instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "        # create volume and attach to the instance",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        db.volume_attached(self.context, volume['id'], instance_uuid,",
            "                           None, '/dev/sda1')",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        volume = volume_api.get(self.context, volume['id'])",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.create_snapshot,",
            "                          self.context, volume,",
            "                          'fake_name', 'fake_description')",
            "        snapshot_ref = volume_api.create_snapshot_force(self.context,",
            "                                                        volume,",
            "                                                        'fake_name',",
            "                                                        'fake_description')",
            "        db.snapshot_destroy(self.context, snapshot_ref['id'])",
            "        db.volume_destroy(self.context, volume['id'])",
            "",
            "        # create volume and attach to the host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        db.volume_attached(self.context, volume['id'], None,",
            "                           'fake_host', '/dev/sda1')",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        volume = volume_api.get(self.context, volume['id'])",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.create_snapshot,",
            "                          self.context, volume,",
            "                          'fake_name', 'fake_description')",
            "        snapshot_ref = volume_api.create_snapshot_force(self.context,",
            "                                                        volume,",
            "                                                        'fake_name',",
            "                                                        'fake_description')",
            "        db.snapshot_destroy(self.context, snapshot_ref['id'])",
            "        db.volume_destroy(self.context, volume['id'])",
            "",
            "    def test_delete_busy_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        snapshot_id = self._create_snapshot(volume_id)['id']",
            "        self.volume.create_snapshot(self.context, volume_id, snapshot_id)",
            "",
            "        self.mox.StubOutWithMock(self.volume.driver, 'delete_snapshot')",
            "        self.volume.driver.delete_snapshot(",
            "            mox.IgnoreArg()).AndRaise(",
            "                exception.SnapshotIsBusy(snapshot_name='fake'))",
            "        self.mox.ReplayAll()",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        snapshot_ref = db.snapshot_get(self.context, snapshot_id)",
            "        self.assertEqual(snapshot_id, snapshot_ref.id)",
            "        self.assertEqual(\"available\", snapshot_ref.status)",
            "",
            "        self.mox.UnsetStubs()",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def _create_volume_from_image(self, fakeout_copy_image_to_volume=False):",
            "        \"\"\"Call copy image to volume, Test the status of volume after calling",
            "        copying image to volume.",
            "        \"\"\"",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        def fake_copy_image_to_volume(context, volume,",
            "                                      image_service, image_id):",
            "            pass",
            "",
            "        def fake_fetch_to_raw(context, image_service, image_id, vol_path):",
            "            pass",
            "",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "        self.stubs.Set(image_utils, 'fetch_to_raw', fake_fetch_to_raw)",
            "        if fakeout_copy_image_to_volume:",
            "            self.stubs.Set(self.volume, '_copy_image_to_volume',",
            "                           fake_copy_image_to_volume)",
            "",
            "        image_id = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        volume_id = self._create_volume(status='creating')['id']",
            "        # creating volume testdata",
            "        try:",
            "            self.volume.create_volume(self.context,",
            "                                      volume_id,",
            "                                      image_id=image_id)",
            "        finally:",
            "            # cleanup",
            "            os.unlink(dst_path)",
            "            volume = db.volume_get(self.context, volume_id)",
            "            return volume",
            "",
            "    def test_create_volume_from_image_status_available(self):",
            "        \"\"\"Verify that before copying image to volume, it is in available",
            "        state.",
            "        \"\"\"",
            "        volume = self._create_volume_from_image()",
            "        self.assertEqual(volume['status'], 'available')",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_volume_from_image_exception(self):",
            "        \"\"\"Verify that create volume from image, the volume status is",
            "        'downloading'.",
            "        \"\"\"",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', lambda x: dst_path)",
            "",
            "        image_id = 'aaaaaaaa-0000-0000-0000-000000000000'",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'creating',",
            "                          'host': 'dummy'})",
            "",
            "        self.assertRaises(exception.ImageNotFound,",
            "                          self.volume.create_volume,",
            "                          self.context,",
            "                          volume_id, None, None, None,",
            "                          None,",
            "                          image_id)",
            "        volume = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(volume['status'], \"error\")",
            "        # cleanup",
            "        db.volume_destroy(self.context, volume_id)",
            "        os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_status_available(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': '70a599e0-31e7-49b7-b260-868f441e862b',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'uploading',",
            "                          'instance_uuid': None,",
            "                          'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.volume.copy_volume_to_image(self.context,",
            "                                             volume_id,",
            "                                             image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'available')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_status_use(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': 'a440c04b-79fa-479c-bed1-0b816eaec379',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(",
            "            self.context,",
            "            {'id': volume_id,",
            "             'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "             'display_description': 'Test Desc',",
            "             'size': 20,",
            "             'status': 'uploading',",
            "             'instance_uuid': 'b21f957d-a72f-4b93-b5a5-45b1161abb02',",
            "             'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.volume.copy_volume_to_image(self.context,",
            "                                             volume_id,",
            "                                             image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'in-use')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_exception(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': 'aaaaaaaa-0000-0000-0000-000000000000',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'in-use',",
            "                          'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.assertRaises(exception.ImageNotFound,",
            "                              self.volume.copy_volume_to_image,",
            "                              self.context,",
            "                              volume_id,",
            "                              image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'available')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_create_volume_from_exact_sized_image(self):",
            "        \"\"\"Verify that an image which is exactly the same size as the",
            "        volume, will work correctly.",
            "        \"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare'}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        try:",
            "            volume_id = None",
            "            volume_api = cinder.volume.api.API(",
            "                image_service=_FakeImageService())",
            "            volume = volume_api.create(self.context, 2, 'name', 'description',",
            "                                       image_id=1)",
            "            volume_id = volume['id']",
            "            self.assertEqual(volume['status'], 'creating')",
            "",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "",
            "    def test_create_volume_from_oversized_image(self):",
            "        \"\"\"Verify that an image which is too big will fail correctly.\"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024 + 1,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare'}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        volume_api = cinder.volume.api.API(image_service=_FakeImageService())",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context, 2,",
            "                          'name', 'description', image_id=1)",
            "",
            "    def test_create_volume_with_mindisk_error(self):",
            "        \"\"\"Verify volumes smaller than image minDisk will cause an error.\"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare',",
            "                        'min_disk': 5}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        volume_api = cinder.volume.api.API(image_service=_FakeImageService())",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context, 2,",
            "                          'name', 'description', image_id=1)",
            "",
            "    def _do_test_create_volume_with_size(self, size):",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        volume = volume_api.create(self.context,",
            "                                   size,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['size'], int(size))",
            "",
            "    def test_create_volume_int_size(self):",
            "        \"\"\"Test volume creation with int size.\"\"\"",
            "        self._do_test_create_volume_with_size(2)",
            "",
            "    def test_create_volume_string_size(self):",
            "        \"\"\"Test volume creation with string size.\"\"\"",
            "        self._do_test_create_volume_with_size('2')",
            "",
            "    def test_create_volume_with_bad_size(self):",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          '2Gb',",
            "                          'name',",
            "                          'description')",
            "",
            "    def test_begin_roll_detaching_volume(self):",
            "        \"\"\"Test begin_detaching and roll_detaching functions.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_api = cinder.volume.api.API()",
            "        volume_api.begin_detaching(self.context, volume)",
            "        volume = db.volume_get(self.context, volume['id'])",
            "        self.assertEqual(volume['status'], \"detaching\")",
            "        volume_api.roll_detaching(self.context, volume)",
            "        volume = db.volume_get(self.context, volume['id'])",
            "        self.assertEqual(volume['status'], \"in-use\")",
            "",
            "    def test_volume_api_update(self):",
            "        # create a raw vol",
            "        volume = self._create_volume()",
            "        # use volume.api to update name",
            "        volume_api = cinder.volume.api.API()",
            "        update_dict = {'display_name': 'test update name'}",
            "        volume_api.update(self.context, volume, update_dict)",
            "        # read changes from db",
            "        vol = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(vol['display_name'], 'test update name')",
            "",
            "    def test_volume_api_update_snapshot(self):",
            "        # create raw snapshot",
            "        volume = self._create_volume()",
            "        snapshot = self._create_snapshot(volume['id'])",
            "        self.assertEquals(snapshot['display_name'], None)",
            "        # use volume.api to update name",
            "        volume_api = cinder.volume.api.API()",
            "        update_dict = {'display_name': 'test update name'}",
            "        volume_api.update_snapshot(self.context, snapshot, update_dict)",
            "        # read changes from db",
            "        snap = db.snapshot_get(context.get_admin_context(), snapshot['id'])",
            "        self.assertEquals(snap['display_name'], 'test update name')",
            "",
            "    def test_volume_get_active_by_window(self):",
            "        # Find all all volumes valid within a timeframe window.",
            "        try:  # Not in window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 1,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 2, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted in window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 2,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted after window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 3,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        # In - created in window",
            "        db.volume_create(",
            "            self.context,",
            "            {",
            "                'id': 4,",
            "                'host': 'devstack',",
            "                'created_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        # Not of window.",
            "        db.volume_create(",
            "            self.context,",
            "            {",
            "                'id': 5,",
            "                'host': 'devstack',",
            "                'created_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        volumes = db.volume_get_active_by_window(",
            "            self.context,",
            "            datetime.datetime(1, 3, 1, 1, 1, 1),",
            "            datetime.datetime(1, 4, 1, 1, 1, 1))",
            "        self.assertEqual(len(volumes), 3)",
            "        self.assertEqual(volumes[0].id, u'2')",
            "        self.assertEqual(volumes[1].id, u'3')",
            "        self.assertEqual(volumes[2].id, u'4')",
            "",
            "    def test_snapshot_get_active_by_window(self):",
            "        # Find all all snapshots valid within a timeframe window.",
            "        vol = db.volume_create(self.context, {'id': 1})",
            "",
            "        try:  # Not in window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 1,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 2, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted in window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 2,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted after window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 3,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        # In - created in window",
            "        db.snapshot_create(",
            "            self.context,",
            "            {",
            "                'id': 4,",
            "                'host': 'devstack',",
            "                'volume_id': 1,",
            "                'created_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        # Not of window.",
            "        db.snapshot_create(",
            "            self.context,",
            "            {",
            "                'id': 5,",
            "                'host': 'devstack',",
            "                'volume_id': 1,",
            "                'created_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        snapshots = db.snapshot_get_active_by_window(",
            "            self.context,",
            "            datetime.datetime(1, 3, 1, 1, 1, 1),",
            "            datetime.datetime(1, 4, 1, 1, 1, 1))",
            "        self.assertEqual(len(snapshots), 3)",
            "        self.assertEqual(snapshots[0].id, u'2')",
            "        self.assertEqual(snapshots[1].id, u'3')",
            "        self.assertEqual(snapshots[2].id, u'4')",
            "",
            "    def test_extend_volume(self):",
            "        \"\"\"Test volume can be extended.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume(2)",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'available'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # Extend fails when new_size < orig_size",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.extend,",
            "                          self.context,",
            "                          volume,",
            "                          1)",
            "",
            "        # Extend fails when new_size == orig_size",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.extend,",
            "                          self.context,",
            "                          volume,",
            "                          2)",
            "",
            "        # works when new_size > orig_size",
            "        volume_api.extend(self.context, volume, 3)",
            "",
            "        volume = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(volume['size'], 3)",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_volume_from_unelevated_context(self):",
            "        \"\"\"Test context does't change after volume creation failure.\"\"\"",
            "        def fake_create_volume(context, volume_ref, snapshot_ref,",
            "                               sourcevol_ref, image_service, image_id,",
            "                               image_location):",
            "            raise exception.CinderException('fake exception')",
            "",
            "        def fake_reschedule_or_error(context, volume_id, exc_info,",
            "                                     snapshot_id, image_id, request_spec,",
            "                                     filter_properties):",
            "            self.assertFalse(context.is_admin)",
            "            self.assertFalse('admin' in context.roles)",
            "            #compare context passed in with the context we saved",
            "            self.assertDictMatch(self.saved_ctxt.__dict__,",
            "                                 context.__dict__)",
            "",
            "        #create context for testing",
            "        ctxt = self.context.deepcopy()",
            "        if 'admin' in ctxt.roles:",
            "            ctxt.roles.remove('admin')",
            "            ctxt.is_admin = False",
            "        #create one copy of context for future comparison",
            "        self.saved_ctxt = ctxt.deepcopy()",
            "",
            "        self.stubs.Set(self.volume, '_reschedule_or_error',",
            "                       fake_reschedule_or_error)",
            "        self.stubs.Set(self.volume, '_create_volume',",
            "                       fake_create_volume)",
            "",
            "        volume_src = self._create_volume()",
            "        self.assertRaises(exception.CinderException,",
            "                          self.volume.create_volume, ctxt, volume_src['id'])",
            "",
            "    def test_create_volume_from_sourcevol(self):",
            "        \"\"\"Test volume can be created from a source volume.\"\"\"",
            "        def fake_create_cloned_volume(volume, src_vref):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_create_cloned_volume)",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(source_volid=volume_src['id'])",
            "        self.volume.create_volume(self.context, volume_dst['id'],",
            "                                  source_volid=volume_src['id'])",
            "        self.assertEqual('available',",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).status)",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_create_volume_from_sourcevol_with_glance_metadata(self):",
            "        \"\"\"Test glance metadata can be correctly copied to new volume.\"\"\"",
            "        def fake_create_cloned_volume(volume, src_vref):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_create_cloned_volume)",
            "        volume_src = self._create_volume_from_image()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(source_volid=volume_src['id'])",
            "        self.volume.create_volume(self.context, volume_dst['id'],",
            "                                  source_volid=volume_src['id'])",
            "        self.assertEqual('available',",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).status)",
            "        src_glancemeta = db.volume_get(context.get_admin_context(),",
            "                                       volume_src['id']).volume_glance_metadata",
            "        dst_glancemeta = db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).volume_glance_metadata",
            "        for meta_src in src_glancemeta:",
            "            for meta_dst in dst_glancemeta:",
            "                if meta_dst.key == meta_src.key:",
            "                    self.assertEquals(meta_dst.value, meta_src.value)",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "",
            "    def test_create_volume_from_sourcevol_failed_clone(self):",
            "        \"\"\"Test src vol status will be restore by error handling code.\"\"\"",
            "        def fake_error_create_cloned_volume(volume, src_vref):",
            "            db.volume_update(self.context, src_vref['id'], {'status': 'error'})",
            "            raise exception.CinderException('fake exception')",
            "",
            "        def fake_reschedule_or_error(context, volume_id, exc_info,",
            "                                     snapshot_id, image_id, request_spec,",
            "                                     filter_properties):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume, '_reschedule_or_error',",
            "                       fake_reschedule_or_error)",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_error_create_cloned_volume)",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(0, source_volid=volume_src['id'])",
            "        self.assertRaises(exception.CinderException,",
            "                          self.volume.create_volume,",
            "                          self.context,",
            "                          volume_dst['id'], None, None, None, None, None,",
            "                          volume_src['id'])",
            "        self.assertEqual(volume_src['status'], 'creating')",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_list_availability_zones_enabled_service(self):",
            "        services = [",
            "            {'availability_zone': 'ping', 'disabled': 0},",
            "            {'availability_zone': 'ping', 'disabled': 1},",
            "            {'availability_zone': 'pong', 'disabled': 0},",
            "            {'availability_zone': 'pung', 'disabled': 1},",
            "        ]",
            "",
            "        def stub_service_get_all_by_topic(*args, **kwargs):",
            "            return services",
            "",
            "        self.stubs.Set(db, 'service_get_all_by_topic',",
            "                       stub_service_get_all_by_topic)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        azs = volume_api.list_availability_zones()",
            "",
            "        expected = (",
            "            {'name': 'pung', 'available': False},",
            "            {'name': 'pong', 'available': True},",
            "            {'name': 'ping', 'available': True},",
            "        )",
            "",
            "        self.assertEqual(expected, azs)",
            "",
            "",
            "class DriverTestCase(test.TestCase):",
            "    \"\"\"Base Test class for Drivers.\"\"\"",
            "    driver_name = \"cinder.volume.driver.FakeBaseDriver\"",
            "",
            "    def setUp(self):",
            "        super(DriverTestCase, self).setUp()",
            "        vol_tmpdir = tempfile.mkdtemp()",
            "        self.flags(volume_driver=self.driver_name,",
            "                   volumes_dir=vol_tmpdir)",
            "        self.volume = importutils.import_object(CONF.volume_manager)",
            "        self.context = context.get_admin_context()",
            "        self.output = \"\"",
            "        self.stubs.Set(iscsi.TgtAdm, '_get_target', self.fake_get_target)",
            "",
            "        def _fake_execute(_command, *_args, **_kwargs):",
            "            \"\"\"Fake _execute.\"\"\"",
            "            return self.output, None",
            "        self.volume.driver.set_execute(_fake_execute)",
            "",
            "    def tearDown(self):",
            "        try:",
            "            shutil.rmtree(CONF.volumes_dir)",
            "        except OSError:",
            "            pass",
            "        super(DriverTestCase, self).tearDown()",
            "",
            "    def fake_get_target(obj, iqn):",
            "        return 1",
            "",
            "    def _attach_volume(self):",
            "        \"\"\"Attach volumes to an instance.\"\"\"",
            "        return []",
            "",
            "    def _detach_volume(self, volume_id_list):",
            "        \"\"\"Detach volumes from an instance.\"\"\"",
            "        for volume_id in volume_id_list:",
            "            db.volume_detached(self.context, volume_id)",
            "            self.volume.delete_volume(self.context, volume_id)",
            "",
            "",
            "class VolumeDriverTestCase(DriverTestCase):",
            "    \"\"\"Test case for VolumeDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMVolumeDriver\"",
            "",
            "    def test_delete_busy_volume(self):",
            "        \"\"\"Test deleting a busy volume.\"\"\"",
            "        self.stubs.Set(self.volume.driver, '_volume_not_present',",
            "                       lambda x: False)",
            "        self.stubs.Set(self.volume.driver, '_delete_volume',",
            "                       lambda x, y: False)",
            "        # Want DriverTestCase._fake_execute to return 'o' so that",
            "        # volume.driver.delete_volume() raises the VolumeIsBusy exception.",
            "        self.output = 'o'",
            "        self.assertRaises(exception.VolumeIsBusy,",
            "                          self.volume.driver.delete_volume,",
            "                          {'name': 'test1', 'size': 1024})",
            "        # when DriverTestCase._fake_execute returns something other than",
            "        # 'o' volume.driver.delete_volume() does not raise an exception.",
            "        self.output = 'x'",
            "        self.volume.driver.delete_volume({'name': 'test1', 'size': 1024})",
            "",
            "",
            "class LVMVolumeDriverTestCase(DriverTestCase):",
            "    \"\"\"Test case for VolumeDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMVolumeDriver\"",
            "",
            "    def test_convert_blocksize_option(self):",
            "        # Test invalid volume_dd_blocksize",
            "        configuration = conf.Configuration(fake_opt, 'fake_group')",
            "        lvm_driver = lvm.LVMVolumeDriver(configuration=configuration)",
            "",
            "        # Test valid volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('10M', 1)",
            "        self.assertEquals(bs, '10M')",
            "        self.assertEquals(count, 103)",
            "",
            "        bs, count = lvm_driver._calculate_count('1xBBB', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test volume_dd_blocksize with fraction",
            "        bs, count = lvm_driver._calculate_count('1.3M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test zero-size volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('0M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test negative volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('-1M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test non-digital volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('ABM', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "",
            "class ISCSITestCase(DriverTestCase):",
            "    \"\"\"Test Case for ISCSIDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMISCSIDriver\"",
            "",
            "    def _attach_volume(self):",
            "        \"\"\"Attach volumes to an instance.\"\"\"",
            "        volume_id_list = []",
            "        for index in xrange(3):",
            "            vol = {}",
            "            vol['size'] = 0",
            "            vol_ref = db.volume_create(self.context, vol)",
            "            self.volume.create_volume(self.context, vol_ref['id'])",
            "            vol_ref = db.volume_get(self.context, vol_ref['id'])",
            "",
            "            # each volume has a different mountpoint",
            "            mountpoint = \"/dev/sd\" + chr((ord('b') + index))",
            "            instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "            db.volume_attached(self.context, vol_ref['id'], instance_uuid,",
            "                               mountpoint)",
            "            volume_id_list.append(vol_ref['id'])",
            "",
            "        return volume_id_list",
            "",
            "    def test_do_iscsi_discovery(self):",
            "        configuration = mox.MockObject(conf.Configuration)",
            "        configuration.iscsi_ip_address = '0.0.0.0'",
            "        configuration.append_config_values(mox.IgnoreArg())",
            "",
            "        iscsi_driver = driver.ISCSIDriver(configuration=configuration)",
            "        iscsi_driver._execute = lambda *a, **kw: \\",
            "            (\"%s dummy\" % CONF.iscsi_ip_address, '')",
            "        volume = {\"name\": \"dummy\",",
            "                  \"host\": \"0.0.0.0\"}",
            "        iscsi_driver._do_iscsi_discovery(volume)",
            "",
            "    def test_get_iscsi_properties(self):",
            "        volume = {\"provider_location\": '',",
            "                  \"id\": \"0\",",
            "                  \"provider_auth\": \"a b c\"}",
            "        iscsi_driver = driver.ISCSIDriver()",
            "        iscsi_driver._do_iscsi_discovery = lambda v: \"0.0.0.0:0000,0 iqn:iqn 0\"",
            "        result = iscsi_driver._get_iscsi_properties(volume)",
            "        self.assertEquals(result[\"target_portal\"], \"0.0.0.0:0000\")",
            "        self.assertEquals(result[\"target_iqn\"], \"iqn:iqn\")",
            "        self.assertEquals(result[\"target_lun\"], 0)",
            "",
            "    def test_get_volume_stats(self):",
            "        def _emulate_vgs_execute(_command, *_args, **_kwargs):",
            "            out = \"  test1-volumes  5,52  0,52\"",
            "            out += \" test2-volumes  5.52  0.52\"",
            "            return out, None",
            "",
            "        self.volume.driver.set_execute(_emulate_vgs_execute)",
            "",
            "        self.volume.driver._update_volume_status()",
            "",
            "        stats = self.volume.driver._stats",
            "",
            "        self.assertEquals(stats['total_capacity_gb'], float('5.52'))",
            "        self.assertEquals(stats['free_capacity_gb'], float('0.52'))",
            "",
            "    def test_validate_connector(self):",
            "        iscsi_driver = driver.ISCSIDriver()",
            "        # Validate a valid connector",
            "        connector = {'ip': '10.0.0.2',",
            "                     'host': 'fakehost',",
            "                     'initiator': 'iqn.2012-07.org.fake:01'}",
            "        iscsi_driver.validate_connector(connector)",
            "",
            "        # Validate a connector without the initiator",
            "        connector = {'ip': '10.0.0.2', 'host': 'fakehost'}",
            "        self.assertRaises(exception.VolumeBackendAPIException,",
            "                          iscsi_driver.validate_connector, connector)",
            "",
            "",
            "class FibreChannelTestCase(DriverTestCase):",
            "    \"\"\"Test Case for FibreChannelDriver\"\"\"",
            "    driver_name = \"cinder.volume.driver.FibreChannelDriver\"",
            "",
            "    def test_initialize_connection(self):",
            "        self.driver = driver.FibreChannelDriver()",
            "        self.driver.do_setup(None)",
            "        self.assertRaises(NotImplementedError,",
            "                          self.driver.initialize_connection, {}, {})",
            "",
            "",
            "class VolumePolicyTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(VolumePolicyTestCase, self).setUp()",
            "",
            "        cinder.policy.reset()",
            "        cinder.policy.init()",
            "",
            "        self.context = context.get_admin_context()",
            "",
            "    def tearDown(self):",
            "        super(VolumePolicyTestCase, self).tearDown()",
            "        cinder.policy.reset()",
            "",
            "    def _set_rules(self, rules):",
            "        cinder.common.policy.set_brain(cinder.common.policy.Brain(rules))",
            "",
            "    def test_check_policy(self):",
            "        self.mox.StubOutWithMock(cinder.policy, 'enforce')",
            "        target = {",
            "            'project_id': self.context.project_id,",
            "            'user_id': self.context.user_id,",
            "        }",
            "        cinder.policy.enforce(self.context, 'volume:attach', target)",
            "        self.mox.ReplayAll()",
            "        cinder.volume.api.check_policy(self.context, 'attach')",
            "",
            "    def test_check_policy_with_target(self):",
            "        self.mox.StubOutWithMock(cinder.policy, 'enforce')",
            "        target = {",
            "            'project_id': self.context.project_id,",
            "            'user_id': self.context.user_id,",
            "            'id': 2,",
            "        }",
            "        cinder.policy.enforce(self.context, 'volume:attach', target)",
            "        self.mox.ReplayAll()",
            "        cinder.volume.api.check_policy(self.context, 'attach', {'id': 2})"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Tests for Volume Code.",
            "",
            "\"\"\"",
            "",
            "import datetime",
            "import os",
            "import re",
            "import shutil",
            "import tempfile",
            "",
            "import mox",
            "from oslo.config import cfg",
            "",
            "from cinder.brick.iscsi import iscsi",
            "from cinder import context",
            "from cinder import db",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import importutils",
            "from cinder.openstack.common.notifier import api as notifier_api",
            "from cinder.openstack.common.notifier import test_notifier",
            "from cinder.openstack.common import rpc",
            "import cinder.policy",
            "from cinder import quota",
            "from cinder import test",
            "from cinder.tests import conf_fixture",
            "from cinder.tests.image import fake as fake_image",
            "from cinder.volume import configuration as conf",
            "from cinder.volume import driver",
            "from cinder.volume.drivers import lvm",
            "",
            "",
            "QUOTAS = quota.QUOTAS",
            "",
            "CONF = cfg.CONF",
            "",
            "fake_opt = [",
            "    cfg.StrOpt('fake_opt', default='fake', help='fake opts')",
            "]",
            "",
            "",
            "class VolumeTestCase(test.TestCase):",
            "    \"\"\"Test Case for volumes.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VolumeTestCase, self).setUp()",
            "        vol_tmpdir = tempfile.mkdtemp()",
            "        self.flags(connection_type='fake',",
            "                   volumes_dir=vol_tmpdir,",
            "                   notification_driver=[test_notifier.__name__])",
            "        self.volume = importutils.import_object(CONF.volume_manager)",
            "        self.context = context.get_admin_context()",
            "        self.stubs.Set(iscsi.TgtAdm, '_get_target', self.fake_get_target)",
            "        fake_image.stub_out_image_service(self.stubs)",
            "        test_notifier.NOTIFICATIONS = []",
            "",
            "    def tearDown(self):",
            "        try:",
            "            shutil.rmtree(CONF.volumes_dir)",
            "        except OSError:",
            "            pass",
            "        notifier_api._reset_drivers()",
            "        super(VolumeTestCase, self).tearDown()",
            "",
            "    def fake_get_target(obj, iqn):",
            "        return 1",
            "",
            "    @staticmethod",
            "    def _create_volume(size=0, snapshot_id=None, image_id=None,",
            "                       source_volid=None, metadata=None, status=\"creating\"):",
            "        \"\"\"Create a volume object.\"\"\"",
            "        vol = {}",
            "        vol['size'] = size",
            "        vol['snapshot_id'] = snapshot_id",
            "        vol['image_id'] = image_id",
            "        vol['source_volid'] = source_volid",
            "        vol['user_id'] = 'fake'",
            "        vol['project_id'] = 'fake'",
            "        vol['availability_zone'] = CONF.storage_availability_zone",
            "        vol['status'] = status",
            "        vol['attach_status'] = \"detached\"",
            "        vol['host'] = CONF.host",
            "        if metadata is not None:",
            "            vol['metadata'] = metadata",
            "        return db.volume_create(context.get_admin_context(), vol)",
            "",
            "    def test_init_host_clears_downloads(self):",
            "        \"\"\"Test that init_host will unwedge a volume stuck in downloading.\"\"\"",
            "        volume = self._create_volume(status='downloading')",
            "        volume_id = volume['id']",
            "        self.volume.init_host()",
            "        volume = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEquals(volume['status'], \"error\")",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_create_delete_volume(self):",
            "        \"\"\"Test volume can be created and deleted.\"\"\"",
            "        # Need to stub out reserve, commit, and rollback",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 0)",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 2)",
            "        msg = test_notifier.NOTIFICATIONS[0]",
            "        self.assertEqual(msg['event_type'], 'volume.create.start')",
            "        expected = {",
            "            'status': 'creating',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': '',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[1]",
            "        self.assertEqual(msg['event_type'], 'volume.create.end')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': '',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        self.assertEqual(volume_id, db.volume_get(context.get_admin_context(),",
            "                         volume_id).id)",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        vol = db.volume_get(context.get_admin_context(read_deleted='yes'),",
            "                            volume_id)",
            "        self.assertEquals(vol['status'], 'deleted')",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 4)",
            "        msg = test_notifier.NOTIFICATIONS[2]",
            "        self.assertEqual(msg['event_type'], 'volume.delete.start')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': 'DONTCARE',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[3]",
            "        self.assertEqual(msg['event_type'], 'volume.delete.end')",
            "        expected = {",
            "            'status': 'available',",
            "            'display_name': None,",
            "            'availability_zone': 'nova',",
            "            'tenant_id': 'fake',",
            "            'created_at': 'DONTCARE',",
            "            'volume_id': volume_id,",
            "            'volume_type': None,",
            "            'snapshot_id': None,",
            "            'user_id': 'fake',",
            "            'launched_at': 'DONTCARE',",
            "            'size': 0,",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        self.assertRaises(exception.NotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_create_delete_volume_with_metadata(self):",
            "        \"\"\"Test volume can be created with metadata and deleted.\"\"\"",
            "        test_meta = {'fake_key': 'fake_value'}",
            "        volume = self._create_volume(0, None, metadata=test_meta)",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        result_meta = {",
            "            volume.volume_metadata[0].key: volume.volume_metadata[0].value}",
            "        self.assertEqual(result_meta, test_meta)",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.NotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_create_volume_with_invalid_metadata(self):",
            "        \"\"\"Test volume create with too much metadata fails.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        test_meta = {'fake_key': 'fake_value' * 256}",
            "        self.assertRaises(exception.InvalidVolumeMetadataSize,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          1,",
            "                          'name',",
            "                          'description',",
            "                          None,",
            "                          None,",
            "                          None,",
            "                          test_meta)",
            "",
            "    def test_create_volume_with_volume_type(self):",
            "        \"\"\"Test volume creation with default volume type.\"\"\"",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # Create volume with default volume type while default",
            "        # volume type doesn't exist, volume_type_id should be NULL",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['volume_type_id'], None)",
            "",
            "        # Create default volume type",
            "        vol_type = conf_fixture.def_vol_type",
            "        db.volume_type_create(context.get_admin_context(),",
            "                              dict(name=vol_type, extra_specs={}))",
            "",
            "        db_vol_type = db.volume_type_get_by_name(context.get_admin_context(),",
            "                                                 vol_type)",
            "",
            "        # Create volume with default volume type",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['volume_type_id'], db_vol_type.get('id'))",
            "",
            "        # Create volume with specific volume type",
            "        vol_type = 'test'",
            "        db.volume_type_create(context.get_admin_context(),",
            "                              dict(name=vol_type, extra_specs={}))",
            "        db_vol_type = db.volume_type_get_by_name(context.get_admin_context(),",
            "                                                 vol_type)",
            "",
            "        volume = volume_api.create(self.context,",
            "                                   1,",
            "                                   'name',",
            "                                   'description',",
            "                                   volume_type=db_vol_type)",
            "        self.assertEquals(volume['volume_type_id'], db_vol_type.get('id'))",
            "",
            "    def test_delete_busy_volume(self):",
            "        \"\"\"Test volume survives deletion if driver reports it as busy.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "",
            "        self.mox.StubOutWithMock(self.volume.driver, 'delete_volume')",
            "        self.volume.driver.delete_volume(",
            "            mox.IgnoreArg()).AndRaise(exception.VolumeIsBusy(",
            "                                      volume_name='fake'))",
            "        self.mox.ReplayAll()",
            "        res = self.volume.delete_volume(self.context, volume_id)",
            "        self.assertEqual(True, res)",
            "        volume_ref = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(volume_id, volume_ref.id)",
            "        self.assertEqual(\"available\", volume_ref.status)",
            "",
            "        self.mox.UnsetStubs()",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_create_volume_from_snapshot(self):",
            "        \"\"\"Test volume can be created from a snapshot.\"\"\"",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        snapshot_id = self._create_snapshot(volume_src['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume_src['id'],",
            "                                    snapshot_id)",
            "        volume_dst = self._create_volume(0, snapshot_id)",
            "        self.volume.create_volume(self.context, volume_dst['id'], snapshot_id)",
            "        self.assertEqual(volume_dst['id'],",
            "                         db.volume_get(",
            "                             context.get_admin_context(),",
            "                             volume_dst['id']).id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).snapshot_id)",
            "",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_create_volume_from_snapshot_fail_bad_size(self):",
            "        \"\"\"Test volume can't be created from snapshot with bad volume size.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        snapshot = dict(id=1234,",
            "                        status='available',",
            "                        volume_size=10)",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          size=1,",
            "                          name='fake_name',",
            "                          description='fake_desc',",
            "                          snapshot=snapshot)",
            "",
            "    def test_create_volume_with_invalid_exclusive_options(self):",
            "        \"\"\"Test volume create with multiple exclusive options fails.\"\"\"",
            "        volume_api = cinder.volume.api.API()",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          1,",
            "                          'name',",
            "                          'description',",
            "                          snapshot='fake_id',",
            "                          image_id='fake_id',",
            "                          source_volume='fake_id')",
            "",
            "    def test_too_big_volume(self):",
            "        \"\"\"Ensure failure if a too large of a volume is requested.\"\"\"",
            "        # FIXME(vish): validation needs to move into the data layer in",
            "        #              volume_create",
            "        return True",
            "        try:",
            "            volume = self._create_volume(1001)",
            "            self.volume.create_volume(self.context, volume)",
            "            self.fail(\"Should have thrown TypeError\")",
            "        except TypeError:",
            "            pass",
            "",
            "    def test_run_attach_detach_volume(self):",
            "        \"\"\"Make sure volume can be attached and detached from instance.\"\"\"",
            "        mountpoint = \"/dev/sdf\"",
            "        # attach volume to the instance then to detach",
            "        instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.volume.attach_volume(self.context, volume_id, instance_uuid,",
            "                                  None, mountpoint)",
            "        vol = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(vol['status'], \"in-use\")",
            "        self.assertEqual(vol['attach_status'], \"attached\")",
            "        self.assertEqual(vol['mountpoint'], mountpoint)",
            "        self.assertEqual(vol['instance_uuid'], instance_uuid)",
            "        self.assertEqual(vol['attached_host'], None)",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          self.volume.delete_volume,",
            "                          self.context,",
            "                          volume_id)",
            "        self.volume.detach_volume(self.context, volume_id)",
            "        vol = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(vol['status'], \"available\")",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.VolumeNotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "        # attach volume to the host then to detach",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        self.volume.attach_volume(self.context, volume_id, None,",
            "                                  'fake_host', mountpoint)",
            "        vol = db.volume_get(context.get_admin_context(), volume_id)",
            "        self.assertEqual(vol['status'], \"in-use\")",
            "        self.assertEqual(vol['attach_status'], \"attached\")",
            "        self.assertEqual(vol['mountpoint'], mountpoint)",
            "        self.assertEqual(vol['instance_uuid'], None)",
            "        # sanitized, conforms to RFC-952 and RFC-1123 specs.",
            "        self.assertEqual(vol['attached_host'], 'fake-host')",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          self.volume.delete_volume,",
            "                          self.context,",
            "                          volume_id)",
            "        self.volume.detach_volume(self.context, volume_id)",
            "        vol = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(vol['status'], \"available\")",
            "",
            "        self.volume.delete_volume(self.context, volume_id)",
            "        self.assertRaises(exception.VolumeNotFound,",
            "                          db.volume_get,",
            "                          self.context,",
            "                          volume_id)",
            "",
            "    def test_concurrent_volumes_get_different_targets(self):",
            "        \"\"\"Ensure multiple concurrent volumes get different targets.\"\"\"",
            "        volume_ids = []",
            "        targets = []",
            "",
            "        def _check(volume_id):",
            "            \"\"\"Make sure targets aren't duplicated.\"\"\"",
            "            volume_ids.append(volume_id)",
            "            admin_context = context.get_admin_context()",
            "            iscsi_target = db.volume_get_iscsi_target_num(admin_context,",
            "                                                          volume_id)",
            "            self.assert_(iscsi_target not in targets)",
            "            targets.append(iscsi_target)",
            "",
            "        total_slots = CONF.iscsi_num_targets",
            "        for _index in xrange(total_slots):",
            "            self._create_volume()",
            "        for volume_id in volume_ids:",
            "            self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def test_multi_node(self):",
            "        # TODO(termie): Figure out how to test with two nodes,",
            "        # each of them having a different FLAG for storage_node",
            "        # This will allow us to test cross-node interactions",
            "        pass",
            "",
            "    @staticmethod",
            "    def _create_snapshot(volume_id, size='0'):",
            "        \"\"\"Create a snapshot object.\"\"\"",
            "        snap = {}",
            "        snap['volume_size'] = size",
            "        snap['user_id'] = 'fake'",
            "        snap['project_id'] = 'fake'",
            "        snap['volume_id'] = volume_id",
            "        snap['status'] = \"creating\"",
            "        return db.snapshot_create(context.get_admin_context(), snap)",
            "",
            "    def test_create_delete_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 0)",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 2)",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.snapshot_get(context.get_admin_context(),",
            "                                         snapshot_id).id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 4)",
            "        msg = test_notifier.NOTIFICATIONS[2]",
            "        self.assertEquals(msg['event_type'], 'snapshot.create.start')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'creating',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[3]",
            "        self.assertEquals(msg['event_type'], 'snapshot.create.end')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'creating',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.assertEquals(len(test_notifier.NOTIFICATIONS), 6)",
            "        msg = test_notifier.NOTIFICATIONS[4]",
            "        self.assertEquals(msg['event_type'], 'snapshot.delete.start')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'available',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "        msg = test_notifier.NOTIFICATIONS[5]",
            "        self.assertEquals(msg['event_type'], 'snapshot.delete.end')",
            "        expected = {",
            "            'created_at': 'DONTCARE',",
            "            'deleted': '',",
            "            'display_name': None,",
            "            'snapshot_id': snapshot_id,",
            "            'status': 'available',",
            "            'tenant_id': 'fake',",
            "            'user_id': 'fake',",
            "            'volume_id': volume['id'],",
            "            'volume_size': 0,",
            "            'availability_zone': 'nova'",
            "        }",
            "        self.assertDictMatch(msg['payload'], expected)",
            "",
            "        snap = db.snapshot_get(context.get_admin_context(read_deleted='yes'),",
            "                               snapshot_id)",
            "        self.assertEquals(snap['status'], 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          db.snapshot_get,",
            "                          self.context,",
            "                          snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_delete_volume_in_use(self):",
            "        \"\"\"Test volume can't be deleted in invalid stats.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'in-use'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # 'in-use' status raises InvalidVolume",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_force_delete_volume(self):",
            "        \"\"\"Test volume can be forced to delete.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'error_deleting'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # 'error_deleting' volumes can't be deleted",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "",
            "        # delete with force",
            "        volume_api.delete(self.context, volume, force=True)",
            "",
            "        # status is deleting",
            "        volume = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(volume['status'], 'deleting')",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_force_delete_attached_volume(self):",
            "        \"\"\"Test volume can't be force delete in attached state\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'in-use'",
            "        volume['attach_status'] = 'attached'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.VolumeAttached,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume,",
            "                          force=True)",
            "",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_cant_delete_volume_with_snapshots(self):",
            "        \"\"\"Test volume can't be deleted with dependent snapshots.\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        self.assertEqual(snapshot_id,",
            "                         db.snapshot_get(context.get_admin_context(),",
            "                                         snapshot_id).id)",
            "",
            "        volume['status'] = 'available'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.delete,",
            "                          self.context,",
            "                          volume)",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_can_delete_errored_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        snapshot_id = self._create_snapshot(volume['id'])['id']",
            "        self.volume.create_snapshot(self.context, volume['id'], snapshot_id)",
            "        snapshot = db.snapshot_get(context.get_admin_context(),",
            "                                   snapshot_id)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        snapshot['status'] = 'badstatus'",
            "        self.assertRaises(exception.InvalidSnapshot,",
            "                          volume_api.delete_snapshot,",
            "                          self.context,",
            "                          snapshot)",
            "",
            "        snapshot['status'] = 'error'",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_snapshot_force(self):",
            "        \"\"\"Test snapshot in use can be created forcibly.\"\"\"",
            "",
            "        def fake_cast(ctxt, topic, msg):",
            "            pass",
            "        self.stubs.Set(rpc, 'cast', fake_cast)",
            "        instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "        # create volume and attach to the instance",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        db.volume_attached(self.context, volume['id'], instance_uuid,",
            "                           None, '/dev/sda1')",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        volume = volume_api.get(self.context, volume['id'])",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.create_snapshot,",
            "                          self.context, volume,",
            "                          'fake_name', 'fake_description')",
            "        snapshot_ref = volume_api.create_snapshot_force(self.context,",
            "                                                        volume,",
            "                                                        'fake_name',",
            "                                                        'fake_description')",
            "        db.snapshot_destroy(self.context, snapshot_ref['id'])",
            "        db.volume_destroy(self.context, volume['id'])",
            "",
            "        # create volume and attach to the host",
            "        volume = self._create_volume()",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        db.volume_attached(self.context, volume['id'], None,",
            "                           'fake_host', '/dev/sda1')",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        volume = volume_api.get(self.context, volume['id'])",
            "        self.assertRaises(exception.InvalidVolume,",
            "                          volume_api.create_snapshot,",
            "                          self.context, volume,",
            "                          'fake_name', 'fake_description')",
            "        snapshot_ref = volume_api.create_snapshot_force(self.context,",
            "                                                        volume,",
            "                                                        'fake_name',",
            "                                                        'fake_description')",
            "        db.snapshot_destroy(self.context, snapshot_ref['id'])",
            "        db.volume_destroy(self.context, volume['id'])",
            "",
            "    def test_delete_busy_snapshot(self):",
            "        \"\"\"Test snapshot can be created and deleted.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_id = volume['id']",
            "        self.volume.create_volume(self.context, volume_id)",
            "        snapshot_id = self._create_snapshot(volume_id)['id']",
            "        self.volume.create_snapshot(self.context, volume_id, snapshot_id)",
            "",
            "        self.mox.StubOutWithMock(self.volume.driver, 'delete_snapshot')",
            "        self.volume.driver.delete_snapshot(",
            "            mox.IgnoreArg()).AndRaise(",
            "                exception.SnapshotIsBusy(snapshot_name='fake'))",
            "        self.mox.ReplayAll()",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        snapshot_ref = db.snapshot_get(self.context, snapshot_id)",
            "        self.assertEqual(snapshot_id, snapshot_ref.id)",
            "        self.assertEqual(\"available\", snapshot_ref.status)",
            "",
            "        self.mox.UnsetStubs()",
            "        self.volume.delete_snapshot(self.context, snapshot_id)",
            "        self.volume.delete_volume(self.context, volume_id)",
            "",
            "    def _create_volume_from_image(self, fakeout_copy_image_to_volume=False):",
            "        \"\"\"Call copy image to volume, Test the status of volume after calling",
            "        copying image to volume.",
            "        \"\"\"",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        def fake_copy_image_to_volume(context, volume,",
            "                                      image_service, image_id):",
            "            pass",
            "",
            "        def fake_fetch_to_raw(context, image_service, image_id, vol_path):",
            "            pass",
            "",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "        self.stubs.Set(image_utils, 'fetch_to_raw', fake_fetch_to_raw)",
            "        if fakeout_copy_image_to_volume:",
            "            self.stubs.Set(self.volume, '_copy_image_to_volume',",
            "                           fake_copy_image_to_volume)",
            "",
            "        image_id = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        volume_id = self._create_volume(status='creating')['id']",
            "        # creating volume testdata",
            "        try:",
            "            self.volume.create_volume(self.context,",
            "                                      volume_id,",
            "                                      image_id=image_id)",
            "        finally:",
            "            # cleanup",
            "            os.unlink(dst_path)",
            "            volume = db.volume_get(self.context, volume_id)",
            "            return volume",
            "",
            "    def test_create_volume_from_image_status_available(self):",
            "        \"\"\"Verify that before copying image to volume, it is in available",
            "        state.",
            "        \"\"\"",
            "        volume = self._create_volume_from_image()",
            "        self.assertEqual(volume['status'], 'available')",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_volume_from_image_exception(self):",
            "        \"\"\"Verify that create volume from image, the volume status is",
            "        'downloading'.",
            "        \"\"\"",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', lambda x: dst_path)",
            "",
            "        image_id = 'aaaaaaaa-0000-0000-0000-000000000000'",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'creating',",
            "                          'host': 'dummy'})",
            "",
            "        self.assertRaises(exception.ImageNotFound,",
            "                          self.volume.create_volume,",
            "                          self.context,",
            "                          volume_id, None, None, None,",
            "                          None,",
            "                          image_id)",
            "        volume = db.volume_get(self.context, volume_id)",
            "        self.assertEqual(volume['status'], \"error\")",
            "        # cleanup",
            "        db.volume_destroy(self.context, volume_id)",
            "        os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_status_available(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': '70a599e0-31e7-49b7-b260-868f441e862b',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'uploading',",
            "                          'instance_uuid': None,",
            "                          'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.volume.copy_volume_to_image(self.context,",
            "                                             volume_id,",
            "                                             image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'available')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_status_use(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': 'a440c04b-79fa-479c-bed1-0b816eaec379',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(",
            "            self.context,",
            "            {'id': volume_id,",
            "             'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "             'display_description': 'Test Desc',",
            "             'size': 20,",
            "             'status': 'uploading',",
            "             'instance_uuid': 'b21f957d-a72f-4b93-b5a5-45b1161abb02',",
            "             'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.volume.copy_volume_to_image(self.context,",
            "                                             volume_id,",
            "                                             image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'in-use')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_copy_volume_to_image_exception(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        os.close(dst_fd)",
            "",
            "        def fake_local_path(volume):",
            "            return dst_path",
            "",
            "        self.stubs.Set(self.volume.driver, 'local_path', fake_local_path)",
            "",
            "        image_meta = {",
            "            'id': 'aaaaaaaa-0000-0000-0000-000000000000',",
            "            'container_format': 'bare',",
            "            'disk_format': 'raw'}",
            "        # creating volume testdata",
            "        volume_id = 1",
            "        db.volume_create(self.context,",
            "                         {'id': volume_id,",
            "                          'updated_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                          'display_description': 'Test Desc',",
            "                          'size': 20,",
            "                          'status': 'in-use',",
            "                          'host': 'dummy'})",
            "",
            "        try:",
            "            # start test",
            "            self.assertRaises(exception.ImageNotFound,",
            "                              self.volume.copy_volume_to_image,",
            "                              self.context,",
            "                              volume_id,",
            "                              image_meta)",
            "",
            "            volume = db.volume_get(self.context, volume_id)",
            "            self.assertEqual(volume['status'], 'available')",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "            os.unlink(dst_path)",
            "",
            "    def test_create_volume_from_exact_sized_image(self):",
            "        \"\"\"Verify that an image which is exactly the same size as the",
            "        volume, will work correctly.",
            "        \"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare'}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        try:",
            "            volume_id = None",
            "            volume_api = cinder.volume.api.API(",
            "                image_service=_FakeImageService())",
            "            volume = volume_api.create(self.context, 2, 'name', 'description',",
            "                                       image_id=1)",
            "            volume_id = volume['id']",
            "            self.assertEqual(volume['status'], 'creating')",
            "",
            "        finally:",
            "            # cleanup",
            "            db.volume_destroy(self.context, volume_id)",
            "",
            "    def test_create_volume_from_oversized_image(self):",
            "        \"\"\"Verify that an image which is too big will fail correctly.\"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024 + 1,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare'}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        volume_api = cinder.volume.api.API(image_service=_FakeImageService())",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context, 2,",
            "                          'name', 'description', image_id=1)",
            "",
            "    def test_create_volume_with_mindisk_error(self):",
            "        \"\"\"Verify volumes smaller than image minDisk will cause an error.\"\"\"",
            "        class _FakeImageService:",
            "            def __init__(self, db_driver=None, image_service=None):",
            "                pass",
            "",
            "            def show(self, context, image_id):",
            "                return {'size': 2 * 1024 * 1024 * 1024,",
            "                        'disk_format': 'raw',",
            "                        'container_format': 'bare',",
            "                        'min_disk': 5}",
            "",
            "        image_id = '70a599e0-31e7-49b7-b260-868f441e862b'",
            "",
            "        volume_api = cinder.volume.api.API(image_service=_FakeImageService())",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context, 2,",
            "                          'name', 'description', image_id=1)",
            "",
            "    def _do_test_create_volume_with_size(self, size):",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        volume = volume_api.create(self.context,",
            "                                   size,",
            "                                   'name',",
            "                                   'description')",
            "        self.assertEquals(volume['size'], int(size))",
            "",
            "    def test_create_volume_int_size(self):",
            "        \"\"\"Test volume creation with int size.\"\"\"",
            "        self._do_test_create_volume_with_size(2)",
            "",
            "    def test_create_volume_string_size(self):",
            "        \"\"\"Test volume creation with string size.\"\"\"",
            "        self._do_test_create_volume_with_size('2')",
            "",
            "    def test_create_volume_with_bad_size(self):",
            "        def fake_reserve(context, expire=None, project_id=None, **deltas):",
            "            return [\"RESERVATION\"]",
            "",
            "        def fake_commit(context, reservations, project_id=None):",
            "            pass",
            "",
            "        def fake_rollback(context, reservations, project_id=None):",
            "            pass",
            "",
            "        self.stubs.Set(QUOTAS, \"reserve\", fake_reserve)",
            "        self.stubs.Set(QUOTAS, \"commit\", fake_commit)",
            "        self.stubs.Set(QUOTAS, \"rollback\", fake_rollback)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.create,",
            "                          self.context,",
            "                          '2Gb',",
            "                          'name',",
            "                          'description')",
            "",
            "    def test_begin_roll_detaching_volume(self):",
            "        \"\"\"Test begin_detaching and roll_detaching functions.\"\"\"",
            "        volume = self._create_volume()",
            "        volume_api = cinder.volume.api.API()",
            "        volume_api.begin_detaching(self.context, volume)",
            "        volume = db.volume_get(self.context, volume['id'])",
            "        self.assertEqual(volume['status'], \"detaching\")",
            "        volume_api.roll_detaching(self.context, volume)",
            "        volume = db.volume_get(self.context, volume['id'])",
            "        self.assertEqual(volume['status'], \"in-use\")",
            "",
            "    def test_volume_api_update(self):",
            "        # create a raw vol",
            "        volume = self._create_volume()",
            "        # use volume.api to update name",
            "        volume_api = cinder.volume.api.API()",
            "        update_dict = {'display_name': 'test update name'}",
            "        volume_api.update(self.context, volume, update_dict)",
            "        # read changes from db",
            "        vol = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(vol['display_name'], 'test update name')",
            "",
            "    def test_volume_api_update_snapshot(self):",
            "        # create raw snapshot",
            "        volume = self._create_volume()",
            "        snapshot = self._create_snapshot(volume['id'])",
            "        self.assertEquals(snapshot['display_name'], None)",
            "        # use volume.api to update name",
            "        volume_api = cinder.volume.api.API()",
            "        update_dict = {'display_name': 'test update name'}",
            "        volume_api.update_snapshot(self.context, snapshot, update_dict)",
            "        # read changes from db",
            "        snap = db.snapshot_get(context.get_admin_context(), snapshot['id'])",
            "        self.assertEquals(snap['display_name'], 'test update name')",
            "",
            "    def test_volume_get_active_by_window(self):",
            "        # Find all all volumes valid within a timeframe window.",
            "        try:  # Not in window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 1,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 2, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted in window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 2,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted after window",
            "            db.volume_create(",
            "                self.context,",
            "                {",
            "                    'id': 3,",
            "                    'host': 'devstack',",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.VolumeNotFound:",
            "            pass",
            "",
            "        # In - created in window",
            "        db.volume_create(",
            "            self.context,",
            "            {",
            "                'id': 4,",
            "                'host': 'devstack',",
            "                'created_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        # Not of window.",
            "        db.volume_create(",
            "            self.context,",
            "            {",
            "                'id': 5,",
            "                'host': 'devstack',",
            "                'created_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        volumes = db.volume_get_active_by_window(",
            "            self.context,",
            "            datetime.datetime(1, 3, 1, 1, 1, 1),",
            "            datetime.datetime(1, 4, 1, 1, 1, 1))",
            "        self.assertEqual(len(volumes), 3)",
            "        self.assertEqual(volumes[0].id, u'2')",
            "        self.assertEqual(volumes[1].id, u'3')",
            "        self.assertEqual(volumes[2].id, u'4')",
            "",
            "    def test_snapshot_get_active_by_window(self):",
            "        # Find all all snapshots valid within a timeframe window.",
            "        vol = db.volume_create(self.context, {'id': 1})",
            "",
            "        try:  # Not in window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 1,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 2, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted in window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 2,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        try:  # In - deleted after window",
            "            db.snapshot_create(",
            "                self.context,",
            "                {",
            "                    'id': 3,",
            "                    'host': 'devstack',",
            "                    'volume_id': 1,",
            "                    'created_at': datetime.datetime(1, 1, 1, 1, 1, 1),",
            "                    'deleted': True, 'status': 'deleted',",
            "                    'deleted_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "                }",
            "            )",
            "        except exception.SnapshotNotFound:",
            "            pass",
            "",
            "        # In - created in window",
            "        db.snapshot_create(",
            "            self.context,",
            "            {",
            "                'id': 4,",
            "                'host': 'devstack',",
            "                'volume_id': 1,",
            "                'created_at': datetime.datetime(1, 3, 10, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        # Not of window.",
            "        db.snapshot_create(",
            "            self.context,",
            "            {",
            "                'id': 5,",
            "                'host': 'devstack',",
            "                'volume_id': 1,",
            "                'created_at': datetime.datetime(1, 5, 1, 1, 1, 1),",
            "            }",
            "        )",
            "",
            "        snapshots = db.snapshot_get_active_by_window(",
            "            self.context,",
            "            datetime.datetime(1, 3, 1, 1, 1, 1),",
            "            datetime.datetime(1, 4, 1, 1, 1, 1))",
            "        self.assertEqual(len(snapshots), 3)",
            "        self.assertEqual(snapshots[0].id, u'2')",
            "        self.assertEqual(snapshots[1].id, u'3')",
            "        self.assertEqual(snapshots[2].id, u'4')",
            "",
            "    def test_extend_volume(self):",
            "        \"\"\"Test volume can be extended.\"\"\"",
            "        # create a volume and assign to host",
            "        volume = self._create_volume(2)",
            "        self.volume.create_volume(self.context, volume['id'])",
            "        volume['status'] = 'available'",
            "        volume['host'] = 'fakehost'",
            "",
            "        volume_api = cinder.volume.api.API()",
            "",
            "        # Extend fails when new_size < orig_size",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.extend,",
            "                          self.context,",
            "                          volume,",
            "                          1)",
            "",
            "        # Extend fails when new_size == orig_size",
            "        self.assertRaises(exception.InvalidInput,",
            "                          volume_api.extend,",
            "                          self.context,",
            "                          volume,",
            "                          2)",
            "",
            "        # works when new_size > orig_size",
            "        volume_api.extend(self.context, volume, 3)",
            "",
            "        volume = db.volume_get(context.get_admin_context(), volume['id'])",
            "        self.assertEquals(volume['size'], 3)",
            "",
            "        # clean up",
            "        self.volume.delete_volume(self.context, volume['id'])",
            "",
            "    def test_create_volume_from_unelevated_context(self):",
            "        \"\"\"Test context does't change after volume creation failure.\"\"\"",
            "        def fake_create_volume(context, volume_ref, snapshot_ref,",
            "                               sourcevol_ref, image_service, image_id,",
            "                               image_location):",
            "            raise exception.CinderException('fake exception')",
            "",
            "        def fake_reschedule_or_error(context, volume_id, exc_info,",
            "                                     snapshot_id, image_id, request_spec,",
            "                                     filter_properties):",
            "            self.assertFalse(context.is_admin)",
            "            self.assertFalse('admin' in context.roles)",
            "            #compare context passed in with the context we saved",
            "            self.assertDictMatch(self.saved_ctxt.__dict__,",
            "                                 context.__dict__)",
            "",
            "        #create context for testing",
            "        ctxt = self.context.deepcopy()",
            "        if 'admin' in ctxt.roles:",
            "            ctxt.roles.remove('admin')",
            "            ctxt.is_admin = False",
            "        #create one copy of context for future comparison",
            "        self.saved_ctxt = ctxt.deepcopy()",
            "",
            "        self.stubs.Set(self.volume, '_reschedule_or_error',",
            "                       fake_reschedule_or_error)",
            "        self.stubs.Set(self.volume, '_create_volume',",
            "                       fake_create_volume)",
            "",
            "        volume_src = self._create_volume()",
            "        self.assertRaises(exception.CinderException,",
            "                          self.volume.create_volume, ctxt, volume_src['id'])",
            "",
            "    def test_create_volume_from_sourcevol(self):",
            "        \"\"\"Test volume can be created from a source volume.\"\"\"",
            "        def fake_create_cloned_volume(volume, src_vref):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_create_cloned_volume)",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(source_volid=volume_src['id'])",
            "        self.volume.create_volume(self.context, volume_dst['id'],",
            "                                  source_volid=volume_src['id'])",
            "        self.assertEqual('available',",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).status)",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_create_volume_from_sourcevol_with_glance_metadata(self):",
            "        \"\"\"Test glance metadata can be correctly copied to new volume.\"\"\"",
            "        def fake_create_cloned_volume(volume, src_vref):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_create_cloned_volume)",
            "        volume_src = self._create_volume_from_image()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(source_volid=volume_src['id'])",
            "        self.volume.create_volume(self.context, volume_dst['id'],",
            "                                  source_volid=volume_src['id'])",
            "        self.assertEqual('available',",
            "                         db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).status)",
            "        src_glancemeta = db.volume_get(context.get_admin_context(),",
            "                                       volume_src['id']).volume_glance_metadata",
            "        dst_glancemeta = db.volume_get(context.get_admin_context(),",
            "                                       volume_dst['id']).volume_glance_metadata",
            "        for meta_src in src_glancemeta:",
            "            for meta_dst in dst_glancemeta:",
            "                if meta_dst.key == meta_src.key:",
            "                    self.assertEquals(meta_dst.value, meta_src.value)",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "",
            "    def test_create_volume_from_sourcevol_failed_clone(self):",
            "        \"\"\"Test src vol status will be restore by error handling code.\"\"\"",
            "        def fake_error_create_cloned_volume(volume, src_vref):",
            "            db.volume_update(self.context, src_vref['id'], {'status': 'error'})",
            "            raise exception.CinderException('fake exception')",
            "",
            "        def fake_reschedule_or_error(context, volume_id, exc_info,",
            "                                     snapshot_id, image_id, request_spec,",
            "                                     filter_properties):",
            "            pass",
            "",
            "        self.stubs.Set(self.volume, '_reschedule_or_error',",
            "                       fake_reschedule_or_error)",
            "        self.stubs.Set(self.volume.driver, 'create_cloned_volume',",
            "                       fake_error_create_cloned_volume)",
            "        volume_src = self._create_volume()",
            "        self.volume.create_volume(self.context, volume_src['id'])",
            "        volume_dst = self._create_volume(0, source_volid=volume_src['id'])",
            "        self.assertRaises(exception.CinderException,",
            "                          self.volume.create_volume,",
            "                          self.context,",
            "                          volume_dst['id'], None, None, None, None, None,",
            "                          volume_src['id'])",
            "        self.assertEqual(volume_src['status'], 'creating')",
            "        self.volume.delete_volume(self.context, volume_dst['id'])",
            "        self.volume.delete_volume(self.context, volume_src['id'])",
            "",
            "    def test_list_availability_zones_enabled_service(self):",
            "        services = [",
            "            {'availability_zone': 'ping', 'disabled': 0},",
            "            {'availability_zone': 'ping', 'disabled': 1},",
            "            {'availability_zone': 'pong', 'disabled': 0},",
            "            {'availability_zone': 'pung', 'disabled': 1},",
            "        ]",
            "",
            "        def stub_service_get_all_by_topic(*args, **kwargs):",
            "            return services",
            "",
            "        self.stubs.Set(db, 'service_get_all_by_topic',",
            "                       stub_service_get_all_by_topic)",
            "",
            "        volume_api = cinder.volume.api.API()",
            "        azs = volume_api.list_availability_zones()",
            "",
            "        expected = (",
            "            {'name': 'pung', 'available': False},",
            "            {'name': 'pong', 'available': True},",
            "            {'name': 'ping', 'available': True},",
            "        )",
            "",
            "        self.assertEqual(expected, azs)",
            "",
            "",
            "class DriverTestCase(test.TestCase):",
            "    \"\"\"Base Test class for Drivers.\"\"\"",
            "    driver_name = \"cinder.volume.driver.FakeBaseDriver\"",
            "",
            "    def setUp(self):",
            "        super(DriverTestCase, self).setUp()",
            "        vol_tmpdir = tempfile.mkdtemp()",
            "        self.flags(volume_driver=self.driver_name,",
            "                   volumes_dir=vol_tmpdir)",
            "        self.volume = importutils.import_object(CONF.volume_manager)",
            "        self.context = context.get_admin_context()",
            "        self.output = \"\"",
            "        self.stubs.Set(iscsi.TgtAdm, '_get_target', self.fake_get_target)",
            "",
            "        def _fake_execute(_command, *_args, **_kwargs):",
            "            \"\"\"Fake _execute.\"\"\"",
            "            return self.output, None",
            "        self.volume.driver.set_execute(_fake_execute)",
            "",
            "    def tearDown(self):",
            "        try:",
            "            shutil.rmtree(CONF.volumes_dir)",
            "        except OSError:",
            "            pass",
            "        super(DriverTestCase, self).tearDown()",
            "",
            "    def fake_get_target(obj, iqn):",
            "        return 1",
            "",
            "    def _attach_volume(self):",
            "        \"\"\"Attach volumes to an instance.\"\"\"",
            "        return []",
            "",
            "    def _detach_volume(self, volume_id_list):",
            "        \"\"\"Detach volumes from an instance.\"\"\"",
            "        for volume_id in volume_id_list:",
            "            db.volume_detached(self.context, volume_id)",
            "            self.volume.delete_volume(self.context, volume_id)",
            "",
            "",
            "class VolumeDriverTestCase(DriverTestCase):",
            "    \"\"\"Test case for VolumeDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMVolumeDriver\"",
            "",
            "    def test_delete_busy_volume(self):",
            "        \"\"\"Test deleting a busy volume.\"\"\"",
            "        self.stubs.Set(self.volume.driver, '_volume_not_present',",
            "                       lambda x: False)",
            "        self.stubs.Set(self.volume.driver, '_delete_volume',",
            "                       lambda x: False)",
            "        # Want DriverTestCase._fake_execute to return 'o' so that",
            "        # volume.driver.delete_volume() raises the VolumeIsBusy exception.",
            "        self.output = 'o'",
            "        self.assertRaises(exception.VolumeIsBusy,",
            "                          self.volume.driver.delete_volume,",
            "                          {'name': 'test1', 'size': 1024})",
            "        # when DriverTestCase._fake_execute returns something other than",
            "        # 'o' volume.driver.delete_volume() does not raise an exception.",
            "        self.output = 'x'",
            "        self.volume.driver.delete_volume({'name': 'test1', 'size': 1024})",
            "",
            "",
            "class LVMVolumeDriverTestCase(DriverTestCase):",
            "    \"\"\"Test case for VolumeDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMVolumeDriver\"",
            "",
            "    def test_convert_blocksize_option(self):",
            "        # Test invalid volume_dd_blocksize",
            "        configuration = conf.Configuration(fake_opt, 'fake_group')",
            "        lvm_driver = lvm.LVMVolumeDriver(configuration=configuration)",
            "",
            "        # Test valid volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('10M', 1)",
            "        self.assertEquals(bs, '10M')",
            "        self.assertEquals(count, 103)",
            "",
            "        bs, count = lvm_driver._calculate_count('1xBBB', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test volume_dd_blocksize with fraction",
            "        bs, count = lvm_driver._calculate_count('1.3M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test zero-size volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('0M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test negative volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('-1M', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "        # Test non-digital volume_dd_blocksize",
            "        bs, count = lvm_driver._calculate_count('ABM', 1)",
            "        self.assertEquals(bs, '1M')",
            "        self.assertEquals(count, 1024)",
            "",
            "    def test_clear_volume(self):",
            "        configuration = conf.Configuration(fake_opt, 'fake_group')",
            "        configuration.volume_clear = 'zero'",
            "        configuration.volume_clear_size = 0",
            "        lvm_driver = lvm.LVMVolumeDriver(configuration=configuration)",
            "        self.stubs.Set(lvm_driver, '_copy_volume', lambda *a, **kw: True)",
            "",
            "        fake_volume = {'name': 'test1',",
            "                       'volume_name': 'test1',",
            "                       'id': 'test1'}",
            "",
            "        # Test volume has 'size' field",
            "        volume = dict(fake_volume, size='123')",
            "        self.assertEquals(True, lvm_driver.clear_volume(volume))",
            "",
            "        # Test volume has 'volume_size' field",
            "        volume = dict(fake_volume, volume_size='123')",
            "        self.assertEquals(True, lvm_driver.clear_volume(volume))",
            "",
            "        # Test volume without 'size' field and 'volume_size' field",
            "        volume = dict(fake_volume)",
            "        self.assertEquals(None, lvm_driver.clear_volume(volume))",
            "",
            "",
            "class ISCSITestCase(DriverTestCase):",
            "    \"\"\"Test Case for ISCSIDriver\"\"\"",
            "    driver_name = \"cinder.volume.drivers.lvm.LVMISCSIDriver\"",
            "",
            "    def _attach_volume(self):",
            "        \"\"\"Attach volumes to an instance.\"\"\"",
            "        volume_id_list = []",
            "        for index in xrange(3):",
            "            vol = {}",
            "            vol['size'] = 0",
            "            vol_ref = db.volume_create(self.context, vol)",
            "            self.volume.create_volume(self.context, vol_ref['id'])",
            "            vol_ref = db.volume_get(self.context, vol_ref['id'])",
            "",
            "            # each volume has a different mountpoint",
            "            mountpoint = \"/dev/sd\" + chr((ord('b') + index))",
            "            instance_uuid = '12345678-1234-5678-1234-567812345678'",
            "            db.volume_attached(self.context, vol_ref['id'], instance_uuid,",
            "                               mountpoint)",
            "            volume_id_list.append(vol_ref['id'])",
            "",
            "        return volume_id_list",
            "",
            "    def test_do_iscsi_discovery(self):",
            "        configuration = mox.MockObject(conf.Configuration)",
            "        configuration.iscsi_ip_address = '0.0.0.0'",
            "        configuration.append_config_values(mox.IgnoreArg())",
            "",
            "        iscsi_driver = driver.ISCSIDriver(configuration=configuration)",
            "        iscsi_driver._execute = lambda *a, **kw: \\",
            "            (\"%s dummy\" % CONF.iscsi_ip_address, '')",
            "        volume = {\"name\": \"dummy\",",
            "                  \"host\": \"0.0.0.0\"}",
            "        iscsi_driver._do_iscsi_discovery(volume)",
            "",
            "    def test_get_iscsi_properties(self):",
            "        volume = {\"provider_location\": '',",
            "                  \"id\": \"0\",",
            "                  \"provider_auth\": \"a b c\"}",
            "        iscsi_driver = driver.ISCSIDriver()",
            "        iscsi_driver._do_iscsi_discovery = lambda v: \"0.0.0.0:0000,0 iqn:iqn 0\"",
            "        result = iscsi_driver._get_iscsi_properties(volume)",
            "        self.assertEquals(result[\"target_portal\"], \"0.0.0.0:0000\")",
            "        self.assertEquals(result[\"target_iqn\"], \"iqn:iqn\")",
            "        self.assertEquals(result[\"target_lun\"], 0)",
            "",
            "    def test_get_volume_stats(self):",
            "        def _emulate_vgs_execute(_command, *_args, **_kwargs):",
            "            out = \"  test1-volumes  5,52  0,52\"",
            "            out += \" test2-volumes  5.52  0.52\"",
            "            return out, None",
            "",
            "        self.volume.driver.set_execute(_emulate_vgs_execute)",
            "",
            "        self.volume.driver._update_volume_status()",
            "",
            "        stats = self.volume.driver._stats",
            "",
            "        self.assertEquals(stats['total_capacity_gb'], float('5.52'))",
            "        self.assertEquals(stats['free_capacity_gb'], float('0.52'))",
            "",
            "    def test_validate_connector(self):",
            "        iscsi_driver = driver.ISCSIDriver()",
            "        # Validate a valid connector",
            "        connector = {'ip': '10.0.0.2',",
            "                     'host': 'fakehost',",
            "                     'initiator': 'iqn.2012-07.org.fake:01'}",
            "        iscsi_driver.validate_connector(connector)",
            "",
            "        # Validate a connector without the initiator",
            "        connector = {'ip': '10.0.0.2', 'host': 'fakehost'}",
            "        self.assertRaises(exception.VolumeBackendAPIException,",
            "                          iscsi_driver.validate_connector, connector)",
            "",
            "",
            "class FibreChannelTestCase(DriverTestCase):",
            "    \"\"\"Test Case for FibreChannelDriver\"\"\"",
            "    driver_name = \"cinder.volume.driver.FibreChannelDriver\"",
            "",
            "    def test_initialize_connection(self):",
            "        self.driver = driver.FibreChannelDriver()",
            "        self.driver.do_setup(None)",
            "        self.assertRaises(NotImplementedError,",
            "                          self.driver.initialize_connection, {}, {})",
            "",
            "",
            "class VolumePolicyTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(VolumePolicyTestCase, self).setUp()",
            "",
            "        cinder.policy.reset()",
            "        cinder.policy.init()",
            "",
            "        self.context = context.get_admin_context()",
            "",
            "    def tearDown(self):",
            "        super(VolumePolicyTestCase, self).tearDown()",
            "        cinder.policy.reset()",
            "",
            "    def _set_rules(self, rules):",
            "        cinder.common.policy.set_brain(cinder.common.policy.Brain(rules))",
            "",
            "    def test_check_policy(self):",
            "        self.mox.StubOutWithMock(cinder.policy, 'enforce')",
            "        target = {",
            "            'project_id': self.context.project_id,",
            "            'user_id': self.context.user_id,",
            "        }",
            "        cinder.policy.enforce(self.context, 'volume:attach', target)",
            "        self.mox.ReplayAll()",
            "        cinder.volume.api.check_policy(self.context, 'attach')",
            "",
            "    def test_check_policy_with_target(self):",
            "        self.mox.StubOutWithMock(cinder.policy, 'enforce')",
            "        target = {",
            "            'project_id': self.context.project_id,",
            "            'user_id': self.context.user_id,",
            "            'id': 2,",
            "        }",
            "        cinder.policy.enforce(self.context, 'volume:attach', target)",
            "        self.mox.ReplayAll()",
            "        cinder.volume.api.check_policy(self.context, 'attach', {'id': 2})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1442": [
                "VolumeDriverTestCase",
                "test_delete_busy_volume"
            ]
        },
        "addLocation": []
    },
    "cinder/volume/drivers/lvm.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             return True"
            },
            "1": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         return False"
            },
            "2": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _delete_volume(self, volume, size_in_g):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    def _delete_volume(self, volume):"
            },
            "5": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         \"\"\"Deletes a logical volume.\"\"\""
            },
            "6": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         # zero out old volumes to prevent data leaking between users"
            },
            "7": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         # TODO(ja): reclaiming space should be done lazy and low priority"
            },
            "8": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             if (out[0] == 'o') or (out[0] == 'O'):"
            },
            "9": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "                 raise exception.VolumeIsBusy(volume_name=volume['name'])"
            },
            "10": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._delete_volume(volume, volume['size'])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        self._delete_volume(volume)"
            },
            "13": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 222,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     def clear_volume(self, volume):"
            },
            "15": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         \"\"\"unprovision old volumes to prevent data leaking between users.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         vol_path = self.local_path(volume)"
            },
            "18": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        size_in_g = volume.get('size')"
            },
            "19": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        size_in_m = self.configuration.volume_clear_size"
            },
            "20": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "21": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not size_in_g:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        size_in_g = volume.get('size', volume.get('volume_size', None))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        if size_in_g is None:"
            },
            "24": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             LOG.warning(_(\"Size for volume: %s not found, \""
            },
            "25": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          \"skipping secure delete.\") % volume['name'])"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+                          \"skipping secure delete.\") % volume['id'])"
            },
            "27": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "             return"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        size_in_m = self.configuration.volume_clear_size"
            },
            "29": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         if self.configuration.volume_clear == 'none':"
            },
            "31": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             return"
            },
            "32": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 274,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "         # TODO(yamahata): zeroing out the whole snapshot triggers COW."
            },
            "34": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         # it's quite slow."
            },
            "35": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._delete_volume(snapshot, snapshot['volume_size'])"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        self._delete_volume(snapshot)"
            },
            "37": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "     def local_path(self, volume):"
            },
            "39": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         # NOTE(vish): stops deprecation warning"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Driver for Linux servers running LVM.",
            "",
            "\"\"\"",
            "",
            "import math",
            "import os",
            "import re",
            "",
            "from oslo.config import cfg",
            "",
            "from cinder.brick.iscsi import iscsi",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import log as logging",
            "from cinder.openstack.common import strutils",
            "from cinder import units",
            "from cinder import utils",
            "from cinder.volume import driver",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "volume_opts = [",
            "    cfg.StrOpt('volume_group',",
            "               default='cinder-volumes',",
            "               help='Name for the VG that will contain exported volumes'),",
            "    cfg.StrOpt('volume_clear',",
            "               default='zero',",
            "               help='Method used to wipe old volumes (valid options are: '",
            "                    'none, zero, shred)'),",
            "    cfg.IntOpt('volume_clear_size',",
            "               default=0,",
            "               help='Size in MiB to wipe at start of old volumes. 0 => all'),",
            "    cfg.StrOpt('volume_dd_blocksize',",
            "               default='1M',",
            "               help='The default block size used when clearing volumes'),",
            "    cfg.StrOpt('pool_size',",
            "               default=None,",
            "               help='Size of thin provisioning pool '",
            "                    '(None uses entire cinder VG)'),",
            "    cfg.IntOpt('lvm_mirrors',",
            "               default=0,",
            "               help='If set, create lvms with multiple mirrors. Note that '",
            "                    'this requires lvm_mirrors + 2 pvs with available space'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(volume_opts)",
            "",
            "",
            "class LVMVolumeDriver(driver.VolumeDriver):",
            "    \"\"\"Executes commands relating to Volumes.\"\"\"",
            "",
            "    VERSION = '1.0'",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(LVMVolumeDriver, self).__init__(*args, **kwargs)",
            "        self.configuration.append_config_values(volume_opts)",
            "",
            "    def check_for_setup_error(self):",
            "        \"\"\"Returns an error if prerequisites aren't met\"\"\"",
            "        out, err = self._execute('vgs', '--noheadings', '-o', 'name',",
            "                                 run_as_root=True)",
            "        volume_groups = out.split()",
            "        if self.configuration.volume_group not in volume_groups:",
            "            exception_message = (_(\"volume group %s doesn't exist\")",
            "                                 % self.configuration.volume_group)",
            "            raise exception.VolumeBackendAPIException(data=exception_message)",
            "",
            "    def _create_volume(self, volume_name, sizestr):",
            "",
            "        no_retry_list = ['Insufficient free extents',",
            "                         'One or more specified logical volume(s) not found']",
            "",
            "        cmd = ['lvcreate', '-L', sizestr, '-n', volume_name,",
            "               self.configuration.volume_group]",
            "        if self.configuration.lvm_mirrors:",
            "            cmd += ['-m', self.configuration.lvm_mirrors, '--nosync']",
            "            terras = int(sizestr[:-1]) / 1024.0",
            "            if terras >= 1.5:",
            "                rsize = int(2 ** math.ceil(math.log(terras) / math.log(2)))",
            "                # NOTE(vish): Next power of two for region size. See:",
            "                #             http://red.ht/U2BPOD",
            "                cmd += ['-R', str(rsize)]",
            "",
            "        self._try_execute(*cmd, run_as_root=True, no_retry_list=no_retry_list)",
            "",
            "    def _calculate_count(self, blocksize, size_in_g):",
            "        # Check if volume_dd_blocksize is valid",
            "        try:",
            "            # Rule out zero-sized/negative dd blocksize which",
            "            # cannot be caught by strutils",
            "            if blocksize.startswith(('-', '0')):",
            "                raise ValueError",
            "            bs = strutils.to_bytes(blocksize)",
            "        except (ValueError, TypeError):",
            "            msg = (_(\"Incorrect value error: %(blocksize)s, \"",
            "                     \"it may indicate that \\'volume_dd_blocksize\\' \"",
            "                     \"was configured incorrectly. Fall back to default.\")",
            "                   % {'blocksize': blocksize})",
            "            LOG.warn(msg)",
            "            # Fall back to default blocksize",
            "            CONF.clear_override('volume_dd_blocksize',",
            "                                self.configuration.config_group)",
            "            blocksize = self.configuration.volume_dd_blocksize",
            "            bs = strutils.to_bytes(blocksize)",
            "",
            "        count = math.ceil(size_in_g * units.GiB / float(bs))",
            "",
            "        return blocksize, int(count)",
            "",
            "    def _copy_volume(self, srcstr, deststr, size_in_g, clearing=False):",
            "        # Use O_DIRECT to avoid thrashing the system buffer cache",
            "        extra_flags = ['iflag=direct', 'oflag=direct']",
            "",
            "        # Check whether O_DIRECT is supported",
            "        try:",
            "            self._execute('dd', 'count=0', 'if=%s' % srcstr, 'of=%s' % deststr,",
            "                          *extra_flags, run_as_root=True)",
            "        except exception.ProcessExecutionError:",
            "            extra_flags = []",
            "",
            "        # If the volume is being unprovisioned then",
            "        # request the data is persisted before returning,",
            "        # so that it's not discarded from the cache.",
            "        if clearing and not extra_flags:",
            "            extra_flags.append('conv=fdatasync')",
            "",
            "        blocksize = self.configuration.volume_dd_blocksize",
            "        blocksize, count = self._calculate_count(blocksize, size_in_g)",
            "",
            "        # Perform the copy",
            "        self._execute('dd', 'if=%s' % srcstr, 'of=%s' % deststr,",
            "                      'count=%d' % count,",
            "                      'bs=%s' % blocksize,",
            "                      *extra_flags, run_as_root=True)",
            "",
            "    def _volume_not_present(self, volume_name):",
            "        path_name = '%s/%s' % (self.configuration.volume_group, volume_name)",
            "        try:",
            "            self._try_execute('lvdisplay', path_name, run_as_root=True)",
            "        except Exception as e:",
            "            # If the volume isn't present",
            "            return True",
            "        return False",
            "",
            "    def _delete_volume(self, volume, size_in_g):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        # zero out old volumes to prevent data leaking between users",
            "        # TODO(ja): reclaiming space should be done lazy and low priority",
            "        dev_path = self.local_path(volume)",
            "        if os.path.exists(dev_path):",
            "            self.clear_volume(volume)",
            "",
            "        self._try_execute('lvremove', '-f', \"%s/%s\" %",
            "                          (self.configuration.volume_group,",
            "                           self._escape_snapshot(volume['name'])),",
            "                          run_as_root=True)",
            "",
            "    def _sizestr(self, size_in_g):",
            "        if int(size_in_g) == 0:",
            "            return '100M'",
            "        return '%sG' % size_in_g",
            "",
            "    # Linux LVM reserves name that starts with snapshot, so that",
            "    # such volume name can't be created. Mangle it.",
            "    def _escape_snapshot(self, snapshot_name):",
            "        if not snapshot_name.startswith('snapshot'):",
            "            return snapshot_name",
            "        return '_' + snapshot_name",
            "",
            "    def create_volume(self, volume):",
            "        \"\"\"Creates a logical volume. Can optionally return a Dictionary of",
            "        changes to the volume object to be persisted.",
            "        \"\"\"",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "",
            "    def create_volume_from_snapshot(self, volume, snapshot):",
            "        \"\"\"Creates a volume from a snapshot.\"\"\"",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "        self._copy_volume(self.local_path(snapshot), self.local_path(volume),",
            "                          snapshot['volume_size'])",
            "",
            "    def delete_volume(self, volume):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        if self._volume_not_present(volume['name']):",
            "            # If the volume isn't present, then don't attempt to delete",
            "            return True",
            "",
            "        # TODO(yamahata): lvm can't delete origin volume only without",
            "        # deleting derived snapshots. Can we do something fancy?",
            "        out, err = self._execute('lvdisplay', '--noheading',",
            "                                 '-C', '-o', 'Attr',",
            "                                 '%s/%s' % (self.configuration.volume_group,",
            "                                            volume['name']),",
            "                                 run_as_root=True)",
            "        # fake_execute returns None resulting unit test error",
            "        if out:",
            "            out = out.strip()",
            "            if (out[0] == 'o') or (out[0] == 'O'):",
            "                raise exception.VolumeIsBusy(volume_name=volume['name'])",
            "",
            "        self._delete_volume(volume, volume['size'])",
            "",
            "    def clear_volume(self, volume):",
            "        \"\"\"unprovision old volumes to prevent data leaking between users.\"\"\"",
            "",
            "        vol_path = self.local_path(volume)",
            "        size_in_g = volume.get('size')",
            "        size_in_m = self.configuration.volume_clear_size",
            "",
            "        if not size_in_g:",
            "            LOG.warning(_(\"Size for volume: %s not found, \"",
            "                          \"skipping secure delete.\") % volume['name'])",
            "            return",
            "",
            "        if self.configuration.volume_clear == 'none':",
            "            return",
            "",
            "        LOG.info(_(\"Performing secure delete on volume: %s\") % volume['id'])",
            "",
            "        if self.configuration.volume_clear == 'zero':",
            "            if size_in_m == 0:",
            "                return self._copy_volume('/dev/zero',",
            "                                         vol_path, size_in_g,",
            "                                         clearing=True)",
            "            else:",
            "                clear_cmd = ['shred', '-n0', '-z', '-s%dMiB' % size_in_m]",
            "        elif self.configuration.volume_clear == 'shred':",
            "            clear_cmd = ['shred', '-n3']",
            "            if size_in_m:",
            "                clear_cmd.append('-s%dMiB' % size_in_m)",
            "        else:",
            "            LOG.error(_(\"Error unrecognized volume_clear option: %s\"),",
            "                      self.configuration.volume_clear)",
            "            return",
            "",
            "        clear_cmd.append(vol_path)",
            "        self._execute(*clear_cmd, run_as_root=True)",
            "",
            "    def create_snapshot(self, snapshot):",
            "        \"\"\"Creates a snapshot.\"\"\"",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  snapshot['volume_name'])",
            "        self._try_execute('lvcreate', '-L',",
            "                          self._sizestr(snapshot['volume_size']),",
            "                          '--name', self._escape_snapshot(snapshot['name']),",
            "                          '--snapshot', orig_lv_name, run_as_root=True)",
            "",
            "    def delete_snapshot(self, snapshot):",
            "        \"\"\"Deletes a snapshot.\"\"\"",
            "        if self._volume_not_present(self._escape_snapshot(snapshot['name'])):",
            "            # If the snapshot isn't present, then don't attempt to delete",
            "            LOG.warning(_(\"snapshot: %s not found, \"",
            "                          \"skipping delete operations\") % snapshot['name'])",
            "            return True",
            "",
            "        # TODO(yamahata): zeroing out the whole snapshot triggers COW.",
            "        # it's quite slow.",
            "        self._delete_volume(snapshot, snapshot['volume_size'])",
            "",
            "    def local_path(self, volume):",
            "        # NOTE(vish): stops deprecation warning",
            "        escaped_group = self.configuration.volume_group.replace('-', '--')",
            "        escaped_name = self._escape_snapshot(volume['name']).replace('-', '--')",
            "        return \"/dev/mapper/%s-%s\" % (escaped_group, escaped_name)",
            "",
            "    def copy_image_to_volume(self, context, volume, image_service, image_id):",
            "        \"\"\"Fetch the image from image_service and write it to the volume.\"\"\"",
            "        image_utils.fetch_to_raw(context,",
            "                                 image_service,",
            "                                 image_id,",
            "                                 self.local_path(volume))",
            "",
            "    def copy_volume_to_image(self, context, volume, image_service, image_meta):",
            "        \"\"\"Copy the volume to the specified image.\"\"\"",
            "        image_utils.upload_volume(context,",
            "                                  image_service,",
            "                                  image_meta,",
            "                                  self.local_path(volume))",
            "",
            "    def create_cloned_volume(self, volume, src_vref):",
            "        \"\"\"Creates a clone of the specified volume.\"\"\"",
            "        LOG.info(_('Creating clone of volume: %s') % src_vref['id'])",
            "        volume_name = self.configuration.volume_name_template % src_vref['id']",
            "        temp_id = 'tmp-snap-%s' % src_vref['id']",
            "        temp_snapshot = {'volume_name': volume_name,",
            "                         'size': src_vref['size'],",
            "                         'volume_size': src_vref['size'],",
            "                         'name': 'clone-snap-%s' % src_vref['id'],",
            "                         'id': temp_id}",
            "        self.create_snapshot(temp_snapshot)",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "        try:",
            "            self._copy_volume(self.local_path(temp_snapshot),",
            "                              self.local_path(volume),",
            "                              src_vref['size'])",
            "        finally:",
            "            self.delete_snapshot(temp_snapshot)",
            "",
            "    def clone_image(self, volume, image_location):",
            "        return False",
            "",
            "    def backup_volume(self, context, backup, backup_service):",
            "        \"\"\"Create a new backup from an existing volume.\"\"\"",
            "        volume = self.db.volume_get(context, backup['volume_id'])",
            "        volume_path = self.local_path(volume)",
            "        with utils.temporary_chown(volume_path):",
            "            with fileutils.file_open(volume_path) as volume_file:",
            "                backup_service.backup(backup, volume_file)",
            "",
            "    def restore_backup(self, context, backup, volume, backup_service):",
            "        \"\"\"Restore an existing backup to a new or existing volume.\"\"\"",
            "        volume_path = self.local_path(volume)",
            "        with utils.temporary_chown(volume_path):",
            "            with fileutils.file_open(volume_path, 'wb') as volume_file:",
            "                backup_service.restore(backup, volume['id'], volume_file)",
            "",
            "",
            "class LVMISCSIDriver(LVMVolumeDriver, driver.ISCSIDriver):",
            "    \"\"\"Executes commands relating to ISCSI volumes.",
            "",
            "    We make use of model provider properties as follows:",
            "",
            "    ``provider_location``",
            "      if present, contains the iSCSI target information in the same",
            "      format as an ietadm discovery",
            "      i.e. '<ip>:<port>,<portal> <target IQN>'",
            "",
            "    ``provider_auth``",
            "      if present, contains a space-separated triple:",
            "      '<auth method> <auth username> <auth password>'.",
            "      `CHAP` is the only auth_method in use at the moment.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.tgtadm = iscsi.get_target_admin()",
            "        super(LVMISCSIDriver, self).__init__(*args, **kwargs)",
            "",
            "    def set_execute(self, execute):",
            "        super(LVMISCSIDriver, self).set_execute(execute)",
            "        self.tgtadm.set_execute(execute)",
            "",
            "    def ensure_export(self, context, volume):",
            "        \"\"\"Synchronously recreates an export for a logical volume.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "",
            "        if isinstance(self.tgtadm, iscsi.LioAdm):",
            "            try:",
            "                volume_info = self.db.volume_get(context, volume['id'])",
            "                (auth_method,",
            "                 auth_user,",
            "                 auth_pass) = volume_info['provider_auth'].split(' ', 3)",
            "                chap_auth = self._iscsi_authentication(auth_method,",
            "                                                       auth_user,",
            "                                                       auth_pass)",
            "            except exception.NotFound:",
            "                LOG.debug(\"volume_info:\", volume_info)",
            "                LOG.info(_(\"Skipping ensure_export. No iscsi_target \"",
            "                           \"provision for volume: %s\"), volume['id'])",
            "                return",
            "",
            "            iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                                   volume['name'])",
            "            volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                          volume['name'])",
            "            iscsi_target = 1",
            "",
            "            self.tgtadm.create_iscsi_target(iscsi_name, iscsi_target,",
            "                                            0, volume_path, chap_auth,",
            "                                            check_exit_code=False)",
            "            return",
            "",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping ensure_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "        else:",
            "            iscsi_target = 1  # dummy value when using TgtAdm",
            "",
            "        chap_auth = None",
            "",
            "        # Check for https://bugs.launchpad.net/cinder/+bug/1065702",
            "        old_name = None",
            "        volume_name = volume['name']",
            "        if (volume['provider_location'] is not None and",
            "                volume['name'] not in volume['provider_location']):",
            "",
            "            msg = _('Detected inconsistency in provider_location id')",
            "            LOG.debug(msg)",
            "            old_name = self._fix_id_migration(context, volume)",
            "            if 'in-use' in volume['status']:",
            "                volume_name = old_name",
            "                old_name = None",
            "",
            "        iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                               volume_name)",
            "        volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                      volume_name)",
            "",
            "        # NOTE(jdg): For TgtAdm case iscsi_name is the ONLY param we need",
            "        # should clean this all up at some point in the future",
            "        self.tgtadm.create_iscsi_target(iscsi_name, iscsi_target,",
            "                                        0, volume_path, chap_auth,",
            "                                        check_exit_code=False,",
            "                                        old_name=old_name)",
            "",
            "    def _fix_id_migration(self, context, volume):",
            "        \"\"\"Fix provider_location and dev files to address bug 1065702.",
            "",
            "        For volumes that the provider_location has NOT been updated",
            "        and are not currently in-use we'll create a new iscsi target",
            "        and remove the persist file.",
            "",
            "        If the volume is in-use, we'll just stick with the old name",
            "        and when detach is called we'll feed back into ensure_export",
            "        again if necessary and fix things up then.",
            "",
            "        Details at: https://bugs.launchpad.net/cinder/+bug/1065702",
            "        \"\"\"",
            "",
            "        model_update = {}",
            "        pattern = re.compile(r\":|\\s\")",
            "        fields = pattern.split(volume['provider_location'])",
            "        old_name = fields[3]",
            "",
            "        volume['provider_location'] = \\",
            "            volume['provider_location'].replace(old_name, volume['name'])",
            "        model_update['provider_location'] = volume['provider_location']",
            "",
            "        self.db.volume_update(context, volume['id'], model_update)",
            "",
            "        start = os.getcwd()",
            "        os.chdir('/dev/%s' % self.configuration.volume_group)",
            "",
            "        try:",
            "            (out, err) = self._execute('readlink', old_name)",
            "        except exception.ProcessExecutionError:",
            "            link_path = '/dev/%s/%s' % (self.configuration.volume_group,",
            "                                        old_name)",
            "            LOG.debug(_('Symbolic link %s not found') % link_path)",
            "            os.chdir(start)",
            "            return",
            "",
            "        rel_path = out.rstrip()",
            "        self._execute('ln',",
            "                      '-s',",
            "                      rel_path, volume['name'],",
            "                      run_as_root=True)",
            "        os.chdir(start)",
            "        return old_name",
            "",
            "    def _ensure_iscsi_targets(self, context, host):",
            "        \"\"\"Ensure that target ids have been created in datastore.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            host_iscsi_targets = self.db.iscsi_target_count_by_host(context,",
            "                                                                    host)",
            "            if host_iscsi_targets >= self.configuration.iscsi_num_targets:",
            "                return",
            "",
            "            # NOTE(vish): Target ids start at 1, not 0.",
            "            target_end = self.configuration.iscsi_num_targets + 1",
            "            for target_num in xrange(1, target_end):",
            "                target = {'host': host, 'target_num': target_num}",
            "                self.db.iscsi_target_create_safe(context, target)",
            "",
            "    def create_export(self, context, volume):",
            "        \"\"\"Creates an export for a logical volume.\"\"\"",
            "",
            "        iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                               volume['name'])",
            "        volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                      volume['name'])",
            "        model_update = {}",
            "",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            lun = 0",
            "            self._ensure_iscsi_targets(context, volume['host'])",
            "            iscsi_target = self.db.volume_allocate_iscsi_target(context,",
            "                                                                volume['id'],",
            "                                                                volume['host'])",
            "        else:",
            "            lun = 1  # For tgtadm the controller is lun 0, dev starts at lun 1",
            "            iscsi_target = 0  # NOTE(jdg): Not used by tgtadm",
            "",
            "        # Use the same method to generate the username and the password.",
            "        chap_username = utils.generate_username()",
            "        chap_password = utils.generate_password()",
            "        chap_auth = self._iscsi_authentication('IncomingUser', chap_username,",
            "                                               chap_password)",
            "        # NOTE(jdg): For TgtAdm case iscsi_name is the ONLY param we need",
            "        # should clean this all up at some point in the future",
            "        tid = self.tgtadm.create_iscsi_target(iscsi_name,",
            "                                              iscsi_target,",
            "                                              0,",
            "                                              volume_path,",
            "                                              chap_auth)",
            "        model_update['provider_location'] = self._iscsi_location(",
            "            self.configuration.iscsi_ip_address, tid, iscsi_name, lun)",
            "        model_update['provider_auth'] = self._iscsi_authentication(",
            "            'CHAP', chap_username, chap_password)",
            "        return model_update",
            "",
            "    def remove_export(self, context, volume):",
            "        \"\"\"Removes an export for a logical volume.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "",
            "        if isinstance(self.tgtadm, iscsi.LioAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "",
            "            self.tgtadm.remove_iscsi_target(iscsi_target, 0, volume['id'])",
            "",
            "            return",
            "",
            "        elif not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "        else:",
            "            iscsi_target = 0",
            "",
            "        try:",
            "",
            "            # NOTE: provider_location may be unset if the volume hasn't",
            "            # been exported",
            "            location = volume['provider_location'].split(' ')",
            "            iqn = location[1]",
            "",
            "            # ietadm show will exit with an error",
            "            # this export has already been removed",
            "            self.tgtadm.show_target(iscsi_target, iqn=iqn)",
            "",
            "        except Exception as e:",
            "            LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                       \"is presently exported for volume: %s\"), volume['id'])",
            "            return",
            "",
            "        self.tgtadm.remove_iscsi_target(iscsi_target, 0, volume['id'])",
            "",
            "    def get_volume_stats(self, refresh=False):",
            "        \"\"\"Get volume status.",
            "",
            "        If 'refresh' is True, run update the stats first.",
            "        \"\"\"",
            "        if refresh:",
            "            self._update_volume_status()",
            "",
            "        return self._stats",
            "",
            "    def _update_volume_status(self):",
            "        \"\"\"Retrieve status info from volume group.\"\"\"",
            "",
            "        LOG.debug(_(\"Updating volume status\"))",
            "        data = {}",
            "",
            "        # Note(zhiteng): These information are driver/backend specific,",
            "        # each driver may define these values in its own config options",
            "        # or fetch from driver specific configuration file.",
            "        backend_name = self.configuration.safe_get('volume_backend_name')",
            "        data[\"volume_backend_name\"] = backend_name or 'LVM_iSCSI'",
            "        data[\"vendor_name\"] = 'Open Source'",
            "        data[\"driver_version\"] = self.VERSION",
            "        data[\"storage_protocol\"] = 'iSCSI'",
            "",
            "        data['total_capacity_gb'] = 0",
            "        data['free_capacity_gb'] = 0",
            "        data['reserved_percentage'] = self.configuration.reserved_percentage",
            "        data['QoS_support'] = False",
            "",
            "        try:",
            "            out, err = self._execute('vgs', '--noheadings', '--nosuffix',",
            "                                     '--unit=G', '-o', 'name,size,free',",
            "                                     self.configuration.volume_group,",
            "                                     run_as_root=True)",
            "        except exception.ProcessExecutionError as exc:",
            "            LOG.error(_(\"Error retrieving volume status: %s\"), exc.stderr)",
            "            out = False",
            "",
            "        if out:",
            "            volume = out.split()",
            "            data['total_capacity_gb'] = float(volume[1].replace(',', '.'))",
            "            data['free_capacity_gb'] = float(volume[2].replace(',', '.'))",
            "",
            "        self._stats = data",
            "",
            "    def _iscsi_location(self, ip, target, iqn, lun=None):",
            "        return \"%s:%s,%s %s %s\" % (ip, self.configuration.iscsi_port,",
            "                                   target, iqn, lun)",
            "",
            "    def _iscsi_authentication(self, chap, name, password):",
            "        return \"%s %s %s\" % (chap, name, password)",
            "",
            "",
            "class ThinLVMVolumeDriver(LVMISCSIDriver):",
            "    \"\"\"Subclass for thin provisioned LVM's.\"\"\"",
            "",
            "    VERSION = '1.0'",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(ThinLVMVolumeDriver, self).__init__(*args, **kwargs)",
            "",
            "    def check_for_setup_error(self):",
            "        \"\"\"Returns an error if prerequisites aren't met\"\"\"",
            "        out, err = self._execute('lvs', '--option',",
            "                                 'name', '--noheadings',",
            "                                 run_as_root=True)",
            "        pool_name = \"%s-pool\" % self.configuration.volume_group",
            "        if pool_name not in out:",
            "            if not self.configuration.pool_size:",
            "                out, err = self._execute('vgs',",
            "                                         self.configuration.volume_group,",
            "                                         '--noheadings',",
            "                                         '--options',",
            "                                         'name,size',",
            "                                         run_as_root=True)",
            "",
            "                size = re.sub(r'[\\.][\\d][\\d]', '', out.split()[1])",
            "            else:",
            "                size = \"%s\" % self.configuration.pool_size",
            "",
            "            pool_path = '%s/%s' % (self.configuration.volume_group,",
            "                                   pool_name)",
            "            out, err = self._execute('lvcreate', '-T', '-L', size,",
            "                                     pool_path, run_as_root=True)",
            "",
            "    def _do_lvm_snapshot(self, src_lvm_name, dest_vref, is_cinder_snap=True):",
            "            if is_cinder_snap:",
            "                new_name = self._escape_snapshot(dest_vref['name'])",
            "            else:",
            "                new_name = dest_vref['name']",
            "",
            "            self._try_execute('lvcreate', '-s', '-n', new_name,",
            "                              src_lvm_name, run_as_root=True)",
            "",
            "    def _create_volume(self, volume):",
            "        sizestr = self._sizestr(volume['size'])",
            "        vg_name = (\"%s/%s-pool\" % (self.configuration.volume_group,",
            "                                   self.configuration.volume_group))",
            "        self._try_execute('lvcreate', '-T', '-V', sizestr, '-n',",
            "                          volume['name'], vg_name, run_as_root=True)",
            "",
            "    def create_volume(self, volume):",
            "        \"\"\"Creates a logical volume.\"\"\"",
            "        self._create_volume(volume)",
            "",
            "    def delete_volume(self, volume):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        if self._volume_not_present(volume['name']):",
            "            return True",
            "        self._try_execute('lvremove', '-f', \"%s/%s\" %",
            "                          (self.configuration.volume_group,",
            "                           self._escape_snapshot(volume['name'])),",
            "                          run_as_root=True)",
            "",
            "    def create_cloned_volume(self, volume, src_vref):",
            "        \"\"\"Creates a clone of the specified volume.\"\"\"",
            "        LOG.info(_('Creating clone of volume: %s') % src_vref['id'])",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  src_vref['name'])",
            "        self._do_lvm_snapshot(orig_lv_name, volume, False)",
            "",
            "    def create_snapshot(self, snapshot):",
            "        \"\"\"Creates a snapshot of a volume.\"\"\"",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  snapshot['volume_name'])",
            "        self._do_lvm_snapshot(orig_lv_name, snapshot)",
            "",
            "    def get_volume_stats(self, refresh=False):",
            "        \"\"\"Get volume status.",
            "        If 'refresh' is True, run update the stats first.",
            "        \"\"\"",
            "        if refresh:",
            "            self._update_volume_status()",
            "",
            "        return self._stats",
            "",
            "    def _update_volume_status(self):",
            "        \"\"\"Retrieve status info from volume group.\"\"\"",
            "",
            "        LOG.debug(_(\"Updating volume status\"))",
            "        data = {}",
            "",
            "        backend_name = self.configuration.safe_get('volume_backend_name')",
            "        data[\"volume_backend_name\"] = backend_name or self.__class__.__name__",
            "        data[\"vendor_name\"] = 'Open Source'",
            "        data[\"driver_version\"] = self.VERSION",
            "        data[\"storage_protocol\"] = 'iSCSI'",
            "        data['reserved_percentage'] = self.configuration.reserved_percentage",
            "        data['QoS_support'] = False",
            "        data['total_capacity_gb'] = 'infinite'",
            "        data['free_capacity_gb'] = 'infinite'",
            "        self._stats = data"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Driver for Linux servers running LVM.",
            "",
            "\"\"\"",
            "",
            "import math",
            "import os",
            "import re",
            "",
            "from oslo.config import cfg",
            "",
            "from cinder.brick.iscsi import iscsi",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import log as logging",
            "from cinder.openstack.common import strutils",
            "from cinder import units",
            "from cinder import utils",
            "from cinder.volume import driver",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "volume_opts = [",
            "    cfg.StrOpt('volume_group',",
            "               default='cinder-volumes',",
            "               help='Name for the VG that will contain exported volumes'),",
            "    cfg.StrOpt('volume_clear',",
            "               default='zero',",
            "               help='Method used to wipe old volumes (valid options are: '",
            "                    'none, zero, shred)'),",
            "    cfg.IntOpt('volume_clear_size',",
            "               default=0,",
            "               help='Size in MiB to wipe at start of old volumes. 0 => all'),",
            "    cfg.StrOpt('volume_dd_blocksize',",
            "               default='1M',",
            "               help='The default block size used when clearing volumes'),",
            "    cfg.StrOpt('pool_size',",
            "               default=None,",
            "               help='Size of thin provisioning pool '",
            "                    '(None uses entire cinder VG)'),",
            "    cfg.IntOpt('lvm_mirrors',",
            "               default=0,",
            "               help='If set, create lvms with multiple mirrors. Note that '",
            "                    'this requires lvm_mirrors + 2 pvs with available space'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(volume_opts)",
            "",
            "",
            "class LVMVolumeDriver(driver.VolumeDriver):",
            "    \"\"\"Executes commands relating to Volumes.\"\"\"",
            "",
            "    VERSION = '1.0'",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(LVMVolumeDriver, self).__init__(*args, **kwargs)",
            "        self.configuration.append_config_values(volume_opts)",
            "",
            "    def check_for_setup_error(self):",
            "        \"\"\"Returns an error if prerequisites aren't met\"\"\"",
            "        out, err = self._execute('vgs', '--noheadings', '-o', 'name',",
            "                                 run_as_root=True)",
            "        volume_groups = out.split()",
            "        if self.configuration.volume_group not in volume_groups:",
            "            exception_message = (_(\"volume group %s doesn't exist\")",
            "                                 % self.configuration.volume_group)",
            "            raise exception.VolumeBackendAPIException(data=exception_message)",
            "",
            "    def _create_volume(self, volume_name, sizestr):",
            "",
            "        no_retry_list = ['Insufficient free extents',",
            "                         'One or more specified logical volume(s) not found']",
            "",
            "        cmd = ['lvcreate', '-L', sizestr, '-n', volume_name,",
            "               self.configuration.volume_group]",
            "        if self.configuration.lvm_mirrors:",
            "            cmd += ['-m', self.configuration.lvm_mirrors, '--nosync']",
            "            terras = int(sizestr[:-1]) / 1024.0",
            "            if terras >= 1.5:",
            "                rsize = int(2 ** math.ceil(math.log(terras) / math.log(2)))",
            "                # NOTE(vish): Next power of two for region size. See:",
            "                #             http://red.ht/U2BPOD",
            "                cmd += ['-R', str(rsize)]",
            "",
            "        self._try_execute(*cmd, run_as_root=True, no_retry_list=no_retry_list)",
            "",
            "    def _calculate_count(self, blocksize, size_in_g):",
            "        # Check if volume_dd_blocksize is valid",
            "        try:",
            "            # Rule out zero-sized/negative dd blocksize which",
            "            # cannot be caught by strutils",
            "            if blocksize.startswith(('-', '0')):",
            "                raise ValueError",
            "            bs = strutils.to_bytes(blocksize)",
            "        except (ValueError, TypeError):",
            "            msg = (_(\"Incorrect value error: %(blocksize)s, \"",
            "                     \"it may indicate that \\'volume_dd_blocksize\\' \"",
            "                     \"was configured incorrectly. Fall back to default.\")",
            "                   % {'blocksize': blocksize})",
            "            LOG.warn(msg)",
            "            # Fall back to default blocksize",
            "            CONF.clear_override('volume_dd_blocksize',",
            "                                self.configuration.config_group)",
            "            blocksize = self.configuration.volume_dd_blocksize",
            "            bs = strutils.to_bytes(blocksize)",
            "",
            "        count = math.ceil(size_in_g * units.GiB / float(bs))",
            "",
            "        return blocksize, int(count)",
            "",
            "    def _copy_volume(self, srcstr, deststr, size_in_g, clearing=False):",
            "        # Use O_DIRECT to avoid thrashing the system buffer cache",
            "        extra_flags = ['iflag=direct', 'oflag=direct']",
            "",
            "        # Check whether O_DIRECT is supported",
            "        try:",
            "            self._execute('dd', 'count=0', 'if=%s' % srcstr, 'of=%s' % deststr,",
            "                          *extra_flags, run_as_root=True)",
            "        except exception.ProcessExecutionError:",
            "            extra_flags = []",
            "",
            "        # If the volume is being unprovisioned then",
            "        # request the data is persisted before returning,",
            "        # so that it's not discarded from the cache.",
            "        if clearing and not extra_flags:",
            "            extra_flags.append('conv=fdatasync')",
            "",
            "        blocksize = self.configuration.volume_dd_blocksize",
            "        blocksize, count = self._calculate_count(blocksize, size_in_g)",
            "",
            "        # Perform the copy",
            "        self._execute('dd', 'if=%s' % srcstr, 'of=%s' % deststr,",
            "                      'count=%d' % count,",
            "                      'bs=%s' % blocksize,",
            "                      *extra_flags, run_as_root=True)",
            "",
            "    def _volume_not_present(self, volume_name):",
            "        path_name = '%s/%s' % (self.configuration.volume_group, volume_name)",
            "        try:",
            "            self._try_execute('lvdisplay', path_name, run_as_root=True)",
            "        except Exception as e:",
            "            # If the volume isn't present",
            "            return True",
            "        return False",
            "",
            "    def _delete_volume(self, volume):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        # zero out old volumes to prevent data leaking between users",
            "        # TODO(ja): reclaiming space should be done lazy and low priority",
            "        dev_path = self.local_path(volume)",
            "        if os.path.exists(dev_path):",
            "            self.clear_volume(volume)",
            "",
            "        self._try_execute('lvremove', '-f', \"%s/%s\" %",
            "                          (self.configuration.volume_group,",
            "                           self._escape_snapshot(volume['name'])),",
            "                          run_as_root=True)",
            "",
            "    def _sizestr(self, size_in_g):",
            "        if int(size_in_g) == 0:",
            "            return '100M'",
            "        return '%sG' % size_in_g",
            "",
            "    # Linux LVM reserves name that starts with snapshot, so that",
            "    # such volume name can't be created. Mangle it.",
            "    def _escape_snapshot(self, snapshot_name):",
            "        if not snapshot_name.startswith('snapshot'):",
            "            return snapshot_name",
            "        return '_' + snapshot_name",
            "",
            "    def create_volume(self, volume):",
            "        \"\"\"Creates a logical volume. Can optionally return a Dictionary of",
            "        changes to the volume object to be persisted.",
            "        \"\"\"",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "",
            "    def create_volume_from_snapshot(self, volume, snapshot):",
            "        \"\"\"Creates a volume from a snapshot.\"\"\"",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "        self._copy_volume(self.local_path(snapshot), self.local_path(volume),",
            "                          snapshot['volume_size'])",
            "",
            "    def delete_volume(self, volume):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        if self._volume_not_present(volume['name']):",
            "            # If the volume isn't present, then don't attempt to delete",
            "            return True",
            "",
            "        # TODO(yamahata): lvm can't delete origin volume only without",
            "        # deleting derived snapshots. Can we do something fancy?",
            "        out, err = self._execute('lvdisplay', '--noheading',",
            "                                 '-C', '-o', 'Attr',",
            "                                 '%s/%s' % (self.configuration.volume_group,",
            "                                            volume['name']),",
            "                                 run_as_root=True)",
            "        # fake_execute returns None resulting unit test error",
            "        if out:",
            "            out = out.strip()",
            "            if (out[0] == 'o') or (out[0] == 'O'):",
            "                raise exception.VolumeIsBusy(volume_name=volume['name'])",
            "",
            "        self._delete_volume(volume)",
            "",
            "    def clear_volume(self, volume):",
            "        \"\"\"unprovision old volumes to prevent data leaking between users.\"\"\"",
            "",
            "        vol_path = self.local_path(volume)",
            "        size_in_g = volume.get('size', volume.get('volume_size', None))",
            "        if size_in_g is None:",
            "            LOG.warning(_(\"Size for volume: %s not found, \"",
            "                          \"skipping secure delete.\") % volume['id'])",
            "            return",
            "        size_in_m = self.configuration.volume_clear_size",
            "",
            "        if self.configuration.volume_clear == 'none':",
            "            return",
            "",
            "        LOG.info(_(\"Performing secure delete on volume: %s\") % volume['id'])",
            "",
            "        if self.configuration.volume_clear == 'zero':",
            "            if size_in_m == 0:",
            "                return self._copy_volume('/dev/zero',",
            "                                         vol_path, size_in_g,",
            "                                         clearing=True)",
            "            else:",
            "                clear_cmd = ['shred', '-n0', '-z', '-s%dMiB' % size_in_m]",
            "        elif self.configuration.volume_clear == 'shred':",
            "            clear_cmd = ['shred', '-n3']",
            "            if size_in_m:",
            "                clear_cmd.append('-s%dMiB' % size_in_m)",
            "        else:",
            "            LOG.error(_(\"Error unrecognized volume_clear option: %s\"),",
            "                      self.configuration.volume_clear)",
            "            return",
            "",
            "        clear_cmd.append(vol_path)",
            "        self._execute(*clear_cmd, run_as_root=True)",
            "",
            "    def create_snapshot(self, snapshot):",
            "        \"\"\"Creates a snapshot.\"\"\"",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  snapshot['volume_name'])",
            "        self._try_execute('lvcreate', '-L',",
            "                          self._sizestr(snapshot['volume_size']),",
            "                          '--name', self._escape_snapshot(snapshot['name']),",
            "                          '--snapshot', orig_lv_name, run_as_root=True)",
            "",
            "    def delete_snapshot(self, snapshot):",
            "        \"\"\"Deletes a snapshot.\"\"\"",
            "        if self._volume_not_present(self._escape_snapshot(snapshot['name'])):",
            "            # If the snapshot isn't present, then don't attempt to delete",
            "            LOG.warning(_(\"snapshot: %s not found, \"",
            "                          \"skipping delete operations\") % snapshot['name'])",
            "            return True",
            "",
            "        # TODO(yamahata): zeroing out the whole snapshot triggers COW.",
            "        # it's quite slow.",
            "        self._delete_volume(snapshot)",
            "",
            "    def local_path(self, volume):",
            "        # NOTE(vish): stops deprecation warning",
            "        escaped_group = self.configuration.volume_group.replace('-', '--')",
            "        escaped_name = self._escape_snapshot(volume['name']).replace('-', '--')",
            "        return \"/dev/mapper/%s-%s\" % (escaped_group, escaped_name)",
            "",
            "    def copy_image_to_volume(self, context, volume, image_service, image_id):",
            "        \"\"\"Fetch the image from image_service and write it to the volume.\"\"\"",
            "        image_utils.fetch_to_raw(context,",
            "                                 image_service,",
            "                                 image_id,",
            "                                 self.local_path(volume))",
            "",
            "    def copy_volume_to_image(self, context, volume, image_service, image_meta):",
            "        \"\"\"Copy the volume to the specified image.\"\"\"",
            "        image_utils.upload_volume(context,",
            "                                  image_service,",
            "                                  image_meta,",
            "                                  self.local_path(volume))",
            "",
            "    def create_cloned_volume(self, volume, src_vref):",
            "        \"\"\"Creates a clone of the specified volume.\"\"\"",
            "        LOG.info(_('Creating clone of volume: %s') % src_vref['id'])",
            "        volume_name = self.configuration.volume_name_template % src_vref['id']",
            "        temp_id = 'tmp-snap-%s' % src_vref['id']",
            "        temp_snapshot = {'volume_name': volume_name,",
            "                         'size': src_vref['size'],",
            "                         'volume_size': src_vref['size'],",
            "                         'name': 'clone-snap-%s' % src_vref['id'],",
            "                         'id': temp_id}",
            "        self.create_snapshot(temp_snapshot)",
            "        self._create_volume(volume['name'], self._sizestr(volume['size']))",
            "        try:",
            "            self._copy_volume(self.local_path(temp_snapshot),",
            "                              self.local_path(volume),",
            "                              src_vref['size'])",
            "        finally:",
            "            self.delete_snapshot(temp_snapshot)",
            "",
            "    def clone_image(self, volume, image_location):",
            "        return False",
            "",
            "    def backup_volume(self, context, backup, backup_service):",
            "        \"\"\"Create a new backup from an existing volume.\"\"\"",
            "        volume = self.db.volume_get(context, backup['volume_id'])",
            "        volume_path = self.local_path(volume)",
            "        with utils.temporary_chown(volume_path):",
            "            with fileutils.file_open(volume_path) as volume_file:",
            "                backup_service.backup(backup, volume_file)",
            "",
            "    def restore_backup(self, context, backup, volume, backup_service):",
            "        \"\"\"Restore an existing backup to a new or existing volume.\"\"\"",
            "        volume_path = self.local_path(volume)",
            "        with utils.temporary_chown(volume_path):",
            "            with fileutils.file_open(volume_path, 'wb') as volume_file:",
            "                backup_service.restore(backup, volume['id'], volume_file)",
            "",
            "",
            "class LVMISCSIDriver(LVMVolumeDriver, driver.ISCSIDriver):",
            "    \"\"\"Executes commands relating to ISCSI volumes.",
            "",
            "    We make use of model provider properties as follows:",
            "",
            "    ``provider_location``",
            "      if present, contains the iSCSI target information in the same",
            "      format as an ietadm discovery",
            "      i.e. '<ip>:<port>,<portal> <target IQN>'",
            "",
            "    ``provider_auth``",
            "      if present, contains a space-separated triple:",
            "      '<auth method> <auth username> <auth password>'.",
            "      `CHAP` is the only auth_method in use at the moment.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.tgtadm = iscsi.get_target_admin()",
            "        super(LVMISCSIDriver, self).__init__(*args, **kwargs)",
            "",
            "    def set_execute(self, execute):",
            "        super(LVMISCSIDriver, self).set_execute(execute)",
            "        self.tgtadm.set_execute(execute)",
            "",
            "    def ensure_export(self, context, volume):",
            "        \"\"\"Synchronously recreates an export for a logical volume.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "",
            "        if isinstance(self.tgtadm, iscsi.LioAdm):",
            "            try:",
            "                volume_info = self.db.volume_get(context, volume['id'])",
            "                (auth_method,",
            "                 auth_user,",
            "                 auth_pass) = volume_info['provider_auth'].split(' ', 3)",
            "                chap_auth = self._iscsi_authentication(auth_method,",
            "                                                       auth_user,",
            "                                                       auth_pass)",
            "            except exception.NotFound:",
            "                LOG.debug(\"volume_info:\", volume_info)",
            "                LOG.info(_(\"Skipping ensure_export. No iscsi_target \"",
            "                           \"provision for volume: %s\"), volume['id'])",
            "                return",
            "",
            "            iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                                   volume['name'])",
            "            volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                          volume['name'])",
            "            iscsi_target = 1",
            "",
            "            self.tgtadm.create_iscsi_target(iscsi_name, iscsi_target,",
            "                                            0, volume_path, chap_auth,",
            "                                            check_exit_code=False)",
            "            return",
            "",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping ensure_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "        else:",
            "            iscsi_target = 1  # dummy value when using TgtAdm",
            "",
            "        chap_auth = None",
            "",
            "        # Check for https://bugs.launchpad.net/cinder/+bug/1065702",
            "        old_name = None",
            "        volume_name = volume['name']",
            "        if (volume['provider_location'] is not None and",
            "                volume['name'] not in volume['provider_location']):",
            "",
            "            msg = _('Detected inconsistency in provider_location id')",
            "            LOG.debug(msg)",
            "            old_name = self._fix_id_migration(context, volume)",
            "            if 'in-use' in volume['status']:",
            "                volume_name = old_name",
            "                old_name = None",
            "",
            "        iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                               volume_name)",
            "        volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                      volume_name)",
            "",
            "        # NOTE(jdg): For TgtAdm case iscsi_name is the ONLY param we need",
            "        # should clean this all up at some point in the future",
            "        self.tgtadm.create_iscsi_target(iscsi_name, iscsi_target,",
            "                                        0, volume_path, chap_auth,",
            "                                        check_exit_code=False,",
            "                                        old_name=old_name)",
            "",
            "    def _fix_id_migration(self, context, volume):",
            "        \"\"\"Fix provider_location and dev files to address bug 1065702.",
            "",
            "        For volumes that the provider_location has NOT been updated",
            "        and are not currently in-use we'll create a new iscsi target",
            "        and remove the persist file.",
            "",
            "        If the volume is in-use, we'll just stick with the old name",
            "        and when detach is called we'll feed back into ensure_export",
            "        again if necessary and fix things up then.",
            "",
            "        Details at: https://bugs.launchpad.net/cinder/+bug/1065702",
            "        \"\"\"",
            "",
            "        model_update = {}",
            "        pattern = re.compile(r\":|\\s\")",
            "        fields = pattern.split(volume['provider_location'])",
            "        old_name = fields[3]",
            "",
            "        volume['provider_location'] = \\",
            "            volume['provider_location'].replace(old_name, volume['name'])",
            "        model_update['provider_location'] = volume['provider_location']",
            "",
            "        self.db.volume_update(context, volume['id'], model_update)",
            "",
            "        start = os.getcwd()",
            "        os.chdir('/dev/%s' % self.configuration.volume_group)",
            "",
            "        try:",
            "            (out, err) = self._execute('readlink', old_name)",
            "        except exception.ProcessExecutionError:",
            "            link_path = '/dev/%s/%s' % (self.configuration.volume_group,",
            "                                        old_name)",
            "            LOG.debug(_('Symbolic link %s not found') % link_path)",
            "            os.chdir(start)",
            "            return",
            "",
            "        rel_path = out.rstrip()",
            "        self._execute('ln',",
            "                      '-s',",
            "                      rel_path, volume['name'],",
            "                      run_as_root=True)",
            "        os.chdir(start)",
            "        return old_name",
            "",
            "    def _ensure_iscsi_targets(self, context, host):",
            "        \"\"\"Ensure that target ids have been created in datastore.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            host_iscsi_targets = self.db.iscsi_target_count_by_host(context,",
            "                                                                    host)",
            "            if host_iscsi_targets >= self.configuration.iscsi_num_targets:",
            "                return",
            "",
            "            # NOTE(vish): Target ids start at 1, not 0.",
            "            target_end = self.configuration.iscsi_num_targets + 1",
            "            for target_num in xrange(1, target_end):",
            "                target = {'host': host, 'target_num': target_num}",
            "                self.db.iscsi_target_create_safe(context, target)",
            "",
            "    def create_export(self, context, volume):",
            "        \"\"\"Creates an export for a logical volume.\"\"\"",
            "",
            "        iscsi_name = \"%s%s\" % (self.configuration.iscsi_target_prefix,",
            "                               volume['name'])",
            "        volume_path = \"/dev/%s/%s\" % (self.configuration.volume_group,",
            "                                      volume['name'])",
            "        model_update = {}",
            "",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "        if not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            lun = 0",
            "            self._ensure_iscsi_targets(context, volume['host'])",
            "            iscsi_target = self.db.volume_allocate_iscsi_target(context,",
            "                                                                volume['id'],",
            "                                                                volume['host'])",
            "        else:",
            "            lun = 1  # For tgtadm the controller is lun 0, dev starts at lun 1",
            "            iscsi_target = 0  # NOTE(jdg): Not used by tgtadm",
            "",
            "        # Use the same method to generate the username and the password.",
            "        chap_username = utils.generate_username()",
            "        chap_password = utils.generate_password()",
            "        chap_auth = self._iscsi_authentication('IncomingUser', chap_username,",
            "                                               chap_password)",
            "        # NOTE(jdg): For TgtAdm case iscsi_name is the ONLY param we need",
            "        # should clean this all up at some point in the future",
            "        tid = self.tgtadm.create_iscsi_target(iscsi_name,",
            "                                              iscsi_target,",
            "                                              0,",
            "                                              volume_path,",
            "                                              chap_auth)",
            "        model_update['provider_location'] = self._iscsi_location(",
            "            self.configuration.iscsi_ip_address, tid, iscsi_name, lun)",
            "        model_update['provider_auth'] = self._iscsi_authentication(",
            "            'CHAP', chap_username, chap_password)",
            "        return model_update",
            "",
            "    def remove_export(self, context, volume):",
            "        \"\"\"Removes an export for a logical volume.\"\"\"",
            "        # NOTE(jdg): tgtadm doesn't use the iscsi_targets table",
            "        # TODO(jdg): In the future move all of the dependent stuff into the",
            "        # cooresponding target admin class",
            "",
            "        if isinstance(self.tgtadm, iscsi.LioAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "",
            "            self.tgtadm.remove_iscsi_target(iscsi_target, 0, volume['id'])",
            "",
            "            return",
            "",
            "        elif not isinstance(self.tgtadm, iscsi.TgtAdm):",
            "            try:",
            "                iscsi_target = self.db.volume_get_iscsi_target_num(",
            "                    context,",
            "                    volume['id'])",
            "            except exception.NotFound:",
            "                LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                           \"provisioned for volume: %s\"), volume['id'])",
            "                return",
            "        else:",
            "            iscsi_target = 0",
            "",
            "        try:",
            "",
            "            # NOTE: provider_location may be unset if the volume hasn't",
            "            # been exported",
            "            location = volume['provider_location'].split(' ')",
            "            iqn = location[1]",
            "",
            "            # ietadm show will exit with an error",
            "            # this export has already been removed",
            "            self.tgtadm.show_target(iscsi_target, iqn=iqn)",
            "",
            "        except Exception as e:",
            "            LOG.info(_(\"Skipping remove_export. No iscsi_target \"",
            "                       \"is presently exported for volume: %s\"), volume['id'])",
            "            return",
            "",
            "        self.tgtadm.remove_iscsi_target(iscsi_target, 0, volume['id'])",
            "",
            "    def get_volume_stats(self, refresh=False):",
            "        \"\"\"Get volume status.",
            "",
            "        If 'refresh' is True, run update the stats first.",
            "        \"\"\"",
            "        if refresh:",
            "            self._update_volume_status()",
            "",
            "        return self._stats",
            "",
            "    def _update_volume_status(self):",
            "        \"\"\"Retrieve status info from volume group.\"\"\"",
            "",
            "        LOG.debug(_(\"Updating volume status\"))",
            "        data = {}",
            "",
            "        # Note(zhiteng): These information are driver/backend specific,",
            "        # each driver may define these values in its own config options",
            "        # or fetch from driver specific configuration file.",
            "        backend_name = self.configuration.safe_get('volume_backend_name')",
            "        data[\"volume_backend_name\"] = backend_name or 'LVM_iSCSI'",
            "        data[\"vendor_name\"] = 'Open Source'",
            "        data[\"driver_version\"] = self.VERSION",
            "        data[\"storage_protocol\"] = 'iSCSI'",
            "",
            "        data['total_capacity_gb'] = 0",
            "        data['free_capacity_gb'] = 0",
            "        data['reserved_percentage'] = self.configuration.reserved_percentage",
            "        data['QoS_support'] = False",
            "",
            "        try:",
            "            out, err = self._execute('vgs', '--noheadings', '--nosuffix',",
            "                                     '--unit=G', '-o', 'name,size,free',",
            "                                     self.configuration.volume_group,",
            "                                     run_as_root=True)",
            "        except exception.ProcessExecutionError as exc:",
            "            LOG.error(_(\"Error retrieving volume status: %s\"), exc.stderr)",
            "            out = False",
            "",
            "        if out:",
            "            volume = out.split()",
            "            data['total_capacity_gb'] = float(volume[1].replace(',', '.'))",
            "            data['free_capacity_gb'] = float(volume[2].replace(',', '.'))",
            "",
            "        self._stats = data",
            "",
            "    def _iscsi_location(self, ip, target, iqn, lun=None):",
            "        return \"%s:%s,%s %s %s\" % (ip, self.configuration.iscsi_port,",
            "                                   target, iqn, lun)",
            "",
            "    def _iscsi_authentication(self, chap, name, password):",
            "        return \"%s %s %s\" % (chap, name, password)",
            "",
            "",
            "class ThinLVMVolumeDriver(LVMISCSIDriver):",
            "    \"\"\"Subclass for thin provisioned LVM's.\"\"\"",
            "",
            "    VERSION = '1.0'",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(ThinLVMVolumeDriver, self).__init__(*args, **kwargs)",
            "",
            "    def check_for_setup_error(self):",
            "        \"\"\"Returns an error if prerequisites aren't met\"\"\"",
            "        out, err = self._execute('lvs', '--option',",
            "                                 'name', '--noheadings',",
            "                                 run_as_root=True)",
            "        pool_name = \"%s-pool\" % self.configuration.volume_group",
            "        if pool_name not in out:",
            "            if not self.configuration.pool_size:",
            "                out, err = self._execute('vgs',",
            "                                         self.configuration.volume_group,",
            "                                         '--noheadings',",
            "                                         '--options',",
            "                                         'name,size',",
            "                                         run_as_root=True)",
            "",
            "                size = re.sub(r'[\\.][\\d][\\d]', '', out.split()[1])",
            "            else:",
            "                size = \"%s\" % self.configuration.pool_size",
            "",
            "            pool_path = '%s/%s' % (self.configuration.volume_group,",
            "                                   pool_name)",
            "            out, err = self._execute('lvcreate', '-T', '-L', size,",
            "                                     pool_path, run_as_root=True)",
            "",
            "    def _do_lvm_snapshot(self, src_lvm_name, dest_vref, is_cinder_snap=True):",
            "            if is_cinder_snap:",
            "                new_name = self._escape_snapshot(dest_vref['name'])",
            "            else:",
            "                new_name = dest_vref['name']",
            "",
            "            self._try_execute('lvcreate', '-s', '-n', new_name,",
            "                              src_lvm_name, run_as_root=True)",
            "",
            "    def _create_volume(self, volume):",
            "        sizestr = self._sizestr(volume['size'])",
            "        vg_name = (\"%s/%s-pool\" % (self.configuration.volume_group,",
            "                                   self.configuration.volume_group))",
            "        self._try_execute('lvcreate', '-T', '-V', sizestr, '-n',",
            "                          volume['name'], vg_name, run_as_root=True)",
            "",
            "    def create_volume(self, volume):",
            "        \"\"\"Creates a logical volume.\"\"\"",
            "        self._create_volume(volume)",
            "",
            "    def delete_volume(self, volume):",
            "        \"\"\"Deletes a logical volume.\"\"\"",
            "        if self._volume_not_present(volume['name']):",
            "            return True",
            "        self._try_execute('lvremove', '-f', \"%s/%s\" %",
            "                          (self.configuration.volume_group,",
            "                           self._escape_snapshot(volume['name'])),",
            "                          run_as_root=True)",
            "",
            "    def create_cloned_volume(self, volume, src_vref):",
            "        \"\"\"Creates a clone of the specified volume.\"\"\"",
            "        LOG.info(_('Creating clone of volume: %s') % src_vref['id'])",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  src_vref['name'])",
            "        self._do_lvm_snapshot(orig_lv_name, volume, False)",
            "",
            "    def create_snapshot(self, snapshot):",
            "        \"\"\"Creates a snapshot of a volume.\"\"\"",
            "        orig_lv_name = \"%s/%s\" % (self.configuration.volume_group,",
            "                                  snapshot['volume_name'])",
            "        self._do_lvm_snapshot(orig_lv_name, snapshot)",
            "",
            "    def get_volume_stats(self, refresh=False):",
            "        \"\"\"Get volume status.",
            "        If 'refresh' is True, run update the stats first.",
            "        \"\"\"",
            "        if refresh:",
            "            self._update_volume_status()",
            "",
            "        return self._stats",
            "",
            "    def _update_volume_status(self):",
            "        \"\"\"Retrieve status info from volume group.\"\"\"",
            "",
            "        LOG.debug(_(\"Updating volume status\"))",
            "        data = {}",
            "",
            "        backend_name = self.configuration.safe_get('volume_backend_name')",
            "        data[\"volume_backend_name\"] = backend_name or self.__class__.__name__",
            "        data[\"vendor_name\"] = 'Open Source'",
            "        data[\"driver_version\"] = self.VERSION",
            "        data[\"storage_protocol\"] = 'iSCSI'",
            "        data['reserved_percentage'] = self.configuration.reserved_percentage",
            "        data['QoS_support'] = False",
            "        data['total_capacity_gb'] = 'infinite'",
            "        data['free_capacity_gb'] = 'infinite'",
            "        self._stats = data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "165": [
                "LVMVolumeDriver",
                "_delete_volume"
            ],
            "221": [
                "LVMVolumeDriver",
                "delete_volume"
            ],
            "227": [
                "LVMVolumeDriver",
                "clear_volume"
            ],
            "228": [
                "LVMVolumeDriver",
                "clear_volume"
            ],
            "229": [
                "LVMVolumeDriver",
                "clear_volume"
            ],
            "230": [
                "LVMVolumeDriver",
                "clear_volume"
            ],
            "232": [
                "LVMVolumeDriver",
                "clear_volume"
            ],
            "278": [
                "LVMVolumeDriver",
                "delete_snapshot"
            ]
        },
        "addLocation": []
    }
}