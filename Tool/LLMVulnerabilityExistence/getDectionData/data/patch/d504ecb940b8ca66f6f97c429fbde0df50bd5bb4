{
    "sanic/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 999,
                "afterPatchRowNumber": 999,
                "PatchRowcode": "     def asgi_client(self):  # noqa"
            },
            "1": {
                "beforePatchRowNumber": 1000,
                "afterPatchRowNumber": 1000,
                "PatchRowcode": "         \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 1001,
                "afterPatchRowNumber": 1001,
                "PatchRowcode": "         A testing client that uses ASGI to reach into the application to"
            },
            "3": {
                "beforePatchRowNumber": 1002,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        execute hanlers."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1002,
                "PatchRowcode": "+        execute handlers."
            },
            "5": {
                "beforePatchRowNumber": 1003,
                "afterPatchRowNumber": 1003,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 1004,
                "afterPatchRowNumber": 1004,
                "PatchRowcode": "         :return: testing client"
            },
            "7": {
                "beforePatchRowNumber": 1005,
                "afterPatchRowNumber": 1005,
                "PatchRowcode": "         :rtype: :class:`SanicASGITestClient`"
            },
            "8": {
                "beforePatchRowNumber": 1194,
                "afterPatchRowNumber": 1194,
                "PatchRowcode": "         `See user guide re: background tasks"
            },
            "9": {
                "beforePatchRowNumber": 1195,
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "         <https://sanicframework.org/guide/basics/tasks.html#background-tasks>`__"
            },
            "10": {
                "beforePatchRowNumber": 1196,
                "afterPatchRowNumber": 1196,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 1197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param task: future, couroutine or awaitable"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1197,
                "PatchRowcode": "+        :param task: future, coroutine or awaitable"
            },
            "13": {
                "beforePatchRowNumber": 1198,
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 1199,
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "         try:"
            },
            "15": {
                "beforePatchRowNumber": 1200,
                "afterPatchRowNumber": 1200,
                "PatchRowcode": "             loop = self.loop  # Will raise SanicError if loop is not started"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import logging",
            "import logging.config",
            "import re",
            "import sys",
            "",
            "from asyncio import (",
            "    AbstractEventLoop,",
            "    CancelledError,",
            "    Task,",
            "    ensure_future,",
            "    get_running_loop,",
            "    wait_for,",
            ")",
            "from asyncio.futures import Future",
            "from collections import defaultdict, deque",
            "from contextlib import suppress",
            "from functools import partial",
            "from inspect import isawaitable",
            "from socket import socket",
            "from traceback import format_exc",
            "from types import SimpleNamespace",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AnyStr,",
            "    Awaitable,",
            "    Callable,",
            "    Coroutine,",
            "    Deque,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import urlencode, urlunparse",
            "from warnings import filterwarnings",
            "",
            "from sanic_routing.exceptions import FinalizationError, NotFound",
            "from sanic_routing.route import Route",
            "",
            "from sanic.application.ext import setup_ext",
            "from sanic.application.state import ApplicationState, Mode, ServerStage",
            "from sanic.asgi import ASGIApp",
            "from sanic.base.root import BaseSanic",
            "from sanic.blueprint_group import BlueprintGroup",
            "from sanic.blueprints import Blueprint",
            "from sanic.compat import OS_IS_WINDOWS, enable_windows_color_support",
            "from sanic.config import SANIC_PREFIX, Config",
            "from sanic.exceptions import (",
            "    BadRequest,",
            "    SanicException,",
            "    ServerError,",
            "    URLBuildError,",
            ")",
            "from sanic.handlers import ErrorHandler",
            "from sanic.helpers import _default",
            "from sanic.http import Stage",
            "from sanic.log import (",
            "    LOGGING_CONFIG_DEFAULTS,",
            "    deprecation,",
            "    error_logger,",
            "    logger,",
            ")",
            "from sanic.mixins.listeners import ListenerEvent",
            "from sanic.mixins.runner import RunnerMixin",
            "from sanic.models.futures import (",
            "    FutureException,",
            "    FutureListener,",
            "    FutureMiddleware,",
            "    FutureRegistry,",
            "    FutureRoute,",
            "    FutureSignal,",
            "    FutureStatic,",
            ")",
            "from sanic.models.handler_types import ListenerType, MiddlewareType",
            "from sanic.models.handler_types import Sanic as SanicVar",
            "from sanic.request import Request",
            "from sanic.response import BaseHTTPResponse, HTTPResponse, ResponseStream",
            "from sanic.router import Router",
            "from sanic.server.websockets.impl import ConnectionClosed",
            "from sanic.signals import Signal, SignalRouter",
            "from sanic.touchup import TouchUp, TouchUpMeta",
            "",
            "",
            "if TYPE_CHECKING:",
            "    try:",
            "        from sanic_ext import Extend  # type: ignore",
            "        from sanic_ext.extensions.base import Extension  # type: ignore",
            "    except ImportError:",
            "        Extend = TypeVar(\"Extend\", Type)  # type: ignore",
            "",
            "",
            "if OS_IS_WINDOWS:  # no cov",
            "    enable_windows_color_support()",
            "",
            "filterwarnings(\"once\", category=DeprecationWarning)",
            "",
            "",
            "class Sanic(BaseSanic, RunnerMixin, metaclass=TouchUpMeta):",
            "    \"\"\"",
            "    The main application instance",
            "    \"\"\"",
            "",
            "    __touchup__ = (",
            "        \"handle_request\",",
            "        \"handle_exception\",",
            "        \"_run_response_middleware\",",
            "        \"_run_request_middleware\",",
            "    )",
            "    __slots__ = (",
            "        \"_asgi_app\",",
            "        \"_asgi_client\",",
            "        \"_blueprint_order\",",
            "        \"_delayed_tasks\",",
            "        \"_ext\",",
            "        \"_future_exceptions\",",
            "        \"_future_listeners\",",
            "        \"_future_middleware\",",
            "        \"_future_registry\",",
            "        \"_future_routes\",",
            "        \"_future_signals\",",
            "        \"_future_statics\",",
            "        \"_state\",",
            "        \"_task_registry\",",
            "        \"_test_client\",",
            "        \"_test_manager\",",
            "        \"blueprints\",",
            "        \"config\",",
            "        \"configure_logging\",",
            "        \"ctx\",",
            "        \"error_handler\",",
            "        \"go_fast\",",
            "        \"listeners\",",
            "        \"named_request_middleware\",",
            "        \"named_response_middleware\",",
            "        \"request_class\",",
            "        \"request_middleware\",",
            "        \"response_middleware\",",
            "        \"router\",",
            "        \"signal_router\",",
            "        \"sock\",",
            "        \"strict_slashes\",",
            "        \"websocket_enabled\",",
            "        \"websocket_tasks\",",
            "    )",
            "",
            "    _app_registry: Dict[str, \"Sanic\"] = {}",
            "    _uvloop_setting = None  # TODO: Remove in v22.6",
            "    test_mode = False",
            "",
            "    def __init__(",
            "        self,",
            "        name: str = None,",
            "        config: Optional[Config] = None,",
            "        ctx: Optional[Any] = None,",
            "        router: Optional[Router] = None,",
            "        signal_router: Optional[SignalRouter] = None,",
            "        error_handler: Optional[ErrorHandler] = None,",
            "        env_prefix: Optional[str] = SANIC_PREFIX,",
            "        request_class: Optional[Type[Request]] = None,",
            "        strict_slashes: bool = False,",
            "        log_config: Optional[Dict[str, Any]] = None,",
            "        configure_logging: bool = True,",
            "        dumps: Optional[Callable[..., AnyStr]] = None,",
            "        loads: Optional[Callable[..., Any]] = None,",
            "    ) -> None:",
            "        super().__init__(name=name)",
            "",
            "        # logging",
            "        if configure_logging:",
            "            dict_config = log_config or LOGGING_CONFIG_DEFAULTS",
            "            logging.config.dictConfig(dict_config)  # type: ignore",
            "",
            "        if config and env_prefix != SANIC_PREFIX:",
            "            raise SanicException(",
            "                \"When instantiating Sanic with config, you cannot also pass \"",
            "                \"env_prefix\"",
            "            )",
            "",
            "        # First setup config",
            "        self.config: Config = config or Config(env_prefix=env_prefix)",
            "",
            "        # Then we can do the rest",
            "        self._asgi_client: Any = None",
            "        self._blueprint_order: List[Blueprint] = []",
            "        self._delayed_tasks: List[str] = []",
            "        self._future_registry: FutureRegistry = FutureRegistry()",
            "        self._state: ApplicationState = ApplicationState(app=self)",
            "        self._task_registry: Dict[str, Task] = {}",
            "        self._test_client: Any = None",
            "        self._test_manager: Any = None",
            "        self.asgi = False",
            "        self.auto_reload = False",
            "        self.blueprints: Dict[str, Blueprint] = {}",
            "        self.configure_logging: bool = configure_logging",
            "        self.ctx: Any = ctx or SimpleNamespace()",
            "        self.error_handler: ErrorHandler = error_handler or ErrorHandler()",
            "        self.listeners: Dict[str, List[ListenerType[Any]]] = defaultdict(list)",
            "        self.named_request_middleware: Dict[str, Deque[MiddlewareType]] = {}",
            "        self.named_response_middleware: Dict[str, Deque[MiddlewareType]] = {}",
            "        self.request_class: Type[Request] = request_class or Request",
            "        self.request_middleware: Deque[MiddlewareType] = deque()",
            "        self.response_middleware: Deque[MiddlewareType] = deque()",
            "        self.router: Router = router or Router()",
            "        self.signal_router: SignalRouter = signal_router or SignalRouter()",
            "        self.sock: Optional[socket] = None",
            "        self.strict_slashes: bool = strict_slashes",
            "        self.websocket_enabled: bool = False",
            "        self.websocket_tasks: Set[Future[Any]] = set()",
            "",
            "        # Register alternative method names",
            "        self.go_fast = self.run",
            "        self.router.ctx.app = self",
            "        self.signal_router.ctx.app = self",
            "        self.__class__.register_app(self)",
            "",
            "        if dumps:",
            "            BaseHTTPResponse._dumps = dumps  # type: ignore",
            "        if loads:",
            "            Request._loads = loads  # type: ignore",
            "",
            "    @property",
            "    def loop(self):",
            "        \"\"\"",
            "        Synonymous with asyncio.get_event_loop().",
            "",
            "        .. note::",
            "",
            "            Only supported when using the `app.run` method.",
            "        \"\"\"",
            "        if self.state.stage is ServerStage.STOPPED and self.asgi is False:",
            "            raise SanicException(",
            "                \"Loop can only be retrieved after the app has started \"",
            "                \"running. Not supported with `create_server` function\"",
            "            )",
            "        try:",
            "            return get_running_loop()",
            "        except RuntimeError:",
            "            if sys.version_info > (3, 10):",
            "                return asyncio.get_event_loop_policy().get_event_loop()",
            "            else:",
            "                return asyncio.get_event_loop()",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Registration",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def register_listener(",
            "        self, listener: ListenerType[SanicVar], event: str",
            "    ) -> ListenerType[SanicVar]:",
            "        \"\"\"",
            "        Register the listener for a given event.",
            "",
            "        :param listener: callable i.e. setup_db(app, loop)",
            "        :param event: when to register listener i.e. 'before_server_start'",
            "        :return: listener",
            "        \"\"\"",
            "",
            "        try:",
            "            _event = ListenerEvent[event.upper()]",
            "        except (ValueError, AttributeError):",
            "            valid = \", \".join(",
            "                map(lambda x: x.lower(), ListenerEvent.__members__.keys())",
            "            )",
            "            raise BadRequest(f\"Invalid event: {event}. Use one of: {valid}\")",
            "",
            "        if \".\" in _event:",
            "            self.signal(_event.value)(",
            "                partial(self._listener, listener=listener)",
            "            )",
            "        else:",
            "            self.listeners[_event.value].append(listener)",
            "",
            "        return listener",
            "",
            "    def register_middleware(",
            "        self, middleware: MiddlewareType, attach_to: str = \"request\"",
            "    ) -> MiddlewareType:",
            "        \"\"\"",
            "        Register an application level middleware that will be attached",
            "        to all the API URLs registered under this application.",
            "",
            "        This method is internally invoked by the :func:`middleware`",
            "        decorator provided at the app level.",
            "",
            "        :param middleware: Callback method to be attached to the",
            "            middleware",
            "        :param attach_to: The state at which the middleware needs to be",
            "            invoked in the lifecycle of an *HTTP Request*.",
            "            **request** - Invoke before the request is processed",
            "            **response** - Invoke before the response is returned back",
            "        :return: decorated method",
            "        \"\"\"",
            "        if attach_to == \"request\":",
            "            if middleware not in self.request_middleware:",
            "                self.request_middleware.append(middleware)",
            "        if attach_to == \"response\":",
            "            if middleware not in self.response_middleware:",
            "                self.response_middleware.appendleft(middleware)",
            "        return middleware",
            "",
            "    def register_named_middleware(",
            "        self,",
            "        middleware: MiddlewareType,",
            "        route_names: Iterable[str],",
            "        attach_to: str = \"request\",",
            "    ):",
            "        \"\"\"",
            "        Method for attaching middleware to specific routes. This is mainly an",
            "        internal tool for use by Blueprints to attach middleware to only its",
            "        specific routes. But, it could be used in a more generalized fashion.",
            "",
            "        :param middleware: the middleware to execute",
            "        :param route_names: a list of the names of the endpoints",
            "        :type route_names: Iterable[str]",
            "        :param attach_to: whether to attach to request or response,",
            "            defaults to \"request\"",
            "        :type attach_to: str, optional",
            "        \"\"\"",
            "        if attach_to == \"request\":",
            "            for _rn in route_names:",
            "                if _rn not in self.named_request_middleware:",
            "                    self.named_request_middleware[_rn] = deque()",
            "                if middleware not in self.named_request_middleware[_rn]:",
            "                    self.named_request_middleware[_rn].append(middleware)",
            "        if attach_to == \"response\":",
            "            for _rn in route_names:",
            "                if _rn not in self.named_response_middleware:",
            "                    self.named_response_middleware[_rn] = deque()",
            "                if middleware not in self.named_response_middleware[_rn]:",
            "                    self.named_response_middleware[_rn].appendleft(middleware)",
            "        return middleware",
            "",
            "    def _apply_exception_handler(",
            "        self,",
            "        handler: FutureException,",
            "        route_names: Optional[List[str]] = None,",
            "    ):",
            "        \"\"\"Decorate a function to be registered as a handler for exceptions",
            "",
            "        :param exceptions: exceptions",
            "        :return: decorated function",
            "        \"\"\"",
            "",
            "        for exception in handler.exceptions:",
            "            if isinstance(exception, (tuple, list)):",
            "                for e in exception:",
            "                    self.error_handler.add(e, handler.handler, route_names)",
            "            else:",
            "                self.error_handler.add(exception, handler.handler, route_names)",
            "        return handler.handler",
            "",
            "    def _apply_listener(self, listener: FutureListener):",
            "        return self.register_listener(listener.listener, listener.event)",
            "",
            "    def _apply_route(self, route: FutureRoute) -> List[Route]:",
            "        params = route._asdict()",
            "        websocket = params.pop(\"websocket\", False)",
            "        subprotocols = params.pop(\"subprotocols\", None)",
            "",
            "        if websocket:",
            "            self.enable_websocket()",
            "            websocket_handler = partial(",
            "                self._websocket_handler,",
            "                route.handler,",
            "                subprotocols=subprotocols,",
            "            )",
            "            websocket_handler.__name__ = route.handler.__name__  # type: ignore",
            "            websocket_handler.is_websocket = True  # type: ignore",
            "            params[\"handler\"] = websocket_handler",
            "",
            "        ctx = params.pop(\"route_context\")",
            "",
            "        routes = self.router.add(**params)",
            "        if isinstance(routes, Route):",
            "            routes = [routes]",
            "",
            "        for r in routes:",
            "            r.ctx.websocket = websocket",
            "            r.ctx.static = params.get(\"static\", False)",
            "            r.ctx.__dict__.update(ctx)",
            "",
            "        return routes",
            "",
            "    def _apply_static(self, static: FutureStatic) -> Route:",
            "        return self._register_static(static)",
            "",
            "    def _apply_middleware(",
            "        self,",
            "        middleware: FutureMiddleware,",
            "        route_names: Optional[List[str]] = None,",
            "    ):",
            "        if route_names:",
            "            return self.register_named_middleware(",
            "                middleware.middleware, route_names, middleware.attach_to",
            "            )",
            "        else:",
            "            return self.register_middleware(",
            "                middleware.middleware, middleware.attach_to",
            "            )",
            "",
            "    def _apply_signal(self, signal: FutureSignal) -> Signal:",
            "        return self.signal_router.add(*signal)",
            "",
            "    def dispatch(",
            "        self,",
            "        event: str,",
            "        *,",
            "        condition: Optional[Dict[str, str]] = None,",
            "        context: Optional[Dict[str, Any]] = None,",
            "        fail_not_found: bool = True,",
            "        inline: bool = False,",
            "        reverse: bool = False,",
            "    ) -> Coroutine[Any, Any, Awaitable[Any]]:",
            "        return self.signal_router.dispatch(",
            "            event,",
            "            context=context,",
            "            condition=condition,",
            "            inline=inline,",
            "            reverse=reverse,",
            "            fail_not_found=fail_not_found,",
            "        )",
            "",
            "    async def event(",
            "        self, event: str, timeout: Optional[Union[int, float]] = None",
            "    ):",
            "        signal = self.signal_router.name_index.get(event)",
            "        if not signal:",
            "            if self.config.EVENT_AUTOREGISTER:",
            "                self.signal_router.reset()",
            "                self.add_signal(None, event)",
            "                signal = self.signal_router.name_index[event]",
            "                self.signal_router.finalize()",
            "            else:",
            "                raise NotFound(\"Could not find signal %s\" % event)",
            "        return await wait_for(signal.ctx.event.wait(), timeout=timeout)",
            "",
            "    def enable_websocket(self, enable=True):",
            "        \"\"\"Enable or disable the support for websocket.",
            "",
            "        Websocket is enabled automatically if websocket routes are",
            "        added to the application.",
            "        \"\"\"",
            "        if not self.websocket_enabled:",
            "            # if the server is stopped, we want to cancel any ongoing",
            "            # websocket tasks, to allow the server to exit promptly",
            "            self.listener(\"before_server_stop\")(self._cancel_websocket_tasks)",
            "",
            "        self.websocket_enabled = enable",
            "",
            "    def blueprint(",
            "        self,",
            "        blueprint: Union[",
            "            Blueprint, List[Blueprint], Tuple[Blueprint], BlueprintGroup",
            "        ],",
            "        **options: Any,",
            "    ):",
            "        \"\"\"Register a blueprint on the application.",
            "",
            "        :param blueprint: Blueprint object or (list, tuple) thereof",
            "        :param options: option dictionary with blueprint defaults",
            "        :return: Nothing",
            "        \"\"\"",
            "        if isinstance(blueprint, (list, tuple, BlueprintGroup)):",
            "            for item in blueprint:",
            "                params = {**options}",
            "                if isinstance(blueprint, BlueprintGroup):",
            "                    if blueprint.url_prefix:",
            "                        merge_from = [",
            "                            options.get(\"url_prefix\", \"\"),",
            "                            blueprint.url_prefix,",
            "                        ]",
            "                        if not isinstance(item, BlueprintGroup):",
            "                            merge_from.append(item.url_prefix or \"\")",
            "                        merged_prefix = \"/\".join(",
            "                            u.strip(\"/\") for u in merge_from",
            "                        ).rstrip(\"/\")",
            "                        params[\"url_prefix\"] = f\"/{merged_prefix}\"",
            "",
            "                    for _attr in [\"version\", \"strict_slashes\"]:",
            "                        if getattr(item, _attr) is None:",
            "                            params[_attr] = getattr(",
            "                                blueprint, _attr",
            "                            ) or options.get(_attr)",
            "                    if item.version_prefix == \"/v\":",
            "                        if blueprint.version_prefix == \"/v\":",
            "                            params[\"version_prefix\"] = options.get(",
            "                                \"version_prefix\"",
            "                            )",
            "                        else:",
            "                            params[\"version_prefix\"] = blueprint.version_prefix",
            "                self.blueprint(item, **params)",
            "            return",
            "        if blueprint.name in self.blueprints:",
            "            assert self.blueprints[blueprint.name] is blueprint, (",
            "                'A blueprint with the name \"%s\" is already registered.  '",
            "                \"Blueprint names must be unique.\" % (blueprint.name,)",
            "            )",
            "        else:",
            "            self.blueprints[blueprint.name] = blueprint",
            "            self._blueprint_order.append(blueprint)",
            "",
            "        if (",
            "            self.strict_slashes is not None",
            "            and blueprint.strict_slashes is None",
            "        ):",
            "            blueprint.strict_slashes = self.strict_slashes",
            "        blueprint.register(self, options)",
            "",
            "    def url_for(self, view_name: str, **kwargs):",
            "        \"\"\"Build a URL based on a view name and the values provided.",
            "",
            "        In order to build a URL, all request parameters must be supplied as",
            "        keyword arguments, and each parameter must pass the test for the",
            "        specified parameter type. If these conditions are not met, a",
            "        `URLBuildError` will be thrown.",
            "",
            "        Keyword arguments that are not request parameters will be included in",
            "        the output URL's query string.",
            "",
            "        There are several _special_ keyword arguments that will alter how the",
            "        URL will be returned:",
            "",
            "        1. **_anchor**: ``str`` - Adds an ``#anchor`` to the end",
            "        2. **_scheme**: ``str`` - Should be either ``\"http\"`` or ``\"https\"``,",
            "           default is ``\"http\"``",
            "        3. **_external**: ``bool`` - Whether to return the path or a full URL",
            "           with scheme and host",
            "        4. **_host**: ``str`` - Used when one or more hosts are defined for a",
            "           route to tell Sanic which to use",
            "           (only applies with ``_external=True``)",
            "        5. **_server**: ``str`` - If not using ``_host``, this will be used",
            "           for defining the hostname of the URL",
            "           (only applies with ``_external=True``),",
            "           defaults to ``app.config.SERVER_NAME``",
            "",
            "        If you want the PORT to appear in your URL, you should set it in:",
            "",
            "        .. code-block::",
            "",
            "            app.config.SERVER_NAME = \"myserver:7777\"",
            "",
            "        `See user guide re: routing",
            "        <https://sanicframework.org/guide/basics/routing.html#generating-a-url>`__",
            "",
            "        :param view_name: string referencing the view name",
            "        :param kwargs: keys and values that are used to build request",
            "            parameters and query string arguments.",
            "",
            "        :return: the built URL",
            "",
            "        Raises:",
            "            URLBuildError",
            "        \"\"\"",
            "        # find the route by the supplied view name",
            "        kw: Dict[str, str] = {}",
            "        # special static files url_for",
            "",
            "        if \".\" not in view_name:",
            "            view_name = f\"{self.name}.{view_name}\"",
            "",
            "        if view_name.endswith(\".static\"):",
            "            name = kwargs.pop(\"name\", None)",
            "            if name:",
            "                view_name = view_name.replace(\"static\", name)",
            "            kw.update(name=view_name)",
            "",
            "        route = self.router.find_route_by_view_name(view_name, **kw)",
            "        if not route:",
            "            raise URLBuildError(",
            "                f\"Endpoint with name `{view_name}` was not found\"",
            "            )",
            "",
            "        uri = route.path",
            "",
            "        if getattr(route.ctx, \"static\", None):",
            "            filename = kwargs.pop(\"filename\", \"\")",
            "            # it's static folder",
            "            if \"__file_uri__\" in uri:",
            "                folder_ = uri.split(\"<__file_uri__:\", 1)[0]",
            "                if folder_.endswith(\"/\"):",
            "                    folder_ = folder_[:-1]",
            "",
            "                if filename.startswith(\"/\"):",
            "                    filename = filename[1:]",
            "",
            "                kwargs[\"__file_uri__\"] = filename",
            "",
            "        if (",
            "            uri != \"/\"",
            "            and uri.endswith(\"/\")",
            "            and not route.strict",
            "            and not route.raw_path[:-1]",
            "        ):",
            "            uri = uri[:-1]",
            "",
            "        if not uri.startswith(\"/\"):",
            "            uri = f\"/{uri}\"",
            "",
            "        out = uri",
            "",
            "        # _method is only a placeholder now, don't know how to support it",
            "        kwargs.pop(\"_method\", None)",
            "        anchor = kwargs.pop(\"_anchor\", \"\")",
            "        # _external need SERVER_NAME in config or pass _server arg",
            "        host = kwargs.pop(\"_host\", None)",
            "        external = kwargs.pop(\"_external\", False) or bool(host)",
            "        scheme = kwargs.pop(\"_scheme\", \"\")",
            "        if route.ctx.hosts and external:",
            "            if not host and len(route.ctx.hosts) > 1:",
            "                raise ValueError(",
            "                    f\"Host is ambiguous: {', '.join(route.ctx.hosts)}\"",
            "                )",
            "            elif host and host not in route.ctx.hosts:",
            "                raise ValueError(",
            "                    f\"Requested host ({host}) is not available for this \"",
            "                    f\"route: {route.ctx.hosts}\"",
            "                )",
            "            elif not host:",
            "                host = list(route.ctx.hosts)[0]",
            "",
            "        if scheme and not external:",
            "            raise ValueError(\"When specifying _scheme, _external must be True\")",
            "",
            "        netloc = kwargs.pop(\"_server\", None)",
            "        if netloc is None and external:",
            "            netloc = host or self.config.get(\"SERVER_NAME\", \"\")",
            "",
            "        if external:",
            "            if not scheme:",
            "                if \":\" in netloc[:8]:",
            "                    scheme = netloc[:8].split(\":\", 1)[0]",
            "                else:",
            "                    scheme = \"http\"",
            "",
            "            if \"://\" in netloc[:8]:",
            "                netloc = netloc.split(\"://\", 1)[-1]",
            "",
            "        # find all the parameters we will need to build in the URL",
            "        # matched_params = re.findall(self.router.parameter_pattern, uri)",
            "        route.finalize()",
            "        for param_info in route.params.values():",
            "            # name, _type, pattern = self.router.parse_parameter_string(match)",
            "            # we only want to match against each individual parameter",
            "",
            "            try:",
            "                supplied_param = str(kwargs.pop(param_info.name))",
            "            except KeyError:",
            "                raise URLBuildError(",
            "                    f\"Required parameter `{param_info.name}` was not \"",
            "                    \"passed to url_for\"",
            "                )",
            "",
            "            # determine if the parameter supplied by the caller",
            "            # passes the test in the URL",
            "            if param_info.pattern:",
            "                pattern = (",
            "                    param_info.pattern[1]",
            "                    if isinstance(param_info.pattern, tuple)",
            "                    else param_info.pattern",
            "                )",
            "                passes_pattern = pattern.match(supplied_param)",
            "                if not passes_pattern:",
            "                    if param_info.cast != str:",
            "                        msg = (",
            "                            f'Value \"{supplied_param}\" '",
            "                            f\"for parameter `{param_info.name}` does \"",
            "                            \"not match pattern for type \"",
            "                            f\"`{param_info.cast.__name__}`: \"",
            "                            f\"{pattern.pattern}\"",
            "                        )",
            "                    else:",
            "                        msg = (",
            "                            f'Value \"{supplied_param}\" for parameter '",
            "                            f\"`{param_info.name}` does not satisfy \"",
            "                            f\"pattern {pattern.pattern}\"",
            "                        )",
            "                    raise URLBuildError(msg)",
            "",
            "            # replace the parameter in the URL with the supplied value",
            "            replacement_regex = f\"(<{param_info.name}.*?>)\"",
            "            out = re.sub(replacement_regex, supplied_param, out)",
            "",
            "        # parse the remainder of the keyword arguments into a querystring",
            "        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"",
            "        # scheme://netloc/path;parameters?query#fragment",
            "        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))",
            "",
            "        return out",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Request Handling",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def handle_exception(",
            "        self, request: Request, exception: BaseException",
            "    ):  # no cov",
            "        \"\"\"",
            "        A handler that catches specific exceptions and outputs a response.",
            "",
            "        :param request: The current request object",
            "        :param exception: The exception that was raised",
            "        :raises ServerError: response 500",
            "        \"\"\"",
            "        await self.dispatch(",
            "            \"http.lifecycle.exception\",",
            "            inline=True,",
            "            context={\"request\": request, \"exception\": exception},",
            "        )",
            "",
            "        if (",
            "            request.stream is not None",
            "            and request.stream.stage is not Stage.HANDLER",
            "        ):",
            "            error_logger.exception(exception, exc_info=True)",
            "            logger.error(",
            "                \"The error response will not be sent to the client for \"",
            "                f'the following exception:\"{exception}\". A previous response '",
            "                \"has at least partially been sent.\"",
            "            )",
            "",
            "            handler = self.error_handler._lookup(",
            "                exception, request.name if request else None",
            "            )",
            "            if handler:",
            "                logger.warning(",
            "                    \"An error occurred while handling the request after at \"",
            "                    \"least some part of the response was sent to the client. \"",
            "                    \"The response from your custom exception handler \"",
            "                    f\"{handler.__name__} will not be sent to the client.\"",
            "                    \"Exception handlers should only be used to generate the \"",
            "                    \"exception responses. If you would like to perform any \"",
            "                    \"other action on a raised exception, consider using a \"",
            "                    \"signal handler like \"",
            "                    '`@app.signal(\"http.lifecycle.exception\")`\\n'",
            "                    \"For further information, please see the docs: \"",
            "                    \"https://sanicframework.org/en/guide/advanced/\"",
            "                    \"signals.html\",",
            "                )",
            "            return",
            "",
            "        # -------------------------------------------- #",
            "        # Request Middleware",
            "        # -------------------------------------------- #",
            "        response = await self._run_request_middleware(",
            "            request, request_name=None",
            "        )",
            "        # No middleware results",
            "        if not response:",
            "            try:",
            "                response = self.error_handler.response(request, exception)",
            "                if isawaitable(response):",
            "                    response = await response",
            "            except Exception as e:",
            "                if isinstance(e, SanicException):",
            "                    response = self.error_handler.default(request, e)",
            "                elif self.debug:",
            "                    response = HTTPResponse(",
            "                        (",
            "                            f\"Error while handling error: {e}\\n\"",
            "                            f\"Stack: {format_exc()}\"",
            "                        ),",
            "                        status=500,",
            "                    )",
            "                else:",
            "                    response = HTTPResponse(",
            "                        \"An error occurred while handling an error\", status=500",
            "                    )",
            "        if response is not None:",
            "            try:",
            "                request.reset_response()",
            "                response = await request.respond(response)",
            "            except BaseException:",
            "                # Skip response middleware",
            "                if request.stream:",
            "                    request.stream.respond(response)",
            "                await response.send(end_stream=True)",
            "                raise",
            "        else:",
            "            if request.stream:",
            "                response = request.stream.response",
            "",
            "        # Marked for cleanup and DRY with handle_request/handle_exception",
            "        # when ResponseStream is no longer supporder",
            "        if isinstance(response, BaseHTTPResponse):",
            "            await self.dispatch(",
            "                \"http.lifecycle.response\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"response\": response,",
            "                },",
            "            )",
            "            await response.send(end_stream=True)",
            "        elif isinstance(response, ResponseStream):",
            "            resp = await response(request)",
            "            await self.dispatch(",
            "                \"http.lifecycle.response\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"response\": resp,",
            "                },",
            "            )",
            "            await response.eof()",
            "        else:",
            "            raise ServerError(",
            "                f\"Invalid response type {response!r} (need HTTPResponse)\"",
            "            )",
            "",
            "    async def handle_request(self, request: Request):  # no cov",
            "        \"\"\"Take a request from the HTTP Server and return a response object",
            "        to be sent back The HTTP Server only expects a response object, so",
            "        exception handling must be done here",
            "",
            "        :param request: HTTP Request object",
            "        :return: Nothing",
            "        \"\"\"",
            "        await self.dispatch(",
            "            \"http.lifecycle.handle\",",
            "            inline=True,",
            "            context={\"request\": request},",
            "        )",
            "",
            "        # Define `response` var here to remove warnings about",
            "        # allocation before assignment below.",
            "        response = None",
            "        try:",
            "",
            "            await self.dispatch(",
            "                \"http.routing.before\",",
            "                inline=True,",
            "                context={\"request\": request},",
            "            )",
            "            # Fetch handler from router",
            "            route, handler, kwargs = self.router.get(",
            "                request.path,",
            "                request.method,",
            "                request.headers.getone(\"host\", None),",
            "            )",
            "",
            "            request._match_info = {**kwargs}",
            "            request.route = route",
            "",
            "            await self.dispatch(",
            "                \"http.routing.after\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"route\": route,",
            "                    \"kwargs\": kwargs,",
            "                    \"handler\": handler,",
            "                },",
            "            )",
            "",
            "            if (",
            "                request.stream",
            "                and request.stream.request_body",
            "                and not route.ctx.ignore_body",
            "            ):",
            "",
            "                if hasattr(handler, \"is_stream\"):",
            "                    # Streaming handler: lift the size limit",
            "                    request.stream.request_max_size = float(\"inf\")",
            "                else:",
            "                    # Non-streaming handler: preload body",
            "                    await request.receive_body()",
            "",
            "            # -------------------------------------------- #",
            "            # Request Middleware",
            "            # -------------------------------------------- #",
            "            response = await self._run_request_middleware(",
            "                request, request_name=route.name",
            "            )",
            "",
            "            # No middleware results",
            "            if not response:",
            "                # -------------------------------------------- #",
            "                # Execute Handler",
            "                # -------------------------------------------- #",
            "",
            "                if handler is None:",
            "                    raise ServerError(",
            "                        (",
            "                            \"'None' was returned while requesting a \"",
            "                            \"handler from the router\"",
            "                        )",
            "                    )",
            "",
            "                # Run response handler",
            "                response = handler(request, **request.match_info)",
            "                if isawaitable(response):",
            "                    response = await response",
            "",
            "            if request.responded:",
            "                if response is not None:",
            "                    error_logger.error(",
            "                        \"The response object returned by the route handler \"",
            "                        \"will not be sent to client. The request has already \"",
            "                        \"been responded to.\"",
            "                    )",
            "                if request.stream is not None:",
            "                    response = request.stream.response",
            "            elif response is not None:",
            "                response = await request.respond(response)",
            "            elif not hasattr(handler, \"is_websocket\"):",
            "                response = request.stream.response  # type: ignore",
            "",
            "            # Marked for cleanup and DRY with handle_request/handle_exception",
            "            # when ResponseStream is no longer supporder",
            "            if isinstance(response, BaseHTTPResponse):",
            "                await self.dispatch(",
            "                    \"http.lifecycle.response\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": response,",
            "                    },",
            "                )",
            "                ...",
            "                await response.send(end_stream=True)",
            "            elif isinstance(response, ResponseStream):",
            "                resp = await response(request)",
            "                await self.dispatch(",
            "                    \"http.lifecycle.response\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": resp,",
            "                    },",
            "                )",
            "                await response.eof()",
            "            else:",
            "                if not hasattr(handler, \"is_websocket\"):",
            "                    raise ServerError(",
            "                        f\"Invalid response type {response!r} \"",
            "                        \"(need HTTPResponse)\"",
            "                    )",
            "",
            "        except CancelledError:",
            "            raise",
            "        except Exception as e:",
            "            # Response Generation Failed",
            "            await self.handle_exception(request, e)",
            "",
            "    async def _websocket_handler(",
            "        self, handler, request, *args, subprotocols=None, **kwargs",
            "    ):",
            "        if self.asgi:",
            "            ws = request.transport.get_websocket_connection()",
            "            await ws.accept(subprotocols)",
            "        else:",
            "            protocol = request.transport.get_protocol()",
            "            ws = await protocol.websocket_handshake(request, subprotocols)",
            "",
            "        # schedule the application handler",
            "        # its future is kept in self.websocket_tasks in case it",
            "        # needs to be cancelled due to the server being stopped",
            "        fut = ensure_future(handler(request, ws, *args, **kwargs))",
            "        self.websocket_tasks.add(fut)",
            "        cancelled = False",
            "        try:",
            "            await fut",
            "        except (CancelledError, ConnectionClosed):",
            "            cancelled = True",
            "        except Exception as e:",
            "            self.error_handler.log(request, e)",
            "        finally:",
            "            self.websocket_tasks.remove(fut)",
            "            if cancelled:",
            "                ws.end_connection(1000)",
            "            else:",
            "                await ws.close()",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Testing",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @property",
            "    def test_client(self):  # noqa",
            "        if self._test_client:",
            "            return self._test_client",
            "        elif self._test_manager:",
            "            return self._test_manager.test_client",
            "        from sanic_testing.testing import SanicTestClient  # type: ignore",
            "",
            "        self._test_client = SanicTestClient(self)",
            "        return self._test_client",
            "",
            "    @property",
            "    def asgi_client(self):  # noqa",
            "        \"\"\"",
            "        A testing client that uses ASGI to reach into the application to",
            "        execute hanlers.",
            "",
            "        :return: testing client",
            "        :rtype: :class:`SanicASGITestClient`",
            "        \"\"\"",
            "        if self._asgi_client:",
            "            return self._asgi_client",
            "        elif self._test_manager:",
            "            return self._test_manager.asgi_client",
            "        from sanic_testing.testing import SanicASGITestClient  # type: ignore",
            "",
            "        self._asgi_client = SanicASGITestClient(self)",
            "        return self._asgi_client",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Execution",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def _run_request_middleware(",
            "        self, request, request_name=None",
            "    ):  # no cov",
            "        # The if improves speed.  I don't know why",
            "        named_middleware = self.named_request_middleware.get(",
            "            request_name, deque()",
            "        )",
            "        applicable_middleware = self.request_middleware + named_middleware",
            "",
            "        # request.request_middleware_started is meant as a stop-gap solution",
            "        # until RFC 1630 is adopted",
            "        if applicable_middleware and not request.request_middleware_started:",
            "            request.request_middleware_started = True",
            "",
            "            for middleware in applicable_middleware:",
            "                await self.dispatch(",
            "                    \"http.middleware.before\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": None,",
            "                    },",
            "                    condition={\"attach_to\": \"request\"},",
            "                )",
            "",
            "                response = middleware(request)",
            "                if isawaitable(response):",
            "                    response = await response",
            "",
            "                await self.dispatch(",
            "                    \"http.middleware.after\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": None,",
            "                    },",
            "                    condition={\"attach_to\": \"request\"},",
            "                )",
            "",
            "                if response:",
            "                    return response",
            "        return None",
            "",
            "    async def _run_response_middleware(",
            "        self, request, response, request_name=None",
            "    ):  # no cov",
            "        named_middleware = self.named_response_middleware.get(",
            "            request_name, deque()",
            "        )",
            "        applicable_middleware = self.response_middleware + named_middleware",
            "        if applicable_middleware:",
            "            for middleware in applicable_middleware:",
            "                await self.dispatch(",
            "                    \"http.middleware.before\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": response,",
            "                    },",
            "                    condition={\"attach_to\": \"response\"},",
            "                )",
            "",
            "                _response = middleware(request, response)",
            "                if isawaitable(_response):",
            "                    _response = await _response",
            "",
            "                await self.dispatch(",
            "                    \"http.middleware.after\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": _response if _response else response,",
            "                    },",
            "                    condition={\"attach_to\": \"response\"},",
            "                )",
            "",
            "                if _response:",
            "                    response = _response",
            "                    if isinstance(response, BaseHTTPResponse):",
            "                        response = request.stream.respond(response)",
            "                    break",
            "        return response",
            "",
            "    def _build_endpoint_name(self, *parts):",
            "        parts = [self.name, *parts]",
            "        return \".\".join(parts)",
            "",
            "    @classmethod",
            "    def _cancel_websocket_tasks(cls, app, loop):",
            "        for task in app.websocket_tasks:",
            "            task.cancel()",
            "",
            "    @staticmethod",
            "    async def _listener(",
            "        app: Sanic, loop: AbstractEventLoop, listener: ListenerType",
            "    ):",
            "        try:",
            "            maybe_coro = listener(app)  # type: ignore",
            "        except TypeError:",
            "            maybe_coro = listener(app, loop)  # type: ignore",
            "        if maybe_coro and isawaitable(maybe_coro):",
            "            await maybe_coro",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Task management",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @classmethod",
            "    def _prep_task(",
            "        cls,",
            "        task,",
            "        app,",
            "        loop,",
            "    ):",
            "        if callable(task):",
            "            try:",
            "                task = task(app)",
            "            except TypeError:",
            "                task = task()",
            "",
            "        return task",
            "",
            "    @classmethod",
            "    def _loop_add_task(",
            "        cls,",
            "        task,",
            "        app,",
            "        loop,",
            "        *,",
            "        name: Optional[str] = None,",
            "        register: bool = True,",
            "    ) -> Task:",
            "        if not isinstance(task, Future):",
            "            prepped = cls._prep_task(task, app, loop)",
            "            if sys.version_info < (3, 8):  # no cov",
            "                task = loop.create_task(prepped)",
            "                if name:",
            "                    error_logger.warning(",
            "                        \"Cannot set a name for a task when using Python 3.7. \"",
            "                        \"Your task will be created without a name.\"",
            "                    )",
            "                task.get_name = lambda: name",
            "            else:",
            "                task = loop.create_task(prepped, name=name)",
            "",
            "        if name and register and sys.version_info > (3, 7):",
            "            app._task_registry[name] = task",
            "",
            "        return task",
            "",
            "    @staticmethod",
            "    async def dispatch_delayed_tasks(app, loop):",
            "        for name in app._delayed_tasks:",
            "            await app.dispatch(name, context={\"app\": app, \"loop\": loop})",
            "        app._delayed_tasks.clear()",
            "",
            "    @staticmethod",
            "    async def run_delayed_task(app, loop, task):",
            "        prepped = app._prep_task(task, app, loop)",
            "        await prepped",
            "",
            "    def add_task(",
            "        self,",
            "        task: Union[Future[Any], Coroutine[Any, Any, Any], Awaitable[Any]],",
            "        *,",
            "        name: Optional[str] = None,",
            "        register: bool = True,",
            "    ) -> Optional[Task]:",
            "        \"\"\"",
            "        Schedule a task to run later, after the loop has started.",
            "        Different from asyncio.ensure_future in that it does not",
            "        also return a future, and the actual ensure_future call",
            "        is delayed until before server start.",
            "",
            "        `See user guide re: background tasks",
            "        <https://sanicframework.org/guide/basics/tasks.html#background-tasks>`__",
            "",
            "        :param task: future, couroutine or awaitable",
            "        \"\"\"",
            "        try:",
            "            loop = self.loop  # Will raise SanicError if loop is not started",
            "            return self._loop_add_task(",
            "                task, self, loop, name=name, register=register",
            "            )",
            "        except SanicException:",
            "            task_name = f\"sanic.delayed_task.{hash(task)}\"",
            "            if not self._delayed_tasks:",
            "                self.after_server_start(partial(self.dispatch_delayed_tasks))",
            "",
            "            if name:",
            "                raise RuntimeError(",
            "                    \"Cannot name task outside of a running application\"",
            "                )",
            "",
            "            self.signal(task_name)(partial(self.run_delayed_task, task=task))",
            "            self._delayed_tasks.append(task_name)",
            "            return None",
            "",
            "    def get_task(",
            "        self, name: str, *, raise_exception: bool = True",
            "    ) -> Optional[Task]:",
            "        try:",
            "            return self._task_registry[name]",
            "        except KeyError:",
            "            if raise_exception:",
            "                raise SanicException(",
            "                    f'Registered task named \"{name}\" not found.'",
            "                )",
            "            return None",
            "",
            "    async def cancel_task(",
            "        self,",
            "        name: str,",
            "        msg: Optional[str] = None,",
            "        *,",
            "        raise_exception: bool = True,",
            "    ) -> None:",
            "        task = self.get_task(name, raise_exception=raise_exception)",
            "        if task and not task.cancelled():",
            "            args: Tuple[str, ...] = ()",
            "            if msg:",
            "                if sys.version_info >= (3, 9):",
            "                    args = (msg,)",
            "                else:  # no cov",
            "                    raise RuntimeError(",
            "                        \"Cancelling a task with a message is only supported \"",
            "                        \"on Python 3.9+.\"",
            "                    )",
            "            task.cancel(*args)",
            "            try:",
            "                await task",
            "            except CancelledError:",
            "                ...",
            "",
            "    def purge_tasks(self):",
            "        for key, task in self._task_registry.items():",
            "            if task.done() or task.cancelled():",
            "                self._task_registry[key] = None",
            "",
            "        self._task_registry = {",
            "            k: v for k, v in self._task_registry.items() if v is not None",
            "        }",
            "",
            "    def shutdown_tasks(",
            "        self, timeout: Optional[float] = None, increment: float = 0.1",
            "    ):",
            "        for task in self.tasks:",
            "            if task.get_name() != \"RunServer\":",
            "                task.cancel()",
            "",
            "        if timeout is None:",
            "            timeout = self.config.GRACEFUL_SHUTDOWN_TIMEOUT",
            "",
            "        while len(self._task_registry) and timeout:",
            "            with suppress(RuntimeError):",
            "                running_loop = get_running_loop()",
            "                running_loop.run_until_complete(asyncio.sleep(increment))",
            "            self.purge_tasks()",
            "            timeout -= increment",
            "",
            "    @property",
            "    def tasks(self):",
            "        return iter(self._task_registry.values())",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # ASGI",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def __call__(self, scope, receive, send):",
            "        \"\"\"",
            "        To be ASGI compliant, our instance must be a callable that accepts",
            "        three arguments: scope, receive, send. See the ASGI reference for more",
            "        details: https://asgi.readthedocs.io/en/latest",
            "        \"\"\"",
            "        self.asgi = True",
            "        if scope[\"type\"] == \"lifespan\":",
            "            self.motd(\"\")",
            "        self._asgi_app = await ASGIApp.create(self, scope, receive, send)",
            "        asgi_app = self._asgi_app",
            "        await asgi_app()",
            "",
            "    _asgi_single_callable = True  # We conform to ASGI 3.0 single-callable",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Configuration",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def update_config(self, config: Union[bytes, str, dict, Any]):",
            "        \"\"\"",
            "        Update app.config. Full implementation can be found in the user guide.",
            "",
            "        `See user guide re: configuration",
            "        <https://sanicframework.org/guide/deployment/configuration.html#basics>`__",
            "        \"\"\"",
            "",
            "        self.config.update_config(config)",
            "",
            "    @property",
            "    def asgi(self):",
            "        return self.state.asgi",
            "",
            "    @asgi.setter",
            "    def asgi(self, value: bool):",
            "        self.state.asgi = value",
            "",
            "    @property",
            "    def debug(self):",
            "        return self.state.is_debug",
            "",
            "    @debug.setter",
            "    def debug(self, value: bool):",
            "        deprecation(",
            "            \"Setting the value of a Sanic application's debug value directly \"",
            "            \"is deprecated and will be removed in v22.9. Please set it using \"",
            "            \"the CLI, app.run, app.prepare, or directly set \"",
            "            \"app.state.mode to Mode.DEBUG.\",",
            "            22.9,",
            "        )",
            "        mode = Mode.DEBUG if value else Mode.PRODUCTION",
            "        self.state.mode = mode",
            "",
            "    @property",
            "    def auto_reload(self):",
            "        return self.config.AUTO_RELOAD",
            "",
            "    @auto_reload.setter",
            "    def auto_reload(self, value: bool):",
            "        self.config.AUTO_RELOAD = value",
            "",
            "    @property",
            "    def state(self) -> ApplicationState:  # type: ignore",
            "        \"\"\"",
            "        :return: The application state",
            "        \"\"\"",
            "        return self._state",
            "",
            "    @property",
            "    def is_running(self):",
            "        deprecation(",
            "            \"Use of the is_running property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        return self.state.is_running",
            "",
            "    @is_running.setter",
            "    def is_running(self, value: bool):",
            "        deprecation(",
            "            \"Use of the is_running property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        self.state.is_running = value",
            "",
            "    @property",
            "    def is_stopping(self):",
            "        deprecation(",
            "            \"Use of the is_stopping property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        return self.state.is_stopping",
            "",
            "    @is_stopping.setter",
            "    def is_stopping(self, value: bool):",
            "        deprecation(",
            "            \"Use of the is_stopping property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        self.state.is_stopping = value",
            "",
            "    @property",
            "    def reload_dirs(self):",
            "        return self.state.reload_dirs",
            "",
            "    @property",
            "    def ext(self) -> Extend:",
            "        if not hasattr(self, \"_ext\"):",
            "            setup_ext(self, fail=True)",
            "",
            "        if not hasattr(self, \"_ext\"):",
            "            raise RuntimeError(",
            "                \"Sanic Extensions is not installed. You can add it to your \"",
            "                \"environment using:\\n$ pip install sanic[ext]\\nor\\n$ pip \"",
            "                \"install sanic-ext\"",
            "            )",
            "        return self._ext  # type: ignore",
            "",
            "    def extend(",
            "        self,",
            "        *,",
            "        extensions: Optional[List[Type[Extension]]] = None,",
            "        built_in_extensions: bool = True,",
            "        config: Optional[Union[Config, Dict[str, Any]]] = None,",
            "        **kwargs,",
            "    ) -> Extend:",
            "        if hasattr(self, \"_ext\"):",
            "            raise RuntimeError(",
            "                \"Cannot extend Sanic after Sanic Extensions has been setup.\"",
            "            )",
            "        setup_ext(",
            "            self,",
            "            extensions=extensions,",
            "            built_in_extensions=built_in_extensions,",
            "            config=config,",
            "            fail=True,",
            "            **kwargs,",
            "        )",
            "        return self.ext",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Class methods",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @classmethod",
            "    def register_app(cls, app: \"Sanic\") -> None:",
            "        \"\"\"",
            "        Register a Sanic instance",
            "        \"\"\"",
            "        if not isinstance(app, cls):",
            "            raise SanicException(\"Registered app must be an instance of Sanic\")",
            "",
            "        name = app.name",
            "        if name in cls._app_registry and not cls.test_mode:",
            "            raise SanicException(f'Sanic app name \"{name}\" already in use.')",
            "",
            "        cls._app_registry[name] = app",
            "",
            "    @classmethod",
            "    def get_app(",
            "        cls, name: Optional[str] = None, *, force_create: bool = False",
            "    ) -> \"Sanic\":",
            "        \"\"\"",
            "        Retrieve an instantiated Sanic instance",
            "        \"\"\"",
            "        if name is None:",
            "            if len(cls._app_registry) > 1:",
            "                raise SanicException(",
            "                    'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'",
            "                )",
            "            elif len(cls._app_registry) == 0:",
            "                raise SanicException(\"No Sanic apps have been registered.\")",
            "            else:",
            "                return list(cls._app_registry.values())[0]",
            "        try:",
            "            return cls._app_registry[name]",
            "        except KeyError:",
            "            if force_create:",
            "                return cls(name)",
            "            raise SanicException(f'Sanic app name \"{name}\" not found.')",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Lifecycle",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def finalize(self):",
            "        try:",
            "            self.router.finalize()",
            "        except FinalizationError as e:",
            "            if not Sanic.test_mode:",
            "                raise e",
            "",
            "    def signalize(self, allow_fail_builtin=True):",
            "        self.signal_router.allow_fail_builtin = allow_fail_builtin",
            "        try:",
            "            self.signal_router.finalize()",
            "        except FinalizationError as e:",
            "            if not Sanic.test_mode:",
            "                raise e",
            "",
            "    async def _startup(self):",
            "        self._future_registry.clear()",
            "",
            "        if not hasattr(self, \"_ext\"):",
            "            setup_ext(self)",
            "        if hasattr(self, \"_ext\"):",
            "            self.ext._display()",
            "",
            "        if self.state.is_debug and self.config.TOUCHUP is not True:",
            "            self.config.TOUCHUP = False",
            "        elif self.config.TOUCHUP is _default:",
            "            self.config.TOUCHUP = True",
            "",
            "        # Setup routers",
            "        self.signalize(self.config.TOUCHUP)",
            "        self.finalize()",
            "",
            "        # TODO: Replace in v22.6 to check against apps in app registry",
            "        if (",
            "            self.__class__._uvloop_setting is not None",
            "            and self.__class__._uvloop_setting != self.config.USE_UVLOOP",
            "        ):",
            "            error_logger.warning(",
            "                \"It looks like you're running several apps with different \"",
            "                \"uvloop settings. This is not supported and may lead to \"",
            "                \"unintended behaviour.\"",
            "            )",
            "        self.__class__._uvloop_setting = self.config.USE_UVLOOP",
            "",
            "        # Startup time optimizations",
            "        if self.state.primary:",
            "            # TODO:",
            "            # - Raise warning if secondary apps have error handler config",
            "            if self.config.TOUCHUP:",
            "                TouchUp.run(self)",
            "",
            "        self.state.is_started = True",
            "",
            "    async def _server_event(",
            "        self,",
            "        concern: str,",
            "        action: str,",
            "        loop: Optional[AbstractEventLoop] = None,",
            "    ) -> None:",
            "        event = f\"server.{concern}.{action}\"",
            "        if action not in (\"before\", \"after\") or concern not in (",
            "            \"init\",",
            "            \"shutdown\",",
            "        ):",
            "            raise SanicException(f\"Invalid server event: {event}\")",
            "        logger.debug(",
            "            f\"Triggering server events: {event}\", extra={\"verbosity\": 1}",
            "        )",
            "        reverse = concern == \"shutdown\"",
            "        if loop is None:",
            "            loop = self.loop",
            "        await self.dispatch(",
            "            event,",
            "            fail_not_found=False,",
            "            reverse=reverse,",
            "            inline=True,",
            "            context={",
            "                \"app\": self,",
            "                \"loop\": loop,",
            "            },",
            "        )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import logging",
            "import logging.config",
            "import re",
            "import sys",
            "",
            "from asyncio import (",
            "    AbstractEventLoop,",
            "    CancelledError,",
            "    Task,",
            "    ensure_future,",
            "    get_running_loop,",
            "    wait_for,",
            ")",
            "from asyncio.futures import Future",
            "from collections import defaultdict, deque",
            "from contextlib import suppress",
            "from functools import partial",
            "from inspect import isawaitable",
            "from socket import socket",
            "from traceback import format_exc",
            "from types import SimpleNamespace",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AnyStr,",
            "    Awaitable,",
            "    Callable,",
            "    Coroutine,",
            "    Deque,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import urlencode, urlunparse",
            "from warnings import filterwarnings",
            "",
            "from sanic_routing.exceptions import FinalizationError, NotFound",
            "from sanic_routing.route import Route",
            "",
            "from sanic.application.ext import setup_ext",
            "from sanic.application.state import ApplicationState, Mode, ServerStage",
            "from sanic.asgi import ASGIApp",
            "from sanic.base.root import BaseSanic",
            "from sanic.blueprint_group import BlueprintGroup",
            "from sanic.blueprints import Blueprint",
            "from sanic.compat import OS_IS_WINDOWS, enable_windows_color_support",
            "from sanic.config import SANIC_PREFIX, Config",
            "from sanic.exceptions import (",
            "    BadRequest,",
            "    SanicException,",
            "    ServerError,",
            "    URLBuildError,",
            ")",
            "from sanic.handlers import ErrorHandler",
            "from sanic.helpers import _default",
            "from sanic.http import Stage",
            "from sanic.log import (",
            "    LOGGING_CONFIG_DEFAULTS,",
            "    deprecation,",
            "    error_logger,",
            "    logger,",
            ")",
            "from sanic.mixins.listeners import ListenerEvent",
            "from sanic.mixins.runner import RunnerMixin",
            "from sanic.models.futures import (",
            "    FutureException,",
            "    FutureListener,",
            "    FutureMiddleware,",
            "    FutureRegistry,",
            "    FutureRoute,",
            "    FutureSignal,",
            "    FutureStatic,",
            ")",
            "from sanic.models.handler_types import ListenerType, MiddlewareType",
            "from sanic.models.handler_types import Sanic as SanicVar",
            "from sanic.request import Request",
            "from sanic.response import BaseHTTPResponse, HTTPResponse, ResponseStream",
            "from sanic.router import Router",
            "from sanic.server.websockets.impl import ConnectionClosed",
            "from sanic.signals import Signal, SignalRouter",
            "from sanic.touchup import TouchUp, TouchUpMeta",
            "",
            "",
            "if TYPE_CHECKING:",
            "    try:",
            "        from sanic_ext import Extend  # type: ignore",
            "        from sanic_ext.extensions.base import Extension  # type: ignore",
            "    except ImportError:",
            "        Extend = TypeVar(\"Extend\", Type)  # type: ignore",
            "",
            "",
            "if OS_IS_WINDOWS:  # no cov",
            "    enable_windows_color_support()",
            "",
            "filterwarnings(\"once\", category=DeprecationWarning)",
            "",
            "",
            "class Sanic(BaseSanic, RunnerMixin, metaclass=TouchUpMeta):",
            "    \"\"\"",
            "    The main application instance",
            "    \"\"\"",
            "",
            "    __touchup__ = (",
            "        \"handle_request\",",
            "        \"handle_exception\",",
            "        \"_run_response_middleware\",",
            "        \"_run_request_middleware\",",
            "    )",
            "    __slots__ = (",
            "        \"_asgi_app\",",
            "        \"_asgi_client\",",
            "        \"_blueprint_order\",",
            "        \"_delayed_tasks\",",
            "        \"_ext\",",
            "        \"_future_exceptions\",",
            "        \"_future_listeners\",",
            "        \"_future_middleware\",",
            "        \"_future_registry\",",
            "        \"_future_routes\",",
            "        \"_future_signals\",",
            "        \"_future_statics\",",
            "        \"_state\",",
            "        \"_task_registry\",",
            "        \"_test_client\",",
            "        \"_test_manager\",",
            "        \"blueprints\",",
            "        \"config\",",
            "        \"configure_logging\",",
            "        \"ctx\",",
            "        \"error_handler\",",
            "        \"go_fast\",",
            "        \"listeners\",",
            "        \"named_request_middleware\",",
            "        \"named_response_middleware\",",
            "        \"request_class\",",
            "        \"request_middleware\",",
            "        \"response_middleware\",",
            "        \"router\",",
            "        \"signal_router\",",
            "        \"sock\",",
            "        \"strict_slashes\",",
            "        \"websocket_enabled\",",
            "        \"websocket_tasks\",",
            "    )",
            "",
            "    _app_registry: Dict[str, \"Sanic\"] = {}",
            "    _uvloop_setting = None  # TODO: Remove in v22.6",
            "    test_mode = False",
            "",
            "    def __init__(",
            "        self,",
            "        name: str = None,",
            "        config: Optional[Config] = None,",
            "        ctx: Optional[Any] = None,",
            "        router: Optional[Router] = None,",
            "        signal_router: Optional[SignalRouter] = None,",
            "        error_handler: Optional[ErrorHandler] = None,",
            "        env_prefix: Optional[str] = SANIC_PREFIX,",
            "        request_class: Optional[Type[Request]] = None,",
            "        strict_slashes: bool = False,",
            "        log_config: Optional[Dict[str, Any]] = None,",
            "        configure_logging: bool = True,",
            "        dumps: Optional[Callable[..., AnyStr]] = None,",
            "        loads: Optional[Callable[..., Any]] = None,",
            "    ) -> None:",
            "        super().__init__(name=name)",
            "",
            "        # logging",
            "        if configure_logging:",
            "            dict_config = log_config or LOGGING_CONFIG_DEFAULTS",
            "            logging.config.dictConfig(dict_config)  # type: ignore",
            "",
            "        if config and env_prefix != SANIC_PREFIX:",
            "            raise SanicException(",
            "                \"When instantiating Sanic with config, you cannot also pass \"",
            "                \"env_prefix\"",
            "            )",
            "",
            "        # First setup config",
            "        self.config: Config = config or Config(env_prefix=env_prefix)",
            "",
            "        # Then we can do the rest",
            "        self._asgi_client: Any = None",
            "        self._blueprint_order: List[Blueprint] = []",
            "        self._delayed_tasks: List[str] = []",
            "        self._future_registry: FutureRegistry = FutureRegistry()",
            "        self._state: ApplicationState = ApplicationState(app=self)",
            "        self._task_registry: Dict[str, Task] = {}",
            "        self._test_client: Any = None",
            "        self._test_manager: Any = None",
            "        self.asgi = False",
            "        self.auto_reload = False",
            "        self.blueprints: Dict[str, Blueprint] = {}",
            "        self.configure_logging: bool = configure_logging",
            "        self.ctx: Any = ctx or SimpleNamespace()",
            "        self.error_handler: ErrorHandler = error_handler or ErrorHandler()",
            "        self.listeners: Dict[str, List[ListenerType[Any]]] = defaultdict(list)",
            "        self.named_request_middleware: Dict[str, Deque[MiddlewareType]] = {}",
            "        self.named_response_middleware: Dict[str, Deque[MiddlewareType]] = {}",
            "        self.request_class: Type[Request] = request_class or Request",
            "        self.request_middleware: Deque[MiddlewareType] = deque()",
            "        self.response_middleware: Deque[MiddlewareType] = deque()",
            "        self.router: Router = router or Router()",
            "        self.signal_router: SignalRouter = signal_router or SignalRouter()",
            "        self.sock: Optional[socket] = None",
            "        self.strict_slashes: bool = strict_slashes",
            "        self.websocket_enabled: bool = False",
            "        self.websocket_tasks: Set[Future[Any]] = set()",
            "",
            "        # Register alternative method names",
            "        self.go_fast = self.run",
            "        self.router.ctx.app = self",
            "        self.signal_router.ctx.app = self",
            "        self.__class__.register_app(self)",
            "",
            "        if dumps:",
            "            BaseHTTPResponse._dumps = dumps  # type: ignore",
            "        if loads:",
            "            Request._loads = loads  # type: ignore",
            "",
            "    @property",
            "    def loop(self):",
            "        \"\"\"",
            "        Synonymous with asyncio.get_event_loop().",
            "",
            "        .. note::",
            "",
            "            Only supported when using the `app.run` method.",
            "        \"\"\"",
            "        if self.state.stage is ServerStage.STOPPED and self.asgi is False:",
            "            raise SanicException(",
            "                \"Loop can only be retrieved after the app has started \"",
            "                \"running. Not supported with `create_server` function\"",
            "            )",
            "        try:",
            "            return get_running_loop()",
            "        except RuntimeError:",
            "            if sys.version_info > (3, 10):",
            "                return asyncio.get_event_loop_policy().get_event_loop()",
            "            else:",
            "                return asyncio.get_event_loop()",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Registration",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def register_listener(",
            "        self, listener: ListenerType[SanicVar], event: str",
            "    ) -> ListenerType[SanicVar]:",
            "        \"\"\"",
            "        Register the listener for a given event.",
            "",
            "        :param listener: callable i.e. setup_db(app, loop)",
            "        :param event: when to register listener i.e. 'before_server_start'",
            "        :return: listener",
            "        \"\"\"",
            "",
            "        try:",
            "            _event = ListenerEvent[event.upper()]",
            "        except (ValueError, AttributeError):",
            "            valid = \", \".join(",
            "                map(lambda x: x.lower(), ListenerEvent.__members__.keys())",
            "            )",
            "            raise BadRequest(f\"Invalid event: {event}. Use one of: {valid}\")",
            "",
            "        if \".\" in _event:",
            "            self.signal(_event.value)(",
            "                partial(self._listener, listener=listener)",
            "            )",
            "        else:",
            "            self.listeners[_event.value].append(listener)",
            "",
            "        return listener",
            "",
            "    def register_middleware(",
            "        self, middleware: MiddlewareType, attach_to: str = \"request\"",
            "    ) -> MiddlewareType:",
            "        \"\"\"",
            "        Register an application level middleware that will be attached",
            "        to all the API URLs registered under this application.",
            "",
            "        This method is internally invoked by the :func:`middleware`",
            "        decorator provided at the app level.",
            "",
            "        :param middleware: Callback method to be attached to the",
            "            middleware",
            "        :param attach_to: The state at which the middleware needs to be",
            "            invoked in the lifecycle of an *HTTP Request*.",
            "            **request** - Invoke before the request is processed",
            "            **response** - Invoke before the response is returned back",
            "        :return: decorated method",
            "        \"\"\"",
            "        if attach_to == \"request\":",
            "            if middleware not in self.request_middleware:",
            "                self.request_middleware.append(middleware)",
            "        if attach_to == \"response\":",
            "            if middleware not in self.response_middleware:",
            "                self.response_middleware.appendleft(middleware)",
            "        return middleware",
            "",
            "    def register_named_middleware(",
            "        self,",
            "        middleware: MiddlewareType,",
            "        route_names: Iterable[str],",
            "        attach_to: str = \"request\",",
            "    ):",
            "        \"\"\"",
            "        Method for attaching middleware to specific routes. This is mainly an",
            "        internal tool for use by Blueprints to attach middleware to only its",
            "        specific routes. But, it could be used in a more generalized fashion.",
            "",
            "        :param middleware: the middleware to execute",
            "        :param route_names: a list of the names of the endpoints",
            "        :type route_names: Iterable[str]",
            "        :param attach_to: whether to attach to request or response,",
            "            defaults to \"request\"",
            "        :type attach_to: str, optional",
            "        \"\"\"",
            "        if attach_to == \"request\":",
            "            for _rn in route_names:",
            "                if _rn not in self.named_request_middleware:",
            "                    self.named_request_middleware[_rn] = deque()",
            "                if middleware not in self.named_request_middleware[_rn]:",
            "                    self.named_request_middleware[_rn].append(middleware)",
            "        if attach_to == \"response\":",
            "            for _rn in route_names:",
            "                if _rn not in self.named_response_middleware:",
            "                    self.named_response_middleware[_rn] = deque()",
            "                if middleware not in self.named_response_middleware[_rn]:",
            "                    self.named_response_middleware[_rn].appendleft(middleware)",
            "        return middleware",
            "",
            "    def _apply_exception_handler(",
            "        self,",
            "        handler: FutureException,",
            "        route_names: Optional[List[str]] = None,",
            "    ):",
            "        \"\"\"Decorate a function to be registered as a handler for exceptions",
            "",
            "        :param exceptions: exceptions",
            "        :return: decorated function",
            "        \"\"\"",
            "",
            "        for exception in handler.exceptions:",
            "            if isinstance(exception, (tuple, list)):",
            "                for e in exception:",
            "                    self.error_handler.add(e, handler.handler, route_names)",
            "            else:",
            "                self.error_handler.add(exception, handler.handler, route_names)",
            "        return handler.handler",
            "",
            "    def _apply_listener(self, listener: FutureListener):",
            "        return self.register_listener(listener.listener, listener.event)",
            "",
            "    def _apply_route(self, route: FutureRoute) -> List[Route]:",
            "        params = route._asdict()",
            "        websocket = params.pop(\"websocket\", False)",
            "        subprotocols = params.pop(\"subprotocols\", None)",
            "",
            "        if websocket:",
            "            self.enable_websocket()",
            "            websocket_handler = partial(",
            "                self._websocket_handler,",
            "                route.handler,",
            "                subprotocols=subprotocols,",
            "            )",
            "            websocket_handler.__name__ = route.handler.__name__  # type: ignore",
            "            websocket_handler.is_websocket = True  # type: ignore",
            "            params[\"handler\"] = websocket_handler",
            "",
            "        ctx = params.pop(\"route_context\")",
            "",
            "        routes = self.router.add(**params)",
            "        if isinstance(routes, Route):",
            "            routes = [routes]",
            "",
            "        for r in routes:",
            "            r.ctx.websocket = websocket",
            "            r.ctx.static = params.get(\"static\", False)",
            "            r.ctx.__dict__.update(ctx)",
            "",
            "        return routes",
            "",
            "    def _apply_static(self, static: FutureStatic) -> Route:",
            "        return self._register_static(static)",
            "",
            "    def _apply_middleware(",
            "        self,",
            "        middleware: FutureMiddleware,",
            "        route_names: Optional[List[str]] = None,",
            "    ):",
            "        if route_names:",
            "            return self.register_named_middleware(",
            "                middleware.middleware, route_names, middleware.attach_to",
            "            )",
            "        else:",
            "            return self.register_middleware(",
            "                middleware.middleware, middleware.attach_to",
            "            )",
            "",
            "    def _apply_signal(self, signal: FutureSignal) -> Signal:",
            "        return self.signal_router.add(*signal)",
            "",
            "    def dispatch(",
            "        self,",
            "        event: str,",
            "        *,",
            "        condition: Optional[Dict[str, str]] = None,",
            "        context: Optional[Dict[str, Any]] = None,",
            "        fail_not_found: bool = True,",
            "        inline: bool = False,",
            "        reverse: bool = False,",
            "    ) -> Coroutine[Any, Any, Awaitable[Any]]:",
            "        return self.signal_router.dispatch(",
            "            event,",
            "            context=context,",
            "            condition=condition,",
            "            inline=inline,",
            "            reverse=reverse,",
            "            fail_not_found=fail_not_found,",
            "        )",
            "",
            "    async def event(",
            "        self, event: str, timeout: Optional[Union[int, float]] = None",
            "    ):",
            "        signal = self.signal_router.name_index.get(event)",
            "        if not signal:",
            "            if self.config.EVENT_AUTOREGISTER:",
            "                self.signal_router.reset()",
            "                self.add_signal(None, event)",
            "                signal = self.signal_router.name_index[event]",
            "                self.signal_router.finalize()",
            "            else:",
            "                raise NotFound(\"Could not find signal %s\" % event)",
            "        return await wait_for(signal.ctx.event.wait(), timeout=timeout)",
            "",
            "    def enable_websocket(self, enable=True):",
            "        \"\"\"Enable or disable the support for websocket.",
            "",
            "        Websocket is enabled automatically if websocket routes are",
            "        added to the application.",
            "        \"\"\"",
            "        if not self.websocket_enabled:",
            "            # if the server is stopped, we want to cancel any ongoing",
            "            # websocket tasks, to allow the server to exit promptly",
            "            self.listener(\"before_server_stop\")(self._cancel_websocket_tasks)",
            "",
            "        self.websocket_enabled = enable",
            "",
            "    def blueprint(",
            "        self,",
            "        blueprint: Union[",
            "            Blueprint, List[Blueprint], Tuple[Blueprint], BlueprintGroup",
            "        ],",
            "        **options: Any,",
            "    ):",
            "        \"\"\"Register a blueprint on the application.",
            "",
            "        :param blueprint: Blueprint object or (list, tuple) thereof",
            "        :param options: option dictionary with blueprint defaults",
            "        :return: Nothing",
            "        \"\"\"",
            "        if isinstance(blueprint, (list, tuple, BlueprintGroup)):",
            "            for item in blueprint:",
            "                params = {**options}",
            "                if isinstance(blueprint, BlueprintGroup):",
            "                    if blueprint.url_prefix:",
            "                        merge_from = [",
            "                            options.get(\"url_prefix\", \"\"),",
            "                            blueprint.url_prefix,",
            "                        ]",
            "                        if not isinstance(item, BlueprintGroup):",
            "                            merge_from.append(item.url_prefix or \"\")",
            "                        merged_prefix = \"/\".join(",
            "                            u.strip(\"/\") for u in merge_from",
            "                        ).rstrip(\"/\")",
            "                        params[\"url_prefix\"] = f\"/{merged_prefix}\"",
            "",
            "                    for _attr in [\"version\", \"strict_slashes\"]:",
            "                        if getattr(item, _attr) is None:",
            "                            params[_attr] = getattr(",
            "                                blueprint, _attr",
            "                            ) or options.get(_attr)",
            "                    if item.version_prefix == \"/v\":",
            "                        if blueprint.version_prefix == \"/v\":",
            "                            params[\"version_prefix\"] = options.get(",
            "                                \"version_prefix\"",
            "                            )",
            "                        else:",
            "                            params[\"version_prefix\"] = blueprint.version_prefix",
            "                self.blueprint(item, **params)",
            "            return",
            "        if blueprint.name in self.blueprints:",
            "            assert self.blueprints[blueprint.name] is blueprint, (",
            "                'A blueprint with the name \"%s\" is already registered.  '",
            "                \"Blueprint names must be unique.\" % (blueprint.name,)",
            "            )",
            "        else:",
            "            self.blueprints[blueprint.name] = blueprint",
            "            self._blueprint_order.append(blueprint)",
            "",
            "        if (",
            "            self.strict_slashes is not None",
            "            and blueprint.strict_slashes is None",
            "        ):",
            "            blueprint.strict_slashes = self.strict_slashes",
            "        blueprint.register(self, options)",
            "",
            "    def url_for(self, view_name: str, **kwargs):",
            "        \"\"\"Build a URL based on a view name and the values provided.",
            "",
            "        In order to build a URL, all request parameters must be supplied as",
            "        keyword arguments, and each parameter must pass the test for the",
            "        specified parameter type. If these conditions are not met, a",
            "        `URLBuildError` will be thrown.",
            "",
            "        Keyword arguments that are not request parameters will be included in",
            "        the output URL's query string.",
            "",
            "        There are several _special_ keyword arguments that will alter how the",
            "        URL will be returned:",
            "",
            "        1. **_anchor**: ``str`` - Adds an ``#anchor`` to the end",
            "        2. **_scheme**: ``str`` - Should be either ``\"http\"`` or ``\"https\"``,",
            "           default is ``\"http\"``",
            "        3. **_external**: ``bool`` - Whether to return the path or a full URL",
            "           with scheme and host",
            "        4. **_host**: ``str`` - Used when one or more hosts are defined for a",
            "           route to tell Sanic which to use",
            "           (only applies with ``_external=True``)",
            "        5. **_server**: ``str`` - If not using ``_host``, this will be used",
            "           for defining the hostname of the URL",
            "           (only applies with ``_external=True``),",
            "           defaults to ``app.config.SERVER_NAME``",
            "",
            "        If you want the PORT to appear in your URL, you should set it in:",
            "",
            "        .. code-block::",
            "",
            "            app.config.SERVER_NAME = \"myserver:7777\"",
            "",
            "        `See user guide re: routing",
            "        <https://sanicframework.org/guide/basics/routing.html#generating-a-url>`__",
            "",
            "        :param view_name: string referencing the view name",
            "        :param kwargs: keys and values that are used to build request",
            "            parameters and query string arguments.",
            "",
            "        :return: the built URL",
            "",
            "        Raises:",
            "            URLBuildError",
            "        \"\"\"",
            "        # find the route by the supplied view name",
            "        kw: Dict[str, str] = {}",
            "        # special static files url_for",
            "",
            "        if \".\" not in view_name:",
            "            view_name = f\"{self.name}.{view_name}\"",
            "",
            "        if view_name.endswith(\".static\"):",
            "            name = kwargs.pop(\"name\", None)",
            "            if name:",
            "                view_name = view_name.replace(\"static\", name)",
            "            kw.update(name=view_name)",
            "",
            "        route = self.router.find_route_by_view_name(view_name, **kw)",
            "        if not route:",
            "            raise URLBuildError(",
            "                f\"Endpoint with name `{view_name}` was not found\"",
            "            )",
            "",
            "        uri = route.path",
            "",
            "        if getattr(route.ctx, \"static\", None):",
            "            filename = kwargs.pop(\"filename\", \"\")",
            "            # it's static folder",
            "            if \"__file_uri__\" in uri:",
            "                folder_ = uri.split(\"<__file_uri__:\", 1)[0]",
            "                if folder_.endswith(\"/\"):",
            "                    folder_ = folder_[:-1]",
            "",
            "                if filename.startswith(\"/\"):",
            "                    filename = filename[1:]",
            "",
            "                kwargs[\"__file_uri__\"] = filename",
            "",
            "        if (",
            "            uri != \"/\"",
            "            and uri.endswith(\"/\")",
            "            and not route.strict",
            "            and not route.raw_path[:-1]",
            "        ):",
            "            uri = uri[:-1]",
            "",
            "        if not uri.startswith(\"/\"):",
            "            uri = f\"/{uri}\"",
            "",
            "        out = uri",
            "",
            "        # _method is only a placeholder now, don't know how to support it",
            "        kwargs.pop(\"_method\", None)",
            "        anchor = kwargs.pop(\"_anchor\", \"\")",
            "        # _external need SERVER_NAME in config or pass _server arg",
            "        host = kwargs.pop(\"_host\", None)",
            "        external = kwargs.pop(\"_external\", False) or bool(host)",
            "        scheme = kwargs.pop(\"_scheme\", \"\")",
            "        if route.ctx.hosts and external:",
            "            if not host and len(route.ctx.hosts) > 1:",
            "                raise ValueError(",
            "                    f\"Host is ambiguous: {', '.join(route.ctx.hosts)}\"",
            "                )",
            "            elif host and host not in route.ctx.hosts:",
            "                raise ValueError(",
            "                    f\"Requested host ({host}) is not available for this \"",
            "                    f\"route: {route.ctx.hosts}\"",
            "                )",
            "            elif not host:",
            "                host = list(route.ctx.hosts)[0]",
            "",
            "        if scheme and not external:",
            "            raise ValueError(\"When specifying _scheme, _external must be True\")",
            "",
            "        netloc = kwargs.pop(\"_server\", None)",
            "        if netloc is None and external:",
            "            netloc = host or self.config.get(\"SERVER_NAME\", \"\")",
            "",
            "        if external:",
            "            if not scheme:",
            "                if \":\" in netloc[:8]:",
            "                    scheme = netloc[:8].split(\":\", 1)[0]",
            "                else:",
            "                    scheme = \"http\"",
            "",
            "            if \"://\" in netloc[:8]:",
            "                netloc = netloc.split(\"://\", 1)[-1]",
            "",
            "        # find all the parameters we will need to build in the URL",
            "        # matched_params = re.findall(self.router.parameter_pattern, uri)",
            "        route.finalize()",
            "        for param_info in route.params.values():",
            "            # name, _type, pattern = self.router.parse_parameter_string(match)",
            "            # we only want to match against each individual parameter",
            "",
            "            try:",
            "                supplied_param = str(kwargs.pop(param_info.name))",
            "            except KeyError:",
            "                raise URLBuildError(",
            "                    f\"Required parameter `{param_info.name}` was not \"",
            "                    \"passed to url_for\"",
            "                )",
            "",
            "            # determine if the parameter supplied by the caller",
            "            # passes the test in the URL",
            "            if param_info.pattern:",
            "                pattern = (",
            "                    param_info.pattern[1]",
            "                    if isinstance(param_info.pattern, tuple)",
            "                    else param_info.pattern",
            "                )",
            "                passes_pattern = pattern.match(supplied_param)",
            "                if not passes_pattern:",
            "                    if param_info.cast != str:",
            "                        msg = (",
            "                            f'Value \"{supplied_param}\" '",
            "                            f\"for parameter `{param_info.name}` does \"",
            "                            \"not match pattern for type \"",
            "                            f\"`{param_info.cast.__name__}`: \"",
            "                            f\"{pattern.pattern}\"",
            "                        )",
            "                    else:",
            "                        msg = (",
            "                            f'Value \"{supplied_param}\" for parameter '",
            "                            f\"`{param_info.name}` does not satisfy \"",
            "                            f\"pattern {pattern.pattern}\"",
            "                        )",
            "                    raise URLBuildError(msg)",
            "",
            "            # replace the parameter in the URL with the supplied value",
            "            replacement_regex = f\"(<{param_info.name}.*?>)\"",
            "            out = re.sub(replacement_regex, supplied_param, out)",
            "",
            "        # parse the remainder of the keyword arguments into a querystring",
            "        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"",
            "        # scheme://netloc/path;parameters?query#fragment",
            "        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))",
            "",
            "        return out",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Request Handling",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def handle_exception(",
            "        self, request: Request, exception: BaseException",
            "    ):  # no cov",
            "        \"\"\"",
            "        A handler that catches specific exceptions and outputs a response.",
            "",
            "        :param request: The current request object",
            "        :param exception: The exception that was raised",
            "        :raises ServerError: response 500",
            "        \"\"\"",
            "        await self.dispatch(",
            "            \"http.lifecycle.exception\",",
            "            inline=True,",
            "            context={\"request\": request, \"exception\": exception},",
            "        )",
            "",
            "        if (",
            "            request.stream is not None",
            "            and request.stream.stage is not Stage.HANDLER",
            "        ):",
            "            error_logger.exception(exception, exc_info=True)",
            "            logger.error(",
            "                \"The error response will not be sent to the client for \"",
            "                f'the following exception:\"{exception}\". A previous response '",
            "                \"has at least partially been sent.\"",
            "            )",
            "",
            "            handler = self.error_handler._lookup(",
            "                exception, request.name if request else None",
            "            )",
            "            if handler:",
            "                logger.warning(",
            "                    \"An error occurred while handling the request after at \"",
            "                    \"least some part of the response was sent to the client. \"",
            "                    \"The response from your custom exception handler \"",
            "                    f\"{handler.__name__} will not be sent to the client.\"",
            "                    \"Exception handlers should only be used to generate the \"",
            "                    \"exception responses. If you would like to perform any \"",
            "                    \"other action on a raised exception, consider using a \"",
            "                    \"signal handler like \"",
            "                    '`@app.signal(\"http.lifecycle.exception\")`\\n'",
            "                    \"For further information, please see the docs: \"",
            "                    \"https://sanicframework.org/en/guide/advanced/\"",
            "                    \"signals.html\",",
            "                )",
            "            return",
            "",
            "        # -------------------------------------------- #",
            "        # Request Middleware",
            "        # -------------------------------------------- #",
            "        response = await self._run_request_middleware(",
            "            request, request_name=None",
            "        )",
            "        # No middleware results",
            "        if not response:",
            "            try:",
            "                response = self.error_handler.response(request, exception)",
            "                if isawaitable(response):",
            "                    response = await response",
            "            except Exception as e:",
            "                if isinstance(e, SanicException):",
            "                    response = self.error_handler.default(request, e)",
            "                elif self.debug:",
            "                    response = HTTPResponse(",
            "                        (",
            "                            f\"Error while handling error: {e}\\n\"",
            "                            f\"Stack: {format_exc()}\"",
            "                        ),",
            "                        status=500,",
            "                    )",
            "                else:",
            "                    response = HTTPResponse(",
            "                        \"An error occurred while handling an error\", status=500",
            "                    )",
            "        if response is not None:",
            "            try:",
            "                request.reset_response()",
            "                response = await request.respond(response)",
            "            except BaseException:",
            "                # Skip response middleware",
            "                if request.stream:",
            "                    request.stream.respond(response)",
            "                await response.send(end_stream=True)",
            "                raise",
            "        else:",
            "            if request.stream:",
            "                response = request.stream.response",
            "",
            "        # Marked for cleanup and DRY with handle_request/handle_exception",
            "        # when ResponseStream is no longer supporder",
            "        if isinstance(response, BaseHTTPResponse):",
            "            await self.dispatch(",
            "                \"http.lifecycle.response\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"response\": response,",
            "                },",
            "            )",
            "            await response.send(end_stream=True)",
            "        elif isinstance(response, ResponseStream):",
            "            resp = await response(request)",
            "            await self.dispatch(",
            "                \"http.lifecycle.response\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"response\": resp,",
            "                },",
            "            )",
            "            await response.eof()",
            "        else:",
            "            raise ServerError(",
            "                f\"Invalid response type {response!r} (need HTTPResponse)\"",
            "            )",
            "",
            "    async def handle_request(self, request: Request):  # no cov",
            "        \"\"\"Take a request from the HTTP Server and return a response object",
            "        to be sent back The HTTP Server only expects a response object, so",
            "        exception handling must be done here",
            "",
            "        :param request: HTTP Request object",
            "        :return: Nothing",
            "        \"\"\"",
            "        await self.dispatch(",
            "            \"http.lifecycle.handle\",",
            "            inline=True,",
            "            context={\"request\": request},",
            "        )",
            "",
            "        # Define `response` var here to remove warnings about",
            "        # allocation before assignment below.",
            "        response = None",
            "        try:",
            "",
            "            await self.dispatch(",
            "                \"http.routing.before\",",
            "                inline=True,",
            "                context={\"request\": request},",
            "            )",
            "            # Fetch handler from router",
            "            route, handler, kwargs = self.router.get(",
            "                request.path,",
            "                request.method,",
            "                request.headers.getone(\"host\", None),",
            "            )",
            "",
            "            request._match_info = {**kwargs}",
            "            request.route = route",
            "",
            "            await self.dispatch(",
            "                \"http.routing.after\",",
            "                inline=True,",
            "                context={",
            "                    \"request\": request,",
            "                    \"route\": route,",
            "                    \"kwargs\": kwargs,",
            "                    \"handler\": handler,",
            "                },",
            "            )",
            "",
            "            if (",
            "                request.stream",
            "                and request.stream.request_body",
            "                and not route.ctx.ignore_body",
            "            ):",
            "",
            "                if hasattr(handler, \"is_stream\"):",
            "                    # Streaming handler: lift the size limit",
            "                    request.stream.request_max_size = float(\"inf\")",
            "                else:",
            "                    # Non-streaming handler: preload body",
            "                    await request.receive_body()",
            "",
            "            # -------------------------------------------- #",
            "            # Request Middleware",
            "            # -------------------------------------------- #",
            "            response = await self._run_request_middleware(",
            "                request, request_name=route.name",
            "            )",
            "",
            "            # No middleware results",
            "            if not response:",
            "                # -------------------------------------------- #",
            "                # Execute Handler",
            "                # -------------------------------------------- #",
            "",
            "                if handler is None:",
            "                    raise ServerError(",
            "                        (",
            "                            \"'None' was returned while requesting a \"",
            "                            \"handler from the router\"",
            "                        )",
            "                    )",
            "",
            "                # Run response handler",
            "                response = handler(request, **request.match_info)",
            "                if isawaitable(response):",
            "                    response = await response",
            "",
            "            if request.responded:",
            "                if response is not None:",
            "                    error_logger.error(",
            "                        \"The response object returned by the route handler \"",
            "                        \"will not be sent to client. The request has already \"",
            "                        \"been responded to.\"",
            "                    )",
            "                if request.stream is not None:",
            "                    response = request.stream.response",
            "            elif response is not None:",
            "                response = await request.respond(response)",
            "            elif not hasattr(handler, \"is_websocket\"):",
            "                response = request.stream.response  # type: ignore",
            "",
            "            # Marked for cleanup and DRY with handle_request/handle_exception",
            "            # when ResponseStream is no longer supporder",
            "            if isinstance(response, BaseHTTPResponse):",
            "                await self.dispatch(",
            "                    \"http.lifecycle.response\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": response,",
            "                    },",
            "                )",
            "                ...",
            "                await response.send(end_stream=True)",
            "            elif isinstance(response, ResponseStream):",
            "                resp = await response(request)",
            "                await self.dispatch(",
            "                    \"http.lifecycle.response\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": resp,",
            "                    },",
            "                )",
            "                await response.eof()",
            "            else:",
            "                if not hasattr(handler, \"is_websocket\"):",
            "                    raise ServerError(",
            "                        f\"Invalid response type {response!r} \"",
            "                        \"(need HTTPResponse)\"",
            "                    )",
            "",
            "        except CancelledError:",
            "            raise",
            "        except Exception as e:",
            "            # Response Generation Failed",
            "            await self.handle_exception(request, e)",
            "",
            "    async def _websocket_handler(",
            "        self, handler, request, *args, subprotocols=None, **kwargs",
            "    ):",
            "        if self.asgi:",
            "            ws = request.transport.get_websocket_connection()",
            "            await ws.accept(subprotocols)",
            "        else:",
            "            protocol = request.transport.get_protocol()",
            "            ws = await protocol.websocket_handshake(request, subprotocols)",
            "",
            "        # schedule the application handler",
            "        # its future is kept in self.websocket_tasks in case it",
            "        # needs to be cancelled due to the server being stopped",
            "        fut = ensure_future(handler(request, ws, *args, **kwargs))",
            "        self.websocket_tasks.add(fut)",
            "        cancelled = False",
            "        try:",
            "            await fut",
            "        except (CancelledError, ConnectionClosed):",
            "            cancelled = True",
            "        except Exception as e:",
            "            self.error_handler.log(request, e)",
            "        finally:",
            "            self.websocket_tasks.remove(fut)",
            "            if cancelled:",
            "                ws.end_connection(1000)",
            "            else:",
            "                await ws.close()",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Testing",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @property",
            "    def test_client(self):  # noqa",
            "        if self._test_client:",
            "            return self._test_client",
            "        elif self._test_manager:",
            "            return self._test_manager.test_client",
            "        from sanic_testing.testing import SanicTestClient  # type: ignore",
            "",
            "        self._test_client = SanicTestClient(self)",
            "        return self._test_client",
            "",
            "    @property",
            "    def asgi_client(self):  # noqa",
            "        \"\"\"",
            "        A testing client that uses ASGI to reach into the application to",
            "        execute handlers.",
            "",
            "        :return: testing client",
            "        :rtype: :class:`SanicASGITestClient`",
            "        \"\"\"",
            "        if self._asgi_client:",
            "            return self._asgi_client",
            "        elif self._test_manager:",
            "            return self._test_manager.asgi_client",
            "        from sanic_testing.testing import SanicASGITestClient  # type: ignore",
            "",
            "        self._asgi_client = SanicASGITestClient(self)",
            "        return self._asgi_client",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Execution",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def _run_request_middleware(",
            "        self, request, request_name=None",
            "    ):  # no cov",
            "        # The if improves speed.  I don't know why",
            "        named_middleware = self.named_request_middleware.get(",
            "            request_name, deque()",
            "        )",
            "        applicable_middleware = self.request_middleware + named_middleware",
            "",
            "        # request.request_middleware_started is meant as a stop-gap solution",
            "        # until RFC 1630 is adopted",
            "        if applicable_middleware and not request.request_middleware_started:",
            "            request.request_middleware_started = True",
            "",
            "            for middleware in applicable_middleware:",
            "                await self.dispatch(",
            "                    \"http.middleware.before\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": None,",
            "                    },",
            "                    condition={\"attach_to\": \"request\"},",
            "                )",
            "",
            "                response = middleware(request)",
            "                if isawaitable(response):",
            "                    response = await response",
            "",
            "                await self.dispatch(",
            "                    \"http.middleware.after\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": None,",
            "                    },",
            "                    condition={\"attach_to\": \"request\"},",
            "                )",
            "",
            "                if response:",
            "                    return response",
            "        return None",
            "",
            "    async def _run_response_middleware(",
            "        self, request, response, request_name=None",
            "    ):  # no cov",
            "        named_middleware = self.named_response_middleware.get(",
            "            request_name, deque()",
            "        )",
            "        applicable_middleware = self.response_middleware + named_middleware",
            "        if applicable_middleware:",
            "            for middleware in applicable_middleware:",
            "                await self.dispatch(",
            "                    \"http.middleware.before\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": response,",
            "                    },",
            "                    condition={\"attach_to\": \"response\"},",
            "                )",
            "",
            "                _response = middleware(request, response)",
            "                if isawaitable(_response):",
            "                    _response = await _response",
            "",
            "                await self.dispatch(",
            "                    \"http.middleware.after\",",
            "                    inline=True,",
            "                    context={",
            "                        \"request\": request,",
            "                        \"response\": _response if _response else response,",
            "                    },",
            "                    condition={\"attach_to\": \"response\"},",
            "                )",
            "",
            "                if _response:",
            "                    response = _response",
            "                    if isinstance(response, BaseHTTPResponse):",
            "                        response = request.stream.respond(response)",
            "                    break",
            "        return response",
            "",
            "    def _build_endpoint_name(self, *parts):",
            "        parts = [self.name, *parts]",
            "        return \".\".join(parts)",
            "",
            "    @classmethod",
            "    def _cancel_websocket_tasks(cls, app, loop):",
            "        for task in app.websocket_tasks:",
            "            task.cancel()",
            "",
            "    @staticmethod",
            "    async def _listener(",
            "        app: Sanic, loop: AbstractEventLoop, listener: ListenerType",
            "    ):",
            "        try:",
            "            maybe_coro = listener(app)  # type: ignore",
            "        except TypeError:",
            "            maybe_coro = listener(app, loop)  # type: ignore",
            "        if maybe_coro and isawaitable(maybe_coro):",
            "            await maybe_coro",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Task management",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @classmethod",
            "    def _prep_task(",
            "        cls,",
            "        task,",
            "        app,",
            "        loop,",
            "    ):",
            "        if callable(task):",
            "            try:",
            "                task = task(app)",
            "            except TypeError:",
            "                task = task()",
            "",
            "        return task",
            "",
            "    @classmethod",
            "    def _loop_add_task(",
            "        cls,",
            "        task,",
            "        app,",
            "        loop,",
            "        *,",
            "        name: Optional[str] = None,",
            "        register: bool = True,",
            "    ) -> Task:",
            "        if not isinstance(task, Future):",
            "            prepped = cls._prep_task(task, app, loop)",
            "            if sys.version_info < (3, 8):  # no cov",
            "                task = loop.create_task(prepped)",
            "                if name:",
            "                    error_logger.warning(",
            "                        \"Cannot set a name for a task when using Python 3.7. \"",
            "                        \"Your task will be created without a name.\"",
            "                    )",
            "                task.get_name = lambda: name",
            "            else:",
            "                task = loop.create_task(prepped, name=name)",
            "",
            "        if name and register and sys.version_info > (3, 7):",
            "            app._task_registry[name] = task",
            "",
            "        return task",
            "",
            "    @staticmethod",
            "    async def dispatch_delayed_tasks(app, loop):",
            "        for name in app._delayed_tasks:",
            "            await app.dispatch(name, context={\"app\": app, \"loop\": loop})",
            "        app._delayed_tasks.clear()",
            "",
            "    @staticmethod",
            "    async def run_delayed_task(app, loop, task):",
            "        prepped = app._prep_task(task, app, loop)",
            "        await prepped",
            "",
            "    def add_task(",
            "        self,",
            "        task: Union[Future[Any], Coroutine[Any, Any, Any], Awaitable[Any]],",
            "        *,",
            "        name: Optional[str] = None,",
            "        register: bool = True,",
            "    ) -> Optional[Task]:",
            "        \"\"\"",
            "        Schedule a task to run later, after the loop has started.",
            "        Different from asyncio.ensure_future in that it does not",
            "        also return a future, and the actual ensure_future call",
            "        is delayed until before server start.",
            "",
            "        `See user guide re: background tasks",
            "        <https://sanicframework.org/guide/basics/tasks.html#background-tasks>`__",
            "",
            "        :param task: future, coroutine or awaitable",
            "        \"\"\"",
            "        try:",
            "            loop = self.loop  # Will raise SanicError if loop is not started",
            "            return self._loop_add_task(",
            "                task, self, loop, name=name, register=register",
            "            )",
            "        except SanicException:",
            "            task_name = f\"sanic.delayed_task.{hash(task)}\"",
            "            if not self._delayed_tasks:",
            "                self.after_server_start(partial(self.dispatch_delayed_tasks))",
            "",
            "            if name:",
            "                raise RuntimeError(",
            "                    \"Cannot name task outside of a running application\"",
            "                )",
            "",
            "            self.signal(task_name)(partial(self.run_delayed_task, task=task))",
            "            self._delayed_tasks.append(task_name)",
            "            return None",
            "",
            "    def get_task(",
            "        self, name: str, *, raise_exception: bool = True",
            "    ) -> Optional[Task]:",
            "        try:",
            "            return self._task_registry[name]",
            "        except KeyError:",
            "            if raise_exception:",
            "                raise SanicException(",
            "                    f'Registered task named \"{name}\" not found.'",
            "                )",
            "            return None",
            "",
            "    async def cancel_task(",
            "        self,",
            "        name: str,",
            "        msg: Optional[str] = None,",
            "        *,",
            "        raise_exception: bool = True,",
            "    ) -> None:",
            "        task = self.get_task(name, raise_exception=raise_exception)",
            "        if task and not task.cancelled():",
            "            args: Tuple[str, ...] = ()",
            "            if msg:",
            "                if sys.version_info >= (3, 9):",
            "                    args = (msg,)",
            "                else:  # no cov",
            "                    raise RuntimeError(",
            "                        \"Cancelling a task with a message is only supported \"",
            "                        \"on Python 3.9+.\"",
            "                    )",
            "            task.cancel(*args)",
            "            try:",
            "                await task",
            "            except CancelledError:",
            "                ...",
            "",
            "    def purge_tasks(self):",
            "        for key, task in self._task_registry.items():",
            "            if task.done() or task.cancelled():",
            "                self._task_registry[key] = None",
            "",
            "        self._task_registry = {",
            "            k: v for k, v in self._task_registry.items() if v is not None",
            "        }",
            "",
            "    def shutdown_tasks(",
            "        self, timeout: Optional[float] = None, increment: float = 0.1",
            "    ):",
            "        for task in self.tasks:",
            "            if task.get_name() != \"RunServer\":",
            "                task.cancel()",
            "",
            "        if timeout is None:",
            "            timeout = self.config.GRACEFUL_SHUTDOWN_TIMEOUT",
            "",
            "        while len(self._task_registry) and timeout:",
            "            with suppress(RuntimeError):",
            "                running_loop = get_running_loop()",
            "                running_loop.run_until_complete(asyncio.sleep(increment))",
            "            self.purge_tasks()",
            "            timeout -= increment",
            "",
            "    @property",
            "    def tasks(self):",
            "        return iter(self._task_registry.values())",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # ASGI",
            "    # -------------------------------------------------------------------- #",
            "",
            "    async def __call__(self, scope, receive, send):",
            "        \"\"\"",
            "        To be ASGI compliant, our instance must be a callable that accepts",
            "        three arguments: scope, receive, send. See the ASGI reference for more",
            "        details: https://asgi.readthedocs.io/en/latest",
            "        \"\"\"",
            "        self.asgi = True",
            "        if scope[\"type\"] == \"lifespan\":",
            "            self.motd(\"\")",
            "        self._asgi_app = await ASGIApp.create(self, scope, receive, send)",
            "        asgi_app = self._asgi_app",
            "        await asgi_app()",
            "",
            "    _asgi_single_callable = True  # We conform to ASGI 3.0 single-callable",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Configuration",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def update_config(self, config: Union[bytes, str, dict, Any]):",
            "        \"\"\"",
            "        Update app.config. Full implementation can be found in the user guide.",
            "",
            "        `See user guide re: configuration",
            "        <https://sanicframework.org/guide/deployment/configuration.html#basics>`__",
            "        \"\"\"",
            "",
            "        self.config.update_config(config)",
            "",
            "    @property",
            "    def asgi(self):",
            "        return self.state.asgi",
            "",
            "    @asgi.setter",
            "    def asgi(self, value: bool):",
            "        self.state.asgi = value",
            "",
            "    @property",
            "    def debug(self):",
            "        return self.state.is_debug",
            "",
            "    @debug.setter",
            "    def debug(self, value: bool):",
            "        deprecation(",
            "            \"Setting the value of a Sanic application's debug value directly \"",
            "            \"is deprecated and will be removed in v22.9. Please set it using \"",
            "            \"the CLI, app.run, app.prepare, or directly set \"",
            "            \"app.state.mode to Mode.DEBUG.\",",
            "            22.9,",
            "        )",
            "        mode = Mode.DEBUG if value else Mode.PRODUCTION",
            "        self.state.mode = mode",
            "",
            "    @property",
            "    def auto_reload(self):",
            "        return self.config.AUTO_RELOAD",
            "",
            "    @auto_reload.setter",
            "    def auto_reload(self, value: bool):",
            "        self.config.AUTO_RELOAD = value",
            "",
            "    @property",
            "    def state(self) -> ApplicationState:  # type: ignore",
            "        \"\"\"",
            "        :return: The application state",
            "        \"\"\"",
            "        return self._state",
            "",
            "    @property",
            "    def is_running(self):",
            "        deprecation(",
            "            \"Use of the is_running property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        return self.state.is_running",
            "",
            "    @is_running.setter",
            "    def is_running(self, value: bool):",
            "        deprecation(",
            "            \"Use of the is_running property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        self.state.is_running = value",
            "",
            "    @property",
            "    def is_stopping(self):",
            "        deprecation(",
            "            \"Use of the is_stopping property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        return self.state.is_stopping",
            "",
            "    @is_stopping.setter",
            "    def is_stopping(self, value: bool):",
            "        deprecation(",
            "            \"Use of the is_stopping property is no longer used by Sanic \"",
            "            \"internally. The property is now deprecated and will be removed \"",
            "            \"in version 22.9. You may continue to set the property for your \"",
            "            \"own needs until that time. If you would like to check whether \"",
            "            \"the application is operational, please use app.state.stage. More \"",
            "            \"information is available at ___.\",",
            "            22.9,",
            "        )",
            "        self.state.is_stopping = value",
            "",
            "    @property",
            "    def reload_dirs(self):",
            "        return self.state.reload_dirs",
            "",
            "    @property",
            "    def ext(self) -> Extend:",
            "        if not hasattr(self, \"_ext\"):",
            "            setup_ext(self, fail=True)",
            "",
            "        if not hasattr(self, \"_ext\"):",
            "            raise RuntimeError(",
            "                \"Sanic Extensions is not installed. You can add it to your \"",
            "                \"environment using:\\n$ pip install sanic[ext]\\nor\\n$ pip \"",
            "                \"install sanic-ext\"",
            "            )",
            "        return self._ext  # type: ignore",
            "",
            "    def extend(",
            "        self,",
            "        *,",
            "        extensions: Optional[List[Type[Extension]]] = None,",
            "        built_in_extensions: bool = True,",
            "        config: Optional[Union[Config, Dict[str, Any]]] = None,",
            "        **kwargs,",
            "    ) -> Extend:",
            "        if hasattr(self, \"_ext\"):",
            "            raise RuntimeError(",
            "                \"Cannot extend Sanic after Sanic Extensions has been setup.\"",
            "            )",
            "        setup_ext(",
            "            self,",
            "            extensions=extensions,",
            "            built_in_extensions=built_in_extensions,",
            "            config=config,",
            "            fail=True,",
            "            **kwargs,",
            "        )",
            "        return self.ext",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Class methods",
            "    # -------------------------------------------------------------------- #",
            "",
            "    @classmethod",
            "    def register_app(cls, app: \"Sanic\") -> None:",
            "        \"\"\"",
            "        Register a Sanic instance",
            "        \"\"\"",
            "        if not isinstance(app, cls):",
            "            raise SanicException(\"Registered app must be an instance of Sanic\")",
            "",
            "        name = app.name",
            "        if name in cls._app_registry and not cls.test_mode:",
            "            raise SanicException(f'Sanic app name \"{name}\" already in use.')",
            "",
            "        cls._app_registry[name] = app",
            "",
            "    @classmethod",
            "    def get_app(",
            "        cls, name: Optional[str] = None, *, force_create: bool = False",
            "    ) -> \"Sanic\":",
            "        \"\"\"",
            "        Retrieve an instantiated Sanic instance",
            "        \"\"\"",
            "        if name is None:",
            "            if len(cls._app_registry) > 1:",
            "                raise SanicException(",
            "                    'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'",
            "                )",
            "            elif len(cls._app_registry) == 0:",
            "                raise SanicException(\"No Sanic apps have been registered.\")",
            "            else:",
            "                return list(cls._app_registry.values())[0]",
            "        try:",
            "            return cls._app_registry[name]",
            "        except KeyError:",
            "            if force_create:",
            "                return cls(name)",
            "            raise SanicException(f'Sanic app name \"{name}\" not found.')",
            "",
            "    # -------------------------------------------------------------------- #",
            "    # Lifecycle",
            "    # -------------------------------------------------------------------- #",
            "",
            "    def finalize(self):",
            "        try:",
            "            self.router.finalize()",
            "        except FinalizationError as e:",
            "            if not Sanic.test_mode:",
            "                raise e",
            "",
            "    def signalize(self, allow_fail_builtin=True):",
            "        self.signal_router.allow_fail_builtin = allow_fail_builtin",
            "        try:",
            "            self.signal_router.finalize()",
            "        except FinalizationError as e:",
            "            if not Sanic.test_mode:",
            "                raise e",
            "",
            "    async def _startup(self):",
            "        self._future_registry.clear()",
            "",
            "        if not hasattr(self, \"_ext\"):",
            "            setup_ext(self)",
            "        if hasattr(self, \"_ext\"):",
            "            self.ext._display()",
            "",
            "        if self.state.is_debug and self.config.TOUCHUP is not True:",
            "            self.config.TOUCHUP = False",
            "        elif self.config.TOUCHUP is _default:",
            "            self.config.TOUCHUP = True",
            "",
            "        # Setup routers",
            "        self.signalize(self.config.TOUCHUP)",
            "        self.finalize()",
            "",
            "        # TODO: Replace in v22.6 to check against apps in app registry",
            "        if (",
            "            self.__class__._uvloop_setting is not None",
            "            and self.__class__._uvloop_setting != self.config.USE_UVLOOP",
            "        ):",
            "            error_logger.warning(",
            "                \"It looks like you're running several apps with different \"",
            "                \"uvloop settings. This is not supported and may lead to \"",
            "                \"unintended behaviour.\"",
            "            )",
            "        self.__class__._uvloop_setting = self.config.USE_UVLOOP",
            "",
            "        # Startup time optimizations",
            "        if self.state.primary:",
            "            # TODO:",
            "            # - Raise warning if secondary apps have error handler config",
            "            if self.config.TOUCHUP:",
            "                TouchUp.run(self)",
            "",
            "        self.state.is_started = True",
            "",
            "    async def _server_event(",
            "        self,",
            "        concern: str,",
            "        action: str,",
            "        loop: Optional[AbstractEventLoop] = None,",
            "    ) -> None:",
            "        event = f\"server.{concern}.{action}\"",
            "        if action not in (\"before\", \"after\") or concern not in (",
            "            \"init\",",
            "            \"shutdown\",",
            "        ):",
            "            raise SanicException(f\"Invalid server event: {event}\")",
            "        logger.debug(",
            "            f\"Triggering server events: {event}\", extra={\"verbosity\": 1}",
            "        )",
            "        reverse = concern == \"shutdown\"",
            "        if loop is None:",
            "            loop = self.loop",
            "        await self.dispatch(",
            "            event,",
            "            fail_not_found=False,",
            "            reverse=reverse,",
            "            inline=True,",
            "            context={",
            "                \"app\": self,",
            "                \"loop\": loop,",
            "            },",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1002": [
                "Sanic",
                "asgi_client"
            ],
            "1197": [
                "Sanic",
                "add_task"
            ]
        },
        "addLocation": []
    },
    "sanic/http/http3.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "     app: Sanic, ssl: Union[SanicSSLContext, CertSelector, SSLContext]"
            },
            "1": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 379,
                "PatchRowcode": " ):"
            },
            "2": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "     # TODO:"
            },
            "3": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # - proper selection needed if servince with multiple certs insted of"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+    # - proper selection needed if service with multiple certs insted of"
            },
            "5": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "     #   just taking the first"
            },
            "6": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "     if isinstance(ssl, CertSelector):"
            },
            "7": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         ssl = cast(SanicSSLContext, ssl.sanic_select[0])"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "",
            "from abc import ABC, abstractmethod",
            "from ssl import SSLContext",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from sanic.compat import Header",
            "from sanic.constants import LocalCertCreator",
            "from sanic.exceptions import PayloadTooLarge, SanicException, ServerError",
            "from sanic.helpers import has_message_body",
            "from sanic.http.constants import Stage",
            "from sanic.http.stream import Stream",
            "from sanic.http.tls.context import CertSelector, CertSimple, SanicSSLContext",
            "from sanic.log import Colors, logger",
            "from sanic.models.protocol_types import TransportProtocol",
            "from sanic.models.server_types import ConnInfo",
            "",
            "",
            "try:",
            "    from aioquic.h0.connection import H0_ALPN, H0Connection",
            "    from aioquic.h3.connection import H3_ALPN, H3Connection",
            "    from aioquic.h3.events import (",
            "        DatagramReceived,",
            "        DataReceived,",
            "        H3Event,",
            "        HeadersReceived,",
            "        WebTransportStreamDataReceived,",
            "    )",
            "    from aioquic.quic.configuration import QuicConfiguration",
            "    from aioquic.tls import SessionTicket",
            "",
            "    HTTP3_AVAILABLE = True",
            "except ModuleNotFoundError:  # no cov",
            "    HTTP3_AVAILABLE = False",
            "",
            "if TYPE_CHECKING:",
            "    from sanic import Sanic",
            "    from sanic.request import Request",
            "    from sanic.response import BaseHTTPResponse",
            "    from sanic.server.protocols.http_protocol import Http3Protocol",
            "",
            "    HttpConnection = Union[H0Connection, H3Connection]",
            "",
            "",
            "class HTTP3Transport(TransportProtocol):",
            "    __slots__ = (\"_protocol\",)",
            "",
            "    def __init__(self, protocol: Http3Protocol):",
            "        self._protocol = protocol",
            "",
            "    def get_protocol(self) -> Http3Protocol:",
            "        return self._protocol",
            "",
            "    def get_extra_info(self, info: str, default: Any = None) -> Any:",
            "        if (",
            "            info in (\"socket\", \"sockname\", \"peername\")",
            "            and self._protocol._transport",
            "        ):",
            "            return self._protocol._transport.get_extra_info(info, default)",
            "        elif info == \"network_paths\":",
            "            return self._protocol._quic._network_paths",
            "        elif info == \"ssl_context\":",
            "            return self._protocol.app.state.ssl",
            "        return default",
            "",
            "",
            "class Receiver(ABC):",
            "    future: asyncio.Future",
            "",
            "    def __init__(self, transmit, protocol, request: Request) -> None:",
            "        self.transmit = transmit",
            "        self.protocol = protocol",
            "        self.request = request",
            "",
            "    @abstractmethod",
            "    async def run(self):  # no cov",
            "        ...",
            "",
            "",
            "class HTTPReceiver(Receiver, Stream):",
            "    stage: Stage",
            "    request: Request",
            "",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.request_body = None",
            "        self.stage = Stage.IDLE",
            "        self.headers_sent = False",
            "        self.response: Optional[BaseHTTPResponse] = None",
            "        self.request_max_size = self.protocol.request_max_size",
            "        self.request_bytes = 0",
            "",
            "    async def run(self, exception: Optional[Exception] = None):",
            "        self.stage = Stage.HANDLER",
            "        self.head_only = self.request.method.upper() == \"HEAD\"",
            "",
            "        if exception:",
            "            logger.info(  # no cov",
            "                f\"{Colors.BLUE}[exception]: \"",
            "                f\"{Colors.RED}{exception}{Colors.END}\",",
            "                exc_info=True,",
            "                extra={\"verbosity\": 1},",
            "            )",
            "            await self.error_response(exception)",
            "        else:",
            "            try:",
            "                logger.info(  # no cov",
            "                    f\"{Colors.BLUE}[request]:{Colors.END} {self.request}\",",
            "                    extra={\"verbosity\": 1},",
            "                )",
            "                await self.protocol.request_handler(self.request)",
            "            except Exception as e:  # no cov",
            "                # This should largely be handled within the request handler.",
            "                # But, just in case...",
            "                await self.run(e)",
            "        self.stage = Stage.IDLE",
            "",
            "    async def error_response(self, exception: Exception) -> None:",
            "        \"\"\"",
            "        Handle response when exception encountered",
            "        \"\"\"",
            "        # From request and handler states we can respond, otherwise be silent",
            "        app = self.protocol.app",
            "",
            "        await app.handle_exception(self.request, exception)",
            "",
            "    def _prepare_headers(",
            "        self, response: BaseHTTPResponse",
            "    ) -> List[Tuple[bytes, bytes]]:",
            "        size = len(response.body) if response.body else 0",
            "        headers = response.headers",
            "        status = response.status",
            "",
            "        if not has_message_body(status) and (",
            "            size",
            "            or \"content-length\" in headers",
            "            or \"transfer-encoding\" in headers",
            "        ):",
            "            headers.pop(\"content-length\", None)",
            "            headers.pop(\"transfer-encoding\", None)",
            "            logger.warning(  # no cov",
            "                f\"Message body set in response on {self.request.path}. \"",
            "                f\"A {status} response may only have headers, no body.\"",
            "            )",
            "        elif \"content-length\" not in headers:",
            "            if size:",
            "                headers[\"content-length\"] = size",
            "            else:",
            "                headers[\"transfer-encoding\"] = \"chunked\"",
            "",
            "        headers = [",
            "            (b\":status\", str(response.status).encode()),",
            "            *response.processed_headers,",
            "        ]",
            "        return headers",
            "",
            "    def send_headers(self) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[send]: {Colors.GREEN}HEADERS{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        if not self.response:",
            "            raise RuntimeError(\"no response\")",
            "",
            "        response = self.response",
            "        headers = self._prepare_headers(response)",
            "",
            "        self.protocol.connection.send_headers(",
            "            stream_id=self.request.stream_id,",
            "            headers=headers,",
            "        )",
            "        self.headers_sent = True",
            "        self.stage = Stage.RESPONSE",
            "",
            "        if self.response.body and not self.head_only:",
            "            self._send(self.response.body, False)",
            "        elif self.head_only:",
            "            self.future.cancel()",
            "",
            "    def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[respond]:{Colors.END} {response}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "",
            "        if self.stage is not Stage.HANDLER:",
            "            self.stage = Stage.FAILED",
            "            raise RuntimeError(\"Response already started\")",
            "",
            "        # Disconnect any earlier but unused response object",
            "        if self.response is not None:",
            "            self.response.stream = None",
            "",
            "        self.response, response.stream = response, self",
            "",
            "        return response",
            "",
            "    def receive_body(self, data: bytes) -> None:",
            "        self.request_bytes += len(data)",
            "        if self.request_bytes > self.request_max_size:",
            "            raise PayloadTooLarge(\"Request body exceeds the size limit\")",
            "",
            "        self.request.body += data",
            "",
            "    async def send(self, data: bytes, end_stream: bool) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[send]: {Colors.GREEN}data={data.decode()} \"",
            "            f\"end_stream={end_stream}{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        self._send(data, end_stream)",
            "",
            "    def _send(self, data: bytes, end_stream: bool) -> None:",
            "        if not self.headers_sent:",
            "            self.send_headers()",
            "        if self.stage is not Stage.RESPONSE:",
            "            raise ServerError(f\"not ready to send: {self.stage}\")",
            "",
            "        # Chunked",
            "        if (",
            "            self.response",
            "            and self.response.headers.get(\"transfer-encoding\") == \"chunked\"",
            "        ):",
            "            size = len(data)",
            "            if end_stream:",
            "                data = (",
            "                    b\"%x\\r\\n%b\\r\\n0\\r\\n\\r\\n\" % (size, data)",
            "                    if size",
            "                    else b\"0\\r\\n\\r\\n\"",
            "                )",
            "            elif size:",
            "                data = b\"%x\\r\\n%b\\r\\n\" % (size, data)",
            "",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[transmitting]{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        self.protocol.connection.send_data(",
            "            stream_id=self.request.stream_id,",
            "            data=data,",
            "            end_stream=end_stream,",
            "        )",
            "        self.transmit()",
            "",
            "        if end_stream:",
            "            self.stage = Stage.IDLE",
            "",
            "",
            "class WebsocketReceiver(Receiver):  # noqa",
            "    async def run(self):",
            "        ...",
            "",
            "",
            "class WebTransportReceiver(Receiver):  # noqa",
            "    async def run(self):",
            "        ...",
            "",
            "",
            "class Http3:",
            "    \"\"\"",
            "    Internal helper for managing the HTTP/3 request/response cycle",
            "    \"\"\"",
            "",
            "    if HTTP3_AVAILABLE:",
            "        HANDLER_PROPERTY_MAPPING = {",
            "            DataReceived: \"stream_id\",",
            "            HeadersReceived: \"stream_id\",",
            "            DatagramReceived: \"flow_id\",",
            "            WebTransportStreamDataReceived: \"session_id\",",
            "        }",
            "",
            "    def __init__(",
            "        self,",
            "        protocol: Http3Protocol,",
            "        transmit: Callable[[], None],",
            "    ) -> None:",
            "        self.protocol = protocol",
            "        self.transmit = transmit",
            "        self.receivers: Dict[int, Receiver] = {}",
            "",
            "    def http_event_received(self, event: H3Event) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[http_event_received]: \"",
            "            f\"{Colors.YELLOW}{event}{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        receiver, created_new = self.get_or_make_receiver(event)",
            "        receiver = cast(HTTPReceiver, receiver)",
            "",
            "        if isinstance(event, HeadersReceived) and created_new:",
            "            receiver.future = asyncio.ensure_future(receiver.run())",
            "        elif isinstance(event, DataReceived):",
            "            try:",
            "                receiver.receive_body(event.data)",
            "            except Exception as e:",
            "                receiver.future.cancel()",
            "                receiver.future = asyncio.ensure_future(receiver.run(e))",
            "        else:",
            "            ...  # Intentionally here to help out Touchup",
            "            logger.debug(  # no cov",
            "                f\"{Colors.RED}DOING NOTHING{Colors.END}\",",
            "                extra={\"verbosity\": 2},",
            "            )",
            "",
            "    def get_or_make_receiver(self, event: H3Event) -> Tuple[Receiver, bool]:",
            "        if (",
            "            isinstance(event, HeadersReceived)",
            "            and event.stream_id not in self.receivers",
            "        ):",
            "            request = self._make_request(event)",
            "            receiver = HTTPReceiver(self.transmit, self.protocol, request)",
            "            request.stream = receiver",
            "",
            "            self.receivers[event.stream_id] = receiver",
            "            return receiver, True",
            "        else:",
            "            ident = getattr(event, self.HANDLER_PROPERTY_MAPPING[type(event)])",
            "            return self.receivers[ident], False",
            "",
            "    def get_receiver_by_stream_id(self, stream_id: int) -> Receiver:",
            "        return self.receivers[stream_id]",
            "",
            "    def _make_request(self, event: HeadersReceived) -> Request:",
            "        headers = Header(((k.decode(), v.decode()) for k, v in event.headers))",
            "        method = headers[\":method\"]",
            "        path = headers[\":path\"]",
            "        scheme = headers.pop(\":scheme\", \"\")",
            "        authority = headers.pop(\":authority\", \"\")",
            "",
            "        if authority:",
            "            headers[\"host\"] = authority",
            "",
            "        transport = HTTP3Transport(self.protocol)",
            "        request = self.protocol.request_class(",
            "            path.encode(),",
            "            headers,",
            "            \"3\",",
            "            method,",
            "            transport,",
            "            self.protocol.app,",
            "            b\"\",",
            "        )",
            "        request.conn_info = ConnInfo(transport)",
            "        request._stream_id = event.stream_id",
            "        request._scheme = scheme",
            "",
            "        return request",
            "",
            "",
            "class SessionTicketStore:",
            "    \"\"\"",
            "    Simple in-memory store for session tickets.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        self.tickets: Dict[bytes, SessionTicket] = {}",
            "",
            "    def add(self, ticket: SessionTicket) -> None:",
            "        self.tickets[ticket.ticket] = ticket",
            "",
            "    def pop(self, label: bytes) -> Optional[SessionTicket]:",
            "        return self.tickets.pop(label, None)",
            "",
            "",
            "def get_config(",
            "    app: Sanic, ssl: Union[SanicSSLContext, CertSelector, SSLContext]",
            "):",
            "    # TODO:",
            "    # - proper selection needed if servince with multiple certs insted of",
            "    #   just taking the first",
            "    if isinstance(ssl, CertSelector):",
            "        ssl = cast(SanicSSLContext, ssl.sanic_select[0])",
            "    if app.config.LOCAL_CERT_CREATOR is LocalCertCreator.TRUSTME:",
            "        raise SanicException(",
            "            \"Sorry, you cannot currently use trustme as a local certificate \"",
            "            \"generator for an HTTP/3 server. This is not yet supported. You \"",
            "            \"should be able to use mkcert instead. For more information, see: \"",
            "            \"https://github.com/aiortc/aioquic/issues/295.\"",
            "        )",
            "    if not isinstance(ssl, CertSimple):",
            "        raise SanicException(\"SSLContext is not CertSimple\")",
            "",
            "    config = QuicConfiguration(",
            "        alpn_protocols=H3_ALPN + H0_ALPN + [\"siduck\"],",
            "        is_client=False,",
            "        max_datagram_frame_size=65536,",
            "    )",
            "    password = app.config.TLS_CERT_PASSWORD or None",
            "",
            "    config.load_cert_chain(",
            "        ssl.sanic[\"cert\"], ssl.sanic[\"key\"], password=password",
            "    )",
            "",
            "    return config"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "",
            "from abc import ABC, abstractmethod",
            "from ssl import SSLContext",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from sanic.compat import Header",
            "from sanic.constants import LocalCertCreator",
            "from sanic.exceptions import PayloadTooLarge, SanicException, ServerError",
            "from sanic.helpers import has_message_body",
            "from sanic.http.constants import Stage",
            "from sanic.http.stream import Stream",
            "from sanic.http.tls.context import CertSelector, CertSimple, SanicSSLContext",
            "from sanic.log import Colors, logger",
            "from sanic.models.protocol_types import TransportProtocol",
            "from sanic.models.server_types import ConnInfo",
            "",
            "",
            "try:",
            "    from aioquic.h0.connection import H0_ALPN, H0Connection",
            "    from aioquic.h3.connection import H3_ALPN, H3Connection",
            "    from aioquic.h3.events import (",
            "        DatagramReceived,",
            "        DataReceived,",
            "        H3Event,",
            "        HeadersReceived,",
            "        WebTransportStreamDataReceived,",
            "    )",
            "    from aioquic.quic.configuration import QuicConfiguration",
            "    from aioquic.tls import SessionTicket",
            "",
            "    HTTP3_AVAILABLE = True",
            "except ModuleNotFoundError:  # no cov",
            "    HTTP3_AVAILABLE = False",
            "",
            "if TYPE_CHECKING:",
            "    from sanic import Sanic",
            "    from sanic.request import Request",
            "    from sanic.response import BaseHTTPResponse",
            "    from sanic.server.protocols.http_protocol import Http3Protocol",
            "",
            "    HttpConnection = Union[H0Connection, H3Connection]",
            "",
            "",
            "class HTTP3Transport(TransportProtocol):",
            "    __slots__ = (\"_protocol\",)",
            "",
            "    def __init__(self, protocol: Http3Protocol):",
            "        self._protocol = protocol",
            "",
            "    def get_protocol(self) -> Http3Protocol:",
            "        return self._protocol",
            "",
            "    def get_extra_info(self, info: str, default: Any = None) -> Any:",
            "        if (",
            "            info in (\"socket\", \"sockname\", \"peername\")",
            "            and self._protocol._transport",
            "        ):",
            "            return self._protocol._transport.get_extra_info(info, default)",
            "        elif info == \"network_paths\":",
            "            return self._protocol._quic._network_paths",
            "        elif info == \"ssl_context\":",
            "            return self._protocol.app.state.ssl",
            "        return default",
            "",
            "",
            "class Receiver(ABC):",
            "    future: asyncio.Future",
            "",
            "    def __init__(self, transmit, protocol, request: Request) -> None:",
            "        self.transmit = transmit",
            "        self.protocol = protocol",
            "        self.request = request",
            "",
            "    @abstractmethod",
            "    async def run(self):  # no cov",
            "        ...",
            "",
            "",
            "class HTTPReceiver(Receiver, Stream):",
            "    stage: Stage",
            "    request: Request",
            "",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.request_body = None",
            "        self.stage = Stage.IDLE",
            "        self.headers_sent = False",
            "        self.response: Optional[BaseHTTPResponse] = None",
            "        self.request_max_size = self.protocol.request_max_size",
            "        self.request_bytes = 0",
            "",
            "    async def run(self, exception: Optional[Exception] = None):",
            "        self.stage = Stage.HANDLER",
            "        self.head_only = self.request.method.upper() == \"HEAD\"",
            "",
            "        if exception:",
            "            logger.info(  # no cov",
            "                f\"{Colors.BLUE}[exception]: \"",
            "                f\"{Colors.RED}{exception}{Colors.END}\",",
            "                exc_info=True,",
            "                extra={\"verbosity\": 1},",
            "            )",
            "            await self.error_response(exception)",
            "        else:",
            "            try:",
            "                logger.info(  # no cov",
            "                    f\"{Colors.BLUE}[request]:{Colors.END} {self.request}\",",
            "                    extra={\"verbosity\": 1},",
            "                )",
            "                await self.protocol.request_handler(self.request)",
            "            except Exception as e:  # no cov",
            "                # This should largely be handled within the request handler.",
            "                # But, just in case...",
            "                await self.run(e)",
            "        self.stage = Stage.IDLE",
            "",
            "    async def error_response(self, exception: Exception) -> None:",
            "        \"\"\"",
            "        Handle response when exception encountered",
            "        \"\"\"",
            "        # From request and handler states we can respond, otherwise be silent",
            "        app = self.protocol.app",
            "",
            "        await app.handle_exception(self.request, exception)",
            "",
            "    def _prepare_headers(",
            "        self, response: BaseHTTPResponse",
            "    ) -> List[Tuple[bytes, bytes]]:",
            "        size = len(response.body) if response.body else 0",
            "        headers = response.headers",
            "        status = response.status",
            "",
            "        if not has_message_body(status) and (",
            "            size",
            "            or \"content-length\" in headers",
            "            or \"transfer-encoding\" in headers",
            "        ):",
            "            headers.pop(\"content-length\", None)",
            "            headers.pop(\"transfer-encoding\", None)",
            "            logger.warning(  # no cov",
            "                f\"Message body set in response on {self.request.path}. \"",
            "                f\"A {status} response may only have headers, no body.\"",
            "            )",
            "        elif \"content-length\" not in headers:",
            "            if size:",
            "                headers[\"content-length\"] = size",
            "            else:",
            "                headers[\"transfer-encoding\"] = \"chunked\"",
            "",
            "        headers = [",
            "            (b\":status\", str(response.status).encode()),",
            "            *response.processed_headers,",
            "        ]",
            "        return headers",
            "",
            "    def send_headers(self) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[send]: {Colors.GREEN}HEADERS{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        if not self.response:",
            "            raise RuntimeError(\"no response\")",
            "",
            "        response = self.response",
            "        headers = self._prepare_headers(response)",
            "",
            "        self.protocol.connection.send_headers(",
            "            stream_id=self.request.stream_id,",
            "            headers=headers,",
            "        )",
            "        self.headers_sent = True",
            "        self.stage = Stage.RESPONSE",
            "",
            "        if self.response.body and not self.head_only:",
            "            self._send(self.response.body, False)",
            "        elif self.head_only:",
            "            self.future.cancel()",
            "",
            "    def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[respond]:{Colors.END} {response}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "",
            "        if self.stage is not Stage.HANDLER:",
            "            self.stage = Stage.FAILED",
            "            raise RuntimeError(\"Response already started\")",
            "",
            "        # Disconnect any earlier but unused response object",
            "        if self.response is not None:",
            "            self.response.stream = None",
            "",
            "        self.response, response.stream = response, self",
            "",
            "        return response",
            "",
            "    def receive_body(self, data: bytes) -> None:",
            "        self.request_bytes += len(data)",
            "        if self.request_bytes > self.request_max_size:",
            "            raise PayloadTooLarge(\"Request body exceeds the size limit\")",
            "",
            "        self.request.body += data",
            "",
            "    async def send(self, data: bytes, end_stream: bool) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[send]: {Colors.GREEN}data={data.decode()} \"",
            "            f\"end_stream={end_stream}{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        self._send(data, end_stream)",
            "",
            "    def _send(self, data: bytes, end_stream: bool) -> None:",
            "        if not self.headers_sent:",
            "            self.send_headers()",
            "        if self.stage is not Stage.RESPONSE:",
            "            raise ServerError(f\"not ready to send: {self.stage}\")",
            "",
            "        # Chunked",
            "        if (",
            "            self.response",
            "            and self.response.headers.get(\"transfer-encoding\") == \"chunked\"",
            "        ):",
            "            size = len(data)",
            "            if end_stream:",
            "                data = (",
            "                    b\"%x\\r\\n%b\\r\\n0\\r\\n\\r\\n\" % (size, data)",
            "                    if size",
            "                    else b\"0\\r\\n\\r\\n\"",
            "                )",
            "            elif size:",
            "                data = b\"%x\\r\\n%b\\r\\n\" % (size, data)",
            "",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[transmitting]{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        self.protocol.connection.send_data(",
            "            stream_id=self.request.stream_id,",
            "            data=data,",
            "            end_stream=end_stream,",
            "        )",
            "        self.transmit()",
            "",
            "        if end_stream:",
            "            self.stage = Stage.IDLE",
            "",
            "",
            "class WebsocketReceiver(Receiver):  # noqa",
            "    async def run(self):",
            "        ...",
            "",
            "",
            "class WebTransportReceiver(Receiver):  # noqa",
            "    async def run(self):",
            "        ...",
            "",
            "",
            "class Http3:",
            "    \"\"\"",
            "    Internal helper for managing the HTTP/3 request/response cycle",
            "    \"\"\"",
            "",
            "    if HTTP3_AVAILABLE:",
            "        HANDLER_PROPERTY_MAPPING = {",
            "            DataReceived: \"stream_id\",",
            "            HeadersReceived: \"stream_id\",",
            "            DatagramReceived: \"flow_id\",",
            "            WebTransportStreamDataReceived: \"session_id\",",
            "        }",
            "",
            "    def __init__(",
            "        self,",
            "        protocol: Http3Protocol,",
            "        transmit: Callable[[], None],",
            "    ) -> None:",
            "        self.protocol = protocol",
            "        self.transmit = transmit",
            "        self.receivers: Dict[int, Receiver] = {}",
            "",
            "    def http_event_received(self, event: H3Event) -> None:",
            "        logger.debug(  # no cov",
            "            f\"{Colors.BLUE}[http_event_received]: \"",
            "            f\"{Colors.YELLOW}{event}{Colors.END}\",",
            "            extra={\"verbosity\": 2},",
            "        )",
            "        receiver, created_new = self.get_or_make_receiver(event)",
            "        receiver = cast(HTTPReceiver, receiver)",
            "",
            "        if isinstance(event, HeadersReceived) and created_new:",
            "            receiver.future = asyncio.ensure_future(receiver.run())",
            "        elif isinstance(event, DataReceived):",
            "            try:",
            "                receiver.receive_body(event.data)",
            "            except Exception as e:",
            "                receiver.future.cancel()",
            "                receiver.future = asyncio.ensure_future(receiver.run(e))",
            "        else:",
            "            ...  # Intentionally here to help out Touchup",
            "            logger.debug(  # no cov",
            "                f\"{Colors.RED}DOING NOTHING{Colors.END}\",",
            "                extra={\"verbosity\": 2},",
            "            )",
            "",
            "    def get_or_make_receiver(self, event: H3Event) -> Tuple[Receiver, bool]:",
            "        if (",
            "            isinstance(event, HeadersReceived)",
            "            and event.stream_id not in self.receivers",
            "        ):",
            "            request = self._make_request(event)",
            "            receiver = HTTPReceiver(self.transmit, self.protocol, request)",
            "            request.stream = receiver",
            "",
            "            self.receivers[event.stream_id] = receiver",
            "            return receiver, True",
            "        else:",
            "            ident = getattr(event, self.HANDLER_PROPERTY_MAPPING[type(event)])",
            "            return self.receivers[ident], False",
            "",
            "    def get_receiver_by_stream_id(self, stream_id: int) -> Receiver:",
            "        return self.receivers[stream_id]",
            "",
            "    def _make_request(self, event: HeadersReceived) -> Request:",
            "        headers = Header(((k.decode(), v.decode()) for k, v in event.headers))",
            "        method = headers[\":method\"]",
            "        path = headers[\":path\"]",
            "        scheme = headers.pop(\":scheme\", \"\")",
            "        authority = headers.pop(\":authority\", \"\")",
            "",
            "        if authority:",
            "            headers[\"host\"] = authority",
            "",
            "        transport = HTTP3Transport(self.protocol)",
            "        request = self.protocol.request_class(",
            "            path.encode(),",
            "            headers,",
            "            \"3\",",
            "            method,",
            "            transport,",
            "            self.protocol.app,",
            "            b\"\",",
            "        )",
            "        request.conn_info = ConnInfo(transport)",
            "        request._stream_id = event.stream_id",
            "        request._scheme = scheme",
            "",
            "        return request",
            "",
            "",
            "class SessionTicketStore:",
            "    \"\"\"",
            "    Simple in-memory store for session tickets.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        self.tickets: Dict[bytes, SessionTicket] = {}",
            "",
            "    def add(self, ticket: SessionTicket) -> None:",
            "        self.tickets[ticket.ticket] = ticket",
            "",
            "    def pop(self, label: bytes) -> Optional[SessionTicket]:",
            "        return self.tickets.pop(label, None)",
            "",
            "",
            "def get_config(",
            "    app: Sanic, ssl: Union[SanicSSLContext, CertSelector, SSLContext]",
            "):",
            "    # TODO:",
            "    # - proper selection needed if service with multiple certs insted of",
            "    #   just taking the first",
            "    if isinstance(ssl, CertSelector):",
            "        ssl = cast(SanicSSLContext, ssl.sanic_select[0])",
            "    if app.config.LOCAL_CERT_CREATOR is LocalCertCreator.TRUSTME:",
            "        raise SanicException(",
            "            \"Sorry, you cannot currently use trustme as a local certificate \"",
            "            \"generator for an HTTP/3 server. This is not yet supported. You \"",
            "            \"should be able to use mkcert instead. For more information, see: \"",
            "            \"https://github.com/aiortc/aioquic/issues/295.\"",
            "        )",
            "    if not isinstance(ssl, CertSimple):",
            "        raise SanicException(\"SSLContext is not CertSimple\")",
            "",
            "    config = QuicConfiguration(",
            "        alpn_protocols=H3_ALPN + H0_ALPN + [\"siduck\"],",
            "        is_client=False,",
            "        max_datagram_frame_size=65536,",
            "    )",
            "    password = app.config.TLS_CERT_PASSWORD or None",
            "",
            "    config.load_cert_chain(",
            "        ssl.sanic[\"cert\"], ssl.sanic[\"key\"], password=password",
            "    )",
            "",
            "    return config"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "381": [
                "get_config"
            ]
        },
        "addLocation": []
    },
    "sanic/request.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     @classmethod"
            },
            "1": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     def get_current(cls) -> Request:"
            },
            "2": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Retrieve the currrent request object"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        Retrieve the current request object"
            },
            "5": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         This implements `Context Variables"
            },
            "7": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         <https://docs.python.org/3/library/contextvars.html>`_"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from contextvars import ContextVar",
            "from inspect import isawaitable",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    DefaultDict,",
            "    Dict,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "from sanic_routing.route import Route",
            "",
            "from sanic.http.constants import HTTP  # type: ignore",
            "from sanic.http.stream import Stream",
            "from sanic.models.asgi import ASGIScope",
            "from sanic.models.http_types import Credentials",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from sanic.server import ConnInfo",
            "    from sanic.app import Sanic",
            "",
            "import email.utils",
            "import uuid",
            "",
            "from collections import defaultdict",
            "from http.cookies import SimpleCookie",
            "from types import SimpleNamespace",
            "from urllib.parse import parse_qs, parse_qsl, unquote, urlunparse",
            "",
            "from httptools import parse_url",
            "from httptools.parser.errors import HttpParserInvalidURLError",
            "",
            "from sanic.compat import CancelledErrors, Header",
            "from sanic.constants import DEFAULT_HTTP_CONTENT_TYPE",
            "from sanic.exceptions import BadRequest, BadURL, ServerError",
            "from sanic.headers import (",
            "    AcceptContainer,",
            "    Options,",
            "    parse_accept,",
            "    parse_content_header,",
            "    parse_credentials,",
            "    parse_forwarded,",
            "    parse_host,",
            "    parse_xforwarded,",
            ")",
            "from sanic.http import Stage",
            "from sanic.log import error_logger, logger",
            "from sanic.models.protocol_types import TransportProtocol",
            "from sanic.response import BaseHTTPResponse, HTTPResponse",
            "",
            "",
            "try:",
            "    from ujson import loads as json_loads  # type: ignore",
            "except ImportError:",
            "    from json import loads as json_loads  # type: ignore",
            "",
            "",
            "class RequestParameters(dict):",
            "    \"\"\"",
            "    Hosts a dict with lists as values where get returns the first",
            "    value of the list and getlist returns the whole shebang",
            "    \"\"\"",
            "",
            "    def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:",
            "        \"\"\"Return the first value, either the default or actual\"\"\"",
            "        return super().get(name, [default])[0]",
            "",
            "    def getlist(",
            "        self, name: str, default: Optional[Any] = None",
            "    ) -> Optional[Any]:",
            "        \"\"\"",
            "        Return the entire list",
            "        \"\"\"",
            "        return super().get(name, default)",
            "",
            "",
            "class Request:",
            "    \"\"\"",
            "    Properties of an HTTP request such as URL, headers, etc.",
            "    \"\"\"",
            "",
            "    _current: ContextVar[Request] = ContextVar(\"request\")",
            "    _loads = json_loads",
            "",
            "    __slots__ = (",
            "        \"__weakref__\",",
            "        \"_cookies\",",
            "        \"_id\",",
            "        \"_ip\",",
            "        \"_parsed_url\",",
            "        \"_port\",",
            "        \"_protocol\",",
            "        \"_remote_addr\",",
            "        \"_scheme\",",
            "        \"_socket\",",
            "        \"_stream_id\",",
            "        \"_match_info\",",
            "        \"_name\",",
            "        \"app\",",
            "        \"body\",",
            "        \"conn_info\",",
            "        \"ctx\",",
            "        \"head\",",
            "        \"headers\",",
            "        \"method\",",
            "        \"parsed_accept\",",
            "        \"parsed_args\",",
            "        \"parsed_credentials\",",
            "        \"parsed_files\",",
            "        \"parsed_form\",",
            "        \"parsed_forwarded\",",
            "        \"parsed_json\",",
            "        \"parsed_not_grouped_args\",",
            "        \"parsed_token\",",
            "        \"raw_url\",",
            "        \"responded\",",
            "        \"request_middleware_started\",",
            "        \"route\",",
            "        \"stream\",",
            "        \"transport\",",
            "        \"version\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        url_bytes: bytes,",
            "        headers: Header,",
            "        version: str,",
            "        method: str,",
            "        transport: TransportProtocol,",
            "        app: Sanic,",
            "        head: bytes = b\"\",",
            "        stream_id: int = 0,",
            "    ):",
            "",
            "        self.raw_url = url_bytes",
            "        try:",
            "            self._parsed_url = parse_url(url_bytes)",
            "        except HttpParserInvalidURLError:",
            "            raise BadURL(f\"Bad URL: {url_bytes.decode()}\")",
            "        self._id: Optional[Union[uuid.UUID, str, int]] = None",
            "        self._name: Optional[str] = None",
            "        self._stream_id = stream_id",
            "        self.app = app",
            "",
            "        self.headers = Header(headers)",
            "        self.version = version",
            "        self.method = method",
            "        self.transport = transport",
            "        self.head = head",
            "",
            "        # Init but do not inhale",
            "        self.body = b\"\"",
            "        self.conn_info: Optional[ConnInfo] = None",
            "        self.ctx = SimpleNamespace()",
            "        self.parsed_forwarded: Optional[Options] = None",
            "        self.parsed_accept: Optional[AcceptContainer] = None",
            "        self.parsed_credentials: Optional[Credentials] = None",
            "        self.parsed_json = None",
            "        self.parsed_form: Optional[RequestParameters] = None",
            "        self.parsed_files: Optional[RequestParameters] = None",
            "        self.parsed_token: Optional[str] = None",
            "        self.parsed_args: DefaultDict[",
            "            Tuple[bool, bool, str, str], RequestParameters",
            "        ] = defaultdict(RequestParameters)",
            "        self.parsed_not_grouped_args: DefaultDict[",
            "            Tuple[bool, bool, str, str], List[Tuple[str, str]]",
            "        ] = defaultdict(list)",
            "        self.request_middleware_started = False",
            "        self.responded: bool = False",
            "        self.route: Optional[Route] = None",
            "        self.stream: Optional[Stream] = None",
            "        self._cookies: Optional[Dict[str, str]] = None",
            "        self._match_info: Dict[str, Any] = {}",
            "        self._protocol = None",
            "",
            "    def __repr__(self):",
            "        class_name = self.__class__.__name__",
            "        return f\"<{class_name}: {self.method} {self.path}>\"",
            "",
            "    @classmethod",
            "    def get_current(cls) -> Request:",
            "        \"\"\"",
            "        Retrieve the currrent request object",
            "",
            "        This implements `Context Variables",
            "        <https://docs.python.org/3/library/contextvars.html>`_",
            "        to allow for accessing the current request from anywhere.",
            "",
            "        Raises :exc:`sanic.exceptions.ServerError` if it is outside of",
            "        a request lifecycle.",
            "",
            "        .. code-block:: python",
            "",
            "            from sanic import Request",
            "",
            "            current_request = Request.get_current()",
            "",
            "        :return: the current :class:`sanic.request.Request`",
            "        \"\"\"",
            "        request = cls._current.get(None)",
            "        if not request:",
            "            raise ServerError(\"No current request\")",
            "        return request",
            "",
            "    @classmethod",
            "    def generate_id(*_):",
            "        return uuid.uuid4()",
            "",
            "    @property",
            "    def stream_id(self):",
            "        \"\"\"",
            "        Access the HTTP/3 stream ID.",
            "",
            "        Raises :exc:`sanic.exceptions.ServerError` if it is not an",
            "        HTTP/3 request.",
            "        \"\"\"",
            "        if self.protocol.version is not HTTP.VERSION_3:",
            "            raise ServerError(",
            "                \"Stream ID is only a property of a HTTP/3 request\"",
            "            )",
            "        return self._stream_id",
            "",
            "    def reset_response(self):",
            "        try:",
            "            if (",
            "                self.stream is not None",
            "                and self.stream.stage is not Stage.HANDLER",
            "            ):",
            "                raise ServerError(",
            "                    \"Cannot reset response because previous response was sent.\"",
            "                )",
            "            self.stream.response.stream = None",
            "            self.stream.response = None",
            "            self.responded = False",
            "        except AttributeError:",
            "            pass",
            "",
            "    async def respond(",
            "        self,",
            "        response: Optional[BaseHTTPResponse] = None,",
            "        *,",
            "        status: int = 200,",
            "        headers: Optional[Union[Header, Dict[str, str]]] = None,",
            "        content_type: Optional[str] = None,",
            "    ):",
            "        \"\"\"Respond to the request without returning.",
            "",
            "        This method can only be called once, as you can only respond once.",
            "        If no ``response`` argument is passed, one will be created from the",
            "        ``status``, ``headers`` and ``content_type`` arguments.",
            "",
            "        **The first typical usecase** is if you wish to respond to the",
            "        request without returning from the handler:",
            "",
            "        .. code-block:: python",
            "",
            "            @app.get(\"/\")",
            "            async def handler(request: Request):",
            "                data = ...  # Process something",
            "",
            "                json_response = json({\"data\": data})",
            "                await request.respond(json_response)",
            "",
            "                # You are now free to continue executing other code",
            "                ...",
            "",
            "            @app.on_response",
            "            async def add_header(_, response: HTTPResponse):",
            "                # Middlewares still get executed as expected",
            "                response.headers[\"one\"] = \"two\"",
            "",
            "        **The second possible usecase** is for when you want to directly",
            "        respond to the request:",
            "",
            "        .. code-block:: python",
            "",
            "            response = await request.respond(content_type=\"text/csv\")",
            "            await response.send(\"foo,\")",
            "            await response.send(\"bar\")",
            "",
            "            # You can control the completion of the response by calling",
            "            # the 'eof()' method:",
            "            await response.eof()",
            "",
            "        :param response: response instance to send",
            "        :param status: status code to return in the response",
            "        :param headers: headers to return in the response",
            "        :param content_type: Content-Type header of the response",
            "        :return: final response being sent (may be different from the",
            "            ``response`` parameter because of middlewares) which can be",
            "            used to manually send data",
            "        \"\"\"",
            "        try:",
            "            if self.stream is not None and self.stream.response:",
            "                raise ServerError(\"Second respond call is not allowed.\")",
            "        except AttributeError:",
            "            pass",
            "        # This logic of determining which response to use is subject to change",
            "        if response is None:",
            "            response = HTTPResponse(",
            "                status=status,",
            "                headers=headers,",
            "                content_type=content_type,",
            "            )",
            "",
            "        # Connect the response",
            "        if isinstance(response, BaseHTTPResponse) and self.stream:",
            "            response = self.stream.respond(response)",
            "",
            "            if isawaitable(response):",
            "                response = await response  # type: ignore",
            "        # Run response middleware",
            "        try:",
            "            response = await self.app._run_response_middleware(",
            "                self, response, request_name=self.name",
            "            )",
            "        except CancelledErrors:",
            "            raise",
            "        except Exception:",
            "            error_logger.exception(",
            "                \"Exception occurred in one of response middleware handlers\"",
            "            )",
            "        self.responded = True",
            "        return response",
            "",
            "    async def receive_body(self):",
            "        \"\"\"Receive request.body, if not already received.",
            "",
            "        Streaming handlers may call this to receive the full body. Sanic calls",
            "        this function before running any handlers of non-streaming routes.",
            "",
            "        Custom request classes can override this for custom handling of both",
            "        streaming and non-streaming routes.",
            "        \"\"\"",
            "        if not self.body:",
            "            self.body = b\"\".join([data async for data in self.stream])",
            "",
            "    @property",
            "    def name(self) -> Optional[str]:",
            "        \"\"\"",
            "        The route name",
            "",
            "        In the following pattern:",
            "",
            "        .. code-block::",
            "",
            "            <AppName>.[<BlueprintName>.]<HandlerName>",
            "",
            "        :return: Route name",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        if self._name:",
            "            return self._name",
            "        elif self.route:",
            "            return self.route.name",
            "        return None",
            "",
            "    @property",
            "    def endpoint(self) -> Optional[str]:",
            "        \"\"\"",
            "        :return: Alias of :attr:`sanic.request.Request.name`",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        return self.name",
            "",
            "    @property",
            "    def uri_template(self) -> Optional[str]:",
            "        \"\"\"",
            "        :return: The defined URI template",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        if self.route:",
            "            return f\"/{self.route.path}\"",
            "        return None",
            "",
            "    @property",
            "    def protocol(self):",
            "        \"\"\"",
            "        :return: The HTTP protocol instance",
            "        \"\"\"",
            "        if not self._protocol:",
            "            self._protocol = self.transport.get_protocol()",
            "        return self._protocol",
            "",
            "    @property",
            "    def raw_headers(self) -> bytes:",
            "        \"\"\"",
            "        :return: The unparsed HTTP headers",
            "        :rtype: bytes",
            "        \"\"\"",
            "        _, headers = self.head.split(b\"\\r\\n\", 1)",
            "        return bytes(headers)",
            "",
            "    @property",
            "    def request_line(self) -> bytes:",
            "        \"\"\"",
            "        :return: The first line of a HTTP request",
            "        :rtype: bytes",
            "        \"\"\"",
            "        reqline, _ = self.head.split(b\"\\r\\n\", 1)",
            "        return bytes(reqline)",
            "",
            "    @property",
            "    def id(self) -> Optional[Union[uuid.UUID, str, int]]:",
            "        \"\"\"",
            "        A request ID passed from the client, or generated from the backend.",
            "",
            "        By default, this will look in a request header defined at:",
            "        ``self.app.config.REQUEST_ID_HEADER``. It defaults to",
            "        ``X-Request-ID``. Sanic will try to cast the ID into a ``UUID`` or an",
            "        ``int``. If there is not a UUID from the client, then Sanic will try",
            "        to generate an ID by calling ``Request.generate_id()``. The default",
            "        behavior is to generate a ``UUID``. You can customize this behavior",
            "        by subclassing ``Request``.",
            "",
            "        .. code-block:: python",
            "",
            "            from sanic import Request, Sanic",
            "            from itertools import count",
            "",
            "            class IntRequest(Request):",
            "                counter = count()",
            "",
            "                def generate_id(self):",
            "                    return next(self.counter)",
            "",
            "            app = Sanic(\"MyApp\", request_class=IntRequest)",
            "        \"\"\"",
            "        if not self._id:",
            "            self._id = self.headers.getone(",
            "                self.app.config.REQUEST_ID_HEADER,",
            "                self.__class__.generate_id(self),  # type: ignore",
            "            )",
            "",
            "            # Try casting to a UUID or an integer",
            "            if isinstance(self._id, str):",
            "                try:",
            "                    self._id = uuid.UUID(self._id)",
            "                except ValueError:",
            "                    try:",
            "                        self._id = int(self._id)  # type: ignore",
            "                    except ValueError:",
            "                        ...",
            "",
            "        return self._id  # type: ignore",
            "",
            "    @property",
            "    def json(self) -> Any:",
            "        \"\"\"",
            "        :return: The request body parsed as JSON",
            "        :rtype: Any",
            "        \"\"\"",
            "        if self.parsed_json is None:",
            "            self.load_json()",
            "",
            "        return self.parsed_json",
            "",
            "    def load_json(self, loads=None):",
            "        try:",
            "            if not loads:",
            "                loads = self.__class__._loads",
            "",
            "            self.parsed_json = loads(self.body)",
            "        except Exception:",
            "            if not self.body:",
            "                return None",
            "            raise BadRequest(\"Failed when parsing body as json\")",
            "",
            "        return self.parsed_json",
            "",
            "    @property",
            "    def accept(self) -> AcceptContainer:",
            "        \"\"\"",
            "        :return: The ``Accept`` header parsed",
            "        :rtype: AcceptContainer",
            "        \"\"\"",
            "        if self.parsed_accept is None:",
            "            accept_header = self.headers.getone(\"accept\", \"\")",
            "            self.parsed_accept = parse_accept(accept_header)",
            "        return self.parsed_accept",
            "",
            "    @property",
            "    def token(self) -> Optional[str]:",
            "        \"\"\"Attempt to return the auth header token.",
            "",
            "        :return: token related to request",
            "        \"\"\"",
            "        if self.parsed_token is None:",
            "            prefixes = (\"Bearer\", \"Token\")",
            "            _, token = parse_credentials(",
            "                self.headers.getone(\"authorization\", None), prefixes",
            "            )",
            "            self.parsed_token = token",
            "        return self.parsed_token",
            "",
            "    @property",
            "    def credentials(self) -> Optional[Credentials]:",
            "        \"\"\"Attempt to return the auth header value.",
            "",
            "        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication",
            "        schemas.",
            "",
            "        :return: A Credentials object with token, or username and password",
            "                 related to the request",
            "        \"\"\"",
            "        if self.parsed_credentials is None:",
            "            try:",
            "                prefix, credentials = parse_credentials(",
            "                    self.headers.getone(\"authorization\", None)",
            "                )",
            "                if credentials:",
            "                    self.parsed_credentials = Credentials(",
            "                        auth_type=prefix, token=credentials",
            "                    )",
            "            except ValueError:",
            "                pass",
            "        return self.parsed_credentials",
            "",
            "    def get_form(",
            "        self, keep_blank_values: bool = False",
            "    ) -> Optional[RequestParameters]:",
            "        \"\"\"",
            "        Method to extract and parse the form data from a request.",
            "",
            "        :param keep_blank_values:",
            "            Whether to discard blank values from the form data",
            "        :type keep_blank_values: bool",
            "        :return: the parsed form data",
            "        :rtype: Optional[RequestParameters]",
            "        \"\"\"",
            "        self.parsed_form = RequestParameters()",
            "        self.parsed_files = RequestParameters()",
            "        content_type = self.headers.getone(",
            "            \"content-type\", DEFAULT_HTTP_CONTENT_TYPE",
            "        )",
            "        content_type, parameters = parse_content_header(content_type)",
            "        try:",
            "            if content_type == \"application/x-www-form-urlencoded\":",
            "                self.parsed_form = RequestParameters(",
            "                    parse_qs(",
            "                        self.body.decode(\"utf-8\"),",
            "                        keep_blank_values=keep_blank_values,",
            "                    )",
            "                )",
            "            elif content_type == \"multipart/form-data\":",
            "                # TODO: Stream this instead of reading to/from memory",
            "                boundary = parameters[\"boundary\"].encode(  # type: ignore",
            "                    \"utf-8\"",
            "                )  # type: ignore",
            "                self.parsed_form, self.parsed_files = parse_multipart_form(",
            "                    self.body, boundary",
            "                )",
            "        except Exception:",
            "            error_logger.exception(\"Failed when parsing form\")",
            "",
            "        return self.parsed_form",
            "",
            "    @property",
            "    def form(self):",
            "        \"\"\"",
            "        :return: The request body parsed as form data",
            "        \"\"\"",
            "        if self.parsed_form is None:",
            "            self.get_form()",
            "",
            "        return self.parsed_form",
            "",
            "    @property",
            "    def files(self):",
            "        \"\"\"",
            "        :return: The request body parsed as uploaded files",
            "        \"\"\"",
            "        if self.parsed_files is None:",
            "            self.form  # compute form to get files",
            "",
            "        return self.parsed_files",
            "",
            "    def get_args(",
            "        self,",
            "        keep_blank_values: bool = False,",
            "        strict_parsing: bool = False,",
            "        encoding: str = \"utf-8\",",
            "        errors: str = \"replace\",",
            "    ) -> RequestParameters:",
            "        \"\"\"",
            "        Method to parse ``query_string`` using ``urllib.parse.parse_qs``.",
            "        This methods is used by ``args`` property.",
            "        Can be used directly if you need to change default parameters.",
            "",
            "        :param keep_blank_values:",
            "            flag indicating whether blank values in",
            "            percent-encoded queries should be treated as blank strings.",
            "            A true value indicates that blanks should be retained as blank",
            "            strings.  The default false value indicates that blank values",
            "            are to be ignored and treated as if they were  not included.",
            "        :type keep_blank_values: bool",
            "        :param strict_parsing:",
            "            flag indicating what to do with parsing errors.",
            "            If false (the default), errors are silently ignored. If true,",
            "            errors raise a ValueError exception.",
            "        :type strict_parsing: bool",
            "        :param encoding:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type encoding: str",
            "        :param errors:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type errors: str",
            "        :return: RequestParameters",
            "        \"\"\"",
            "        if (",
            "            keep_blank_values,",
            "            strict_parsing,",
            "            encoding,",
            "            errors,",
            "        ) not in self.parsed_args:",
            "            if self.query_string:",
            "                self.parsed_args[",
            "                    (keep_blank_values, strict_parsing, encoding, errors)",
            "                ] = RequestParameters(",
            "                    parse_qs(",
            "                        qs=self.query_string,",
            "                        keep_blank_values=keep_blank_values,",
            "                        strict_parsing=strict_parsing,",
            "                        encoding=encoding,",
            "                        errors=errors,",
            "                    )",
            "                )",
            "",
            "        return self.parsed_args[",
            "            (keep_blank_values, strict_parsing, encoding, errors)",
            "        ]",
            "",
            "    args = property(get_args)",
            "    \"\"\"",
            "    Convenience property to access :meth:`Request.get_args` with",
            "    default values.",
            "    \"\"\"",
            "",
            "    def get_query_args(",
            "        self,",
            "        keep_blank_values: bool = False,",
            "        strict_parsing: bool = False,",
            "        encoding: str = \"utf-8\",",
            "        errors: str = \"replace\",",
            "    ) -> list:",
            "        \"\"\"",
            "        Method to parse `query_string` using `urllib.parse.parse_qsl`.",
            "        This methods is used by `query_args` property.",
            "        Can be used directly if you need to change default parameters.",
            "",
            "        :param keep_blank_values:",
            "            flag indicating whether blank values in",
            "            percent-encoded queries should be treated as blank strings.",
            "            A true value indicates that blanks should be retained as blank",
            "            strings.  The default false value indicates that blank values",
            "            are to be ignored and treated as if they were  not included.",
            "        :type keep_blank_values: bool",
            "        :param strict_parsing:",
            "            flag indicating what to do with parsing errors.",
            "            If false (the default), errors are silently ignored. If true,",
            "            errors raise a ValueError exception.",
            "        :type strict_parsing: bool",
            "        :param encoding:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type encoding: str",
            "        :param errors:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type errors: str",
            "        :return: list",
            "        \"\"\"",
            "        if (",
            "            keep_blank_values,",
            "            strict_parsing,",
            "            encoding,",
            "            errors,",
            "        ) not in self.parsed_not_grouped_args:",
            "            if self.query_string:",
            "                self.parsed_not_grouped_args[",
            "                    (keep_blank_values, strict_parsing, encoding, errors)",
            "                ] = parse_qsl(",
            "                    qs=self.query_string,",
            "                    keep_blank_values=keep_blank_values,",
            "                    strict_parsing=strict_parsing,",
            "                    encoding=encoding,",
            "                    errors=errors,",
            "                )",
            "        return self.parsed_not_grouped_args[",
            "            (keep_blank_values, strict_parsing, encoding, errors)",
            "        ]",
            "",
            "    query_args = property(get_query_args)",
            "    \"\"\"",
            "    Convenience property to access :meth:`Request.get_query_args` with",
            "    default values.",
            "    \"\"\"",
            "",
            "    @property",
            "    def cookies(self) -> Dict[str, str]:",
            "        \"\"\"",
            "        :return: Incoming cookies on the request",
            "        :rtype: Dict[str, str]",
            "        \"\"\"",
            "",
            "        if self._cookies is None:",
            "            cookie = self.headers.getone(\"cookie\", None)",
            "            if cookie is not None:",
            "                cookies: SimpleCookie = SimpleCookie()",
            "                cookies.load(cookie)",
            "                self._cookies = {",
            "                    name: cookie.value for name, cookie in cookies.items()",
            "                }",
            "            else:",
            "                self._cookies = {}",
            "        return self._cookies",
            "",
            "    @property",
            "    def content_type(self) -> str:",
            "        \"\"\"",
            "        :return: Content-Type header form the request",
            "        :rtype: str",
            "        \"\"\"",
            "        return self.headers.getone(\"content-type\", DEFAULT_HTTP_CONTENT_TYPE)",
            "",
            "    @property",
            "    def match_info(self):",
            "        \"\"\"",
            "        :return: matched info after resolving route",
            "        \"\"\"",
            "        return self._match_info",
            "",
            "    @match_info.setter",
            "    def match_info(self, value):",
            "        self._match_info = value",
            "",
            "    # Transport properties (obtained from local interface only)",
            "",
            "    @property",
            "    def ip(self) -> str:",
            "        \"\"\"",
            "        :return: peer ip of the socket",
            "        :rtype: str",
            "        \"\"\"",
            "        return self.conn_info.client_ip if self.conn_info else \"\"",
            "",
            "    @property",
            "    def port(self) -> int:",
            "        \"\"\"",
            "        :return: peer port of the socket",
            "        :rtype: int",
            "        \"\"\"",
            "        return self.conn_info.client_port if self.conn_info else 0",
            "",
            "    @property",
            "    def socket(self):",
            "        \"\"\"",
            "        :return: Information about the connected socket if available",
            "        \"\"\"",
            "        return self.conn_info.peername if self.conn_info else (None, None)",
            "",
            "    @property",
            "    def path(self) -> str:",
            "        \"\"\"",
            "        :return: path of the local HTTP request",
            "        :rtype: str",
            "        \"\"\"",
            "        return self._parsed_url.path.decode(\"utf-8\")",
            "",
            "    @property",
            "    def network_paths(self):",
            "        \"\"\"",
            "        Access the network paths if available",
            "        \"\"\"",
            "        return self.conn_info.network_paths",
            "",
            "    # Proxy properties (using SERVER_NAME/forwarded/request/transport info)",
            "",
            "    @property",
            "    def forwarded(self) -> Options:",
            "        \"\"\"",
            "        Active proxy information obtained from request headers, as specified in",
            "        Sanic configuration.",
            "",
            "        Field names by, for, proto, host, port and path are normalized.",
            "        - for and by IPv6 addresses are bracketed",
            "        - port (int) is only set by port headers, not from host.",
            "        - path is url-unencoded",
            "",
            "        Additional values may be available from new style Forwarded headers.",
            "",
            "        :return: forwarded address info",
            "        :rtype: Dict[str, str]",
            "        \"\"\"",
            "        if self.parsed_forwarded is None:",
            "            self.parsed_forwarded = (",
            "                parse_forwarded(self.headers, self.app.config)",
            "                or parse_xforwarded(self.headers, self.app.config)",
            "                or {}",
            "            )",
            "        return self.parsed_forwarded",
            "",
            "    @property",
            "    def remote_addr(self) -> str:",
            "        \"\"\"",
            "        Client IP address, if available.",
            "        1. proxied remote address `self.forwarded['for']`",
            "        2. local remote address `self.ip`",
            "",
            "        :return: IPv4, bracketed IPv6, UNIX socket name or arbitrary string",
            "        :rtype: str",
            "        \"\"\"",
            "        if not hasattr(self, \"_remote_addr\"):",
            "            self._remote_addr = str(",
            "                self.forwarded.get(\"for\", \"\")",
            "            )  # or self.ip",
            "        return self._remote_addr",
            "",
            "    @property",
            "    def scheme(self) -> str:",
            "        \"\"\"",
            "        Determine request scheme.",
            "        1. `config.SERVER_NAME` if in full URL format",
            "        2. proxied proto/scheme",
            "        3. local connection protocol",
            "",
            "        :return: http|https|ws|wss or arbitrary value given by the headers.",
            "        :rtype: str",
            "        \"\"\"",
            "        if not hasattr(self, \"_scheme\"):",
            "            if \"//\" in self.app.config.get(\"SERVER_NAME\", \"\"):",
            "                return self.app.config.SERVER_NAME.split(\"//\")[0]",
            "            if \"proto\" in self.forwarded:",
            "                return str(self.forwarded[\"proto\"])",
            "",
            "            if (",
            "                self.app.websocket_enabled",
            "                and self.headers.getone(\"upgrade\", \"\").lower() == \"websocket\"",
            "            ):",
            "                scheme = \"ws\"",
            "            else:",
            "                scheme = \"http\"",
            "",
            "            if self.transport.get_extra_info(\"sslcontext\"):",
            "                scheme += \"s\"",
            "            self._scheme = scheme",
            "",
            "        return self._scheme",
            "",
            "    @property",
            "    def host(self) -> str:",
            "        \"\"\"",
            "        The currently effective server 'host' (hostname or hostname:port).",
            "        1. `config.SERVER_NAME` overrides any client headers",
            "        2. proxied host of original request",
            "        3. request host header",
            "        hostname and port may be separated by",
            "        `sanic.headers.parse_host(request.host)`.",
            "",
            "        :return: the first matching host found, or empty string",
            "        :rtype: str",
            "        \"\"\"",
            "        server_name = self.app.config.get(\"SERVER_NAME\")",
            "        if server_name:",
            "            return server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]",
            "        return str(",
            "            self.forwarded.get(\"host\") or self.headers.getone(\"host\", \"\")",
            "        )",
            "",
            "    @property",
            "    def server_name(self) -> str:",
            "        \"\"\"",
            "        :return: hostname the client connected to, by ``request.host``",
            "        :rtype: str",
            "        \"\"\"",
            "        return parse_host(self.host)[0] or \"\"",
            "",
            "    @property",
            "    def server_port(self) -> int:",
            "        \"\"\"",
            "        The port the client connected to, by forwarded ``port`` or",
            "        ``request.host``.",
            "",
            "        Default port is returned as 80 and 443 based on ``request.scheme``.",
            "",
            "        :return: port number",
            "        :rtype: int",
            "        \"\"\"",
            "        port = self.forwarded.get(\"port\") or parse_host(self.host)[1]",
            "        return int(port or (80 if self.scheme in (\"http\", \"ws\") else 443))",
            "",
            "    @property",
            "    def server_path(self) -> str:",
            "        \"\"\"",
            "        :return: full path of current URL; uses proxied or local path",
            "        :rtype: str",
            "        \"\"\"",
            "        return str(self.forwarded.get(\"path\") or self.path)",
            "",
            "    @property",
            "    def query_string(self) -> str:",
            "        \"\"\"",
            "        :return: representation of the requested query",
            "        :rtype: str",
            "        \"\"\"",
            "        if self._parsed_url.query:",
            "            return self._parsed_url.query.decode(\"utf-8\")",
            "        else:",
            "            return \"\"",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        \"\"\"",
            "        :return: the URL",
            "        :rtype: str",
            "        \"\"\"",
            "        return urlunparse(",
            "            (self.scheme, self.host, self.path, None, self.query_string, None)",
            "        )",
            "",
            "    def url_for(self, view_name: str, **kwargs) -> str:",
            "        \"\"\"",
            "        Same as :func:`sanic.Sanic.url_for`, but automatically determine",
            "        `scheme` and `netloc` base on the request. Since this method is aiming",
            "        to generate correct schema & netloc, `_external` is implied.",
            "",
            "        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`",
            "        :return: an absolute url to the given view",
            "        :rtype: str",
            "        \"\"\"",
            "        # Full URL SERVER_NAME can only be handled in app.url_for",
            "        try:",
            "            if \"//\" in self.app.config.SERVER_NAME:",
            "                return self.app.url_for(view_name, _external=True, **kwargs)",
            "        except AttributeError:",
            "            pass",
            "",
            "        scheme = self.scheme",
            "        host = self.server_name",
            "        port = self.server_port",
            "",
            "        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (",
            "            scheme.lower() in (\"https\", \"wss\") and port == 443",
            "        ):",
            "            netloc = host",
            "        else:",
            "            netloc = f\"{host}:{port}\"",
            "",
            "        return self.app.url_for(",
            "            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs",
            "        )",
            "",
            "    @property",
            "    def scope(self) -> ASGIScope:",
            "        \"\"\"",
            "        :return: The ASGI scope of the request.",
            "                 If the app isn't an ASGI app, then raises an exception.",
            "        :rtype: Optional[ASGIScope]",
            "        \"\"\"",
            "        if not self.app.asgi:",
            "            raise NotImplementedError(",
            "                \"App isn't running in ASGI mode. \"",
            "                \"Scope is only available for ASGI apps.\"",
            "            )",
            "",
            "        return self.transport.scope",
            "",
            "",
            "class File(NamedTuple):",
            "    \"\"\"",
            "    Model for defining a file. It is a ``namedtuple``, therefore you can",
            "    iterate over the object, or access the parameters by name.",
            "",
            "    :param type: The mimetype, defaults to text/plain",
            "    :param body: Bytes of the file",
            "    :param name: The filename",
            "    \"\"\"",
            "",
            "    type: str",
            "    body: bytes",
            "    name: str",
            "",
            "",
            "def parse_multipart_form(body, boundary):",
            "    \"\"\"",
            "    Parse a request body and returns fields and files",
            "",
            "    :param body: bytes request body",
            "    :param boundary: bytes multipart boundary",
            "    :return: fields (RequestParameters), files (RequestParameters)",
            "    \"\"\"",
            "    files = RequestParameters()",
            "    fields = RequestParameters()",
            "",
            "    form_parts = body.split(boundary)",
            "    for form_part in form_parts[1:-1]:",
            "        file_name = None",
            "        content_type = \"text/plain\"",
            "        content_charset = \"utf-8\"",
            "        field_name = None",
            "        line_index = 2",
            "        line_end_index = 0",
            "        while not line_end_index == -1:",
            "            line_end_index = form_part.find(b\"\\r\\n\", line_index)",
            "            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")",
            "            line_index = line_end_index + 2",
            "",
            "            if not form_line:",
            "                break",
            "",
            "            colon_index = form_line.index(\":\")",
            "            idx = colon_index + 2",
            "            form_header_field = form_line[0:colon_index].lower()",
            "            form_header_value, form_parameters = parse_content_header(",
            "                form_line[idx:]",
            "            )",
            "",
            "            if form_header_field == \"content-disposition\":",
            "                field_name = form_parameters.get(\"name\")",
            "                file_name = form_parameters.get(\"filename\")",
            "",
            "                # non-ASCII filenames in RFC2231, \"filename*\" format",
            "                if file_name is None and form_parameters.get(\"filename*\"):",
            "                    encoding, _, value = email.utils.decode_rfc2231(",
            "                        form_parameters[\"filename*\"]",
            "                    )",
            "                    file_name = unquote(value, encoding=encoding)",
            "            elif form_header_field == \"content-type\":",
            "                content_type = form_header_value",
            "                content_charset = form_parameters.get(\"charset\", \"utf-8\")",
            "",
            "        if field_name:",
            "            post_data = form_part[line_index:-4]",
            "            if file_name is None:",
            "                value = post_data.decode(content_charset)",
            "                if field_name in fields:",
            "                    fields[field_name].append(value)",
            "                else:",
            "                    fields[field_name] = [value]",
            "            else:",
            "                form_file = File(",
            "                    type=content_type, name=file_name, body=post_data",
            "                )",
            "                if field_name in files:",
            "                    files[field_name].append(form_file)",
            "                else:",
            "                    files[field_name] = [form_file]",
            "        else:",
            "            logger.debug(",
            "                \"Form-data field does not have a 'name' parameter \"",
            "                \"in the Content-Disposition header\"",
            "            )",
            "",
            "    return fields, files"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from contextvars import ContextVar",
            "from inspect import isawaitable",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    DefaultDict,",
            "    Dict,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "from sanic_routing.route import Route",
            "",
            "from sanic.http.constants import HTTP  # type: ignore",
            "from sanic.http.stream import Stream",
            "from sanic.models.asgi import ASGIScope",
            "from sanic.models.http_types import Credentials",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from sanic.server import ConnInfo",
            "    from sanic.app import Sanic",
            "",
            "import email.utils",
            "import uuid",
            "",
            "from collections import defaultdict",
            "from http.cookies import SimpleCookie",
            "from types import SimpleNamespace",
            "from urllib.parse import parse_qs, parse_qsl, unquote, urlunparse",
            "",
            "from httptools import parse_url",
            "from httptools.parser.errors import HttpParserInvalidURLError",
            "",
            "from sanic.compat import CancelledErrors, Header",
            "from sanic.constants import DEFAULT_HTTP_CONTENT_TYPE",
            "from sanic.exceptions import BadRequest, BadURL, ServerError",
            "from sanic.headers import (",
            "    AcceptContainer,",
            "    Options,",
            "    parse_accept,",
            "    parse_content_header,",
            "    parse_credentials,",
            "    parse_forwarded,",
            "    parse_host,",
            "    parse_xforwarded,",
            ")",
            "from sanic.http import Stage",
            "from sanic.log import error_logger, logger",
            "from sanic.models.protocol_types import TransportProtocol",
            "from sanic.response import BaseHTTPResponse, HTTPResponse",
            "",
            "",
            "try:",
            "    from ujson import loads as json_loads  # type: ignore",
            "except ImportError:",
            "    from json import loads as json_loads  # type: ignore",
            "",
            "",
            "class RequestParameters(dict):",
            "    \"\"\"",
            "    Hosts a dict with lists as values where get returns the first",
            "    value of the list and getlist returns the whole shebang",
            "    \"\"\"",
            "",
            "    def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:",
            "        \"\"\"Return the first value, either the default or actual\"\"\"",
            "        return super().get(name, [default])[0]",
            "",
            "    def getlist(",
            "        self, name: str, default: Optional[Any] = None",
            "    ) -> Optional[Any]:",
            "        \"\"\"",
            "        Return the entire list",
            "        \"\"\"",
            "        return super().get(name, default)",
            "",
            "",
            "class Request:",
            "    \"\"\"",
            "    Properties of an HTTP request such as URL, headers, etc.",
            "    \"\"\"",
            "",
            "    _current: ContextVar[Request] = ContextVar(\"request\")",
            "    _loads = json_loads",
            "",
            "    __slots__ = (",
            "        \"__weakref__\",",
            "        \"_cookies\",",
            "        \"_id\",",
            "        \"_ip\",",
            "        \"_parsed_url\",",
            "        \"_port\",",
            "        \"_protocol\",",
            "        \"_remote_addr\",",
            "        \"_scheme\",",
            "        \"_socket\",",
            "        \"_stream_id\",",
            "        \"_match_info\",",
            "        \"_name\",",
            "        \"app\",",
            "        \"body\",",
            "        \"conn_info\",",
            "        \"ctx\",",
            "        \"head\",",
            "        \"headers\",",
            "        \"method\",",
            "        \"parsed_accept\",",
            "        \"parsed_args\",",
            "        \"parsed_credentials\",",
            "        \"parsed_files\",",
            "        \"parsed_form\",",
            "        \"parsed_forwarded\",",
            "        \"parsed_json\",",
            "        \"parsed_not_grouped_args\",",
            "        \"parsed_token\",",
            "        \"raw_url\",",
            "        \"responded\",",
            "        \"request_middleware_started\",",
            "        \"route\",",
            "        \"stream\",",
            "        \"transport\",",
            "        \"version\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        url_bytes: bytes,",
            "        headers: Header,",
            "        version: str,",
            "        method: str,",
            "        transport: TransportProtocol,",
            "        app: Sanic,",
            "        head: bytes = b\"\",",
            "        stream_id: int = 0,",
            "    ):",
            "",
            "        self.raw_url = url_bytes",
            "        try:",
            "            self._parsed_url = parse_url(url_bytes)",
            "        except HttpParserInvalidURLError:",
            "            raise BadURL(f\"Bad URL: {url_bytes.decode()}\")",
            "        self._id: Optional[Union[uuid.UUID, str, int]] = None",
            "        self._name: Optional[str] = None",
            "        self._stream_id = stream_id",
            "        self.app = app",
            "",
            "        self.headers = Header(headers)",
            "        self.version = version",
            "        self.method = method",
            "        self.transport = transport",
            "        self.head = head",
            "",
            "        # Init but do not inhale",
            "        self.body = b\"\"",
            "        self.conn_info: Optional[ConnInfo] = None",
            "        self.ctx = SimpleNamespace()",
            "        self.parsed_forwarded: Optional[Options] = None",
            "        self.parsed_accept: Optional[AcceptContainer] = None",
            "        self.parsed_credentials: Optional[Credentials] = None",
            "        self.parsed_json = None",
            "        self.parsed_form: Optional[RequestParameters] = None",
            "        self.parsed_files: Optional[RequestParameters] = None",
            "        self.parsed_token: Optional[str] = None",
            "        self.parsed_args: DefaultDict[",
            "            Tuple[bool, bool, str, str], RequestParameters",
            "        ] = defaultdict(RequestParameters)",
            "        self.parsed_not_grouped_args: DefaultDict[",
            "            Tuple[bool, bool, str, str], List[Tuple[str, str]]",
            "        ] = defaultdict(list)",
            "        self.request_middleware_started = False",
            "        self.responded: bool = False",
            "        self.route: Optional[Route] = None",
            "        self.stream: Optional[Stream] = None",
            "        self._cookies: Optional[Dict[str, str]] = None",
            "        self._match_info: Dict[str, Any] = {}",
            "        self._protocol = None",
            "",
            "    def __repr__(self):",
            "        class_name = self.__class__.__name__",
            "        return f\"<{class_name}: {self.method} {self.path}>\"",
            "",
            "    @classmethod",
            "    def get_current(cls) -> Request:",
            "        \"\"\"",
            "        Retrieve the current request object",
            "",
            "        This implements `Context Variables",
            "        <https://docs.python.org/3/library/contextvars.html>`_",
            "        to allow for accessing the current request from anywhere.",
            "",
            "        Raises :exc:`sanic.exceptions.ServerError` if it is outside of",
            "        a request lifecycle.",
            "",
            "        .. code-block:: python",
            "",
            "            from sanic import Request",
            "",
            "            current_request = Request.get_current()",
            "",
            "        :return: the current :class:`sanic.request.Request`",
            "        \"\"\"",
            "        request = cls._current.get(None)",
            "        if not request:",
            "            raise ServerError(\"No current request\")",
            "        return request",
            "",
            "    @classmethod",
            "    def generate_id(*_):",
            "        return uuid.uuid4()",
            "",
            "    @property",
            "    def stream_id(self):",
            "        \"\"\"",
            "        Access the HTTP/3 stream ID.",
            "",
            "        Raises :exc:`sanic.exceptions.ServerError` if it is not an",
            "        HTTP/3 request.",
            "        \"\"\"",
            "        if self.protocol.version is not HTTP.VERSION_3:",
            "            raise ServerError(",
            "                \"Stream ID is only a property of a HTTP/3 request\"",
            "            )",
            "        return self._stream_id",
            "",
            "    def reset_response(self):",
            "        try:",
            "            if (",
            "                self.stream is not None",
            "                and self.stream.stage is not Stage.HANDLER",
            "            ):",
            "                raise ServerError(",
            "                    \"Cannot reset response because previous response was sent.\"",
            "                )",
            "            self.stream.response.stream = None",
            "            self.stream.response = None",
            "            self.responded = False",
            "        except AttributeError:",
            "            pass",
            "",
            "    async def respond(",
            "        self,",
            "        response: Optional[BaseHTTPResponse] = None,",
            "        *,",
            "        status: int = 200,",
            "        headers: Optional[Union[Header, Dict[str, str]]] = None,",
            "        content_type: Optional[str] = None,",
            "    ):",
            "        \"\"\"Respond to the request without returning.",
            "",
            "        This method can only be called once, as you can only respond once.",
            "        If no ``response`` argument is passed, one will be created from the",
            "        ``status``, ``headers`` and ``content_type`` arguments.",
            "",
            "        **The first typical usecase** is if you wish to respond to the",
            "        request without returning from the handler:",
            "",
            "        .. code-block:: python",
            "",
            "            @app.get(\"/\")",
            "            async def handler(request: Request):",
            "                data = ...  # Process something",
            "",
            "                json_response = json({\"data\": data})",
            "                await request.respond(json_response)",
            "",
            "                # You are now free to continue executing other code",
            "                ...",
            "",
            "            @app.on_response",
            "            async def add_header(_, response: HTTPResponse):",
            "                # Middlewares still get executed as expected",
            "                response.headers[\"one\"] = \"two\"",
            "",
            "        **The second possible usecase** is for when you want to directly",
            "        respond to the request:",
            "",
            "        .. code-block:: python",
            "",
            "            response = await request.respond(content_type=\"text/csv\")",
            "            await response.send(\"foo,\")",
            "            await response.send(\"bar\")",
            "",
            "            # You can control the completion of the response by calling",
            "            # the 'eof()' method:",
            "            await response.eof()",
            "",
            "        :param response: response instance to send",
            "        :param status: status code to return in the response",
            "        :param headers: headers to return in the response",
            "        :param content_type: Content-Type header of the response",
            "        :return: final response being sent (may be different from the",
            "            ``response`` parameter because of middlewares) which can be",
            "            used to manually send data",
            "        \"\"\"",
            "        try:",
            "            if self.stream is not None and self.stream.response:",
            "                raise ServerError(\"Second respond call is not allowed.\")",
            "        except AttributeError:",
            "            pass",
            "        # This logic of determining which response to use is subject to change",
            "        if response is None:",
            "            response = HTTPResponse(",
            "                status=status,",
            "                headers=headers,",
            "                content_type=content_type,",
            "            )",
            "",
            "        # Connect the response",
            "        if isinstance(response, BaseHTTPResponse) and self.stream:",
            "            response = self.stream.respond(response)",
            "",
            "            if isawaitable(response):",
            "                response = await response  # type: ignore",
            "        # Run response middleware",
            "        try:",
            "            response = await self.app._run_response_middleware(",
            "                self, response, request_name=self.name",
            "            )",
            "        except CancelledErrors:",
            "            raise",
            "        except Exception:",
            "            error_logger.exception(",
            "                \"Exception occurred in one of response middleware handlers\"",
            "            )",
            "        self.responded = True",
            "        return response",
            "",
            "    async def receive_body(self):",
            "        \"\"\"Receive request.body, if not already received.",
            "",
            "        Streaming handlers may call this to receive the full body. Sanic calls",
            "        this function before running any handlers of non-streaming routes.",
            "",
            "        Custom request classes can override this for custom handling of both",
            "        streaming and non-streaming routes.",
            "        \"\"\"",
            "        if not self.body:",
            "            self.body = b\"\".join([data async for data in self.stream])",
            "",
            "    @property",
            "    def name(self) -> Optional[str]:",
            "        \"\"\"",
            "        The route name",
            "",
            "        In the following pattern:",
            "",
            "        .. code-block::",
            "",
            "            <AppName>.[<BlueprintName>.]<HandlerName>",
            "",
            "        :return: Route name",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        if self._name:",
            "            return self._name",
            "        elif self.route:",
            "            return self.route.name",
            "        return None",
            "",
            "    @property",
            "    def endpoint(self) -> Optional[str]:",
            "        \"\"\"",
            "        :return: Alias of :attr:`sanic.request.Request.name`",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        return self.name",
            "",
            "    @property",
            "    def uri_template(self) -> Optional[str]:",
            "        \"\"\"",
            "        :return: The defined URI template",
            "        :rtype: Optional[str]",
            "        \"\"\"",
            "        if self.route:",
            "            return f\"/{self.route.path}\"",
            "        return None",
            "",
            "    @property",
            "    def protocol(self):",
            "        \"\"\"",
            "        :return: The HTTP protocol instance",
            "        \"\"\"",
            "        if not self._protocol:",
            "            self._protocol = self.transport.get_protocol()",
            "        return self._protocol",
            "",
            "    @property",
            "    def raw_headers(self) -> bytes:",
            "        \"\"\"",
            "        :return: The unparsed HTTP headers",
            "        :rtype: bytes",
            "        \"\"\"",
            "        _, headers = self.head.split(b\"\\r\\n\", 1)",
            "        return bytes(headers)",
            "",
            "    @property",
            "    def request_line(self) -> bytes:",
            "        \"\"\"",
            "        :return: The first line of a HTTP request",
            "        :rtype: bytes",
            "        \"\"\"",
            "        reqline, _ = self.head.split(b\"\\r\\n\", 1)",
            "        return bytes(reqline)",
            "",
            "    @property",
            "    def id(self) -> Optional[Union[uuid.UUID, str, int]]:",
            "        \"\"\"",
            "        A request ID passed from the client, or generated from the backend.",
            "",
            "        By default, this will look in a request header defined at:",
            "        ``self.app.config.REQUEST_ID_HEADER``. It defaults to",
            "        ``X-Request-ID``. Sanic will try to cast the ID into a ``UUID`` or an",
            "        ``int``. If there is not a UUID from the client, then Sanic will try",
            "        to generate an ID by calling ``Request.generate_id()``. The default",
            "        behavior is to generate a ``UUID``. You can customize this behavior",
            "        by subclassing ``Request``.",
            "",
            "        .. code-block:: python",
            "",
            "            from sanic import Request, Sanic",
            "            from itertools import count",
            "",
            "            class IntRequest(Request):",
            "                counter = count()",
            "",
            "                def generate_id(self):",
            "                    return next(self.counter)",
            "",
            "            app = Sanic(\"MyApp\", request_class=IntRequest)",
            "        \"\"\"",
            "        if not self._id:",
            "            self._id = self.headers.getone(",
            "                self.app.config.REQUEST_ID_HEADER,",
            "                self.__class__.generate_id(self),  # type: ignore",
            "            )",
            "",
            "            # Try casting to a UUID or an integer",
            "            if isinstance(self._id, str):",
            "                try:",
            "                    self._id = uuid.UUID(self._id)",
            "                except ValueError:",
            "                    try:",
            "                        self._id = int(self._id)  # type: ignore",
            "                    except ValueError:",
            "                        ...",
            "",
            "        return self._id  # type: ignore",
            "",
            "    @property",
            "    def json(self) -> Any:",
            "        \"\"\"",
            "        :return: The request body parsed as JSON",
            "        :rtype: Any",
            "        \"\"\"",
            "        if self.parsed_json is None:",
            "            self.load_json()",
            "",
            "        return self.parsed_json",
            "",
            "    def load_json(self, loads=None):",
            "        try:",
            "            if not loads:",
            "                loads = self.__class__._loads",
            "",
            "            self.parsed_json = loads(self.body)",
            "        except Exception:",
            "            if not self.body:",
            "                return None",
            "            raise BadRequest(\"Failed when parsing body as json\")",
            "",
            "        return self.parsed_json",
            "",
            "    @property",
            "    def accept(self) -> AcceptContainer:",
            "        \"\"\"",
            "        :return: The ``Accept`` header parsed",
            "        :rtype: AcceptContainer",
            "        \"\"\"",
            "        if self.parsed_accept is None:",
            "            accept_header = self.headers.getone(\"accept\", \"\")",
            "            self.parsed_accept = parse_accept(accept_header)",
            "        return self.parsed_accept",
            "",
            "    @property",
            "    def token(self) -> Optional[str]:",
            "        \"\"\"Attempt to return the auth header token.",
            "",
            "        :return: token related to request",
            "        \"\"\"",
            "        if self.parsed_token is None:",
            "            prefixes = (\"Bearer\", \"Token\")",
            "            _, token = parse_credentials(",
            "                self.headers.getone(\"authorization\", None), prefixes",
            "            )",
            "            self.parsed_token = token",
            "        return self.parsed_token",
            "",
            "    @property",
            "    def credentials(self) -> Optional[Credentials]:",
            "        \"\"\"Attempt to return the auth header value.",
            "",
            "        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication",
            "        schemas.",
            "",
            "        :return: A Credentials object with token, or username and password",
            "                 related to the request",
            "        \"\"\"",
            "        if self.parsed_credentials is None:",
            "            try:",
            "                prefix, credentials = parse_credentials(",
            "                    self.headers.getone(\"authorization\", None)",
            "                )",
            "                if credentials:",
            "                    self.parsed_credentials = Credentials(",
            "                        auth_type=prefix, token=credentials",
            "                    )",
            "            except ValueError:",
            "                pass",
            "        return self.parsed_credentials",
            "",
            "    def get_form(",
            "        self, keep_blank_values: bool = False",
            "    ) -> Optional[RequestParameters]:",
            "        \"\"\"",
            "        Method to extract and parse the form data from a request.",
            "",
            "        :param keep_blank_values:",
            "            Whether to discard blank values from the form data",
            "        :type keep_blank_values: bool",
            "        :return: the parsed form data",
            "        :rtype: Optional[RequestParameters]",
            "        \"\"\"",
            "        self.parsed_form = RequestParameters()",
            "        self.parsed_files = RequestParameters()",
            "        content_type = self.headers.getone(",
            "            \"content-type\", DEFAULT_HTTP_CONTENT_TYPE",
            "        )",
            "        content_type, parameters = parse_content_header(content_type)",
            "        try:",
            "            if content_type == \"application/x-www-form-urlencoded\":",
            "                self.parsed_form = RequestParameters(",
            "                    parse_qs(",
            "                        self.body.decode(\"utf-8\"),",
            "                        keep_blank_values=keep_blank_values,",
            "                    )",
            "                )",
            "            elif content_type == \"multipart/form-data\":",
            "                # TODO: Stream this instead of reading to/from memory",
            "                boundary = parameters[\"boundary\"].encode(  # type: ignore",
            "                    \"utf-8\"",
            "                )  # type: ignore",
            "                self.parsed_form, self.parsed_files = parse_multipart_form(",
            "                    self.body, boundary",
            "                )",
            "        except Exception:",
            "            error_logger.exception(\"Failed when parsing form\")",
            "",
            "        return self.parsed_form",
            "",
            "    @property",
            "    def form(self):",
            "        \"\"\"",
            "        :return: The request body parsed as form data",
            "        \"\"\"",
            "        if self.parsed_form is None:",
            "            self.get_form()",
            "",
            "        return self.parsed_form",
            "",
            "    @property",
            "    def files(self):",
            "        \"\"\"",
            "        :return: The request body parsed as uploaded files",
            "        \"\"\"",
            "        if self.parsed_files is None:",
            "            self.form  # compute form to get files",
            "",
            "        return self.parsed_files",
            "",
            "    def get_args(",
            "        self,",
            "        keep_blank_values: bool = False,",
            "        strict_parsing: bool = False,",
            "        encoding: str = \"utf-8\",",
            "        errors: str = \"replace\",",
            "    ) -> RequestParameters:",
            "        \"\"\"",
            "        Method to parse ``query_string`` using ``urllib.parse.parse_qs``.",
            "        This methods is used by ``args`` property.",
            "        Can be used directly if you need to change default parameters.",
            "",
            "        :param keep_blank_values:",
            "            flag indicating whether blank values in",
            "            percent-encoded queries should be treated as blank strings.",
            "            A true value indicates that blanks should be retained as blank",
            "            strings.  The default false value indicates that blank values",
            "            are to be ignored and treated as if they were  not included.",
            "        :type keep_blank_values: bool",
            "        :param strict_parsing:",
            "            flag indicating what to do with parsing errors.",
            "            If false (the default), errors are silently ignored. If true,",
            "            errors raise a ValueError exception.",
            "        :type strict_parsing: bool",
            "        :param encoding:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type encoding: str",
            "        :param errors:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type errors: str",
            "        :return: RequestParameters",
            "        \"\"\"",
            "        if (",
            "            keep_blank_values,",
            "            strict_parsing,",
            "            encoding,",
            "            errors,",
            "        ) not in self.parsed_args:",
            "            if self.query_string:",
            "                self.parsed_args[",
            "                    (keep_blank_values, strict_parsing, encoding, errors)",
            "                ] = RequestParameters(",
            "                    parse_qs(",
            "                        qs=self.query_string,",
            "                        keep_blank_values=keep_blank_values,",
            "                        strict_parsing=strict_parsing,",
            "                        encoding=encoding,",
            "                        errors=errors,",
            "                    )",
            "                )",
            "",
            "        return self.parsed_args[",
            "            (keep_blank_values, strict_parsing, encoding, errors)",
            "        ]",
            "",
            "    args = property(get_args)",
            "    \"\"\"",
            "    Convenience property to access :meth:`Request.get_args` with",
            "    default values.",
            "    \"\"\"",
            "",
            "    def get_query_args(",
            "        self,",
            "        keep_blank_values: bool = False,",
            "        strict_parsing: bool = False,",
            "        encoding: str = \"utf-8\",",
            "        errors: str = \"replace\",",
            "    ) -> list:",
            "        \"\"\"",
            "        Method to parse `query_string` using `urllib.parse.parse_qsl`.",
            "        This methods is used by `query_args` property.",
            "        Can be used directly if you need to change default parameters.",
            "",
            "        :param keep_blank_values:",
            "            flag indicating whether blank values in",
            "            percent-encoded queries should be treated as blank strings.",
            "            A true value indicates that blanks should be retained as blank",
            "            strings.  The default false value indicates that blank values",
            "            are to be ignored and treated as if they were  not included.",
            "        :type keep_blank_values: bool",
            "        :param strict_parsing:",
            "            flag indicating what to do with parsing errors.",
            "            If false (the default), errors are silently ignored. If true,",
            "            errors raise a ValueError exception.",
            "        :type strict_parsing: bool",
            "        :param encoding:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type encoding: str",
            "        :param errors:",
            "            specify how to decode percent-encoded sequences",
            "            into Unicode characters, as accepted by the bytes.decode() method.",
            "        :type errors: str",
            "        :return: list",
            "        \"\"\"",
            "        if (",
            "            keep_blank_values,",
            "            strict_parsing,",
            "            encoding,",
            "            errors,",
            "        ) not in self.parsed_not_grouped_args:",
            "            if self.query_string:",
            "                self.parsed_not_grouped_args[",
            "                    (keep_blank_values, strict_parsing, encoding, errors)",
            "                ] = parse_qsl(",
            "                    qs=self.query_string,",
            "                    keep_blank_values=keep_blank_values,",
            "                    strict_parsing=strict_parsing,",
            "                    encoding=encoding,",
            "                    errors=errors,",
            "                )",
            "        return self.parsed_not_grouped_args[",
            "            (keep_blank_values, strict_parsing, encoding, errors)",
            "        ]",
            "",
            "    query_args = property(get_query_args)",
            "    \"\"\"",
            "    Convenience property to access :meth:`Request.get_query_args` with",
            "    default values.",
            "    \"\"\"",
            "",
            "    @property",
            "    def cookies(self) -> Dict[str, str]:",
            "        \"\"\"",
            "        :return: Incoming cookies on the request",
            "        :rtype: Dict[str, str]",
            "        \"\"\"",
            "",
            "        if self._cookies is None:",
            "            cookie = self.headers.getone(\"cookie\", None)",
            "            if cookie is not None:",
            "                cookies: SimpleCookie = SimpleCookie()",
            "                cookies.load(cookie)",
            "                self._cookies = {",
            "                    name: cookie.value for name, cookie in cookies.items()",
            "                }",
            "            else:",
            "                self._cookies = {}",
            "        return self._cookies",
            "",
            "    @property",
            "    def content_type(self) -> str:",
            "        \"\"\"",
            "        :return: Content-Type header form the request",
            "        :rtype: str",
            "        \"\"\"",
            "        return self.headers.getone(\"content-type\", DEFAULT_HTTP_CONTENT_TYPE)",
            "",
            "    @property",
            "    def match_info(self):",
            "        \"\"\"",
            "        :return: matched info after resolving route",
            "        \"\"\"",
            "        return self._match_info",
            "",
            "    @match_info.setter",
            "    def match_info(self, value):",
            "        self._match_info = value",
            "",
            "    # Transport properties (obtained from local interface only)",
            "",
            "    @property",
            "    def ip(self) -> str:",
            "        \"\"\"",
            "        :return: peer ip of the socket",
            "        :rtype: str",
            "        \"\"\"",
            "        return self.conn_info.client_ip if self.conn_info else \"\"",
            "",
            "    @property",
            "    def port(self) -> int:",
            "        \"\"\"",
            "        :return: peer port of the socket",
            "        :rtype: int",
            "        \"\"\"",
            "        return self.conn_info.client_port if self.conn_info else 0",
            "",
            "    @property",
            "    def socket(self):",
            "        \"\"\"",
            "        :return: Information about the connected socket if available",
            "        \"\"\"",
            "        return self.conn_info.peername if self.conn_info else (None, None)",
            "",
            "    @property",
            "    def path(self) -> str:",
            "        \"\"\"",
            "        :return: path of the local HTTP request",
            "        :rtype: str",
            "        \"\"\"",
            "        return self._parsed_url.path.decode(\"utf-8\")",
            "",
            "    @property",
            "    def network_paths(self):",
            "        \"\"\"",
            "        Access the network paths if available",
            "        \"\"\"",
            "        return self.conn_info.network_paths",
            "",
            "    # Proxy properties (using SERVER_NAME/forwarded/request/transport info)",
            "",
            "    @property",
            "    def forwarded(self) -> Options:",
            "        \"\"\"",
            "        Active proxy information obtained from request headers, as specified in",
            "        Sanic configuration.",
            "",
            "        Field names by, for, proto, host, port and path are normalized.",
            "        - for and by IPv6 addresses are bracketed",
            "        - port (int) is only set by port headers, not from host.",
            "        - path is url-unencoded",
            "",
            "        Additional values may be available from new style Forwarded headers.",
            "",
            "        :return: forwarded address info",
            "        :rtype: Dict[str, str]",
            "        \"\"\"",
            "        if self.parsed_forwarded is None:",
            "            self.parsed_forwarded = (",
            "                parse_forwarded(self.headers, self.app.config)",
            "                or parse_xforwarded(self.headers, self.app.config)",
            "                or {}",
            "            )",
            "        return self.parsed_forwarded",
            "",
            "    @property",
            "    def remote_addr(self) -> str:",
            "        \"\"\"",
            "        Client IP address, if available.",
            "        1. proxied remote address `self.forwarded['for']`",
            "        2. local remote address `self.ip`",
            "",
            "        :return: IPv4, bracketed IPv6, UNIX socket name or arbitrary string",
            "        :rtype: str",
            "        \"\"\"",
            "        if not hasattr(self, \"_remote_addr\"):",
            "            self._remote_addr = str(",
            "                self.forwarded.get(\"for\", \"\")",
            "            )  # or self.ip",
            "        return self._remote_addr",
            "",
            "    @property",
            "    def scheme(self) -> str:",
            "        \"\"\"",
            "        Determine request scheme.",
            "        1. `config.SERVER_NAME` if in full URL format",
            "        2. proxied proto/scheme",
            "        3. local connection protocol",
            "",
            "        :return: http|https|ws|wss or arbitrary value given by the headers.",
            "        :rtype: str",
            "        \"\"\"",
            "        if not hasattr(self, \"_scheme\"):",
            "            if \"//\" in self.app.config.get(\"SERVER_NAME\", \"\"):",
            "                return self.app.config.SERVER_NAME.split(\"//\")[0]",
            "            if \"proto\" in self.forwarded:",
            "                return str(self.forwarded[\"proto\"])",
            "",
            "            if (",
            "                self.app.websocket_enabled",
            "                and self.headers.getone(\"upgrade\", \"\").lower() == \"websocket\"",
            "            ):",
            "                scheme = \"ws\"",
            "            else:",
            "                scheme = \"http\"",
            "",
            "            if self.transport.get_extra_info(\"sslcontext\"):",
            "                scheme += \"s\"",
            "            self._scheme = scheme",
            "",
            "        return self._scheme",
            "",
            "    @property",
            "    def host(self) -> str:",
            "        \"\"\"",
            "        The currently effective server 'host' (hostname or hostname:port).",
            "        1. `config.SERVER_NAME` overrides any client headers",
            "        2. proxied host of original request",
            "        3. request host header",
            "        hostname and port may be separated by",
            "        `sanic.headers.parse_host(request.host)`.",
            "",
            "        :return: the first matching host found, or empty string",
            "        :rtype: str",
            "        \"\"\"",
            "        server_name = self.app.config.get(\"SERVER_NAME\")",
            "        if server_name:",
            "            return server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]",
            "        return str(",
            "            self.forwarded.get(\"host\") or self.headers.getone(\"host\", \"\")",
            "        )",
            "",
            "    @property",
            "    def server_name(self) -> str:",
            "        \"\"\"",
            "        :return: hostname the client connected to, by ``request.host``",
            "        :rtype: str",
            "        \"\"\"",
            "        return parse_host(self.host)[0] or \"\"",
            "",
            "    @property",
            "    def server_port(self) -> int:",
            "        \"\"\"",
            "        The port the client connected to, by forwarded ``port`` or",
            "        ``request.host``.",
            "",
            "        Default port is returned as 80 and 443 based on ``request.scheme``.",
            "",
            "        :return: port number",
            "        :rtype: int",
            "        \"\"\"",
            "        port = self.forwarded.get(\"port\") or parse_host(self.host)[1]",
            "        return int(port or (80 if self.scheme in (\"http\", \"ws\") else 443))",
            "",
            "    @property",
            "    def server_path(self) -> str:",
            "        \"\"\"",
            "        :return: full path of current URL; uses proxied or local path",
            "        :rtype: str",
            "        \"\"\"",
            "        return str(self.forwarded.get(\"path\") or self.path)",
            "",
            "    @property",
            "    def query_string(self) -> str:",
            "        \"\"\"",
            "        :return: representation of the requested query",
            "        :rtype: str",
            "        \"\"\"",
            "        if self._parsed_url.query:",
            "            return self._parsed_url.query.decode(\"utf-8\")",
            "        else:",
            "            return \"\"",
            "",
            "    @property",
            "    def url(self) -> str:",
            "        \"\"\"",
            "        :return: the URL",
            "        :rtype: str",
            "        \"\"\"",
            "        return urlunparse(",
            "            (self.scheme, self.host, self.path, None, self.query_string, None)",
            "        )",
            "",
            "    def url_for(self, view_name: str, **kwargs) -> str:",
            "        \"\"\"",
            "        Same as :func:`sanic.Sanic.url_for`, but automatically determine",
            "        `scheme` and `netloc` base on the request. Since this method is aiming",
            "        to generate correct schema & netloc, `_external` is implied.",
            "",
            "        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`",
            "        :return: an absolute url to the given view",
            "        :rtype: str",
            "        \"\"\"",
            "        # Full URL SERVER_NAME can only be handled in app.url_for",
            "        try:",
            "            if \"//\" in self.app.config.SERVER_NAME:",
            "                return self.app.url_for(view_name, _external=True, **kwargs)",
            "        except AttributeError:",
            "            pass",
            "",
            "        scheme = self.scheme",
            "        host = self.server_name",
            "        port = self.server_port",
            "",
            "        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (",
            "            scheme.lower() in (\"https\", \"wss\") and port == 443",
            "        ):",
            "            netloc = host",
            "        else:",
            "            netloc = f\"{host}:{port}\"",
            "",
            "        return self.app.url_for(",
            "            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs",
            "        )",
            "",
            "    @property",
            "    def scope(self) -> ASGIScope:",
            "        \"\"\"",
            "        :return: The ASGI scope of the request.",
            "                 If the app isn't an ASGI app, then raises an exception.",
            "        :rtype: Optional[ASGIScope]",
            "        \"\"\"",
            "        if not self.app.asgi:",
            "            raise NotImplementedError(",
            "                \"App isn't running in ASGI mode. \"",
            "                \"Scope is only available for ASGI apps.\"",
            "            )",
            "",
            "        return self.transport.scope",
            "",
            "",
            "class File(NamedTuple):",
            "    \"\"\"",
            "    Model for defining a file. It is a ``namedtuple``, therefore you can",
            "    iterate over the object, or access the parameters by name.",
            "",
            "    :param type: The mimetype, defaults to text/plain",
            "    :param body: Bytes of the file",
            "    :param name: The filename",
            "    \"\"\"",
            "",
            "    type: str",
            "    body: bytes",
            "    name: str",
            "",
            "",
            "def parse_multipart_form(body, boundary):",
            "    \"\"\"",
            "    Parse a request body and returns fields and files",
            "",
            "    :param body: bytes request body",
            "    :param boundary: bytes multipart boundary",
            "    :return: fields (RequestParameters), files (RequestParameters)",
            "    \"\"\"",
            "    files = RequestParameters()",
            "    fields = RequestParameters()",
            "",
            "    form_parts = body.split(boundary)",
            "    for form_part in form_parts[1:-1]:",
            "        file_name = None",
            "        content_type = \"text/plain\"",
            "        content_charset = \"utf-8\"",
            "        field_name = None",
            "        line_index = 2",
            "        line_end_index = 0",
            "        while not line_end_index == -1:",
            "            line_end_index = form_part.find(b\"\\r\\n\", line_index)",
            "            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")",
            "            line_index = line_end_index + 2",
            "",
            "            if not form_line:",
            "                break",
            "",
            "            colon_index = form_line.index(\":\")",
            "            idx = colon_index + 2",
            "            form_header_field = form_line[0:colon_index].lower()",
            "            form_header_value, form_parameters = parse_content_header(",
            "                form_line[idx:]",
            "            )",
            "",
            "            if form_header_field == \"content-disposition\":",
            "                field_name = form_parameters.get(\"name\")",
            "                file_name = form_parameters.get(\"filename\")",
            "",
            "                # non-ASCII filenames in RFC2231, \"filename*\" format",
            "                if file_name is None and form_parameters.get(\"filename*\"):",
            "                    encoding, _, value = email.utils.decode_rfc2231(",
            "                        form_parameters[\"filename*\"]",
            "                    )",
            "                    file_name = unquote(value, encoding=encoding)",
            "            elif form_header_field == \"content-type\":",
            "                content_type = form_header_value",
            "                content_charset = form_parameters.get(\"charset\", \"utf-8\")",
            "",
            "        if field_name:",
            "            post_data = form_part[line_index:-4]",
            "            if file_name is None:",
            "                value = post_data.decode(content_charset)",
            "                if field_name in fields:",
            "                    fields[field_name].append(value)",
            "                else:",
            "                    fields[field_name] = [value]",
            "            else:",
            "                form_file = File(",
            "                    type=content_type, name=file_name, body=post_data",
            "                )",
            "                if field_name in files:",
            "                    files[field_name].append(form_file)",
            "                else:",
            "                    files[field_name] = [form_file]",
            "        else:",
            "            logger.debug(",
            "                \"Form-data field does not have a 'name' parameter \"",
            "                \"in the Content-Disposition header\"",
            "            )",
            "",
            "    return fields, files"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "191": [
                "Request",
                "get_current"
            ]
        },
        "addLocation": []
    },
    "sanic/server/websockets/impl.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     def _force_disconnect(self) -> bool:"
            },
            "2": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Internal methdod used by end_connection and fail_connection"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        Internal method used by end_connection and fail_connection"
            },
            "5": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         only when the graceful auto-closer cannot be used"
            },
            "6": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         if self.auto_closer_task and not self.auto_closer_task.done():"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import random",
            "import struct",
            "",
            "from typing import (",
            "    AsyncIterator,",
            "    Dict,",
            "    Iterable,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Union,",
            ")",
            "",
            "from websockets.connection import CLOSED, CLOSING, OPEN, Event",
            "from websockets.exceptions import ConnectionClosed, ConnectionClosedError",
            "from websockets.frames import Frame, Opcode",
            "from websockets.server import ServerConnection",
            "from websockets.typing import Data",
            "",
            "from sanic.log import error_logger, logger",
            "from sanic.server.protocols.base_protocol import SanicProtocol",
            "",
            "from ...exceptions import ServerError, WebsocketClosed",
            "from .frame import WebsocketFrameAssembler",
            "",
            "",
            "class WebsocketImplProtocol:",
            "    connection: ServerConnection",
            "    io_proto: Optional[SanicProtocol]",
            "    loop: Optional[asyncio.AbstractEventLoop]",
            "    max_queue: int",
            "    close_timeout: float",
            "    ping_interval: Optional[float]",
            "    ping_timeout: Optional[float]",
            "    assembler: WebsocketFrameAssembler",
            "    # Dict[bytes, asyncio.Future[None]]",
            "    pings: Dict[bytes, asyncio.Future]",
            "    conn_mutex: asyncio.Lock",
            "    recv_lock: asyncio.Lock",
            "    recv_cancel: Optional[asyncio.Future]",
            "    process_event_mutex: asyncio.Lock",
            "    can_pause: bool",
            "    # Optional[asyncio.Future[None]]",
            "    data_finished_fut: Optional[asyncio.Future]",
            "    # Optional[asyncio.Future[None]]",
            "    pause_frame_fut: Optional[asyncio.Future]",
            "    # Optional[asyncio.Future[None]]",
            "    connection_lost_waiter: Optional[asyncio.Future]",
            "    keepalive_ping_task: Optional[asyncio.Task]",
            "    auto_closer_task: Optional[asyncio.Task]",
            "",
            "    def __init__(",
            "        self,",
            "        connection,",
            "        max_queue=None,",
            "        ping_interval: Optional[float] = 20,",
            "        ping_timeout: Optional[float] = 20,",
            "        close_timeout: float = 10,",
            "        loop=None,",
            "    ):",
            "        self.connection = connection",
            "        self.io_proto = None",
            "        self.loop = None",
            "        self.max_queue = max_queue",
            "        self.close_timeout = close_timeout",
            "        self.ping_interval = ping_interval",
            "        self.ping_timeout = ping_timeout",
            "        self.assembler = WebsocketFrameAssembler(self)",
            "        self.pings = {}",
            "        self.conn_mutex = asyncio.Lock()",
            "        self.recv_lock = asyncio.Lock()",
            "        self.recv_cancel = None",
            "        self.process_event_mutex = asyncio.Lock()",
            "        self.data_finished_fut = None",
            "        self.can_pause = True",
            "        self.pause_frame_fut = None",
            "        self.keepalive_ping_task = None",
            "        self.auto_closer_task = None",
            "        self.connection_lost_waiter = None",
            "",
            "    @property",
            "    def subprotocol(self):",
            "        return self.connection.subprotocol",
            "",
            "    def pause_frames(self):",
            "        if not self.can_pause:",
            "            return False",
            "        if self.pause_frame_fut:",
            "            logger.debug(\"Websocket connection already paused.\")",
            "            return False",
            "        if (not self.loop) or (not self.io_proto):",
            "            return False",
            "        if self.io_proto.transport:",
            "            self.io_proto.transport.pause_reading()",
            "        self.pause_frame_fut = self.loop.create_future()",
            "        logger.debug(\"Websocket connection paused.\")",
            "        return True",
            "",
            "    def resume_frames(self):",
            "        if not self.pause_frame_fut:",
            "            logger.debug(\"Websocket connection not paused.\")",
            "            return False",
            "        if (not self.loop) or (not self.io_proto):",
            "            logger.debug(",
            "                \"Websocket attempting to resume reading frames, \"",
            "                \"but connection is gone.\"",
            "            )",
            "            return False",
            "        if self.io_proto.transport:",
            "            self.io_proto.transport.resume_reading()",
            "        self.pause_frame_fut.set_result(None)",
            "        self.pause_frame_fut = None",
            "        logger.debug(\"Websocket connection unpaused.\")",
            "        return True",
            "",
            "    async def connection_made(",
            "        self,",
            "        io_proto: SanicProtocol,",
            "        loop: Optional[asyncio.AbstractEventLoop] = None,",
            "    ):",
            "        if not loop:",
            "            try:",
            "                loop = getattr(io_proto, \"loop\")",
            "            except AttributeError:",
            "                loop = asyncio.get_event_loop()",
            "        if not loop:",
            "            # This catch is for mypy type checker",
            "            # to assert loop is not None here.",
            "            raise ServerError(\"Connection received with no asyncio loop.\")",
            "        if self.auto_closer_task:",
            "            raise ServerError(",
            "                \"Cannot call connection_made more than once \"",
            "                \"on a websocket connection.\"",
            "            )",
            "        self.loop = loop",
            "        self.io_proto = io_proto",
            "        self.connection_lost_waiter = self.loop.create_future()",
            "        self.data_finished_fut = asyncio.shield(self.loop.create_future())",
            "",
            "        if self.ping_interval:",
            "            self.keepalive_ping_task = asyncio.create_task(",
            "                self.keepalive_ping()",
            "            )",
            "        self.auto_closer_task = asyncio.create_task(",
            "            self.auto_close_connection()",
            "        )",
            "",
            "    async def wait_for_connection_lost(self, timeout=None) -> bool:",
            "        \"\"\"",
            "        Wait until the TCP connection is closed or ``timeout`` elapses.",
            "        If timeout is None, wait forever.",
            "        Recommend you should pass in self.close_timeout as timeout",
            "",
            "        Return ``True`` if the connection is closed and ``False`` otherwise.",
            "",
            "        \"\"\"",
            "        if not self.connection_lost_waiter:",
            "            return False",
            "        if self.connection_lost_waiter.done():",
            "            return True",
            "        else:",
            "            try:",
            "                await asyncio.wait_for(",
            "                    asyncio.shield(self.connection_lost_waiter), timeout",
            "                )",
            "                return True",
            "            except asyncio.TimeoutError:",
            "                # Re-check self.connection_lost_waiter.done() synchronously",
            "                # because connection_lost() could run between the moment the",
            "                # timeout occurs and the moment this coroutine resumes running",
            "                return self.connection_lost_waiter.done()",
            "",
            "    async def process_events(self, events: Sequence[Event]) -> None:",
            "        \"\"\"",
            "        Process a list of incoming events.",
            "        \"\"\"",
            "        # Wrapped in a mutex lock, to prevent other incoming events",
            "        # from processing at the same time",
            "        async with self.process_event_mutex:",
            "            for event in events:",
            "                if not isinstance(event, Frame):",
            "                    # Event is not a frame. Ignore it.",
            "                    continue",
            "                if event.opcode == Opcode.PONG:",
            "                    await self.process_pong(event)",
            "                elif event.opcode == Opcode.CLOSE:",
            "                    if self.recv_cancel:",
            "                        self.recv_cancel.cancel()",
            "                else:",
            "                    await self.assembler.put(event)",
            "",
            "    async def process_pong(self, frame: Frame) -> None:",
            "        if frame.data in self.pings:",
            "            # Acknowledge all pings up to the one matching this pong.",
            "            ping_ids = []",
            "            for ping_id, ping in self.pings.items():",
            "                ping_ids.append(ping_id)",
            "                if not ping.done():",
            "                    ping.set_result(None)",
            "                if ping_id == frame.data:",
            "                    break",
            "            else:  # noqa",
            "                raise ServerError(\"ping_id is not in self.pings\")",
            "            # Remove acknowledged pings from self.pings.",
            "            for ping_id in ping_ids:",
            "                del self.pings[ping_id]",
            "",
            "    async def keepalive_ping(self) -> None:",
            "        \"\"\"",
            "        Send a Ping frame and wait for a Pong frame at regular intervals.",
            "        This coroutine exits when the connection terminates and one of the",
            "        following happens:",
            "        - :meth:`ping` raises :exc:`ConnectionClosed`, or",
            "        - :meth:`auto_close_connection` cancels :attr:`keepalive_ping_task`.",
            "        \"\"\"",
            "        if self.ping_interval is None:",
            "            return",
            "",
            "        try:",
            "            while True:",
            "                await asyncio.sleep(self.ping_interval)",
            "",
            "                # ping() raises CancelledError if the connection is closed,",
            "                # when auto_close_connection() cancels keepalive_ping_task.",
            "",
            "                # ping() raises ConnectionClosed if the connection is lost,",
            "                # when connection_lost() calls abort_pings().",
            "",
            "                ping_waiter = await self.ping()",
            "",
            "                if self.ping_timeout is not None:",
            "                    try:",
            "                        await asyncio.wait_for(ping_waiter, self.ping_timeout)",
            "                    except asyncio.TimeoutError:",
            "                        error_logger.warning(",
            "                            \"Websocket timed out waiting for pong\"",
            "                        )",
            "                        self.fail_connection(1011)",
            "                        break",
            "        except asyncio.CancelledError:",
            "            # It is expected for this task to be cancelled during during",
            "            # normal operation, when the connection is closed.",
            "            logger.debug(\"Websocket keepalive ping task was cancelled.\")",
            "        except (ConnectionClosed, WebsocketClosed):",
            "            logger.debug(\"Websocket closed. Keepalive ping task exiting.\")",
            "        except Exception as e:",
            "            error_logger.warning(",
            "                \"Unexpected exception in websocket keepalive ping task.\"",
            "            )",
            "            logger.debug(str(e))",
            "",
            "    def _force_disconnect(self) -> bool:",
            "        \"\"\"",
            "        Internal methdod used by end_connection and fail_connection",
            "        only when the graceful auto-closer cannot be used",
            "        \"\"\"",
            "        if self.auto_closer_task and not self.auto_closer_task.done():",
            "            self.auto_closer_task.cancel()",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if self.keepalive_ping_task and not self.keepalive_ping_task.done():",
            "            self.keepalive_ping_task.cancel()",
            "            self.keepalive_ping_task = None",
            "        if self.loop and self.io_proto and self.io_proto.transport:",
            "            self.io_proto.transport.close()",
            "            self.loop.call_later(",
            "                self.close_timeout, self.io_proto.transport.abort",
            "            )",
            "        # We were never open, or already closed",
            "        return True",
            "",
            "    def fail_connection(self, code: int = 1006, reason: str = \"\") -> bool:",
            "        \"\"\"",
            "        Fail the WebSocket Connection",
            "        This requires:",
            "        1. Stopping all processing of incoming data, which means cancelling",
            "           pausing the underlying io protocol. The close code will be 1006",
            "           unless a close frame was received earlier.",
            "        2. Sending a close frame with an appropriate code if the opening",
            "           handshake succeeded and the other side is likely to process it.",
            "        3. Closing the connection. :meth:`auto_close_connection` takes care",
            "           of this.",
            "        (The specification describes these steps in the opposite order.)",
            "        \"\"\"",
            "        if self.io_proto and self.io_proto.transport:",
            "            # Stop new data coming in",
            "            # In Python Version 3.7: pause_reading is idempotent",
            "            # ut can be called when the transport is already paused or closed",
            "            self.io_proto.transport.pause_reading()",
            "",
            "            # Keeping fail_connection() synchronous guarantees it can't",
            "            # get stuck and simplifies the implementation of the callers.",
            "            # Not draining the write buffer is acceptable in this context.",
            "",
            "            # clear the send buffer",
            "            _ = self.connection.data_to_send()",
            "            # If we're not already CLOSED or CLOSING, then send the close.",
            "            if self.connection.state is OPEN:",
            "                if code in (1000, 1001):",
            "                    self.connection.send_close(code, reason)",
            "                else:",
            "                    self.connection.fail(code, reason)",
            "                try:",
            "                    data_to_send = self.connection.data_to_send()",
            "                    while (",
            "                        len(data_to_send)",
            "                        and self.io_proto",
            "                        and self.io_proto.transport",
            "                    ):",
            "                        frame_data = data_to_send.pop(0)",
            "                        self.io_proto.transport.write(frame_data)",
            "                except Exception:",
            "                    # sending close frames may fail if the",
            "                    # transport closes during this period",
            "                    ...",
            "        if code == 1006:",
            "            # Special case: 1006 consider the transport already closed",
            "            self.connection.state = CLOSED",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            # We have a graceful auto-closer. Use it to close the connection.",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if (not self.auto_closer_task) or self.auto_closer_task.done():",
            "            return self._force_disconnect()",
            "        return False",
            "",
            "    def end_connection(self, code=1000, reason=\"\"):",
            "        # This is like slightly more graceful form of fail_connection",
            "        # Use this instead of close() when you need an immediate",
            "        # close and cannot await websocket.close() handshake.",
            "",
            "        if code == 1006 or not self.io_proto or not self.io_proto.transport:",
            "            return self.fail_connection(code, reason)",
            "",
            "        # Stop new data coming in",
            "        # In Python Version 3.7: pause_reading is idempotent",
            "        # i.e. it can be called when the transport is already paused or closed.",
            "        self.io_proto.transport.pause_reading()",
            "        if self.connection.state == OPEN:",
            "            data_to_send = self.connection.data_to_send()",
            "            self.connection.send_close(code, reason)",
            "            data_to_send.extend(self.connection.data_to_send())",
            "            try:",
            "                while (",
            "                    len(data_to_send)",
            "                    and self.io_proto",
            "                    and self.io_proto.transport",
            "                ):",
            "                    frame_data = data_to_send.pop(0)",
            "                    self.io_proto.transport.write(frame_data)",
            "            except Exception:",
            "                # sending close frames may fail if the",
            "                # transport closes during this period",
            "                # But that doesn't matter at this point",
            "                ...",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            # We have the ability to signal the auto-closer",
            "            # try to trigger it to auto-close the connection",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if (not self.auto_closer_task) or self.auto_closer_task.done():",
            "            # Auto-closer is not running, do force disconnect",
            "            return self._force_disconnect()",
            "        return False",
            "",
            "    async def auto_close_connection(self) -> None:",
            "        \"\"\"",
            "        Close the WebSocket Connection",
            "        When the opening handshake succeeds, :meth:`connection_open` starts",
            "        this coroutine in a task. It waits for the data transfer phase to",
            "        complete then it closes the TCP connection cleanly.",
            "        When the opening handshake fails, :meth:`fail_connection` does the",
            "        same. There's no data transfer phase in that case.",
            "        \"\"\"",
            "        try:",
            "            # Wait for the data transfer phase to complete.",
            "            if self.data_finished_fut:",
            "                try:",
            "                    await self.data_finished_fut",
            "                    logger.debug(",
            "                        \"Websocket task finished. Closing the connection.\"",
            "                    )",
            "                except asyncio.CancelledError:",
            "                    # Cancelled error is called when data phase is cancelled",
            "                    # if an error occurred or the client closed the connection",
            "                    logger.debug(",
            "                        \"Websocket handler cancelled. Closing the connection.\"",
            "                    )",
            "",
            "            # Cancel the keepalive ping task.",
            "            if self.keepalive_ping_task:",
            "                self.keepalive_ping_task.cancel()",
            "                self.keepalive_ping_task = None",
            "",
            "            # Half-close the TCP connection if possible (when there's no TLS).",
            "            if (",
            "                self.io_proto",
            "                and self.io_proto.transport",
            "                and self.io_proto.transport.can_write_eof()",
            "            ):",
            "                logger.debug(\"Websocket half-closing TCP connection\")",
            "                self.io_proto.transport.write_eof()",
            "                if self.connection_lost_waiter:",
            "                    if await self.wait_for_connection_lost(timeout=0):",
            "                        return",
            "        except asyncio.CancelledError:",
            "            ...",
            "        finally:",
            "            # The try/finally ensures that the transport never remains open,",
            "            # even if this coroutine is cancelled (for example).",
            "            if (not self.io_proto) or (not self.io_proto.transport):",
            "                # we were never open, or done. Can't do any finalization.",
            "                return",
            "            elif (",
            "                self.connection_lost_waiter",
            "                and self.connection_lost_waiter.done()",
            "            ):",
            "                # connection confirmed closed already, proceed to abort waiter",
            "                ...",
            "            elif self.io_proto.transport.is_closing():",
            "                # Connection is already closing (due to half-close above)",
            "                # proceed to abort waiter",
            "                ...",
            "            else:",
            "                self.io_proto.transport.close()",
            "            if not self.connection_lost_waiter:",
            "                # Our connection monitor task isn't running.",
            "                try:",
            "                    await asyncio.sleep(self.close_timeout)",
            "                except asyncio.CancelledError:",
            "                    ...",
            "                if self.io_proto and self.io_proto.transport:",
            "                    self.io_proto.transport.abort()",
            "            else:",
            "                if await self.wait_for_connection_lost(",
            "                    timeout=self.close_timeout",
            "                ):",
            "                    # Connection aborted before the timeout expired.",
            "                    return",
            "                error_logger.warning(",
            "                    \"Timeout waiting for TCP connection to close. Aborting\"",
            "                )",
            "                if self.io_proto and self.io_proto.transport:",
            "                    self.io_proto.transport.abort()",
            "",
            "    def abort_pings(self) -> None:",
            "        \"\"\"",
            "        Raise ConnectionClosed in pending keepalive pings.",
            "        They'll never receive a pong once the connection is closed.",
            "        \"\"\"",
            "        if self.connection.state is not CLOSED:",
            "            raise ServerError(",
            "                \"Webscoket about_pings should only be called \"",
            "                \"after connection state is changed to CLOSED\"",
            "            )",
            "",
            "        for ping in self.pings.values():",
            "            ping.set_exception(ConnectionClosedError(None, None))",
            "            # If the exception is never retrieved, it will be logged when ping",
            "            # is garbage-collected. This is confusing for users.",
            "            # Given that ping is done (with an exception), canceling it does",
            "            # nothing, but it prevents logging the exception.",
            "            ping.cancel()",
            "",
            "    async def close(self, code: int = 1000, reason: str = \"\") -> None:",
            "        \"\"\"",
            "        Perform the closing handshake.",
            "        This is a websocket-protocol level close.",
            "        :meth:`close` waits for the other end to complete the handshake and",
            "        for the TCP connection to terminate.",
            "        :meth:`close` is idempotent: it doesn't do anything once the",
            "        connection is closed.",
            "        :param code: WebSocket close code",
            "        :param reason: WebSocket close reason",
            "        \"\"\"",
            "        if code == 1006:",
            "            self.fail_connection(code, reason)",
            "            return",
            "        async with self.conn_mutex:",
            "            if self.connection.state is OPEN:",
            "                self.connection.send_close(code, reason)",
            "                data_to_send = self.connection.data_to_send()",
            "                await self.send_data(data_to_send)",
            "",
            "    async def recv(self, timeout: Optional[float] = None) -> Optional[Data]:",
            "        \"\"\"",
            "        Receive the next message.",
            "        Return a :class:`str` for a text frame and :class:`bytes` for a binary",
            "        frame.",
            "        When the end of the message stream is reached, :meth:`recv` raises",
            "        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it",
            "        raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal",
            "        connection closure and",
            "        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol",
            "        error or a network failure.",
            "        If ``timeout`` is ``None``, block until a message is received. Else,",
            "        if no message is received within ``timeout`` seconds, return ``None``.",
            "        Set ``timeout`` to ``0`` to check if a message was already received.",
            "        :raises ~websockets.exceptions.ConnectionClosed: when the",
            "            connection is closed",
            "        :raises asyncio.CancelledError: if the websocket closes while waiting",
            "        :raises ServerError: if two tasks call :meth:`recv` or",
            "            :meth:`recv_streaming` concurrently",
            "        \"\"\"",
            "",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"cannot call recv while another task is \"",
            "                \"already waiting for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        try:",
            "            self.recv_cancel = asyncio.Future()",
            "            tasks = (",
            "                self.recv_cancel,",
            "                asyncio.ensure_future(self.assembler.get(timeout)),",
            "            )",
            "            done, pending = await asyncio.wait(",
            "                tasks,",
            "                return_when=asyncio.FIRST_COMPLETED,",
            "            )",
            "            done_task = next(iter(done))",
            "            if done_task is self.recv_cancel:",
            "                # recv was cancelled",
            "                for p in pending:",
            "                    p.cancel()",
            "                raise asyncio.CancelledError()",
            "            else:",
            "                self.recv_cancel.cancel()",
            "                return done_task.result()",
            "        finally:",
            "            self.recv_cancel = None",
            "            self.recv_lock.release()",
            "",
            "    async def recv_burst(self, max_recv=256) -> Sequence[Data]:",
            "        \"\"\"",
            "        Receive the messages which have arrived since last checking.",
            "        Return a :class:`list` containing :class:`str` for a text frame",
            "        and :class:`bytes` for a binary frame.",
            "        When the end of the message stream is reached, :meth:`recv_burst`",
            "        raises :exc:`~websockets.exceptions.ConnectionClosed`. Specifically,",
            "        it raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a",
            "        normal connection closure and",
            "        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol",
            "        error or a network failure.",
            "        :raises ~websockets.exceptions.ConnectionClosed: when the",
            "            connection is closed",
            "        :raises ServerError: if two tasks call :meth:`recv_burst` or",
            "            :meth:`recv_streaming` concurrently",
            "        \"\"\"",
            "",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"cannot call recv_burst while another task is already waiting \"",
            "                \"for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        messages = []",
            "        try:",
            "            # Prevent pausing the transport when we're",
            "            # receiving a burst of messages",
            "            self.can_pause = False",
            "            self.recv_cancel = asyncio.Future()",
            "            while True:",
            "                tasks = (",
            "                    self.recv_cancel,",
            "                    asyncio.ensure_future(self.assembler.get(timeout=0)),",
            "                )",
            "                done, pending = await asyncio.wait(",
            "                    tasks,",
            "                    return_when=asyncio.FIRST_COMPLETED,",
            "                )",
            "                done_task = next(iter(done))",
            "                if done_task is self.recv_cancel:",
            "                    # recv_burst was cancelled",
            "                    for p in pending:",
            "                        p.cancel()",
            "                    raise asyncio.CancelledError()",
            "                m = done_task.result()",
            "                if m is None:",
            "                    # None left in the burst. This is good!",
            "                    break",
            "                messages.append(m)",
            "                if len(messages) >= max_recv:",
            "                    # Too much data in the pipe. Hit our burst limit.",
            "                    break",
            "                # Allow an eventloop iteration for the",
            "                # next message to pass into the Assembler",
            "                await asyncio.sleep(0)",
            "            self.recv_cancel.cancel()",
            "        finally:",
            "            self.recv_cancel = None",
            "            self.can_pause = True",
            "            self.recv_lock.release()",
            "        return messages",
            "",
            "    async def recv_streaming(self) -> AsyncIterator[Data]:",
            "        \"\"\"",
            "        Receive the next message frame by frame.",
            "        Return an iterator of :class:`str` for a text frame and :class:`bytes`",
            "        for a binary frame. The iterator should be exhausted, or else the",
            "        connection will become unusable.",
            "        With the exception of the return value, :meth:`recv_streaming` behaves",
            "        like :meth:`recv`.",
            "        \"\"\"",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"Cannot call recv_streaming while another task \"",
            "                \"is already waiting for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        try:",
            "            cancelled = False",
            "            self.recv_cancel = asyncio.Future()",
            "            self.can_pause = False",
            "            async for m in self.assembler.get_iter():",
            "                if self.recv_cancel.done():",
            "                    cancelled = True",
            "                    break",
            "                yield m",
            "            if cancelled:",
            "                raise asyncio.CancelledError()",
            "        finally:",
            "            self.can_pause = True",
            "            self.recv_cancel = None",
            "            self.recv_lock.release()",
            "",
            "    async def send(self, message: Union[Data, Iterable[Data]]) -> None:",
            "        \"\"\"",
            "        Send a message.",
            "        A string (:class:`str`) is sent as a `Text frame`_. A bytestring or",
            "        bytes-like object (:class:`bytes`, :class:`bytearray`, or",
            "        :class:`memoryview`) is sent as a `Binary frame`_.",
            "        .. _Text frame: https://tools.ietf.org/html/rfc6455#section-5.6",
            "        .. _Binary frame: https://tools.ietf.org/html/rfc6455#section-5.6",
            "        :meth:`send` also accepts an iterable of strings, bytestrings, or",
            "        bytes-like objects. In that case the message is fragmented. Each item",
            "        is treated as a message fragment and sent in its own frame. All items",
            "        must be of the same type, or else :meth:`send` will raise a",
            "        :exc:`TypeError` and the connection will be closed.",
            "        :meth:`send` rejects dict-like objects because this is often an error.",
            "        If you wish to send the keys of a dict-like object as fragments, call",
            "        its :meth:`~dict.keys` method and pass the result to :meth:`send`.",
            "        :raises TypeError: for unsupported inputs",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                raise WebsocketClosed(",
            "                    \"Cannot write to websocket interface after it is closed.\"",
            "                )",
            "            if (not self.data_finished_fut) or self.data_finished_fut.done():",
            "                raise ServerError(",
            "                    \"Cannot write to websocket interface after it is finished.\"",
            "                )",
            "",
            "            # Unfragmented message -- this case must be handled first because",
            "            # strings and bytes-like objects are iterable.",
            "",
            "            if isinstance(message, str):",
            "                self.connection.send_text(message.encode(\"utf-8\"))",
            "                await self.send_data(self.connection.data_to_send())",
            "",
            "            elif isinstance(message, (bytes, bytearray, memoryview)):",
            "                self.connection.send_binary(message)",
            "                await self.send_data(self.connection.data_to_send())",
            "",
            "            elif isinstance(message, Mapping):",
            "                # Catch a common mistake -- passing a dict to send().",
            "                raise TypeError(\"data is a dict-like object\")",
            "",
            "            elif isinstance(message, Iterable):",
            "                # Fragmented message -- regular iterator.",
            "                raise NotImplementedError(",
            "                    \"Fragmented websocket messages are not supported.\"",
            "                )",
            "            else:",
            "                raise TypeError(\"Websocket data must be bytes, str.\")",
            "",
            "    async def ping(self, data: Optional[Data] = None) -> asyncio.Future:",
            "        \"\"\"",
            "        Send a ping.",
            "        Return an :class:`~asyncio.Future` that will be resolved when the",
            "        corresponding pong is received. You can ignore it if you don't intend",
            "        to wait.",
            "        A ping may serve as a keepalive or as a check that the remote endpoint",
            "        received all messages up to this point::",
            "            await pong_event = ws.ping()",
            "            await pong_event # only if you want to wait for the pong",
            "        By default, the ping contains four random bytes. This payload may be",
            "        overridden with the optional ``data`` argument which must be a string",
            "        (which will be encoded to UTF-8) or a bytes-like object.",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                raise WebsocketClosed(",
            "                    \"Cannot send a ping when the websocket interface \"",
            "                    \"is closed.\"",
            "                )",
            "            if (not self.io_proto) or (not self.io_proto.loop):",
            "                raise ServerError(",
            "                    \"Cannot send a ping when the websocket has no I/O \"",
            "                    \"protocol attached.\"",
            "                )",
            "            if data is not None:",
            "                if isinstance(data, str):",
            "                    data = data.encode(\"utf-8\")",
            "                elif isinstance(data, (bytearray, memoryview)):",
            "                    data = bytes(data)",
            "",
            "            # Protect against duplicates if a payload is explicitly set.",
            "            if data in self.pings:",
            "                raise ValueError(",
            "                    \"already waiting for a pong with the same data\"",
            "                )",
            "",
            "            # Generate a unique random payload otherwise.",
            "            while data is None or data in self.pings:",
            "                data = struct.pack(\"!I\", random.getrandbits(32))",
            "",
            "            self.pings[data] = self.io_proto.loop.create_future()",
            "",
            "            self.connection.send_ping(data)",
            "            await self.send_data(self.connection.data_to_send())",
            "",
            "            return asyncio.shield(self.pings[data])",
            "",
            "    async def pong(self, data: Data = b\"\") -> None:",
            "        \"\"\"",
            "        Send a pong.",
            "        An unsolicited pong may serve as a unidirectional heartbeat.",
            "        The payload may be set with the optional ``data`` argument which must",
            "        be a string (which will be encoded to UTF-8) or a bytes-like object.",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                # Cannot send pong after transport is shutting down",
            "                return",
            "            if isinstance(data, str):",
            "                data = data.encode(\"utf-8\")",
            "            elif isinstance(data, (bytearray, memoryview)):",
            "                data = bytes(data)",
            "            self.connection.send_pong(data)",
            "            await self.send_data(self.connection.data_to_send())",
            "",
            "    async def send_data(self, data_to_send):",
            "        for data in data_to_send:",
            "            if data:",
            "                await self.io_proto.send(data)",
            "            else:",
            "                # Send an EOF - We don't actually send it,",
            "                # just trigger to autoclose the connection",
            "                if (",
            "                    self.auto_closer_task",
            "                    and not self.auto_closer_task.done()",
            "                    and self.data_finished_fut",
            "                    and not self.data_finished_fut.done()",
            "                ):",
            "                    # Auto-close the connection",
            "                    self.data_finished_fut.set_result(None)",
            "                else:",
            "                    # This will fail the connection appropriately",
            "                    SanicProtocol.close(self.io_proto, timeout=1.0)",
            "",
            "    async def async_data_received(self, data_to_send, events_to_process):",
            "        if self.connection.state in (OPEN, CLOSING) and len(data_to_send) > 0:",
            "            # receiving data can generate data to send (eg, pong for a ping)",
            "            # send connection.data_to_send()",
            "            await self.send_data(data_to_send)",
            "        if len(events_to_process) > 0:",
            "            await self.process_events(events_to_process)",
            "",
            "    def data_received(self, data):",
            "        self.connection.receive_data(data)",
            "        data_to_send = self.connection.data_to_send()",
            "        events_to_process = self.connection.events_received()",
            "        if len(data_to_send) > 0 or len(events_to_process) > 0:",
            "            asyncio.create_task(",
            "                self.async_data_received(data_to_send, events_to_process)",
            "            )",
            "",
            "    async def async_eof_received(self, data_to_send, events_to_process):",
            "        # receiving EOF can generate data to send",
            "        # send connection.data_to_send()",
            "        if self.connection.state in (OPEN, CLOSING) and len(data_to_send) > 0:",
            "            await self.send_data(data_to_send)",
            "        if len(events_to_process) > 0:",
            "            await self.process_events(events_to_process)",
            "        if self.recv_cancel:",
            "            self.recv_cancel.cancel()",
            "        if (",
            "            self.auto_closer_task",
            "            and not self.auto_closer_task.done()",
            "            and self.data_finished_fut",
            "            and not self.data_finished_fut.done()",
            "        ):",
            "            # Auto-close the connection",
            "            self.data_finished_fut.set_result(None)",
            "            # Cancel the running handler if its waiting",
            "        else:",
            "            # This will fail the connection appropriately",
            "            SanicProtocol.close(self.io_proto, timeout=1.0)",
            "",
            "    def eof_received(self) -> Optional[bool]:",
            "        self.connection.receive_eof()",
            "        data_to_send = self.connection.data_to_send()",
            "        events_to_process = self.connection.events_received()",
            "        asyncio.create_task(",
            "            self.async_eof_received(data_to_send, events_to_process)",
            "        )",
            "        return False",
            "",
            "    def connection_lost(self, exc):",
            "        \"\"\"",
            "        The WebSocket Connection is Closed.",
            "        \"\"\"",
            "        if not self.connection.state == CLOSED:",
            "            # signal to the websocket connection handler",
            "            # we've lost the connection",
            "            self.connection.fail(code=1006)",
            "            self.connection.state = CLOSED",
            "",
            "        self.abort_pings()",
            "        if self.connection_lost_waiter:",
            "            self.connection_lost_waiter.set_result(None)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import random",
            "import struct",
            "",
            "from typing import (",
            "    AsyncIterator,",
            "    Dict,",
            "    Iterable,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Union,",
            ")",
            "",
            "from websockets.connection import CLOSED, CLOSING, OPEN, Event",
            "from websockets.exceptions import ConnectionClosed, ConnectionClosedError",
            "from websockets.frames import Frame, Opcode",
            "from websockets.server import ServerConnection",
            "from websockets.typing import Data",
            "",
            "from sanic.log import error_logger, logger",
            "from sanic.server.protocols.base_protocol import SanicProtocol",
            "",
            "from ...exceptions import ServerError, WebsocketClosed",
            "from .frame import WebsocketFrameAssembler",
            "",
            "",
            "class WebsocketImplProtocol:",
            "    connection: ServerConnection",
            "    io_proto: Optional[SanicProtocol]",
            "    loop: Optional[asyncio.AbstractEventLoop]",
            "    max_queue: int",
            "    close_timeout: float",
            "    ping_interval: Optional[float]",
            "    ping_timeout: Optional[float]",
            "    assembler: WebsocketFrameAssembler",
            "    # Dict[bytes, asyncio.Future[None]]",
            "    pings: Dict[bytes, asyncio.Future]",
            "    conn_mutex: asyncio.Lock",
            "    recv_lock: asyncio.Lock",
            "    recv_cancel: Optional[asyncio.Future]",
            "    process_event_mutex: asyncio.Lock",
            "    can_pause: bool",
            "    # Optional[asyncio.Future[None]]",
            "    data_finished_fut: Optional[asyncio.Future]",
            "    # Optional[asyncio.Future[None]]",
            "    pause_frame_fut: Optional[asyncio.Future]",
            "    # Optional[asyncio.Future[None]]",
            "    connection_lost_waiter: Optional[asyncio.Future]",
            "    keepalive_ping_task: Optional[asyncio.Task]",
            "    auto_closer_task: Optional[asyncio.Task]",
            "",
            "    def __init__(",
            "        self,",
            "        connection,",
            "        max_queue=None,",
            "        ping_interval: Optional[float] = 20,",
            "        ping_timeout: Optional[float] = 20,",
            "        close_timeout: float = 10,",
            "        loop=None,",
            "    ):",
            "        self.connection = connection",
            "        self.io_proto = None",
            "        self.loop = None",
            "        self.max_queue = max_queue",
            "        self.close_timeout = close_timeout",
            "        self.ping_interval = ping_interval",
            "        self.ping_timeout = ping_timeout",
            "        self.assembler = WebsocketFrameAssembler(self)",
            "        self.pings = {}",
            "        self.conn_mutex = asyncio.Lock()",
            "        self.recv_lock = asyncio.Lock()",
            "        self.recv_cancel = None",
            "        self.process_event_mutex = asyncio.Lock()",
            "        self.data_finished_fut = None",
            "        self.can_pause = True",
            "        self.pause_frame_fut = None",
            "        self.keepalive_ping_task = None",
            "        self.auto_closer_task = None",
            "        self.connection_lost_waiter = None",
            "",
            "    @property",
            "    def subprotocol(self):",
            "        return self.connection.subprotocol",
            "",
            "    def pause_frames(self):",
            "        if not self.can_pause:",
            "            return False",
            "        if self.pause_frame_fut:",
            "            logger.debug(\"Websocket connection already paused.\")",
            "            return False",
            "        if (not self.loop) or (not self.io_proto):",
            "            return False",
            "        if self.io_proto.transport:",
            "            self.io_proto.transport.pause_reading()",
            "        self.pause_frame_fut = self.loop.create_future()",
            "        logger.debug(\"Websocket connection paused.\")",
            "        return True",
            "",
            "    def resume_frames(self):",
            "        if not self.pause_frame_fut:",
            "            logger.debug(\"Websocket connection not paused.\")",
            "            return False",
            "        if (not self.loop) or (not self.io_proto):",
            "            logger.debug(",
            "                \"Websocket attempting to resume reading frames, \"",
            "                \"but connection is gone.\"",
            "            )",
            "            return False",
            "        if self.io_proto.transport:",
            "            self.io_proto.transport.resume_reading()",
            "        self.pause_frame_fut.set_result(None)",
            "        self.pause_frame_fut = None",
            "        logger.debug(\"Websocket connection unpaused.\")",
            "        return True",
            "",
            "    async def connection_made(",
            "        self,",
            "        io_proto: SanicProtocol,",
            "        loop: Optional[asyncio.AbstractEventLoop] = None,",
            "    ):",
            "        if not loop:",
            "            try:",
            "                loop = getattr(io_proto, \"loop\")",
            "            except AttributeError:",
            "                loop = asyncio.get_event_loop()",
            "        if not loop:",
            "            # This catch is for mypy type checker",
            "            # to assert loop is not None here.",
            "            raise ServerError(\"Connection received with no asyncio loop.\")",
            "        if self.auto_closer_task:",
            "            raise ServerError(",
            "                \"Cannot call connection_made more than once \"",
            "                \"on a websocket connection.\"",
            "            )",
            "        self.loop = loop",
            "        self.io_proto = io_proto",
            "        self.connection_lost_waiter = self.loop.create_future()",
            "        self.data_finished_fut = asyncio.shield(self.loop.create_future())",
            "",
            "        if self.ping_interval:",
            "            self.keepalive_ping_task = asyncio.create_task(",
            "                self.keepalive_ping()",
            "            )",
            "        self.auto_closer_task = asyncio.create_task(",
            "            self.auto_close_connection()",
            "        )",
            "",
            "    async def wait_for_connection_lost(self, timeout=None) -> bool:",
            "        \"\"\"",
            "        Wait until the TCP connection is closed or ``timeout`` elapses.",
            "        If timeout is None, wait forever.",
            "        Recommend you should pass in self.close_timeout as timeout",
            "",
            "        Return ``True`` if the connection is closed and ``False`` otherwise.",
            "",
            "        \"\"\"",
            "        if not self.connection_lost_waiter:",
            "            return False",
            "        if self.connection_lost_waiter.done():",
            "            return True",
            "        else:",
            "            try:",
            "                await asyncio.wait_for(",
            "                    asyncio.shield(self.connection_lost_waiter), timeout",
            "                )",
            "                return True",
            "            except asyncio.TimeoutError:",
            "                # Re-check self.connection_lost_waiter.done() synchronously",
            "                # because connection_lost() could run between the moment the",
            "                # timeout occurs and the moment this coroutine resumes running",
            "                return self.connection_lost_waiter.done()",
            "",
            "    async def process_events(self, events: Sequence[Event]) -> None:",
            "        \"\"\"",
            "        Process a list of incoming events.",
            "        \"\"\"",
            "        # Wrapped in a mutex lock, to prevent other incoming events",
            "        # from processing at the same time",
            "        async with self.process_event_mutex:",
            "            for event in events:",
            "                if not isinstance(event, Frame):",
            "                    # Event is not a frame. Ignore it.",
            "                    continue",
            "                if event.opcode == Opcode.PONG:",
            "                    await self.process_pong(event)",
            "                elif event.opcode == Opcode.CLOSE:",
            "                    if self.recv_cancel:",
            "                        self.recv_cancel.cancel()",
            "                else:",
            "                    await self.assembler.put(event)",
            "",
            "    async def process_pong(self, frame: Frame) -> None:",
            "        if frame.data in self.pings:",
            "            # Acknowledge all pings up to the one matching this pong.",
            "            ping_ids = []",
            "            for ping_id, ping in self.pings.items():",
            "                ping_ids.append(ping_id)",
            "                if not ping.done():",
            "                    ping.set_result(None)",
            "                if ping_id == frame.data:",
            "                    break",
            "            else:  # noqa",
            "                raise ServerError(\"ping_id is not in self.pings\")",
            "            # Remove acknowledged pings from self.pings.",
            "            for ping_id in ping_ids:",
            "                del self.pings[ping_id]",
            "",
            "    async def keepalive_ping(self) -> None:",
            "        \"\"\"",
            "        Send a Ping frame and wait for a Pong frame at regular intervals.",
            "        This coroutine exits when the connection terminates and one of the",
            "        following happens:",
            "        - :meth:`ping` raises :exc:`ConnectionClosed`, or",
            "        - :meth:`auto_close_connection` cancels :attr:`keepalive_ping_task`.",
            "        \"\"\"",
            "        if self.ping_interval is None:",
            "            return",
            "",
            "        try:",
            "            while True:",
            "                await asyncio.sleep(self.ping_interval)",
            "",
            "                # ping() raises CancelledError if the connection is closed,",
            "                # when auto_close_connection() cancels keepalive_ping_task.",
            "",
            "                # ping() raises ConnectionClosed if the connection is lost,",
            "                # when connection_lost() calls abort_pings().",
            "",
            "                ping_waiter = await self.ping()",
            "",
            "                if self.ping_timeout is not None:",
            "                    try:",
            "                        await asyncio.wait_for(ping_waiter, self.ping_timeout)",
            "                    except asyncio.TimeoutError:",
            "                        error_logger.warning(",
            "                            \"Websocket timed out waiting for pong\"",
            "                        )",
            "                        self.fail_connection(1011)",
            "                        break",
            "        except asyncio.CancelledError:",
            "            # It is expected for this task to be cancelled during during",
            "            # normal operation, when the connection is closed.",
            "            logger.debug(\"Websocket keepalive ping task was cancelled.\")",
            "        except (ConnectionClosed, WebsocketClosed):",
            "            logger.debug(\"Websocket closed. Keepalive ping task exiting.\")",
            "        except Exception as e:",
            "            error_logger.warning(",
            "                \"Unexpected exception in websocket keepalive ping task.\"",
            "            )",
            "            logger.debug(str(e))",
            "",
            "    def _force_disconnect(self) -> bool:",
            "        \"\"\"",
            "        Internal method used by end_connection and fail_connection",
            "        only when the graceful auto-closer cannot be used",
            "        \"\"\"",
            "        if self.auto_closer_task and not self.auto_closer_task.done():",
            "            self.auto_closer_task.cancel()",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if self.keepalive_ping_task and not self.keepalive_ping_task.done():",
            "            self.keepalive_ping_task.cancel()",
            "            self.keepalive_ping_task = None",
            "        if self.loop and self.io_proto and self.io_proto.transport:",
            "            self.io_proto.transport.close()",
            "            self.loop.call_later(",
            "                self.close_timeout, self.io_proto.transport.abort",
            "            )",
            "        # We were never open, or already closed",
            "        return True",
            "",
            "    def fail_connection(self, code: int = 1006, reason: str = \"\") -> bool:",
            "        \"\"\"",
            "        Fail the WebSocket Connection",
            "        This requires:",
            "        1. Stopping all processing of incoming data, which means cancelling",
            "           pausing the underlying io protocol. The close code will be 1006",
            "           unless a close frame was received earlier.",
            "        2. Sending a close frame with an appropriate code if the opening",
            "           handshake succeeded and the other side is likely to process it.",
            "        3. Closing the connection. :meth:`auto_close_connection` takes care",
            "           of this.",
            "        (The specification describes these steps in the opposite order.)",
            "        \"\"\"",
            "        if self.io_proto and self.io_proto.transport:",
            "            # Stop new data coming in",
            "            # In Python Version 3.7: pause_reading is idempotent",
            "            # ut can be called when the transport is already paused or closed",
            "            self.io_proto.transport.pause_reading()",
            "",
            "            # Keeping fail_connection() synchronous guarantees it can't",
            "            # get stuck and simplifies the implementation of the callers.",
            "            # Not draining the write buffer is acceptable in this context.",
            "",
            "            # clear the send buffer",
            "            _ = self.connection.data_to_send()",
            "            # If we're not already CLOSED or CLOSING, then send the close.",
            "            if self.connection.state is OPEN:",
            "                if code in (1000, 1001):",
            "                    self.connection.send_close(code, reason)",
            "                else:",
            "                    self.connection.fail(code, reason)",
            "                try:",
            "                    data_to_send = self.connection.data_to_send()",
            "                    while (",
            "                        len(data_to_send)",
            "                        and self.io_proto",
            "                        and self.io_proto.transport",
            "                    ):",
            "                        frame_data = data_to_send.pop(0)",
            "                        self.io_proto.transport.write(frame_data)",
            "                except Exception:",
            "                    # sending close frames may fail if the",
            "                    # transport closes during this period",
            "                    ...",
            "        if code == 1006:",
            "            # Special case: 1006 consider the transport already closed",
            "            self.connection.state = CLOSED",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            # We have a graceful auto-closer. Use it to close the connection.",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if (not self.auto_closer_task) or self.auto_closer_task.done():",
            "            return self._force_disconnect()",
            "        return False",
            "",
            "    def end_connection(self, code=1000, reason=\"\"):",
            "        # This is like slightly more graceful form of fail_connection",
            "        # Use this instead of close() when you need an immediate",
            "        # close and cannot await websocket.close() handshake.",
            "",
            "        if code == 1006 or not self.io_proto or not self.io_proto.transport:",
            "            return self.fail_connection(code, reason)",
            "",
            "        # Stop new data coming in",
            "        # In Python Version 3.7: pause_reading is idempotent",
            "        # i.e. it can be called when the transport is already paused or closed.",
            "        self.io_proto.transport.pause_reading()",
            "        if self.connection.state == OPEN:",
            "            data_to_send = self.connection.data_to_send()",
            "            self.connection.send_close(code, reason)",
            "            data_to_send.extend(self.connection.data_to_send())",
            "            try:",
            "                while (",
            "                    len(data_to_send)",
            "                    and self.io_proto",
            "                    and self.io_proto.transport",
            "                ):",
            "                    frame_data = data_to_send.pop(0)",
            "                    self.io_proto.transport.write(frame_data)",
            "            except Exception:",
            "                # sending close frames may fail if the",
            "                # transport closes during this period",
            "                # But that doesn't matter at this point",
            "                ...",
            "        if self.data_finished_fut and not self.data_finished_fut.done():",
            "            # We have the ability to signal the auto-closer",
            "            # try to trigger it to auto-close the connection",
            "            self.data_finished_fut.cancel()",
            "            self.data_finished_fut = None",
            "        if (not self.auto_closer_task) or self.auto_closer_task.done():",
            "            # Auto-closer is not running, do force disconnect",
            "            return self._force_disconnect()",
            "        return False",
            "",
            "    async def auto_close_connection(self) -> None:",
            "        \"\"\"",
            "        Close the WebSocket Connection",
            "        When the opening handshake succeeds, :meth:`connection_open` starts",
            "        this coroutine in a task. It waits for the data transfer phase to",
            "        complete then it closes the TCP connection cleanly.",
            "        When the opening handshake fails, :meth:`fail_connection` does the",
            "        same. There's no data transfer phase in that case.",
            "        \"\"\"",
            "        try:",
            "            # Wait for the data transfer phase to complete.",
            "            if self.data_finished_fut:",
            "                try:",
            "                    await self.data_finished_fut",
            "                    logger.debug(",
            "                        \"Websocket task finished. Closing the connection.\"",
            "                    )",
            "                except asyncio.CancelledError:",
            "                    # Cancelled error is called when data phase is cancelled",
            "                    # if an error occurred or the client closed the connection",
            "                    logger.debug(",
            "                        \"Websocket handler cancelled. Closing the connection.\"",
            "                    )",
            "",
            "            # Cancel the keepalive ping task.",
            "            if self.keepalive_ping_task:",
            "                self.keepalive_ping_task.cancel()",
            "                self.keepalive_ping_task = None",
            "",
            "            # Half-close the TCP connection if possible (when there's no TLS).",
            "            if (",
            "                self.io_proto",
            "                and self.io_proto.transport",
            "                and self.io_proto.transport.can_write_eof()",
            "            ):",
            "                logger.debug(\"Websocket half-closing TCP connection\")",
            "                self.io_proto.transport.write_eof()",
            "                if self.connection_lost_waiter:",
            "                    if await self.wait_for_connection_lost(timeout=0):",
            "                        return",
            "        except asyncio.CancelledError:",
            "            ...",
            "        finally:",
            "            # The try/finally ensures that the transport never remains open,",
            "            # even if this coroutine is cancelled (for example).",
            "            if (not self.io_proto) or (not self.io_proto.transport):",
            "                # we were never open, or done. Can't do any finalization.",
            "                return",
            "            elif (",
            "                self.connection_lost_waiter",
            "                and self.connection_lost_waiter.done()",
            "            ):",
            "                # connection confirmed closed already, proceed to abort waiter",
            "                ...",
            "            elif self.io_proto.transport.is_closing():",
            "                # Connection is already closing (due to half-close above)",
            "                # proceed to abort waiter",
            "                ...",
            "            else:",
            "                self.io_proto.transport.close()",
            "            if not self.connection_lost_waiter:",
            "                # Our connection monitor task isn't running.",
            "                try:",
            "                    await asyncio.sleep(self.close_timeout)",
            "                except asyncio.CancelledError:",
            "                    ...",
            "                if self.io_proto and self.io_proto.transport:",
            "                    self.io_proto.transport.abort()",
            "            else:",
            "                if await self.wait_for_connection_lost(",
            "                    timeout=self.close_timeout",
            "                ):",
            "                    # Connection aborted before the timeout expired.",
            "                    return",
            "                error_logger.warning(",
            "                    \"Timeout waiting for TCP connection to close. Aborting\"",
            "                )",
            "                if self.io_proto and self.io_proto.transport:",
            "                    self.io_proto.transport.abort()",
            "",
            "    def abort_pings(self) -> None:",
            "        \"\"\"",
            "        Raise ConnectionClosed in pending keepalive pings.",
            "        They'll never receive a pong once the connection is closed.",
            "        \"\"\"",
            "        if self.connection.state is not CLOSED:",
            "            raise ServerError(",
            "                \"Webscoket about_pings should only be called \"",
            "                \"after connection state is changed to CLOSED\"",
            "            )",
            "",
            "        for ping in self.pings.values():",
            "            ping.set_exception(ConnectionClosedError(None, None))",
            "            # If the exception is never retrieved, it will be logged when ping",
            "            # is garbage-collected. This is confusing for users.",
            "            # Given that ping is done (with an exception), canceling it does",
            "            # nothing, but it prevents logging the exception.",
            "            ping.cancel()",
            "",
            "    async def close(self, code: int = 1000, reason: str = \"\") -> None:",
            "        \"\"\"",
            "        Perform the closing handshake.",
            "        This is a websocket-protocol level close.",
            "        :meth:`close` waits for the other end to complete the handshake and",
            "        for the TCP connection to terminate.",
            "        :meth:`close` is idempotent: it doesn't do anything once the",
            "        connection is closed.",
            "        :param code: WebSocket close code",
            "        :param reason: WebSocket close reason",
            "        \"\"\"",
            "        if code == 1006:",
            "            self.fail_connection(code, reason)",
            "            return",
            "        async with self.conn_mutex:",
            "            if self.connection.state is OPEN:",
            "                self.connection.send_close(code, reason)",
            "                data_to_send = self.connection.data_to_send()",
            "                await self.send_data(data_to_send)",
            "",
            "    async def recv(self, timeout: Optional[float] = None) -> Optional[Data]:",
            "        \"\"\"",
            "        Receive the next message.",
            "        Return a :class:`str` for a text frame and :class:`bytes` for a binary",
            "        frame.",
            "        When the end of the message stream is reached, :meth:`recv` raises",
            "        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it",
            "        raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal",
            "        connection closure and",
            "        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol",
            "        error or a network failure.",
            "        If ``timeout`` is ``None``, block until a message is received. Else,",
            "        if no message is received within ``timeout`` seconds, return ``None``.",
            "        Set ``timeout`` to ``0`` to check if a message was already received.",
            "        :raises ~websockets.exceptions.ConnectionClosed: when the",
            "            connection is closed",
            "        :raises asyncio.CancelledError: if the websocket closes while waiting",
            "        :raises ServerError: if two tasks call :meth:`recv` or",
            "            :meth:`recv_streaming` concurrently",
            "        \"\"\"",
            "",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"cannot call recv while another task is \"",
            "                \"already waiting for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        try:",
            "            self.recv_cancel = asyncio.Future()",
            "            tasks = (",
            "                self.recv_cancel,",
            "                asyncio.ensure_future(self.assembler.get(timeout)),",
            "            )",
            "            done, pending = await asyncio.wait(",
            "                tasks,",
            "                return_when=asyncio.FIRST_COMPLETED,",
            "            )",
            "            done_task = next(iter(done))",
            "            if done_task is self.recv_cancel:",
            "                # recv was cancelled",
            "                for p in pending:",
            "                    p.cancel()",
            "                raise asyncio.CancelledError()",
            "            else:",
            "                self.recv_cancel.cancel()",
            "                return done_task.result()",
            "        finally:",
            "            self.recv_cancel = None",
            "            self.recv_lock.release()",
            "",
            "    async def recv_burst(self, max_recv=256) -> Sequence[Data]:",
            "        \"\"\"",
            "        Receive the messages which have arrived since last checking.",
            "        Return a :class:`list` containing :class:`str` for a text frame",
            "        and :class:`bytes` for a binary frame.",
            "        When the end of the message stream is reached, :meth:`recv_burst`",
            "        raises :exc:`~websockets.exceptions.ConnectionClosed`. Specifically,",
            "        it raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a",
            "        normal connection closure and",
            "        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol",
            "        error or a network failure.",
            "        :raises ~websockets.exceptions.ConnectionClosed: when the",
            "            connection is closed",
            "        :raises ServerError: if two tasks call :meth:`recv_burst` or",
            "            :meth:`recv_streaming` concurrently",
            "        \"\"\"",
            "",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"cannot call recv_burst while another task is already waiting \"",
            "                \"for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        messages = []",
            "        try:",
            "            # Prevent pausing the transport when we're",
            "            # receiving a burst of messages",
            "            self.can_pause = False",
            "            self.recv_cancel = asyncio.Future()",
            "            while True:",
            "                tasks = (",
            "                    self.recv_cancel,",
            "                    asyncio.ensure_future(self.assembler.get(timeout=0)),",
            "                )",
            "                done, pending = await asyncio.wait(",
            "                    tasks,",
            "                    return_when=asyncio.FIRST_COMPLETED,",
            "                )",
            "                done_task = next(iter(done))",
            "                if done_task is self.recv_cancel:",
            "                    # recv_burst was cancelled",
            "                    for p in pending:",
            "                        p.cancel()",
            "                    raise asyncio.CancelledError()",
            "                m = done_task.result()",
            "                if m is None:",
            "                    # None left in the burst. This is good!",
            "                    break",
            "                messages.append(m)",
            "                if len(messages) >= max_recv:",
            "                    # Too much data in the pipe. Hit our burst limit.",
            "                    break",
            "                # Allow an eventloop iteration for the",
            "                # next message to pass into the Assembler",
            "                await asyncio.sleep(0)",
            "            self.recv_cancel.cancel()",
            "        finally:",
            "            self.recv_cancel = None",
            "            self.can_pause = True",
            "            self.recv_lock.release()",
            "        return messages",
            "",
            "    async def recv_streaming(self) -> AsyncIterator[Data]:",
            "        \"\"\"",
            "        Receive the next message frame by frame.",
            "        Return an iterator of :class:`str` for a text frame and :class:`bytes`",
            "        for a binary frame. The iterator should be exhausted, or else the",
            "        connection will become unusable.",
            "        With the exception of the return value, :meth:`recv_streaming` behaves",
            "        like :meth:`recv`.",
            "        \"\"\"",
            "        if self.recv_lock.locked():",
            "            raise ServerError(",
            "                \"Cannot call recv_streaming while another task \"",
            "                \"is already waiting for the next message\"",
            "            )",
            "        await self.recv_lock.acquire()",
            "        if self.connection.state is CLOSED:",
            "            self.recv_lock.release()",
            "            raise WebsocketClosed(",
            "                \"Cannot receive from websocket interface after it is closed.\"",
            "            )",
            "        try:",
            "            cancelled = False",
            "            self.recv_cancel = asyncio.Future()",
            "            self.can_pause = False",
            "            async for m in self.assembler.get_iter():",
            "                if self.recv_cancel.done():",
            "                    cancelled = True",
            "                    break",
            "                yield m",
            "            if cancelled:",
            "                raise asyncio.CancelledError()",
            "        finally:",
            "            self.can_pause = True",
            "            self.recv_cancel = None",
            "            self.recv_lock.release()",
            "",
            "    async def send(self, message: Union[Data, Iterable[Data]]) -> None:",
            "        \"\"\"",
            "        Send a message.",
            "        A string (:class:`str`) is sent as a `Text frame`_. A bytestring or",
            "        bytes-like object (:class:`bytes`, :class:`bytearray`, or",
            "        :class:`memoryview`) is sent as a `Binary frame`_.",
            "        .. _Text frame: https://tools.ietf.org/html/rfc6455#section-5.6",
            "        .. _Binary frame: https://tools.ietf.org/html/rfc6455#section-5.6",
            "        :meth:`send` also accepts an iterable of strings, bytestrings, or",
            "        bytes-like objects. In that case the message is fragmented. Each item",
            "        is treated as a message fragment and sent in its own frame. All items",
            "        must be of the same type, or else :meth:`send` will raise a",
            "        :exc:`TypeError` and the connection will be closed.",
            "        :meth:`send` rejects dict-like objects because this is often an error.",
            "        If you wish to send the keys of a dict-like object as fragments, call",
            "        its :meth:`~dict.keys` method and pass the result to :meth:`send`.",
            "        :raises TypeError: for unsupported inputs",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                raise WebsocketClosed(",
            "                    \"Cannot write to websocket interface after it is closed.\"",
            "                )",
            "            if (not self.data_finished_fut) or self.data_finished_fut.done():",
            "                raise ServerError(",
            "                    \"Cannot write to websocket interface after it is finished.\"",
            "                )",
            "",
            "            # Unfragmented message -- this case must be handled first because",
            "            # strings and bytes-like objects are iterable.",
            "",
            "            if isinstance(message, str):",
            "                self.connection.send_text(message.encode(\"utf-8\"))",
            "                await self.send_data(self.connection.data_to_send())",
            "",
            "            elif isinstance(message, (bytes, bytearray, memoryview)):",
            "                self.connection.send_binary(message)",
            "                await self.send_data(self.connection.data_to_send())",
            "",
            "            elif isinstance(message, Mapping):",
            "                # Catch a common mistake -- passing a dict to send().",
            "                raise TypeError(\"data is a dict-like object\")",
            "",
            "            elif isinstance(message, Iterable):",
            "                # Fragmented message -- regular iterator.",
            "                raise NotImplementedError(",
            "                    \"Fragmented websocket messages are not supported.\"",
            "                )",
            "            else:",
            "                raise TypeError(\"Websocket data must be bytes, str.\")",
            "",
            "    async def ping(self, data: Optional[Data] = None) -> asyncio.Future:",
            "        \"\"\"",
            "        Send a ping.",
            "        Return an :class:`~asyncio.Future` that will be resolved when the",
            "        corresponding pong is received. You can ignore it if you don't intend",
            "        to wait.",
            "        A ping may serve as a keepalive or as a check that the remote endpoint",
            "        received all messages up to this point::",
            "            await pong_event = ws.ping()",
            "            await pong_event # only if you want to wait for the pong",
            "        By default, the ping contains four random bytes. This payload may be",
            "        overridden with the optional ``data`` argument which must be a string",
            "        (which will be encoded to UTF-8) or a bytes-like object.",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                raise WebsocketClosed(",
            "                    \"Cannot send a ping when the websocket interface \"",
            "                    \"is closed.\"",
            "                )",
            "            if (not self.io_proto) or (not self.io_proto.loop):",
            "                raise ServerError(",
            "                    \"Cannot send a ping when the websocket has no I/O \"",
            "                    \"protocol attached.\"",
            "                )",
            "            if data is not None:",
            "                if isinstance(data, str):",
            "                    data = data.encode(\"utf-8\")",
            "                elif isinstance(data, (bytearray, memoryview)):",
            "                    data = bytes(data)",
            "",
            "            # Protect against duplicates if a payload is explicitly set.",
            "            if data in self.pings:",
            "                raise ValueError(",
            "                    \"already waiting for a pong with the same data\"",
            "                )",
            "",
            "            # Generate a unique random payload otherwise.",
            "            while data is None or data in self.pings:",
            "                data = struct.pack(\"!I\", random.getrandbits(32))",
            "",
            "            self.pings[data] = self.io_proto.loop.create_future()",
            "",
            "            self.connection.send_ping(data)",
            "            await self.send_data(self.connection.data_to_send())",
            "",
            "            return asyncio.shield(self.pings[data])",
            "",
            "    async def pong(self, data: Data = b\"\") -> None:",
            "        \"\"\"",
            "        Send a pong.",
            "        An unsolicited pong may serve as a unidirectional heartbeat.",
            "        The payload may be set with the optional ``data`` argument which must",
            "        be a string (which will be encoded to UTF-8) or a bytes-like object.",
            "        \"\"\"",
            "        async with self.conn_mutex:",
            "            if self.connection.state in (CLOSED, CLOSING):",
            "                # Cannot send pong after transport is shutting down",
            "                return",
            "            if isinstance(data, str):",
            "                data = data.encode(\"utf-8\")",
            "            elif isinstance(data, (bytearray, memoryview)):",
            "                data = bytes(data)",
            "            self.connection.send_pong(data)",
            "            await self.send_data(self.connection.data_to_send())",
            "",
            "    async def send_data(self, data_to_send):",
            "        for data in data_to_send:",
            "            if data:",
            "                await self.io_proto.send(data)",
            "            else:",
            "                # Send an EOF - We don't actually send it,",
            "                # just trigger to autoclose the connection",
            "                if (",
            "                    self.auto_closer_task",
            "                    and not self.auto_closer_task.done()",
            "                    and self.data_finished_fut",
            "                    and not self.data_finished_fut.done()",
            "                ):",
            "                    # Auto-close the connection",
            "                    self.data_finished_fut.set_result(None)",
            "                else:",
            "                    # This will fail the connection appropriately",
            "                    SanicProtocol.close(self.io_proto, timeout=1.0)",
            "",
            "    async def async_data_received(self, data_to_send, events_to_process):",
            "        if self.connection.state in (OPEN, CLOSING) and len(data_to_send) > 0:",
            "            # receiving data can generate data to send (eg, pong for a ping)",
            "            # send connection.data_to_send()",
            "            await self.send_data(data_to_send)",
            "        if len(events_to_process) > 0:",
            "            await self.process_events(events_to_process)",
            "",
            "    def data_received(self, data):",
            "        self.connection.receive_data(data)",
            "        data_to_send = self.connection.data_to_send()",
            "        events_to_process = self.connection.events_received()",
            "        if len(data_to_send) > 0 or len(events_to_process) > 0:",
            "            asyncio.create_task(",
            "                self.async_data_received(data_to_send, events_to_process)",
            "            )",
            "",
            "    async def async_eof_received(self, data_to_send, events_to_process):",
            "        # receiving EOF can generate data to send",
            "        # send connection.data_to_send()",
            "        if self.connection.state in (OPEN, CLOSING) and len(data_to_send) > 0:",
            "            await self.send_data(data_to_send)",
            "        if len(events_to_process) > 0:",
            "            await self.process_events(events_to_process)",
            "        if self.recv_cancel:",
            "            self.recv_cancel.cancel()",
            "        if (",
            "            self.auto_closer_task",
            "            and not self.auto_closer_task.done()",
            "            and self.data_finished_fut",
            "            and not self.data_finished_fut.done()",
            "        ):",
            "            # Auto-close the connection",
            "            self.data_finished_fut.set_result(None)",
            "            # Cancel the running handler if its waiting",
            "        else:",
            "            # This will fail the connection appropriately",
            "            SanicProtocol.close(self.io_proto, timeout=1.0)",
            "",
            "    def eof_received(self) -> Optional[bool]:",
            "        self.connection.receive_eof()",
            "        data_to_send = self.connection.data_to_send()",
            "        events_to_process = self.connection.events_received()",
            "        asyncio.create_task(",
            "            self.async_eof_received(data_to_send, events_to_process)",
            "        )",
            "        return False",
            "",
            "    def connection_lost(self, exc):",
            "        \"\"\"",
            "        The WebSocket Connection is Closed.",
            "        \"\"\"",
            "        if not self.connection.state == CLOSED:",
            "            # signal to the websocket connection handler",
            "            # we've lost the connection",
            "            self.connection.fail(code=1006)",
            "            self.connection.state = CLOSED",
            "",
            "        self.abort_pings()",
            "        if self.connection_lost_waiter:",
            "            self.connection_lost_waiter.set_result(None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "255": [
                "WebsocketImplProtocol",
                "_force_disconnect"
            ]
        },
        "addLocation": []
    }
}