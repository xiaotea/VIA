{
    "os_vif/internal/ip/ip_command.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     @abc.abstractmethod"
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,"
            },
            "3": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            vlan_id=None):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            vlan_id=None, ageing=None):"
            },
            "5": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         \"\"\"Method to add an interface."
            },
            "6": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         :param   device: A network device (string)"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         :param   link: String root network interface name, 'device' will be a"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                        VLAN tagged virtual interface"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         :param   vlan_id: Integer VLAN ID for VLAN devices"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        :param   ageing: integer value in seconds before learned"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                         mac addresses are forgotten."
            },
            "13": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         :return: status of the command execution"
            },
            "14": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "import six",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class IpCommand(object):",
            "",
            "    TYPE_VETH = 'veth'",
            "    TYPE_VLAN = 'vlan'",
            "    TYPE_BRIDGE = 'bridge'",
            "",
            "    @abc.abstractmethod",
            "    def set(self, device, check_exit_code=None, state=None, mtu=None,",
            "            address=None, promisc=None, master=None):",
            "        \"\"\"Method to set a parameter in an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   check_exit_code: List of integers of allowed execution exit",
            "                                  codes",
            "        :param   state: String network device state",
            "        :param   mtu: Integer MTU value",
            "        :param   address: String MAC address",
            "        :param   promisc: Boolean promiscuous mode",
            "        :param   master: String the master device that this device belongs to",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,",
            "            vlan_id=None):",
            "        \"\"\"Method to add an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   dev_type: String network device type (TYPE_VETH, TYPE_VLAN)",
            "        :param   check_exit_code: List of integers of allowed execution exit",
            "                                  codes",
            "        :param   peer: String peer name, for veth interfaces",
            "        :param   link: String root network interface name, 'device' will be a",
            "                       VLAN tagged virtual interface",
            "        :param   vlan_id: Integer VLAN ID for VLAN devices",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def delete(self, device, check_exit_code=None):",
            "        \"\"\"Method to delete an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   dev_type: String network device type (TYPE_VETH, TYPE_VLAN)",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def exists(self, device):",
            "        \"\"\"Method to dectect if a device exists.",
            "",
            "        :param   device: A network device (string)",
            "        :return: True if device exists else False",
            "        \"\"\""
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "import six",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class IpCommand(object):",
            "",
            "    TYPE_VETH = 'veth'",
            "    TYPE_VLAN = 'vlan'",
            "    TYPE_BRIDGE = 'bridge'",
            "",
            "    @abc.abstractmethod",
            "    def set(self, device, check_exit_code=None, state=None, mtu=None,",
            "            address=None, promisc=None, master=None):",
            "        \"\"\"Method to set a parameter in an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   check_exit_code: List of integers of allowed execution exit",
            "                                  codes",
            "        :param   state: String network device state",
            "        :param   mtu: Integer MTU value",
            "        :param   address: String MAC address",
            "        :param   promisc: Boolean promiscuous mode",
            "        :param   master: String the master device that this device belongs to",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,",
            "            vlan_id=None, ageing=None):",
            "        \"\"\"Method to add an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   dev_type: String network device type (TYPE_VETH, TYPE_VLAN)",
            "        :param   check_exit_code: List of integers of allowed execution exit",
            "                                  codes",
            "        :param   peer: String peer name, for veth interfaces",
            "        :param   link: String root network interface name, 'device' will be a",
            "                       VLAN tagged virtual interface",
            "        :param   vlan_id: Integer VLAN ID for VLAN devices",
            "        :param   ageing: integer value in seconds before learned",
            "                         mac addresses are forgotten.",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def delete(self, device, check_exit_code=None):",
            "        \"\"\"Method to delete an interface.",
            "",
            "        :param   device: A network device (string)",
            "        :param   dev_type: String network device type (TYPE_VETH, TYPE_VLAN)",
            "        :return: status of the command execution",
            "        \"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def exists(self, device):",
            "        \"\"\"Method to dectect if a device exists.",
            "",
            "        :param   device: A network device (string)",
            "        :return: True if device exists else False",
            "        \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "42": [
                "IpCommand",
                "add"
            ]
        },
        "addLocation": []
    },
    "os_vif/internal/ip/linux/impl_pyroute2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             return self._ip_link(ip, 'set', check_exit_code, **args)"
            },
            "1": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,"
            },
            "3": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            vlan_id=None):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            vlan_id=None, ageing=None):"
            },
            "5": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         check_exit_code = check_exit_code or []"
            },
            "6": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         with iproute.IPRoute() as ip:"
            },
            "7": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             args = {'ifname': device,"
            },
            "8": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                 # in the bridge_data class located in the"
            },
            "9": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 # pyroute2.netlink.rtnl.ifinfmsg module for mode details"
            },
            "10": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                 # https://github.com/svinota/pyroute2/blob/3ba9cdde34b2346ef8c2f8ba17cef5dbeb4c6d52/pyroute2/netlink/rtnl/ifinfmsg/__init__.py#L776-L820"
            },
            "11": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                args['IFLA_BR_AGEING_TIME'] = 0  # disable mac learning ageing"
            },
            "12": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                 args['IFLA_BR_FORWARD_DELAY'] = 0  # set no delay"
            },
            "13": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                 args['IFLA_BR_STP_STATE'] = 0  # disable spanning tree"
            },
            "14": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                 args['IFLA_BR_MCAST_SNOOPING'] = 0  # disable snooping"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                # NOTE(sean-k-mooney): we conditionally enable mac ageing as"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                # this code is shared between the ovs and linux bridge"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                # plugins. For linux bridge we want to allow the default"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                # ageing of 300 seconds, whereas for ovs with the ip-tables"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                # firewall we want to disable ageing. None was chosen as"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                # the default value of ageing to allow the caller to determine"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                # what policy to use and keep this code generic."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                if ageing is not None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                    args['IFLA_BR_AGEING_TIME'] = ageing"
            },
            "24": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "             else:"
            },
            "25": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "                 raise exception.NetworkInterfaceTypeNotDefined(type=dev_type)"
            },
            "26": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from pyroute2 import iproute",
            "from pyroute2.netlink import exceptions as ipexc",
            "from pyroute2.netlink.rtnl import ifinfmsg",
            "",
            "from os_vif import exception",
            "from os_vif.internal.ip import ip_command",
            "from os_vif import utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class PyRoute2(ip_command.IpCommand):",
            "",
            "    def _ip_link(self, ip, command, check_exit_code, **kwargs):",
            "        try:",
            "            LOG.debug('pyroute2 command %(command)s, arguments %(args)s' %",
            "                      {'command': command, 'args': kwargs})",
            "            return ip.link(command, **kwargs)",
            "        except ipexc.NetlinkError as e:",
            "            with excutils.save_and_reraise_exception() as ctx:",
            "                if e.code in check_exit_code:",
            "                    LOG.error('NetlinkError was raised, code %s, message: %s' %",
            "                              (e.code, str(e)))",
            "                    ctx.reraise = False",
            "",
            "    def set(self, device, check_exit_code=None, state=None, mtu=None,",
            "            address=None, promisc=None, master=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            if not idx:",
            "                raise exception.NetworkInterfaceNotFound(interface=device)",
            "            idx = idx[0]",
            "",
            "            args = {'index': idx}",
            "            if state:",
            "                args['state'] = state",
            "            if mtu:",
            "                args['mtu'] = mtu",
            "            if address:",
            "                args['address'] = address",
            "            if promisc is not None:",
            "                flags = ip.link('get', index=idx)[0]['flags']",
            "                args['flags'] = (utils.set_mask(flags, ifinfmsg.IFF_PROMISC)",
            "                                 if promisc is True else",
            "                                 utils.unset_mask(flags, ifinfmsg.IFF_PROMISC))",
            "            if master:",
            "                args['master'] = ip.link_lookup(ifname=master)",
            "",
            "            if isinstance(check_exit_code, int):",
            "                check_exit_code = [check_exit_code]",
            "",
            "            return self._ip_link(ip, 'set', check_exit_code, **args)",
            "",
            "    def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,",
            "            vlan_id=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            args = {'ifname': device,",
            "                    'kind': dev_type}",
            "            if self.TYPE_VLAN == dev_type:",
            "                args['vlan_id'] = vlan_id",
            "                idx = ip.link_lookup(ifname=link)",
            "                if 0 == len(idx):",
            "                    raise exception.NetworkInterfaceNotFound(interface=link)",
            "                args['link'] = idx[0]",
            "            elif self.TYPE_VETH == dev_type:",
            "                args['peer'] = peer",
            "            elif self.TYPE_BRIDGE == dev_type:",
            "                # NOTE(sean-k-mooney): the keys are defined in the pyroute2",
            "                # codebase but are not documented. see the nla_map field",
            "                # in the bridge_data class located in the",
            "                # pyroute2.netlink.rtnl.ifinfmsg module for mode details",
            "                # https://github.com/svinota/pyroute2/blob/3ba9cdde34b2346ef8c2f8ba17cef5dbeb4c6d52/pyroute2/netlink/rtnl/ifinfmsg/__init__.py#L776-L820",
            "                args['IFLA_BR_AGEING_TIME'] = 0  # disable mac learning ageing",
            "                args['IFLA_BR_FORWARD_DELAY'] = 0  # set no delay",
            "                args['IFLA_BR_STP_STATE'] = 0  # disable spanning tree",
            "                args['IFLA_BR_MCAST_SNOOPING'] = 0  # disable snooping",
            "            else:",
            "                raise exception.NetworkInterfaceTypeNotDefined(type=dev_type)",
            "",
            "            return self._ip_link(ip, 'add', check_exit_code, **args)",
            "",
            "    def delete(self, device, check_exit_code=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            if len(idx) == 0:",
            "                raise exception.NetworkInterfaceNotFound(interface=device)",
            "            idx = idx[0]",
            "",
            "            return self._ip_link(ip, 'del', check_exit_code, **{'index': idx})",
            "",
            "    def exists(self, device):",
            "        \"\"\"Return True if the device exists.\"\"\"",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            return True if idx else False"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from pyroute2 import iproute",
            "from pyroute2.netlink import exceptions as ipexc",
            "from pyroute2.netlink.rtnl import ifinfmsg",
            "",
            "from os_vif import exception",
            "from os_vif.internal.ip import ip_command",
            "from os_vif import utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class PyRoute2(ip_command.IpCommand):",
            "",
            "    def _ip_link(self, ip, command, check_exit_code, **kwargs):",
            "        try:",
            "            LOG.debug('pyroute2 command %(command)s, arguments %(args)s' %",
            "                      {'command': command, 'args': kwargs})",
            "            return ip.link(command, **kwargs)",
            "        except ipexc.NetlinkError as e:",
            "            with excutils.save_and_reraise_exception() as ctx:",
            "                if e.code in check_exit_code:",
            "                    LOG.error('NetlinkError was raised, code %s, message: %s' %",
            "                              (e.code, str(e)))",
            "                    ctx.reraise = False",
            "",
            "    def set(self, device, check_exit_code=None, state=None, mtu=None,",
            "            address=None, promisc=None, master=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            if not idx:",
            "                raise exception.NetworkInterfaceNotFound(interface=device)",
            "            idx = idx[0]",
            "",
            "            args = {'index': idx}",
            "            if state:",
            "                args['state'] = state",
            "            if mtu:",
            "                args['mtu'] = mtu",
            "            if address:",
            "                args['address'] = address",
            "            if promisc is not None:",
            "                flags = ip.link('get', index=idx)[0]['flags']",
            "                args['flags'] = (utils.set_mask(flags, ifinfmsg.IFF_PROMISC)",
            "                                 if promisc is True else",
            "                                 utils.unset_mask(flags, ifinfmsg.IFF_PROMISC))",
            "            if master:",
            "                args['master'] = ip.link_lookup(ifname=master)",
            "",
            "            if isinstance(check_exit_code, int):",
            "                check_exit_code = [check_exit_code]",
            "",
            "            return self._ip_link(ip, 'set', check_exit_code, **args)",
            "",
            "    def add(self, device, dev_type, check_exit_code=None, peer=None, link=None,",
            "            vlan_id=None, ageing=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            args = {'ifname': device,",
            "                    'kind': dev_type}",
            "            if self.TYPE_VLAN == dev_type:",
            "                args['vlan_id'] = vlan_id",
            "                idx = ip.link_lookup(ifname=link)",
            "                if 0 == len(idx):",
            "                    raise exception.NetworkInterfaceNotFound(interface=link)",
            "                args['link'] = idx[0]",
            "            elif self.TYPE_VETH == dev_type:",
            "                args['peer'] = peer",
            "            elif self.TYPE_BRIDGE == dev_type:",
            "                # NOTE(sean-k-mooney): the keys are defined in the pyroute2",
            "                # codebase but are not documented. see the nla_map field",
            "                # in the bridge_data class located in the",
            "                # pyroute2.netlink.rtnl.ifinfmsg module for mode details",
            "                # https://github.com/svinota/pyroute2/blob/3ba9cdde34b2346ef8c2f8ba17cef5dbeb4c6d52/pyroute2/netlink/rtnl/ifinfmsg/__init__.py#L776-L820",
            "                args['IFLA_BR_FORWARD_DELAY'] = 0  # set no delay",
            "                args['IFLA_BR_STP_STATE'] = 0  # disable spanning tree",
            "                args['IFLA_BR_MCAST_SNOOPING'] = 0  # disable snooping",
            "                # NOTE(sean-k-mooney): we conditionally enable mac ageing as",
            "                # this code is shared between the ovs and linux bridge",
            "                # plugins. For linux bridge we want to allow the default",
            "                # ageing of 300 seconds, whereas for ovs with the ip-tables",
            "                # firewall we want to disable ageing. None was chosen as",
            "                # the default value of ageing to allow the caller to determine",
            "                # what policy to use and keep this code generic.",
            "                if ageing is not None:",
            "                    args['IFLA_BR_AGEING_TIME'] = ageing",
            "            else:",
            "                raise exception.NetworkInterfaceTypeNotDefined(type=dev_type)",
            "",
            "            return self._ip_link(ip, 'add', check_exit_code, **args)",
            "",
            "    def delete(self, device, check_exit_code=None):",
            "        check_exit_code = check_exit_code or []",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            if len(idx) == 0:",
            "                raise exception.NetworkInterfaceNotFound(interface=device)",
            "            idx = idx[0]",
            "",
            "            return self._ip_link(ip, 'del', check_exit_code, **{'index': idx})",
            "",
            "    def exists(self, device):",
            "        \"\"\"Return True if the device exists.\"\"\"",
            "        with iproute.IPRoute() as ip:",
            "            idx = ip.link_lookup(ifname=device)",
            "            return True if idx else False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "70": [
                "PyRoute2",
                "add"
            ],
            "89": [
                "PyRoute2",
                "add"
            ]
        },
        "addLocation": []
    },
    "os_vif/tests/functional/internal/command/ip/test_impl_pyroute2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         _ip_cmd_add(device, 'bridge')"
            },
            "1": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         self.assertTrue(self.exist_device(device))"
            },
            "2": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         base_path = \"/sys/class/net/test_dev_11/bridge/%s\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        with open(base_path % \"forward_delay\", \"r\") as f:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            self.assertEqual(\"0\", f.readline().rstrip('\\n'))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        with open(base_path % \"stp_state\", \"r\") as f:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            self.assertEqual(\"0\", f.readline().rstrip('\\n'))"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        with open(base_path % \"multicast_snooping\", \"r\") as f:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            self.assertEqual(\"0\", f.readline().rstrip('\\n'))"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        with open(base_path % \"ageing_time\", \"r\") as f:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            value = int(f.readline().rstrip('\\n'))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            # NOTE(sean-k-mooney): IEEE 8021-Q recommends that the default"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            # ageing should be 300 and the linux kernel defaults to 300"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            # via an unconditional define. As such we expect this to be"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            # 300 however since services like network-manager could change"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            # the default on bridge creation we check that if it is not 300"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            # then the value should not be 0."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+            self.assertTrue(300 == value or value != 0)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    def test_add_bridge_with_mac_ageing_0(self):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        device = \"test_dev_12\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        self.addCleanup(self.del_device, device)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        _ip_cmd_add(device, 'bridge', ageing=0)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        self.assertTrue(self.exist_device(device))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        base_path = \"/sys/class/net/test_dev_12/bridge/%s\""
            },
            "25": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         with open(base_path % \"forward_delay\", \"r\") as f:"
            },
            "26": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "             self.assertEqual(\"0\", f.readline().rstrip('\\n'))"
            },
            "27": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         with open(base_path % \"stp_state\", \"r\") as f:"
            },
            "28": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             self.assertEqual(\"0\", f.readline().rstrip('\\n'))"
            },
            "29": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "     def test_add_port_to_bridge(self):"
            },
            "31": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        device = \"test_dev_12\""
            },
            "32": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        bridge = \"test_dev_13\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        device = \"test_dev_13\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        bridge = \"test_dev_14\""
            },
            "35": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         self.addCleanup(self.del_device, device)"
            },
            "36": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         self.addCleanup(self.del_device, bridge)"
            },
            "37": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         self.add_device(device, 'dummy')"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import os",
            "import re",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_utils import excutils",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from os_vif.tests.functional import base",
            "from os_vif.tests.functional import privsep",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _execute_command(*args):",
            "    return processutils.execute(*args)",
            "",
            "",
            "class ShellIpCommands(object):",
            "",
            "    def add_device(self, device, dev_type, peer=None, link=None,",
            "                   vlan_id=None):",
            "        if 'vlan' == dev_type:",
            "            _execute_command('ip', 'link', 'add', 'link', link,",
            "                             'name', device, 'type', dev_type, 'vlan', 'id',",
            "                             vlan_id)",
            "        elif 'veth' == dev_type:",
            "            _execute_command('ip', 'link', 'add', device, 'type', dev_type,",
            "                             'peer', 'name', peer)",
            "        elif 'dummy' == dev_type:",
            "            _execute_command('ip', 'link', 'add', device, 'type', dev_type)",
            "",
            "    def del_device(self, device):",
            "        if self.exist_device(device):",
            "            _execute_command('ip', 'link', 'del', device)",
            "",
            "    def set_status_up(self, device):",
            "        _execute_command('ip', 'link', 'set', device, 'up')",
            "",
            "    def set_status_down(self, device):",
            "        _execute_command('ip', 'link', 'set', device, 'down')",
            "",
            "    def set_device_mtu(self, device, mtu):",
            "        _execute_command('ip', 'link', 'set', device, 'mtu', mtu)",
            "",
            "    def show_device(self, device):",
            "        val, err = _execute_command('ip', 'link', 'show', device)",
            "        return val.splitlines()",
            "",
            "    def exist_device(self, device):",
            "        try:",
            "            _execute_command('ip', 'link', 'show', device)",
            "            return True",
            "        except processutils.ProcessExecutionError as e:",
            "            with excutils.save_and_reraise_exception() as saved_exception:",
            "                if e.exit_code == 1:",
            "                    saved_exception.reraise = False",
            "                    return False",
            "",
            "    def show_state(self, device):",
            "        regex = re.compile(r\".*state (?P<state>\\w+)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        if match is None:",
            "            return",
            "        return match.group('state')",
            "",
            "    def show_promisc(self, device):",
            "        regex = re.compile(r\".*(PROMISC)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        return True if match else False",
            "",
            "    def show_mac(self, device):",
            "        exp = r\".*link/ether (?P<mac>([0-9A-Fa-f]{2}[:]){5}[0-9A-Fa-f]{2})\"",
            "        regex = re.compile(exp)",
            "        match = regex.match(self.show_device(device)[1])",
            "        if match is None:",
            "            return",
            "        return match.group('mac')",
            "",
            "    def show_mtu(self, device):",
            "        regex = re.compile(r\".*mtu (?P<mtu>\\d+)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        if match is None:",
            "            return",
            "        return int(match.group('mtu'))",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_set(*args, **kwargs):",
            "    ip_lib.set(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_add(*args, **kwargs):",
            "    ip_lib.add(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_delete(*args, **kwargs):",
            "    ip_lib.delete(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_exists(*args, **kwargs):",
            "    return ip_lib.exists(*args, **kwargs)",
            "",
            "",
            "class TestIpCommand(ShellIpCommands, base.BaseFunctionalTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestIpCommand, self).setUp()",
            "",
            "    def test_set_state(self):",
            "        device1 = \"test_dev_1\"",
            "        device2 = \"test_dev_2\"",
            "        self.addCleanup(self.del_device, device1)",
            "        self.add_device(device1, 'veth', peer=device2)",
            "        _ip_cmd_set(device1, state='up')",
            "        _ip_cmd_set(device2, state='up')",
            "        self.assertEqual('UP', self.show_state(device1))",
            "        self.assertEqual('UP', self.show_state(device2))",
            "        _ip_cmd_set(device1, state='down')",
            "        _ip_cmd_set(device2, state='down')",
            "        self.assertEqual('DOWN', self.show_state(device1))",
            "        self.assertEqual('DOWN', self.show_state(device2))",
            "",
            "    def test_set_mtu(self):",
            "        device = \"test_dev_3\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, mtu=1200)",
            "        self.assertEqual(1200, self.show_mtu(device))",
            "        _ip_cmd_set(device, mtu=900)",
            "        self.assertEqual(900, self.show_mtu(device))",
            "",
            "    def test_set_address(self):",
            "        device = \"test_dev_4\"",
            "        address1 = \"36:a7:e4:f9:01:01\"",
            "        address2 = \"36:a7:e4:f9:01:01\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, address=address1)",
            "        self.assertEqual(address1, self.show_mac(device))",
            "        _ip_cmd_set(device, address=address2)",
            "        self.assertEqual(address2, self.show_mac(device))",
            "",
            "    def test_set_promisc(self):",
            "        device = \"test_dev_5\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, promisc=True)",
            "        self.assertTrue(self.show_promisc(device))",
            "        _ip_cmd_set(device, promisc=False)",
            "        self.assertFalse(self.show_promisc(device))",
            "",
            "    def test_add_vlan(self):",
            "        device = \"test_dev_6\"",
            "        link = \"test_devlink\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, link)",
            "        self.add_device(link, 'dummy')",
            "        _ip_cmd_add(device, 'vlan', link=link, vlan_id=100)",
            "        self.assertTrue(self.exist_device(device))",
            "",
            "    def test_add_veth(self):",
            "        device = \"test_dev_7\"",
            "        peer = \"test_devpeer\"",
            "        self.addCleanup(self.del_device, device)",
            "        _ip_cmd_add(device, 'veth', peer=peer)",
            "        self.assertTrue(self.exist_device(device))",
            "        self.assertTrue(self.exist_device(peer))",
            "",
            "    def test_delete(self):",
            "        device = \"test_dev_8\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        self.assertTrue(self.exist_device(device))",
            "        _ip_cmd_delete(device)",
            "        self.assertFalse(self.exist_device(device))",
            "",
            "    def test_iproute_object_closes_correctly(self):",
            "        # NOTE(ralonsoh): check https://bugs.launchpad.net/os-vif/+bug/1807949",
            "        device = \"test_dev_9\"",
            "        link = \"test_devlink_2\"",
            "        self.add_device(link, 'dummy')",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, link)",
            "        for _ in range(300):",
            "            _ip_cmd_add(device, 'vlan', link=link, vlan_id=100)",
            "            _ip_cmd_delete(device)",
            "",
            "    def test_exists(self):",
            "        device = \"test_dev_10\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        self.assertTrue(_ip_cmd_exists(device))",
            "        self.del_device(device)",
            "        self.assertFalse(_ip_cmd_exists(device))",
            "",
            "    def test_add_bridge(self):",
            "        device = \"test_dev_11\"",
            "        self.addCleanup(self.del_device, device)",
            "        _ip_cmd_add(device, 'bridge')",
            "        self.assertTrue(self.exist_device(device))",
            "        base_path = \"/sys/class/net/test_dev_11/bridge/%s\"",
            "        with open(base_path % \"forward_delay\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"stp_state\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"ageing_time\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"multicast_snooping\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "",
            "    def test_add_port_to_bridge(self):",
            "        device = \"test_dev_12\"",
            "        bridge = \"test_dev_13\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, bridge)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_add(bridge, 'bridge')",
            "        self.assertTrue(self.exist_device(device))",
            "        self.assertTrue(self.exist_device(bridge))",
            "        _ip_cmd_set(device, master=bridge)",
            "        path = \"/sys/class/net/{}/brif/{}\".format(bridge, device)",
            "        self.assertTrue(os.path.exists(path))"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import os",
            "import re",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_utils import excutils",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from os_vif.tests.functional import base",
            "from os_vif.tests.functional import privsep",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _execute_command(*args):",
            "    return processutils.execute(*args)",
            "",
            "",
            "class ShellIpCommands(object):",
            "",
            "    def add_device(self, device, dev_type, peer=None, link=None,",
            "                   vlan_id=None):",
            "        if 'vlan' == dev_type:",
            "            _execute_command('ip', 'link', 'add', 'link', link,",
            "                             'name', device, 'type', dev_type, 'vlan', 'id',",
            "                             vlan_id)",
            "        elif 'veth' == dev_type:",
            "            _execute_command('ip', 'link', 'add', device, 'type', dev_type,",
            "                             'peer', 'name', peer)",
            "        elif 'dummy' == dev_type:",
            "            _execute_command('ip', 'link', 'add', device, 'type', dev_type)",
            "",
            "    def del_device(self, device):",
            "        if self.exist_device(device):",
            "            _execute_command('ip', 'link', 'del', device)",
            "",
            "    def set_status_up(self, device):",
            "        _execute_command('ip', 'link', 'set', device, 'up')",
            "",
            "    def set_status_down(self, device):",
            "        _execute_command('ip', 'link', 'set', device, 'down')",
            "",
            "    def set_device_mtu(self, device, mtu):",
            "        _execute_command('ip', 'link', 'set', device, 'mtu', mtu)",
            "",
            "    def show_device(self, device):",
            "        val, err = _execute_command('ip', 'link', 'show', device)",
            "        return val.splitlines()",
            "",
            "    def exist_device(self, device):",
            "        try:",
            "            _execute_command('ip', 'link', 'show', device)",
            "            return True",
            "        except processutils.ProcessExecutionError as e:",
            "            with excutils.save_and_reraise_exception() as saved_exception:",
            "                if e.exit_code == 1:",
            "                    saved_exception.reraise = False",
            "                    return False",
            "",
            "    def show_state(self, device):",
            "        regex = re.compile(r\".*state (?P<state>\\w+)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        if match is None:",
            "            return",
            "        return match.group('state')",
            "",
            "    def show_promisc(self, device):",
            "        regex = re.compile(r\".*(PROMISC)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        return True if match else False",
            "",
            "    def show_mac(self, device):",
            "        exp = r\".*link/ether (?P<mac>([0-9A-Fa-f]{2}[:]){5}[0-9A-Fa-f]{2})\"",
            "        regex = re.compile(exp)",
            "        match = regex.match(self.show_device(device)[1])",
            "        if match is None:",
            "            return",
            "        return match.group('mac')",
            "",
            "    def show_mtu(self, device):",
            "        regex = re.compile(r\".*mtu (?P<mtu>\\d+)\")",
            "        match = regex.match(self.show_device(device)[0])",
            "        if match is None:",
            "            return",
            "        return int(match.group('mtu'))",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_set(*args, **kwargs):",
            "    ip_lib.set(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_add(*args, **kwargs):",
            "    ip_lib.add(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_delete(*args, **kwargs):",
            "    ip_lib.delete(*args, **kwargs)",
            "",
            "",
            "@privsep.os_vif_pctxt.entrypoint",
            "def _ip_cmd_exists(*args, **kwargs):",
            "    return ip_lib.exists(*args, **kwargs)",
            "",
            "",
            "class TestIpCommand(ShellIpCommands, base.BaseFunctionalTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestIpCommand, self).setUp()",
            "",
            "    def test_set_state(self):",
            "        device1 = \"test_dev_1\"",
            "        device2 = \"test_dev_2\"",
            "        self.addCleanup(self.del_device, device1)",
            "        self.add_device(device1, 'veth', peer=device2)",
            "        _ip_cmd_set(device1, state='up')",
            "        _ip_cmd_set(device2, state='up')",
            "        self.assertEqual('UP', self.show_state(device1))",
            "        self.assertEqual('UP', self.show_state(device2))",
            "        _ip_cmd_set(device1, state='down')",
            "        _ip_cmd_set(device2, state='down')",
            "        self.assertEqual('DOWN', self.show_state(device1))",
            "        self.assertEqual('DOWN', self.show_state(device2))",
            "",
            "    def test_set_mtu(self):",
            "        device = \"test_dev_3\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, mtu=1200)",
            "        self.assertEqual(1200, self.show_mtu(device))",
            "        _ip_cmd_set(device, mtu=900)",
            "        self.assertEqual(900, self.show_mtu(device))",
            "",
            "    def test_set_address(self):",
            "        device = \"test_dev_4\"",
            "        address1 = \"36:a7:e4:f9:01:01\"",
            "        address2 = \"36:a7:e4:f9:01:01\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, address=address1)",
            "        self.assertEqual(address1, self.show_mac(device))",
            "        _ip_cmd_set(device, address=address2)",
            "        self.assertEqual(address2, self.show_mac(device))",
            "",
            "    def test_set_promisc(self):",
            "        device = \"test_dev_5\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_set(device, promisc=True)",
            "        self.assertTrue(self.show_promisc(device))",
            "        _ip_cmd_set(device, promisc=False)",
            "        self.assertFalse(self.show_promisc(device))",
            "",
            "    def test_add_vlan(self):",
            "        device = \"test_dev_6\"",
            "        link = \"test_devlink\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, link)",
            "        self.add_device(link, 'dummy')",
            "        _ip_cmd_add(device, 'vlan', link=link, vlan_id=100)",
            "        self.assertTrue(self.exist_device(device))",
            "",
            "    def test_add_veth(self):",
            "        device = \"test_dev_7\"",
            "        peer = \"test_devpeer\"",
            "        self.addCleanup(self.del_device, device)",
            "        _ip_cmd_add(device, 'veth', peer=peer)",
            "        self.assertTrue(self.exist_device(device))",
            "        self.assertTrue(self.exist_device(peer))",
            "",
            "    def test_delete(self):",
            "        device = \"test_dev_8\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        self.assertTrue(self.exist_device(device))",
            "        _ip_cmd_delete(device)",
            "        self.assertFalse(self.exist_device(device))",
            "",
            "    def test_iproute_object_closes_correctly(self):",
            "        # NOTE(ralonsoh): check https://bugs.launchpad.net/os-vif/+bug/1807949",
            "        device = \"test_dev_9\"",
            "        link = \"test_devlink_2\"",
            "        self.add_device(link, 'dummy')",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, link)",
            "        for _ in range(300):",
            "            _ip_cmd_add(device, 'vlan', link=link, vlan_id=100)",
            "            _ip_cmd_delete(device)",
            "",
            "    def test_exists(self):",
            "        device = \"test_dev_10\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.add_device(device, 'dummy')",
            "        self.assertTrue(_ip_cmd_exists(device))",
            "        self.del_device(device)",
            "        self.assertFalse(_ip_cmd_exists(device))",
            "",
            "    def test_add_bridge(self):",
            "        device = \"test_dev_11\"",
            "        self.addCleanup(self.del_device, device)",
            "        _ip_cmd_add(device, 'bridge')",
            "        self.assertTrue(self.exist_device(device))",
            "        base_path = \"/sys/class/net/test_dev_11/bridge/%s\"",
            "        with open(base_path % \"forward_delay\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"stp_state\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"multicast_snooping\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"ageing_time\", \"r\") as f:",
            "            value = int(f.readline().rstrip('\\n'))",
            "            # NOTE(sean-k-mooney): IEEE 8021-Q recommends that the default",
            "            # ageing should be 300 and the linux kernel defaults to 300",
            "            # via an unconditional define. As such we expect this to be",
            "            # 300 however since services like network-manager could change",
            "            # the default on bridge creation we check that if it is not 300",
            "            # then the value should not be 0.",
            "            self.assertTrue(300 == value or value != 0)",
            "",
            "    def test_add_bridge_with_mac_ageing_0(self):",
            "        device = \"test_dev_12\"",
            "        self.addCleanup(self.del_device, device)",
            "        _ip_cmd_add(device, 'bridge', ageing=0)",
            "        self.assertTrue(self.exist_device(device))",
            "        base_path = \"/sys/class/net/test_dev_12/bridge/%s\"",
            "        with open(base_path % \"forward_delay\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"stp_state\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"ageing_time\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "        with open(base_path % \"multicast_snooping\", \"r\") as f:",
            "            self.assertEqual(\"0\", f.readline().rstrip('\\n'))",
            "",
            "    def test_add_port_to_bridge(self):",
            "        device = \"test_dev_13\"",
            "        bridge = \"test_dev_14\"",
            "        self.addCleanup(self.del_device, device)",
            "        self.addCleanup(self.del_device, bridge)",
            "        self.add_device(device, 'dummy')",
            "        _ip_cmd_add(bridge, 'bridge')",
            "        self.assertTrue(self.exist_device(device))",
            "        self.assertTrue(self.exist_device(bridge))",
            "        _ip_cmd_set(device, master=bridge)",
            "        path = \"/sys/class/net/{}/brif/{}\".format(bridge, device)",
            "        self.assertTrue(os.path.exists(path))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "226": [
                "TestIpCommand",
                "test_add_port_to_bridge"
            ],
            "227": [
                "TestIpCommand",
                "test_add_port_to_bridge"
            ]
        },
        "addLocation": [
            "os_vif.tests.functional.internal.command.ip.test_impl_pyroute2.ShellIpCommands.self",
            "os_vif.tests.functional.internal.command.ip.test_impl_pyroute2.TestIpCommand.self"
        ]
    },
    "os_vif/tests/unit/internal/ip/linux/test_impl_pyroute2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "     def test_add_bridge(self):"
            },
            "2": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         self.ip.add(self.DEVICE, self.TYPE_BRIDGE)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        args = {'ifname': self.DEVICE,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                'kind': self.TYPE_BRIDGE,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                'IFLA_BR_FORWARD_DELAY': 0,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+                'IFLA_BR_STP_STATE': 0,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+                'IFLA_BR_MCAST_SNOOPING': 0}"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        self.ip_link.assert_called_once_with('add', **args)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    def test_add_bridge_with_ageing(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        self.ip.add(self.DEVICE, self.TYPE_BRIDGE, ageing=0)"
            },
            "12": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         args = {'ifname': self.DEVICE,"
            },
            "13": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                 'kind': self.TYPE_BRIDGE,"
            },
            "14": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                 'IFLA_BR_AGEING_TIME': 0,"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import mock",
            "from pyroute2 import iproute",
            "from pyroute2.netlink import exceptions as ipexc",
            "from pyroute2.netlink.rtnl import ifinfmsg",
            "",
            "from os_vif import exception",
            "from os_vif.internal.ip.linux import impl_pyroute2",
            "from os_vif.tests.unit import base",
            "",
            "",
            "class TestIpCommand(base.TestCase):",
            "",
            "    ERROR_CODE = 40",
            "    OTHER_ERROR_CODE = 50",
            "    DEVICE = 'device'",
            "    MTU = 1500",
            "    MAC = 'ca:fe:ca:fe:ca:fe'",
            "    UP = 'up'",
            "    TYPE_VETH = 'veth'",
            "    TYPE_VLAN = 'vlan'",
            "    TYPE_BRIDGE = 'bridge'",
            "    LINK = 'device2'",
            "    VLAN_ID = 14",
            "",
            "    def setUp(self):",
            "        super(TestIpCommand, self).setUp()",
            "        self.ip = impl_pyroute2.PyRoute2()",
            "        self.ip_link_p = mock.patch.object(iproute.IPRoute, 'link')",
            "        self.ip_link = self.ip_link_p.start()",
            "",
            "    def test_set(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.return_value = [{'flags': 0x4000}]",
            "            self.ip.set(self.DEVICE, state=self.UP, mtu=self.MTU,",
            "                        address=self.MAC, promisc=True)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            args = {'state': self.UP,",
            "                    'mtu': self.MTU,",
            "                    'address': self.MAC,",
            "                    'flags': 0x4000 | ifinfmsg.IFF_PROMISC}",
            "            calls = [mock.call('get', index=1),",
            "                     mock.call('set', index=1, **args)]",
            "            self.ip_link.assert_has_calls(calls)",
            "",
            "    def test_set_exit_code(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                          msg=\"Error message\")",
            "",
            "            self.ip.set(self.DEVICE, check_exit_code=[self.ERROR_CODE])",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('set', index=1)",
            "",
            "            self.assertRaises(ipexc.NetlinkError, self.ip.set, self.DEVICE,",
            "                              check_exit_code=[self.OTHER_ERROR_CODE])",
            "",
            "    def test_set_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound, self.ip.set,",
            "                              self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_not_called()",
            "",
            "    def test_add_veth(self):",
            "        self.ip.add(self.DEVICE, self.TYPE_VETH, peer='peer')",
            "        self.ip_link.assert_called_once_with(",
            "            'add', ifname=self.DEVICE, kind=self.TYPE_VETH, peer='peer')",
            "",
            "    def test_add_vlan(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip.add(self.DEVICE, self.TYPE_VLAN, link=self.LINK,",
            "                        vlan_id=self.VLAN_ID)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.LINK)",
            "            args = {'ifname': self.DEVICE,",
            "                    'kind': self.TYPE_VLAN,",
            "                    'vlan_id': self.VLAN_ID,",
            "                    'link': 1}",
            "            self.ip_link.assert_called_once_with('add', **args)",
            "",
            "    def test_add_bridge(self):",
            "        self.ip.add(self.DEVICE, self.TYPE_BRIDGE)",
            "        args = {'ifname': self.DEVICE,",
            "                'kind': self.TYPE_BRIDGE,",
            "                'IFLA_BR_AGEING_TIME': 0,",
            "                'IFLA_BR_FORWARD_DELAY': 0,",
            "                'IFLA_BR_STP_STATE': 0,",
            "                'IFLA_BR_MCAST_SNOOPING': 0}",
            "        self.ip_link.assert_called_once_with('add', **args)",
            "",
            "    def test_add_vlan_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound, self.ip.add,",
            "                              self.DEVICE, self.TYPE_VLAN, link=self.LINK)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.LINK)",
            "            self.ip_link.assert_not_called()",
            "",
            "    def test_add_other_type(self):",
            "        self.assertRaises(exception.NetworkInterfaceTypeNotDefined,",
            "                          self.ip.add, self.DEVICE, 'type_not_defined')",
            "",
            "    def test_add_exit_code(self):",
            "        self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                      msg=\"Error message\")",
            "",
            "        self.ip.add(self.DEVICE, self.TYPE_VETH, peer='peer',",
            "                    check_exit_code=[self.ERROR_CODE])",
            "        self.ip_link.assert_called_once_with(",
            "            'add', ifname=self.DEVICE, kind=self.TYPE_VETH, peer='peer')",
            "",
            "        self.assertRaises(ipexc.NetlinkError, self.ip.add, self.DEVICE,",
            "                          self.TYPE_VLAN, peer='peer',",
            "                          check_exit_code=[self.OTHER_ERROR_CODE])",
            "",
            "    def test_delete(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip.delete(self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('del', index=1)",
            "",
            "    def test_delete_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound,",
            "                              self.ip.delete, self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "",
            "    def test_delete_exit_code(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                          msg=\"Error message\")",
            "",
            "            self.ip.delete(self.DEVICE, check_exit_code=[self.ERROR_CODE])",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('del', index=1)",
            "",
            "            self.assertRaises(ipexc.NetlinkError, self.ip.delete, self.DEVICE,",
            "                              check_exit_code=[self.OTHER_ERROR_CODE])"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import mock",
            "from pyroute2 import iproute",
            "from pyroute2.netlink import exceptions as ipexc",
            "from pyroute2.netlink.rtnl import ifinfmsg",
            "",
            "from os_vif import exception",
            "from os_vif.internal.ip.linux import impl_pyroute2",
            "from os_vif.tests.unit import base",
            "",
            "",
            "class TestIpCommand(base.TestCase):",
            "",
            "    ERROR_CODE = 40",
            "    OTHER_ERROR_CODE = 50",
            "    DEVICE = 'device'",
            "    MTU = 1500",
            "    MAC = 'ca:fe:ca:fe:ca:fe'",
            "    UP = 'up'",
            "    TYPE_VETH = 'veth'",
            "    TYPE_VLAN = 'vlan'",
            "    TYPE_BRIDGE = 'bridge'",
            "    LINK = 'device2'",
            "    VLAN_ID = 14",
            "",
            "    def setUp(self):",
            "        super(TestIpCommand, self).setUp()",
            "        self.ip = impl_pyroute2.PyRoute2()",
            "        self.ip_link_p = mock.patch.object(iproute.IPRoute, 'link')",
            "        self.ip_link = self.ip_link_p.start()",
            "",
            "    def test_set(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.return_value = [{'flags': 0x4000}]",
            "            self.ip.set(self.DEVICE, state=self.UP, mtu=self.MTU,",
            "                        address=self.MAC, promisc=True)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            args = {'state': self.UP,",
            "                    'mtu': self.MTU,",
            "                    'address': self.MAC,",
            "                    'flags': 0x4000 | ifinfmsg.IFF_PROMISC}",
            "            calls = [mock.call('get', index=1),",
            "                     mock.call('set', index=1, **args)]",
            "            self.ip_link.assert_has_calls(calls)",
            "",
            "    def test_set_exit_code(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                          msg=\"Error message\")",
            "",
            "            self.ip.set(self.DEVICE, check_exit_code=[self.ERROR_CODE])",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('set', index=1)",
            "",
            "            self.assertRaises(ipexc.NetlinkError, self.ip.set, self.DEVICE,",
            "                              check_exit_code=[self.OTHER_ERROR_CODE])",
            "",
            "    def test_set_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound, self.ip.set,",
            "                              self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_not_called()",
            "",
            "    def test_add_veth(self):",
            "        self.ip.add(self.DEVICE, self.TYPE_VETH, peer='peer')",
            "        self.ip_link.assert_called_once_with(",
            "            'add', ifname=self.DEVICE, kind=self.TYPE_VETH, peer='peer')",
            "",
            "    def test_add_vlan(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip.add(self.DEVICE, self.TYPE_VLAN, link=self.LINK,",
            "                        vlan_id=self.VLAN_ID)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.LINK)",
            "            args = {'ifname': self.DEVICE,",
            "                    'kind': self.TYPE_VLAN,",
            "                    'vlan_id': self.VLAN_ID,",
            "                    'link': 1}",
            "            self.ip_link.assert_called_once_with('add', **args)",
            "",
            "    def test_add_bridge(self):",
            "        self.ip.add(self.DEVICE, self.TYPE_BRIDGE)",
            "        args = {'ifname': self.DEVICE,",
            "                'kind': self.TYPE_BRIDGE,",
            "                'IFLA_BR_FORWARD_DELAY': 0,",
            "                'IFLA_BR_STP_STATE': 0,",
            "                'IFLA_BR_MCAST_SNOOPING': 0}",
            "        self.ip_link.assert_called_once_with('add', **args)",
            "",
            "    def test_add_bridge_with_ageing(self):",
            "        self.ip.add(self.DEVICE, self.TYPE_BRIDGE, ageing=0)",
            "        args = {'ifname': self.DEVICE,",
            "                'kind': self.TYPE_BRIDGE,",
            "                'IFLA_BR_AGEING_TIME': 0,",
            "                'IFLA_BR_FORWARD_DELAY': 0,",
            "                'IFLA_BR_STP_STATE': 0,",
            "                'IFLA_BR_MCAST_SNOOPING': 0}",
            "        self.ip_link.assert_called_once_with('add', **args)",
            "",
            "    def test_add_vlan_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound, self.ip.add,",
            "                              self.DEVICE, self.TYPE_VLAN, link=self.LINK)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.LINK)",
            "            self.ip_link.assert_not_called()",
            "",
            "    def test_add_other_type(self):",
            "        self.assertRaises(exception.NetworkInterfaceTypeNotDefined,",
            "                          self.ip.add, self.DEVICE, 'type_not_defined')",
            "",
            "    def test_add_exit_code(self):",
            "        self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                      msg=\"Error message\")",
            "",
            "        self.ip.add(self.DEVICE, self.TYPE_VETH, peer='peer',",
            "                    check_exit_code=[self.ERROR_CODE])",
            "        self.ip_link.assert_called_once_with(",
            "            'add', ifname=self.DEVICE, kind=self.TYPE_VETH, peer='peer')",
            "",
            "        self.assertRaises(ipexc.NetlinkError, self.ip.add, self.DEVICE,",
            "                          self.TYPE_VLAN, peer='peer',",
            "                          check_exit_code=[self.OTHER_ERROR_CODE])",
            "",
            "    def test_delete(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip.delete(self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('del', index=1)",
            "",
            "    def test_delete_no_interface_found(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[]) as mock_link_lookup:",
            "            self.assertRaises(exception.NetworkInterfaceNotFound,",
            "                              self.ip.delete, self.DEVICE)",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "",
            "    def test_delete_exit_code(self):",
            "        with mock.patch.object(iproute.IPRoute, 'link_lookup',",
            "                               return_value=[1]) as mock_link_lookup:",
            "            self.ip_link.side_effect = ipexc.NetlinkError(self.ERROR_CODE,",
            "                                                          msg=\"Error message\")",
            "",
            "            self.ip.delete(self.DEVICE, check_exit_code=[self.ERROR_CODE])",
            "            mock_link_lookup.assert_called_once_with(ifname=self.DEVICE)",
            "            self.ip_link.assert_called_once_with('del', index=1)",
            "",
            "            self.assertRaises(ipexc.NetlinkError, self.ip.delete, self.DEVICE,",
            "                              check_exit_code=[self.OTHER_ERROR_CODE])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "os_vif.tests.unit.internal.ip.linux.test_impl_pyroute2.TestIpCommand.self",
            "os_vif.tests.unit.internal.ip.linux.test_impl_pyroute2.TestIpCommand.test_add_bridge.args"
        ]
    },
    "vif_plug_ovs/linux_net.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " @privsep.vif_plug.entrypoint"
            },
            "1": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " def ensure_bridge(bridge):"
            },
            "2": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     if not ip_lib.exists(bridge):"
            },
            "3": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ip_lib.add(bridge, 'bridge')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        # NOTE(sean-k-mooney): we set mac ageing to 0 to disable mac ageing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        # on the hybrid plug bridge to avoid packet loss during live"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        # migration. This avoids bug #1715317 and related bug #1414559"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        ip_lib.add(bridge, 'bridge', ageing=0)"
            },
            "8": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     _disable_ipv6(bridge)"
            },
            "9": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "     _arp_filtering(bridge)"
            },
            "10": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     # we bring up the bridge to allow it to switch packets"
            }
        },
        "frontPatchFile": [
            "# Derived from nova/network/linux_net.py",
            "#",
            "# Copyright (c) 2011 X.commerce, a business unit of eBay Inc.",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Implements vlans, bridges using linux utilities.\"\"\"",
            "",
            "import glob",
            "import os",
            "import re",
            "import sys",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "",
            "from vif_plug_ovs import constants",
            "from vif_plug_ovs import exception",
            "from vif_plug_ovs import privsep",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VIRTFN_RE = re.compile(r\"virtfn(\\d+)\")",
            "",
            "# phys_port_name only contains the VF number",
            "INT_RE = re.compile(r\"^(\\d+)$\")",
            "# phys_port_name contains VF## or vf##",
            "VF_RE = re.compile(r\"vf(\\d+)\", re.IGNORECASE)",
            "# phys_port_name contains PF## or pf##",
            "PF_RE = re.compile(r\"pf(\\d+)\", re.IGNORECASE)",
            "# bus_info (bdf) contains <bus>:<dev>.<func>",
            "PF_FUNC_RE = re.compile(r\"\\.(\\d+)\", 0)",
            "",
            "_SRIOV_TOTALVFS = \"sriov_totalvfs\"",
            "NIC_NAME_LEN = 14",
            "",
            "",
            "def _update_device_mtu(dev, mtu):",
            "    if not mtu:",
            "        return",
            "    if sys.platform != constants.PLATFORM_WIN32:",
            "        # Hyper-V with OVS does not support external programming of",
            "        # virtual interface MTUs via netsh or other Windows tools.",
            "        # When plugging an interface on Windows, we therefore skip",
            "        # programming the MTU and fallback to DHCP advertisement.",
            "        set_device_mtu(dev, mtu)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def delete_net_dev(dev):",
            "    \"\"\"Delete a network device only if it exists.\"\"\"",
            "    if ip_lib.exists(dev):",
            "        try:",
            "            ip_lib.delete(dev, check_exit_code=[0, 2, 254])",
            "            LOG.debug(\"Net device removed: '%s'\", dev)",
            "        except processutils.ProcessExecutionError:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(\"Failed removing net device: '%s'\", dev)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def create_veth_pair(dev1_name, dev2_name, mtu):",
            "    \"\"\"Create a pair of veth devices with the specified names,",
            "    deleting any previous devices with those names.",
            "    \"\"\"",
            "    for dev in [dev1_name, dev2_name]:",
            "        delete_net_dev(dev)",
            "",
            "    ip_lib.add(dev1_name, 'veth', peer=dev2_name)",
            "    for dev in [dev1_name, dev2_name]:",
            "        ip_lib.set(dev, state='up')",
            "        ip_lib.set(dev, promisc='on')",
            "        _update_device_mtu(dev, mtu)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def update_veth_pair(dev1_name, dev2_name, mtu):",
            "    \"\"\"Update a pair of veth devices with new configuration.\"\"\"",
            "    for dev in [dev1_name, dev2_name]:",
            "        _update_device_mtu(dev, mtu)",
            "",
            "",
            "def _disable_ipv6(bridge):",
            "    \"\"\"Disable ipv6 if available for bridge. Must be called from",
            "       privsep context.",
            "    \"\"\"",
            "    # NOTE(sean-k-mooney): os-vif disables ipv6 to ensure the Bridge",
            "    # does not aquire an ipv6 auto config or link local adress.",
            "    # This is required to prevent bug 1302080.",
            "    # https://bugs.launchpad.net/neutron/+bug/1302080",
            "    disv6 = ('/proc/sys/net/ipv6/conf/%s/disable_ipv6' %",
            "             bridge)",
            "    if os.path.exists(disv6):",
            "        with open(disv6, 'w') as f:",
            "            f.write('1')",
            "",
            "",
            "# TODO(ralonsoh): extract into common module",
            "def _arp_filtering(bridge):",
            "    \"\"\"Prevent the bridge from replying to ARP messages with machine local IPs",
            "",
            "    1. Reply only if the target IP address is local address configured on the",
            "       incoming interface.",
            "    2. Always use the best local address.",
            "    \"\"\"",
            "    arp_params = [('/proc/sys/net/ipv4/conf/%s/arp_ignore' % bridge, '1'),",
            "                  ('/proc/sys/net/ipv4/conf/%s/arp_announce' % bridge, '2')]",
            "    for parameter, value in arp_params:",
            "        if os.path.exists(parameter):",
            "            with open(parameter, 'w') as f:",
            "                f.write(value)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def ensure_bridge(bridge):",
            "    if not ip_lib.exists(bridge):",
            "        ip_lib.add(bridge, 'bridge')",
            "    _disable_ipv6(bridge)",
            "    _arp_filtering(bridge)",
            "    # we bring up the bridge to allow it to switch packets",
            "    set_interface_state(bridge, 'up')",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def delete_bridge(bridge, dev):",
            "    if ip_lib.exists(bridge):",
            "        # Note(sean-k-mooney): this will detach all ports on",
            "        # the bridge before deleting the bridge.",
            "        ip_lib.delete(bridge, check_exit_code=[0, 2, 254])",
            "        # howver it will not set the detached interface down",
            "        # so we set the dev down if dev is not None and exists.",
            "        if dev and ip_lib.exists(dev):",
            "            set_interface_state(dev, \"down\")",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def add_bridge_port(bridge, dev):",
            "    ip_lib.set(dev, master=bridge)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def set_device_mtu(dev, mtu):",
            "    \"\"\"Set the device MTU.\"\"\"",
            "    if ip_lib.exists(dev):",
            "        ip_lib.set(dev, mtu=mtu, check_exit_code=[0, 2, 254])",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def set_interface_state(interface_name, port_state):",
            "    ip_lib.set(interface_name, state=port_state, check_exit_code=[0, 2, 254])",
            "",
            "",
            "def _parse_vf_number(phys_port_name):",
            "    \"\"\"Parses phys_port_name and returns VF number or None.",
            "",
            "    To determine the VF number of a representor, parse phys_port_name",
            "    in the following sequence and return the first valid match. If none",
            "    match, then the representor is not for a VF.",
            "    \"\"\"",
            "    match = INT_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    match = VF_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "def _parse_pf_number(phys_port_name):",
            "    \"\"\"Parses phys_port_name and returns PF number or None.",
            "",
            "    To determine the PF number of a representor, parse phys_port_name in",
            "    the following sequence and return the first valid match. If none",
            "    match, then the representor is not for a PF.",
            "    \"\"\"",
            "    match = PF_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "# This function is taken from nova/pci/utils.py",
            "def get_function_by_ifname(ifname):",
            "    \"\"\"Given the device name, returns the PCI address of a device",
            "    and returns True if the address is in a physical function.",
            "    \"\"\"",
            "    dev_path = \"/sys/class/net/%s/device\" % ifname",
            "    sriov_totalvfs = 0",
            "    if os.path.isdir(dev_path):",
            "        try:",
            "            # sriov_totalvfs contains the maximum possible VFs for this PF",
            "            dev_path_file = os.path.join(dev_path, _SRIOV_TOTALVFS)",
            "            with open(dev_path_file, 'r') as fd:",
            "                sriov_totalvfs = int(fd.readline().rstrip())",
            "                return (os.readlink(dev_path).strip(\"./\"),",
            "                        sriov_totalvfs > 0)",
            "        except (IOError, ValueError):",
            "            return os.readlink(dev_path).strip(\"./\"), False",
            "    return None, False",
            "",
            "",
            "def _get_pf_func(pf_ifname):",
            "    \"\"\"Gets PF function number using pf_ifname and returns function",
            "    number or None.",
            "    \"\"\"",
            "",
            "    address_str, pf = get_function_by_ifname(pf_ifname)",
            "    if not address_str:",
            "        return None",
            "    match = PF_FUNC_RE.search(address_str)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "def get_representor_port(pf_ifname, vf_num):",
            "    \"\"\"Get the representor netdevice which is corresponding to the VF.",
            "",
            "    This method gets PF interface name and number of VF. It iterates over all",
            "    the interfaces under the PF location and looks for interface that has the",
            "    VF number in the phys_port_name. That interface is the representor for",
            "    the requested VF.",
            "    \"\"\"",
            "    pf_path = \"/sys/class/net/%s\" % pf_ifname",
            "    pf_sw_id_file = os.path.join(pf_path, \"phys_switch_id\")",
            "",
            "    pf_sw_id = None",
            "    try:",
            "        with open(pf_sw_id_file, 'r') as fd:",
            "            pf_sw_id = fd.readline().rstrip()",
            "    except (OSError, IOError):",
            "        raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "    pf_subsystem_file = os.path.join(pf_path, \"subsystem\")",
            "    try:",
            "        devices = os.listdir(pf_subsystem_file)",
            "    except (OSError, IOError):",
            "        raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "    for device in devices:",
            "        address_str, pf = get_function_by_ifname(device)",
            "        if pf:",
            "            continue",
            "",
            "        device_path = \"/sys/class/net/%s\" % device",
            "        device_sw_id_file = os.path.join(device_path, \"phys_switch_id\")",
            "        try:",
            "            with open(device_sw_id_file, 'r') as fd:",
            "                device_sw_id = fd.readline().rstrip()",
            "        except (OSError, IOError):",
            "            continue",
            "",
            "        if device_sw_id != pf_sw_id:",
            "            continue",
            "        device_port_name_file = (",
            "            os.path.join(device_path, 'phys_port_name'))",
            "",
            "        if not os.path.isfile(device_port_name_file):",
            "            continue",
            "",
            "        try:",
            "            with open(device_port_name_file, 'r') as fd:",
            "                phys_port_name = fd.readline().rstrip()",
            "        except (OSError, IOError):",
            "            continue",
            "",
            "        # If the phys_port_name of the VF-rep is of the format pfXvfY",
            "        # (or vfY@pfX), then match \"X\" (parent PF's func number) with",
            "        # the PCI func number of pf_ifname.",
            "        rep_parent_pf_func = _parse_pf_number(phys_port_name)",
            "        if rep_parent_pf_func is not None:",
            "                ifname_pf_func = _get_pf_func(pf_ifname)",
            "                if ifname_pf_func is None:",
            "                    continue",
            "                if int(rep_parent_pf_func) != int(ifname_pf_func):",
            "                    continue",
            "",
            "        representor_num = _parse_vf_number(phys_port_name)",
            "        # Note: representor_num can be 0, referring to VF0",
            "        if representor_num is None:",
            "            continue",
            "",
            "        # At this point we're confident we have a representor.",
            "        try:",
            "            if int(representor_num) == int(vf_num):",
            "                return device",
            "        except (ValueError):",
            "            continue",
            "",
            "    raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "",
            "def _get_sysfs_netdev_path(pci_addr, pf_interface):",
            "    \"\"\"Get the sysfs path based on the PCI address of the device.",
            "",
            "    Assumes a networking device - will not check for the existence of the path.",
            "    \"\"\"",
            "    if pf_interface:",
            "        return \"/sys/bus/pci/devices/%s/physfn/net\" % (pci_addr)",
            "    return \"/sys/bus/pci/devices/%s/net\" % (pci_addr)",
            "",
            "",
            "def _is_switchdev(netdev):",
            "    \"\"\"Returns True if a netdev has a readable phys_switch_id\"\"\"",
            "    try:",
            "        sw_id_file = \"/sys/class/net/%s/phys_switch_id\" % netdev",
            "        with open(sw_id_file, 'r') as fd:",
            "            phys_switch_id = fd.readline().rstrip()",
            "        if phys_switch_id != \"\" and phys_switch_id is not None:",
            "            return True",
            "    except (OSError, IOError):",
            "        return False",
            "    return False",
            "",
            "",
            "def get_ifname_by_pci_address(pci_addr, pf_interface=False, switchdev=False):",
            "    \"\"\"Get the interface name based on a VF's pci address",
            "",
            "    :param pci_addr: the PCI address of the VF",
            "    :param pf_interface: if True, look for the netdev of the parent PF",
            "    :param switchdev: if True, ensure that phys_switch_id is valid",
            "",
            "    :returns: netdev interface name",
            "",
            "    The returned interface name is either the parent PF or that of the VF",
            "    itself based on the argument of pf_interface.",
            "    \"\"\"",
            "    dev_path = _get_sysfs_netdev_path(pci_addr, pf_interface)",
            "    # make the if statement later more readable",
            "    ignore_switchdev = not switchdev",
            "    try:",
            "        for netdev in os.listdir(dev_path):",
            "            if ignore_switchdev or _is_switchdev(netdev):",
            "                return netdev",
            "    except Exception:",
            "        raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "    raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "",
            "",
            "def get_vf_num_by_pci_address(pci_addr):",
            "    \"\"\"Get the VF number based on a VF's pci address",
            "",
            "    A VF is associated with an VF number, which ip link command uses to",
            "    configure it. This number can be obtained from the PCI device filesystem.",
            "    \"\"\"",
            "    virtfns_path = \"/sys/bus/pci/devices/%s/physfn/virtfn*\" % (pci_addr)",
            "    vf_num = None",
            "    try:",
            "        for vf_path in glob.iglob(virtfns_path):",
            "            if re.search(pci_addr, os.readlink(vf_path)):",
            "                t = VIRTFN_RE.search(vf_path)",
            "                vf_num = t.group(1)",
            "                break",
            "    except Exception:",
            "        pass",
            "    if vf_num is None:",
            "        raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "    return vf_num",
            "",
            "",
            "def get_dpdk_representor_port_name(port_id):",
            "    devname = \"vfr\" + port_id",
            "    return devname[:NIC_NAME_LEN]",
            "",
            "",
            "def get_pf_pci_from_vf(vf_pci):",
            "    \"\"\"Get physical function PCI address of a VF",
            "",
            "    :param vf_pci: the PCI address of the VF",
            "    :return: the PCI address of the PF",
            "    \"\"\"",
            "    physfn_path = os.readlink(\"/sys/bus/pci/devices/%s/physfn\" % vf_pci)",
            "    return os.path.basename(physfn_path)"
        ],
        "afterPatchFile": [
            "# Derived from nova/network/linux_net.py",
            "#",
            "# Copyright (c) 2011 X.commerce, a business unit of eBay Inc.",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Implements vlans, bridges using linux utilities.\"\"\"",
            "",
            "import glob",
            "import os",
            "import re",
            "import sys",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "",
            "from vif_plug_ovs import constants",
            "from vif_plug_ovs import exception",
            "from vif_plug_ovs import privsep",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VIRTFN_RE = re.compile(r\"virtfn(\\d+)\")",
            "",
            "# phys_port_name only contains the VF number",
            "INT_RE = re.compile(r\"^(\\d+)$\")",
            "# phys_port_name contains VF## or vf##",
            "VF_RE = re.compile(r\"vf(\\d+)\", re.IGNORECASE)",
            "# phys_port_name contains PF## or pf##",
            "PF_RE = re.compile(r\"pf(\\d+)\", re.IGNORECASE)",
            "# bus_info (bdf) contains <bus>:<dev>.<func>",
            "PF_FUNC_RE = re.compile(r\"\\.(\\d+)\", 0)",
            "",
            "_SRIOV_TOTALVFS = \"sriov_totalvfs\"",
            "NIC_NAME_LEN = 14",
            "",
            "",
            "def _update_device_mtu(dev, mtu):",
            "    if not mtu:",
            "        return",
            "    if sys.platform != constants.PLATFORM_WIN32:",
            "        # Hyper-V with OVS does not support external programming of",
            "        # virtual interface MTUs via netsh or other Windows tools.",
            "        # When plugging an interface on Windows, we therefore skip",
            "        # programming the MTU and fallback to DHCP advertisement.",
            "        set_device_mtu(dev, mtu)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def delete_net_dev(dev):",
            "    \"\"\"Delete a network device only if it exists.\"\"\"",
            "    if ip_lib.exists(dev):",
            "        try:",
            "            ip_lib.delete(dev, check_exit_code=[0, 2, 254])",
            "            LOG.debug(\"Net device removed: '%s'\", dev)",
            "        except processutils.ProcessExecutionError:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(\"Failed removing net device: '%s'\", dev)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def create_veth_pair(dev1_name, dev2_name, mtu):",
            "    \"\"\"Create a pair of veth devices with the specified names,",
            "    deleting any previous devices with those names.",
            "    \"\"\"",
            "    for dev in [dev1_name, dev2_name]:",
            "        delete_net_dev(dev)",
            "",
            "    ip_lib.add(dev1_name, 'veth', peer=dev2_name)",
            "    for dev in [dev1_name, dev2_name]:",
            "        ip_lib.set(dev, state='up')",
            "        ip_lib.set(dev, promisc='on')",
            "        _update_device_mtu(dev, mtu)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def update_veth_pair(dev1_name, dev2_name, mtu):",
            "    \"\"\"Update a pair of veth devices with new configuration.\"\"\"",
            "    for dev in [dev1_name, dev2_name]:",
            "        _update_device_mtu(dev, mtu)",
            "",
            "",
            "def _disable_ipv6(bridge):",
            "    \"\"\"Disable ipv6 if available for bridge. Must be called from",
            "       privsep context.",
            "    \"\"\"",
            "    # NOTE(sean-k-mooney): os-vif disables ipv6 to ensure the Bridge",
            "    # does not aquire an ipv6 auto config or link local adress.",
            "    # This is required to prevent bug 1302080.",
            "    # https://bugs.launchpad.net/neutron/+bug/1302080",
            "    disv6 = ('/proc/sys/net/ipv6/conf/%s/disable_ipv6' %",
            "             bridge)",
            "    if os.path.exists(disv6):",
            "        with open(disv6, 'w') as f:",
            "            f.write('1')",
            "",
            "",
            "# TODO(ralonsoh): extract into common module",
            "def _arp_filtering(bridge):",
            "    \"\"\"Prevent the bridge from replying to ARP messages with machine local IPs",
            "",
            "    1. Reply only if the target IP address is local address configured on the",
            "       incoming interface.",
            "    2. Always use the best local address.",
            "    \"\"\"",
            "    arp_params = [('/proc/sys/net/ipv4/conf/%s/arp_ignore' % bridge, '1'),",
            "                  ('/proc/sys/net/ipv4/conf/%s/arp_announce' % bridge, '2')]",
            "    for parameter, value in arp_params:",
            "        if os.path.exists(parameter):",
            "            with open(parameter, 'w') as f:",
            "                f.write(value)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def ensure_bridge(bridge):",
            "    if not ip_lib.exists(bridge):",
            "        # NOTE(sean-k-mooney): we set mac ageing to 0 to disable mac ageing",
            "        # on the hybrid plug bridge to avoid packet loss during live",
            "        # migration. This avoids bug #1715317 and related bug #1414559",
            "        ip_lib.add(bridge, 'bridge', ageing=0)",
            "    _disable_ipv6(bridge)",
            "    _arp_filtering(bridge)",
            "    # we bring up the bridge to allow it to switch packets",
            "    set_interface_state(bridge, 'up')",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def delete_bridge(bridge, dev):",
            "    if ip_lib.exists(bridge):",
            "        # Note(sean-k-mooney): this will detach all ports on",
            "        # the bridge before deleting the bridge.",
            "        ip_lib.delete(bridge, check_exit_code=[0, 2, 254])",
            "        # howver it will not set the detached interface down",
            "        # so we set the dev down if dev is not None and exists.",
            "        if dev and ip_lib.exists(dev):",
            "            set_interface_state(dev, \"down\")",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def add_bridge_port(bridge, dev):",
            "    ip_lib.set(dev, master=bridge)",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def set_device_mtu(dev, mtu):",
            "    \"\"\"Set the device MTU.\"\"\"",
            "    if ip_lib.exists(dev):",
            "        ip_lib.set(dev, mtu=mtu, check_exit_code=[0, 2, 254])",
            "",
            "",
            "@privsep.vif_plug.entrypoint",
            "def set_interface_state(interface_name, port_state):",
            "    ip_lib.set(interface_name, state=port_state, check_exit_code=[0, 2, 254])",
            "",
            "",
            "def _parse_vf_number(phys_port_name):",
            "    \"\"\"Parses phys_port_name and returns VF number or None.",
            "",
            "    To determine the VF number of a representor, parse phys_port_name",
            "    in the following sequence and return the first valid match. If none",
            "    match, then the representor is not for a VF.",
            "    \"\"\"",
            "    match = INT_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    match = VF_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "def _parse_pf_number(phys_port_name):",
            "    \"\"\"Parses phys_port_name and returns PF number or None.",
            "",
            "    To determine the PF number of a representor, parse phys_port_name in",
            "    the following sequence and return the first valid match. If none",
            "    match, then the representor is not for a PF.",
            "    \"\"\"",
            "    match = PF_RE.search(phys_port_name)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "# This function is taken from nova/pci/utils.py",
            "def get_function_by_ifname(ifname):",
            "    \"\"\"Given the device name, returns the PCI address of a device",
            "    and returns True if the address is in a physical function.",
            "    \"\"\"",
            "    dev_path = \"/sys/class/net/%s/device\" % ifname",
            "    sriov_totalvfs = 0",
            "    if os.path.isdir(dev_path):",
            "        try:",
            "            # sriov_totalvfs contains the maximum possible VFs for this PF",
            "            dev_path_file = os.path.join(dev_path, _SRIOV_TOTALVFS)",
            "            with open(dev_path_file, 'r') as fd:",
            "                sriov_totalvfs = int(fd.readline().rstrip())",
            "                return (os.readlink(dev_path).strip(\"./\"),",
            "                        sriov_totalvfs > 0)",
            "        except (IOError, ValueError):",
            "            return os.readlink(dev_path).strip(\"./\"), False",
            "    return None, False",
            "",
            "",
            "def _get_pf_func(pf_ifname):",
            "    \"\"\"Gets PF function number using pf_ifname and returns function",
            "    number or None.",
            "    \"\"\"",
            "",
            "    address_str, pf = get_function_by_ifname(pf_ifname)",
            "    if not address_str:",
            "        return None",
            "    match = PF_FUNC_RE.search(address_str)",
            "    if match:",
            "        return match.group(1)",
            "    return None",
            "",
            "",
            "def get_representor_port(pf_ifname, vf_num):",
            "    \"\"\"Get the representor netdevice which is corresponding to the VF.",
            "",
            "    This method gets PF interface name and number of VF. It iterates over all",
            "    the interfaces under the PF location and looks for interface that has the",
            "    VF number in the phys_port_name. That interface is the representor for",
            "    the requested VF.",
            "    \"\"\"",
            "    pf_path = \"/sys/class/net/%s\" % pf_ifname",
            "    pf_sw_id_file = os.path.join(pf_path, \"phys_switch_id\")",
            "",
            "    pf_sw_id = None",
            "    try:",
            "        with open(pf_sw_id_file, 'r') as fd:",
            "            pf_sw_id = fd.readline().rstrip()",
            "    except (OSError, IOError):",
            "        raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "    pf_subsystem_file = os.path.join(pf_path, \"subsystem\")",
            "    try:",
            "        devices = os.listdir(pf_subsystem_file)",
            "    except (OSError, IOError):",
            "        raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "    for device in devices:",
            "        address_str, pf = get_function_by_ifname(device)",
            "        if pf:",
            "            continue",
            "",
            "        device_path = \"/sys/class/net/%s\" % device",
            "        device_sw_id_file = os.path.join(device_path, \"phys_switch_id\")",
            "        try:",
            "            with open(device_sw_id_file, 'r') as fd:",
            "                device_sw_id = fd.readline().rstrip()",
            "        except (OSError, IOError):",
            "            continue",
            "",
            "        if device_sw_id != pf_sw_id:",
            "            continue",
            "        device_port_name_file = (",
            "            os.path.join(device_path, 'phys_port_name'))",
            "",
            "        if not os.path.isfile(device_port_name_file):",
            "            continue",
            "",
            "        try:",
            "            with open(device_port_name_file, 'r') as fd:",
            "                phys_port_name = fd.readline().rstrip()",
            "        except (OSError, IOError):",
            "            continue",
            "",
            "        # If the phys_port_name of the VF-rep is of the format pfXvfY",
            "        # (or vfY@pfX), then match \"X\" (parent PF's func number) with",
            "        # the PCI func number of pf_ifname.",
            "        rep_parent_pf_func = _parse_pf_number(phys_port_name)",
            "        if rep_parent_pf_func is not None:",
            "                ifname_pf_func = _get_pf_func(pf_ifname)",
            "                if ifname_pf_func is None:",
            "                    continue",
            "                if int(rep_parent_pf_func) != int(ifname_pf_func):",
            "                    continue",
            "",
            "        representor_num = _parse_vf_number(phys_port_name)",
            "        # Note: representor_num can be 0, referring to VF0",
            "        if representor_num is None:",
            "            continue",
            "",
            "        # At this point we're confident we have a representor.",
            "        try:",
            "            if int(representor_num) == int(vf_num):",
            "                return device",
            "        except (ValueError):",
            "            continue",
            "",
            "    raise exception.RepresentorNotFound(ifname=pf_ifname, vf_num=vf_num)",
            "",
            "",
            "def _get_sysfs_netdev_path(pci_addr, pf_interface):",
            "    \"\"\"Get the sysfs path based on the PCI address of the device.",
            "",
            "    Assumes a networking device - will not check for the existence of the path.",
            "    \"\"\"",
            "    if pf_interface:",
            "        return \"/sys/bus/pci/devices/%s/physfn/net\" % (pci_addr)",
            "    return \"/sys/bus/pci/devices/%s/net\" % (pci_addr)",
            "",
            "",
            "def _is_switchdev(netdev):",
            "    \"\"\"Returns True if a netdev has a readable phys_switch_id\"\"\"",
            "    try:",
            "        sw_id_file = \"/sys/class/net/%s/phys_switch_id\" % netdev",
            "        with open(sw_id_file, 'r') as fd:",
            "            phys_switch_id = fd.readline().rstrip()",
            "        if phys_switch_id != \"\" and phys_switch_id is not None:",
            "            return True",
            "    except (OSError, IOError):",
            "        return False",
            "    return False",
            "",
            "",
            "def get_ifname_by_pci_address(pci_addr, pf_interface=False, switchdev=False):",
            "    \"\"\"Get the interface name based on a VF's pci address",
            "",
            "    :param pci_addr: the PCI address of the VF",
            "    :param pf_interface: if True, look for the netdev of the parent PF",
            "    :param switchdev: if True, ensure that phys_switch_id is valid",
            "",
            "    :returns: netdev interface name",
            "",
            "    The returned interface name is either the parent PF or that of the VF",
            "    itself based on the argument of pf_interface.",
            "    \"\"\"",
            "    dev_path = _get_sysfs_netdev_path(pci_addr, pf_interface)",
            "    # make the if statement later more readable",
            "    ignore_switchdev = not switchdev",
            "    try:",
            "        for netdev in os.listdir(dev_path):",
            "            if ignore_switchdev or _is_switchdev(netdev):",
            "                return netdev",
            "    except Exception:",
            "        raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "    raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "",
            "",
            "def get_vf_num_by_pci_address(pci_addr):",
            "    \"\"\"Get the VF number based on a VF's pci address",
            "",
            "    A VF is associated with an VF number, which ip link command uses to",
            "    configure it. This number can be obtained from the PCI device filesystem.",
            "    \"\"\"",
            "    virtfns_path = \"/sys/bus/pci/devices/%s/physfn/virtfn*\" % (pci_addr)",
            "    vf_num = None",
            "    try:",
            "        for vf_path in glob.iglob(virtfns_path):",
            "            if re.search(pci_addr, os.readlink(vf_path)):",
            "                t = VIRTFN_RE.search(vf_path)",
            "                vf_num = t.group(1)",
            "                break",
            "    except Exception:",
            "        pass",
            "    if vf_num is None:",
            "        raise exception.PciDeviceNotFoundById(id=pci_addr)",
            "    return vf_num",
            "",
            "",
            "def get_dpdk_representor_port_name(port_id):",
            "    devname = \"vfr\" + port_id",
            "    return devname[:NIC_NAME_LEN]",
            "",
            "",
            "def get_pf_pci_from_vf(vf_pci):",
            "    \"\"\"Get physical function PCI address of a VF",
            "",
            "    :param vf_pci: the PCI address of the VF",
            "    :return: the PCI address of the PF",
            "    \"\"\"",
            "    physfn_path = os.readlink(\"/sys/bus/pci/devices/%s/physfn\" % vf_pci)",
            "    return os.path.basename(physfn_path)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "132": [
                "ensure_bridge"
            ]
        },
        "addLocation": []
    },
    "vif_plug_ovs/tests/unit/test_linux_net.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         linux_net.ensure_bridge(\"br0\")"
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         mock_dev_exists.assert_called_once_with(\"br0\")"
            },
            "3": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_add.assert_called_once_with(\"br0\", \"bridge\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        mock_add.assert_called_once_with(\"br0\", \"bridge\", ageing=0)"
            },
            "5": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         mock_disable_ipv6.assert_called_once_with(\"br0\")"
            },
            "6": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         mock_set_state.assert_called_once_with(\"br0\", \"up\")"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         mock_arp_filtering.assert_called_once_with(\"br0\")"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import glob",
            "import mock",
            "import os.path",
            "import testtools",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from six.moves import builtins",
            "",
            "from vif_plug_ovs import exception",
            "from vif_plug_ovs import linux_net",
            "from vif_plug_ovs import privsep",
            "",
            "",
            "class LinuxNetTest(testtools.TestCase):",
            "",
            "    def setUp(self):",
            "        super(LinuxNetTest, self).setUp()",
            "",
            "        privsep.vif_plug.set_client_mode(False)",
            "",
            "    @mock.patch.object(linux_net, \"_arp_filtering\")",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(linux_net, \"_disable_ipv6\")",
            "    @mock.patch.object(ip_lib, \"add\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=False)",
            "    def test_ensure_bridge(self, mock_dev_exists, mock_add,",
            "                           mock_disable_ipv6, mock_set_state,",
            "                           mock_arp_filtering):",
            "        linux_net.ensure_bridge(\"br0\")",
            "",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "        mock_add.assert_called_once_with(\"br0\", \"bridge\")",
            "        mock_disable_ipv6.assert_called_once_with(\"br0\")",
            "        mock_set_state.assert_called_once_with(\"br0\", \"up\")",
            "        mock_arp_filtering.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch.object(linux_net, \"_arp_filtering\")",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(linux_net, \"_disable_ipv6\")",
            "    @mock.patch.object(ip_lib, \"add\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=True)",
            "    def test_ensure_bridge_exists(self, mock_dev_exists, mock_add,",
            "                                  mock_disable_ipv6, mock_set_state,",
            "                                  mock_arp_filtering):",
            "        linux_net.ensure_bridge(\"br0\")",
            "",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "        mock_add.assert_not_called()",
            "        mock_disable_ipv6.assert_called_once_with(\"br0\")",
            "        mock_set_state.assert_called_once_with(\"br0\", \"up\")",
            "        mock_arp_filtering.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch(\"os.path.exists\")",
            "    def test__disable_ipv6(self, mock_exists, mock_open):",
            "",
            "        exists_path = \"/proc/sys/net/ipv6/conf/br0/disable_ipv6\"",
            "        mock_exists.return_value = False",
            "",
            "        linux_net._disable_ipv6(\"br0\")",
            "        mock_exists.assert_called_once_with(exists_path)",
            "        mock_open.assert_not_called()",
            "",
            "        mock_exists.reset_mock()",
            "        mock_exists.return_value = True",
            "        linux_net._disable_ipv6(\"br0\")",
            "        mock_exists.assert_called_once_with(exists_path)",
            "        mock_open.assert_called_once_with(exists_path, 'w')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch.object(builtins, 'open')",
            "    def test__arp_filtering(self, mock_open, *args):",
            "        mock_open.side_effect = mock.mock_open()",
            "        linux_net._arp_filtering(\"br0\")",
            "",
            "        mock_open.assert_has_calls([",
            "            mock.call('/proc/sys/net/ipv4/conf/br0/arp_ignore', 'w'),",
            "            mock.call('/proc/sys/net/ipv4/conf/br0/arp_announce', 'w')])",
            "        mock_open.side_effect.return_value.write.assert_has_calls([",
            "            mock.call('1'),",
            "            mock.call('2')])",
            "",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=False)",
            "    def test_delete_bridge_none(self, mock_dev_exists, mock_delete):",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_delete.assert_not_called()",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=True)",
            "    def test_delete_bridge_exists(self, mock_dev_exists, mock_delete,",
            "                                  mock_set_state):",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_dev_exists.assert_has_calls([mock.call(\"br0\"),",
            "                                          mock.call(\"vnet1\")])",
            "        mock_delete.assert_called_once_with(\"br0\", check_exit_code=[0, 2, 254])",
            "        mock_set_state.assert_called_once_with(\"vnet1\", \"down\")",
            "",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\")",
            "    def test_delete_interface_not_present(self, mock_dev_exists, mock_delete,",
            "                                          mock_set_state):",
            "        mock_dev_exists.return_value = next(lambda: (yield True),",
            "                                            (yield False))",
            "",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_dev_exists.assert_has_calls([mock.call(\"br0\"),",
            "                                          mock.call(\"vnet1\")])",
            "        mock_delete.assert_called_once_with(\"br0\", check_exit_code=[0, 2, 254])",
            "        mock_set_state.assert_not_called()",
            "",
            "    @mock.patch.object(ip_lib, \"set\")",
            "    def test_add_bridge_port(self, mock_set):",
            "        linux_net.add_bridge_port(\"br0\", \"vnet1\")",
            "        mock_set.assert_called_once_with(\"vnet1\", master=\"br0\")",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_ioerror(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            [IOError()])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        self.assertEqual(test_switchdev, False)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_empty(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            [''])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual(test_switchdev, False)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_positive(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id'])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual(test_switchdev, True)",
            "",
            "    def test_parse_vf_number(self):",
            "        self.assertEqual(linux_net._parse_vf_number(\"0\"), \"0\")",
            "        self.assertEqual(linux_net._parse_vf_number(\"pf13vf42\"), \"42\")",
            "        self.assertEqual(linux_net._parse_vf_number(\"VF19@PF13\"), \"19\")",
            "        self.assertIsNone(linux_net._parse_vf_number(\"p7\"))",
            "        self.assertIsNone(linux_net._parse_vf_number(\"pf31\"))",
            "        self.assertIsNone(linux_net._parse_vf_number(\"g4rbl3d\"))",
            "",
            "    def test_parse_pf_number(self):",
            "        self.assertIsNone(linux_net._parse_pf_number(\"0\"))",
            "        self.assertEqual(linux_net._parse_pf_number(\"pf13vf42\"), \"13\")",
            "        self.assertEqual(linux_net._parse_pf_number(\"VF19@PF13\"), \"13\")",
            "        self.assertIsNone(linux_net._parse_pf_number(\"p7\"))",
            "        self.assertEqual(linux_net._parse_pf_number(\"pf31\"), \"31\")",
            "        self.assertIsNone(linux_net._parse_pf_number(\"g4rbl3d\"))",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port(self, mock_get_function_by_ifname,",
            "                                  mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "              ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', 'pf0vf2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.0\", True)])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_1/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_1/phys_port_name', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_2/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_2/phys_port_name', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        ifname = linux_net.get_representor_port('pf_ifname', '2')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual('rep_vf_2', ifname)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_2_pfs(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname1', 'pf_ifname2', 'rep_pf1_vf_1', 'rep_pf1_vf_2',",
            "            'rep_pf2_vf_1', 'rep_pf2_vf_2',",
            "        ]",
            "        mock_isfile.side_effect = [True, True, True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id',",
            "             'pf_sw_id', 'VF1@PF1', 'pf_sw_id', 'vf2@pf1',",
            "             'pf_sw_id', 'pf2vf1', 'pf_sw_id', 'pf2vf2'])",
            "        # PCI IDs mocked:",
            "        # PF1:    0000:0a:00.1    PF2:    0000:0a:00.2",
            "        # PF1VF1: 0000:0a:02.1    PF1VF2: 0000:0a:02.2",
            "        # PF2VF1: 0000:0a:04.1    PF2VF2: 0000:0a:04.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.1\", True), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:02.1\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:04.1\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:04.2\", False), (\"0000:0a:00.2\", True)])",
            "        ifname = linux_net.get_representor_port('pf_ifname2', '2')",
            "        self.assertEqual('rep_pf2_vf_2', ifname)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_not_found(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', '2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3'),",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_exception_io_error(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', IOError(), 'pf_sw_id', '2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.0\", True)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_exception_value_error(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', 'a'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_physical_function_inferface_name(",
            "            self, mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = ['foo', 'bar']",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['', 'valid_switch'])",
            "        ifname = linux_net.get_ifname_by_pci_address(",
            "            '0000:00:00.1', pf_interface=True, switchdev=False)",
            "        self.assertEqual(ifname, 'foo')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_physical_function_inferface_name_with_switchdev(",
            "            self, mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = ['foo', 'bar']",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['', 'valid_switch'])",
            "        ifname = linux_net.get_ifname_by_pci_address(",
            "            '0000:00:00.1', pf_interface=True, switchdev=True)",
            "        self.assertEqual(ifname, 'bar')",
            "",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_get_ifname_by_pci_address_exception(self, mock_listdir):",
            "        mock_listdir.side_effect = OSError('No such file or directory')",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_ifname_by_pci_address,",
            "            '0000:00:00.1'",
            "        )",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_vf_number_found(self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.return_value = '../../0000:00:00.1'",
            "        vf_num = linux_net.get_vf_num_by_pci_address('0000:00:00.1')",
            "        self.assertEqual(vf_num, '3')",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_vf_number_not_found(self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.return_value = '../../0000:00:00.2'",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_vf_num_by_pci_address,",
            "            '0000:00:00.1'",
            "        )",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_get_vf_num_by_pci_address_exception(",
            "            self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.side_effect = OSError('No such file or directory')",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_vf_num_by_pci_address,",
            "            '0000:00:00.1'",
            "        )"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import glob",
            "import mock",
            "import os.path",
            "import testtools",
            "",
            "from os_vif.internal.ip.api import ip as ip_lib",
            "from six.moves import builtins",
            "",
            "from vif_plug_ovs import exception",
            "from vif_plug_ovs import linux_net",
            "from vif_plug_ovs import privsep",
            "",
            "",
            "class LinuxNetTest(testtools.TestCase):",
            "",
            "    def setUp(self):",
            "        super(LinuxNetTest, self).setUp()",
            "",
            "        privsep.vif_plug.set_client_mode(False)",
            "",
            "    @mock.patch.object(linux_net, \"_arp_filtering\")",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(linux_net, \"_disable_ipv6\")",
            "    @mock.patch.object(ip_lib, \"add\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=False)",
            "    def test_ensure_bridge(self, mock_dev_exists, mock_add,",
            "                           mock_disable_ipv6, mock_set_state,",
            "                           mock_arp_filtering):",
            "        linux_net.ensure_bridge(\"br0\")",
            "",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "        mock_add.assert_called_once_with(\"br0\", \"bridge\", ageing=0)",
            "        mock_disable_ipv6.assert_called_once_with(\"br0\")",
            "        mock_set_state.assert_called_once_with(\"br0\", \"up\")",
            "        mock_arp_filtering.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch.object(linux_net, \"_arp_filtering\")",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(linux_net, \"_disable_ipv6\")",
            "    @mock.patch.object(ip_lib, \"add\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=True)",
            "    def test_ensure_bridge_exists(self, mock_dev_exists, mock_add,",
            "                                  mock_disable_ipv6, mock_set_state,",
            "                                  mock_arp_filtering):",
            "        linux_net.ensure_bridge(\"br0\")",
            "",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "        mock_add.assert_not_called()",
            "        mock_disable_ipv6.assert_called_once_with(\"br0\")",
            "        mock_set_state.assert_called_once_with(\"br0\", \"up\")",
            "        mock_arp_filtering.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch(\"os.path.exists\")",
            "    def test__disable_ipv6(self, mock_exists, mock_open):",
            "",
            "        exists_path = \"/proc/sys/net/ipv6/conf/br0/disable_ipv6\"",
            "        mock_exists.return_value = False",
            "",
            "        linux_net._disable_ipv6(\"br0\")",
            "        mock_exists.assert_called_once_with(exists_path)",
            "        mock_open.assert_not_called()",
            "",
            "        mock_exists.reset_mock()",
            "        mock_exists.return_value = True",
            "        linux_net._disable_ipv6(\"br0\")",
            "        mock_exists.assert_called_once_with(exists_path)",
            "        mock_open.assert_called_once_with(exists_path, 'w')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch.object(builtins, 'open')",
            "    def test__arp_filtering(self, mock_open, *args):",
            "        mock_open.side_effect = mock.mock_open()",
            "        linux_net._arp_filtering(\"br0\")",
            "",
            "        mock_open.assert_has_calls([",
            "            mock.call('/proc/sys/net/ipv4/conf/br0/arp_ignore', 'w'),",
            "            mock.call('/proc/sys/net/ipv4/conf/br0/arp_announce', 'w')])",
            "        mock_open.side_effect.return_value.write.assert_has_calls([",
            "            mock.call('1'),",
            "            mock.call('2')])",
            "",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=False)",
            "    def test_delete_bridge_none(self, mock_dev_exists, mock_delete):",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_delete.assert_not_called()",
            "        mock_dev_exists.assert_called_once_with(\"br0\")",
            "",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\", return_value=True)",
            "    def test_delete_bridge_exists(self, mock_dev_exists, mock_delete,",
            "                                  mock_set_state):",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_dev_exists.assert_has_calls([mock.call(\"br0\"),",
            "                                          mock.call(\"vnet1\")])",
            "        mock_delete.assert_called_once_with(\"br0\", check_exit_code=[0, 2, 254])",
            "        mock_set_state.assert_called_once_with(\"vnet1\", \"down\")",
            "",
            "    @mock.patch.object(linux_net, \"set_interface_state\")",
            "    @mock.patch.object(ip_lib, \"delete\")",
            "    @mock.patch.object(ip_lib, \"exists\")",
            "    def test_delete_interface_not_present(self, mock_dev_exists, mock_delete,",
            "                                          mock_set_state):",
            "        mock_dev_exists.return_value = next(lambda: (yield True),",
            "                                            (yield False))",
            "",
            "        linux_net.delete_bridge(\"br0\", \"vnet1\")",
            "",
            "        mock_dev_exists.assert_has_calls([mock.call(\"br0\"),",
            "                                          mock.call(\"vnet1\")])",
            "        mock_delete.assert_called_once_with(\"br0\", check_exit_code=[0, 2, 254])",
            "        mock_set_state.assert_not_called()",
            "",
            "    @mock.patch.object(ip_lib, \"set\")",
            "    def test_add_bridge_port(self, mock_set):",
            "        linux_net.add_bridge_port(\"br0\", \"vnet1\")",
            "        mock_set.assert_called_once_with(\"vnet1\", master=\"br0\")",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_ioerror(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            [IOError()])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        self.assertEqual(test_switchdev, False)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_empty(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            [''])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual(test_switchdev, False)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    def test_is_switchdev_positive(self, mock_isfile, mock_open):",
            "        mock_isfile.side_effect = [True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id'])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        test_switchdev = linux_net._is_switchdev('pf_ifname')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual(test_switchdev, True)",
            "",
            "    def test_parse_vf_number(self):",
            "        self.assertEqual(linux_net._parse_vf_number(\"0\"), \"0\")",
            "        self.assertEqual(linux_net._parse_vf_number(\"pf13vf42\"), \"42\")",
            "        self.assertEqual(linux_net._parse_vf_number(\"VF19@PF13\"), \"19\")",
            "        self.assertIsNone(linux_net._parse_vf_number(\"p7\"))",
            "        self.assertIsNone(linux_net._parse_vf_number(\"pf31\"))",
            "        self.assertIsNone(linux_net._parse_vf_number(\"g4rbl3d\"))",
            "",
            "    def test_parse_pf_number(self):",
            "        self.assertIsNone(linux_net._parse_pf_number(\"0\"))",
            "        self.assertEqual(linux_net._parse_pf_number(\"pf13vf42\"), \"13\")",
            "        self.assertEqual(linux_net._parse_pf_number(\"VF19@PF13\"), \"13\")",
            "        self.assertIsNone(linux_net._parse_pf_number(\"p7\"))",
            "        self.assertEqual(linux_net._parse_pf_number(\"pf31\"), \"31\")",
            "        self.assertIsNone(linux_net._parse_pf_number(\"g4rbl3d\"))",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port(self, mock_get_function_by_ifname,",
            "                                  mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "              ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', 'pf0vf2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.0\", True)])",
            "        open_calls = (",
            "            [mock.call('/sys/class/net/pf_ifname/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_1/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_1/phys_port_name', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_2/phys_switch_id', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None),",
            "             mock.call('/sys/class/net/rep_vf_2/phys_port_name', 'r'),",
            "             mock.call().readline(),",
            "             mock.call().__exit__(None, None, None)])",
            "        ifname = linux_net.get_representor_port('pf_ifname', '2')",
            "        mock_open.assert_has_calls(open_calls)",
            "        self.assertEqual('rep_vf_2', ifname)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_2_pfs(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname1', 'pf_ifname2', 'rep_pf1_vf_1', 'rep_pf1_vf_2',",
            "            'rep_pf2_vf_1', 'rep_pf2_vf_2',",
            "        ]",
            "        mock_isfile.side_effect = [True, True, True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id',",
            "             'pf_sw_id', 'VF1@PF1', 'pf_sw_id', 'vf2@pf1',",
            "             'pf_sw_id', 'pf2vf1', 'pf_sw_id', 'pf2vf2'])",
            "        # PCI IDs mocked:",
            "        # PF1:    0000:0a:00.1    PF2:    0000:0a:00.2",
            "        # PF1VF1: 0000:0a:02.1    PF1VF2: 0000:0a:02.2",
            "        # PF2VF1: 0000:0a:04.1    PF2VF2: 0000:0a:04.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.1\", True), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:02.1\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:04.1\", False), (\"0000:0a:00.2\", True),",
            "             (\"0000:0a:04.2\", False), (\"0000:0a:00.2\", True)])",
            "        ifname = linux_net.get_representor_port('pf_ifname2', '2')",
            "        self.assertEqual('rep_pf2_vf_2', ifname)",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_not_found(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', '2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3'),",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_exception_io_error(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', IOError(), 'pf_sw_id', '2'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False), (\"0000:0a:00.0\", True)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    @mock.patch.object(linux_net, \"get_function_by_ifname\")",
            "    def test_get_representor_port_exception_value_error(",
            "            self, mock_get_function_by_ifname, mock_listdir, mock_isfile,",
            "            mock_open):",
            "        mock_listdir.return_value = [",
            "            'pf_ifname', 'rep_vf_1', 'rep_vf_2'",
            "        ]",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['pf_sw_id', 'pf_sw_id', '1', 'pf_sw_id', 'a'])",
            "        # PCI IDs mocked:",
            "        # PF0:    0000:0a:00.0",
            "        # PF0VF1: 0000:0a:02.1    PF0VF2: 0000:0a:02.2",
            "        mock_get_function_by_ifname.side_effect = (",
            "            [(\"0000:0a:00.0\", True),",
            "             (\"0000:0a:02.1\", False),",
            "             (\"0000:0a:02.2\", False)])",
            "        self.assertRaises(",
            "            exception.RepresentorNotFound,",
            "            linux_net.get_representor_port,",
            "            'pf_ifname', '3')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_physical_function_inferface_name(",
            "            self, mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = ['foo', 'bar']",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['', 'valid_switch'])",
            "        ifname = linux_net.get_ifname_by_pci_address(",
            "            '0000:00:00.1', pf_interface=True, switchdev=False)",
            "        self.assertEqual(ifname, 'foo')",
            "",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch.object(os.path, 'isfile')",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_physical_function_inferface_name_with_switchdev(",
            "            self, mock_listdir, mock_isfile, mock_open):",
            "        mock_listdir.return_value = ['foo', 'bar']",
            "        mock_isfile.side_effect = [True, True]",
            "        mock_open.return_value.__enter__ = lambda s: s",
            "        readline_mock = mock_open.return_value.readline",
            "        readline_mock.side_effect = (",
            "            ['', 'valid_switch'])",
            "        ifname = linux_net.get_ifname_by_pci_address(",
            "            '0000:00:00.1', pf_interface=True, switchdev=True)",
            "        self.assertEqual(ifname, 'bar')",
            "",
            "    @mock.patch.object(os, 'listdir')",
            "    def test_get_ifname_by_pci_address_exception(self, mock_listdir):",
            "        mock_listdir.side_effect = OSError('No such file or directory')",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_ifname_by_pci_address,",
            "            '0000:00:00.1'",
            "        )",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_vf_number_found(self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.return_value = '../../0000:00:00.1'",
            "        vf_num = linux_net.get_vf_num_by_pci_address('0000:00:00.1')",
            "        self.assertEqual(vf_num, '3')",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_vf_number_not_found(self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.return_value = '../../0000:00:00.2'",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_vf_num_by_pci_address,",
            "            '0000:00:00.1'",
            "        )",
            "",
            "    @mock.patch.object(os, 'readlink')",
            "    @mock.patch.object(glob, 'iglob')",
            "    def test_get_vf_num_by_pci_address_exception(",
            "            self, mock_iglob, mock_readlink):",
            "        mock_iglob.return_value = [",
            "            '/sys/bus/pci/devices/0000:00:00.1/physfn/virtfn3',",
            "        ]",
            "        mock_readlink.side_effect = OSError('No such file or directory')",
            "        self.assertRaises(",
            "            exception.PciDeviceNotFoundById,",
            "            linux_net.get_vf_num_by_pci_address,",
            "            '0000:00:00.1'",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "44": [
                "LinuxNetTest",
                "test_ensure_bridge"
            ]
        },
        "addLocation": []
    }
}