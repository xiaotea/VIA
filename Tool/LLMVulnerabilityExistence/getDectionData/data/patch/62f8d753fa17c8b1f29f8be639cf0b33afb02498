{
    "src/oic/oic/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from oic.oauth2.message import ErrorResponse"
            },
            "1": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " from oic.oauth2.message import Message"
            },
            "2": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " from oic.oauth2.message import MessageFactory"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+from oic.oauth2.message import WrongSigningAlgorithm"
            },
            "4": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " from oic.oauth2.util import get_or_post"
            },
            "5": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " from oic.oic.message import SCOPE2CLAIMS"
            },
            "6": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " from oic.oic.message import AccessTokenResponse"
            },
            "7": {
                "beforePatchRowNumber": 1432,
                "afterPatchRowNumber": 1433,
                "PatchRowcode": "         return resp"
            },
            "8": {
                "beforePatchRowNumber": 1433,
                "afterPatchRowNumber": 1434,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 1434,
                "afterPatchRowNumber": 1435,
                "PatchRowcode": "     def _verify_id_token("
            },
            "10": {
                "beforePatchRowNumber": 1435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, id_token, nonce=\"\", acr_values=None, auth_time=0, max_age=0"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1436,
                "PatchRowcode": "+        self,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1437,
                "PatchRowcode": "+        id_token,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1438,
                "PatchRowcode": "+        nonce=\"\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1439,
                "PatchRowcode": "+        acr_values=None,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1440,
                "PatchRowcode": "+        auth_time=0,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1441,
                "PatchRowcode": "+        max_age=0,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1442,
                "PatchRowcode": "+        response_type=\"\","
            },
            "18": {
                "beforePatchRowNumber": 1436,
                "afterPatchRowNumber": 1443,
                "PatchRowcode": "     ):"
            },
            "19": {
                "beforePatchRowNumber": 1437,
                "afterPatchRowNumber": 1444,
                "PatchRowcode": "         \"\"\""
            },
            "20": {
                "beforePatchRowNumber": 1438,
                "afterPatchRowNumber": 1445,
                "PatchRowcode": "         Verify IdToken."
            },
            "21": {
                "beforePatchRowNumber": 1465,
                "afterPatchRowNumber": 1472,
                "PatchRowcode": "         if _now > id_token[\"exp\"]:"
            },
            "22": {
                "beforePatchRowNumber": 1466,
                "afterPatchRowNumber": 1473,
                "PatchRowcode": "             raise OtherError(\"Passed best before date\")"
            },
            "23": {
                "beforePatchRowNumber": 1467,
                "afterPatchRowNumber": 1474,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1475,
                "PatchRowcode": "+        if response_type != [\"code\"] and id_token.jws_header[\"alg\"] == \"none\":"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1476,
                "PatchRowcode": "+            raise WrongSigningAlgorithm("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1477,
                "PatchRowcode": "+                \"none is not allowed outside Authorization Flow.\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1478,
                "PatchRowcode": "+            )"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1479,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 1468,
                "afterPatchRowNumber": 1480,
                "PatchRowcode": "         if ("
            },
            "30": {
                "beforePatchRowNumber": 1469,
                "afterPatchRowNumber": 1481,
                "PatchRowcode": "             self.id_token_max_age"
            },
            "31": {
                "beforePatchRowNumber": 1470,
                "afterPatchRowNumber": 1482,
                "PatchRowcode": "             and _now > int(id_token[\"iat\"]) + self.id_token_max_age"
            },
            "32": {
                "beforePatchRowNumber": 1491,
                "afterPatchRowNumber": 1503,
                "PatchRowcode": "         except KeyError:"
            },
            "33": {
                "beforePatchRowNumber": 1492,
                "afterPatchRowNumber": 1504,
                "PatchRowcode": "             pass"
            },
            "34": {
                "beforePatchRowNumber": 1493,
                "afterPatchRowNumber": 1505,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 1494,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for param in [\"acr_values\", \"max_age\"]:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1506,
                "PatchRowcode": "+        for param in [\"acr_values\", \"max_age\", \"response_type\"]:"
            },
            "37": {
                "beforePatchRowNumber": 1495,
                "afterPatchRowNumber": 1507,
                "PatchRowcode": "             try:"
            },
            "38": {
                "beforePatchRowNumber": 1496,
                "afterPatchRowNumber": 1508,
                "PatchRowcode": "                 kwa[param] = authn_req[param]"
            },
            "39": {
                "beforePatchRowNumber": 1497,
                "afterPatchRowNumber": 1509,
                "PatchRowcode": "             except KeyError:"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "import logging",
            "import os",
            "import warnings",
            "from base64 import b64encode",
            "from json import JSONDecodeError",
            "from typing import Any",
            "from typing import Dict",
            "from typing import List",
            "from typing import Optional",
            "from typing import Tuple",
            "from typing import Type",
            "from typing import Union",
            "from typing import cast",
            "from urllib.parse import parse_qs",
            "from urllib.parse import urlparse",
            "",
            "from jwkest import BadSyntax",
            "from jwkest import as_bytes",
            "from jwkest import jwe",
            "from jwkest import jws",
            "from jwkest import jwt",
            "from jwkest.jwe import JWE",
            "from requests import ConnectionError",
            "",
            "from oic import oauth2",
            "from oic import rndstr",
            "from oic.exception import AccessDenied",
            "from oic.exception import AuthnToOld",
            "from oic.exception import AuthzError",
            "from oic.exception import CommunicationError",
            "from oic.exception import MissingParameter",
            "from oic.exception import ParameterError",
            "from oic.exception import PyoidcError",
            "from oic.exception import RegistrationError",
            "from oic.exception import RequestError",
            "from oic.exception import SubMismatch",
            "from oic.oauth2 import HTTP_ARGS",
            "from oic.oauth2 import authz_error",
            "from oic.oauth2.consumer import ConfigurationError",
            "from oic.oauth2.exception import MissingRequiredAttribute",
            "from oic.oauth2.exception import OtherError",
            "from oic.oauth2.exception import ParseError",
            "from oic.oauth2.message import ErrorResponse",
            "from oic.oauth2.message import Message",
            "from oic.oauth2.message import MessageFactory",
            "from oic.oauth2.util import get_or_post",
            "from oic.oic.message import SCOPE2CLAIMS",
            "from oic.oic.message import AccessTokenResponse",
            "from oic.oic.message import AuthorizationErrorResponse",
            "from oic.oic.message import AuthorizationRequest",
            "from oic.oic.message import AuthorizationResponse",
            "from oic.oic.message import Claims",
            "from oic.oic.message import ClaimsRequest",
            "from oic.oic.message import ClientRegistrationErrorResponse",
            "from oic.oic.message import EndSessionRequest",
            "from oic.oic.message import IdToken",
            "from oic.oic.message import JasonWebToken",
            "from oic.oic.message import OIDCMessageFactory",
            "from oic.oic.message import OpenIDRequest",
            "from oic.oic.message import OpenIDSchema",
            "from oic.oic.message import RefreshSessionRequest",
            "from oic.oic.message import RegistrationRequest",
            "from oic.oic.message import RegistrationResponse",
            "from oic.oic.message import TokenErrorResponse",
            "from oic.oic.message import UserInfoErrorResponse",
            "from oic.oic.message import UserInfoRequest",
            "from oic.utils import time_util",
            "from oic.utils.http_util import Response",
            "from oic.utils.keyio import KeyJar",
            "from oic.utils.sanitize import sanitize",
            "from oic.utils.settings import OicClientSettings",
            "from oic.utils.settings import OicServerSettings",
            "from oic.utils.settings import PyoidcSettings",
            "from oic.utils.webfinger import OIC_ISSUER",
            "from oic.utils.webfinger import WebFinger",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "ENDPOINTS = [",
            "    \"authorization_endpoint\",",
            "    \"token_endpoint\",",
            "    \"userinfo_endpoint\",",
            "    \"refresh_session_endpoint\",",
            "    \"end_session_endpoint\",",
            "    \"registration_endpoint\",",
            "    \"check_id_endpoint\",",
            "]",
            "",
            "RESPONSE2ERROR: Dict[str, List] = {",
            "    \"AuthorizationResponse\": [AuthorizationErrorResponse, TokenErrorResponse],",
            "    \"AccessTokenResponse\": [TokenErrorResponse],",
            "    \"IdToken\": [ErrorResponse],",
            "    \"RegistrationResponse\": [ClientRegistrationErrorResponse],",
            "    \"OpenIDSchema\": [UserInfoErrorResponse],",
            "}",
            "",
            "REQUEST2ENDPOINT = {",
            "    \"AuthorizationRequest\": \"authorization_endpoint\",",
            "    \"OpenIDRequest\": \"authorization_endpoint\",",
            "    \"AccessTokenRequest\": \"token_endpoint\",",
            "    \"RefreshAccessTokenRequest\": \"token_endpoint\",",
            "    \"UserInfoRequest\": \"userinfo_endpoint\",",
            "    \"CheckSessionRequest\": \"check_session_endpoint\",",
            "    \"CheckIDRequest\": \"check_id_endpoint\",",
            "    \"EndSessionRequest\": \"end_session_endpoint\",",
            "    \"RefreshSessionRequest\": \"refresh_session_endpoint\",",
            "    \"RegistrationRequest\": \"registration_endpoint\",",
            "    \"RotateSecret\": \"registration_endpoint\",",
            "    # ---",
            "    \"ResourceRequest\": \"resource_endpoint\",",
            "    \"TokenIntrospectionRequest\": \"introspection_endpoint\",",
            "    \"TokenRevocationRequest\": \"revocation_endpoint\",",
            "    \"ROPCAccessTokenRequest\": \"token_endpoint\",",
            "}",
            "",
            "# -----------------------------------------------------------------------------",
            "",
            "JWT_BEARER = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"",
            "SAML2_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:saml2-bearer\"",
            "",
            "# This should probably be part of the configuration",
            "MAX_AUTHENTICATION_AGE = 86400",
            "DEF_SIGN_ALG = {",
            "    \"id_token\": \"RS256\",",
            "    \"openid_request_object\": \"RS256\",",
            "    \"client_secret_jwt\": \"HS256\",",
            "    \"private_key_jwt\": \"RS256\",",
            "}",
            "",
            "# -----------------------------------------------------------------------------",
            "ACR_LISTS = [[\"0\", \"1\", \"2\", \"3\", \"4\"]]",
            "",
            "",
            "def verify_acr_level(req, level):",
            "    if req is None:",
            "        return level",
            "    elif \"values\" in req:",
            "        for _r in req[\"values\"]:",
            "            for alist in ACR_LISTS:",
            "                try:",
            "                    if alist.index(_r) <= alist.index(level):",
            "                        return level",
            "                except ValueError:",
            "                    pass",
            "    else:  # Required or Optional",
            "        return level",
            "",
            "    raise AccessDenied(\"\", req)",
            "",
            "",
            "def deser_id_token(inst, txt=\"\"):",
            "    if not txt:",
            "        return None",
            "    else:",
            "        return IdToken().from_jwt(txt, keyjar=inst.keyjar)",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "def make_openid_request(",
            "    arq,",
            "    keys=None,",
            "    userinfo_claims=None,",
            "    idtoken_claims=None,",
            "    request_object_signing_alg=None,",
            "    **kwargs,",
            "):",
            "    \"\"\"",
            "    Construct the specification of what I want returned.",
            "",
            "    The request will be signed.",
            "",
            "    :param arq: The Authorization request",
            "    :param keys: Keys to use for signing/encrypting",
            "    :param userinfo_claims: UserInfo claims",
            "    :param idtoken_claims: IdToken claims",
            "    :param request_object_signing_alg: Which signing algorithm to use",
            "    :return: JWT encoded OpenID request",
            "    \"\"\"",
            "    oir_args = {}",
            "    for prop in OpenIDRequest.c_param.keys():",
            "        try:",
            "            oir_args[prop] = arq[prop]",
            "        except KeyError:",
            "            pass",
            "",
            "    for attr in [\"scope\", \"response_type\"]:",
            "        if attr in oir_args:",
            "            oir_args[attr] = \" \".join(oir_args[attr])",
            "",
            "    c_args = {}",
            "    if userinfo_claims is not None:",
            "        # UserInfoClaims",
            "        c_args[\"userinfo\"] = Claims(**userinfo_claims)",
            "",
            "    if idtoken_claims is not None:",
            "        # IdTokenClaims",
            "        c_args[\"id_token\"] = Claims(**idtoken_claims)",
            "",
            "    if c_args:",
            "        oir_args[\"claims\"] = ClaimsRequest(**c_args)",
            "",
            "    oir = OpenIDRequest(**oir_args)",
            "",
            "    return oir.to_jwt(key=keys, algorithm=request_object_signing_alg)",
            "",
            "",
            "class Token(oauth2.Token):",
            "    pass",
            "",
            "",
            "class Grant(oauth2.Grant):",
            "    _authz_resp = AuthorizationResponse",
            "    _acc_resp = AccessTokenResponse",
            "    _token_class = Token",
            "",
            "    def add_token(self, resp):",
            "        tok = self._token_class(resp)",
            "        if tok.access_token:",
            "            self.tokens.append(tok)",
            "        else:",
            "            _tmp = getattr(tok, \"id_token\", None)",
            "            if _tmp:",
            "                self.tokens.append(tok)",
            "",
            "",
            "PREFERENCE2PROVIDER = {",
            "    \"request_object_signing_alg\": \"request_object_signing_alg_values_supported\",",
            "    \"request_object_encryption_alg\": \"request_object_encryption_alg_values_supported\",",
            "    \"request_object_encryption_enc\": \"request_object_encryption_enc_values_supported\",",
            "    \"userinfo_signed_response_alg\": \"userinfo_signing_alg_values_supported\",",
            "    \"userinfo_encrypted_response_alg\": \"userinfo_encryption_alg_values_supported\",",
            "    \"userinfo_encrypted_response_enc\": \"userinfo_encryption_enc_values_supported\",",
            "    \"id_token_signed_response_alg\": \"id_token_signing_alg_values_supported\",",
            "    \"id_token_encrypted_response_alg\": \"id_token_encryption_alg_values_supported\",",
            "    \"id_token_encrypted_response_enc\": \"id_token_encryption_enc_values_supported\",",
            "    \"default_acr_values\": \"acr_values_supported\",",
            "    \"subject_type\": \"subject_types_supported\",",
            "    \"token_endpoint_auth_method\": \"token_endpoint_auth_methods_supported\",",
            "    \"token_endpoint_auth_signing_alg\": \"token_endpoint_auth_signing_alg_values_supported\",",
            "    \"response_types\": \"response_types_supported\",",
            "    \"grant_types\": \"grant_types_supported\",",
            "}",
            "",
            "PROVIDER2PREFERENCE = dict([(v, k) for k, v in PREFERENCE2PROVIDER.items()])",
            "",
            "PROVIDER_DEFAULT = {",
            "    \"token_endpoint_auth_method\": \"client_secret_basic\",",
            "    \"id_token_signed_response_alg\": \"RS256\",",
            "}",
            "",
            "PARAMMAP = {",
            "    \"sign\": \"%s_signed_response_alg\",",
            "    \"alg\": \"%s_encrypted_response_alg\",",
            "    \"enc\": \"%s_encrypted_response_enc\",",
            "}",
            "",
            "rt2gt = {",
            "    \"code\": [\"authorization_code\"],",
            "    \"id_token\": [\"implicit\"],",
            "    \"id_token token\": [\"implicit\"],",
            "    \"code id_token\": [\"authorization_code\", \"implicit\"],",
            "    \"code token\": [\"authorization_code\", \"implicit\"],",
            "    \"code id_token token\": [\"authorization_code\", \"implicit\"],",
            "}",
            "",
            "",
            "def response_types_to_grant_types(resp_types, **kwargs):",
            "    _res = set()",
            "",
            "    if \"grant_types\" in kwargs:",
            "        _res.update(set(kwargs[\"grant_types\"]))",
            "",
            "    for response_type in resp_types:",
            "        _rt = response_type.split(\" \")",
            "        _rt.sort()",
            "        try:",
            "            _gt = rt2gt[\" \".join(_rt)]",
            "        except KeyError:",
            "            raise ValueError(\"No such response type combination: {}\".format(resp_types))",
            "        else:",
            "            _res.update(set(_gt))",
            "",
            "    return list(_res)",
            "",
            "",
            "def claims_match(value, claimspec):",
            "    \"\"\"",
            "    Implement matching according to section 5.5.1 of http://openid.net/specs/openid-connect-core-1_0.html.",
            "",
            "    The lack of value is not checked here.",
            "    Also the text doesn't prohibit having both 'value' and 'values'.",
            "",
            "    :param value: single value or list of values",
            "    :param claimspec: None or dictionary with 'essential', 'value' or 'values'",
            "    as key",
            "    :return: Boolean",
            "    \"\"\"",
            "    if claimspec is None:  # match anything",
            "        return True",
            "",
            "    matched = False",
            "    for key, val in claimspec.items():",
            "        if key == \"value\":",
            "            if value == val:",
            "                matched = True",
            "        elif key == \"values\":",
            "            if value in val:",
            "                matched = True",
            "        elif key == \"essential\":",
            "            # Whether it's essential or not doesn't change anything here",
            "            continue",
            "",
            "        if matched:",
            "            break",
            "",
            "    if matched is False:",
            "        if list(claimspec.keys()) == [\"essential\"]:",
            "            return True",
            "",
            "    return matched",
            "",
            "",
            "class Client(oauth2.Client):",
            "    _endpoints = ENDPOINTS",
            "",
            "    def __init__(",
            "        self,",
            "        client_id=None,",
            "        client_prefs=None,",
            "        client_authn_method=None,",
            "        keyjar=None,",
            "        verify_ssl=None,",
            "        config=None,",
            "        client_cert=None,",
            "        requests_dir=\"requests\",",
            "        message_factory: Type[MessageFactory] = OIDCMessageFactory,",
            "        settings: PyoidcSettings = None,",
            "    ):",
            "        \"\"\"",
            "        Initialize the instance.",
            "",
            "        Keyword Args:",
            "            settings",
            "                Instance of :class:`OauthClientSettings` with configuration options.",
            "                Currently used settings are:",
            "                 - verify_ssl",
            "                 - client_cert",
            "                 - timeout",
            "        \"\"\"",
            "        self.settings = settings or OicClientSettings()",
            "        if verify_ssl is not None:",
            "            warnings.warn(",
            "                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.verify_ssl = verify_ssl",
            "        if client_cert is not None:",
            "            warnings.warn(",
            "                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.client_cert = client_cert",
            "        oauth2.Client.__init__(",
            "            self,",
            "            client_id,",
            "            client_authn_method=client_authn_method,",
            "            keyjar=keyjar,",
            "            config=config,",
            "            message_factory=message_factory,",
            "            settings=self.settings,",
            "        )",
            "",
            "        self.file_store = \"./file/\"",
            "        self.file_uri = \"http://localhost/\"",
            "        self.base_url = \"\"",
            "",
            "        # OpenID connect specific endpoints",
            "        for endpoint in ENDPOINTS:",
            "            setattr(self, endpoint, \"\")",
            "",
            "        self.id_token: Dict[str, Token] = {}",
            "        self.log = None",
            "",
            "        self.request2endpoint = REQUEST2ENDPOINT",
            "        self.response2error = RESPONSE2ERROR",
            "",
            "        self.grant_class = Grant",
            "        self.token_class = Token",
            "        self.provider_info = Message()",
            "        self.registration_response: RegistrationResponse = RegistrationResponse()",
            "        self.client_prefs = client_prefs or {}",
            "",
            "        self.behaviour: Dict[str, Any] = {}",
            "        self.scope = [\"openid\"]",
            "",
            "        self.wf = WebFinger(OIC_ISSUER)",
            "        self.wf.httpd = self",
            "        self.allow = {}",
            "        self.post_logout_redirect_uris: List[str] = []",
            "        self.registration_expires = 0",
            "        self.registration_access_token = None",
            "        self.id_token_max_age = 0",
            "",
            "        # Default key by kid for different key types",
            "        # For instance {'sig': {\"RSA\":\"abc\"}}",
            "        self.kid = {\"sig\": {}, \"enc\": {}}",
            "        self.requests_dir = requests_dir",
            "",
            "    def _get_id_token(self, **kwargs):",
            "        try:",
            "            return kwargs[\"id_token\"]",
            "        except KeyError:",
            "            grant = self.get_grant(**kwargs)",
            "",
            "        if grant:",
            "            try:",
            "                _scope = kwargs[\"scope\"]",
            "            except KeyError:",
            "                _scope = None",
            "",
            "            for token in grant.tokens:",
            "                if token.scope and _scope:",
            "                    flag = True",
            "                    for item in _scope:",
            "                        if item not in token.scope:",
            "                            flag = False",
            "                            break",
            "                    if not flag:",
            "                        break",
            "                if token.id_token:",
            "                    return token.id_token.jwt",
            "",
            "        return None",
            "",
            "    def request_object_encryption(self, msg, **kwargs):",
            "        try:",
            "            encalg = kwargs[\"request_object_encryption_alg\"]",
            "        except KeyError:",
            "            try:",
            "                encalg = self.behaviour[\"request_object_encryption_alg\"]",
            "            except KeyError:",
            "                return msg",
            "",
            "        try:",
            "            encenc = kwargs[\"request_object_encryption_enc\"]",
            "        except KeyError:",
            "            try:",
            "                encenc = self.behaviour[\"request_object_encryption_enc\"]",
            "            except KeyError:",
            "                raise MissingRequiredAttribute(",
            "                    \"No request_object_encryption_enc specified\"",
            "                )",
            "",
            "        _jwe = JWE(msg, alg=encalg, enc=encenc)",
            "        _kty = jwe.alg2keytype(encalg)",
            "",
            "        try:",
            "            _kid = kwargs[\"enc_kid\"]",
            "        except KeyError:",
            "            _kid = \"\"",
            "",
            "        if \"target\" not in kwargs:",
            "            raise MissingRequiredAttribute(\"No target specified\")",
            "",
            "        if _kid:",
            "            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"], kid=_kid)",
            "            _jwe[\"kid\"] = _kid",
            "        else:",
            "            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"])",
            "",
            "        return _jwe.encrypt(_keys)",
            "",
            "    @staticmethod",
            "    def construct_redirect_uri(**kwargs):",
            "        _filedir = kwargs[\"local_dir\"]",
            "        if not os.path.isdir(_filedir):",
            "            os.makedirs(_filedir)",
            "        _webpath = kwargs[\"base_path\"]",
            "        _name = rndstr(10) + \".jwt\"",
            "        filename = os.path.join(_filedir, _name)",
            "        while os.path.exists(filename):",
            "            _name = rndstr(10)",
            "            filename = os.path.join(_filedir, _name)",
            "        _webname = \"%s%s\" % (_webpath, _name)",
            "        return filename, _webname",
            "",
            "    def filename_from_webname(self, webname):",
            "        _filedir = self.requests_dir",
            "        if not os.path.isdir(_filedir):",
            "            os.makedirs(_filedir)",
            "",
            "        if webname.startswith(self.base_url):",
            "            return webname[len(self.base_url) :]",
            "        else:",
            "            raise ValueError(\"Invalid webname, must start with base_url\")",
            "",
            "    def construct_AuthorizationRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request_args is not None:",
            "            if \"nonce\" not in request_args:",
            "                _rt = request_args[\"response_type\"]",
            "                if \"token\" in _rt or \"id_token\" in _rt:",
            "                    request_args[\"nonce\"] = rndstr(32)",
            "        elif \"response_type\" in kwargs:",
            "            if \"token\" in kwargs[\"response_type\"]:",
            "                request_args = {\"nonce\": rndstr(32)}",
            "        else:  # Never wrong to specify a nonce",
            "            request_args = {\"nonce\": rndstr(32)}",
            "",
            "        request_param = kwargs.get(\"request_param\")",
            "        if \"request_method\" in kwargs:",
            "            if kwargs[\"request_method\"] == \"file\":",
            "                request_param = \"request_uri\"",
            "            else:",
            "                request_param = \"request\"",
            "            del kwargs[\"request_method\"]",
            "",
            "        areq = super().construct_AuthorizationRequest(",
            "            request=request, request_args=request_args, extra_args=extra_args, **kwargs",
            "        )",
            "",
            "        if request_param:",
            "            alg = None",
            "            for arg in [\"request_object_signing_alg\", \"algorithm\"]:",
            "                try:  # Trumps everything",
            "                    alg = kwargs[arg]",
            "                except KeyError:",
            "                    pass",
            "                else:",
            "                    break",
            "",
            "            if not alg:",
            "                try:",
            "                    alg = self.behaviour[\"request_object_signing_alg\"]",
            "                except KeyError:",
            "                    alg = \"none\"",
            "",
            "            kwargs[\"request_object_signing_alg\"] = alg",
            "",
            "            if \"keys\" not in kwargs and alg and alg != \"none\":",
            "                _kty = jws.alg2keytype(alg)",
            "                try:",
            "                    _kid = kwargs[\"sig_kid\"]",
            "                except KeyError:",
            "                    _kid = self.kid[\"sig\"].get(_kty, None)",
            "",
            "                kwargs[\"keys\"] = self.keyjar.get_signing_key(_kty, kid=_kid)",
            "",
            "            _req = make_openid_request(areq, **kwargs)",
            "",
            "            # Should the request be encrypted",
            "            _req = self.request_object_encryption(_req, **kwargs)",
            "",
            "            if request_param == \"request\":",
            "                areq[\"request\"] = _req",
            "            else:",
            "                try:",
            "                    _webname = self.registration_response[\"request_uris\"][0]",
            "                    filename = self.filename_from_webname(_webname)",
            "                except KeyError:",
            "                    filename, _webname = self.construct_redirect_uri(**kwargs)",
            "                with open(filename, mode=\"w\") as fid:",
            "                    fid.write(_req)",
            "                areq[\"request_uri\"] = _webname",
            "",
            "        return areq",
            "",
            "    def construct_UserInfoRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"userinfo_endpoint\")",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        if \"access_token\" in request_args:",
            "            pass",
            "        else:",
            "            if \"scope\" not in kwargs:",
            "                kwargs[\"scope\"] = \"openid\"",
            "            token = self.get_token(**kwargs)",
            "            if token is None:",
            "                raise MissingParameter(\"No valid token available\")",
            "",
            "            request_args[\"access_token\"] = token.access_token",
            "",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_RegistrationRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"registration_endpoint\")",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_RefreshSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"refreshsession_endpoint\")",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def _id_token_based(self, request, request_args=None, extra_args=None, **kwargs):",
            "",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        try:",
            "            _prop = kwargs[\"prop\"]",
            "        except KeyError:",
            "            _prop = \"id_token\"",
            "",
            "        if _prop in request_args:",
            "            pass",
            "        else:",
            "            raw_id_token = self._get_id_token(**kwargs)",
            "            if raw_id_token is None:",
            "                raise MissingParameter(\"No valid id token available\")",
            "",
            "            request_args[_prop] = raw_id_token",
            "",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_CheckSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"checksession_endpoint\")",
            "",
            "        return self._id_token_based(request, request_args, extra_args, **kwargs)",
            "",
            "    def construct_CheckIDRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"checkid_endpoint\")",
            "        # access_token is where the id_token will be placed",
            "        return self._id_token_based(",
            "            request, request_args, extra_args, prop=\"access_token\", **kwargs",
            "        )",
            "",
            "    def construct_EndSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"endsession_endpoint\")",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        if \"state\" in request_args and \"state\" not in kwargs:",
            "            kwargs[\"state\"] = request_args[\"state\"]",
            "",
            "        return self._id_token_based(request, request_args, extra_args, **kwargs)",
            "",
            "    def do_authorization_request(",
            "        self,",
            "        state=\"\",",
            "        body_type=\"\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "        **kwargs,",
            "    ):",
            "        algs = self.sign_enc_algs(\"id_token\")",
            "",
            "        if \"code_challenge\" in self.config:",
            "            _args, code_verifier = self.add_code_challenge()",
            "            request_args.update(_args)",
            "",
            "        return super().do_authorization_request(",
            "            state=state,",
            "            body_type=body_type,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            http_args=http_args,",
            "            algs=algs,",
            "        )",
            "",
            "    def do_access_token_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"POST\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "        authn_method=\"client_secret_basic\",",
            "        **kwargs,",
            "    ):",
            "        atr = super().do_access_token_request(",
            "            scope=scope,",
            "            state=state,",
            "            body_type=body_type,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            http_args=http_args,",
            "            authn_method=authn_method,",
            "            **kwargs,",
            "        )",
            "        try:",
            "            _idt = atr[\"id_token\"]",
            "        except KeyError:",
            "            pass",
            "        else:",
            "            try:",
            "                if self.state2nonce[state] != _idt[\"nonce\"]:",
            "                    raise ParameterError('Someone has messed with \"nonce\"')",
            "            except KeyError:",
            "                pass",
            "        return atr",
            "",
            "    def do_registration_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"POST\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"registration_endpoint\")",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        response_cls = self.message_factory.get_response_type(\"registration_endpoint\")",
            "        response = self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "        return response",
            "",
            "    def do_check_session_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "",
            "        request = self.message_factory.get_request_type(\"checksession_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"checksession_endpoint\")",
            "",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def do_check_id_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"checkid_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"checkid_endpoint\")",
            "",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def do_end_session_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"endsession_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"endsession_endpoint\")",
            "        url, body, ht_args, _ = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def user_info_request(self, method=\"GET\", state=\"\", scope=\"\", **kwargs):",
            "        uir = self.message_factory.get_request_type(\"userinfo_endpoint\")()",
            "        logger.debug(\"[user_info_request]: kwargs:%s\" % (sanitize(kwargs),))",
            "        token: Optional[Token] = None",
            "        if \"token\" in kwargs:",
            "            if kwargs[\"token\"]:",
            "                uir[\"access_token\"] = kwargs[\"token\"]",
            "                token = Token()",
            "                token.token_type = \"Bearer\"",
            "                token.access_token = kwargs[\"token\"]",
            "                kwargs[\"behavior\"] = \"use_authorization_header\"",
            "            else:",
            "                # What to do ? Need a callback",
            "                pass",
            "        elif \"access_token\" in kwargs and kwargs[\"access_token\"]:",
            "            uir[\"access_token\"] = kwargs[\"access_token\"]",
            "            del kwargs[\"access_token\"]",
            "        elif state:",
            "            token = self.grant[state].get_token(scope)",
            "            if token is None:",
            "                raise AccessDenied(\"invalid_token\")",
            "            if token.is_valid():",
            "                uir[\"access_token\"] = token.access_token",
            "                if (",
            "                    token.token_type",
            "                    and token.token_type.lower() == \"bearer\"",
            "                    and method == \"GET\"",
            "                ):",
            "                    kwargs[\"behavior\"] = \"use_authorization_header\"",
            "            else:",
            "                # raise oauth2.OldAccessToken",
            "                if self.log:",
            "                    self.log.info(\"do access token refresh\")",
            "                try:",
            "                    self.do_access_token_refresh(token=token, state=state)",
            "                    token = cast(Token, self.grant[state].get_token(scope))",
            "                    uir[\"access_token\"] = token.access_token",
            "                except Exception:",
            "                    raise",
            "",
            "        uri = self._endpoint(\"userinfo_endpoint\", **kwargs)",
            "        # If access token is a bearer token it might be sent in the",
            "        # authorization header",
            "        # 4 ways of sending the access_token:",
            "        # - POST with token in authorization header",
            "        # - POST with token in message body",
            "        # - GET with token in authorization header",
            "        # - GET with token as query parameter",
            "        if \"behavior\" in kwargs:",
            "            _behav = kwargs[\"behavior\"]",
            "            _token = uir[\"access_token\"]",
            "            _ttype = \"\"",
            "            try:",
            "                _ttype = kwargs[\"token_type\"]",
            "            except KeyError:",
            "                if token:",
            "                    try:",
            "                        _ttype = cast(str, token.token_type)",
            "                    except AttributeError:",
            "                        raise MissingParameter(\"Unspecified token type\")",
            "",
            "            if \"as_query_parameter\" == _behav:",
            "                method = \"GET\"",
            "            elif token:",
            "                # use_authorization_header, token_in_message_body",
            "                if \"use_authorization_header\" in _behav:",
            "                    token_header = \"{type} {token}\".format(",
            "                        type=_ttype.capitalize(), token=_token",
            "                    )",
            "                    if \"headers\" in kwargs:",
            "                        kwargs[\"headers\"].update({\"Authorization\": token_header})",
            "                    else:",
            "                        kwargs[\"headers\"] = {\"Authorization\": token_header}",
            "",
            "                if \"token_in_message_body\" not in _behav:",
            "                    # remove the token from the request",
            "                    del uir[\"access_token\"]",
            "",
            "        path, body, kwargs = get_or_post(uri, method, uir, **kwargs)",
            "",
            "        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])",
            "",
            "        return path, body, method, h_args",
            "",
            "    def do_user_info_request(",
            "        self, method=\"POST\", state=\"\", scope=\"openid\", request=\"openid\", **kwargs",
            "    ):",
            "",
            "        kwargs[\"request\"] = request",
            "        path, body, method, h_args = self.user_info_request(",
            "            method, state, scope, **kwargs",
            "        )",
            "",
            "        logger.debug(",
            "            \"[do_user_info_request] PATH:%s BODY:%s H_ARGS: %s\"",
            "            % (sanitize(path), sanitize(body), sanitize(h_args))",
            "        )",
            "",
            "        if self.events:",
            "            self.events.store(\"Request\", {\"body\": body})",
            "            self.events.store(\"request_url\", path)",
            "            self.events.store(\"request_http_args\", h_args)",
            "",
            "        try:",
            "            resp = self.http_request(path, method, data=body, **h_args)",
            "        except oauth2.exception.MissingRequiredAttribute:",
            "            raise",
            "",
            "        if resp.status_code == 200:",
            "            if \"application/json\" in resp.headers[\"content-type\"]:",
            "                sformat = \"json\"",
            "            elif \"application/jwt\" in resp.headers[\"content-type\"]:",
            "                sformat = \"jwt\"",
            "            else:",
            "                raise PyoidcError(",
            "                    \"ERROR: Unexpected content-type: %s\" % resp.headers[\"content-type\"]",
            "                )",
            "        elif resp.status_code == 500:",
            "            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)",
            "        elif resp.status_code == 405:",
            "            # Method not allowed error",
            "            allowed_methods = [x.strip() for x in resp.headers[\"allow\"].split(\",\")]",
            "            raise CommunicationError(",
            "                \"Server responded with HTTP Error Code 405\", \"\", allowed_methods",
            "            )",
            "        elif 400 <= resp.status_code < 500:",
            "            # the response text might be a OIDC message",
            "            try:",
            "                res = ErrorResponse().from_json(resp.text)",
            "            except Exception:",
            "                raise RequestError(resp.text)",
            "            else:",
            "                self.store_response(res, resp.text)",
            "                return res",
            "        else:",
            "            raise PyoidcError(",
            "                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)",
            "            )",
            "",
            "        try:",
            "            _schema = kwargs[\"user_info_schema\"]",
            "        except KeyError:",
            "            _schema = OpenIDSchema",
            "",
            "        logger.debug(\"Reponse text: '%s'\" % sanitize(resp.text))",
            "",
            "        _txt = resp.text",
            "        if sformat == \"json\":",
            "            res = _schema().from_json(txt=_txt)",
            "        else:",
            "            verify = kwargs.get(\"verify\", True)",
            "            res = _schema().from_jwt(",
            "                _txt,",
            "                keyjar=self.keyjar,",
            "                sender=self.provider_info[\"issuer\"],",
            "                verify=verify,",
            "            )",
            "",
            "        if \"error\" in res:  # Error response",
            "            res = UserInfoErrorResponse(**res.to_dict())",
            "",
            "        if state:",
            "            # Verify userinfo sub claim against what's returned in the ID Token",
            "            idt = self.grant[state].get_id_token()",
            "            if idt:",
            "                if idt[\"sub\"] != res[\"sub\"]:",
            "                    raise SubMismatch(",
            "                        \"Sub identifier not the same in userinfo and Id Token\"",
            "                    )",
            "",
            "        self.store_response(res, _txt)",
            "",
            "        return res",
            "",
            "    def get_userinfo_claims(",
            "        self, access_token, endpoint, method=\"POST\", schema_class=OpenIDSchema, **kwargs",
            "    ):",
            "",
            "        uir = UserInfoRequest(access_token=access_token)",
            "",
            "        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])",
            "",
            "        if \"authn_method\" in kwargs:",
            "            http_args = self.init_authentication_method(**kwargs)",
            "        else:",
            "            # If nothing defined this is the default",
            "            http_args = self.init_authentication_method(uir, \"bearer_header\", **kwargs)",
            "",
            "        h_args.update(http_args)",
            "        path, body, kwargs = get_or_post(endpoint, method, uir, **kwargs)",
            "",
            "        try:",
            "            resp = self.http_request(path, method, data=body, **h_args)",
            "        except MissingRequiredAttribute:",
            "            raise",
            "",
            "        if resp.status_code == 200:",
            "            # FIXME: Could this also encounter application/jwt for encrypted userinfo",
            "            #        the do_userinfo_request method already handles it",
            "            if \"application/json\" not in resp.headers[\"content-type\"]:",
            "                raise PyoidcError(",
            "                    \"ERROR: content-type in response unexpected: %s\"",
            "                    % resp.headers[\"content-type\"]",
            "                )",
            "        elif resp.status_code == 500:",
            "            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)",
            "        else:",
            "            raise PyoidcError(",
            "                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)",
            "            )",
            "",
            "        res = schema_class().from_json(txt=resp.text)",
            "        self.store_response(res, resp.text)",
            "        return res",
            "",
            "    def unpack_aggregated_claims(self, userinfo):",
            "        if userinfo[\"_claim_sources\"]:",
            "            for csrc, spec in userinfo[\"_claim_sources\"].items():",
            "                if \"JWT\" in spec:",
            "                    aggregated_claims = Message().from_jwt(",
            "                        spec[\"JWT\"].encode(\"utf-8\"), keyjar=self.keyjar, sender=csrc",
            "                    )",
            "                    claims = [",
            "                        value",
            "                        for value, src in userinfo[\"_claim_names\"].items()",
            "                        if src == csrc",
            "                    ]",
            "",
            "                    if set(claims) != set(list(aggregated_claims.keys())):",
            "                        logger.warning(",
            "                            \"Claims from claim source doesn't match what's in \"",
            "                            \"the userinfo\"",
            "                        )",
            "",
            "                    for key, vals in aggregated_claims.items():",
            "                        userinfo[key] = vals",
            "",
            "        return userinfo",
            "",
            "    def fetch_distributed_claims(self, userinfo, callback=None):",
            "        for csrc, spec in userinfo[\"_claim_sources\"].items():",
            "            if \"endpoint\" in spec:",
            "                if not spec[\"endpoint\"].startswith(\"https://\"):",
            "                    logger.warning(",
            "                        \"Fetching distributed claims from an untrusted source: %s\",",
            "                        spec[\"endpoint\"],",
            "                    )",
            "                if \"access_token\" in spec:",
            "                    _uinfo = self.do_user_info_request(",
            "                        method=\"GET\",",
            "                        token=spec[\"access_token\"],",
            "                        userinfo_endpoint=spec[\"endpoint\"],",
            "                        verify=False,",
            "                    )",
            "                else:",
            "                    if callback:",
            "                        _uinfo = self.do_user_info_request(",
            "                            method=\"GET\",",
            "                            token=callback(spec[\"endpoint\"]),",
            "                            userinfo_endpoint=spec[\"endpoint\"],",
            "                            verify=False,",
            "                        )",
            "                    else:",
            "                        _uinfo = self.do_user_info_request(",
            "                            method=\"GET\",",
            "                            userinfo_endpoint=spec[\"endpoint\"],",
            "                            verify=False,",
            "                        )",
            "",
            "                claims = [",
            "                    value",
            "                    for value, src in userinfo[\"_claim_names\"].items()",
            "                    if src == csrc",
            "                ]",
            "",
            "                if set(claims) != set(list(_uinfo.keys())):",
            "                    logger.warning(",
            "                        \"Claims from claim source doesn't match what's in \"",
            "                        \"the userinfo\"",
            "                    )",
            "",
            "                for key, vals in _uinfo.items():",
            "                    userinfo[key] = vals",
            "",
            "        # Remove the `_claim_sources` and `_claim_names` from userinfo and better be safe than sorry",
            "        if \"_claim_sources\" in userinfo:",
            "            del userinfo[\"_claim_sources\"]",
            "        if \"_claim_names\" in userinfo:",
            "            del userinfo[\"_claim_names\"]",
            "        return userinfo",
            "",
            "    def verify_alg_support(self, alg, usage, other):",
            "        \"\"\"",
            "        Verify that the algorithm to be used are supported by the other side.",
            "",
            "        :param alg: The algorithm specification",
            "        :param usage: In which context the 'alg' will be used.",
            "            The following values are supported:",
            "            - userinfo",
            "            - id_token",
            "            - request_object",
            "            - token_endpoint_auth",
            "        :param other: The identifier for the other side",
            "        :return: True or False",
            "        \"\"\"",
            "        try:",
            "            _pcr = self.provider_info",
            "            supported = _pcr[\"%s_algs_supported\" % usage]",
            "        except KeyError:",
            "            try:",
            "                supported = getattr(self, \"%s_algs_supported\" % usage)",
            "            except AttributeError:",
            "                supported = None",
            "",
            "        if supported is None:",
            "            return True",
            "        else:",
            "            if alg in supported:",
            "                return True",
            "            else:",
            "                return False",
            "",
            "    def match_preferences(self, pcr=None, issuer=None):",
            "        \"\"\"",
            "        Match the clients preferences against what the provider can do.",
            "",
            "        :param pcr: Provider configuration response if available",
            "        :param issuer: The issuer identifier",
            "        \"\"\"",
            "        if not pcr:",
            "            pcr = self.provider_info",
            "",
            "        regreq = self.message_factory.get_request_type(\"registration_endpoint\")",
            "",
            "        for _pref, _prov in PREFERENCE2PROVIDER.items():",
            "            try:",
            "                vals = self.client_prefs[_pref]",
            "            except KeyError:",
            "                continue",
            "",
            "            try:",
            "                _pvals = pcr[_prov]",
            "            except KeyError:",
            "                try:",
            "                    self.behaviour[_pref] = PROVIDER_DEFAULT[_pref]",
            "                except KeyError:",
            "                    if isinstance(pcr.c_param[_prov][0], list):",
            "                        self.behaviour[_pref] = []",
            "                    else:",
            "                        self.behaviour[_pref] = None",
            "                continue",
            "",
            "            if isinstance(vals, str):",
            "                if vals in _pvals:",
            "                    self.behaviour[_pref] = vals",
            "            else:",
            "                vtyp = regreq.c_param[_pref]",
            "",
            "                if isinstance(vtyp[0], list):",
            "                    self.behaviour[_pref] = []",
            "                    for val in vals:",
            "                        if val in _pvals:",
            "                            self.behaviour[_pref].append(val)",
            "                else:",
            "                    for val in vals:",
            "                        if val in _pvals:",
            "                            self.behaviour[_pref] = val",
            "                            break",
            "",
            "            if _pref not in self.behaviour:",
            "                raise ConfigurationError(\"OP couldn't match preference:%s\" % _pref, pcr)",
            "",
            "        for key, val in self.client_prefs.items():",
            "            if key in self.behaviour:",
            "                continue",
            "",
            "            try:",
            "                vtyp = regreq.c_param[key]",
            "                if isinstance(vtyp[0], list):",
            "                    pass",
            "                elif isinstance(val, list) and not isinstance(val, str):",
            "                    val = val[0]",
            "            except KeyError:",
            "                pass",
            "            if key not in PREFERENCE2PROVIDER:",
            "                self.behaviour[key] = val",
            "",
            "    def store_registration_info(self, reginfo):",
            "        self.registration_response = reginfo",
            "        if \"token_endpoint_auth_method\" not in self.registration_response:",
            "            self.registration_response[",
            "                \"token_endpoint_auth_method\"  # nosec",
            "            ] = \"client_secret_basic\"",
            "        self.client_id = reginfo[\"client_id\"]",
            "        try:",
            "            self.client_secret = reginfo[\"client_secret\"]",
            "        except KeyError:  # Not required",
            "            pass",
            "        else:",
            "            try:",
            "                self.registration_expires = reginfo[\"client_secret_expires_at\"]",
            "            except KeyError:",
            "                pass",
            "        try:",
            "            self.registration_access_token = reginfo[\"registration_access_token\"]",
            "        except KeyError:",
            "            pass",
            "",
            "    def handle_registration_info(self, response):",
            "        err_msg = \"Got error response: {}\"",
            "        unk_msg = \"Unknown response: {}\"",
            "        if response.status_code in [200, 201]:",
            "            resp = self.message_factory.get_response_type(",
            "                \"registration_endpoint\"",
            "            )().deserialize(response.text, \"json\")",
            "            # Some implementations sends back a 200 with an error message inside",
            "            try:",
            "                resp.verify()",
            "            except oauth2.message.MissingRequiredAttribute as err:",
            "                logger.error(err)",
            "                raise RegistrationError(err)",
            "            except Exception:",
            "                resp = ErrorResponse().deserialize(response.text, \"json\")",
            "                if resp.verify():",
            "                    logger.error(err_msg.format(sanitize(resp.to_json())))",
            "                    if self.events:",
            "                        self.events.store(\"protocol response\", resp)",
            "                    raise RegistrationError(resp.to_dict())",
            "                else:  # Something else",
            "                    logger.error(unk_msg.format(sanitize(response.text)))",
            "                    raise RegistrationError(response.text)",
            "            else:",
            "                # got a proper registration response",
            "                self.store_response(resp, response.text)",
            "                self.store_registration_info(resp)",
            "        elif 400 <= response.status_code <= 499:",
            "            try:",
            "                resp = ErrorResponse().deserialize(response.text, \"json\")",
            "            except JSONDecodeError:",
            "                logger.error(unk_msg.format(sanitize(response.text)))",
            "                raise RegistrationError(response.text)",
            "",
            "            if resp.verify():",
            "                logger.error(err_msg.format(sanitize(resp.to_json())))",
            "                if self.events:",
            "                    self.events.store(\"protocol response\", resp)",
            "                raise RegistrationError(resp.to_dict())",
            "            else:  # Something else",
            "                logger.error(unk_msg.format(sanitize(response.text)))",
            "                raise RegistrationError(response.text)",
            "        else:",
            "            raise RegistrationError(response.text)",
            "",
            "        return resp",
            "",
            "    def registration_read(self, url=\"\", registration_access_token=None):",
            "        \"\"\"",
            "        Read the client registration info from the given url.",
            "",
            "        :raises RegistrationError: If an error happend",
            "        :return: RegistrationResponse",
            "        \"\"\"",
            "        if not url:",
            "            url = self.registration_response[\"registration_client_uri\"]",
            "",
            "        if not registration_access_token:",
            "            registration_access_token = self.registration_access_token",
            "",
            "        headers = {\"Authorization\": \"Bearer %s\" % registration_access_token}",
            "        rsp = self.http_request(url, \"GET\", headers=headers)",
            "",
            "        return self.handle_registration_info(rsp)",
            "",
            "    def generate_request_uris(self, request_dir):",
            "        \"\"\"",
            "        Need to generate a path that is unique for the OP combo.",
            "",
            "        :return: A list of uris",
            "        \"\"\"",
            "        m = hashlib.sha256()",
            "        m.update(as_bytes(self.provider_info[\"issuer\"]))",
            "        m.update(as_bytes(self.base_url))",
            "        return \"{}{}/{}\".format(self.base_url, request_dir, m.hexdigest())",
            "",
            "    def create_registration_request(self, **kwargs):",
            "        \"\"\"",
            "        Create a registration request.",
            "",
            "        :param kwargs: parameters to the registration request",
            "        :return:",
            "        \"\"\"",
            "        req = self.message_factory.get_request_type(\"registration_endpoint\")()",
            "",
            "        for prop in req.parameters():",
            "            try:",
            "                req[prop] = kwargs[prop]",
            "            except KeyError:",
            "                try:",
            "                    req[prop] = self.behaviour[prop]",
            "                except KeyError:",
            "                    pass",
            "",
            "        if \"post_logout_redirect_uris\" not in req:",
            "            try:",
            "                req[\"post_logout_redirect_uris\"] = self.post_logout_redirect_uris",
            "            except AttributeError:",
            "                pass",
            "",
            "        if \"redirect_uris\" not in req:",
            "            try:",
            "                req[\"redirect_uris\"] = self.redirect_uris",
            "            except AttributeError:",
            "                raise MissingRequiredAttribute(\"redirect_uris\", req)",
            "",
            "        try:",
            "            if self.provider_info[\"require_request_uri_registration\"] is True:",
            "                req[\"request_uris\"] = self.generate_request_uris(self.requests_dir)",
            "        except KeyError:",
            "            pass",
            "",
            "        if \"response_types\" in req:",
            "            req[\"grant_types\"] = response_types_to_grant_types(",
            "                req[\"response_types\"], **kwargs",
            "            )",
            "",
            "        return req",
            "",
            "    def register(self, url, registration_token=None, **kwargs):",
            "        \"\"\"",
            "        Register the client at an OP.",
            "",
            "        :param url: The OPs registration endpoint",
            "        :param registration_token: Initial Access Token for registration endpoint",
            "        :param kwargs: parameters to the registration request",
            "        :return:",
            "        \"\"\"",
            "        req = self.create_registration_request(**kwargs)",
            "",
            "        logger.debug(\"[registration_request]: kwargs:%s\" % (sanitize(kwargs),))",
            "",
            "        if self.events:",
            "            self.events.store(\"Protocol request\", req)",
            "",
            "        headers = {\"content-type\": \"application/json\"}",
            "        if registration_token is not None:",
            "            try:",
            "                token = jwt.JWT()",
            "                token.unpack(registration_token)",
            "            except BadSyntax:",
            "                # no JWT",
            "                registration_token = b64encode(registration_token.encode()).decode()",
            "            finally:",
            "                headers[\"Authorization\"] = \"Bearer \" + registration_token",
            "",
            "        rsp = self.http_request(url, \"POST\", data=req.to_json(), headers=headers)",
            "",
            "        return self.handle_registration_info(rsp)",
            "",
            "    def normalization(self, principal, idtype=\"mail\"):",
            "        if idtype == \"mail\":",
            "            (_, domain) = principal.split(\"@\")",
            "            subject = \"acct:%s\" % principal",
            "        elif idtype == \"url\":",
            "            p = urlparse(principal)",
            "            domain = p.netloc",
            "            subject = principal",
            "        else:",
            "            domain = \"\"",
            "            subject = principal",
            "",
            "        return subject, domain",
            "",
            "    def discover(self, principal, host=None):",
            "        return self.wf.discovery_query(principal, host=host)",
            "",
            "    def sign_enc_algs(self, typ):",
            "        resp = {}",
            "        for key, val in PARAMMAP.items():",
            "            try:",
            "                resp[key] = self.registration_response[val % typ]",
            "            except (TypeError, KeyError):",
            "                if key == \"sign\":",
            "                    resp[key] = DEF_SIGN_ALG[\"id_token\"]",
            "        return resp",
            "",
            "    def _verify_id_token(",
            "        self, id_token, nonce=\"\", acr_values=None, auth_time=0, max_age=0",
            "    ):",
            "        \"\"\"",
            "        Verify IdToken.",
            "",
            "        If the JWT alg Header Parameter uses a MAC based algorithm such as",
            "        HS256, HS384, or HS512, the octets of the UTF-8 representation of the",
            "        client_secret corresponding to the client_id contained in the aud",
            "        (audience) Claim are used as the key to validate the signature. For MAC",
            "        based algorithms, the behavior is unspecified if the aud is",
            "        multi-valued or if an azp value is present that is different than the",
            "        aud value.",
            "",
            "        :param id_token: The ID Token tp check",
            "        :param nonce: The nonce specified in the authorization request",
            "        :param acr_values: Asked for acr values",
            "        :param auth_time: An auth_time claim",
            "        :param max_age: Max age of authentication",
            "        \"\"\"",
            "        if self.provider_info[\"issuer\"] != id_token[\"iss\"]:",
            "            raise OtherError(\"issuer != iss\")",
            "",
            "        if self.client_id not in id_token[\"aud\"]:",
            "            raise OtherError(\"not intended for me\")",
            "        if len(id_token[\"aud\"]) > 1:",
            "            if \"azp\" not in id_token or id_token[\"azp\"] != self.client_id:",
            "                raise OtherError(\"not intended for me\")",
            "",
            "        _now = time_util.utc_time_sans_frac()",
            "",
            "        if _now > id_token[\"exp\"]:",
            "            raise OtherError(\"Passed best before date\")",
            "",
            "        if (",
            "            self.id_token_max_age",
            "            and _now > int(id_token[\"iat\"]) + self.id_token_max_age",
            "        ):",
            "            raise OtherError(\"I think this ID token is to old\")",
            "",
            "        if nonce and nonce != id_token[\"nonce\"]:",
            "            raise OtherError(\"nonce mismatch\")",
            "",
            "        if acr_values and id_token[\"acr\"] not in acr_values:",
            "            raise OtherError(\"acr mismatch\")",
            "",
            "        if max_age and _now > int(id_token[\"auth_time\"] + max_age):",
            "            raise AuthnToOld(\"To old authentication\")",
            "",
            "        if auth_time:",
            "            if not claims_match(id_token[\"auth_time\"], {\"auth_time\": auth_time}):",
            "                raise AuthnToOld(\"To old authentication\")",
            "",
            "    def verify_id_token(self, id_token, authn_req):",
            "        kwa = {}",
            "        try:",
            "            kwa[\"nonce\"] = authn_req[\"nonce\"]",
            "        except KeyError:",
            "            pass",
            "",
            "        for param in [\"acr_values\", \"max_age\"]:",
            "            try:",
            "                kwa[param] = authn_req[param]",
            "            except KeyError:",
            "                pass",
            "",
            "        self._verify_id_token(id_token, **kwa)",
            "",
            "",
            "class Server(oauth2.Server):",
            "    \"\"\"OIC Server class.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        verify_ssl: bool = None,",
            "        keyjar: KeyJar = None,",
            "        client_cert: Union[str, Tuple[str, str]] = None,",
            "        timeout: float = None,",
            "        message_factory: Type[MessageFactory] = OIDCMessageFactory,",
            "        settings: PyoidcSettings = None,",
            "    ):",
            "        \"\"\"Initialize the server.\"\"\"",
            "        self.settings = settings or OicServerSettings()",
            "        if verify_ssl is not None:",
            "            warnings.warn(",
            "                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.verify_ssl = verify_ssl",
            "        if client_cert is not None:",
            "            warnings.warn(",
            "                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.client_cert = client_cert",
            "        if timeout is not None:",
            "            warnings.warn(",
            "                \"`timeout` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.timeout = timeout",
            "",
            "        super().__init__(",
            "            keyjar=keyjar,",
            "            message_factory=message_factory,",
            "            settings=self.settings,",
            "        )",
            "",
            "    @staticmethod",
            "    def _parse_urlencoded(url=None, query=None):",
            "        if url:",
            "            parts = urlparse(url)",
            "            scheme, netloc, path, params, query, fragment = parts[:6]",
            "",
            "        return parse_qs(query)",
            "",
            "    def handle_request_uri(self, request_uri, verify=True, sender=\"\"):",
            "        \"\"\"",
            "        Handle request URI.",
            "",
            "        :param request_uri: URL pointing to where the signed request should be fetched from.",
            "        :param verify: Whether the signature on the request should be verified.",
            "        Don't use anything but the default unless you REALLY know what you're doing",
            "        :param sender: The issuer of the request JWT.",
            "        :return:",
            "        \"\"\"",
            "        # Do a HTTP get",
            "        logger.debug(\"Get request from request_uri: {}\".format(request_uri))",
            "        try:",
            "            http_req = self.http_request(request_uri)",
            "        except ConnectionError:",
            "            logger.error(\"Connection Error\")",
            "            return authz_error(\"invalid_request_uri\")",
            "",
            "        if not http_req:",
            "            logger.error(\"Nothing returned\")",
            "            return authz_error(\"invalid_request_uri\")",
            "        elif http_req.status_code >= 400:",
            "            logger.error(\"HTTP error {}:{}\".format(http_req.status_code, http_req.text))",
            "            raise AuthzError(\"invalid_request\")",
            "",
            "        # http_req.text is a signed JWT",
            "        try:",
            "            logger.debug(\"request txt: {}\".format(http_req.text))",
            "            req = self.parse_jwt_request(",
            "                txt=http_req.text, verify=verify, sender=sender",
            "            )",
            "        except Exception as err:",
            "            logger.error(",
            "                \"{}:{} encountered while parsing fetched request\".format(",
            "                    err.__class__, err",
            "                )",
            "            )",
            "            raise AuthzError(\"invalid_openid_request_object\")",
            "",
            "        logger.debug(\"Fetched request: {}\".format(req))",
            "        return req",
            "",
            "    def parse_authorization_request(",
            "        self, request=AuthorizationRequest, url=None, query=None, keys=None",
            "    ):",
            "        if url:",
            "            parts = urlparse(url)",
            "            scheme, netloc, path, params, query, fragment = parts[:6]",
            "",
            "        if isinstance(query, dict):",
            "            sformat = \"dict\"",
            "        else:",
            "            sformat = \"urlencoded\"",
            "",
            "        _req = self._parse_request(request, query, sformat, verify=False)",
            "",
            "        if self.events:",
            "            self.events.store(\"Request\", _req)",
            "",
            "        _req_req: Union[Message, Dict[str, Any]] = {}",
            "        try:",
            "            _request = _req[\"request\"]",
            "        except KeyError:",
            "            try:",
            "                _url = _req[\"request_uri\"]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                _req_req = self.handle_request_uri(",
            "                    _url, verify=False, sender=_req[\"client_id\"]",
            "                )",
            "        else:",
            "            if isinstance(_request, Message):",
            "                _req_req = _request",
            "            else:",
            "                try:",
            "                    _req_req = self.parse_jwt_request(",
            "                        request, txt=_request, verify=False",
            "                    )",
            "                except Exception:",
            "                    _req_req = self._parse_request(",
            "                        request, _request, \"urlencoded\", verify=False",
            "                    )",
            "                else:  # remove JWT attributes",
            "                    for attr in JasonWebToken.c_param:",
            "                        try:",
            "                            del _req_req[attr]",
            "                        except KeyError:",
            "                            pass",
            "",
            "        if isinstance(_req_req, Response):",
            "            return _req_req",
            "",
            "        if _req_req:",
            "            if self.events:",
            "                self.events.store(\"Signed Request\", _req_req)",
            "",
            "            for key, val in _req.items():",
            "                if key in [\"request\", \"request_uri\"]:",
            "                    continue",
            "                if key not in _req_req:",
            "                    _req_req[key] = val",
            "            _req = _req_req",
            "",
            "        if self.events:",
            "            self.events.store(\"Combined Request\", _req)",
            "",
            "        try:",
            "            _req.verify(keyjar=self.keyjar)",
            "        except Exception as err:",
            "            if self.events:",
            "                self.events.store(\"Exception\", err)",
            "            logger.error(err)",
            "            raise",
            "",
            "        return _req",
            "",
            "    def parse_jwt_request(",
            "        self,",
            "        request=AuthorizationRequest,",
            "        txt=\"\",",
            "        keyjar=None,",
            "        verify=True,",
            "        sender=\"\",",
            "        **kwargs,",
            "    ):",
            "        \"\"\"Overridden to use OIC Message type.\"\"\"",
            "        if \"keys\" in kwargs:",
            "            keyjar = kwargs[\"keys\"]",
            "            warnings.warn(",
            "                \"`keys` was renamed to `keyjar`, please update your code.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "        return super().parse_jwt_request(",
            "            request=request, txt=txt, keyjar=keyjar, verify=verify, sender=sender",
            "        )",
            "",
            "    def parse_check_session_request(self, url=None, query=None):",
            "        param = self._parse_urlencoded(url, query)",
            "        assert \"id_token\" in param  # nosec, ignore the rest",
            "        return deser_id_token(self, param[\"id_token\"][0])",
            "",
            "    def parse_check_id_request(self, url=None, query=None):",
            "        param = self._parse_urlencoded(url, query)",
            "        assert \"access_token\" in param  # nosec, ignore the rest",
            "        return deser_id_token(self, param[\"access_token\"][0])",
            "",
            "    def _parse_request(self, request_cls, data, sformat, client_id=None, verify=True):",
            "        if sformat == \"json\":",
            "            request = request_cls().from_json(data)",
            "        elif sformat == \"jwt\":",
            "            request = request_cls().from_jwt(data, keyjar=self.keyjar, sender=client_id)",
            "        elif sformat == \"urlencoded\":",
            "            if \"?\" in data:",
            "                parts = urlparse(data)",
            "                scheme, netloc, path, params, query, fragment = parts[:6]",
            "            else:",
            "                query = data",
            "            request = request_cls().from_urlencoded(query)",
            "        elif sformat == \"dict\":",
            "            request = request_cls(**data)",
            "        else:",
            "            raise ParseError(",
            "                \"Unknown package format: '{}'\".format(sformat), request_cls",
            "            )",
            "",
            "        # get the verification keys",
            "        if client_id:",
            "            keys = self.keyjar.verify_keys(client_id)",
            "            sender = client_id",
            "        else:",
            "            try:",
            "                keys = self.keyjar.verify_keys(request[\"client_id\"])",
            "                sender = request[\"client_id\"]",
            "            except KeyError:",
            "                keys = None",
            "                sender = \"\"",
            "",
            "        logger.debug(\"Found {} verify keys\".format(len(keys or \"\")))",
            "        if verify:",
            "            request.verify(key=keys, keyjar=self.keyjar, sender=sender)",
            "        return request",
            "",
            "    def parse_open_id_request(self, data, sformat=\"urlencoded\", client_id=None):",
            "        return self._parse_request(OpenIDRequest, data, sformat, client_id)",
            "",
            "    def parse_user_info_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(UserInfoRequest, data, sformat)",
            "",
            "    def parse_userinfo_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(UserInfoRequest, data, sformat)",
            "",
            "    def parse_refresh_session_request(self, url=None, query=None):",
            "        if url:",
            "            parts = urlparse(url)",
            "            query = parts.query",
            "        return RefreshSessionRequest().from_urlencoded(query)",
            "",
            "    def parse_registration_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(RegistrationRequest, data, sformat)",
            "",
            "    def parse_end_session_request(self, query, sformat=\"urlencoded\"):",
            "        esr = self._parse_request(EndSessionRequest, query, sformat)",
            "        # if there is a id_token in there it is as a string",
            "        esr[\"id_token\"] = deser_id_token(self, esr[\"id_token\"])",
            "        return esr",
            "",
            "    @staticmethod",
            "    def update_claims(session, where, about, old_claims=None):",
            "        \"\"\"",
            "        Update claims dictionary.",
            "",
            "        :param session:",
            "        :param where: Which request",
            "        :param about: userinfo or id_token",
            "        :param old_claims:",
            "        :return: claims or None",
            "        \"\"\"",
            "        if old_claims is None:",
            "            old_claims = {}",
            "",
            "        req = None",
            "        if where == \"oidreq\":",
            "            try:",
            "                req = OpenIDRequest().deserialize(session[where], \"json\")",
            "            except KeyError:",
            "                pass",
            "        else:  # where == \"authzreq\"",
            "            try:",
            "                req = AuthorizationRequest().deserialize(session[where], \"json\")",
            "            except KeyError:",
            "                pass",
            "",
            "        if req:",
            "            logger.debug(\"%s: %s\" % (where, sanitize(req.to_dict())))",
            "            try:",
            "                _claims = req[\"claims\"][about]",
            "                if _claims:",
            "                    # update with old claims, do not overwrite",
            "                    for key, val in old_claims.items():",
            "                        if key not in _claims:",
            "                            _claims[key] = val",
            "                    return _claims",
            "            except KeyError:",
            "                pass",
            "",
            "        return old_claims",
            "",
            "    def id_token_claims(self, session):",
            "        \"\"\"",
            "        Pick the IdToken claims from the request.",
            "",
            "        :param session: Session information",
            "        :return: The IdToken claims",
            "        \"\"\"",
            "        itc: Dict[str, str] = {}",
            "        itc = self.update_claims(session, \"authzreq\", \"id_token\", itc)",
            "        itc = self.update_claims(session, \"oidreq\", \"id_token\", itc)",
            "        return itc",
            "",
            "    def make_id_token(",
            "        self,",
            "        session,",
            "        loa=\"2\",",
            "        issuer=\"\",",
            "        alg=\"RS256\",",
            "        code=None,",
            "        access_token=None,",
            "        user_info=None,",
            "        auth_time=0,",
            "        exp=None,",
            "        extra_claims=None,",
            "    ):",
            "        \"\"\"",
            "        Create ID Token.",
            "",
            "        :param session: Session information",
            "        :param loa: Level of Assurance/Authentication context",
            "        :param issuer: My identifier",
            "        :param alg: Which signing algorithm to use for the IdToken",
            "        :param code: Access grant",
            "        :param access_token: Access Token",
            "        :param user_info: If user info are to be part of the IdToken",
            "        :return: IDToken instance",
            "        \"\"\"",
            "        # defaults",
            "        if exp is None:",
            "            inawhile = {\"days\": 1}",
            "        else:",
            "            inawhile = exp",
            "        # Handle the idtoken_claims",
            "        extra = {}",
            "        itc = self.id_token_claims(session)",
            "        if itc.keys():",
            "            try:",
            "                inawhile = {\"seconds\": itc[\"max_age\"]}",
            "            except KeyError:",
            "                pass",
            "            for key, val in itc.items():",
            "                if key == \"auth_time\":",
            "                    extra[\"auth_time\"] = auth_time",
            "                elif key == \"acr\":",
            "                    extra[\"acr\"] = verify_acr_level(val, loa)",
            "        else:",
            "            if auth_time:",
            "                extra[\"auth_time\"] = auth_time",
            "            if loa:",
            "                extra[\"acr\"] = loa",
            "",
            "        if not user_info:",
            "            _args: Dict[str, str] = {}",
            "        else:",
            "            try:",
            "                _args = user_info.to_dict()",
            "            except AttributeError:",
            "                _args = user_info",
            "",
            "        # Make sure that there are no name clashes",
            "        for key in [\"iss\", \"sub\", \"aud\", \"exp\", \"acr\", \"nonce\", \"auth_time\"]:",
            "            try:",
            "                del _args[key]",
            "            except KeyError:",
            "                pass",
            "",
            "        halg = \"HS%s\" % alg[-3:]",
            "",
            "        if extra_claims is not None:",
            "            _args.update(extra_claims)",
            "        if code:",
            "            _args[\"c_hash\"] = jws.left_hash(code.encode(\"utf-8\"), halg)",
            "        if access_token:",
            "            _args[\"at_hash\"] = jws.left_hash(access_token.encode(\"utf-8\"), halg)",
            "",
            "        idt = IdToken(",
            "            iss=issuer,",
            "            sub=session[\"sub\"],",
            "            aud=session[\"client_id\"],",
            "            exp=time_util.epoch_in_a_while(**inawhile),",
            "            acr=loa,",
            "            iat=time_util.utc_time_sans_frac(),",
            "            **_args,",
            "        )",
            "",
            "        for key, val in extra.items():",
            "            idt[key] = val",
            "",
            "        if \"nonce\" in session:",
            "            idt[\"nonce\"] = session[\"nonce\"]",
            "",
            "        return idt",
            "",
            "",
            "def scope2claims(scopes, extra_scope_dict=None):",
            "    res: Dict[str, None] = {}",
            "    # Construct the scope translation map",
            "    trans_map: Dict[str, Any] = SCOPE2CLAIMS.copy()",
            "    if extra_scope_dict is not None:",
            "        trans_map.update(extra_scope_dict)",
            "    for scope in scopes:",
            "        try:",
            "            claims = dict([(name, None) for name in trans_map[scope]])",
            "            res.update(claims)",
            "        except KeyError:",
            "            continue",
            "    return res"
        ],
        "afterPatchFile": [
            "import hashlib",
            "import logging",
            "import os",
            "import warnings",
            "from base64 import b64encode",
            "from json import JSONDecodeError",
            "from typing import Any",
            "from typing import Dict",
            "from typing import List",
            "from typing import Optional",
            "from typing import Tuple",
            "from typing import Type",
            "from typing import Union",
            "from typing import cast",
            "from urllib.parse import parse_qs",
            "from urllib.parse import urlparse",
            "",
            "from jwkest import BadSyntax",
            "from jwkest import as_bytes",
            "from jwkest import jwe",
            "from jwkest import jws",
            "from jwkest import jwt",
            "from jwkest.jwe import JWE",
            "from requests import ConnectionError",
            "",
            "from oic import oauth2",
            "from oic import rndstr",
            "from oic.exception import AccessDenied",
            "from oic.exception import AuthnToOld",
            "from oic.exception import AuthzError",
            "from oic.exception import CommunicationError",
            "from oic.exception import MissingParameter",
            "from oic.exception import ParameterError",
            "from oic.exception import PyoidcError",
            "from oic.exception import RegistrationError",
            "from oic.exception import RequestError",
            "from oic.exception import SubMismatch",
            "from oic.oauth2 import HTTP_ARGS",
            "from oic.oauth2 import authz_error",
            "from oic.oauth2.consumer import ConfigurationError",
            "from oic.oauth2.exception import MissingRequiredAttribute",
            "from oic.oauth2.exception import OtherError",
            "from oic.oauth2.exception import ParseError",
            "from oic.oauth2.message import ErrorResponse",
            "from oic.oauth2.message import Message",
            "from oic.oauth2.message import MessageFactory",
            "from oic.oauth2.message import WrongSigningAlgorithm",
            "from oic.oauth2.util import get_or_post",
            "from oic.oic.message import SCOPE2CLAIMS",
            "from oic.oic.message import AccessTokenResponse",
            "from oic.oic.message import AuthorizationErrorResponse",
            "from oic.oic.message import AuthorizationRequest",
            "from oic.oic.message import AuthorizationResponse",
            "from oic.oic.message import Claims",
            "from oic.oic.message import ClaimsRequest",
            "from oic.oic.message import ClientRegistrationErrorResponse",
            "from oic.oic.message import EndSessionRequest",
            "from oic.oic.message import IdToken",
            "from oic.oic.message import JasonWebToken",
            "from oic.oic.message import OIDCMessageFactory",
            "from oic.oic.message import OpenIDRequest",
            "from oic.oic.message import OpenIDSchema",
            "from oic.oic.message import RefreshSessionRequest",
            "from oic.oic.message import RegistrationRequest",
            "from oic.oic.message import RegistrationResponse",
            "from oic.oic.message import TokenErrorResponse",
            "from oic.oic.message import UserInfoErrorResponse",
            "from oic.oic.message import UserInfoRequest",
            "from oic.utils import time_util",
            "from oic.utils.http_util import Response",
            "from oic.utils.keyio import KeyJar",
            "from oic.utils.sanitize import sanitize",
            "from oic.utils.settings import OicClientSettings",
            "from oic.utils.settings import OicServerSettings",
            "from oic.utils.settings import PyoidcSettings",
            "from oic.utils.webfinger import OIC_ISSUER",
            "from oic.utils.webfinger import WebFinger",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "ENDPOINTS = [",
            "    \"authorization_endpoint\",",
            "    \"token_endpoint\",",
            "    \"userinfo_endpoint\",",
            "    \"refresh_session_endpoint\",",
            "    \"end_session_endpoint\",",
            "    \"registration_endpoint\",",
            "    \"check_id_endpoint\",",
            "]",
            "",
            "RESPONSE2ERROR: Dict[str, List] = {",
            "    \"AuthorizationResponse\": [AuthorizationErrorResponse, TokenErrorResponse],",
            "    \"AccessTokenResponse\": [TokenErrorResponse],",
            "    \"IdToken\": [ErrorResponse],",
            "    \"RegistrationResponse\": [ClientRegistrationErrorResponse],",
            "    \"OpenIDSchema\": [UserInfoErrorResponse],",
            "}",
            "",
            "REQUEST2ENDPOINT = {",
            "    \"AuthorizationRequest\": \"authorization_endpoint\",",
            "    \"OpenIDRequest\": \"authorization_endpoint\",",
            "    \"AccessTokenRequest\": \"token_endpoint\",",
            "    \"RefreshAccessTokenRequest\": \"token_endpoint\",",
            "    \"UserInfoRequest\": \"userinfo_endpoint\",",
            "    \"CheckSessionRequest\": \"check_session_endpoint\",",
            "    \"CheckIDRequest\": \"check_id_endpoint\",",
            "    \"EndSessionRequest\": \"end_session_endpoint\",",
            "    \"RefreshSessionRequest\": \"refresh_session_endpoint\",",
            "    \"RegistrationRequest\": \"registration_endpoint\",",
            "    \"RotateSecret\": \"registration_endpoint\",",
            "    # ---",
            "    \"ResourceRequest\": \"resource_endpoint\",",
            "    \"TokenIntrospectionRequest\": \"introspection_endpoint\",",
            "    \"TokenRevocationRequest\": \"revocation_endpoint\",",
            "    \"ROPCAccessTokenRequest\": \"token_endpoint\",",
            "}",
            "",
            "# -----------------------------------------------------------------------------",
            "",
            "JWT_BEARER = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"",
            "SAML2_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:saml2-bearer\"",
            "",
            "# This should probably be part of the configuration",
            "MAX_AUTHENTICATION_AGE = 86400",
            "DEF_SIGN_ALG = {",
            "    \"id_token\": \"RS256\",",
            "    \"openid_request_object\": \"RS256\",",
            "    \"client_secret_jwt\": \"HS256\",",
            "    \"private_key_jwt\": \"RS256\",",
            "}",
            "",
            "# -----------------------------------------------------------------------------",
            "ACR_LISTS = [[\"0\", \"1\", \"2\", \"3\", \"4\"]]",
            "",
            "",
            "def verify_acr_level(req, level):",
            "    if req is None:",
            "        return level",
            "    elif \"values\" in req:",
            "        for _r in req[\"values\"]:",
            "            for alist in ACR_LISTS:",
            "                try:",
            "                    if alist.index(_r) <= alist.index(level):",
            "                        return level",
            "                except ValueError:",
            "                    pass",
            "    else:  # Required or Optional",
            "        return level",
            "",
            "    raise AccessDenied(\"\", req)",
            "",
            "",
            "def deser_id_token(inst, txt=\"\"):",
            "    if not txt:",
            "        return None",
            "    else:",
            "        return IdToken().from_jwt(txt, keyjar=inst.keyjar)",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "def make_openid_request(",
            "    arq,",
            "    keys=None,",
            "    userinfo_claims=None,",
            "    idtoken_claims=None,",
            "    request_object_signing_alg=None,",
            "    **kwargs,",
            "):",
            "    \"\"\"",
            "    Construct the specification of what I want returned.",
            "",
            "    The request will be signed.",
            "",
            "    :param arq: The Authorization request",
            "    :param keys: Keys to use for signing/encrypting",
            "    :param userinfo_claims: UserInfo claims",
            "    :param idtoken_claims: IdToken claims",
            "    :param request_object_signing_alg: Which signing algorithm to use",
            "    :return: JWT encoded OpenID request",
            "    \"\"\"",
            "    oir_args = {}",
            "    for prop in OpenIDRequest.c_param.keys():",
            "        try:",
            "            oir_args[prop] = arq[prop]",
            "        except KeyError:",
            "            pass",
            "",
            "    for attr in [\"scope\", \"response_type\"]:",
            "        if attr in oir_args:",
            "            oir_args[attr] = \" \".join(oir_args[attr])",
            "",
            "    c_args = {}",
            "    if userinfo_claims is not None:",
            "        # UserInfoClaims",
            "        c_args[\"userinfo\"] = Claims(**userinfo_claims)",
            "",
            "    if idtoken_claims is not None:",
            "        # IdTokenClaims",
            "        c_args[\"id_token\"] = Claims(**idtoken_claims)",
            "",
            "    if c_args:",
            "        oir_args[\"claims\"] = ClaimsRequest(**c_args)",
            "",
            "    oir = OpenIDRequest(**oir_args)",
            "",
            "    return oir.to_jwt(key=keys, algorithm=request_object_signing_alg)",
            "",
            "",
            "class Token(oauth2.Token):",
            "    pass",
            "",
            "",
            "class Grant(oauth2.Grant):",
            "    _authz_resp = AuthorizationResponse",
            "    _acc_resp = AccessTokenResponse",
            "    _token_class = Token",
            "",
            "    def add_token(self, resp):",
            "        tok = self._token_class(resp)",
            "        if tok.access_token:",
            "            self.tokens.append(tok)",
            "        else:",
            "            _tmp = getattr(tok, \"id_token\", None)",
            "            if _tmp:",
            "                self.tokens.append(tok)",
            "",
            "",
            "PREFERENCE2PROVIDER = {",
            "    \"request_object_signing_alg\": \"request_object_signing_alg_values_supported\",",
            "    \"request_object_encryption_alg\": \"request_object_encryption_alg_values_supported\",",
            "    \"request_object_encryption_enc\": \"request_object_encryption_enc_values_supported\",",
            "    \"userinfo_signed_response_alg\": \"userinfo_signing_alg_values_supported\",",
            "    \"userinfo_encrypted_response_alg\": \"userinfo_encryption_alg_values_supported\",",
            "    \"userinfo_encrypted_response_enc\": \"userinfo_encryption_enc_values_supported\",",
            "    \"id_token_signed_response_alg\": \"id_token_signing_alg_values_supported\",",
            "    \"id_token_encrypted_response_alg\": \"id_token_encryption_alg_values_supported\",",
            "    \"id_token_encrypted_response_enc\": \"id_token_encryption_enc_values_supported\",",
            "    \"default_acr_values\": \"acr_values_supported\",",
            "    \"subject_type\": \"subject_types_supported\",",
            "    \"token_endpoint_auth_method\": \"token_endpoint_auth_methods_supported\",",
            "    \"token_endpoint_auth_signing_alg\": \"token_endpoint_auth_signing_alg_values_supported\",",
            "    \"response_types\": \"response_types_supported\",",
            "    \"grant_types\": \"grant_types_supported\",",
            "}",
            "",
            "PROVIDER2PREFERENCE = dict([(v, k) for k, v in PREFERENCE2PROVIDER.items()])",
            "",
            "PROVIDER_DEFAULT = {",
            "    \"token_endpoint_auth_method\": \"client_secret_basic\",",
            "    \"id_token_signed_response_alg\": \"RS256\",",
            "}",
            "",
            "PARAMMAP = {",
            "    \"sign\": \"%s_signed_response_alg\",",
            "    \"alg\": \"%s_encrypted_response_alg\",",
            "    \"enc\": \"%s_encrypted_response_enc\",",
            "}",
            "",
            "rt2gt = {",
            "    \"code\": [\"authorization_code\"],",
            "    \"id_token\": [\"implicit\"],",
            "    \"id_token token\": [\"implicit\"],",
            "    \"code id_token\": [\"authorization_code\", \"implicit\"],",
            "    \"code token\": [\"authorization_code\", \"implicit\"],",
            "    \"code id_token token\": [\"authorization_code\", \"implicit\"],",
            "}",
            "",
            "",
            "def response_types_to_grant_types(resp_types, **kwargs):",
            "    _res = set()",
            "",
            "    if \"grant_types\" in kwargs:",
            "        _res.update(set(kwargs[\"grant_types\"]))",
            "",
            "    for response_type in resp_types:",
            "        _rt = response_type.split(\" \")",
            "        _rt.sort()",
            "        try:",
            "            _gt = rt2gt[\" \".join(_rt)]",
            "        except KeyError:",
            "            raise ValueError(\"No such response type combination: {}\".format(resp_types))",
            "        else:",
            "            _res.update(set(_gt))",
            "",
            "    return list(_res)",
            "",
            "",
            "def claims_match(value, claimspec):",
            "    \"\"\"",
            "    Implement matching according to section 5.5.1 of http://openid.net/specs/openid-connect-core-1_0.html.",
            "",
            "    The lack of value is not checked here.",
            "    Also the text doesn't prohibit having both 'value' and 'values'.",
            "",
            "    :param value: single value or list of values",
            "    :param claimspec: None or dictionary with 'essential', 'value' or 'values'",
            "    as key",
            "    :return: Boolean",
            "    \"\"\"",
            "    if claimspec is None:  # match anything",
            "        return True",
            "",
            "    matched = False",
            "    for key, val in claimspec.items():",
            "        if key == \"value\":",
            "            if value == val:",
            "                matched = True",
            "        elif key == \"values\":",
            "            if value in val:",
            "                matched = True",
            "        elif key == \"essential\":",
            "            # Whether it's essential or not doesn't change anything here",
            "            continue",
            "",
            "        if matched:",
            "            break",
            "",
            "    if matched is False:",
            "        if list(claimspec.keys()) == [\"essential\"]:",
            "            return True",
            "",
            "    return matched",
            "",
            "",
            "class Client(oauth2.Client):",
            "    _endpoints = ENDPOINTS",
            "",
            "    def __init__(",
            "        self,",
            "        client_id=None,",
            "        client_prefs=None,",
            "        client_authn_method=None,",
            "        keyjar=None,",
            "        verify_ssl=None,",
            "        config=None,",
            "        client_cert=None,",
            "        requests_dir=\"requests\",",
            "        message_factory: Type[MessageFactory] = OIDCMessageFactory,",
            "        settings: PyoidcSettings = None,",
            "    ):",
            "        \"\"\"",
            "        Initialize the instance.",
            "",
            "        Keyword Args:",
            "            settings",
            "                Instance of :class:`OauthClientSettings` with configuration options.",
            "                Currently used settings are:",
            "                 - verify_ssl",
            "                 - client_cert",
            "                 - timeout",
            "        \"\"\"",
            "        self.settings = settings or OicClientSettings()",
            "        if verify_ssl is not None:",
            "            warnings.warn(",
            "                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.verify_ssl = verify_ssl",
            "        if client_cert is not None:",
            "            warnings.warn(",
            "                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.client_cert = client_cert",
            "        oauth2.Client.__init__(",
            "            self,",
            "            client_id,",
            "            client_authn_method=client_authn_method,",
            "            keyjar=keyjar,",
            "            config=config,",
            "            message_factory=message_factory,",
            "            settings=self.settings,",
            "        )",
            "",
            "        self.file_store = \"./file/\"",
            "        self.file_uri = \"http://localhost/\"",
            "        self.base_url = \"\"",
            "",
            "        # OpenID connect specific endpoints",
            "        for endpoint in ENDPOINTS:",
            "            setattr(self, endpoint, \"\")",
            "",
            "        self.id_token: Dict[str, Token] = {}",
            "        self.log = None",
            "",
            "        self.request2endpoint = REQUEST2ENDPOINT",
            "        self.response2error = RESPONSE2ERROR",
            "",
            "        self.grant_class = Grant",
            "        self.token_class = Token",
            "        self.provider_info = Message()",
            "        self.registration_response: RegistrationResponse = RegistrationResponse()",
            "        self.client_prefs = client_prefs or {}",
            "",
            "        self.behaviour: Dict[str, Any] = {}",
            "        self.scope = [\"openid\"]",
            "",
            "        self.wf = WebFinger(OIC_ISSUER)",
            "        self.wf.httpd = self",
            "        self.allow = {}",
            "        self.post_logout_redirect_uris: List[str] = []",
            "        self.registration_expires = 0",
            "        self.registration_access_token = None",
            "        self.id_token_max_age = 0",
            "",
            "        # Default key by kid for different key types",
            "        # For instance {'sig': {\"RSA\":\"abc\"}}",
            "        self.kid = {\"sig\": {}, \"enc\": {}}",
            "        self.requests_dir = requests_dir",
            "",
            "    def _get_id_token(self, **kwargs):",
            "        try:",
            "            return kwargs[\"id_token\"]",
            "        except KeyError:",
            "            grant = self.get_grant(**kwargs)",
            "",
            "        if grant:",
            "            try:",
            "                _scope = kwargs[\"scope\"]",
            "            except KeyError:",
            "                _scope = None",
            "",
            "            for token in grant.tokens:",
            "                if token.scope and _scope:",
            "                    flag = True",
            "                    for item in _scope:",
            "                        if item not in token.scope:",
            "                            flag = False",
            "                            break",
            "                    if not flag:",
            "                        break",
            "                if token.id_token:",
            "                    return token.id_token.jwt",
            "",
            "        return None",
            "",
            "    def request_object_encryption(self, msg, **kwargs):",
            "        try:",
            "            encalg = kwargs[\"request_object_encryption_alg\"]",
            "        except KeyError:",
            "            try:",
            "                encalg = self.behaviour[\"request_object_encryption_alg\"]",
            "            except KeyError:",
            "                return msg",
            "",
            "        try:",
            "            encenc = kwargs[\"request_object_encryption_enc\"]",
            "        except KeyError:",
            "            try:",
            "                encenc = self.behaviour[\"request_object_encryption_enc\"]",
            "            except KeyError:",
            "                raise MissingRequiredAttribute(",
            "                    \"No request_object_encryption_enc specified\"",
            "                )",
            "",
            "        _jwe = JWE(msg, alg=encalg, enc=encenc)",
            "        _kty = jwe.alg2keytype(encalg)",
            "",
            "        try:",
            "            _kid = kwargs[\"enc_kid\"]",
            "        except KeyError:",
            "            _kid = \"\"",
            "",
            "        if \"target\" not in kwargs:",
            "            raise MissingRequiredAttribute(\"No target specified\")",
            "",
            "        if _kid:",
            "            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"], kid=_kid)",
            "            _jwe[\"kid\"] = _kid",
            "        else:",
            "            _keys = self.keyjar.get_encrypt_key(_kty, owner=kwargs[\"target\"])",
            "",
            "        return _jwe.encrypt(_keys)",
            "",
            "    @staticmethod",
            "    def construct_redirect_uri(**kwargs):",
            "        _filedir = kwargs[\"local_dir\"]",
            "        if not os.path.isdir(_filedir):",
            "            os.makedirs(_filedir)",
            "        _webpath = kwargs[\"base_path\"]",
            "        _name = rndstr(10) + \".jwt\"",
            "        filename = os.path.join(_filedir, _name)",
            "        while os.path.exists(filename):",
            "            _name = rndstr(10)",
            "            filename = os.path.join(_filedir, _name)",
            "        _webname = \"%s%s\" % (_webpath, _name)",
            "        return filename, _webname",
            "",
            "    def filename_from_webname(self, webname):",
            "        _filedir = self.requests_dir",
            "        if not os.path.isdir(_filedir):",
            "            os.makedirs(_filedir)",
            "",
            "        if webname.startswith(self.base_url):",
            "            return webname[len(self.base_url) :]",
            "        else:",
            "            raise ValueError(\"Invalid webname, must start with base_url\")",
            "",
            "    def construct_AuthorizationRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request_args is not None:",
            "            if \"nonce\" not in request_args:",
            "                _rt = request_args[\"response_type\"]",
            "                if \"token\" in _rt or \"id_token\" in _rt:",
            "                    request_args[\"nonce\"] = rndstr(32)",
            "        elif \"response_type\" in kwargs:",
            "            if \"token\" in kwargs[\"response_type\"]:",
            "                request_args = {\"nonce\": rndstr(32)}",
            "        else:  # Never wrong to specify a nonce",
            "            request_args = {\"nonce\": rndstr(32)}",
            "",
            "        request_param = kwargs.get(\"request_param\")",
            "        if \"request_method\" in kwargs:",
            "            if kwargs[\"request_method\"] == \"file\":",
            "                request_param = \"request_uri\"",
            "            else:",
            "                request_param = \"request\"",
            "            del kwargs[\"request_method\"]",
            "",
            "        areq = super().construct_AuthorizationRequest(",
            "            request=request, request_args=request_args, extra_args=extra_args, **kwargs",
            "        )",
            "",
            "        if request_param:",
            "            alg = None",
            "            for arg in [\"request_object_signing_alg\", \"algorithm\"]:",
            "                try:  # Trumps everything",
            "                    alg = kwargs[arg]",
            "                except KeyError:",
            "                    pass",
            "                else:",
            "                    break",
            "",
            "            if not alg:",
            "                try:",
            "                    alg = self.behaviour[\"request_object_signing_alg\"]",
            "                except KeyError:",
            "                    alg = \"none\"",
            "",
            "            kwargs[\"request_object_signing_alg\"] = alg",
            "",
            "            if \"keys\" not in kwargs and alg and alg != \"none\":",
            "                _kty = jws.alg2keytype(alg)",
            "                try:",
            "                    _kid = kwargs[\"sig_kid\"]",
            "                except KeyError:",
            "                    _kid = self.kid[\"sig\"].get(_kty, None)",
            "",
            "                kwargs[\"keys\"] = self.keyjar.get_signing_key(_kty, kid=_kid)",
            "",
            "            _req = make_openid_request(areq, **kwargs)",
            "",
            "            # Should the request be encrypted",
            "            _req = self.request_object_encryption(_req, **kwargs)",
            "",
            "            if request_param == \"request\":",
            "                areq[\"request\"] = _req",
            "            else:",
            "                try:",
            "                    _webname = self.registration_response[\"request_uris\"][0]",
            "                    filename = self.filename_from_webname(_webname)",
            "                except KeyError:",
            "                    filename, _webname = self.construct_redirect_uri(**kwargs)",
            "                with open(filename, mode=\"w\") as fid:",
            "                    fid.write(_req)",
            "                areq[\"request_uri\"] = _webname",
            "",
            "        return areq",
            "",
            "    def construct_UserInfoRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"userinfo_endpoint\")",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        if \"access_token\" in request_args:",
            "            pass",
            "        else:",
            "            if \"scope\" not in kwargs:",
            "                kwargs[\"scope\"] = \"openid\"",
            "            token = self.get_token(**kwargs)",
            "            if token is None:",
            "                raise MissingParameter(\"No valid token available\")",
            "",
            "            request_args[\"access_token\"] = token.access_token",
            "",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_RegistrationRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"registration_endpoint\")",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_RefreshSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"refreshsession_endpoint\")",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def _id_token_based(self, request, request_args=None, extra_args=None, **kwargs):",
            "",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        try:",
            "            _prop = kwargs[\"prop\"]",
            "        except KeyError:",
            "            _prop = \"id_token\"",
            "",
            "        if _prop in request_args:",
            "            pass",
            "        else:",
            "            raw_id_token = self._get_id_token(**kwargs)",
            "            if raw_id_token is None:",
            "                raise MissingParameter(\"No valid id token available\")",
            "",
            "            request_args[_prop] = raw_id_token",
            "",
            "        return self.construct_request(request, request_args, extra_args)",
            "",
            "    def construct_CheckSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"checksession_endpoint\")",
            "",
            "        return self._id_token_based(request, request_args, extra_args, **kwargs)",
            "",
            "    def construct_CheckIDRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"checkid_endpoint\")",
            "        # access_token is where the id_token will be placed",
            "        return self._id_token_based(",
            "            request, request_args, extra_args, prop=\"access_token\", **kwargs",
            "        )",
            "",
            "    def construct_EndSessionRequest(",
            "        self, request=None, request_args=None, extra_args=None, **kwargs",
            "    ):",
            "",
            "        if request is None:",
            "            request = self.message_factory.get_request_type(\"endsession_endpoint\")",
            "        if request_args is None:",
            "            request_args = {}",
            "",
            "        if \"state\" in request_args and \"state\" not in kwargs:",
            "            kwargs[\"state\"] = request_args[\"state\"]",
            "",
            "        return self._id_token_based(request, request_args, extra_args, **kwargs)",
            "",
            "    def do_authorization_request(",
            "        self,",
            "        state=\"\",",
            "        body_type=\"\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "        **kwargs,",
            "    ):",
            "        algs = self.sign_enc_algs(\"id_token\")",
            "",
            "        if \"code_challenge\" in self.config:",
            "            _args, code_verifier = self.add_code_challenge()",
            "            request_args.update(_args)",
            "",
            "        return super().do_authorization_request(",
            "            state=state,",
            "            body_type=body_type,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            http_args=http_args,",
            "            algs=algs,",
            "        )",
            "",
            "    def do_access_token_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"POST\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "        authn_method=\"client_secret_basic\",",
            "        **kwargs,",
            "    ):",
            "        atr = super().do_access_token_request(",
            "            scope=scope,",
            "            state=state,",
            "            body_type=body_type,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            http_args=http_args,",
            "            authn_method=authn_method,",
            "            **kwargs,",
            "        )",
            "        try:",
            "            _idt = atr[\"id_token\"]",
            "        except KeyError:",
            "            pass",
            "        else:",
            "            try:",
            "                if self.state2nonce[state] != _idt[\"nonce\"]:",
            "                    raise ParameterError('Someone has messed with \"nonce\"')",
            "            except KeyError:",
            "                pass",
            "        return atr",
            "",
            "    def do_registration_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"POST\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"registration_endpoint\")",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        response_cls = self.message_factory.get_response_type(\"registration_endpoint\")",
            "        response = self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "        return response",
            "",
            "    def do_check_session_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "",
            "        request = self.message_factory.get_request_type(\"checksession_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"checksession_endpoint\")",
            "",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def do_check_id_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"json\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"checkid_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"checkid_endpoint\")",
            "",
            "        url, body, ht_args, csi = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def do_end_session_request(",
            "        self,",
            "        scope=\"\",",
            "        state=\"\",",
            "        body_type=\"\",",
            "        method=\"GET\",",
            "        request_args=None,",
            "        extra_args=None,",
            "        http_args=None,",
            "    ):",
            "        request = self.message_factory.get_request_type(\"endsession_endpoint\")",
            "        response_cls = self.message_factory.get_response_type(\"endsession_endpoint\")",
            "        url, body, ht_args, _ = self.request_info(",
            "            request,",
            "            method=method,",
            "            request_args=request_args,",
            "            extra_args=extra_args,",
            "            scope=scope,",
            "            state=state,",
            "        )",
            "",
            "        if http_args is None:",
            "            http_args = ht_args",
            "        else:",
            "            http_args.update(http_args)",
            "",
            "        return self.request_and_return(",
            "            url, response_cls, method, body, body_type, state=state, http_args=http_args",
            "        )",
            "",
            "    def user_info_request(self, method=\"GET\", state=\"\", scope=\"\", **kwargs):",
            "        uir = self.message_factory.get_request_type(\"userinfo_endpoint\")()",
            "        logger.debug(\"[user_info_request]: kwargs:%s\" % (sanitize(kwargs),))",
            "        token: Optional[Token] = None",
            "        if \"token\" in kwargs:",
            "            if kwargs[\"token\"]:",
            "                uir[\"access_token\"] = kwargs[\"token\"]",
            "                token = Token()",
            "                token.token_type = \"Bearer\"",
            "                token.access_token = kwargs[\"token\"]",
            "                kwargs[\"behavior\"] = \"use_authorization_header\"",
            "            else:",
            "                # What to do ? Need a callback",
            "                pass",
            "        elif \"access_token\" in kwargs and kwargs[\"access_token\"]:",
            "            uir[\"access_token\"] = kwargs[\"access_token\"]",
            "            del kwargs[\"access_token\"]",
            "        elif state:",
            "            token = self.grant[state].get_token(scope)",
            "            if token is None:",
            "                raise AccessDenied(\"invalid_token\")",
            "            if token.is_valid():",
            "                uir[\"access_token\"] = token.access_token",
            "                if (",
            "                    token.token_type",
            "                    and token.token_type.lower() == \"bearer\"",
            "                    and method == \"GET\"",
            "                ):",
            "                    kwargs[\"behavior\"] = \"use_authorization_header\"",
            "            else:",
            "                # raise oauth2.OldAccessToken",
            "                if self.log:",
            "                    self.log.info(\"do access token refresh\")",
            "                try:",
            "                    self.do_access_token_refresh(token=token, state=state)",
            "                    token = cast(Token, self.grant[state].get_token(scope))",
            "                    uir[\"access_token\"] = token.access_token",
            "                except Exception:",
            "                    raise",
            "",
            "        uri = self._endpoint(\"userinfo_endpoint\", **kwargs)",
            "        # If access token is a bearer token it might be sent in the",
            "        # authorization header",
            "        # 4 ways of sending the access_token:",
            "        # - POST with token in authorization header",
            "        # - POST with token in message body",
            "        # - GET with token in authorization header",
            "        # - GET with token as query parameter",
            "        if \"behavior\" in kwargs:",
            "            _behav = kwargs[\"behavior\"]",
            "            _token = uir[\"access_token\"]",
            "            _ttype = \"\"",
            "            try:",
            "                _ttype = kwargs[\"token_type\"]",
            "            except KeyError:",
            "                if token:",
            "                    try:",
            "                        _ttype = cast(str, token.token_type)",
            "                    except AttributeError:",
            "                        raise MissingParameter(\"Unspecified token type\")",
            "",
            "            if \"as_query_parameter\" == _behav:",
            "                method = \"GET\"",
            "            elif token:",
            "                # use_authorization_header, token_in_message_body",
            "                if \"use_authorization_header\" in _behav:",
            "                    token_header = \"{type} {token}\".format(",
            "                        type=_ttype.capitalize(), token=_token",
            "                    )",
            "                    if \"headers\" in kwargs:",
            "                        kwargs[\"headers\"].update({\"Authorization\": token_header})",
            "                    else:",
            "                        kwargs[\"headers\"] = {\"Authorization\": token_header}",
            "",
            "                if \"token_in_message_body\" not in _behav:",
            "                    # remove the token from the request",
            "                    del uir[\"access_token\"]",
            "",
            "        path, body, kwargs = get_or_post(uri, method, uir, **kwargs)",
            "",
            "        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])",
            "",
            "        return path, body, method, h_args",
            "",
            "    def do_user_info_request(",
            "        self, method=\"POST\", state=\"\", scope=\"openid\", request=\"openid\", **kwargs",
            "    ):",
            "",
            "        kwargs[\"request\"] = request",
            "        path, body, method, h_args = self.user_info_request(",
            "            method, state, scope, **kwargs",
            "        )",
            "",
            "        logger.debug(",
            "            \"[do_user_info_request] PATH:%s BODY:%s H_ARGS: %s\"",
            "            % (sanitize(path), sanitize(body), sanitize(h_args))",
            "        )",
            "",
            "        if self.events:",
            "            self.events.store(\"Request\", {\"body\": body})",
            "            self.events.store(\"request_url\", path)",
            "            self.events.store(\"request_http_args\", h_args)",
            "",
            "        try:",
            "            resp = self.http_request(path, method, data=body, **h_args)",
            "        except oauth2.exception.MissingRequiredAttribute:",
            "            raise",
            "",
            "        if resp.status_code == 200:",
            "            if \"application/json\" in resp.headers[\"content-type\"]:",
            "                sformat = \"json\"",
            "            elif \"application/jwt\" in resp.headers[\"content-type\"]:",
            "                sformat = \"jwt\"",
            "            else:",
            "                raise PyoidcError(",
            "                    \"ERROR: Unexpected content-type: %s\" % resp.headers[\"content-type\"]",
            "                )",
            "        elif resp.status_code == 500:",
            "            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)",
            "        elif resp.status_code == 405:",
            "            # Method not allowed error",
            "            allowed_methods = [x.strip() for x in resp.headers[\"allow\"].split(\",\")]",
            "            raise CommunicationError(",
            "                \"Server responded with HTTP Error Code 405\", \"\", allowed_methods",
            "            )",
            "        elif 400 <= resp.status_code < 500:",
            "            # the response text might be a OIDC message",
            "            try:",
            "                res = ErrorResponse().from_json(resp.text)",
            "            except Exception:",
            "                raise RequestError(resp.text)",
            "            else:",
            "                self.store_response(res, resp.text)",
            "                return res",
            "        else:",
            "            raise PyoidcError(",
            "                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)",
            "            )",
            "",
            "        try:",
            "            _schema = kwargs[\"user_info_schema\"]",
            "        except KeyError:",
            "            _schema = OpenIDSchema",
            "",
            "        logger.debug(\"Reponse text: '%s'\" % sanitize(resp.text))",
            "",
            "        _txt = resp.text",
            "        if sformat == \"json\":",
            "            res = _schema().from_json(txt=_txt)",
            "        else:",
            "            verify = kwargs.get(\"verify\", True)",
            "            res = _schema().from_jwt(",
            "                _txt,",
            "                keyjar=self.keyjar,",
            "                sender=self.provider_info[\"issuer\"],",
            "                verify=verify,",
            "            )",
            "",
            "        if \"error\" in res:  # Error response",
            "            res = UserInfoErrorResponse(**res.to_dict())",
            "",
            "        if state:",
            "            # Verify userinfo sub claim against what's returned in the ID Token",
            "            idt = self.grant[state].get_id_token()",
            "            if idt:",
            "                if idt[\"sub\"] != res[\"sub\"]:",
            "                    raise SubMismatch(",
            "                        \"Sub identifier not the same in userinfo and Id Token\"",
            "                    )",
            "",
            "        self.store_response(res, _txt)",
            "",
            "        return res",
            "",
            "    def get_userinfo_claims(",
            "        self, access_token, endpoint, method=\"POST\", schema_class=OpenIDSchema, **kwargs",
            "    ):",
            "",
            "        uir = UserInfoRequest(access_token=access_token)",
            "",
            "        h_args = dict([(k, v) for k, v in kwargs.items() if k in HTTP_ARGS])",
            "",
            "        if \"authn_method\" in kwargs:",
            "            http_args = self.init_authentication_method(**kwargs)",
            "        else:",
            "            # If nothing defined this is the default",
            "            http_args = self.init_authentication_method(uir, \"bearer_header\", **kwargs)",
            "",
            "        h_args.update(http_args)",
            "        path, body, kwargs = get_or_post(endpoint, method, uir, **kwargs)",
            "",
            "        try:",
            "            resp = self.http_request(path, method, data=body, **h_args)",
            "        except MissingRequiredAttribute:",
            "            raise",
            "",
            "        if resp.status_code == 200:",
            "            # FIXME: Could this also encounter application/jwt for encrypted userinfo",
            "            #        the do_userinfo_request method already handles it",
            "            if \"application/json\" not in resp.headers[\"content-type\"]:",
            "                raise PyoidcError(",
            "                    \"ERROR: content-type in response unexpected: %s\"",
            "                    % resp.headers[\"content-type\"]",
            "                )",
            "        elif resp.status_code == 500:",
            "            raise PyoidcError(\"ERROR: Something went wrong: %s\" % resp.text)",
            "        else:",
            "            raise PyoidcError(",
            "                \"ERROR: Something went wrong [%s]: %s\" % (resp.status_code, resp.text)",
            "            )",
            "",
            "        res = schema_class().from_json(txt=resp.text)",
            "        self.store_response(res, resp.text)",
            "        return res",
            "",
            "    def unpack_aggregated_claims(self, userinfo):",
            "        if userinfo[\"_claim_sources\"]:",
            "            for csrc, spec in userinfo[\"_claim_sources\"].items():",
            "                if \"JWT\" in spec:",
            "                    aggregated_claims = Message().from_jwt(",
            "                        spec[\"JWT\"].encode(\"utf-8\"), keyjar=self.keyjar, sender=csrc",
            "                    )",
            "                    claims = [",
            "                        value",
            "                        for value, src in userinfo[\"_claim_names\"].items()",
            "                        if src == csrc",
            "                    ]",
            "",
            "                    if set(claims) != set(list(aggregated_claims.keys())):",
            "                        logger.warning(",
            "                            \"Claims from claim source doesn't match what's in \"",
            "                            \"the userinfo\"",
            "                        )",
            "",
            "                    for key, vals in aggregated_claims.items():",
            "                        userinfo[key] = vals",
            "",
            "        return userinfo",
            "",
            "    def fetch_distributed_claims(self, userinfo, callback=None):",
            "        for csrc, spec in userinfo[\"_claim_sources\"].items():",
            "            if \"endpoint\" in spec:",
            "                if not spec[\"endpoint\"].startswith(\"https://\"):",
            "                    logger.warning(",
            "                        \"Fetching distributed claims from an untrusted source: %s\",",
            "                        spec[\"endpoint\"],",
            "                    )",
            "                if \"access_token\" in spec:",
            "                    _uinfo = self.do_user_info_request(",
            "                        method=\"GET\",",
            "                        token=spec[\"access_token\"],",
            "                        userinfo_endpoint=spec[\"endpoint\"],",
            "                        verify=False,",
            "                    )",
            "                else:",
            "                    if callback:",
            "                        _uinfo = self.do_user_info_request(",
            "                            method=\"GET\",",
            "                            token=callback(spec[\"endpoint\"]),",
            "                            userinfo_endpoint=spec[\"endpoint\"],",
            "                            verify=False,",
            "                        )",
            "                    else:",
            "                        _uinfo = self.do_user_info_request(",
            "                            method=\"GET\",",
            "                            userinfo_endpoint=spec[\"endpoint\"],",
            "                            verify=False,",
            "                        )",
            "",
            "                claims = [",
            "                    value",
            "                    for value, src in userinfo[\"_claim_names\"].items()",
            "                    if src == csrc",
            "                ]",
            "",
            "                if set(claims) != set(list(_uinfo.keys())):",
            "                    logger.warning(",
            "                        \"Claims from claim source doesn't match what's in \"",
            "                        \"the userinfo\"",
            "                    )",
            "",
            "                for key, vals in _uinfo.items():",
            "                    userinfo[key] = vals",
            "",
            "        # Remove the `_claim_sources` and `_claim_names` from userinfo and better be safe than sorry",
            "        if \"_claim_sources\" in userinfo:",
            "            del userinfo[\"_claim_sources\"]",
            "        if \"_claim_names\" in userinfo:",
            "            del userinfo[\"_claim_names\"]",
            "        return userinfo",
            "",
            "    def verify_alg_support(self, alg, usage, other):",
            "        \"\"\"",
            "        Verify that the algorithm to be used are supported by the other side.",
            "",
            "        :param alg: The algorithm specification",
            "        :param usage: In which context the 'alg' will be used.",
            "            The following values are supported:",
            "            - userinfo",
            "            - id_token",
            "            - request_object",
            "            - token_endpoint_auth",
            "        :param other: The identifier for the other side",
            "        :return: True or False",
            "        \"\"\"",
            "        try:",
            "            _pcr = self.provider_info",
            "            supported = _pcr[\"%s_algs_supported\" % usage]",
            "        except KeyError:",
            "            try:",
            "                supported = getattr(self, \"%s_algs_supported\" % usage)",
            "            except AttributeError:",
            "                supported = None",
            "",
            "        if supported is None:",
            "            return True",
            "        else:",
            "            if alg in supported:",
            "                return True",
            "            else:",
            "                return False",
            "",
            "    def match_preferences(self, pcr=None, issuer=None):",
            "        \"\"\"",
            "        Match the clients preferences against what the provider can do.",
            "",
            "        :param pcr: Provider configuration response if available",
            "        :param issuer: The issuer identifier",
            "        \"\"\"",
            "        if not pcr:",
            "            pcr = self.provider_info",
            "",
            "        regreq = self.message_factory.get_request_type(\"registration_endpoint\")",
            "",
            "        for _pref, _prov in PREFERENCE2PROVIDER.items():",
            "            try:",
            "                vals = self.client_prefs[_pref]",
            "            except KeyError:",
            "                continue",
            "",
            "            try:",
            "                _pvals = pcr[_prov]",
            "            except KeyError:",
            "                try:",
            "                    self.behaviour[_pref] = PROVIDER_DEFAULT[_pref]",
            "                except KeyError:",
            "                    if isinstance(pcr.c_param[_prov][0], list):",
            "                        self.behaviour[_pref] = []",
            "                    else:",
            "                        self.behaviour[_pref] = None",
            "                continue",
            "",
            "            if isinstance(vals, str):",
            "                if vals in _pvals:",
            "                    self.behaviour[_pref] = vals",
            "            else:",
            "                vtyp = regreq.c_param[_pref]",
            "",
            "                if isinstance(vtyp[0], list):",
            "                    self.behaviour[_pref] = []",
            "                    for val in vals:",
            "                        if val in _pvals:",
            "                            self.behaviour[_pref].append(val)",
            "                else:",
            "                    for val in vals:",
            "                        if val in _pvals:",
            "                            self.behaviour[_pref] = val",
            "                            break",
            "",
            "            if _pref not in self.behaviour:",
            "                raise ConfigurationError(\"OP couldn't match preference:%s\" % _pref, pcr)",
            "",
            "        for key, val in self.client_prefs.items():",
            "            if key in self.behaviour:",
            "                continue",
            "",
            "            try:",
            "                vtyp = regreq.c_param[key]",
            "                if isinstance(vtyp[0], list):",
            "                    pass",
            "                elif isinstance(val, list) and not isinstance(val, str):",
            "                    val = val[0]",
            "            except KeyError:",
            "                pass",
            "            if key not in PREFERENCE2PROVIDER:",
            "                self.behaviour[key] = val",
            "",
            "    def store_registration_info(self, reginfo):",
            "        self.registration_response = reginfo",
            "        if \"token_endpoint_auth_method\" not in self.registration_response:",
            "            self.registration_response[",
            "                \"token_endpoint_auth_method\"  # nosec",
            "            ] = \"client_secret_basic\"",
            "        self.client_id = reginfo[\"client_id\"]",
            "        try:",
            "            self.client_secret = reginfo[\"client_secret\"]",
            "        except KeyError:  # Not required",
            "            pass",
            "        else:",
            "            try:",
            "                self.registration_expires = reginfo[\"client_secret_expires_at\"]",
            "            except KeyError:",
            "                pass",
            "        try:",
            "            self.registration_access_token = reginfo[\"registration_access_token\"]",
            "        except KeyError:",
            "            pass",
            "",
            "    def handle_registration_info(self, response):",
            "        err_msg = \"Got error response: {}\"",
            "        unk_msg = \"Unknown response: {}\"",
            "        if response.status_code in [200, 201]:",
            "            resp = self.message_factory.get_response_type(",
            "                \"registration_endpoint\"",
            "            )().deserialize(response.text, \"json\")",
            "            # Some implementations sends back a 200 with an error message inside",
            "            try:",
            "                resp.verify()",
            "            except oauth2.message.MissingRequiredAttribute as err:",
            "                logger.error(err)",
            "                raise RegistrationError(err)",
            "            except Exception:",
            "                resp = ErrorResponse().deserialize(response.text, \"json\")",
            "                if resp.verify():",
            "                    logger.error(err_msg.format(sanitize(resp.to_json())))",
            "                    if self.events:",
            "                        self.events.store(\"protocol response\", resp)",
            "                    raise RegistrationError(resp.to_dict())",
            "                else:  # Something else",
            "                    logger.error(unk_msg.format(sanitize(response.text)))",
            "                    raise RegistrationError(response.text)",
            "            else:",
            "                # got a proper registration response",
            "                self.store_response(resp, response.text)",
            "                self.store_registration_info(resp)",
            "        elif 400 <= response.status_code <= 499:",
            "            try:",
            "                resp = ErrorResponse().deserialize(response.text, \"json\")",
            "            except JSONDecodeError:",
            "                logger.error(unk_msg.format(sanitize(response.text)))",
            "                raise RegistrationError(response.text)",
            "",
            "            if resp.verify():",
            "                logger.error(err_msg.format(sanitize(resp.to_json())))",
            "                if self.events:",
            "                    self.events.store(\"protocol response\", resp)",
            "                raise RegistrationError(resp.to_dict())",
            "            else:  # Something else",
            "                logger.error(unk_msg.format(sanitize(response.text)))",
            "                raise RegistrationError(response.text)",
            "        else:",
            "            raise RegistrationError(response.text)",
            "",
            "        return resp",
            "",
            "    def registration_read(self, url=\"\", registration_access_token=None):",
            "        \"\"\"",
            "        Read the client registration info from the given url.",
            "",
            "        :raises RegistrationError: If an error happend",
            "        :return: RegistrationResponse",
            "        \"\"\"",
            "        if not url:",
            "            url = self.registration_response[\"registration_client_uri\"]",
            "",
            "        if not registration_access_token:",
            "            registration_access_token = self.registration_access_token",
            "",
            "        headers = {\"Authorization\": \"Bearer %s\" % registration_access_token}",
            "        rsp = self.http_request(url, \"GET\", headers=headers)",
            "",
            "        return self.handle_registration_info(rsp)",
            "",
            "    def generate_request_uris(self, request_dir):",
            "        \"\"\"",
            "        Need to generate a path that is unique for the OP combo.",
            "",
            "        :return: A list of uris",
            "        \"\"\"",
            "        m = hashlib.sha256()",
            "        m.update(as_bytes(self.provider_info[\"issuer\"]))",
            "        m.update(as_bytes(self.base_url))",
            "        return \"{}{}/{}\".format(self.base_url, request_dir, m.hexdigest())",
            "",
            "    def create_registration_request(self, **kwargs):",
            "        \"\"\"",
            "        Create a registration request.",
            "",
            "        :param kwargs: parameters to the registration request",
            "        :return:",
            "        \"\"\"",
            "        req = self.message_factory.get_request_type(\"registration_endpoint\")()",
            "",
            "        for prop in req.parameters():",
            "            try:",
            "                req[prop] = kwargs[prop]",
            "            except KeyError:",
            "                try:",
            "                    req[prop] = self.behaviour[prop]",
            "                except KeyError:",
            "                    pass",
            "",
            "        if \"post_logout_redirect_uris\" not in req:",
            "            try:",
            "                req[\"post_logout_redirect_uris\"] = self.post_logout_redirect_uris",
            "            except AttributeError:",
            "                pass",
            "",
            "        if \"redirect_uris\" not in req:",
            "            try:",
            "                req[\"redirect_uris\"] = self.redirect_uris",
            "            except AttributeError:",
            "                raise MissingRequiredAttribute(\"redirect_uris\", req)",
            "",
            "        try:",
            "            if self.provider_info[\"require_request_uri_registration\"] is True:",
            "                req[\"request_uris\"] = self.generate_request_uris(self.requests_dir)",
            "        except KeyError:",
            "            pass",
            "",
            "        if \"response_types\" in req:",
            "            req[\"grant_types\"] = response_types_to_grant_types(",
            "                req[\"response_types\"], **kwargs",
            "            )",
            "",
            "        return req",
            "",
            "    def register(self, url, registration_token=None, **kwargs):",
            "        \"\"\"",
            "        Register the client at an OP.",
            "",
            "        :param url: The OPs registration endpoint",
            "        :param registration_token: Initial Access Token for registration endpoint",
            "        :param kwargs: parameters to the registration request",
            "        :return:",
            "        \"\"\"",
            "        req = self.create_registration_request(**kwargs)",
            "",
            "        logger.debug(\"[registration_request]: kwargs:%s\" % (sanitize(kwargs),))",
            "",
            "        if self.events:",
            "            self.events.store(\"Protocol request\", req)",
            "",
            "        headers = {\"content-type\": \"application/json\"}",
            "        if registration_token is not None:",
            "            try:",
            "                token = jwt.JWT()",
            "                token.unpack(registration_token)",
            "            except BadSyntax:",
            "                # no JWT",
            "                registration_token = b64encode(registration_token.encode()).decode()",
            "            finally:",
            "                headers[\"Authorization\"] = \"Bearer \" + registration_token",
            "",
            "        rsp = self.http_request(url, \"POST\", data=req.to_json(), headers=headers)",
            "",
            "        return self.handle_registration_info(rsp)",
            "",
            "    def normalization(self, principal, idtype=\"mail\"):",
            "        if idtype == \"mail\":",
            "            (_, domain) = principal.split(\"@\")",
            "            subject = \"acct:%s\" % principal",
            "        elif idtype == \"url\":",
            "            p = urlparse(principal)",
            "            domain = p.netloc",
            "            subject = principal",
            "        else:",
            "            domain = \"\"",
            "            subject = principal",
            "",
            "        return subject, domain",
            "",
            "    def discover(self, principal, host=None):",
            "        return self.wf.discovery_query(principal, host=host)",
            "",
            "    def sign_enc_algs(self, typ):",
            "        resp = {}",
            "        for key, val in PARAMMAP.items():",
            "            try:",
            "                resp[key] = self.registration_response[val % typ]",
            "            except (TypeError, KeyError):",
            "                if key == \"sign\":",
            "                    resp[key] = DEF_SIGN_ALG[\"id_token\"]",
            "        return resp",
            "",
            "    def _verify_id_token(",
            "        self,",
            "        id_token,",
            "        nonce=\"\",",
            "        acr_values=None,",
            "        auth_time=0,",
            "        max_age=0,",
            "        response_type=\"\",",
            "    ):",
            "        \"\"\"",
            "        Verify IdToken.",
            "",
            "        If the JWT alg Header Parameter uses a MAC based algorithm such as",
            "        HS256, HS384, or HS512, the octets of the UTF-8 representation of the",
            "        client_secret corresponding to the client_id contained in the aud",
            "        (audience) Claim are used as the key to validate the signature. For MAC",
            "        based algorithms, the behavior is unspecified if the aud is",
            "        multi-valued or if an azp value is present that is different than the",
            "        aud value.",
            "",
            "        :param id_token: The ID Token tp check",
            "        :param nonce: The nonce specified in the authorization request",
            "        :param acr_values: Asked for acr values",
            "        :param auth_time: An auth_time claim",
            "        :param max_age: Max age of authentication",
            "        \"\"\"",
            "        if self.provider_info[\"issuer\"] != id_token[\"iss\"]:",
            "            raise OtherError(\"issuer != iss\")",
            "",
            "        if self.client_id not in id_token[\"aud\"]:",
            "            raise OtherError(\"not intended for me\")",
            "        if len(id_token[\"aud\"]) > 1:",
            "            if \"azp\" not in id_token or id_token[\"azp\"] != self.client_id:",
            "                raise OtherError(\"not intended for me\")",
            "",
            "        _now = time_util.utc_time_sans_frac()",
            "",
            "        if _now > id_token[\"exp\"]:",
            "            raise OtherError(\"Passed best before date\")",
            "",
            "        if response_type != [\"code\"] and id_token.jws_header[\"alg\"] == \"none\":",
            "            raise WrongSigningAlgorithm(",
            "                \"none is not allowed outside Authorization Flow.\"",
            "            )",
            "",
            "        if (",
            "            self.id_token_max_age",
            "            and _now > int(id_token[\"iat\"]) + self.id_token_max_age",
            "        ):",
            "            raise OtherError(\"I think this ID token is to old\")",
            "",
            "        if nonce and nonce != id_token[\"nonce\"]:",
            "            raise OtherError(\"nonce mismatch\")",
            "",
            "        if acr_values and id_token[\"acr\"] not in acr_values:",
            "            raise OtherError(\"acr mismatch\")",
            "",
            "        if max_age and _now > int(id_token[\"auth_time\"] + max_age):",
            "            raise AuthnToOld(\"To old authentication\")",
            "",
            "        if auth_time:",
            "            if not claims_match(id_token[\"auth_time\"], {\"auth_time\": auth_time}):",
            "                raise AuthnToOld(\"To old authentication\")",
            "",
            "    def verify_id_token(self, id_token, authn_req):",
            "        kwa = {}",
            "        try:",
            "            kwa[\"nonce\"] = authn_req[\"nonce\"]",
            "        except KeyError:",
            "            pass",
            "",
            "        for param in [\"acr_values\", \"max_age\", \"response_type\"]:",
            "            try:",
            "                kwa[param] = authn_req[param]",
            "            except KeyError:",
            "                pass",
            "",
            "        self._verify_id_token(id_token, **kwa)",
            "",
            "",
            "class Server(oauth2.Server):",
            "    \"\"\"OIC Server class.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        verify_ssl: bool = None,",
            "        keyjar: KeyJar = None,",
            "        client_cert: Union[str, Tuple[str, str]] = None,",
            "        timeout: float = None,",
            "        message_factory: Type[MessageFactory] = OIDCMessageFactory,",
            "        settings: PyoidcSettings = None,",
            "    ):",
            "        \"\"\"Initialize the server.\"\"\"",
            "        self.settings = settings or OicServerSettings()",
            "        if verify_ssl is not None:",
            "            warnings.warn(",
            "                \"`verify_ssl` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.verify_ssl = verify_ssl",
            "        if client_cert is not None:",
            "            warnings.warn(",
            "                \"`client_cert` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.client_cert = client_cert",
            "        if timeout is not None:",
            "            warnings.warn(",
            "                \"`timeout` is deprecated, please use `settings` instead if you need to set a non-default value.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.settings.timeout = timeout",
            "",
            "        super().__init__(",
            "            keyjar=keyjar,",
            "            message_factory=message_factory,",
            "            settings=self.settings,",
            "        )",
            "",
            "    @staticmethod",
            "    def _parse_urlencoded(url=None, query=None):",
            "        if url:",
            "            parts = urlparse(url)",
            "            scheme, netloc, path, params, query, fragment = parts[:6]",
            "",
            "        return parse_qs(query)",
            "",
            "    def handle_request_uri(self, request_uri, verify=True, sender=\"\"):",
            "        \"\"\"",
            "        Handle request URI.",
            "",
            "        :param request_uri: URL pointing to where the signed request should be fetched from.",
            "        :param verify: Whether the signature on the request should be verified.",
            "        Don't use anything but the default unless you REALLY know what you're doing",
            "        :param sender: The issuer of the request JWT.",
            "        :return:",
            "        \"\"\"",
            "        # Do a HTTP get",
            "        logger.debug(\"Get request from request_uri: {}\".format(request_uri))",
            "        try:",
            "            http_req = self.http_request(request_uri)",
            "        except ConnectionError:",
            "            logger.error(\"Connection Error\")",
            "            return authz_error(\"invalid_request_uri\")",
            "",
            "        if not http_req:",
            "            logger.error(\"Nothing returned\")",
            "            return authz_error(\"invalid_request_uri\")",
            "        elif http_req.status_code >= 400:",
            "            logger.error(\"HTTP error {}:{}\".format(http_req.status_code, http_req.text))",
            "            raise AuthzError(\"invalid_request\")",
            "",
            "        # http_req.text is a signed JWT",
            "        try:",
            "            logger.debug(\"request txt: {}\".format(http_req.text))",
            "            req = self.parse_jwt_request(",
            "                txt=http_req.text, verify=verify, sender=sender",
            "            )",
            "        except Exception as err:",
            "            logger.error(",
            "                \"{}:{} encountered while parsing fetched request\".format(",
            "                    err.__class__, err",
            "                )",
            "            )",
            "            raise AuthzError(\"invalid_openid_request_object\")",
            "",
            "        logger.debug(\"Fetched request: {}\".format(req))",
            "        return req",
            "",
            "    def parse_authorization_request(",
            "        self, request=AuthorizationRequest, url=None, query=None, keys=None",
            "    ):",
            "        if url:",
            "            parts = urlparse(url)",
            "            scheme, netloc, path, params, query, fragment = parts[:6]",
            "",
            "        if isinstance(query, dict):",
            "            sformat = \"dict\"",
            "        else:",
            "            sformat = \"urlencoded\"",
            "",
            "        _req = self._parse_request(request, query, sformat, verify=False)",
            "",
            "        if self.events:",
            "            self.events.store(\"Request\", _req)",
            "",
            "        _req_req: Union[Message, Dict[str, Any]] = {}",
            "        try:",
            "            _request = _req[\"request\"]",
            "        except KeyError:",
            "            try:",
            "                _url = _req[\"request_uri\"]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                _req_req = self.handle_request_uri(",
            "                    _url, verify=False, sender=_req[\"client_id\"]",
            "                )",
            "        else:",
            "            if isinstance(_request, Message):",
            "                _req_req = _request",
            "            else:",
            "                try:",
            "                    _req_req = self.parse_jwt_request(",
            "                        request, txt=_request, verify=False",
            "                    )",
            "                except Exception:",
            "                    _req_req = self._parse_request(",
            "                        request, _request, \"urlencoded\", verify=False",
            "                    )",
            "                else:  # remove JWT attributes",
            "                    for attr in JasonWebToken.c_param:",
            "                        try:",
            "                            del _req_req[attr]",
            "                        except KeyError:",
            "                            pass",
            "",
            "        if isinstance(_req_req, Response):",
            "            return _req_req",
            "",
            "        if _req_req:",
            "            if self.events:",
            "                self.events.store(\"Signed Request\", _req_req)",
            "",
            "            for key, val in _req.items():",
            "                if key in [\"request\", \"request_uri\"]:",
            "                    continue",
            "                if key not in _req_req:",
            "                    _req_req[key] = val",
            "            _req = _req_req",
            "",
            "        if self.events:",
            "            self.events.store(\"Combined Request\", _req)",
            "",
            "        try:",
            "            _req.verify(keyjar=self.keyjar)",
            "        except Exception as err:",
            "            if self.events:",
            "                self.events.store(\"Exception\", err)",
            "            logger.error(err)",
            "            raise",
            "",
            "        return _req",
            "",
            "    def parse_jwt_request(",
            "        self,",
            "        request=AuthorizationRequest,",
            "        txt=\"\",",
            "        keyjar=None,",
            "        verify=True,",
            "        sender=\"\",",
            "        **kwargs,",
            "    ):",
            "        \"\"\"Overridden to use OIC Message type.\"\"\"",
            "        if \"keys\" in kwargs:",
            "            keyjar = kwargs[\"keys\"]",
            "            warnings.warn(",
            "                \"`keys` was renamed to `keyjar`, please update your code.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "        return super().parse_jwt_request(",
            "            request=request, txt=txt, keyjar=keyjar, verify=verify, sender=sender",
            "        )",
            "",
            "    def parse_check_session_request(self, url=None, query=None):",
            "        param = self._parse_urlencoded(url, query)",
            "        assert \"id_token\" in param  # nosec, ignore the rest",
            "        return deser_id_token(self, param[\"id_token\"][0])",
            "",
            "    def parse_check_id_request(self, url=None, query=None):",
            "        param = self._parse_urlencoded(url, query)",
            "        assert \"access_token\" in param  # nosec, ignore the rest",
            "        return deser_id_token(self, param[\"access_token\"][0])",
            "",
            "    def _parse_request(self, request_cls, data, sformat, client_id=None, verify=True):",
            "        if sformat == \"json\":",
            "            request = request_cls().from_json(data)",
            "        elif sformat == \"jwt\":",
            "            request = request_cls().from_jwt(data, keyjar=self.keyjar, sender=client_id)",
            "        elif sformat == \"urlencoded\":",
            "            if \"?\" in data:",
            "                parts = urlparse(data)",
            "                scheme, netloc, path, params, query, fragment = parts[:6]",
            "            else:",
            "                query = data",
            "            request = request_cls().from_urlencoded(query)",
            "        elif sformat == \"dict\":",
            "            request = request_cls(**data)",
            "        else:",
            "            raise ParseError(",
            "                \"Unknown package format: '{}'\".format(sformat), request_cls",
            "            )",
            "",
            "        # get the verification keys",
            "        if client_id:",
            "            keys = self.keyjar.verify_keys(client_id)",
            "            sender = client_id",
            "        else:",
            "            try:",
            "                keys = self.keyjar.verify_keys(request[\"client_id\"])",
            "                sender = request[\"client_id\"]",
            "            except KeyError:",
            "                keys = None",
            "                sender = \"\"",
            "",
            "        logger.debug(\"Found {} verify keys\".format(len(keys or \"\")))",
            "        if verify:",
            "            request.verify(key=keys, keyjar=self.keyjar, sender=sender)",
            "        return request",
            "",
            "    def parse_open_id_request(self, data, sformat=\"urlencoded\", client_id=None):",
            "        return self._parse_request(OpenIDRequest, data, sformat, client_id)",
            "",
            "    def parse_user_info_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(UserInfoRequest, data, sformat)",
            "",
            "    def parse_userinfo_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(UserInfoRequest, data, sformat)",
            "",
            "    def parse_refresh_session_request(self, url=None, query=None):",
            "        if url:",
            "            parts = urlparse(url)",
            "            query = parts.query",
            "        return RefreshSessionRequest().from_urlencoded(query)",
            "",
            "    def parse_registration_request(self, data, sformat=\"urlencoded\"):",
            "        return self._parse_request(RegistrationRequest, data, sformat)",
            "",
            "    def parse_end_session_request(self, query, sformat=\"urlencoded\"):",
            "        esr = self._parse_request(EndSessionRequest, query, sformat)",
            "        # if there is a id_token in there it is as a string",
            "        esr[\"id_token\"] = deser_id_token(self, esr[\"id_token\"])",
            "        return esr",
            "",
            "    @staticmethod",
            "    def update_claims(session, where, about, old_claims=None):",
            "        \"\"\"",
            "        Update claims dictionary.",
            "",
            "        :param session:",
            "        :param where: Which request",
            "        :param about: userinfo or id_token",
            "        :param old_claims:",
            "        :return: claims or None",
            "        \"\"\"",
            "        if old_claims is None:",
            "            old_claims = {}",
            "",
            "        req = None",
            "        if where == \"oidreq\":",
            "            try:",
            "                req = OpenIDRequest().deserialize(session[where], \"json\")",
            "            except KeyError:",
            "                pass",
            "        else:  # where == \"authzreq\"",
            "            try:",
            "                req = AuthorizationRequest().deserialize(session[where], \"json\")",
            "            except KeyError:",
            "                pass",
            "",
            "        if req:",
            "            logger.debug(\"%s: %s\" % (where, sanitize(req.to_dict())))",
            "            try:",
            "                _claims = req[\"claims\"][about]",
            "                if _claims:",
            "                    # update with old claims, do not overwrite",
            "                    for key, val in old_claims.items():",
            "                        if key not in _claims:",
            "                            _claims[key] = val",
            "                    return _claims",
            "            except KeyError:",
            "                pass",
            "",
            "        return old_claims",
            "",
            "    def id_token_claims(self, session):",
            "        \"\"\"",
            "        Pick the IdToken claims from the request.",
            "",
            "        :param session: Session information",
            "        :return: The IdToken claims",
            "        \"\"\"",
            "        itc: Dict[str, str] = {}",
            "        itc = self.update_claims(session, \"authzreq\", \"id_token\", itc)",
            "        itc = self.update_claims(session, \"oidreq\", \"id_token\", itc)",
            "        return itc",
            "",
            "    def make_id_token(",
            "        self,",
            "        session,",
            "        loa=\"2\",",
            "        issuer=\"\",",
            "        alg=\"RS256\",",
            "        code=None,",
            "        access_token=None,",
            "        user_info=None,",
            "        auth_time=0,",
            "        exp=None,",
            "        extra_claims=None,",
            "    ):",
            "        \"\"\"",
            "        Create ID Token.",
            "",
            "        :param session: Session information",
            "        :param loa: Level of Assurance/Authentication context",
            "        :param issuer: My identifier",
            "        :param alg: Which signing algorithm to use for the IdToken",
            "        :param code: Access grant",
            "        :param access_token: Access Token",
            "        :param user_info: If user info are to be part of the IdToken",
            "        :return: IDToken instance",
            "        \"\"\"",
            "        # defaults",
            "        if exp is None:",
            "            inawhile = {\"days\": 1}",
            "        else:",
            "            inawhile = exp",
            "        # Handle the idtoken_claims",
            "        extra = {}",
            "        itc = self.id_token_claims(session)",
            "        if itc.keys():",
            "            try:",
            "                inawhile = {\"seconds\": itc[\"max_age\"]}",
            "            except KeyError:",
            "                pass",
            "            for key, val in itc.items():",
            "                if key == \"auth_time\":",
            "                    extra[\"auth_time\"] = auth_time",
            "                elif key == \"acr\":",
            "                    extra[\"acr\"] = verify_acr_level(val, loa)",
            "        else:",
            "            if auth_time:",
            "                extra[\"auth_time\"] = auth_time",
            "            if loa:",
            "                extra[\"acr\"] = loa",
            "",
            "        if not user_info:",
            "            _args: Dict[str, str] = {}",
            "        else:",
            "            try:",
            "                _args = user_info.to_dict()",
            "            except AttributeError:",
            "                _args = user_info",
            "",
            "        # Make sure that there are no name clashes",
            "        for key in [\"iss\", \"sub\", \"aud\", \"exp\", \"acr\", \"nonce\", \"auth_time\"]:",
            "            try:",
            "                del _args[key]",
            "            except KeyError:",
            "                pass",
            "",
            "        halg = \"HS%s\" % alg[-3:]",
            "",
            "        if extra_claims is not None:",
            "            _args.update(extra_claims)",
            "        if code:",
            "            _args[\"c_hash\"] = jws.left_hash(code.encode(\"utf-8\"), halg)",
            "        if access_token:",
            "            _args[\"at_hash\"] = jws.left_hash(access_token.encode(\"utf-8\"), halg)",
            "",
            "        idt = IdToken(",
            "            iss=issuer,",
            "            sub=session[\"sub\"],",
            "            aud=session[\"client_id\"],",
            "            exp=time_util.epoch_in_a_while(**inawhile),",
            "            acr=loa,",
            "            iat=time_util.utc_time_sans_frac(),",
            "            **_args,",
            "        )",
            "",
            "        for key, val in extra.items():",
            "            idt[key] = val",
            "",
            "        if \"nonce\" in session:",
            "            idt[\"nonce\"] = session[\"nonce\"]",
            "",
            "        return idt",
            "",
            "",
            "def scope2claims(scopes, extra_scope_dict=None):",
            "    res: Dict[str, None] = {}",
            "    # Construct the scope translation map",
            "    trans_map: Dict[str, Any] = SCOPE2CLAIMS.copy()",
            "    if extra_scope_dict is not None:",
            "        trans_map.update(extra_scope_dict)",
            "    for scope in scopes:",
            "        try:",
            "            claims = dict([(name, None) for name in trans_map[scope]])",
            "            res.update(claims)",
            "        except KeyError:",
            "            continue",
            "    return res"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1435": [
                "Client",
                "_verify_id_token"
            ],
            "1494": [
                "Client",
                "verify_id_token"
            ]
        },
        "addLocation": []
    },
    "src/oic/oic/consumer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import warnings"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from typing import Dict"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from typing import Optional"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from typing import Tuple"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from typing import Union"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from oic import rndstr"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from oic.exception import AuthzError"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from oic.oic.message import BackChannelLogoutRequest"
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from oic.oic.message import Claims"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from oic.oic.message import ClaimsRequest"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from oic.oic.message import IdToken"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from oic.utils import http_util"
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from oic.utils.sanitize import sanitize"
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from oic.utils.sdb import DictSessionBackend"
            },
            "15": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "         if self.debug:"
            },
            "16": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "             _log_info(\"Redirecting to: %s\" % location)"
            },
            "17": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 345,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+        self.authz_req[areq[\"state\"]] = areq"
            },
            "19": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "         return sid, location"
            },
            "20": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 348,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "     def _parse_authz(self, query=\"\", **kwargs):"
            },
            "22": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]"
            },
            "23": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "         return aresp, _state"
            },
            "24": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 370,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def parse_authz(self, query=\"\", **kwargs):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+    def parse_authz("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        self, query=\"\", **kwargs"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+    ) -> Union["
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+        http_util.BadRequest,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+        Tuple["
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+            Optional[AuthorizationResponse],"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+            Optional[AccessTokenResponse],"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+            Optional[IdToken],"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        ],"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+    ]:"
            },
            "36": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         \"\"\""
            },
            "37": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         Parse authorization response from server."
            },
            "38": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 383,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         [\"id_token\"]"
            },
            "40": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         [\"id_token\", \"token\"]"
            },
            "41": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "         [\"token\"]"
            },
            "42": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "43": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :return: A AccessTokenResponse instance"
            },
            "44": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         \"\"\""
            },
            "45": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "         _log_info = logger.info"
            },
            "46": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "         logger.debug(\"- authorization -\")"
            },
            "47": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 394,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+        # FIXME: This shouldn't be here... We should rather raise a sepcific Client error"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+        # That would simplify the return value of this function"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+        # and drop bunch of assertions from tests added in this commit."
            },
            "51": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         if not query:"
            },
            "52": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "             return http_util.BadRequest(\"Missing query\")"
            },
            "53": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 400,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         _log_info(\"response: %s\" % sanitize(query))"
            },
            "55": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 402,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+        if \"algs\" not in kwargs:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            kwargs[\"algs\"] = self.sign_enc_algs(\"id_token\")"
            },
            "58": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "         if \"code\" in self.consumer_config[\"response_type\"]:"
            },
            "59": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "             aresp, _state = self._parse_authz(query, **kwargs)"
            },
            "60": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 407,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "                 except KeyError:"
            },
            "62": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "                     pass"
            },
            "63": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 428,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return aresp, atr, idt"
            },
            "65": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 429,
                "PatchRowcode": "         elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow"
            },
            "66": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "             _log_info(\"Expect Access Token Response\")"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+            aresp = None"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+            _state = None"
            },
            "69": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "             atr = self.parse_response("
            },
            "70": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "                 AccessTokenResponse,"
            },
            "71": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "                 info=query,"
            },
            "72": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "             if isinstance(atr, ErrorResponse):"
            },
            "73": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "                 raise TokenError(atr.get(\"error\"), atr)"
            },
            "74": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 442,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            idt = None"
            },
            "76": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None, atr, idt"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+            idt = atr.get(\"id_token\")"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "         else:  # only id_token"
            },
            "80": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "             aresp, _state = self._parse_authz(query, **kwargs)"
            },
            "81": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 447,
                "PatchRowcode": " "
            },
            "82": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "                     session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])"
            },
            "83": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "                 except KeyError:"
            },
            "84": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "                     pass"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+            # Null the aresp as only id_token should be returned"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+            aresp = atr = None"
            },
            "87": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 459,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None, None, idt"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+        # Verify the IdToken if it was present"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+        if idt is not None:"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+            self.verify_id_token(idt, self.authz_req.get(_state or atr[\"state\"]))"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+        return aresp, atr, idt"
            },
            "93": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 464,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "     def complete(self, state):"
            },
            "95": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "import logging",
            "import os.path",
            "import warnings",
            "from typing import Dict",
            "from typing import Optional",
            "",
            "from oic import rndstr",
            "from oic.exception import AuthzError",
            "from oic.exception import MessageException",
            "from oic.exception import NotForMe",
            "from oic.exception import PyoidcError",
            "from oic.oauth2 import Grant",
            "from oic.oauth2.consumer import TokenError",
            "from oic.oauth2.consumer import UnknownState",
            "from oic.oauth2.consumer import stateID",
            "from oic.oauth2.message import ErrorResponse",
            "from oic.oic import ENDPOINTS",
            "from oic.oic import Client",
            "from oic.oic.message import AccessTokenResponse",
            "from oic.oic.message import AuthorizationRequest",
            "from oic.oic.message import AuthorizationResponse",
            "from oic.oic.message import BackChannelLogoutRequest",
            "from oic.oic.message import Claims",
            "from oic.oic.message import ClaimsRequest",
            "from oic.utils import http_util",
            "from oic.utils.sanitize import sanitize",
            "from oic.utils.sdb import DictSessionBackend",
            "from oic.utils.sdb import SessionBackend",
            "from oic.utils.sdb import session_extended_get",
            "from oic.utils.sdb import session_get",
            "from oic.utils.sdb import session_update",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def factory(kaka, sdb, config):",
            "    \"\"\"",
            "    Return the right Consumer instance dependent on what's in the cookie.",
            "",
            "    :param kaka: The cookie",
            "    :param sdb: The session database",
            "    :param config: The common Consumer configuration",
            "    :return: Consumer instance or None",
            "    \"\"\"",
            "    part = http_util.cookie_parts(config[\"name\"], kaka)",
            "    if part is None:",
            "        return None",
            "",
            "    cons = Consumer(sdb, config)",
            "    cons.restore(part[0])",
            "    http_util.parse_cookie(config[\"name\"], cons.seed, kaka)",
            "    return cons",
            "",
            "",
            "def build_userinfo_claims(claims, sformat=\"signed\", locale=\"us-en\"):",
            "    \"\"\"",
            "    Create userinfo request based on claims.",
            "",
            "    config example::",
            "",
            "        \"userinfo\":{",
            "            \"name\": {\"essential\": true},",
            "            \"nickname\": null,",
            "            \"email\": {\"essential\": true},",
            "            \"email_verified\": {\"essential\": true},",
            "            \"picture\": null",
            "        }",
            "    \"\"\"",
            "    return Claims(format=sformat, **claims)",
            "",
            "",
            "def clean_response(aresp):",
            "    \"\"\"",
            "    Create a new instance with only the standard attributes.",
            "",
            "    :param aresp: The original AccessTokenResponse",
            "    :return: An AccessTokenResponse instance",
            "    \"\"\"",
            "    atr = AccessTokenResponse()",
            "    for prop in atr.parameters():",
            "        try:",
            "            atr[prop] = aresp[prop]",
            "        except KeyError:",
            "            pass",
            "",
            "    return atr",
            "",
            "",
            "IGNORE = [",
            "    \"request2endpoint\",",
            "    \"response2error\",",
            "    \"grant_class\",",
            "    \"token_class\",",
            "    \"sdb\",",
            "    \"wf\",",
            "    \"events\",",
            "    \"message_factory\",",
            "]",
            "",
            "CONSUMER_PREF_ARGS = [",
            "    \"token_endpoint_auth_method\",",
            "    \"subject_type\",",
            "    \"require_signed_request_object\",",
            "    \"userinfo_signed_response_algs\",",
            "    \"userinfo_encrypted_response_alg\",",
            "    \"userinfo_encrypted_response_enc\",",
            "    \"userinfo_encrypted_response_int\",",
            "    \"id_token_signed_response_algs\",",
            "    \"id_token_encrypted_response_alg\",",
            "    \"id_token_encrypted_response_enc\",",
            "    \"id_token_encrypted_response_int\",",
            "    \"request_object_signing_alg\",",
            "    \"request_object_encryption_alg\",",
            "    \"request_object_encryption_enc\",",
            "    \"default_max_age\",",
            "    \"require_auth_time\",",
            "    \"default_acr_values\",",
            "]",
            "",
            "",
            "class Consumer(Client):",
            "    \"\"\"An OpenID Connect consumer implementation.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        session_db,",
            "        consumer_config,",
            "        client_config=None,",
            "        server_info=None,",
            "        debug=False,",
            "        client_prefs=None,",
            "        sso_db=None,",
            "    ):",
            "        \"\"\"",
            "        Initialize a Consumer instance.",
            "",
            "        :param session_db: Where info are kept about sessions",
            "        :param config: Configuration of the consumer",
            "        :param client_config: Client configuration",
            "        :param server_info: Information about the server",
            "        :param client_prefs: Run time preferences, which are chosen depends",
            "        on what the server can do.",
            "        \"\"\"",
            "        if client_config is None:",
            "            client_config = {}",
            "",
            "        Client.__init__(self, **client_config)",
            "",
            "        self.consumer_config = consumer_config",
            "        if consumer_config:",
            "            try:",
            "                self.debug = consumer_config[\"debug\"]",
            "            except KeyError:",
            "                self.debug = 0",
            "",
            "        if server_info:",
            "            for endpoint in ENDPOINTS:",
            "                try:",
            "                    setattr(self, endpoint, server_info[endpoint])",
            "                except KeyError:",
            "                    setattr(self, endpoint, \"\")",
            "",
            "        if not isinstance(session_db, SessionBackend):",
            "            warnings.warn(",
            "                \"Please use `SessionBackend` to ensure proper API for the database.\",",
            "                DeprecationWarning,",
            "            )",
            "        self.sdb = session_db",
            "",
            "        if sso_db is not None:",
            "            if not isinstance(sso_db, SessionBackend):",
            "                warnings.warn(",
            "                    \"Please use `SessionBackend` to ensure proper API for the database.\",",
            "                    DeprecationWarning,",
            "                )",
            "            self.sso_db: SessionBackend = sso_db",
            "        else:",
            "            self.sso_db = DictSessionBackend()",
            "",
            "        self.debug = debug",
            "        self.seed = \"\"",
            "        self.nonce = \"\"",
            "        self.request_filename = \"\"",
            "        self.request_uri = \"\"",
            "        self.user_info = None",
            "        self.registration_expires_at = 0",
            "        self.secret_type = \"Bearer\"",
            "",
            "    def update(self, sid):",
            "        \"\"\"",
            "        Update the instance variables from something stored in the session database.",
            "",
            "        Will not overwrite something that's already there.",
            "        Except for the grant dictionary !!",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        for key, val in self.sdb[sid].items():",
            "            try:",
            "                _val = getattr(self, key)",
            "            except AttributeError:",
            "                continue",
            "",
            "            if not _val and val:",
            "                setattr(self, key, val)",
            "            elif key == \"grant\" and val:",
            "                # val is a Grant instance",
            "                val.update(_val)",
            "                setattr(self, key, val)",
            "",
            "    def restore(self, sid):",
            "        \"\"\"",
            "        Restore the instance variables from something stored in the session database.",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        for key, val in self.sdb[sid].items():",
            "            setattr(self, key, val)",
            "",
            "    def dictionary(self):",
            "        return dict([(k, v) for k, v in self.__dict__.items() if k not in IGNORE])",
            "",
            "    def _backup(self, sid):",
            "        \"\"\"",
            "        Store instance variable values in the session store under a session identifier.",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        self.sdb[sid] = self.dictionary()",
            "",
            "    def begin(self, scope=\"\", response_type=\"\", use_nonce=False, path=\"\", **kwargs):",
            "        \"\"\"",
            "        Begin the OIDC flow.",
            "",
            "        :param scope: Defines which user info claims is wanted",
            "        :param response_type: Controls the parameters returned in the response from the Authorization Endpoint",
            "        :param use_nonce: If not implicit flow nonce is optional. This defines if it should be used anyway.",
            "        :param path: The path part of the redirect URL",
            "        :return: A 2-tuple, session identifier and URL to which the user should be redirected",
            "        \"\"\"",
            "        _log_info = logger.info",
            "",
            "        if self.debug:",
            "            _log_info(\"- begin -\")",
            "",
            "        _page = self.consumer_config[\"authz_page\"]",
            "        if not path.endswith(\"/\"):",
            "            if _page.startswith(\"/\"):",
            "                self.redirect_uris = [path + _page]",
            "            else:",
            "                self.redirect_uris = [\"%s/%s\" % (path, _page)]",
            "        else:",
            "            if _page.startswith(\"/\"):",
            "                self.redirect_uris = [path + _page[1:]]",
            "            else:",
            "                self.redirect_uris = [\"%s/%s\" % (path, _page)]",
            "",
            "        # Put myself in the dictionary of sessions, keyed on session-id",
            "        if not self.seed:",
            "            self.seed = rndstr()",
            "",
            "        if not scope:",
            "            scope = self.consumer_config[\"scope\"]",
            "        if not response_type:",
            "            response_type = self.consumer_config[\"response_type\"]",
            "",
            "        sid = stateID(path, self.seed)",
            "        self.grant[sid] = Grant(seed=self.seed)",
            "",
            "        self._backup(sid)",
            "        self.sdb[\"seed:%s\" % self.seed] = sid",
            "        self.sso_db[sid] = {}",
            "",
            "        args = {",
            "            \"client_id\": self.client_id,",
            "            \"state\": sid,",
            "            \"response_type\": response_type,",
            "            \"scope\": scope,",
            "        }",
            "",
            "        # nonce is REQUIRED in implicit flow,",
            "        # OPTIONAL on code flow.",
            "        if \"token\" in response_type or use_nonce:",
            "            args[\"nonce\"] = rndstr(12)",
            "            self.state2nonce[sid] = args[\"nonce\"]",
            "",
            "        if \"max_age\" in self.consumer_config:",
            "            args[\"max_age\"] = self.consumer_config[\"max_age\"]",
            "",
            "        _claims = None",
            "        if \"user_info\" in self.consumer_config:",
            "            _claims = ClaimsRequest(",
            "                userinfo=Claims(**self.consumer_config[\"user_info\"])",
            "            )",
            "        if \"id_token\" in self.consumer_config:",
            "            if _claims:",
            "                _claims[\"id_token\"] = Claims(**self.consumer_config[\"id_token\"])",
            "            else:",
            "                _claims = ClaimsRequest(",
            "                    id_token=Claims(**self.consumer_config[\"id_token\"])",
            "                )",
            "",
            "        if _claims:",
            "            args[\"claims\"] = _claims",
            "",
            "        if \"request_method\" in self.consumer_config:",
            "            areq = self.construct_AuthorizationRequest(",
            "                request_args=args, extra_args=None, request_param=\"request\"",
            "            )",
            "",
            "            if self.consumer_config[\"request_method\"] == \"file\":",
            "                id_request = areq[\"request\"]",
            "                del areq[\"request\"]",
            "                _filedir = self.consumer_config[\"temp_dir\"]",
            "                _webpath = self.consumer_config[\"temp_path\"]",
            "                _name = rndstr(10)",
            "                filename = os.path.join(_filedir, _name)",
            "                while os.path.exists(filename):",
            "                    _name = rndstr(10)",
            "                    filename = os.path.join(_filedir, _name)",
            "                fid = open(filename, mode=\"w\")",
            "                fid.write(id_request)",
            "                fid.close()",
            "                _webname = \"%s%s/%s\" % (path, _webpath, _name)",
            "                areq[\"request_uri\"] = _webname",
            "                self.request_uri = _webname",
            "                self._backup(sid)",
            "        else:",
            "            if \"userinfo_claims\" in args:  # can only be carried in an IDRequest",
            "                raise PyoidcError(\"Need a request method\")",
            "",
            "            areq = self.construct_AuthorizationRequest(",
            "                AuthorizationRequest, request_args=args",
            "            )",
            "",
            "        location = areq.request(self.authorization_endpoint)",
            "",
            "        if self.debug:",
            "            _log_info(\"Redirecting to: %s\" % location)",
            "",
            "        return sid, location",
            "",
            "    def _parse_authz(self, query=\"\", **kwargs):",
            "        _log_info = logger.info",
            "        # Might be an error response",
            "        _log_info(\"Expect Authorization Response\")",
            "        aresp = self.parse_response(",
            "            AuthorizationResponse, info=query, sformat=\"urlencoded\", keyjar=self.keyjar",
            "        )",
            "        if isinstance(aresp, ErrorResponse):",
            "            _log_info(\"ErrorResponse: %s\" % sanitize(aresp))",
            "            raise AuthzError(aresp.get(\"error\"), aresp)",
            "",
            "        _log_info(\"Aresp: %s\" % sanitize(aresp))",
            "",
            "        _state = aresp[\"state\"]",
            "        try:",
            "            self.update(_state)",
            "        except KeyError:",
            "            raise UnknownState(_state, aresp)",
            "",
            "        self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]",
            "        return aresp, _state",
            "",
            "    def parse_authz(self, query=\"\", **kwargs):",
            "        \"\"\"",
            "        Parse authorization response from server.",
            "",
            "        Couple of cases",
            "        [\"code\"]",
            "        [\"code\", \"token\"]",
            "        [\"code\", \"id_token\", \"token\"]",
            "        [\"id_token\"]",
            "        [\"id_token\", \"token\"]",
            "        [\"token\"]",
            "",
            "        :return: A AccessTokenResponse instance",
            "        \"\"\"",
            "        _log_info = logger.info",
            "        logger.debug(\"- authorization -\")",
            "",
            "        if not query:",
            "            return http_util.BadRequest(\"Missing query\")",
            "",
            "        _log_info(\"response: %s\" % sanitize(query))",
            "",
            "        if \"code\" in self.consumer_config[\"response_type\"]:",
            "            aresp, _state = self._parse_authz(query, **kwargs)",
            "",
            "            # May have token and id_token information too",
            "            if \"access_token\" in aresp:",
            "                atr = clean_response(aresp)",
            "                self.access_token = atr",
            "                # update the grant object",
            "                self.get_grant(state=_state).add_token(atr)",
            "            else:",
            "                atr = None",
            "",
            "            self._backup(_state)",
            "",
            "            try:",
            "                idt = aresp[\"id_token\"]",
            "            except KeyError:",
            "                idt = None",
            "            else:",
            "                try:",
            "                    session_update(self.sdb, idt[\"sid\"], \"smid\", _state)",
            "                except KeyError:",
            "                    pass",
            "",
            "            return aresp, atr, idt",
            "        elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow",
            "            _log_info(\"Expect Access Token Response\")",
            "            atr = self.parse_response(",
            "                AccessTokenResponse,",
            "                info=query,",
            "                sformat=\"urlencoded\",",
            "                keyjar=self.keyjar,",
            "                **kwargs,",
            "            )",
            "            if isinstance(atr, ErrorResponse):",
            "                raise TokenError(atr.get(\"error\"), atr)",
            "",
            "            idt = None",
            "            return None, atr, idt",
            "        else:  # only id_token",
            "            aresp, _state = self._parse_authz(query, **kwargs)",
            "",
            "            try:",
            "                idt = aresp[\"id_token\"]",
            "            except KeyError:",
            "                idt = None",
            "            else:",
            "                try:",
            "                    session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])",
            "                except KeyError:",
            "                    pass",
            "",
            "            return None, None, idt",
            "",
            "    def complete(self, state):",
            "        \"\"\"",
            "        Do the access token request, the last step in a code flow.",
            "",
            "        If Implicit flow was used then this method is never used.",
            "        \"\"\"",
            "        args = {\"redirect_uri\": self.redirect_uris[0]}",
            "        if \"password\" in self.consumer_config and self.consumer_config[\"password\"]:",
            "            logger.info(\"basic auth\")",
            "            http_args = {\"password\": self.consumer_config[\"password\"]}",
            "        elif self.client_secret:",
            "            logger.info(\"request_body auth\")",
            "            http_args = {}",
            "            args.update(",
            "                {",
            "                    \"client_secret\": self.client_secret,",
            "                    \"client_id\": self.client_id,",
            "                    \"secret_type\": self.secret_type,",
            "                }",
            "            )",
            "        else:",
            "            raise PyoidcError(\"Nothing to authenticate with\")",
            "",
            "        resp = self.do_access_token_request(",
            "            state=state, request_args=args, http_args=http_args",
            "        )",
            "",
            "        logger.info(\"Access Token Response: %s\" % sanitize(resp))",
            "",
            "        if resp.type() == \"ErrorResponse\":",
            "            raise TokenError(resp.error, resp)",
            "",
            "        self._backup(state)",
            "",
            "        return resp",
            "",
            "    def refresh_token(self):",
            "        pass",
            "",
            "    def get_user_info(self, state):",
            "        uinfo = self.do_user_info_request(state=state, schema=\"openid\")",
            "",
            "        if uinfo.type() == \"ErrorResponse\":",
            "            raise TokenError(uinfo.error, uinfo)",
            "",
            "        self.user_info = uinfo",
            "        self._backup(state)",
            "",
            "        return uinfo",
            "",
            "    def refresh_session(self):",
            "        pass",
            "",
            "    def check_session(self):",
            "        \"\"\"",
            "        Check session endpoint.",
            "",
            "        With python you could use PyQuery to get the onclick attribute of each",
            "        anchor tag, parse that with a regular expression to get the placeId,",
            "        build the /places/duplicates.jsp?inPID= URL yourself, use requests to",
            "        load the content at that URL, then PyQuery again on the content to get",
            "        the data you need.",
            "",
            "        for iframe in mosoup(\"iframe\"):",
            "            mosoup.iframe.extract()",
            "",
            "        It accepts postMessage requests from the relevant RP iframe and uses",
            "        postMessage to post back the login status of the End-User at the OP.",
            "",
            "        :return:",
            "        \"\"\"",
            "        pass",
            "",
            "    def end_session(self):",
            "        pass",
            "",
            "    # LOGOUT related",
            "",
            "    def backchannel_logout(",
            "        self, request: Optional[str] = None, request_args: Optional[Dict] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Receives a back channel logout request.",
            "",
            "        :param request: A urlencoded request",
            "        :param request_args: The request as a dictionary",
            "        :return: A Session Identifier",
            "        \"\"\"",
            "        if request:",
            "            req = BackChannelLogoutRequest().from_urlencoded(request)",
            "        elif request_args is not None:",
            "            req = BackChannelLogoutRequest(**request_args)",
            "        else:",
            "            raise ValueError(\"Missing request specification\")",
            "",
            "        kwargs = {\"aud\": self.client_id, \"iss\": self.issuer, \"keyjar\": self.keyjar}",
            "",
            "        try:",
            "            req.verify(**kwargs)",
            "        except (MessageException, ValueError, NotForMe) as err:",
            "            raise MessageException(\"Bogus logout request: {}\".format(err))",
            "",
            "        # Find the subject through 'sid' or 'sub'",
            "",
            "        try:",
            "            sub = req[\"logout_token\"][\"sub\"]",
            "        except KeyError:",
            "            # verify has guaranteed that there will be a sid if sub is missing",
            "            sm_id = req[\"logout_token\"][\"sid\"]",
            "            _sid = session_get(self.sso_db, \"smid\", sm_id)",
            "        else:",
            "            _sid = session_extended_get(",
            "                self.sso_db, sub, \"issuer\", req[\"logout_token\"][\"iss\"]",
            "            )",
            "",
            "        return _sid"
        ],
        "afterPatchFile": [
            "import logging",
            "import os.path",
            "import warnings",
            "from typing import Dict",
            "from typing import Optional",
            "from typing import Tuple",
            "from typing import Union",
            "",
            "from oic import rndstr",
            "from oic.exception import AuthzError",
            "from oic.exception import MessageException",
            "from oic.exception import NotForMe",
            "from oic.exception import PyoidcError",
            "from oic.oauth2 import Grant",
            "from oic.oauth2.consumer import TokenError",
            "from oic.oauth2.consumer import UnknownState",
            "from oic.oauth2.consumer import stateID",
            "from oic.oauth2.message import ErrorResponse",
            "from oic.oic import ENDPOINTS",
            "from oic.oic import Client",
            "from oic.oic.message import AccessTokenResponse",
            "from oic.oic.message import AuthorizationRequest",
            "from oic.oic.message import AuthorizationResponse",
            "from oic.oic.message import BackChannelLogoutRequest",
            "from oic.oic.message import Claims",
            "from oic.oic.message import ClaimsRequest",
            "from oic.oic.message import IdToken",
            "from oic.utils import http_util",
            "from oic.utils.sanitize import sanitize",
            "from oic.utils.sdb import DictSessionBackend",
            "from oic.utils.sdb import SessionBackend",
            "from oic.utils.sdb import session_extended_get",
            "from oic.utils.sdb import session_get",
            "from oic.utils.sdb import session_update",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def factory(kaka, sdb, config):",
            "    \"\"\"",
            "    Return the right Consumer instance dependent on what's in the cookie.",
            "",
            "    :param kaka: The cookie",
            "    :param sdb: The session database",
            "    :param config: The common Consumer configuration",
            "    :return: Consumer instance or None",
            "    \"\"\"",
            "    part = http_util.cookie_parts(config[\"name\"], kaka)",
            "    if part is None:",
            "        return None",
            "",
            "    cons = Consumer(sdb, config)",
            "    cons.restore(part[0])",
            "    http_util.parse_cookie(config[\"name\"], cons.seed, kaka)",
            "    return cons",
            "",
            "",
            "def build_userinfo_claims(claims, sformat=\"signed\", locale=\"us-en\"):",
            "    \"\"\"",
            "    Create userinfo request based on claims.",
            "",
            "    config example::",
            "",
            "        \"userinfo\":{",
            "            \"name\": {\"essential\": true},",
            "            \"nickname\": null,",
            "            \"email\": {\"essential\": true},",
            "            \"email_verified\": {\"essential\": true},",
            "            \"picture\": null",
            "        }",
            "    \"\"\"",
            "    return Claims(format=sformat, **claims)",
            "",
            "",
            "def clean_response(aresp):",
            "    \"\"\"",
            "    Create a new instance with only the standard attributes.",
            "",
            "    :param aresp: The original AccessTokenResponse",
            "    :return: An AccessTokenResponse instance",
            "    \"\"\"",
            "    atr = AccessTokenResponse()",
            "    for prop in atr.parameters():",
            "        try:",
            "            atr[prop] = aresp[prop]",
            "        except KeyError:",
            "            pass",
            "",
            "    return atr",
            "",
            "",
            "IGNORE = [",
            "    \"request2endpoint\",",
            "    \"response2error\",",
            "    \"grant_class\",",
            "    \"token_class\",",
            "    \"sdb\",",
            "    \"wf\",",
            "    \"events\",",
            "    \"message_factory\",",
            "]",
            "",
            "CONSUMER_PREF_ARGS = [",
            "    \"token_endpoint_auth_method\",",
            "    \"subject_type\",",
            "    \"require_signed_request_object\",",
            "    \"userinfo_signed_response_algs\",",
            "    \"userinfo_encrypted_response_alg\",",
            "    \"userinfo_encrypted_response_enc\",",
            "    \"userinfo_encrypted_response_int\",",
            "    \"id_token_signed_response_algs\",",
            "    \"id_token_encrypted_response_alg\",",
            "    \"id_token_encrypted_response_enc\",",
            "    \"id_token_encrypted_response_int\",",
            "    \"request_object_signing_alg\",",
            "    \"request_object_encryption_alg\",",
            "    \"request_object_encryption_enc\",",
            "    \"default_max_age\",",
            "    \"require_auth_time\",",
            "    \"default_acr_values\",",
            "]",
            "",
            "",
            "class Consumer(Client):",
            "    \"\"\"An OpenID Connect consumer implementation.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        session_db,",
            "        consumer_config,",
            "        client_config=None,",
            "        server_info=None,",
            "        debug=False,",
            "        client_prefs=None,",
            "        sso_db=None,",
            "    ):",
            "        \"\"\"",
            "        Initialize a Consumer instance.",
            "",
            "        :param session_db: Where info are kept about sessions",
            "        :param config: Configuration of the consumer",
            "        :param client_config: Client configuration",
            "        :param server_info: Information about the server",
            "        :param client_prefs: Run time preferences, which are chosen depends",
            "        on what the server can do.",
            "        \"\"\"",
            "        if client_config is None:",
            "            client_config = {}",
            "",
            "        Client.__init__(self, **client_config)",
            "",
            "        self.consumer_config = consumer_config",
            "        if consumer_config:",
            "            try:",
            "                self.debug = consumer_config[\"debug\"]",
            "            except KeyError:",
            "                self.debug = 0",
            "",
            "        if server_info:",
            "            for endpoint in ENDPOINTS:",
            "                try:",
            "                    setattr(self, endpoint, server_info[endpoint])",
            "                except KeyError:",
            "                    setattr(self, endpoint, \"\")",
            "",
            "        if not isinstance(session_db, SessionBackend):",
            "            warnings.warn(",
            "                \"Please use `SessionBackend` to ensure proper API for the database.\",",
            "                DeprecationWarning,",
            "            )",
            "        self.sdb = session_db",
            "",
            "        if sso_db is not None:",
            "            if not isinstance(sso_db, SessionBackend):",
            "                warnings.warn(",
            "                    \"Please use `SessionBackend` to ensure proper API for the database.\",",
            "                    DeprecationWarning,",
            "                )",
            "            self.sso_db: SessionBackend = sso_db",
            "        else:",
            "            self.sso_db = DictSessionBackend()",
            "",
            "        self.debug = debug",
            "        self.seed = \"\"",
            "        self.nonce = \"\"",
            "        self.request_filename = \"\"",
            "        self.request_uri = \"\"",
            "        self.user_info = None",
            "        self.registration_expires_at = 0",
            "        self.secret_type = \"Bearer\"",
            "",
            "    def update(self, sid):",
            "        \"\"\"",
            "        Update the instance variables from something stored in the session database.",
            "",
            "        Will not overwrite something that's already there.",
            "        Except for the grant dictionary !!",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        for key, val in self.sdb[sid].items():",
            "            try:",
            "                _val = getattr(self, key)",
            "            except AttributeError:",
            "                continue",
            "",
            "            if not _val and val:",
            "                setattr(self, key, val)",
            "            elif key == \"grant\" and val:",
            "                # val is a Grant instance",
            "                val.update(_val)",
            "                setattr(self, key, val)",
            "",
            "    def restore(self, sid):",
            "        \"\"\"",
            "        Restore the instance variables from something stored in the session database.",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        for key, val in self.sdb[sid].items():",
            "            setattr(self, key, val)",
            "",
            "    def dictionary(self):",
            "        return dict([(k, v) for k, v in self.__dict__.items() if k not in IGNORE])",
            "",
            "    def _backup(self, sid):",
            "        \"\"\"",
            "        Store instance variable values in the session store under a session identifier.",
            "",
            "        :param sid: Session identifier",
            "        \"\"\"",
            "        self.sdb[sid] = self.dictionary()",
            "",
            "    def begin(self, scope=\"\", response_type=\"\", use_nonce=False, path=\"\", **kwargs):",
            "        \"\"\"",
            "        Begin the OIDC flow.",
            "",
            "        :param scope: Defines which user info claims is wanted",
            "        :param response_type: Controls the parameters returned in the response from the Authorization Endpoint",
            "        :param use_nonce: If not implicit flow nonce is optional. This defines if it should be used anyway.",
            "        :param path: The path part of the redirect URL",
            "        :return: A 2-tuple, session identifier and URL to which the user should be redirected",
            "        \"\"\"",
            "        _log_info = logger.info",
            "",
            "        if self.debug:",
            "            _log_info(\"- begin -\")",
            "",
            "        _page = self.consumer_config[\"authz_page\"]",
            "        if not path.endswith(\"/\"):",
            "            if _page.startswith(\"/\"):",
            "                self.redirect_uris = [path + _page]",
            "            else:",
            "                self.redirect_uris = [\"%s/%s\" % (path, _page)]",
            "        else:",
            "            if _page.startswith(\"/\"):",
            "                self.redirect_uris = [path + _page[1:]]",
            "            else:",
            "                self.redirect_uris = [\"%s/%s\" % (path, _page)]",
            "",
            "        # Put myself in the dictionary of sessions, keyed on session-id",
            "        if not self.seed:",
            "            self.seed = rndstr()",
            "",
            "        if not scope:",
            "            scope = self.consumer_config[\"scope\"]",
            "        if not response_type:",
            "            response_type = self.consumer_config[\"response_type\"]",
            "",
            "        sid = stateID(path, self.seed)",
            "        self.grant[sid] = Grant(seed=self.seed)",
            "",
            "        self._backup(sid)",
            "        self.sdb[\"seed:%s\" % self.seed] = sid",
            "        self.sso_db[sid] = {}",
            "",
            "        args = {",
            "            \"client_id\": self.client_id,",
            "            \"state\": sid,",
            "            \"response_type\": response_type,",
            "            \"scope\": scope,",
            "        }",
            "",
            "        # nonce is REQUIRED in implicit flow,",
            "        # OPTIONAL on code flow.",
            "        if \"token\" in response_type or use_nonce:",
            "            args[\"nonce\"] = rndstr(12)",
            "            self.state2nonce[sid] = args[\"nonce\"]",
            "",
            "        if \"max_age\" in self.consumer_config:",
            "            args[\"max_age\"] = self.consumer_config[\"max_age\"]",
            "",
            "        _claims = None",
            "        if \"user_info\" in self.consumer_config:",
            "            _claims = ClaimsRequest(",
            "                userinfo=Claims(**self.consumer_config[\"user_info\"])",
            "            )",
            "        if \"id_token\" in self.consumer_config:",
            "            if _claims:",
            "                _claims[\"id_token\"] = Claims(**self.consumer_config[\"id_token\"])",
            "            else:",
            "                _claims = ClaimsRequest(",
            "                    id_token=Claims(**self.consumer_config[\"id_token\"])",
            "                )",
            "",
            "        if _claims:",
            "            args[\"claims\"] = _claims",
            "",
            "        if \"request_method\" in self.consumer_config:",
            "            areq = self.construct_AuthorizationRequest(",
            "                request_args=args, extra_args=None, request_param=\"request\"",
            "            )",
            "",
            "            if self.consumer_config[\"request_method\"] == \"file\":",
            "                id_request = areq[\"request\"]",
            "                del areq[\"request\"]",
            "                _filedir = self.consumer_config[\"temp_dir\"]",
            "                _webpath = self.consumer_config[\"temp_path\"]",
            "                _name = rndstr(10)",
            "                filename = os.path.join(_filedir, _name)",
            "                while os.path.exists(filename):",
            "                    _name = rndstr(10)",
            "                    filename = os.path.join(_filedir, _name)",
            "                fid = open(filename, mode=\"w\")",
            "                fid.write(id_request)",
            "                fid.close()",
            "                _webname = \"%s%s/%s\" % (path, _webpath, _name)",
            "                areq[\"request_uri\"] = _webname",
            "                self.request_uri = _webname",
            "                self._backup(sid)",
            "        else:",
            "            if \"userinfo_claims\" in args:  # can only be carried in an IDRequest",
            "                raise PyoidcError(\"Need a request method\")",
            "",
            "            areq = self.construct_AuthorizationRequest(",
            "                AuthorizationRequest, request_args=args",
            "            )",
            "",
            "        location = areq.request(self.authorization_endpoint)",
            "",
            "        if self.debug:",
            "            _log_info(\"Redirecting to: %s\" % location)",
            "",
            "        self.authz_req[areq[\"state\"]] = areq",
            "        return sid, location",
            "",
            "    def _parse_authz(self, query=\"\", **kwargs):",
            "        _log_info = logger.info",
            "        # Might be an error response",
            "        _log_info(\"Expect Authorization Response\")",
            "        aresp = self.parse_response(",
            "            AuthorizationResponse, info=query, sformat=\"urlencoded\", keyjar=self.keyjar",
            "        )",
            "        if isinstance(aresp, ErrorResponse):",
            "            _log_info(\"ErrorResponse: %s\" % sanitize(aresp))",
            "            raise AuthzError(aresp.get(\"error\"), aresp)",
            "",
            "        _log_info(\"Aresp: %s\" % sanitize(aresp))",
            "",
            "        _state = aresp[\"state\"]",
            "        try:",
            "            self.update(_state)",
            "        except KeyError:",
            "            raise UnknownState(_state, aresp)",
            "",
            "        self.redirect_uris = [self.sdb[_state][\"redirect_uris\"]]",
            "        return aresp, _state",
            "",
            "    def parse_authz(",
            "        self, query=\"\", **kwargs",
            "    ) -> Union[",
            "        http_util.BadRequest,",
            "        Tuple[",
            "            Optional[AuthorizationResponse],",
            "            Optional[AccessTokenResponse],",
            "            Optional[IdToken],",
            "        ],",
            "    ]:",
            "        \"\"\"",
            "        Parse authorization response from server.",
            "",
            "        Couple of cases",
            "        [\"code\"]",
            "        [\"code\", \"token\"]",
            "        [\"code\", \"id_token\", \"token\"]",
            "        [\"id_token\"]",
            "        [\"id_token\", \"token\"]",
            "        [\"token\"]",
            "        \"\"\"",
            "        _log_info = logger.info",
            "        logger.debug(\"- authorization -\")",
            "",
            "        # FIXME: This shouldn't be here... We should rather raise a sepcific Client error",
            "        # That would simplify the return value of this function",
            "        # and drop bunch of assertions from tests added in this commit.",
            "        if not query:",
            "            return http_util.BadRequest(\"Missing query\")",
            "",
            "        _log_info(\"response: %s\" % sanitize(query))",
            "",
            "        if \"algs\" not in kwargs:",
            "            kwargs[\"algs\"] = self.sign_enc_algs(\"id_token\")",
            "        if \"code\" in self.consumer_config[\"response_type\"]:",
            "            aresp, _state = self._parse_authz(query, **kwargs)",
            "",
            "            # May have token and id_token information too",
            "            if \"access_token\" in aresp:",
            "                atr = clean_response(aresp)",
            "                self.access_token = atr",
            "                # update the grant object",
            "                self.get_grant(state=_state).add_token(atr)",
            "            else:",
            "                atr = None",
            "",
            "            self._backup(_state)",
            "",
            "            try:",
            "                idt = aresp[\"id_token\"]",
            "            except KeyError:",
            "                idt = None",
            "            else:",
            "                try:",
            "                    session_update(self.sdb, idt[\"sid\"], \"smid\", _state)",
            "                except KeyError:",
            "                    pass",
            "",
            "        elif \"token\" in self.consumer_config[\"response_type\"]:  # implicit flow",
            "            _log_info(\"Expect Access Token Response\")",
            "            aresp = None",
            "            _state = None",
            "            atr = self.parse_response(",
            "                AccessTokenResponse,",
            "                info=query,",
            "                sformat=\"urlencoded\",",
            "                keyjar=self.keyjar,",
            "                **kwargs,",
            "            )",
            "            if isinstance(atr, ErrorResponse):",
            "                raise TokenError(atr.get(\"error\"), atr)",
            "",
            "            idt = atr.get(\"id_token\")",
            "",
            "        else:  # only id_token",
            "            aresp, _state = self._parse_authz(query, **kwargs)",
            "",
            "            try:",
            "                idt = aresp[\"id_token\"]",
            "            except KeyError:",
            "                idt = None",
            "            else:",
            "                try:",
            "                    session_update(self.sso_db, _state, \"smid\", idt[\"sid\"])",
            "                except KeyError:",
            "                    pass",
            "            # Null the aresp as only id_token should be returned",
            "            aresp = atr = None",
            "",
            "        # Verify the IdToken if it was present",
            "        if idt is not None:",
            "            self.verify_id_token(idt, self.authz_req.get(_state or atr[\"state\"]))",
            "        return aresp, atr, idt",
            "",
            "    def complete(self, state):",
            "        \"\"\"",
            "        Do the access token request, the last step in a code flow.",
            "",
            "        If Implicit flow was used then this method is never used.",
            "        \"\"\"",
            "        args = {\"redirect_uri\": self.redirect_uris[0]}",
            "        if \"password\" in self.consumer_config and self.consumer_config[\"password\"]:",
            "            logger.info(\"basic auth\")",
            "            http_args = {\"password\": self.consumer_config[\"password\"]}",
            "        elif self.client_secret:",
            "            logger.info(\"request_body auth\")",
            "            http_args = {}",
            "            args.update(",
            "                {",
            "                    \"client_secret\": self.client_secret,",
            "                    \"client_id\": self.client_id,",
            "                    \"secret_type\": self.secret_type,",
            "                }",
            "            )",
            "        else:",
            "            raise PyoidcError(\"Nothing to authenticate with\")",
            "",
            "        resp = self.do_access_token_request(",
            "            state=state, request_args=args, http_args=http_args",
            "        )",
            "",
            "        logger.info(\"Access Token Response: %s\" % sanitize(resp))",
            "",
            "        if resp.type() == \"ErrorResponse\":",
            "            raise TokenError(resp.error, resp)",
            "",
            "        self._backup(state)",
            "",
            "        return resp",
            "",
            "    def refresh_token(self):",
            "        pass",
            "",
            "    def get_user_info(self, state):",
            "        uinfo = self.do_user_info_request(state=state, schema=\"openid\")",
            "",
            "        if uinfo.type() == \"ErrorResponse\":",
            "            raise TokenError(uinfo.error, uinfo)",
            "",
            "        self.user_info = uinfo",
            "        self._backup(state)",
            "",
            "        return uinfo",
            "",
            "    def refresh_session(self):",
            "        pass",
            "",
            "    def check_session(self):",
            "        \"\"\"",
            "        Check session endpoint.",
            "",
            "        With python you could use PyQuery to get the onclick attribute of each",
            "        anchor tag, parse that with a regular expression to get the placeId,",
            "        build the /places/duplicates.jsp?inPID= URL yourself, use requests to",
            "        load the content at that URL, then PyQuery again on the content to get",
            "        the data you need.",
            "",
            "        for iframe in mosoup(\"iframe\"):",
            "            mosoup.iframe.extract()",
            "",
            "        It accepts postMessage requests from the relevant RP iframe and uses",
            "        postMessage to post back the login status of the End-User at the OP.",
            "",
            "        :return:",
            "        \"\"\"",
            "        pass",
            "",
            "    def end_session(self):",
            "        pass",
            "",
            "    # LOGOUT related",
            "",
            "    def backchannel_logout(",
            "        self, request: Optional[str] = None, request_args: Optional[Dict] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Receives a back channel logout request.",
            "",
            "        :param request: A urlencoded request",
            "        :param request_args: The request as a dictionary",
            "        :return: A Session Identifier",
            "        \"\"\"",
            "        if request:",
            "            req = BackChannelLogoutRequest().from_urlencoded(request)",
            "        elif request_args is not None:",
            "            req = BackChannelLogoutRequest(**request_args)",
            "        else:",
            "            raise ValueError(\"Missing request specification\")",
            "",
            "        kwargs = {\"aud\": self.client_id, \"iss\": self.issuer, \"keyjar\": self.keyjar}",
            "",
            "        try:",
            "            req.verify(**kwargs)",
            "        except (MessageException, ValueError, NotForMe) as err:",
            "            raise MessageException(\"Bogus logout request: {}\".format(err))",
            "",
            "        # Find the subject through 'sid' or 'sub'",
            "",
            "        try:",
            "            sub = req[\"logout_token\"][\"sub\"]",
            "        except KeyError:",
            "            # verify has guaranteed that there will be a sid if sub is missing",
            "            sm_id = req[\"logout_token\"][\"sid\"]",
            "            _sid = session_get(self.sso_db, \"smid\", sm_id)",
            "        else:",
            "            _sid = session_extended_get(",
            "                self.sso_db, sub, \"issuer\", req[\"logout_token\"][\"iss\"]",
            "            )",
            "",
            "        return _sid"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "367": [
                "Consumer",
                "parse_authz"
            ],
            "378": [
                "Consumer",
                "parse_authz"
            ],
            "379": [
                "Consumer",
                "parse_authz"
            ],
            "413": [
                "Consumer",
                "parse_authz"
            ],
            "426": [
                "Consumer",
                "parse_authz"
            ],
            "427": [
                "Consumer",
                "parse_authz"
            ],
            "441": [
                "Consumer",
                "parse_authz"
            ]
        },
        "addLocation": [
            "src.octoprint.filemanager.storage.LocalFileStorage._copy_metadata_entry",
            "src.oic.oic.consumer.Consumer.begin.args",
            "src.oic.oic.consumer.Consumer.redirect_uris"
        ]
    },
    "src/oic/oic/message.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "     if check_hash:"
            },
            "2": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "         _alg = idt.jws_header[\"alg\"]"
            },
            "3": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # What if _alg == 'none'"
            },
            "4": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        hfunc = \"HS\" + _alg[-3:]"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+        if _alg != \"none\":"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+            hfunc = \"HS\" + _alg[-3:]"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+        else:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+            # This is allowed only for `code` and it needs to be checked by a Client"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+            hfunc = None"
            },
            "11": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 321,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"access_token\" in instance:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        if \"access_token\" in instance and hfunc is not None:"
            },
            "14": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "             if \"at_hash\" not in idt:"
            },
            "15": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "                 raise MissingRequiredAttribute(\"Missing at_hash property\", idt)"
            },
            "16": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "             if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):"
            },
            "17": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "                 raise AtHashError(\"Failed to verify access_token hash\", idt)"
            },
            "18": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"code\" in instance:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        if \"code\" in instance and hfunc is not None:"
            },
            "21": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "             if \"c_hash\" not in idt:"
            },
            "22": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                 raise MissingRequiredAttribute(\"Missing c_hash property\", idt)"
            },
            "23": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "             if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):"
            },
            "24": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": 782,
                "PatchRowcode": "         else:"
            },
            "25": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": 783,
                "PatchRowcode": "             if (_iat + _storage_time) < (_now - _skew):"
            },
            "26": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": 784,
                "PatchRowcode": "                 raise IATError(\"Issued too long ago\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 785,
                "PatchRowcode": "+            if _now < (_iat - _skew):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 786,
                "PatchRowcode": "+                raise IATError(\"Issued in the future\")"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 787,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 788,
                "PatchRowcode": "+        if _exp < _iat:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 789,
                "PatchRowcode": "+            raise EXPError(\"Invalid expiration time\")"
            },
            "32": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": 790,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": 791,
                "PatchRowcode": "         return True"
            },
            "34": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": 792,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import inspect",
            "import json",
            "import logging",
            "import sys",
            "import time",
            "import warnings",
            "from typing import Dict",
            "from typing import List",
            "from urllib.parse import urlencode",
            "from urllib.parse import urlparse",
            "",
            "from jwkest import jws",
            "from jwkest.jwe import JWEException",
            "from jwkest.jwe import factory as JWE_factory",
            "from jwkest.jwt import JWT",
            "",
            "from oic.exception import InvalidRequest",
            "from oic.exception import IssuerMismatch",
            "from oic.exception import MessageException",
            "from oic.exception import NotForMe",
            "from oic.exception import PyoidcError",
            "from oic.oauth2 import message",
            "from oic.oauth2.exception import VerificationError",
            "from oic.oauth2.message import OPTIONAL_LIST_OF_SP_SEP_STRINGS",
            "from oic.oauth2.message import OPTIONAL_LIST_OF_STRINGS",
            "from oic.oauth2.message import REQUIRED_LIST_OF_SP_SEP_STRINGS",
            "from oic.oauth2.message import REQUIRED_LIST_OF_STRINGS",
            "from oic.oauth2.message import SINGLE_OPTIONAL_INT",
            "from oic.oauth2.message import SINGLE_OPTIONAL_JSON",
            "from oic.oauth2.message import SINGLE_OPTIONAL_STRING",
            "from oic.oauth2.message import SINGLE_REQUIRED_STRING",
            "from oic.oauth2.message import Message",
            "from oic.oauth2.message import MessageFactory",
            "from oic.oauth2.message import MessageTuple",
            "from oic.oauth2.message import MissingRequiredAttribute",
            "from oic.oauth2.message import MissingRequiredValue",
            "from oic.oauth2.message import NotAllowedValue",
            "from oic.oauth2.message import ParamDefinition",
            "from oic.oauth2.message import SchemeError",
            "from oic.utils import time_util",
            "from oic.utils.time_util import utc_time_sans_frac",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "NONCE_STORAGE_TIME = 4 * 3600",
            "",
            "",
            "class AtHashError(VerificationError):",
            "    pass",
            "",
            "",
            "class CHashError(VerificationError):",
            "    pass",
            "",
            "",
            "class EXPError(VerificationError):",
            "    pass",
            "",
            "",
            "class IATError(VerificationError):",
            "    pass",
            "",
            "",
            "def json_ser(val, sformat=None, lev=0):",
            "    return json.dumps(val)",
            "",
            "",
            "def json_deser(val, sformat=None, lev=0):",
            "    return json.loads(val)",
            "",
            "",
            "def json_conv(val, sformat=None, lev=0):",
            "    if isinstance(val, dict):",
            "        for key, _val in val.items():",
            "            if _val is None:",
            "                val[key] = \"none\"",
            "            elif _val is True:",
            "                val[key] = \"true\"",
            "            elif _val is False:",
            "                val[key] = \"false\"",
            "",
            "    return val",
            "",
            "",
            "def json_rest(val, sformat=None, lev=0):",
            "    if isinstance(val, dict):",
            "        for key, _val in val.items():",
            "            if _val == \"none\":",
            "                val[key] = None",
            "            elif _val == \"true\":",
            "                val[key] = True",
            "            elif _val == \"false\":",
            "                val[key] = False",
            "",
            "    return val",
            "",
            "",
            "# value type, required, serializer, deserializer, null value allowed",
            "SINGLE_OPTIONAL_BOOLEAN = ParamDefinition(bool, False, None, None, False)",
            "SINGLE_OPTIONAL_JSON_WN = ParamDefinition(dict, False, json_ser, json_deser, True)",
            "SINGLE_OPTIONAL_JSON_CONV = ParamDefinition(dict, False, json_conv, json_rest, True)",
            "SINGLE_REQUIRED_INT = ParamDefinition(int, True, None, None, False)",
            "",
            "",
            "def idtoken_deser(val, sformat=\"urlencoded\"):",
            "    # id_token are always serialized as a JWT",
            "    return IdToken().deserialize(val, \"jwt\")",
            "",
            "",
            "def address_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "        elif sformat == \"dict\":",
            "            sformat = \"json\"",
            "    return AddressClaim().deserialize(val, sformat)",
            "",
            "",
            "def claims_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return Claims().deserialize(val, sformat)",
            "",
            "",
            "def message_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return Message().deserialize(val, sformat)",
            "",
            "",
            "def msg_ser(inst, sformat, lev=0):",
            "    if sformat in [\"urlencoded\", \"json\"]:",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        else:",
            "            res = inst",
            "    elif sformat == \"dict\":",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        elif isinstance(inst, dict):",
            "            res = inst",
            "        elif isinstance(inst, str):  # Iff ID Token",
            "            res = inst",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(inst))",
            "    else:",
            "        raise PyoidcError(\"Unknown sformat\", inst)",
            "",
            "    return res",
            "",
            "",
            "def msg_ser_json(inst, sformat=\"json\", lev=0):",
            "    # sformat = \"json\" always except when dict",
            "    if lev:",
            "        sformat = \"dict\"",
            "",
            "    if sformat == \"dict\":",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        elif isinstance(inst, dict):",
            "            res = inst",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(inst))",
            "    else:",
            "        sformat = \"json\"",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        else:",
            "            res = inst",
            "",
            "    return res",
            "",
            "",
            "def msg_list_ser(insts, sformat, lev=0):",
            "    return [msg_ser(inst, sformat, lev) for inst in insts]",
            "",
            "",
            "def claims_ser(val, sformat=\"urlencoded\", lev=0):",
            "    # everything in c_extension",
            "    if isinstance(val, str):",
            "        item = val",
            "    elif isinstance(val, list):",
            "        item = val[0]",
            "    else:",
            "        item = val",
            "",
            "    if isinstance(item, Message):",
            "        return item.serialize(method=sformat, lev=lev + 1)",
            "",
            "    if sformat == \"urlencoded\":",
            "        assert isinstance(  # nosec",
            "            item, dict",
            "        )  # We cannot urlencode anything else than Mapping",
            "        res = urlencode(item)",
            "    elif sformat == \"json\":",
            "        if lev:",
            "            res = item",
            "        else:",
            "            res = json.dumps(item)",
            "    elif sformat == \"dict\":",
            "        if isinstance(item, dict):",
            "            res = item",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(item))",
            "    else:",
            "        raise PyoidcError(\"Unknown sformat: %s\" % sformat, val)",
            "",
            "    return res",
            "",
            "",
            "def registration_request_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return RegistrationRequest().deserialize(val, sformat)",
            "",
            "",
            "def claims_request_deser(val, sformat=\"json\"):",
            "    # never 'urlencoded'",
            "    if sformat == \"urlencoded\":",
            "        sformat = \"json\"",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return ClaimsRequest().deserialize(val, sformat)",
            "",
            "",
            "OPTIONAL_ADDRESS = ParamDefinition(Message, False, msg_ser, address_deser, False)",
            "OPTIONAL_LOGICAL = ParamDefinition(bool, False, None, None, False)",
            "OPTIONAL_MULTIPLE_Claims = ParamDefinition(",
            "    Message, False, claims_ser, claims_deser, False",
            ")",
            "",
            "SINGLE_OPTIONAL_IDTOKEN = ParamDefinition(str, False, msg_ser, None, False)",
            "",
            "SINGLE_OPTIONAL_REGISTRATION_REQUEST = ParamDefinition(",
            "    Message, False, msg_ser, registration_request_deser, False",
            ")",
            "SINGLE_OPTIONAL_CLAIMSREQ = ParamDefinition(",
            "    Message, False, msg_ser_json, claims_request_deser, False",
            ")",
            "",
            "OPTIONAL_MESSAGE = ParamDefinition(Message, False, msg_ser, message_deser, False)",
            "REQUIRED_MESSAGE = ParamDefinition(Message, True, msg_ser, message_deser, False)",
            "",
            "# ----------------------------------------------------------------------------",
            "",
            "",
            "SCOPE_CHARSET = []",
            "for char in [\"\\x21\", (\"\\x23\", \"\\x5b\"), (\"\\x5d\", \"\\x7E\")]:",
            "    if isinstance(char, tuple):",
            "        c = char[0]",
            "        while c <= char[1]:",
            "            SCOPE_CHARSET.append(c)",
            "            c = chr(ord(c) + 1)",
            "    else:",
            "        SCOPE_CHARSET.append(set)",
            "",
            "",
            "def check_char_set(string, allowed):",
            "    for c in string:",
            "        if c not in allowed:",
            "            raise NotAllowedValue(\"'%c' not in the allowed character set\" % c)",
            "",
            "",
            "TOKEN_VERIFY_ARGS = [\"key\", \"keyjar\", \"algs\", \"sender\"]",
            "",
            "",
            "def verify_id_token(instance, check_hash=False, **kwargs):",
            "    # Try to decode the JWT, checks the signature",
            "    args = {}",
            "    for arg in TOKEN_VERIFY_ARGS:",
            "        try:",
            "            args[arg] = kwargs[arg]",
            "        except KeyError:",
            "            pass",
            "",
            "    _jws = str(instance[\"id_token\"])",
            "",
            "    # It can be encrypted, so try to decrypt first",
            "    _jwe = JWE_factory(_jws)",
            "    if _jwe is not None:",
            "        try:",
            "            _jws = _jwe.decrypt(keys=kwargs[\"keyjar\"].get_decrypt_key())",
            "        except JWEException as err:",
            "            raise VerificationError(\"Could not decrypt id_token\", err)",
            "    _packer = JWT()",
            "    _body = _packer.unpack(_jws).payload()",
            "",
            "    if \"keyjar\" in kwargs:",
            "        try:",
            "            if _body[\"iss\"] not in kwargs[\"keyjar\"]:",
            "                raise ValueError(\"Unknown issuer\")",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"iss\")",
            "",
            "    if _jwe is not None:",
            "        # Use the original encrypted token to set correct headers",
            "        idt = IdToken().from_jwt(str(instance[\"id_token\"]), **args)",
            "    else:",
            "        idt = IdToken().from_jwt(_jws, **args)",
            "    if not idt.verify(**kwargs):",
            "        raise VerificationError(\"Could not verify id_token\", idt)",
            "",
            "    if check_hash:",
            "        _alg = idt.jws_header[\"alg\"]",
            "        # What if _alg == 'none'",
            "",
            "        hfunc = \"HS\" + _alg[-3:]",
            "",
            "        if \"access_token\" in instance:",
            "            if \"at_hash\" not in idt:",
            "                raise MissingRequiredAttribute(\"Missing at_hash property\", idt)",
            "            if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):",
            "                raise AtHashError(\"Failed to verify access_token hash\", idt)",
            "",
            "        if \"code\" in instance:",
            "            if \"c_hash\" not in idt:",
            "                raise MissingRequiredAttribute(\"Missing c_hash property\", idt)",
            "            if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):",
            "                raise CHashError(\"Failed to verify code hash\", idt)",
            "",
            "    return idt",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "",
            "",
            "class RefreshAccessTokenRequest(message.RefreshAccessTokenRequest):",
            "    pass",
            "",
            "",
            "class TokenErrorResponse(message.TokenErrorResponse):",
            "    pass",
            "",
            "",
            "class AccessTokenResponse(message.AccessTokenResponse):",
            "    c_param = message.AccessTokenResponse.c_param.copy()",
            "    c_param.update({\"id_token\": SINGLE_OPTIONAL_STRING})",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            # replace the JWT with the verified IdToken instance",
            "            self[\"id_token\"] = verify_id_token(self, **kwargs)",
            "",
            "        return True",
            "",
            "",
            "class UserInfoRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "class AuthorizationResponse(message.AuthorizationResponse, message.AccessTokenResponse):",
            "    c_param = message.AuthorizationResponse.c_param.copy()",
            "    c_param.update(message.AccessTokenResponse.c_param)",
            "    c_param.update(",
            "        {",
            "            \"code\": SINGLE_OPTIONAL_STRING,",
            "            \"access_token\": SINGLE_OPTIONAL_STRING,",
            "            \"token_type\": SINGLE_OPTIONAL_STRING,",
            "            \"id_token\": SINGLE_OPTIONAL_IDTOKEN,",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"aud\" in self:",
            "            if \"client_id\" in kwargs:",
            "                # check that it's for me",
            "                if kwargs[\"client_id\"] not in self[\"aud\"]:",
            "                    return False",
            "",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "        if \"access_token\" in self:",
            "            if \"token_type\" not in self:",
            "                raise MissingRequiredValue(\"Missing token_type parameter\", self)",
            "",
            "        return True",
            "",
            "",
            "class AuthorizationErrorResponse(message.AuthorizationErrorResponse):",
            "    c_allowed_values = message.AuthorizationErrorResponse.c_allowed_values.copy()",
            "    c_allowed_values[\"error\"].extend(",
            "        [",
            "            \"interaction_required\",",
            "            \"login_required\",",
            "            \"session_selection_required\",",
            "            \"consent_required\",",
            "            \"invalid_request_uri\",",
            "            \"invalid_request_object\",",
            "            \"registration_not_supported\",",
            "            \"request_not_supported\",",
            "            \"request_uri_not_supported\",",
            "        ]",
            "    )",
            "",
            "",
            "class AuthorizationRequest(message.AuthorizationRequest):",
            "    c_param = message.AuthorizationRequest.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"scope\": REQUIRED_LIST_OF_SP_SEP_STRINGS,",
            "            \"redirect_uri\": SINGLE_REQUIRED_STRING,",
            "            \"nonce\": SINGLE_OPTIONAL_STRING,",
            "            \"display\": SINGLE_OPTIONAL_STRING,",
            "            \"prompt\": OPTIONAL_LIST_OF_STRINGS,",
            "            \"max_age\": SINGLE_OPTIONAL_INT,",
            "            \"ui_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"claims_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"id_token_hint\": SINGLE_OPTIONAL_STRING,",
            "            \"login_hint\": SINGLE_OPTIONAL_STRING,",
            "            \"acr_values\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"claims\": SINGLE_OPTIONAL_CLAIMSREQ,",
            "            \"registration\": SINGLE_OPTIONAL_JSON,",
            "            \"request\": SINGLE_OPTIONAL_STRING,",
            "            \"request_uri\": SINGLE_OPTIONAL_STRING,",
            "            \"response_mode\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "    c_allowed_values = message.AuthorizationRequest.c_allowed_values.copy()",
            "    c_allowed_values.update(",
            "        {",
            "            \"display\": [\"page\", \"popup\", \"touch\", \"wap\"],",
            "            \"prompt\": [\"none\", \"login\", \"consent\", \"select_account\"],",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        \"\"\"",
            "        Check that the request is valid.",
            "",
            "        Authorization Request parameters that are OPTIONAL in the OAuth 2.0",
            "        specification MAY be included in the OpenID Request Object without also",
            "        passing them as OAuth 2.0 Authorization Request parameters, with one",
            "        exception: The scope parameter MUST always be present in OAuth 2.0",
            "        Authorization Request parameters.",
            "        All parameter values that are present both in the OAuth 2.0",
            "        Authorization Request and in the OpenID Request Object MUST exactly match.",
            "        \"\"\"",
            "        super().verify(**kwargs)",
            "",
            "        args = {}",
            "        for arg in [\"key\", \"keyjar\", \"opponent_id\", \"sender\"]:",
            "            try:",
            "                args[arg] = kwargs[arg]",
            "            except KeyError:",
            "                pass",
            "",
            "        if \"opponent_id\" not in kwargs:",
            "            args[\"opponent_id\"] = self[\"client_id\"]",
            "",
            "        if \"request\" in self:",
            "            if isinstance(self[\"request\"], str):",
            "                # Try to decode the JWT, checks the signature",
            "                oidr = OpenIDRequest().from_jwt(str(self[\"request\"]), **args)",
            "",
            "                # verify that nothing is change in the original message",
            "                for key, val in oidr.items():",
            "                    if key in self and self[key] != val:",
            "                        raise AssertionError()",
            "",
            "                # replace the JWT with the parsed and verified instance",
            "                self[\"request\"] = oidr",
            "",
            "        if \"id_token_hint\" in self:",
            "            if isinstance(self[\"id_token_hint\"], str):",
            "                idt = IdToken().from_jwt(str(self[\"id_token_hint\"]), **args)",
            "                self[\"id_token_hint\"] = idt",
            "",
            "        if \"response_type\" not in self:",
            "            raise MissingRequiredAttribute(\"response_type missing\", self)",
            "",
            "        _rt = self[\"response_type\"]",
            "        if \"token\" in _rt or \"id_token\" in _rt:",
            "            if \"nonce\" not in self:",
            "                raise MissingRequiredAttribute(\"Nonce missing\", self)",
            "",
            "        if \"openid\" not in self.get(\"scope\", []):",
            "            raise MissingRequiredValue(\"openid not in scope\", self)",
            "",
            "        if \"offline_access\" in self.get(\"scope\", []):",
            "            if \"prompt\" not in self or \"consent\" not in self[\"prompt\"]:",
            "                raise MissingRequiredValue(\"consent in prompt\", self)",
            "",
            "        if \"prompt\" in self:",
            "            if \"none\" in self[\"prompt\"] and len(self[\"prompt\"]) > 1:",
            "                raise InvalidRequest(\"prompt none combined with other value\", self)",
            "",
            "        return True",
            "",
            "",
            "class AccessTokenRequest(message.AccessTokenRequest):",
            "    c_param = message.AccessTokenRequest.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"client_assertion_type\": SINGLE_OPTIONAL_STRING,",
            "            \"client_assertion\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "    c_default = {\"grant_type\": \"authorization_code\"}",
            "    c_allowed_values = {",
            "        \"client_assertion_type\": [",
            "            \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"",
            "        ]",
            "    }",
            "",
            "",
            "class AddressClaim(Message):",
            "    c_param = {",
            "        \"formatted\": SINGLE_OPTIONAL_STRING,",
            "        \"street_address\": SINGLE_OPTIONAL_STRING,",
            "        \"locality\": SINGLE_OPTIONAL_STRING,",
            "        \"region\": SINGLE_OPTIONAL_STRING,",
            "        \"postal_code\": SINGLE_OPTIONAL_STRING,",
            "        \"country\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "class OpenIDSchema(Message):",
            "    c_param = {",
            "        \"sub\": SINGLE_REQUIRED_STRING,",
            "        \"name\": SINGLE_OPTIONAL_STRING,",
            "        \"given_name\": SINGLE_OPTIONAL_STRING,",
            "        \"family_name\": SINGLE_OPTIONAL_STRING,",
            "        \"middle_name\": SINGLE_OPTIONAL_STRING,",
            "        \"nickname\": SINGLE_OPTIONAL_STRING,",
            "        \"preferred_username\": SINGLE_OPTIONAL_STRING,",
            "        \"profile\": SINGLE_OPTIONAL_STRING,",
            "        \"picture\": SINGLE_OPTIONAL_STRING,",
            "        \"website\": SINGLE_OPTIONAL_STRING,",
            "        \"email\": SINGLE_OPTIONAL_STRING,",
            "        \"email_verified\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"gender\": SINGLE_OPTIONAL_STRING,",
            "        \"birthdate\": SINGLE_OPTIONAL_STRING,",
            "        \"zoneinfo\": SINGLE_OPTIONAL_STRING,",
            "        \"locale\": SINGLE_OPTIONAL_STRING,",
            "        \"phone_number\": SINGLE_OPTIONAL_STRING,",
            "        \"phone_number_verified\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"address\": OPTIONAL_ADDRESS,",
            "        \"updated_at\": SINGLE_OPTIONAL_INT,",
            "        \"_claim_names\": OPTIONAL_MESSAGE,",
            "        \"_claim_sources\": OPTIONAL_MESSAGE,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"birthdate\" in self:",
            "            # Either YYYY-MM-DD or just YYYY or 0000-MM-DD",
            "            try:",
            "                time.strptime(self[\"birthdate\"], \"%Y-%m-%d\")",
            "            except ValueError:",
            "                try:",
            "                    time.strptime(self[\"birthdate\"], \"%Y\")",
            "                except ValueError:",
            "                    try:",
            "                        time.strptime(self[\"birthdate\"], \"0000-%m-%d\")",
            "                    except ValueError:",
            "                        raise VerificationError(\"Birthdate format error\", self)",
            "",
            "        if any(val is None for val in self.values()):",
            "            return False",
            "",
            "        return True",
            "",
            "",
            "class RegistrationRequest(Message):",
            "    c_param = {",
            "        \"redirect_uris\": REQUIRED_LIST_OF_STRINGS,",
            "        \"response_types\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"grant_types\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"application_type\": SINGLE_OPTIONAL_STRING,",
            "        \"contacts\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"client_name\": SINGLE_OPTIONAL_STRING,",
            "        \"logo_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"client_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"policy_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"tos_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"sector_identifier_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"subject_type\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_signed_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_signed_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_signing_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_encryption_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_encryption_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"token_endpoint_auth_method\": SINGLE_OPTIONAL_STRING,",
            "        \"token_endpoint_auth_signing_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"default_max_age\": SINGLE_OPTIONAL_INT,",
            "        \"require_auth_time\": OPTIONAL_LOGICAL,",
            "        \"default_acr_values\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"initiate_login_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"request_uris\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"post_logout_redirect_uris\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"frontchannel_logout_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"frontchannel_logout_session_required\": OPTIONAL_LOGICAL,",
            "        \"backchannel_logout_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"backchannel_logout_session_required\": OPTIONAL_LOGICAL,",
            "    }",
            "    c_default = {\"application_type\": \"web\", \"response_types\": [\"code\"]}",
            "    c_allowed_values = {",
            "        \"application_type\": [\"native\", \"web\"],",
            "        \"subject_type\": [\"public\", \"pairwise\"],",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"initiate_login_uri\" in self and not self[\"initiate_login_uri\"].startswith(",
            "            \"https:\"",
            "        ):",
            "            raise AssertionError()",
            "",
            "        for param in [",
            "            \"request_object_encryption\",",
            "            \"id_token_encrypted_response\",",
            "            \"userinfo_encrypted_response\",",
            "        ]:",
            "            alg_param = \"%s_alg\" % param",
            "            enc_param = \"%s_enc\" % param",
            "            if alg_param in self:",
            "                if enc_param not in self:",
            "                    self[enc_param] = \"A128CBC-HS256\"",
            "",
            "            # both or none",
            "            if enc_param in self and alg_param not in self:",
            "                raise AssertionError()",
            "",
            "        if (",
            "            \"token_endpoint_auth_signing_alg\" in self",
            "            and self[\"token_endpoint_auth_signing_alg\"] == \"none\"",
            "        ):",
            "            raise AssertionError()",
            "",
            "        return True",
            "",
            "",
            "class RegistrationResponse(Message):",
            "    \"\"\"Response to client_register registration requests.\"\"\"",
            "",
            "    c_param = {",
            "        \"client_id\": SINGLE_REQUIRED_STRING,",
            "        \"client_secret\": SINGLE_OPTIONAL_STRING,",
            "        \"registration_access_token\": SINGLE_OPTIONAL_STRING,",
            "        \"registration_client_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"client_id_issued_at\": SINGLE_OPTIONAL_INT,",
            "        \"client_secret_expires_at\": SINGLE_OPTIONAL_INT,",
            "    }",
            "    c_param.update(RegistrationRequest.c_param)",
            "",
            "    def verify(self, **kwargs):",
            "        \"\"\"",
            "        Verify that the response is valid.",
            "",
            "        Implementations MUST either return both a Client Configuration Endpoint",
            "        and a Registration Access Token or neither of them.",
            "        :param kwargs:",
            "        :return: True if the message is OK otherwise False",
            "        \"\"\"",
            "        super(RegistrationResponse, self).verify(**kwargs)",
            "",
            "        has_reg_uri = \"registration_client_uri\" in self",
            "        has_reg_at = \"registration_access_token\" in self",
            "        if has_reg_uri != has_reg_at:",
            "            raise VerificationError(",
            "                (",
            "                    \"Only one of registration_client_uri\"",
            "                    \" and registration_access_token present\"",
            "                ),",
            "                self,",
            "            )",
            "",
            "        return True",
            "",
            "",
            "class ClientRegistrationErrorResponse(message.ErrorResponse):",
            "    c_allowed_values = {",
            "        \"error\": [",
            "            \"invalid_redirect_uri\",",
            "            \"invalid_client_metadata\",",
            "            \"invalid_configuration_parameter\",",
            "        ]",
            "    }",
            "",
            "",
            "class IdToken(OpenIDSchema):",
            "    c_param = OpenIDSchema.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"iss\": SINGLE_REQUIRED_STRING,",
            "            \"sub\": SINGLE_REQUIRED_STRING,",
            "            \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "            \"exp\": SINGLE_REQUIRED_INT,",
            "            \"iat\": SINGLE_REQUIRED_INT,",
            "            \"auth_time\": SINGLE_OPTIONAL_INT,",
            "            \"nonce\": SINGLE_OPTIONAL_STRING,",
            "            \"at_hash\": SINGLE_OPTIONAL_STRING,",
            "            \"c_hash\": SINGLE_OPTIONAL_STRING,",
            "            \"acr\": SINGLE_OPTIONAL_STRING,",
            "            \"amr\": OPTIONAL_LIST_OF_STRINGS,",
            "            \"azp\": SINGLE_OPTIONAL_STRING,",
            "            \"sub_jwk\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super(IdToken, self).verify(**kwargs)",
            "",
            "        try:",
            "            if kwargs[\"iss\"] != self[\"iss\"]:",
            "                raise IssuerMismatch(\"{} != {}\".format(kwargs[\"iss\"], self[\"iss\"]))",
            "        except KeyError:",
            "            pass",
            "",
            "        if \"aud\" in self:",
            "            if \"client_id\" in kwargs:",
            "                # check that I'm among the recipients",
            "                if kwargs[\"client_id\"] not in self[\"aud\"]:",
            "                    raise NotForMe(",
            "                        \"{} not in aud:{}\".format(kwargs[\"client_id\"], self[\"aud\"]),",
            "                        self,",
            "                    )",
            "",
            "            # Then azp has to be present and be one of the aud values",
            "            if len(self[\"aud\"]) > 1:",
            "                if \"azp\" not in self:",
            "                    raise VerificationError(\"azp missing\", self)",
            "                if self[\"azp\"] not in self[\"aud\"]:",
            "                    raise VerificationError(\"Mismatch between azp and aud claims\", self)",
            "",
            "        if \"azp\" in self:",
            "            if \"client_id\" in kwargs:",
            "                if kwargs[\"client_id\"] != self[\"azp\"]:",
            "                    raise NotForMe(",
            "                        \"{} != azp:{}\".format(kwargs[\"client_id\"], self[\"azp\"]), self",
            "                    )",
            "",
            "        _now = time_util.utc_time_sans_frac()",
            "",
            "        try:",
            "            _skew = kwargs[\"skew\"]",
            "        except KeyError:",
            "            _skew = 0",
            "",
            "        try:",
            "            _exp = self[\"exp\"]",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"exp\")",
            "        else:",
            "            if (_now - _skew) > _exp:",
            "                raise EXPError(\"Invalid expiration time\")",
            "",
            "        try:",
            "            _storage_time = kwargs[\"nonce_storage_time\"]",
            "        except KeyError:",
            "            _storage_time = NONCE_STORAGE_TIME",
            "",
            "        try:",
            "            _iat = self[\"iat\"]",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"iat\")",
            "        else:",
            "            if (_iat + _storage_time) < (_now - _skew):",
            "                raise IATError(\"Issued too long ago\")",
            "",
            "        return True",
            "",
            "",
            "class StateFullMessage(Message):",
            "    c_param = {\"state\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class RefreshSessionRequest(StateFullMessage):",
            "    c_param = StateFullMessage.c_param.copy()",
            "    c_param.update(",
            "        {\"id_token\": SINGLE_REQUIRED_STRING, \"redirect_url\": SINGLE_REQUIRED_STRING}",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super(RefreshSessionRequest, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class RefreshSessionResponse(StateFullMessage):",
            "    c_param = StateFullMessage.c_param.copy()",
            "    c_param.update({\"id_token\": SINGLE_REQUIRED_STRING})",
            "",
            "    def verify(self, **kwargs):",
            "        super(RefreshSessionResponse, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class CheckSessionRequest(Message):",
            "    c_param = {\"id_token\": SINGLE_REQUIRED_STRING}",
            "",
            "    def verify(self, **kwargs):",
            "        super(CheckSessionRequest, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class CheckIDRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class EndSessionRequest(Message):",
            "    c_param = {",
            "        \"id_token_hint\": SINGLE_OPTIONAL_STRING,",
            "        \"post_logout_redirect_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"state\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "class EndSessionResponse(Message):",
            "    c_param = {\"state\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "class Claims(Message):",
            "    pass",
            "",
            "",
            "class ClaimsRequest(Message):",
            "    c_param = {",
            "        \"userinfo\": OPTIONAL_MULTIPLE_Claims,",
            "        \"id_token\": OPTIONAL_MULTIPLE_Claims,",
            "    }",
            "",
            "",
            "class OpenIDRequest(AuthorizationRequest):",
            "    pass",
            "",
            "",
            "class ProviderConfigurationResponse(Message):",
            "    c_param = {",
            "        \"issuer\": SINGLE_REQUIRED_STRING,",
            "        \"authorization_endpoint\": SINGLE_REQUIRED_STRING,",
            "        \"token_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks_uri\": SINGLE_REQUIRED_STRING,",
            "        \"registration_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"scopes_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"response_types_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"response_modes_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"grant_types_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"acr_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"subject_types_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"id_token_signing_alg_values_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"id_token_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"id_token_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"token_endpoint_auth_methods_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"token_endpoint_auth_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"display_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claim_types_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claims_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"service_documentation\": SINGLE_OPTIONAL_STRING,",
            "        \"claims_locales_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"ui_locales_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claims_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"request_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"request_uri_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"require_request_uri_registration\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"op_policy_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"op_tos_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"check_session_iframe\": SINGLE_OPTIONAL_STRING,",
            "        \"end_session_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"frontchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"frontchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"backchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"backchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "    }",
            "    c_default = {",
            "        \"version\": \"3.0\",",
            "        \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\"],",
            "        \"claims_parameter_supported\": False,",
            "        \"request_parameter_supported\": False,",
            "        \"request_uri_parameter_supported\": True,",
            "        \"require_request_uri_registration\": False,",
            "        \"grant_types_supported\": [\"authorization_code\", \"implicit\"],",
            "        \"frontchannel_logout_supported\": False,",
            "        \"frontchannel_logout_session_supported\": False,",
            "        \"backchannel_logout_supported\": False,",
            "        \"backchannel_logout_session_supported\": False,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"scopes_supported\" in self:",
            "            if \"openid\" not in self[\"scopes_supported\"]:",
            "                raise AssertionError()",
            "            for scope in self[\"scopes_supported\"]:",
            "                check_char_set(scope, SCOPE_CHARSET)",
            "",
            "        parts = urlparse(self[\"issuer\"])",
            "        if parts.scheme != \"https\":",
            "            raise SchemeError(\"Not HTTPS\")",
            "",
            "        if parts.query or parts.fragment:",
            "            raise AssertionError()",
            "",
            "        if (",
            "            any(\"code\" in rt for rt in self[\"response_types_supported\"])",
            "            and \"token_endpoint\" not in self",
            "        ):",
            "            raise MissingRequiredAttribute(\"token_endpoint\")",
            "",
            "        return True",
            "",
            "",
            "class AuthnToken(Message):",
            "    c_param = {",
            "        \"iss\": SINGLE_REQUIRED_STRING,",
            "        \"sub\": SINGLE_REQUIRED_STRING,",
            "        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"jti\": SINGLE_REQUIRED_STRING,",
            "        \"exp\": SINGLE_REQUIRED_INT,",
            "        \"iat\": SINGLE_OPTIONAL_INT,",
            "    }",
            "",
            "",
            "# According to RFC 7519 all claims are optional",
            "class JasonWebToken(Message):",
            "    c_param = {",
            "        \"iss\": SINGLE_OPTIONAL_STRING,",
            "        \"sub\": SINGLE_OPTIONAL_STRING,",
            "        \"aud\": OPTIONAL_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"exp\": SINGLE_OPTIONAL_INT,",
            "        \"nbf\": SINGLE_OPTIONAL_INT,",
            "        \"iat\": SINGLE_OPTIONAL_INT,",
            "        \"jti\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "def jwt_deser(val, sformat=\"json\"):",
            "    if sformat == \"urlencoded\":",
            "        sformat = \"json\"",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return JasonWebToken().deserialize(val, sformat)",
            "",
            "",
            "SINGLE_OPTIONAL_JWT = ParamDefinition(Message, False, msg_ser, jwt_deser, False)",
            "",
            "",
            "class UserInfoErrorResponse(message.ErrorResponse):",
            "    c_allowed_values = {",
            "        \"error\": [",
            "            \"invalid_schema\",",
            "            \"invalid_request\",",
            "            \"invalid_token\",",
            "            \"insufficient_scope\",",
            "        ]",
            "    }",
            "",
            "",
            "class DiscoveryRequest(Message):",
            "    c_param = {\"principal\": SINGLE_REQUIRED_STRING, \"service\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class DiscoveryResponse(Message):",
            "    c_param = {\"locations\": REQUIRED_LIST_OF_STRINGS}",
            "",
            "",
            "class ResourceRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "SCOPE2CLAIMS: Dict[str, List[str]] = {",
            "    \"openid\": [\"sub\"],",
            "    \"profile\": [",
            "        \"name\",",
            "        \"given_name\",",
            "        \"family_name\",",
            "        \"middle_name\",",
            "        \"nickname\",",
            "        \"profile\",",
            "        \"picture\",",
            "        \"website\",",
            "        \"gender\",",
            "        \"birthdate\",",
            "        \"zoneinfo\",",
            "        \"locale\",",
            "        \"updated_at\",",
            "        \"preferred_username\",",
            "    ],",
            "    \"email\": [\"email\", \"email_verified\"],",
            "    \"address\": [\"address\"],",
            "    \"phone\": [\"phone_number\", \"phone_number_verified\"],",
            "    \"offline_access\": [],",
            "}",
            "",
            "# LOGOUT related messages",
            "",
            "SINGLE_OPTIONAL_JSON = ParamDefinition(dict, False, json_ser, json_deser, False)",
            "SINGLE_REQUIRED_JSON = ParamDefinition(dict, True, json_ser, json_deser, False)",
            "",
            "BACK_CHANNEL_LOGOUT_EVENT = \"http://schemas.openid.net/event/backchannel-logout\"",
            "",
            "",
            "class LogoutToken(Message):",
            "    \"\"\"Defined in https://openid.net/specs/openid-connect-backchannel-1_0.html#LogoutToken .\"\"\"",
            "",
            "    c_param = {",
            "        \"iss\": SINGLE_REQUIRED_STRING,",
            "        \"sub\": SINGLE_OPTIONAL_STRING,",
            "        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"iat\": SINGLE_REQUIRED_INT,",
            "        \"jti\": SINGLE_REQUIRED_STRING,",
            "        \"events\": SINGLE_REQUIRED_JSON,",
            "        \"sid\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"nonce\" in self:",
            "            raise MessageException(",
            "                '\"nonce\" is prohibited from appearing in a LogoutToken.'",
            "            )",
            "",
            "        # Check the 'events' JSON",
            "        _keys = list(self[\"events\"].keys())",
            "        if len(_keys) != 1:",
            "            raise ValueError('Must only be one member in \"events\"')",
            "        if _keys[0] != BACK_CHANNEL_LOGOUT_EVENT:",
            "            raise ValueError('Wrong member in \"events\"')",
            "        if self[\"events\"][_keys[0]] != {}:",
            "            raise ValueError('Wrong member value in \"events\"')",
            "",
            "        # There must be either a 'sub' or a 'sid', and may contain both",
            "        if not (\"sub\" in self or \"sid\" in self):",
            "            raise ValueError('There MUST be either a \"sub\" or a \"sid\"')",
            "",
            "        try:",
            "            if kwargs[\"aud\"] not in self[\"aud\"]:",
            "                raise NotForMe(\"Not among intended audience\")",
            "        except KeyError:",
            "            pass",
            "",
            "        try:",
            "            if kwargs[\"iss\"] != self[\"iss\"]:",
            "                raise NotForMe(\"Wrong issuer\")",
            "        except KeyError:",
            "            pass",
            "",
            "        _now = utc_time_sans_frac()",
            "",
            "        _skew = kwargs.get(\"skew\", 0)",
            "        _iat = self.get(\"iat\", 0)",
            "",
            "        if _iat and _iat > (_now + _skew):",
            "            raise ValueError(\"Invalid issued_at time\")",
            "",
            "        return True",
            "",
            "",
            "ID_TOKEN_VERIFY_ARGS = [",
            "    \"keyjar\",",
            "    \"verify\",",
            "    \"encalg\",",
            "    \"encenc\",",
            "    \"sigalg\",",
            "    \"issuer\",",
            "    \"allow_missing_kid\",",
            "    \"no_kid_issuer\",",
            "    \"trusting\",",
            "    \"skew\",",
            "    \"nonce_storage_time\",",
            "    \"client_id\",",
            "]",
            "",
            "",
            "class BackChannelLogoutRequest(Message):",
            "    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-backchannel-1_0.html .\"\"\"",
            "",
            "    c_param = {\"logout_token\": SINGLE_REQUIRED_STRING}",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        args = {arg: kwargs[arg] for arg in TOKEN_VERIFY_ARGS if arg in kwargs}",
            "",
            "        logout_token = LogoutToken().from_jwt(str(self[\"logout_token\"]), **args)",
            "        logout_token.verify(**kwargs)",
            "",
            "        self[\"logout_token\"] = logout_token",
            "        logger.info(\"Verified Logout Token: {}\".format(logout_token.to_dict()))",
            "",
            "        return True",
            "",
            "",
            "class FrontChannelLogoutRequest(Message):",
            "    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-frontchannel-1_0.html .\"\"\"",
            "",
            "    c_param = {\"iss\": SINGLE_OPTIONAL_STRING, \"sid\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "MSG = {",
            "    \"RefreshAccessTokenRequest\": RefreshAccessTokenRequest,",
            "    \"TokenErrorResponse\": TokenErrorResponse,",
            "    \"AccessTokenResponse\": AccessTokenResponse,",
            "    \"UserInfoRequest\": UserInfoRequest,",
            "    \"AuthorizationResponse\": AuthorizationResponse,",
            "    \"AuthorizationErrorResponse\": AuthorizationErrorResponse,",
            "    \"AuthorizationRequest\": AuthorizationRequest,",
            "    \"AccessTokenRequest\": AccessTokenRequest,",
            "    \"AddressClaim\": AddressClaim,",
            "    \"OpenIDSchema\": OpenIDSchema,",
            "    \"RegistrationRequest\": RegistrationRequest,",
            "    \"RegistrationResponse\": RegistrationResponse,",
            "    \"ClientRegistrationErrorResponse\": ClientRegistrationErrorResponse,",
            "    \"IdToken\": IdToken,",
            "    \"RefreshSessionRequest\": RefreshSessionRequest,",
            "    \"RefreshSessionResponse\": RefreshSessionResponse,",
            "    \"CheckSessionRequest\": CheckSessionRequest,",
            "    \"CheckIDRequest\": CheckIDRequest,",
            "    \"EndSessionRequest\": EndSessionRequest,",
            "    \"EndSessionResponse\": EndSessionResponse,",
            "    \"Claims\": Claims,",
            "    \"OpenIDRequest\": OpenIDRequest,",
            "    \"ProviderConfigurationResponse\": ProviderConfigurationResponse,",
            "    \"AuthnToken\": AuthnToken,",
            "    \"UserInfoErrorResponse\": UserInfoErrorResponse,",
            "    \"DiscoveryRequest\": DiscoveryRequest,",
            "    \"DiscoveryResponse\": DiscoveryResponse,",
            "    \"ResourceRequest\": ResourceRequest,",
            "    # LOGOUT messages",
            "    \"LogoutToken\": LogoutToken,",
            "    \"BackChannelLogoutRequest\": BackChannelLogoutRequest,",
            "    \"FrontChannelLogoutRequest\": FrontChannelLogoutRequest,",
            "}",
            "",
            "",
            "def factory(msgtype):",
            "    warnings.warn(",
            "        \"`factory` is deprecated. Use `OIDCMessageFactory` instead.\", DeprecationWarning",
            "    )",
            "    for _, obj in inspect.getmembers(sys.modules[__name__]):",
            "        if inspect.isclass(obj) and issubclass(obj, Message):",
            "            try:",
            "                if obj.__name__ == msgtype:",
            "                    return obj",
            "            except AttributeError:",
            "                pass",
            "",
            "    # Fall back to basic OAuth2 messages",
            "    return message.factory(msgtype)",
            "",
            "",
            "class OIDCMessageFactory(MessageFactory):",
            "    \"\"\"Factory that knows OIDC message types.\"\"\"",
            "",
            "    authorization_endpoint = MessageTuple(AuthorizationRequest, AuthorizationResponse)",
            "    token_endpoint = MessageTuple(AccessTokenRequest, AccessTokenResponse)",
            "    refresh_endpoint = MessageTuple(RefreshAccessTokenRequest, AccessTokenResponse)",
            "    resource_endpoint = MessageTuple(ResourceRequest, Message)",
            "    configuration_endpoint = MessageTuple(Message, ProviderConfigurationResponse)",
            "",
            "    userinfo_endpoint = MessageTuple(UserInfoRequest, Message)",
            "    registration_endpoint = MessageTuple(RegistrationRequest, RegistrationResponse)",
            "    endsession_endpoint = MessageTuple(EndSessionRequest, EndSessionResponse)",
            "    checkid_endpoint = MessageTuple(CheckIDRequest, IdToken)",
            "    checksession_endpoint = MessageTuple(CheckSessionRequest, IdToken)",
            "    refreshsession_endpoint = MessageTuple(",
            "        RefreshSessionRequest, RefreshSessionResponse",
            "    )",
            "    discovery_endpoint = MessageTuple(DiscoveryRequest, DiscoveryResponse)"
        ],
        "afterPatchFile": [
            "import inspect",
            "import json",
            "import logging",
            "import sys",
            "import time",
            "import warnings",
            "from typing import Dict",
            "from typing import List",
            "from urllib.parse import urlencode",
            "from urllib.parse import urlparse",
            "",
            "from jwkest import jws",
            "from jwkest.jwe import JWEException",
            "from jwkest.jwe import factory as JWE_factory",
            "from jwkest.jwt import JWT",
            "",
            "from oic.exception import InvalidRequest",
            "from oic.exception import IssuerMismatch",
            "from oic.exception import MessageException",
            "from oic.exception import NotForMe",
            "from oic.exception import PyoidcError",
            "from oic.oauth2 import message",
            "from oic.oauth2.exception import VerificationError",
            "from oic.oauth2.message import OPTIONAL_LIST_OF_SP_SEP_STRINGS",
            "from oic.oauth2.message import OPTIONAL_LIST_OF_STRINGS",
            "from oic.oauth2.message import REQUIRED_LIST_OF_SP_SEP_STRINGS",
            "from oic.oauth2.message import REQUIRED_LIST_OF_STRINGS",
            "from oic.oauth2.message import SINGLE_OPTIONAL_INT",
            "from oic.oauth2.message import SINGLE_OPTIONAL_JSON",
            "from oic.oauth2.message import SINGLE_OPTIONAL_STRING",
            "from oic.oauth2.message import SINGLE_REQUIRED_STRING",
            "from oic.oauth2.message import Message",
            "from oic.oauth2.message import MessageFactory",
            "from oic.oauth2.message import MessageTuple",
            "from oic.oauth2.message import MissingRequiredAttribute",
            "from oic.oauth2.message import MissingRequiredValue",
            "from oic.oauth2.message import NotAllowedValue",
            "from oic.oauth2.message import ParamDefinition",
            "from oic.oauth2.message import SchemeError",
            "from oic.utils import time_util",
            "from oic.utils.time_util import utc_time_sans_frac",
            "",
            "__author__ = \"rohe0002\"",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "NONCE_STORAGE_TIME = 4 * 3600",
            "",
            "",
            "class AtHashError(VerificationError):",
            "    pass",
            "",
            "",
            "class CHashError(VerificationError):",
            "    pass",
            "",
            "",
            "class EXPError(VerificationError):",
            "    pass",
            "",
            "",
            "class IATError(VerificationError):",
            "    pass",
            "",
            "",
            "def json_ser(val, sformat=None, lev=0):",
            "    return json.dumps(val)",
            "",
            "",
            "def json_deser(val, sformat=None, lev=0):",
            "    return json.loads(val)",
            "",
            "",
            "def json_conv(val, sformat=None, lev=0):",
            "    if isinstance(val, dict):",
            "        for key, _val in val.items():",
            "            if _val is None:",
            "                val[key] = \"none\"",
            "            elif _val is True:",
            "                val[key] = \"true\"",
            "            elif _val is False:",
            "                val[key] = \"false\"",
            "",
            "    return val",
            "",
            "",
            "def json_rest(val, sformat=None, lev=0):",
            "    if isinstance(val, dict):",
            "        for key, _val in val.items():",
            "            if _val == \"none\":",
            "                val[key] = None",
            "            elif _val == \"true\":",
            "                val[key] = True",
            "            elif _val == \"false\":",
            "                val[key] = False",
            "",
            "    return val",
            "",
            "",
            "# value type, required, serializer, deserializer, null value allowed",
            "SINGLE_OPTIONAL_BOOLEAN = ParamDefinition(bool, False, None, None, False)",
            "SINGLE_OPTIONAL_JSON_WN = ParamDefinition(dict, False, json_ser, json_deser, True)",
            "SINGLE_OPTIONAL_JSON_CONV = ParamDefinition(dict, False, json_conv, json_rest, True)",
            "SINGLE_REQUIRED_INT = ParamDefinition(int, True, None, None, False)",
            "",
            "",
            "def idtoken_deser(val, sformat=\"urlencoded\"):",
            "    # id_token are always serialized as a JWT",
            "    return IdToken().deserialize(val, \"jwt\")",
            "",
            "",
            "def address_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "        elif sformat == \"dict\":",
            "            sformat = \"json\"",
            "    return AddressClaim().deserialize(val, sformat)",
            "",
            "",
            "def claims_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return Claims().deserialize(val, sformat)",
            "",
            "",
            "def message_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return Message().deserialize(val, sformat)",
            "",
            "",
            "def msg_ser(inst, sformat, lev=0):",
            "    if sformat in [\"urlencoded\", \"json\"]:",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        else:",
            "            res = inst",
            "    elif sformat == \"dict\":",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        elif isinstance(inst, dict):",
            "            res = inst",
            "        elif isinstance(inst, str):  # Iff ID Token",
            "            res = inst",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(inst))",
            "    else:",
            "        raise PyoidcError(\"Unknown sformat\", inst)",
            "",
            "    return res",
            "",
            "",
            "def msg_ser_json(inst, sformat=\"json\", lev=0):",
            "    # sformat = \"json\" always except when dict",
            "    if lev:",
            "        sformat = \"dict\"",
            "",
            "    if sformat == \"dict\":",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        elif isinstance(inst, dict):",
            "            res = inst",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(inst))",
            "    else:",
            "        sformat = \"json\"",
            "        if isinstance(inst, Message):",
            "            res = inst.serialize(sformat, lev)",
            "        else:",
            "            res = inst",
            "",
            "    return res",
            "",
            "",
            "def msg_list_ser(insts, sformat, lev=0):",
            "    return [msg_ser(inst, sformat, lev) for inst in insts]",
            "",
            "",
            "def claims_ser(val, sformat=\"urlencoded\", lev=0):",
            "    # everything in c_extension",
            "    if isinstance(val, str):",
            "        item = val",
            "    elif isinstance(val, list):",
            "        item = val[0]",
            "    else:",
            "        item = val",
            "",
            "    if isinstance(item, Message):",
            "        return item.serialize(method=sformat, lev=lev + 1)",
            "",
            "    if sformat == \"urlencoded\":",
            "        assert isinstance(  # nosec",
            "            item, dict",
            "        )  # We cannot urlencode anything else than Mapping",
            "        res = urlencode(item)",
            "    elif sformat == \"json\":",
            "        if lev:",
            "            res = item",
            "        else:",
            "            res = json.dumps(item)",
            "    elif sformat == \"dict\":",
            "        if isinstance(item, dict):",
            "            res = item",
            "        else:",
            "            raise MessageException(\"Wrong type: %s\" % type(item))",
            "    else:",
            "        raise PyoidcError(\"Unknown sformat: %s\" % sformat, val)",
            "",
            "    return res",
            "",
            "",
            "def registration_request_deser(val, sformat=\"urlencoded\"):",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return RegistrationRequest().deserialize(val, sformat)",
            "",
            "",
            "def claims_request_deser(val, sformat=\"json\"):",
            "    # never 'urlencoded'",
            "    if sformat == \"urlencoded\":",
            "        sformat = \"json\"",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return ClaimsRequest().deserialize(val, sformat)",
            "",
            "",
            "OPTIONAL_ADDRESS = ParamDefinition(Message, False, msg_ser, address_deser, False)",
            "OPTIONAL_LOGICAL = ParamDefinition(bool, False, None, None, False)",
            "OPTIONAL_MULTIPLE_Claims = ParamDefinition(",
            "    Message, False, claims_ser, claims_deser, False",
            ")",
            "",
            "SINGLE_OPTIONAL_IDTOKEN = ParamDefinition(str, False, msg_ser, None, False)",
            "",
            "SINGLE_OPTIONAL_REGISTRATION_REQUEST = ParamDefinition(",
            "    Message, False, msg_ser, registration_request_deser, False",
            ")",
            "SINGLE_OPTIONAL_CLAIMSREQ = ParamDefinition(",
            "    Message, False, msg_ser_json, claims_request_deser, False",
            ")",
            "",
            "OPTIONAL_MESSAGE = ParamDefinition(Message, False, msg_ser, message_deser, False)",
            "REQUIRED_MESSAGE = ParamDefinition(Message, True, msg_ser, message_deser, False)",
            "",
            "# ----------------------------------------------------------------------------",
            "",
            "",
            "SCOPE_CHARSET = []",
            "for char in [\"\\x21\", (\"\\x23\", \"\\x5b\"), (\"\\x5d\", \"\\x7E\")]:",
            "    if isinstance(char, tuple):",
            "        c = char[0]",
            "        while c <= char[1]:",
            "            SCOPE_CHARSET.append(c)",
            "            c = chr(ord(c) + 1)",
            "    else:",
            "        SCOPE_CHARSET.append(set)",
            "",
            "",
            "def check_char_set(string, allowed):",
            "    for c in string:",
            "        if c not in allowed:",
            "            raise NotAllowedValue(\"'%c' not in the allowed character set\" % c)",
            "",
            "",
            "TOKEN_VERIFY_ARGS = [\"key\", \"keyjar\", \"algs\", \"sender\"]",
            "",
            "",
            "def verify_id_token(instance, check_hash=False, **kwargs):",
            "    # Try to decode the JWT, checks the signature",
            "    args = {}",
            "    for arg in TOKEN_VERIFY_ARGS:",
            "        try:",
            "            args[arg] = kwargs[arg]",
            "        except KeyError:",
            "            pass",
            "",
            "    _jws = str(instance[\"id_token\"])",
            "",
            "    # It can be encrypted, so try to decrypt first",
            "    _jwe = JWE_factory(_jws)",
            "    if _jwe is not None:",
            "        try:",
            "            _jws = _jwe.decrypt(keys=kwargs[\"keyjar\"].get_decrypt_key())",
            "        except JWEException as err:",
            "            raise VerificationError(\"Could not decrypt id_token\", err)",
            "    _packer = JWT()",
            "    _body = _packer.unpack(_jws).payload()",
            "",
            "    if \"keyjar\" in kwargs:",
            "        try:",
            "            if _body[\"iss\"] not in kwargs[\"keyjar\"]:",
            "                raise ValueError(\"Unknown issuer\")",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"iss\")",
            "",
            "    if _jwe is not None:",
            "        # Use the original encrypted token to set correct headers",
            "        idt = IdToken().from_jwt(str(instance[\"id_token\"]), **args)",
            "    else:",
            "        idt = IdToken().from_jwt(_jws, **args)",
            "    if not idt.verify(**kwargs):",
            "        raise VerificationError(\"Could not verify id_token\", idt)",
            "",
            "    if check_hash:",
            "        _alg = idt.jws_header[\"alg\"]",
            "        if _alg != \"none\":",
            "            hfunc = \"HS\" + _alg[-3:]",
            "        else:",
            "            # This is allowed only for `code` and it needs to be checked by a Client",
            "            hfunc = None",
            "",
            "        if \"access_token\" in instance and hfunc is not None:",
            "            if \"at_hash\" not in idt:",
            "                raise MissingRequiredAttribute(\"Missing at_hash property\", idt)",
            "            if idt[\"at_hash\"] != jws.left_hash(instance[\"access_token\"], hfunc):",
            "                raise AtHashError(\"Failed to verify access_token hash\", idt)",
            "",
            "        if \"code\" in instance and hfunc is not None:",
            "            if \"c_hash\" not in idt:",
            "                raise MissingRequiredAttribute(\"Missing c_hash property\", idt)",
            "            if idt[\"c_hash\"] != jws.left_hash(instance[\"code\"], hfunc):",
            "                raise CHashError(\"Failed to verify code hash\", idt)",
            "",
            "    return idt",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "",
            "",
            "class RefreshAccessTokenRequest(message.RefreshAccessTokenRequest):",
            "    pass",
            "",
            "",
            "class TokenErrorResponse(message.TokenErrorResponse):",
            "    pass",
            "",
            "",
            "class AccessTokenResponse(message.AccessTokenResponse):",
            "    c_param = message.AccessTokenResponse.c_param.copy()",
            "    c_param.update({\"id_token\": SINGLE_OPTIONAL_STRING})",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            # replace the JWT with the verified IdToken instance",
            "            self[\"id_token\"] = verify_id_token(self, **kwargs)",
            "",
            "        return True",
            "",
            "",
            "class UserInfoRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "class AuthorizationResponse(message.AuthorizationResponse, message.AccessTokenResponse):",
            "    c_param = message.AuthorizationResponse.c_param.copy()",
            "    c_param.update(message.AccessTokenResponse.c_param)",
            "    c_param.update(",
            "        {",
            "            \"code\": SINGLE_OPTIONAL_STRING,",
            "            \"access_token\": SINGLE_OPTIONAL_STRING,",
            "            \"token_type\": SINGLE_OPTIONAL_STRING,",
            "            \"id_token\": SINGLE_OPTIONAL_IDTOKEN,",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"aud\" in self:",
            "            if \"client_id\" in kwargs:",
            "                # check that it's for me",
            "                if kwargs[\"client_id\"] not in self[\"aud\"]:",
            "                    return False",
            "",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "        if \"access_token\" in self:",
            "            if \"token_type\" not in self:",
            "                raise MissingRequiredValue(\"Missing token_type parameter\", self)",
            "",
            "        return True",
            "",
            "",
            "class AuthorizationErrorResponse(message.AuthorizationErrorResponse):",
            "    c_allowed_values = message.AuthorizationErrorResponse.c_allowed_values.copy()",
            "    c_allowed_values[\"error\"].extend(",
            "        [",
            "            \"interaction_required\",",
            "            \"login_required\",",
            "            \"session_selection_required\",",
            "            \"consent_required\",",
            "            \"invalid_request_uri\",",
            "            \"invalid_request_object\",",
            "            \"registration_not_supported\",",
            "            \"request_not_supported\",",
            "            \"request_uri_not_supported\",",
            "        ]",
            "    )",
            "",
            "",
            "class AuthorizationRequest(message.AuthorizationRequest):",
            "    c_param = message.AuthorizationRequest.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"scope\": REQUIRED_LIST_OF_SP_SEP_STRINGS,",
            "            \"redirect_uri\": SINGLE_REQUIRED_STRING,",
            "            \"nonce\": SINGLE_OPTIONAL_STRING,",
            "            \"display\": SINGLE_OPTIONAL_STRING,",
            "            \"prompt\": OPTIONAL_LIST_OF_STRINGS,",
            "            \"max_age\": SINGLE_OPTIONAL_INT,",
            "            \"ui_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"claims_locales\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"id_token_hint\": SINGLE_OPTIONAL_STRING,",
            "            \"login_hint\": SINGLE_OPTIONAL_STRING,",
            "            \"acr_values\": OPTIONAL_LIST_OF_SP_SEP_STRINGS,",
            "            \"claims\": SINGLE_OPTIONAL_CLAIMSREQ,",
            "            \"registration\": SINGLE_OPTIONAL_JSON,",
            "            \"request\": SINGLE_OPTIONAL_STRING,",
            "            \"request_uri\": SINGLE_OPTIONAL_STRING,",
            "            \"response_mode\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "    c_allowed_values = message.AuthorizationRequest.c_allowed_values.copy()",
            "    c_allowed_values.update(",
            "        {",
            "            \"display\": [\"page\", \"popup\", \"touch\", \"wap\"],",
            "            \"prompt\": [\"none\", \"login\", \"consent\", \"select_account\"],",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        \"\"\"",
            "        Check that the request is valid.",
            "",
            "        Authorization Request parameters that are OPTIONAL in the OAuth 2.0",
            "        specification MAY be included in the OpenID Request Object without also",
            "        passing them as OAuth 2.0 Authorization Request parameters, with one",
            "        exception: The scope parameter MUST always be present in OAuth 2.0",
            "        Authorization Request parameters.",
            "        All parameter values that are present both in the OAuth 2.0",
            "        Authorization Request and in the OpenID Request Object MUST exactly match.",
            "        \"\"\"",
            "        super().verify(**kwargs)",
            "",
            "        args = {}",
            "        for arg in [\"key\", \"keyjar\", \"opponent_id\", \"sender\"]:",
            "            try:",
            "                args[arg] = kwargs[arg]",
            "            except KeyError:",
            "                pass",
            "",
            "        if \"opponent_id\" not in kwargs:",
            "            args[\"opponent_id\"] = self[\"client_id\"]",
            "",
            "        if \"request\" in self:",
            "            if isinstance(self[\"request\"], str):",
            "                # Try to decode the JWT, checks the signature",
            "                oidr = OpenIDRequest().from_jwt(str(self[\"request\"]), **args)",
            "",
            "                # verify that nothing is change in the original message",
            "                for key, val in oidr.items():",
            "                    if key in self and self[key] != val:",
            "                        raise AssertionError()",
            "",
            "                # replace the JWT with the parsed and verified instance",
            "                self[\"request\"] = oidr",
            "",
            "        if \"id_token_hint\" in self:",
            "            if isinstance(self[\"id_token_hint\"], str):",
            "                idt = IdToken().from_jwt(str(self[\"id_token_hint\"]), **args)",
            "                self[\"id_token_hint\"] = idt",
            "",
            "        if \"response_type\" not in self:",
            "            raise MissingRequiredAttribute(\"response_type missing\", self)",
            "",
            "        _rt = self[\"response_type\"]",
            "        if \"token\" in _rt or \"id_token\" in _rt:",
            "            if \"nonce\" not in self:",
            "                raise MissingRequiredAttribute(\"Nonce missing\", self)",
            "",
            "        if \"openid\" not in self.get(\"scope\", []):",
            "            raise MissingRequiredValue(\"openid not in scope\", self)",
            "",
            "        if \"offline_access\" in self.get(\"scope\", []):",
            "            if \"prompt\" not in self or \"consent\" not in self[\"prompt\"]:",
            "                raise MissingRequiredValue(\"consent in prompt\", self)",
            "",
            "        if \"prompt\" in self:",
            "            if \"none\" in self[\"prompt\"] and len(self[\"prompt\"]) > 1:",
            "                raise InvalidRequest(\"prompt none combined with other value\", self)",
            "",
            "        return True",
            "",
            "",
            "class AccessTokenRequest(message.AccessTokenRequest):",
            "    c_param = message.AccessTokenRequest.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"client_assertion_type\": SINGLE_OPTIONAL_STRING,",
            "            \"client_assertion\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "    c_default = {\"grant_type\": \"authorization_code\"}",
            "    c_allowed_values = {",
            "        \"client_assertion_type\": [",
            "            \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"",
            "        ]",
            "    }",
            "",
            "",
            "class AddressClaim(Message):",
            "    c_param = {",
            "        \"formatted\": SINGLE_OPTIONAL_STRING,",
            "        \"street_address\": SINGLE_OPTIONAL_STRING,",
            "        \"locality\": SINGLE_OPTIONAL_STRING,",
            "        \"region\": SINGLE_OPTIONAL_STRING,",
            "        \"postal_code\": SINGLE_OPTIONAL_STRING,",
            "        \"country\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "class OpenIDSchema(Message):",
            "    c_param = {",
            "        \"sub\": SINGLE_REQUIRED_STRING,",
            "        \"name\": SINGLE_OPTIONAL_STRING,",
            "        \"given_name\": SINGLE_OPTIONAL_STRING,",
            "        \"family_name\": SINGLE_OPTIONAL_STRING,",
            "        \"middle_name\": SINGLE_OPTIONAL_STRING,",
            "        \"nickname\": SINGLE_OPTIONAL_STRING,",
            "        \"preferred_username\": SINGLE_OPTIONAL_STRING,",
            "        \"profile\": SINGLE_OPTIONAL_STRING,",
            "        \"picture\": SINGLE_OPTIONAL_STRING,",
            "        \"website\": SINGLE_OPTIONAL_STRING,",
            "        \"email\": SINGLE_OPTIONAL_STRING,",
            "        \"email_verified\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"gender\": SINGLE_OPTIONAL_STRING,",
            "        \"birthdate\": SINGLE_OPTIONAL_STRING,",
            "        \"zoneinfo\": SINGLE_OPTIONAL_STRING,",
            "        \"locale\": SINGLE_OPTIONAL_STRING,",
            "        \"phone_number\": SINGLE_OPTIONAL_STRING,",
            "        \"phone_number_verified\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"address\": OPTIONAL_ADDRESS,",
            "        \"updated_at\": SINGLE_OPTIONAL_INT,",
            "        \"_claim_names\": OPTIONAL_MESSAGE,",
            "        \"_claim_sources\": OPTIONAL_MESSAGE,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"birthdate\" in self:",
            "            # Either YYYY-MM-DD or just YYYY or 0000-MM-DD",
            "            try:",
            "                time.strptime(self[\"birthdate\"], \"%Y-%m-%d\")",
            "            except ValueError:",
            "                try:",
            "                    time.strptime(self[\"birthdate\"], \"%Y\")",
            "                except ValueError:",
            "                    try:",
            "                        time.strptime(self[\"birthdate\"], \"0000-%m-%d\")",
            "                    except ValueError:",
            "                        raise VerificationError(\"Birthdate format error\", self)",
            "",
            "        if any(val is None for val in self.values()):",
            "            return False",
            "",
            "        return True",
            "",
            "",
            "class RegistrationRequest(Message):",
            "    c_param = {",
            "        \"redirect_uris\": REQUIRED_LIST_OF_STRINGS,",
            "        \"response_types\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"grant_types\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"application_type\": SINGLE_OPTIONAL_STRING,",
            "        \"contacts\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"client_name\": SINGLE_OPTIONAL_STRING,",
            "        \"logo_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"client_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"policy_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"tos_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"sector_identifier_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"subject_type\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_signed_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"id_token_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_signed_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_encrypted_response_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_encrypted_response_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_signing_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_encryption_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"request_object_encryption_enc\": SINGLE_OPTIONAL_STRING,",
            "        \"token_endpoint_auth_method\": SINGLE_OPTIONAL_STRING,",
            "        \"token_endpoint_auth_signing_alg\": SINGLE_OPTIONAL_STRING,",
            "        \"default_max_age\": SINGLE_OPTIONAL_INT,",
            "        \"require_auth_time\": OPTIONAL_LOGICAL,",
            "        \"default_acr_values\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"initiate_login_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"request_uris\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"post_logout_redirect_uris\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"frontchannel_logout_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"frontchannel_logout_session_required\": OPTIONAL_LOGICAL,",
            "        \"backchannel_logout_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"backchannel_logout_session_required\": OPTIONAL_LOGICAL,",
            "    }",
            "    c_default = {\"application_type\": \"web\", \"response_types\": [\"code\"]}",
            "    c_allowed_values = {",
            "        \"application_type\": [\"native\", \"web\"],",
            "        \"subject_type\": [\"public\", \"pairwise\"],",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"initiate_login_uri\" in self and not self[\"initiate_login_uri\"].startswith(",
            "            \"https:\"",
            "        ):",
            "            raise AssertionError()",
            "",
            "        for param in [",
            "            \"request_object_encryption\",",
            "            \"id_token_encrypted_response\",",
            "            \"userinfo_encrypted_response\",",
            "        ]:",
            "            alg_param = \"%s_alg\" % param",
            "            enc_param = \"%s_enc\" % param",
            "            if alg_param in self:",
            "                if enc_param not in self:",
            "                    self[enc_param] = \"A128CBC-HS256\"",
            "",
            "            # both or none",
            "            if enc_param in self and alg_param not in self:",
            "                raise AssertionError()",
            "",
            "        if (",
            "            \"token_endpoint_auth_signing_alg\" in self",
            "            and self[\"token_endpoint_auth_signing_alg\"] == \"none\"",
            "        ):",
            "            raise AssertionError()",
            "",
            "        return True",
            "",
            "",
            "class RegistrationResponse(Message):",
            "    \"\"\"Response to client_register registration requests.\"\"\"",
            "",
            "    c_param = {",
            "        \"client_id\": SINGLE_REQUIRED_STRING,",
            "        \"client_secret\": SINGLE_OPTIONAL_STRING,",
            "        \"registration_access_token\": SINGLE_OPTIONAL_STRING,",
            "        \"registration_client_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"client_id_issued_at\": SINGLE_OPTIONAL_INT,",
            "        \"client_secret_expires_at\": SINGLE_OPTIONAL_INT,",
            "    }",
            "    c_param.update(RegistrationRequest.c_param)",
            "",
            "    def verify(self, **kwargs):",
            "        \"\"\"",
            "        Verify that the response is valid.",
            "",
            "        Implementations MUST either return both a Client Configuration Endpoint",
            "        and a Registration Access Token or neither of them.",
            "        :param kwargs:",
            "        :return: True if the message is OK otherwise False",
            "        \"\"\"",
            "        super(RegistrationResponse, self).verify(**kwargs)",
            "",
            "        has_reg_uri = \"registration_client_uri\" in self",
            "        has_reg_at = \"registration_access_token\" in self",
            "        if has_reg_uri != has_reg_at:",
            "            raise VerificationError(",
            "                (",
            "                    \"Only one of registration_client_uri\"",
            "                    \" and registration_access_token present\"",
            "                ),",
            "                self,",
            "            )",
            "",
            "        return True",
            "",
            "",
            "class ClientRegistrationErrorResponse(message.ErrorResponse):",
            "    c_allowed_values = {",
            "        \"error\": [",
            "            \"invalid_redirect_uri\",",
            "            \"invalid_client_metadata\",",
            "            \"invalid_configuration_parameter\",",
            "        ]",
            "    }",
            "",
            "",
            "class IdToken(OpenIDSchema):",
            "    c_param = OpenIDSchema.c_param.copy()",
            "    c_param.update(",
            "        {",
            "            \"iss\": SINGLE_REQUIRED_STRING,",
            "            \"sub\": SINGLE_REQUIRED_STRING,",
            "            \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "            \"exp\": SINGLE_REQUIRED_INT,",
            "            \"iat\": SINGLE_REQUIRED_INT,",
            "            \"auth_time\": SINGLE_OPTIONAL_INT,",
            "            \"nonce\": SINGLE_OPTIONAL_STRING,",
            "            \"at_hash\": SINGLE_OPTIONAL_STRING,",
            "            \"c_hash\": SINGLE_OPTIONAL_STRING,",
            "            \"acr\": SINGLE_OPTIONAL_STRING,",
            "            \"amr\": OPTIONAL_LIST_OF_STRINGS,",
            "            \"azp\": SINGLE_OPTIONAL_STRING,",
            "            \"sub_jwk\": SINGLE_OPTIONAL_STRING,",
            "        }",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super(IdToken, self).verify(**kwargs)",
            "",
            "        try:",
            "            if kwargs[\"iss\"] != self[\"iss\"]:",
            "                raise IssuerMismatch(\"{} != {}\".format(kwargs[\"iss\"], self[\"iss\"]))",
            "        except KeyError:",
            "            pass",
            "",
            "        if \"aud\" in self:",
            "            if \"client_id\" in kwargs:",
            "                # check that I'm among the recipients",
            "                if kwargs[\"client_id\"] not in self[\"aud\"]:",
            "                    raise NotForMe(",
            "                        \"{} not in aud:{}\".format(kwargs[\"client_id\"], self[\"aud\"]),",
            "                        self,",
            "                    )",
            "",
            "            # Then azp has to be present and be one of the aud values",
            "            if len(self[\"aud\"]) > 1:",
            "                if \"azp\" not in self:",
            "                    raise VerificationError(\"azp missing\", self)",
            "                if self[\"azp\"] not in self[\"aud\"]:",
            "                    raise VerificationError(\"Mismatch between azp and aud claims\", self)",
            "",
            "        if \"azp\" in self:",
            "            if \"client_id\" in kwargs:",
            "                if kwargs[\"client_id\"] != self[\"azp\"]:",
            "                    raise NotForMe(",
            "                        \"{} != azp:{}\".format(kwargs[\"client_id\"], self[\"azp\"]), self",
            "                    )",
            "",
            "        _now = time_util.utc_time_sans_frac()",
            "",
            "        try:",
            "            _skew = kwargs[\"skew\"]",
            "        except KeyError:",
            "            _skew = 0",
            "",
            "        try:",
            "            _exp = self[\"exp\"]",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"exp\")",
            "        else:",
            "            if (_now - _skew) > _exp:",
            "                raise EXPError(\"Invalid expiration time\")",
            "",
            "        try:",
            "            _storage_time = kwargs[\"nonce_storage_time\"]",
            "        except KeyError:",
            "            _storage_time = NONCE_STORAGE_TIME",
            "",
            "        try:",
            "            _iat = self[\"iat\"]",
            "        except KeyError:",
            "            raise MissingRequiredAttribute(\"iat\")",
            "        else:",
            "            if (_iat + _storage_time) < (_now - _skew):",
            "                raise IATError(\"Issued too long ago\")",
            "            if _now < (_iat - _skew):",
            "                raise IATError(\"Issued in the future\")",
            "",
            "        if _exp < _iat:",
            "            raise EXPError(\"Invalid expiration time\")",
            "",
            "        return True",
            "",
            "",
            "class StateFullMessage(Message):",
            "    c_param = {\"state\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class RefreshSessionRequest(StateFullMessage):",
            "    c_param = StateFullMessage.c_param.copy()",
            "    c_param.update(",
            "        {\"id_token\": SINGLE_REQUIRED_STRING, \"redirect_url\": SINGLE_REQUIRED_STRING}",
            "    )",
            "",
            "    def verify(self, **kwargs):",
            "        super(RefreshSessionRequest, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class RefreshSessionResponse(StateFullMessage):",
            "    c_param = StateFullMessage.c_param.copy()",
            "    c_param.update({\"id_token\": SINGLE_REQUIRED_STRING})",
            "",
            "    def verify(self, **kwargs):",
            "        super(RefreshSessionResponse, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class CheckSessionRequest(Message):",
            "    c_param = {\"id_token\": SINGLE_REQUIRED_STRING}",
            "",
            "    def verify(self, **kwargs):",
            "        super(CheckSessionRequest, self).verify(**kwargs)",
            "        if \"id_token\" in self:",
            "            self[\"id_token\"] = verify_id_token(self, check_hash=True, **kwargs)",
            "",
            "",
            "class CheckIDRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class EndSessionRequest(Message):",
            "    c_param = {",
            "        \"id_token_hint\": SINGLE_OPTIONAL_STRING,",
            "        \"post_logout_redirect_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"state\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "class EndSessionResponse(Message):",
            "    c_param = {\"state\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "class Claims(Message):",
            "    pass",
            "",
            "",
            "class ClaimsRequest(Message):",
            "    c_param = {",
            "        \"userinfo\": OPTIONAL_MULTIPLE_Claims,",
            "        \"id_token\": OPTIONAL_MULTIPLE_Claims,",
            "    }",
            "",
            "",
            "class OpenIDRequest(AuthorizationRequest):",
            "    pass",
            "",
            "",
            "class ProviderConfigurationResponse(Message):",
            "    c_param = {",
            "        \"issuer\": SINGLE_REQUIRED_STRING,",
            "        \"authorization_endpoint\": SINGLE_REQUIRED_STRING,",
            "        \"token_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"userinfo_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"jwks_uri\": SINGLE_REQUIRED_STRING,",
            "        \"registration_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"scopes_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"response_types_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"response_modes_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"grant_types_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"acr_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"subject_types_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"id_token_signing_alg_values_supported\": REQUIRED_LIST_OF_STRINGS,",
            "        \"id_token_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"id_token_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"userinfo_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_encryption_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"request_object_encryption_enc_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"token_endpoint_auth_methods_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"token_endpoint_auth_signing_alg_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"display_values_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claim_types_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claims_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"service_documentation\": SINGLE_OPTIONAL_STRING,",
            "        \"claims_locales_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"ui_locales_supported\": OPTIONAL_LIST_OF_STRINGS,",
            "        \"claims_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"request_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"request_uri_parameter_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"require_request_uri_registration\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"op_policy_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"op_tos_uri\": SINGLE_OPTIONAL_STRING,",
            "        \"check_session_iframe\": SINGLE_OPTIONAL_STRING,",
            "        \"end_session_endpoint\": SINGLE_OPTIONAL_STRING,",
            "        \"frontchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"frontchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"backchannel_logout_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "        \"backchannel_logout_session_supported\": SINGLE_OPTIONAL_BOOLEAN,",
            "    }",
            "    c_default = {",
            "        \"version\": \"3.0\",",
            "        \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\"],",
            "        \"claims_parameter_supported\": False,",
            "        \"request_parameter_supported\": False,",
            "        \"request_uri_parameter_supported\": True,",
            "        \"require_request_uri_registration\": False,",
            "        \"grant_types_supported\": [\"authorization_code\", \"implicit\"],",
            "        \"frontchannel_logout_supported\": False,",
            "        \"frontchannel_logout_session_supported\": False,",
            "        \"backchannel_logout_supported\": False,",
            "        \"backchannel_logout_session_supported\": False,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"scopes_supported\" in self:",
            "            if \"openid\" not in self[\"scopes_supported\"]:",
            "                raise AssertionError()",
            "            for scope in self[\"scopes_supported\"]:",
            "                check_char_set(scope, SCOPE_CHARSET)",
            "",
            "        parts = urlparse(self[\"issuer\"])",
            "        if parts.scheme != \"https\":",
            "            raise SchemeError(\"Not HTTPS\")",
            "",
            "        if parts.query or parts.fragment:",
            "            raise AssertionError()",
            "",
            "        if (",
            "            any(\"code\" in rt for rt in self[\"response_types_supported\"])",
            "            and \"token_endpoint\" not in self",
            "        ):",
            "            raise MissingRequiredAttribute(\"token_endpoint\")",
            "",
            "        return True",
            "",
            "",
            "class AuthnToken(Message):",
            "    c_param = {",
            "        \"iss\": SINGLE_REQUIRED_STRING,",
            "        \"sub\": SINGLE_REQUIRED_STRING,",
            "        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"jti\": SINGLE_REQUIRED_STRING,",
            "        \"exp\": SINGLE_REQUIRED_INT,",
            "        \"iat\": SINGLE_OPTIONAL_INT,",
            "    }",
            "",
            "",
            "# According to RFC 7519 all claims are optional",
            "class JasonWebToken(Message):",
            "    c_param = {",
            "        \"iss\": SINGLE_OPTIONAL_STRING,",
            "        \"sub\": SINGLE_OPTIONAL_STRING,",
            "        \"aud\": OPTIONAL_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"exp\": SINGLE_OPTIONAL_INT,",
            "        \"nbf\": SINGLE_OPTIONAL_INT,",
            "        \"iat\": SINGLE_OPTIONAL_INT,",
            "        \"jti\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "",
            "def jwt_deser(val, sformat=\"json\"):",
            "    if sformat == \"urlencoded\":",
            "        sformat = \"json\"",
            "    if sformat in [\"dict\", \"json\"]:",
            "        if not isinstance(val, str):",
            "            val = json.dumps(val)",
            "            sformat = \"json\"",
            "    return JasonWebToken().deserialize(val, sformat)",
            "",
            "",
            "SINGLE_OPTIONAL_JWT = ParamDefinition(Message, False, msg_ser, jwt_deser, False)",
            "",
            "",
            "class UserInfoErrorResponse(message.ErrorResponse):",
            "    c_allowed_values = {",
            "        \"error\": [",
            "            \"invalid_schema\",",
            "            \"invalid_request\",",
            "            \"invalid_token\",",
            "            \"insufficient_scope\",",
            "        ]",
            "    }",
            "",
            "",
            "class DiscoveryRequest(Message):",
            "    c_param = {\"principal\": SINGLE_REQUIRED_STRING, \"service\": SINGLE_REQUIRED_STRING}",
            "",
            "",
            "class DiscoveryResponse(Message):",
            "    c_param = {\"locations\": REQUIRED_LIST_OF_STRINGS}",
            "",
            "",
            "class ResourceRequest(Message):",
            "    c_param = {\"access_token\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "SCOPE2CLAIMS: Dict[str, List[str]] = {",
            "    \"openid\": [\"sub\"],",
            "    \"profile\": [",
            "        \"name\",",
            "        \"given_name\",",
            "        \"family_name\",",
            "        \"middle_name\",",
            "        \"nickname\",",
            "        \"profile\",",
            "        \"picture\",",
            "        \"website\",",
            "        \"gender\",",
            "        \"birthdate\",",
            "        \"zoneinfo\",",
            "        \"locale\",",
            "        \"updated_at\",",
            "        \"preferred_username\",",
            "    ],",
            "    \"email\": [\"email\", \"email_verified\"],",
            "    \"address\": [\"address\"],",
            "    \"phone\": [\"phone_number\", \"phone_number_verified\"],",
            "    \"offline_access\": [],",
            "}",
            "",
            "# LOGOUT related messages",
            "",
            "SINGLE_OPTIONAL_JSON = ParamDefinition(dict, False, json_ser, json_deser, False)",
            "SINGLE_REQUIRED_JSON = ParamDefinition(dict, True, json_ser, json_deser, False)",
            "",
            "BACK_CHANNEL_LOGOUT_EVENT = \"http://schemas.openid.net/event/backchannel-logout\"",
            "",
            "",
            "class LogoutToken(Message):",
            "    \"\"\"Defined in https://openid.net/specs/openid-connect-backchannel-1_0.html#LogoutToken .\"\"\"",
            "",
            "    c_param = {",
            "        \"iss\": SINGLE_REQUIRED_STRING,",
            "        \"sub\": SINGLE_OPTIONAL_STRING,",
            "        \"aud\": REQUIRED_LIST_OF_STRINGS,  # Array of strings or string",
            "        \"iat\": SINGLE_REQUIRED_INT,",
            "        \"jti\": SINGLE_REQUIRED_STRING,",
            "        \"events\": SINGLE_REQUIRED_JSON,",
            "        \"sid\": SINGLE_OPTIONAL_STRING,",
            "    }",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        if \"nonce\" in self:",
            "            raise MessageException(",
            "                '\"nonce\" is prohibited from appearing in a LogoutToken.'",
            "            )",
            "",
            "        # Check the 'events' JSON",
            "        _keys = list(self[\"events\"].keys())",
            "        if len(_keys) != 1:",
            "            raise ValueError('Must only be one member in \"events\"')",
            "        if _keys[0] != BACK_CHANNEL_LOGOUT_EVENT:",
            "            raise ValueError('Wrong member in \"events\"')",
            "        if self[\"events\"][_keys[0]] != {}:",
            "            raise ValueError('Wrong member value in \"events\"')",
            "",
            "        # There must be either a 'sub' or a 'sid', and may contain both",
            "        if not (\"sub\" in self or \"sid\" in self):",
            "            raise ValueError('There MUST be either a \"sub\" or a \"sid\"')",
            "",
            "        try:",
            "            if kwargs[\"aud\"] not in self[\"aud\"]:",
            "                raise NotForMe(\"Not among intended audience\")",
            "        except KeyError:",
            "            pass",
            "",
            "        try:",
            "            if kwargs[\"iss\"] != self[\"iss\"]:",
            "                raise NotForMe(\"Wrong issuer\")",
            "        except KeyError:",
            "            pass",
            "",
            "        _now = utc_time_sans_frac()",
            "",
            "        _skew = kwargs.get(\"skew\", 0)",
            "        _iat = self.get(\"iat\", 0)",
            "",
            "        if _iat and _iat > (_now + _skew):",
            "            raise ValueError(\"Invalid issued_at time\")",
            "",
            "        return True",
            "",
            "",
            "ID_TOKEN_VERIFY_ARGS = [",
            "    \"keyjar\",",
            "    \"verify\",",
            "    \"encalg\",",
            "    \"encenc\",",
            "    \"sigalg\",",
            "    \"issuer\",",
            "    \"allow_missing_kid\",",
            "    \"no_kid_issuer\",",
            "    \"trusting\",",
            "    \"skew\",",
            "    \"nonce_storage_time\",",
            "    \"client_id\",",
            "]",
            "",
            "",
            "class BackChannelLogoutRequest(Message):",
            "    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-backchannel-1_0.html .\"\"\"",
            "",
            "    c_param = {\"logout_token\": SINGLE_REQUIRED_STRING}",
            "",
            "    def verify(self, **kwargs):",
            "        super().verify(**kwargs)",
            "",
            "        args = {arg: kwargs[arg] for arg in TOKEN_VERIFY_ARGS if arg in kwargs}",
            "",
            "        logout_token = LogoutToken().from_jwt(str(self[\"logout_token\"]), **args)",
            "        logout_token.verify(**kwargs)",
            "",
            "        self[\"logout_token\"] = logout_token",
            "        logger.info(\"Verified Logout Token: {}\".format(logout_token.to_dict()))",
            "",
            "        return True",
            "",
            "",
            "class FrontChannelLogoutRequest(Message):",
            "    \"\"\"Defines the message used in https://openid.net/specs/openid-connect-frontchannel-1_0.html .\"\"\"",
            "",
            "    c_param = {\"iss\": SINGLE_OPTIONAL_STRING, \"sid\": SINGLE_OPTIONAL_STRING}",
            "",
            "",
            "MSG = {",
            "    \"RefreshAccessTokenRequest\": RefreshAccessTokenRequest,",
            "    \"TokenErrorResponse\": TokenErrorResponse,",
            "    \"AccessTokenResponse\": AccessTokenResponse,",
            "    \"UserInfoRequest\": UserInfoRequest,",
            "    \"AuthorizationResponse\": AuthorizationResponse,",
            "    \"AuthorizationErrorResponse\": AuthorizationErrorResponse,",
            "    \"AuthorizationRequest\": AuthorizationRequest,",
            "    \"AccessTokenRequest\": AccessTokenRequest,",
            "    \"AddressClaim\": AddressClaim,",
            "    \"OpenIDSchema\": OpenIDSchema,",
            "    \"RegistrationRequest\": RegistrationRequest,",
            "    \"RegistrationResponse\": RegistrationResponse,",
            "    \"ClientRegistrationErrorResponse\": ClientRegistrationErrorResponse,",
            "    \"IdToken\": IdToken,",
            "    \"RefreshSessionRequest\": RefreshSessionRequest,",
            "    \"RefreshSessionResponse\": RefreshSessionResponse,",
            "    \"CheckSessionRequest\": CheckSessionRequest,",
            "    \"CheckIDRequest\": CheckIDRequest,",
            "    \"EndSessionRequest\": EndSessionRequest,",
            "    \"EndSessionResponse\": EndSessionResponse,",
            "    \"Claims\": Claims,",
            "    \"OpenIDRequest\": OpenIDRequest,",
            "    \"ProviderConfigurationResponse\": ProviderConfigurationResponse,",
            "    \"AuthnToken\": AuthnToken,",
            "    \"UserInfoErrorResponse\": UserInfoErrorResponse,",
            "    \"DiscoveryRequest\": DiscoveryRequest,",
            "    \"DiscoveryResponse\": DiscoveryResponse,",
            "    \"ResourceRequest\": ResourceRequest,",
            "    # LOGOUT messages",
            "    \"LogoutToken\": LogoutToken,",
            "    \"BackChannelLogoutRequest\": BackChannelLogoutRequest,",
            "    \"FrontChannelLogoutRequest\": FrontChannelLogoutRequest,",
            "}",
            "",
            "",
            "def factory(msgtype):",
            "    warnings.warn(",
            "        \"`factory` is deprecated. Use `OIDCMessageFactory` instead.\", DeprecationWarning",
            "    )",
            "    for _, obj in inspect.getmembers(sys.modules[__name__]):",
            "        if inspect.isclass(obj) and issubclass(obj, Message):",
            "            try:",
            "                if obj.__name__ == msgtype:",
            "                    return obj",
            "            except AttributeError:",
            "                pass",
            "",
            "    # Fall back to basic OAuth2 messages",
            "    return message.factory(msgtype)",
            "",
            "",
            "class OIDCMessageFactory(MessageFactory):",
            "    \"\"\"Factory that knows OIDC message types.\"\"\"",
            "",
            "    authorization_endpoint = MessageTuple(AuthorizationRequest, AuthorizationResponse)",
            "    token_endpoint = MessageTuple(AccessTokenRequest, AccessTokenResponse)",
            "    refresh_endpoint = MessageTuple(RefreshAccessTokenRequest, AccessTokenResponse)",
            "    resource_endpoint = MessageTuple(ResourceRequest, Message)",
            "    configuration_endpoint = MessageTuple(Message, ProviderConfigurationResponse)",
            "",
            "    userinfo_endpoint = MessageTuple(UserInfoRequest, Message)",
            "    registration_endpoint = MessageTuple(RegistrationRequest, RegistrationResponse)",
            "    endsession_endpoint = MessageTuple(EndSessionRequest, EndSessionResponse)",
            "    checkid_endpoint = MessageTuple(CheckIDRequest, IdToken)",
            "    checksession_endpoint = MessageTuple(CheckSessionRequest, IdToken)",
            "    refreshsession_endpoint = MessageTuple(",
            "        RefreshSessionRequest, RefreshSessionResponse",
            "    )",
            "    discovery_endpoint = MessageTuple(DiscoveryRequest, DiscoveryResponse)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "316": [
                "verify_id_token"
            ],
            "317": [
                "verify_id_token"
            ],
            "318": [
                "verify_id_token"
            ],
            "320": [
                "verify_id_token"
            ],
            "326": [
                "verify_id_token"
            ]
        },
        "addLocation": []
    }
}