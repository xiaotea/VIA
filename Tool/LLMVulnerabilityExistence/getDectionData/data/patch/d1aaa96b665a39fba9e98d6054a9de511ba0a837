{
    "rdiffweb/controller/tests/test_page_login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         self.assertEqual('admin', session.get(SESSION_KEY))"
            },
            "1": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         self.assertIsNotNone(session.get(LOGIN_TIME))"
            },
            "2": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    def test_login_case_insensitive(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        # When authenticating with valid credentials with all uppercase username"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        self.getPage('/login/', method='POST', body={'login': self.USERNAME.upper(), 'password': self.PASSWORD})"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # Then a new session_id is generated"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        self.assertStatus('303 See Other')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        self.assertHeaderItemValue('Location', self.baseurl + '/')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        self.getPage('/')"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        self.assertStatus(200)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def test_cookie_http_only(self):"
            },
            "13": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         # Given a request made to rdiffweb"
            },
            "14": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         # When receiving the response"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "import os",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject, UserObject",
            "from rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY",
            "",
            "",
            "class LoginPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/')",
            "        # Then user is redirected to login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # Then a session object is created without a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNone(session.get(SESSION_KEY))",
            "",
            "    def test_login_success(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authenticating with valid credentials.",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a session object is created with a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertEqual('admin', session.get(SESSION_KEY))",
            "        self.assertIsNotNone(session.get(LOGIN_TIME))",
            "",
            "    def test_cookie_http_only(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with HttpOnly",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('HttpOnly', cookie)",
            "",
            "    def test_login_with_plaintext(self):",
            "        \"\"\"",
            "        Requesting plain text without being authenticated should show the login form.",
            "        \"\"\"",
            "        # When querying root page without authentication",
            "        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('with_root', '/'),",
            "            ('with_browse_url', '/browse/admin/testcases/Revisions/'),",
            "            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),",
            "            (",
            "                'with_broken_encoding',",
            "                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',",
            "            ),",
            "            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),",
            "            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),",
            "            ('with_admin', '/admin/'),",
            "        ]",
            "    )",
            "    def test_login(self, unused, original_url):",
            "        # Given an unauthenticated user",
            "        # Query the page without login-in",
            "        self.getPage(original_url)",
            "        # Then user is redirected to the login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authentication is successful",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then user is redirected to original URL",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + original_url)",
            "        # Then cookie is not persistent",
            "        self.assertNotIn('expires', self.cookies[0][1])",
            "        self.assertNotIn('Max-Age', self.cookies[0][1])",
            "        # When requesting the original page",
            "        self.getPage(original_url)",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "",
            "    def test_getpage_with_redirect_post(self):",
            "        \"\"\"",
            "        Check encoding of redirect url when send using POST method.",
            "        \"\"\"",
            "        # When posting invalid credentials",
            "        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        # Then page return without HTTP Error",
            "        self.assertStatus('200 OK')",
            "        # Then page display an error",
            "        self.assertInBody('Invalid username or password.')",
            "        self.assertInBody('form-login')",
            "        # Then redirect URL is ignored",
            "        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')",
            "",
            "    def test_getpage_without_username(self):",
            "        \"\"\"",
            "        Check if error is raised when requesting /login without a username.",
            "        \"\"\"",
            "        self.getPage('/login/', method='GET')",
            "        self.assertStatus('200 OK')",
            "",
            "    def test_getpage_with_username_too_long(self):",
            "        b = {'login': 'admin' * 52, 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('Username too long.')",
            "",
            "    def test_getpage_with_empty_password(self):",
            "        \"\"\"",
            "        Check if authentication is failing without a password.",
            "        \"\"\"",
            "        b = {'login': 'admin', 'password': ''}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('This field is required.')",
            "",
            "    def test_getpage_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='GET')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_post_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='POST')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_login_twice(self):",
            "        # Given an authenticated user",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "        # Given another user",
            "        userobj = UserObject.add_user('otheruser', password='password')",
            "        userobj.commit()",
            "        # When trying to re-authenticated with login page",
            "        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})",
            "        # Then user is still authenticated with previous user",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "",
            "    def test_login_persistent(self):",
            "        # Given a user authenticated with persistent",
            "        self.getPage('/logout', method=\"POST\")",
            "        self.assertStatus(303)",
            "        self.getPage(",
            "            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}",
            "        )",
            "        self.assertStatus(303)",
            "        # Then a persistent cookie is return",
            "        self.assertIn('expires', self.cookies[0][1])",
            "        self.assertIn('Max-Age', self.cookies[0][1])",
            "        # Then a session is created with persistent flag",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # Then session timeout is 30 days in future",
            "        self.assertAlmostEqual(session.timeout, 43200, delta=2)",
            "",
            "",
            "class LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def test_getpage_default(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')",
            "",
            "",
            "class LoginPageWithHeaderName(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'header-name': 'HEADER-NAME'}",
            "",
            "    def test_getpage_default(self):",
            "        # Given a custom header-name",
            "        # When querying the loging page",
            "        self.getPage('/login/')",
            "        # Then the page display the header-name",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('HEADER-NAME')",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'rate-limit': 5}},",
            "        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},",
            "    ]",
            ")",
            "class LoginPageRateLimitTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1')",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1.-login')",
            "        return super().setUp()",
            "",
            "    def test_login_ratelimit(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page",
            "        for i in range(1, 5):",
            "            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "            self.assertStatus(200)",
            "        # Then a 429 error (too many request) is return",
            "        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest2(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_forwarded_for(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Forwarded-For`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then original IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest3(rdiffweb.test.WebCase):",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_real_ip(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Real-IP`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Real-IP', '127.0.0.128')],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then the X-Real-IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Real-IP', '127.0.0.128')],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LogoutPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage_without_login(self):",
            "        # Given an unauthenticated user",
            "        # When Accessing logout page directly",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then user is redirect to root '/'",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_getpage_with_login(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Login",
            "        b = {'login': 'admin', 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('303 See Other')",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        prev_session_id = self.session_id",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('200 OK')",
            "        # When logout",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "import os",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject, UserObject",
            "from rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY",
            "",
            "",
            "class LoginPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/')",
            "        # Then user is redirected to login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # Then a session object is created without a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNone(session.get(SESSION_KEY))",
            "",
            "    def test_login_success(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authenticating with valid credentials.",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a session object is created with a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertEqual('admin', session.get(SESSION_KEY))",
            "        self.assertIsNotNone(session.get(LOGIN_TIME))",
            "",
            "    def test_login_case_insensitive(self):",
            "        # When authenticating with valid credentials with all uppercase username",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME.upper(), 'password': self.PASSWORD})",
            "        # Then a new session_id is generated",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "",
            "    def test_cookie_http_only(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with HttpOnly",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('HttpOnly', cookie)",
            "",
            "    def test_login_with_plaintext(self):",
            "        \"\"\"",
            "        Requesting plain text without being authenticated should show the login form.",
            "        \"\"\"",
            "        # When querying root page without authentication",
            "        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('with_root', '/'),",
            "            ('with_browse_url', '/browse/admin/testcases/Revisions/'),",
            "            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),",
            "            (",
            "                'with_broken_encoding',",
            "                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',",
            "            ),",
            "            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),",
            "            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),",
            "            ('with_admin', '/admin/'),",
            "        ]",
            "    )",
            "    def test_login(self, unused, original_url):",
            "        # Given an unauthenticated user",
            "        # Query the page without login-in",
            "        self.getPage(original_url)",
            "        # Then user is redirected to the login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authentication is successful",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then user is redirected to original URL",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + original_url)",
            "        # Then cookie is not persistent",
            "        self.assertNotIn('expires', self.cookies[0][1])",
            "        self.assertNotIn('Max-Age', self.cookies[0][1])",
            "        # When requesting the original page",
            "        self.getPage(original_url)",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "",
            "    def test_getpage_with_redirect_post(self):",
            "        \"\"\"",
            "        Check encoding of redirect url when send using POST method.",
            "        \"\"\"",
            "        # When posting invalid credentials",
            "        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        # Then page return without HTTP Error",
            "        self.assertStatus('200 OK')",
            "        # Then page display an error",
            "        self.assertInBody('Invalid username or password.')",
            "        self.assertInBody('form-login')",
            "        # Then redirect URL is ignored",
            "        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')",
            "",
            "    def test_getpage_without_username(self):",
            "        \"\"\"",
            "        Check if error is raised when requesting /login without a username.",
            "        \"\"\"",
            "        self.getPage('/login/', method='GET')",
            "        self.assertStatus('200 OK')",
            "",
            "    def test_getpage_with_username_too_long(self):",
            "        b = {'login': 'admin' * 52, 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('Username too long.')",
            "",
            "    def test_getpage_with_empty_password(self):",
            "        \"\"\"",
            "        Check if authentication is failing without a password.",
            "        \"\"\"",
            "        b = {'login': 'admin', 'password': ''}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('This field is required.')",
            "",
            "    def test_getpage_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='GET')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_post_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='POST')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_login_twice(self):",
            "        # Given an authenticated user",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "        # Given another user",
            "        userobj = UserObject.add_user('otheruser', password='password')",
            "        userobj.commit()",
            "        # When trying to re-authenticated with login page",
            "        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})",
            "        # Then user is still authenticated with previous user",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "",
            "    def test_login_persistent(self):",
            "        # Given a user authenticated with persistent",
            "        self.getPage('/logout', method=\"POST\")",
            "        self.assertStatus(303)",
            "        self.getPage(",
            "            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}",
            "        )",
            "        self.assertStatus(303)",
            "        # Then a persistent cookie is return",
            "        self.assertIn('expires', self.cookies[0][1])",
            "        self.assertIn('Max-Age', self.cookies[0][1])",
            "        # Then a session is created with persistent flag",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # Then session timeout is 30 days in future",
            "        self.assertAlmostEqual(session.timeout, 43200, delta=2)",
            "",
            "",
            "class LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def test_getpage_default(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')",
            "",
            "",
            "class LoginPageWithHeaderName(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'header-name': 'HEADER-NAME'}",
            "",
            "    def test_getpage_default(self):",
            "        # Given a custom header-name",
            "        # When querying the loging page",
            "        self.getPage('/login/')",
            "        # Then the page display the header-name",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('HEADER-NAME')",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'rate-limit': 5}},",
            "        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},",
            "    ]",
            ")",
            "class LoginPageRateLimitTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1')",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1.-login')",
            "        return super().setUp()",
            "",
            "    def test_login_ratelimit(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page",
            "        for i in range(1, 5):",
            "            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "            self.assertStatus(200)",
            "        # Then a 429 error (too many request) is return",
            "        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest2(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_forwarded_for(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Forwarded-For`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then original IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest3(rdiffweb.test.WebCase):",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_real_ip(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Real-IP`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Real-IP', '127.0.0.128')],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then the X-Real-IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Real-IP', '127.0.0.128')],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LogoutPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage_without_login(self):",
            "        # Given an unauthenticated user",
            "        # When Accessing logout page directly",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then user is redirect to root '/'",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_getpage_with_login(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Login",
            "        b = {'login': 'admin', 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('303 See Other')",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        prev_session_id = self.session_id",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('200 OK')",
            "        # When logout",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "rdiffweb.controller.tests.test_page_login.LoginPageTest.self",
            "pypdf.generic._data_structures"
        ]
    },
    "rdiffweb/controller/tests/test_page_prefs_general.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         self.assertStatus(303)"
            },
            "1": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         self.getPage(self.PREFS)"
            },
            "2": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.assertInBody(\"Profile updated successfully.\")"
            },
            "3": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Then database is updated with fullname"
            },
            "4": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        # Then database is not updated with new username."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        user = UserObject.get_user(self.USERNAME)"
            },
            "7": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         self.assertIsNotNone(user)"
            },
            "8": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.assertEqual(\"test@test.com\", user.email)"
            },
            "9": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "             self.assertInBody(\"Profile updated successfully.\")"
            },
            "11": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "             # Then database is updated with fullname"
            },
            "12": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             self.assertInBody(new_fullname)"
            },
            "13": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user = UserObject.query.filter(UserObject.username == self.USERNAME).first()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+            user = UserObject.get_user(self.USERNAME)"
            },
            "15": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             self.assertEqual(new_fullname, user.fullname)"
            },
            "16": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         else:"
            },
            "17": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "             self.assertStatus(200)"
            },
            "18": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         # Then nothing happen"
            },
            "19": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "20": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         self.assertNotInBody(\"Profile updated successfully.\")"
            },
            "21": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        user = UserObject.get_user(self.USERNAME)"
            },
            "23": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         self.assertEqual(\"\", user.fullname)"
            },
            "24": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     def test_change_fullname_too_long(self):"
            },
            "26": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         self.assertNotInBody(\"Profile updated successfully.\")"
            },
            "27": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         self.assertInBody(\"Fullname too long.\")"
            },
            "28": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         # Then database is not updated"
            },
            "29": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        user = UserObject.get_user(self.USERNAME)"
            },
            "31": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self.assertEqual(\"\", user.fullname)"
            },
            "32": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "     def test_change_email(self):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import RepoObject, SessionObject, UserObject",
            "",
            "",
            "class PagePrefGeneralTest(rdiffweb.test.WebCase):",
            "",
            "    PREFS = \"/prefs/general\"",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def _set_password(",
            "        self,",
            "        current,",
            "        new_password,",
            "        confirm,",
            "    ):",
            "        b = {",
            "            'action': 'set_password',",
            "            'current': current,",
            "            'new': new_password,",
            "            'confirm': confirm,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def _set_profile_info(self, email, fullname=None):",
            "        b = {",
            "            'action': 'set_profile_info',",
            "            'email': email,",
            "        }",
            "        if fullname:",
            "            b['fullname'] = fullname",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def test_get_page(self):",
            "        # When querying the page",
            "        self.getPage(self.PREFS)",
            "        # Then the page is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody('User profile')",
            "",
            "    def test_change_username_noop(self):",
            "        # Given an authenticated user",
            "        # When updating the username",
            "        self.getPage(",
            "            self.PREFS,",
            "            method='POST',",
            "            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},",
            "        )",
            "        self.assertStatus(303)",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "        # Then database is updated with fullname",
            "        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()",
            "        self.assertIsNotNone(user)",
            "        self.assertEqual(\"test@test.com\", user.email)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('@test.com', False),",
            "            ('test.com', False),",
            "            ('test@te_st.com', False),",
            "            ('test@test.com, test2@test.com', False),",
            "            # Valid",
            "            ('test', True),",
            "            ('My Fullname', True),",
            "        ]",
            "    )",
            "    def test_change_fullname(self, new_fullname, expected_valid):",
            "        # Given an authenticated user",
            "        # When update the fullname",
            "        self._set_profile_info(\"test@test.com\", new_fullname)",
            "        if expected_valid:",
            "            self.assertStatus(303)",
            "            self.getPage(self.PREFS)",
            "            self.assertInBody(\"Profile updated successfully.\")",
            "            # Then database is updated with fullname",
            "            self.assertInBody(new_fullname)",
            "            user = UserObject.query.filter(UserObject.username == self.USERNAME).first()",
            "            self.assertEqual(new_fullname, user.fullname)",
            "        else:",
            "            self.assertStatus(200)",
            "            self.assertNotInBody(\"Profile updated successfully.\")",
            "",
            "    def test_change_fullname_method_get(self):",
            "        # Given an authenticated user",
            "        # When trying to update full name using GET method",
            "        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')",
            "        # Then nothing happen",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Profile updated successfully.\")",
            "        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()",
            "        self.assertEqual(\"\", user.fullname)",
            "",
            "    def test_change_fullname_too_long(self):",
            "        # Given an authenticated user",
            "        # When update the fullname",
            "        self._set_profile_info(\"test@test.com\", \"Fullname\" * 50)",
            "        # Then page return with error message",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Profile updated successfully.\")",
            "        self.assertInBody(\"Fullname too long.\")",
            "        # Then database is not updated",
            "        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()",
            "        self.assertEqual(\"\", user.fullname)",
            "",
            "    def test_change_email(self):",
            "        self._set_profile_info(\"test@test.com\")",
            "        self.assertStatus(303)",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('@test.com', False),",
            "            ('test.com', False),",
            "            ('test', False),",
            "            ('test@te_st.com', False),",
            "            ('test@test.com, test2@test.com', False),",
            "            # Valid",
            "            ('test@test.com', True),",
            "        ]",
            "    )",
            "    def test_change_email_with_invalid_email(self, new_email, expected_valid):",
            "        self._set_profile_info(new_email)",
            "        if expected_valid:",
            "            self.assertStatus(303)",
            "            self.getPage(self.PREFS)",
            "            self.assertInBody(\"Profile updated successfully.\")",
            "            self.assertNotInBody(\"Must be a valid email address.\")",
            "        else:",
            "            self.assertStatus(200)",
            "            self.assertNotInBody(\"Profile updated successfully.\")",
            "            self.assertInBody(\"Must be a valid email address.\")",
            "",
            "    def test_change_email_with_too_long(self):",
            "        self._set_profile_info((\"test1\" * 50) + \"@test.com\")",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_change_password(self):",
            "        # Given a user with 3 active sessions",
            "        self.cookies = None",
            "        self._login(self.USERNAME, self.PASSWORD)",
            "        self.cookies = None",
            "        self._login(self.USERNAME, self.PASSWORD)",
            "        self.assertEqual(3, SessionObject.query.count())",
            "        # When udating user's password",
            "        self.listener.user_password_changed.reset_mock()",
            "        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        # Then user is redirect to same page",
            "        self.assertStatus(303)",
            "        # Then the page return success message.",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Password updated successfully.\")",
            "        # Then a notification is raised",
            "        self.listener.user_password_changed.assert_called_once()",
            "        # Then all users session get deleted except our own session.",
            "        self.assertEqual(1, SessionObject.query.count())",
            "        self.assertEqual(self.session_id, SessionObject.query.first().id)",
            "",
            "    def test_change_password_with_wrong_confirmation(self):",
            "        self._set_password(self.PASSWORD, \"t\", \"a\")",
            "        self.assertInBody(\"The new password and its confirmation do not match.\")",
            "",
            "    def test_change_password_with_wrong_password(self):",
            "        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertInBody(\"Wrong current password\")",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._set_password(self.PASSWORD, \"short\", \"short\")",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._set_password(self.PASSWORD, new_password, new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_same_value(self):",
            "        # Given a user with a password",
            "        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertStatus(303)",
            "        # When updating the pasword with the same password",
            "        self._set_password(\"pr3j5Dwi\", \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertStatus(200)",
            "        # Then an error should be displayed",
            "        self.assertInBody(\"The new password must be different from the current password.\")",
            "",
            "    def test_change_password_method_get(self):",
            "        # Given an authenticated user",
            "        # Trying to update password with GET method",
            "        self.getPage(self.PREFS + '?action=set_password&new=pr3j5Dwi&confirm=pr3j5Dwi&current=' + self.PASSWORD)",
            "        # Then nothing happen",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Password updated successfully.\")",
            "",
            "    def test_invalid_pref(self):",
            "        \"\"\"",
            "        Check if invalid prefs url is 404 Not Found.",
            "        \"\"\"",
            "        self.getPage(\"/prefs/invalid/\")",
            "        self.assertStatus(404)",
            "",
            "    def test_update_repos(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list",
            "        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})",
            "        self.assertStatus(200)",
            "        # Then a success message is displayed",
            "        self.assertInBody('Repositories successfully updated')",
            "        # Then the list is free of inexisting repos.",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "",
            "class PagePrefGeneralRateLimitTest(rdiffweb.test.WebCase):",
            "    login = True",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_change_password_too_many_attemps(self):",
            "        # When udating user's password with wrong current password 5 times",
            "        for _i in range(1, 5):",
            "            self.getPage(",
            "                '/prefs/general',",
            "                method='POST',",
            "                body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},",
            "            )",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"Wrong current password.\")",
            "        # Then user session is cleared and user is redirect to login page",
            "        self.getPage(",
            "            '/prefs/general',",
            "            method='POST',",
            "            body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},",
            "        )",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a warning message is displayed on login page",
            "        self.getPage('/login/')",
            "        self.assertStatus(200)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import RepoObject, SessionObject, UserObject",
            "",
            "",
            "class PagePrefGeneralTest(rdiffweb.test.WebCase):",
            "",
            "    PREFS = \"/prefs/general\"",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def _set_password(",
            "        self,",
            "        current,",
            "        new_password,",
            "        confirm,",
            "    ):",
            "        b = {",
            "            'action': 'set_password',",
            "            'current': current,",
            "            'new': new_password,",
            "            'confirm': confirm,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def _set_profile_info(self, email, fullname=None):",
            "        b = {",
            "            'action': 'set_profile_info',",
            "            'email': email,",
            "        }",
            "        if fullname:",
            "            b['fullname'] = fullname",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def test_get_page(self):",
            "        # When querying the page",
            "        self.getPage(self.PREFS)",
            "        # Then the page is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody('User profile')",
            "",
            "    def test_change_username_noop(self):",
            "        # Given an authenticated user",
            "        # When updating the username",
            "        self.getPage(",
            "            self.PREFS,",
            "            method='POST',",
            "            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},",
            "        )",
            "        self.assertStatus(303)",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "        # Then database is not updated with new username.",
            "        user = UserObject.get_user(self.USERNAME)",
            "        self.assertIsNotNone(user)",
            "        self.assertEqual(\"test@test.com\", user.email)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('@test.com', False),",
            "            ('test.com', False),",
            "            ('test@te_st.com', False),",
            "            ('test@test.com, test2@test.com', False),",
            "            # Valid",
            "            ('test', True),",
            "            ('My Fullname', True),",
            "        ]",
            "    )",
            "    def test_change_fullname(self, new_fullname, expected_valid):",
            "        # Given an authenticated user",
            "        # When update the fullname",
            "        self._set_profile_info(\"test@test.com\", new_fullname)",
            "        if expected_valid:",
            "            self.assertStatus(303)",
            "            self.getPage(self.PREFS)",
            "            self.assertInBody(\"Profile updated successfully.\")",
            "            # Then database is updated with fullname",
            "            self.assertInBody(new_fullname)",
            "            user = UserObject.get_user(self.USERNAME)",
            "            self.assertEqual(new_fullname, user.fullname)",
            "        else:",
            "            self.assertStatus(200)",
            "            self.assertNotInBody(\"Profile updated successfully.\")",
            "",
            "    def test_change_fullname_method_get(self):",
            "        # Given an authenticated user",
            "        # When trying to update full name using GET method",
            "        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')",
            "        # Then nothing happen",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Profile updated successfully.\")",
            "        user = UserObject.get_user(self.USERNAME)",
            "        self.assertEqual(\"\", user.fullname)",
            "",
            "    def test_change_fullname_too_long(self):",
            "        # Given an authenticated user",
            "        # When update the fullname",
            "        self._set_profile_info(\"test@test.com\", \"Fullname\" * 50)",
            "        # Then page return with error message",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Profile updated successfully.\")",
            "        self.assertInBody(\"Fullname too long.\")",
            "        # Then database is not updated",
            "        user = UserObject.get_user(self.USERNAME)",
            "        self.assertEqual(\"\", user.fullname)",
            "",
            "    def test_change_email(self):",
            "        self._set_profile_info(\"test@test.com\")",
            "        self.assertStatus(303)",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('@test.com', False),",
            "            ('test.com', False),",
            "            ('test', False),",
            "            ('test@te_st.com', False),",
            "            ('test@test.com, test2@test.com', False),",
            "            # Valid",
            "            ('test@test.com', True),",
            "        ]",
            "    )",
            "    def test_change_email_with_invalid_email(self, new_email, expected_valid):",
            "        self._set_profile_info(new_email)",
            "        if expected_valid:",
            "            self.assertStatus(303)",
            "            self.getPage(self.PREFS)",
            "            self.assertInBody(\"Profile updated successfully.\")",
            "            self.assertNotInBody(\"Must be a valid email address.\")",
            "        else:",
            "            self.assertStatus(200)",
            "            self.assertNotInBody(\"Profile updated successfully.\")",
            "            self.assertInBody(\"Must be a valid email address.\")",
            "",
            "    def test_change_email_with_too_long(self):",
            "        self._set_profile_info((\"test1\" * 50) + \"@test.com\")",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_change_password(self):",
            "        # Given a user with 3 active sessions",
            "        self.cookies = None",
            "        self._login(self.USERNAME, self.PASSWORD)",
            "        self.cookies = None",
            "        self._login(self.USERNAME, self.PASSWORD)",
            "        self.assertEqual(3, SessionObject.query.count())",
            "        # When udating user's password",
            "        self.listener.user_password_changed.reset_mock()",
            "        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        # Then user is redirect to same page",
            "        self.assertStatus(303)",
            "        # Then the page return success message.",
            "        self.getPage(self.PREFS)",
            "        self.assertInBody(\"Password updated successfully.\")",
            "        # Then a notification is raised",
            "        self.listener.user_password_changed.assert_called_once()",
            "        # Then all users session get deleted except our own session.",
            "        self.assertEqual(1, SessionObject.query.count())",
            "        self.assertEqual(self.session_id, SessionObject.query.first().id)",
            "",
            "    def test_change_password_with_wrong_confirmation(self):",
            "        self._set_password(self.PASSWORD, \"t\", \"a\")",
            "        self.assertInBody(\"The new password and its confirmation do not match.\")",
            "",
            "    def test_change_password_with_wrong_password(self):",
            "        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertInBody(\"Wrong current password\")",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._set_password(self.PASSWORD, \"short\", \"short\")",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._set_password(self.PASSWORD, new_password, new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_same_value(self):",
            "        # Given a user with a password",
            "        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertStatus(303)",
            "        # When updating the pasword with the same password",
            "        self._set_password(\"pr3j5Dwi\", \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertStatus(200)",
            "        # Then an error should be displayed",
            "        self.assertInBody(\"The new password must be different from the current password.\")",
            "",
            "    def test_change_password_method_get(self):",
            "        # Given an authenticated user",
            "        # Trying to update password with GET method",
            "        self.getPage(self.PREFS + '?action=set_password&new=pr3j5Dwi&confirm=pr3j5Dwi&current=' + self.PASSWORD)",
            "        # Then nothing happen",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(\"Password updated successfully.\")",
            "",
            "    def test_invalid_pref(self):",
            "        \"\"\"",
            "        Check if invalid prefs url is 404 Not Found.",
            "        \"\"\"",
            "        self.getPage(\"/prefs/invalid/\")",
            "        self.assertStatus(404)",
            "",
            "    def test_update_repos(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list",
            "        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})",
            "        self.assertStatus(200)",
            "        # Then a success message is displayed",
            "        self.assertInBody('Repositories successfully updated')",
            "        # Then the list is free of inexisting repos.",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "",
            "class PagePrefGeneralRateLimitTest(rdiffweb.test.WebCase):",
            "    login = True",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_change_password_too_many_attemps(self):",
            "        # When udating user's password with wrong current password 5 times",
            "        for _i in range(1, 5):",
            "            self.getPage(",
            "                '/prefs/general',",
            "                method='POST',",
            "                body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},",
            "            )",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"Wrong current password.\")",
            "        # Then user session is cleared and user is redirect to login page",
            "        self.getPage(",
            "            '/prefs/general',",
            "            method='POST',",
            "            body={'action': 'set_password', 'current': 'wrong', 'new': 'pr3j5Dwi', 'confirm': 'pr3j5Dwi'},",
            "        )",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a warning message is displayed on login page",
            "        self.getPage('/login/')",
            "        self.assertStatus(200)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "88": [
                "PagePrefGeneralTest",
                "test_change_username_noop"
            ],
            "89": [
                "PagePrefGeneralTest",
                "test_change_username_noop"
            ],
            "115": [
                "PagePrefGeneralTest",
                "test_change_fullname"
            ],
            "128": [
                "PagePrefGeneralTest",
                "test_change_fullname_method_get"
            ],
            "140": [
                "PagePrefGeneralTest",
                "test_change_fullname_too_long"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         Only verify the user's credentials using the database store."
            },
            "2": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = UserObject.query.filter_by(username=username).first()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        user = UserObject.get_user(username)"
            },
            "5": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         if user and user.validate_password(password):"
            },
            "6": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             return username, {}"
            },
            "7": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         return False"
            },
            "8": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         fullname = extra_attrs.get('_fullname', None)"
            },
            "9": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         email = extra_attrs.get('_email', None)"
            },
            "10": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         # When enabled, create missing userobj in database."
            },
            "11": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        userobj = UserObject.query.filter_by(username=username).first()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        userobj = UserObject.get_user(username)"
            },
            "13": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         if userobj is None and self.add_missing_user:"
            },
            "14": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             try:"
            },
            "15": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                 # At this point, we need to create a new user in database."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "",
            "from rdiffweb.core.model import UserObject",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class LoginPlugin(SimplePlugin):",
            "    \"\"\"",
            "    This plugins register an \"authenticate\" listener to validate",
            "    username and password of users. In addition, it provide a \"login\"",
            "    listener to authenticate and possibly create the user in database.",
            "    \"\"\"",
            "",
            "    add_missing_user = False",
            "    add_user_default_role = UserObject.USER_ROLE",
            "    add_user_default_userroot = None",
            "",
            "    def start(self):",
            "        self.bus.log('Start Login plugin')",
            "        self.bus.subscribe(\"authenticate\", self.authenticate)",
            "        self.bus.subscribe(\"login\", self.login)",
            "",
            "    def stop(self):",
            "        self.bus.log('Stop Login plugin')",
            "        self.bus.unsubscribe(\"authenticate\", self.authenticate)",
            "        self.bus.unsubscribe(\"login\", self.login)",
            "",
            "    def authenticate(self, username, password):",
            "        \"\"\"",
            "        Only verify the user's credentials using the database store.",
            "        \"\"\"",
            "        user = UserObject.query.filter_by(username=username).first()",
            "        if user and user.validate_password(password):",
            "            return username, {}",
            "        return False",
            "",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Validate username password using database and LDAP.",
            "        \"\"\"",
            "        # Validate credentials.",
            "        authenticates = self.bus.publish('authenticate', username, password)",
            "        authenticates = [a for a in authenticates if a]",
            "        if not authenticates:",
            "            return None",
            "        real_username = authenticates[0][0]",
            "        extra_attrs = authenticates[0][1]",
            "        fullname = extra_attrs.get('_fullname', None)",
            "        email = extra_attrs.get('_email', None)",
            "        # When enabled, create missing userobj in database.",
            "        userobj = UserObject.query.filter_by(username=username).first()",
            "        if userobj is None and self.add_missing_user:",
            "            try:",
            "                # At this point, we need to create a new user in database.",
            "                # In case default values are invalid, let evaluate them",
            "                # before creating the user in database.",
            "                default_user_root = self.add_user_default_userroot and self.add_user_default_userroot.format(",
            "                    **extra_attrs",
            "                )",
            "                default_role = UserObject.ROLES.get(self.add_user_default_role)",
            "                userobj = UserObject.add_user(",
            "                    username=real_username,",
            "                    fullname=fullname,",
            "                    email=email,",
            "                    role=default_role,",
            "                    user_root=default_user_root,",
            "                ).commit()",
            "            except Exception:",
            "                logger.error('fail to create new user', exc_info=1)",
            "        if userobj is None:",
            "            # User doesn't exists in database",
            "            return None",
            "",
            "        # Update user attributes",
            "        dirty = False",
            "        if fullname:",
            "            userobj.fullname = fullname",
            "            dirty = True",
            "        if email:",
            "            userobj.email = email",
            "            dirty = True",
            "        if dirty:",
            "            userobj.commit()",
            "        self.bus.publish('user_login', userobj)",
            "        return userobj",
            "",
            "",
            "cherrypy.login = LoginPlugin(cherrypy.engine)",
            "cherrypy.login.subscribe()",
            "",
            "cherrypy.config.namespaces['login'] = lambda key, value: setattr(cherrypy.login, key, value)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "",
            "from rdiffweb.core.model import UserObject",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class LoginPlugin(SimplePlugin):",
            "    \"\"\"",
            "    This plugins register an \"authenticate\" listener to validate",
            "    username and password of users. In addition, it provide a \"login\"",
            "    listener to authenticate and possibly create the user in database.",
            "    \"\"\"",
            "",
            "    add_missing_user = False",
            "    add_user_default_role = UserObject.USER_ROLE",
            "    add_user_default_userroot = None",
            "",
            "    def start(self):",
            "        self.bus.log('Start Login plugin')",
            "        self.bus.subscribe(\"authenticate\", self.authenticate)",
            "        self.bus.subscribe(\"login\", self.login)",
            "",
            "    def stop(self):",
            "        self.bus.log('Stop Login plugin')",
            "        self.bus.unsubscribe(\"authenticate\", self.authenticate)",
            "        self.bus.unsubscribe(\"login\", self.login)",
            "",
            "    def authenticate(self, username, password):",
            "        \"\"\"",
            "        Only verify the user's credentials using the database store.",
            "        \"\"\"",
            "        user = UserObject.get_user(username)",
            "        if user and user.validate_password(password):",
            "            return username, {}",
            "        return False",
            "",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Validate username password using database and LDAP.",
            "        \"\"\"",
            "        # Validate credentials.",
            "        authenticates = self.bus.publish('authenticate', username, password)",
            "        authenticates = [a for a in authenticates if a]",
            "        if not authenticates:",
            "            return None",
            "        real_username = authenticates[0][0]",
            "        extra_attrs = authenticates[0][1]",
            "        fullname = extra_attrs.get('_fullname', None)",
            "        email = extra_attrs.get('_email', None)",
            "        # When enabled, create missing userobj in database.",
            "        userobj = UserObject.get_user(username)",
            "        if userobj is None and self.add_missing_user:",
            "            try:",
            "                # At this point, we need to create a new user in database.",
            "                # In case default values are invalid, let evaluate them",
            "                # before creating the user in database.",
            "                default_user_root = self.add_user_default_userroot and self.add_user_default_userroot.format(",
            "                    **extra_attrs",
            "                )",
            "                default_role = UserObject.ROLES.get(self.add_user_default_role)",
            "                userobj = UserObject.add_user(",
            "                    username=real_username,",
            "                    fullname=fullname,",
            "                    email=email,",
            "                    role=default_role,",
            "                    user_root=default_user_root,",
            "                ).commit()",
            "            except Exception:",
            "                logger.error('fail to create new user', exc_info=1)",
            "        if userobj is None:",
            "            # User doesn't exists in database",
            "            return None",
            "",
            "        # Update user attributes",
            "        dirty = False",
            "        if fullname:",
            "            userobj.fullname = fullname",
            "            dirty = True",
            "        if email:",
            "            userobj.email = email",
            "            dirty = True",
            "        if dirty:",
            "            userobj.commit()",
            "        self.bus.publish('user_login', userobj)",
            "        return userobj",
            "",
            "",
            "cherrypy.login = LoginPlugin(cherrypy.engine)",
            "cherrypy.login.subscribe()",
            "",
            "cherrypy.config.namespaces['login'] = lambda key, value: setattr(cherrypy.login, key, value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "53": [
                "LoginPlugin",
                "authenticate"
            ],
            "72": [
                "LoginPlugin",
                "login"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/model/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " # You should have received a copy of the GNU General Public License"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " # along with this program.  If not, see <http://www.gnu.org/licenses/>."
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+import logging"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+import sys"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import cherrypy"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from sqlalchemy import event"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from sqlalchemy.exc import IntegrityError"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ._repo import RepoObject  # noqa"
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from ._session import DbSession, SessionObject  # noqa"
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ._sshkey import SshKey  # noqa"
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ._token import Token  # noqa"
            },
            "14": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ._user import DuplicateSSHKeyError, UserObject  # noqa"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa"
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " Base = cherrypy.tools.db.get_base()"
            },
            "18": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+logger = logging.getLogger(__name__)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+def _column_add(connection, column):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    if _column_exists(connection, column):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        return"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    table_name = column.table.fullname"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    column_name = column.name"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    column_type = column.type.compile(connection.engine.dialect)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+def _column_exists(connection, column):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    table_name = column.table.fullname"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    column_name = column.name"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    if 'SQLite' in connection.engine.dialect.__class__.__name__:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % ("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            table_name,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            column_name,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    else:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % ("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            table_name,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            column_name,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    data = connection.engine.execute(sql).first()"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    return data[0] >= 1"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+def _index_exists(connection, index_name):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    if 'SQLite' in connection.engine.dialect.__class__.__name__:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        sql = \"SELECT name FROM sqlite_master WHERE type = 'index' AND name = '%s';\" % (index_name)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    else:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        sql = \"SELECT * FROM pg_indexes WHERE indexname = '%s'\" % (index_name)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    return connection.engine.execute(sql).first() is not None"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " @event.listens_for(Base.metadata, 'after_create')"
            },
            "57": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " def db_after_create(target, connection, **kw):"
            },
            "58": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     \"\"\""
            },
            "59": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     Called on database creation to update database schema."
            },
            "60": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     \"\"\""
            },
            "61": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def exists(column):"
            },
            "63": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        table_name = column.table.fullname"
            },
            "64": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        column_name = column.name"
            },
            "65": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if 'SQLite' in connection.engine.dialect.__class__.__name__:"
            },
            "66": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % ("
            },
            "67": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                table_name,"
            },
            "68": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                column_name,"
            },
            "69": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "70": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "71": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % ("
            },
            "72": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                table_name,"
            },
            "73": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                column_name,"
            },
            "74": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "75": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = connection.engine.execute(sql).first()"
            },
            "76": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return data[0] >= 1"
            },
            "77": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "78": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def add_column(column):"
            },
            "79": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if exists(column):"
            },
            "80": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return"
            },
            "81": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        table_name = column.table.fullname"
            },
            "82": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        column_name = column.name"
            },
            "83": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        column_type = column.type.compile(connection.engine.dialect)"
            },
            "84": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))"
            },
            "85": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "86": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     if getattr(connection, '_transaction', None):"
            },
            "87": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         connection._transaction.commit()"
            },
            "88": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     # Add repo's Encoding"
            },
            "90": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    add_column(RepoObject.__table__.c.Encoding)"
            },
            "91": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    add_column(RepoObject.__table__.c.keepdays)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    _column_add(connection, RepoObject.__table__.c.Encoding)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    _column_add(connection, RepoObject.__table__.c.keepdays)"
            },
            "94": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     # Create column for roles using \"isadmin\" column. Keep the"
            },
            "96": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     # original column in case we need to revert to previous version."
            },
            "97": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not exists(UserObject.__table__.c.role):"
            },
            "98": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        add_column(UserObject.__table__.c.role)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+    if not _column_exists(connection, UserObject.__table__.c.role):"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        _column_add(connection, UserObject.__table__.c.role)"
            },
            "101": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})"
            },
            "102": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     # Add user's fullname column"
            },
            "104": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    add_column(UserObject.__table__.c.fullname)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    _column_add(connection, UserObject.__table__.c.fullname)"
            },
            "106": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "107": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     # Add user's mfa column"
            },
            "108": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    add_column(UserObject.__table__.c.mfa)"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    _column_add(connection, UserObject.__table__.c.mfa)"
            },
            "110": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     # Re-create session table if Number column is missing"
            },
            "112": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not exists(SessionObject.__table__.c.Number):"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    if not _column_exists(connection, SessionObject.__table__.c.Number):"
            },
            "114": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         SessionObject.__table__.drop()"
            },
            "115": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         SessionObject.__table__.create()"
            },
            "116": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "117": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     if getattr(connection, '_transaction', None):"
            },
            "118": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         connection._transaction.commit()"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "120": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     # Remove preceding and leading slash (/) generated by previous"
            },
            "121": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     # versions. Also rename '.' to ''"
            },
            "122": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     result = RepoObject.query.all()"
            },
            "123": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "             row.delete()"
            },
            "124": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         else:"
            },
            "125": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             prev_repo = (row.userid, row.repopath)"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    # Fix username case insensitive unique"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    if not _index_exists(connection, 'user_username_index'):"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        duplicate_users = ("
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            UserObject.query.with_entities(func.lower(UserObject.username))"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+            .group_by(func.lower(UserObject.username))"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            .having(func.count(UserObject.username) > 1)"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        ).all()"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        try:"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+            user_username_index.create()"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        except IntegrityError:"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+            msg = ("
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+                'Failure to upgrade your database to make Username case insensitive. '"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+                'You must downgrade and deleted duplicate Username. '"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+                '%s' % '\\n'.join([str(k) for k in duplicate_users]),"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            )"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            logger.error(msg)"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            print(msg, file=sys.stderr)"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            raise SystemExit(12)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import cherrypy",
            "from sqlalchemy import event",
            "",
            "from ._repo import RepoObject  # noqa",
            "from ._session import DbSession, SessionObject  # noqa",
            "from ._sshkey import SshKey  # noqa",
            "from ._token import Token  # noqa",
            "from ._user import DuplicateSSHKeyError, UserObject  # noqa",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "",
            "@event.listens_for(Base.metadata, 'after_create')",
            "def db_after_create(target, connection, **kw):",
            "    \"\"\"",
            "    Called on database creation to update database schema.",
            "    \"\"\"",
            "",
            "    def exists(column):",
            "        table_name = column.table.fullname",
            "        column_name = column.name",
            "        if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "            sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (",
            "                table_name,",
            "                column_name,",
            "            )",
            "        else:",
            "            sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (",
            "                table_name,",
            "                column_name,",
            "            )",
            "        data = connection.engine.execute(sql).first()",
            "        return data[0] >= 1",
            "",
            "    def add_column(column):",
            "        if exists(column):",
            "            return",
            "        table_name = column.table.fullname",
            "        column_name = column.name",
            "        column_type = column.type.compile(connection.engine.dialect)",
            "        connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Add repo's Encoding",
            "    add_column(RepoObject.__table__.c.Encoding)",
            "    add_column(RepoObject.__table__.c.keepdays)",
            "",
            "    # Create column for roles using \"isadmin\" column. Keep the",
            "    # original column in case we need to revert to previous version.",
            "    if not exists(UserObject.__table__.c.role):",
            "        add_column(UserObject.__table__.c.role)",
            "        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})",
            "",
            "    # Add user's fullname column",
            "    add_column(UserObject.__table__.c.fullname)",
            "",
            "    # Add user's mfa column",
            "    add_column(UserObject.__table__.c.mfa)",
            "",
            "    # Re-create session table if Number column is missing",
            "    if not exists(SessionObject.__table__.c.Number):",
            "        SessionObject.__table__.drop()",
            "        SessionObject.__table__.create()",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "    # Remove preceding and leading slash (/) generated by previous",
            "    # versions. Also rename '.' to ''",
            "    result = RepoObject.query.all()",
            "    for row in result:",
            "        if row.repopath.startswith('/') or row.repopath.endswith('/'):",
            "            row.repopath = row.repopath.strip('/')",
            "            row.commit()",
            "        if row.repopath == '.':",
            "            row.repopath = ''",
            "            row.commit()",
            "    # Remove duplicates and nested repositories.",
            "    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()",
            "    prev_repo = (None, None)",
            "    for row in result:",
            "        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):",
            "            row.delete()",
            "        else:",
            "            prev_repo = (row.userid, row.repopath)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "import sys",
            "",
            "import cherrypy",
            "from sqlalchemy import event",
            "from sqlalchemy.exc import IntegrityError",
            "",
            "from ._repo import RepoObject  # noqa",
            "from ._session import DbSession, SessionObject  # noqa",
            "from ._sshkey import SshKey  # noqa",
            "from ._token import Token  # noqa",
            "from ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _column_add(connection, column):",
            "    if _column_exists(connection, column):",
            "        return",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    column_type = column.type.compile(connection.engine.dialect)",
            "    connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))",
            "",
            "",
            "def _column_exists(connection, column):",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    else:",
            "        sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    data = connection.engine.execute(sql).first()",
            "    return data[0] >= 1",
            "",
            "",
            "def _index_exists(connection, index_name):",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT name FROM sqlite_master WHERE type = 'index' AND name = '%s';\" % (index_name)",
            "    else:",
            "        sql = \"SELECT * FROM pg_indexes WHERE indexname = '%s'\" % (index_name)",
            "    return connection.engine.execute(sql).first() is not None",
            "",
            "",
            "@event.listens_for(Base.metadata, 'after_create')",
            "def db_after_create(target, connection, **kw):",
            "    \"\"\"",
            "    Called on database creation to update database schema.",
            "    \"\"\"",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Add repo's Encoding",
            "    _column_add(connection, RepoObject.__table__.c.Encoding)",
            "    _column_add(connection, RepoObject.__table__.c.keepdays)",
            "",
            "    # Create column for roles using \"isadmin\" column. Keep the",
            "    # original column in case we need to revert to previous version.",
            "    if not _column_exists(connection, UserObject.__table__.c.role):",
            "        _column_add(connection, UserObject.__table__.c.role)",
            "        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})",
            "",
            "    # Add user's fullname column",
            "    _column_add(connection, UserObject.__table__.c.fullname)",
            "",
            "    # Add user's mfa column",
            "    _column_add(connection, UserObject.__table__.c.mfa)",
            "",
            "    # Re-create session table if Number column is missing",
            "    if not _column_exists(connection, SessionObject.__table__.c.Number):",
            "        SessionObject.__table__.drop()",
            "        SessionObject.__table__.create()",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Remove preceding and leading slash (/) generated by previous",
            "    # versions. Also rename '.' to ''",
            "    result = RepoObject.query.all()",
            "    for row in result:",
            "        if row.repopath.startswith('/') or row.repopath.endswith('/'):",
            "            row.repopath = row.repopath.strip('/')",
            "            row.commit()",
            "        if row.repopath == '.':",
            "            row.repopath = ''",
            "            row.commit()",
            "    # Remove duplicates and nested repositories.",
            "    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()",
            "    prev_repo = (None, None)",
            "    for row in result:",
            "        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):",
            "            row.delete()",
            "        else:",
            "            prev_repo = (row.userid, row.repopath)",
            "",
            "    # Fix username case insensitive unique",
            "    if not _index_exists(connection, 'user_username_index'):",
            "        duplicate_users = (",
            "            UserObject.query.with_entities(func.lower(UserObject.username))",
            "            .group_by(func.lower(UserObject.username))",
            "            .having(func.count(UserObject.username) > 1)",
            "        ).all()",
            "        try:",
            "            user_username_index.create()",
            "        except IntegrityError:",
            "            msg = (",
            "                'Failure to upgrade your database to make Username case insensitive. '",
            "                'You must downgrade and deleted duplicate Username. '",
            "                '%s' % '\\n'.join([str(k) for k in duplicate_users]),",
            "            )",
            "            logger.error(msg)",
            "            print(msg, file=sys.stderr)",
            "            raise SystemExit(12)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "25": [],
            "36": [
                "db_after_create",
                "exists"
            ],
            "37": [
                "db_after_create",
                "exists"
            ],
            "38": [
                "db_after_create",
                "exists"
            ],
            "39": [
                "db_after_create",
                "exists"
            ],
            "40": [
                "db_after_create",
                "exists"
            ],
            "41": [
                "db_after_create",
                "exists"
            ],
            "42": [
                "db_after_create",
                "exists"
            ],
            "43": [
                "db_after_create",
                "exists"
            ],
            "44": [
                "db_after_create",
                "exists"
            ],
            "45": [
                "db_after_create",
                "exists"
            ],
            "46": [
                "db_after_create",
                "exists"
            ],
            "47": [
                "db_after_create",
                "exists"
            ],
            "48": [
                "db_after_create",
                "exists"
            ],
            "49": [
                "db_after_create",
                "exists"
            ],
            "50": [
                "db_after_create",
                "exists"
            ],
            "51": [
                "db_after_create"
            ],
            "52": [
                "db_after_create",
                "add_column"
            ],
            "53": [
                "db_after_create",
                "add_column"
            ],
            "54": [
                "db_after_create",
                "add_column"
            ],
            "55": [
                "db_after_create",
                "add_column"
            ],
            "56": [
                "db_after_create",
                "add_column"
            ],
            "57": [
                "db_after_create",
                "add_column"
            ],
            "58": [
                "db_after_create",
                "add_column"
            ],
            "59": [
                "db_after_create"
            ],
            "64": [
                "db_after_create"
            ],
            "65": [
                "db_after_create"
            ],
            "69": [
                "db_after_create"
            ],
            "70": [
                "db_after_create"
            ],
            "74": [
                "db_after_create"
            ],
            "77": [
                "db_after_create"
            ],
            "80": [
                "db_after_create"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/model/_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import string"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import cherrypy"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy import Column, Integer, SmallInteger, String, and_, event, inspect, or_"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from sqlalchemy import Column, Index, Integer, SmallInteger, String, and_, event, func, inspect, or_"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from sqlalchemy.exc import IntegrityError"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from sqlalchemy.ext.hybrid import hybrid_property"
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from sqlalchemy.orm import deferred, relationship, validates"
            },
            "8": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\""
            },
            "9": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     userid = Column('UserID', Integer, primary_key=True)"
            },
            "11": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    username = Column('Username', String, nullable=False, unique=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    username = Column('Username', String, nullable=False)"
            },
            "13": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     hash_password = Column('Password', String, nullable=False, default=\"\")"
            },
            "14": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     user_root = Column('UserRoot', String, nullable=False, default=\"\")"
            },
            "15": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     _is_admin = deferred("
            },
            "16": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     @classmethod"
            },
            "18": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     def get_user(cls, user):"
            },
            "19": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Return a user object.\"\"\""
            },
            "20": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return UserObject.query.filter(UserObject.username == user).first()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        \"\"\"Return a user object with username case-insensitive\"\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        return UserObject.query.filter(func.lower(UserObject.username) == user.lower()).first()"
            },
            "23": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     @classmethod"
            },
            "25": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     def create_admin_user(cls, default_username, default_password):"
            },
            "26": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 413,
                "PatchRowcode": "         return check_password(password, self.hash_password)"
            },
            "27": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 414,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 415,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+# Username should be case insensitive"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+user_username_index = Index('user_username_index', func.lower(UserObject.username), unique=True)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 420,
                "PatchRowcode": " @event.listens_for(UserObject.hash_password, \"set\")"
            },
            "34": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 421,
                "PatchRowcode": " def hash_password_set(target, value, oldvalue, initiator):"
            },
            "35": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "     if value and value != oldvalue:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Integer, SmallInteger, String, and_, event, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False, unique=True)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object.\"\"\"",
            "        return UserObject.query.filter(UserObject.username == user).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Index, Integer, SmallInteger, String, and_, event, func, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object with username case-insensitive\"\"\"",
            "        return UserObject.query.filter(func.lower(UserObject.username) == user.lower()).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "# Username should be case insensitive",
            "user_username_index = Index('user_username_index', func.lower(UserObject.username), unique=True)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [],
            "77": [
                "UserObject"
            ],
            "113": [
                "UserObject",
                "get_user"
            ],
            "114": [
                "UserObject",
                "get_user"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/model/tests/test_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         # Check if listener called"
            },
            "1": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self.listener.user_added.assert_not_called()"
            },
            "2": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    def test_add_user_with_duplicate_caseinsensitive(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        \"\"\"Add user to database.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        user = UserObject.add_user('denise')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        user.commit()"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        self.listener.user_added.reset_mock()"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        with self.assertRaises(ValueError):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            UserObject.add_user('dEnIse')"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        # Check if listener called"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        self.listener.user_added.assert_not_called()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     def test_add_user_with_password(self):"
            },
            "14": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         \"\"\"Add user to database with password.\"\"\""
            },
            "15": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         userobj = UserObject.add_user('jo', 'password')"
            },
            "16": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         self.assertEqual('testcases', obj.repo_objs[1].name)"
            },
            "17": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         self.assertEqual(3, obj.repo_objs[1].maxage)"
            },
            "18": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    def test_get_user_case_insensitive(self):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        userobj1 = UserObject.get_user(self.USERNAME)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        userobj2 = UserObject.get_user(self.USERNAME.lower())"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        userobj3 = UserObject.get_user(self.USERNAME.upper())"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self.assertEqual(userobj1, userobj2)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        self.assertEqual(userobj2, userobj3)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     def test_get_user_with_invalid_user(self):"
            },
            "27": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         self.assertIsNone(UserObject.get_user('invalid'))"
            },
            "28": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on June 30, 2022",
            "",
            "Module to test `user` model.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import os",
            "from io import StringIO, open",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject",
            "from rdiffweb.core.passwd import check_password",
            "",
            "",
            "class UserObjectTest(rdiffweb.test.WebCase):",
            "    def _read_ssh_key(self):",
            "        \"\"\"Readthe pub key from test packages\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.readline()",
            "",
            "    def _read_authorized_keys(self):",
            "        \"\"\"Read the content of test_authorized_keys\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.read()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def test_add_user(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_updated_by_listener(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        # Given a listener with side effet",
            "        def change_user_obj(userobj):",
            "            userobj.user_root = '/new/value'",
            "",
            "        self.listener.user_added.side_effect = change_user_obj",
            "        # When adding user",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Then lister get called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "        # Then object was updated by listener",
            "        self.assertEqual('/new/value', userobj.user_root)",
            "",
            "    def test_add_user_with_duplicate(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('denise')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_password(self):",
            "        \"\"\"Add user to database with password.\"\"\"",
            "        userobj = UserObject.add_user('jo', 'password')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('jo'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_delete_admin_user(self):",
            "        # Trying to delete admin user should raise an error.",
            "        userobj = UserObject.get_user('admin')",
            "        with self.assertRaises(ValueError):",
            "            userobj.delete()",
            "",
            "    def test_users(self):",
            "        # Check admin exists",
            "        self.assertEqual(1, UserObject.query.count())",
            "        # Create user.",
            "        user = UserObject.add_user('annik')",
            "        user.commit()",
            "        users = UserObject.query.all()",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual('annik', users[1].username)",
            "        # Then 2 user exists",
            "        self.assertEqual(2, UserObject.query.count())",
            "",
            "    def test_get_user(self):",
            "        # Create new user",
            "        user = UserObject.add_user('bernie', 'my-password')",
            "        user.user_root = self.testcases",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.email = 'bernie@gmail.com'",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        user.repo_objs[0].maxage = -1",
            "        user.repo_objs[1].maxage = 3",
            "        user.commit()",
            "",
            "        # Get user record.",
            "        obj = UserObject.get_user('bernie')",
            "        self.assertIsNotNone(obj)",
            "        self.assertEqual('bernie', obj.username)",
            "        self.assertEqual('bernie@gmail.com', obj.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))",
            "        self.assertEqual(self.testcases, obj.user_root)",
            "        self.assertEqual(True, obj.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)",
            "",
            "        # Get repo object",
            "        self.assertEqual('broker-repo', obj.repo_objs[0].name)",
            "        self.assertEqual(-1, obj.repo_objs[0].maxage)",
            "        self.assertEqual('testcases', obj.repo_objs[1].name)",
            "        self.assertEqual(3, obj.repo_objs[1].maxage)",
            "",
            "    def test_get_user_with_invalid_user(self):",
            "        self.assertIsNone(UserObject.get_user('invalid'))",
            "",
            "    def test_get_set(self):",
            "        user = UserObject.add_user('larry', 'password')",
            "        user.add().commit()",
            "",
            "        self.assertEqual('', user.email)",
            "        self.assertEqual([], user.repo_objs)",
            "        self.assertEqual('', user.user_root)",
            "        self.assertEqual(False, user.is_admin)",
            "        self.assertEqual(UserObject.USER_ROLE, user.role)",
            "",
            "        user.user_root = self.testcases",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(",
            "            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}",
            "        )",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.email = 'larry@gmail.com'",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})",
            "        self.listener.user_attr_changed.reset_mock()",
            "",
            "        self.assertEqual('larry@gmail.com', user.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        self.assertEqual(self.testcases, user.user_root)",
            "        self.assertEqual(True, user.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, user.role)",
            "",
            "    def test_set_role_null(self):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        user.add().commit()",
            "        # When trying to set the role to null",
            "        user.role = None",
            "        # Then an exception is raised",
            "        with self.assertRaises(Exception):",
            "            user.add().commit()",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, False),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_admin(self, role, expected_is_admin):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_admin, user.is_admin)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, True),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_maintainer(self, role, expected_is_maintainer):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_maintainer, user.is_maintainer)",
            "",
            "    def test_set_password_update(self):",
            "        # Given a user in database with a password",
            "        userobj = UserObject.add_user('annik', 'password')",
            "        userobj.commit()",
            "        self.listener.user_password_changed.reset_mock()",
            "        # When updating the user's password",
            "        userobj.set_password('new_password')",
            "        userobj.commit()",
            "        # Then password is SSHA",
            "        self.assertTrue(check_password('new_password', userobj.hash_password))",
            "        # Check if listener called",
            "        self.listener.user_password_changed.assert_called_once_with(userobj)",
            "",
            "    def test_delete_user(self):",
            "        # Given an existing user in database",
            "        userobj = UserObject.add_user('vicky')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('vicky'))",
            "        # When deleting that user",
            "        userobj.delete()",
            "        userobj.commit()",
            "        # Then user it no longer in database",
            "        self.assertIsNone(UserObject.get_user('vicky'))",
            "        # Then listner was called",
            "        self.listener.user_deleted.assert_called_once_with('vicky')",
            "",
            "    def test_set_password_empty(self):",
            "        \"\"\"Expect error when trying to update password of invalid user.\"\"\"",
            "        userobj = UserObject.add_user('john')",
            "        userobj.commit()",
            "        with self.assertRaises(ValueError):",
            "            self.assertFalse(userobj.set_password(''))",
            "",
            "    def test_disk_quota(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.disk_quota",
            "",
            "    def test_disk_usage(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        disk_usage = userobj.disk_usage",
            "        self.assertIsInstance(disk_usage, int)",
            "",
            "    def test_add_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user without an authorizedkey file.",
            "        \"\"\"",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys), \"expecting one key\")",
            "        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)",
            "",
            "    def test_add_authorizedkey_duplicate(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "        # Add the same key",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            userobj.add_authorizedkey(key)",
            "            userobj.commit()",
            "",
            "    def test_add_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user with an authorizedkey file.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "",
            "        # Create empty authorized_keys file",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        open(filename, 'a').close()",
            "",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        with open(filename, 'r') as fh:",
            "            self.assertEqual(key, fh.read())",
            "",
            "    def test_delete_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user without authorizedkey file.",
            "        \"\"\"",
            "        # Update user with ssh keys.",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for k in authorizedkeys.read(StringIO(data)):",
            "            try:",
            "                userobj.add_authorizedkey(k.getvalue())",
            "            except ValueError:",
            "                # Some ssh key in the testing file are not valid.",
            "                pass",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(2, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys))",
            "",
            "    def test_delete_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user with authorizedkey file.",
            "        \"\"\"",
            "        # Create authorized_keys file",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        with open(filename, 'w') as f:",
            "            f.write(data)",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(5, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(4, len(keys))",
            "",
            "    def test_repo_objs(self):",
            "        # Given a user with a list of repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        repos = sorted(userobj.repo_objs, key=lambda r: r.name)",
            "        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])",
            "        # When deleting a repository empty list",
            "        repos[1].delete()",
            "        repos[1].commit()",
            "        # Then the repository is removed from the list.",
            "        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_without_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos()",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_single_repo(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.user_root = os.path.join(self.testcases, 'testcases')",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_empty_userroot(self):",
            "        # Given a user with valid repositories relative to root",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for repo in userobj.repo_objs:",
            "            repo.repopath = self.testcases[1:] + '/' + repo.repopath",
            "            repo.add().commit()",
            "        userobj.user_root = '/'",
            "        userobj.add().commit()",
            "        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))",
            "        # When updating it's userroot directory to an empty value",
            "        userobj.user_root = ''",
            "        userobj.add().commit()",
            "        UserObject.session.expire_all()",
            "        # Then close session",
            "        cherrypy.tools.db.on_end_resource()",
            "        # Then repo status is \"broken\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertFalse(userobj.valid_user_root())",
            "        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])",
            "",
            "",
            "# password: test",
            "@parameterized_class(",
            "    [",
            "        {",
            "            'default_config': {",
            "                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': 'test',",
            "            }",
            "        },",
            "    ]",
            ")",
            "class UserObjectWithAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def test_create_admin_user(self):",
            "        # Given admin-password is configure",
            "        # When database get created",
            "        # Then admin user get created with 'test' password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertIsNotNone(userobj)",
            "        self.assertTrue(check_password('test', userobj.hash_password))",
            "",
            "        # Given admin-password is configure",
            "        # When trying to update admin password",
            "        # Then an exception is raised",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        with self.assertRaises(ValueError):",
            "            userobj.set_password('newpassword')",
            "",
            "",
            "class UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def tearDown(self):",
            "        # Do nothing - We need to makre sure the database is not drop.",
            "        pass",
            "",
            "    def test_create_admin_user_without_password(self):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again",
            "        user = UserObject.create_admin_user(self.USERNAME, None)",
            "        user.commit()",
            "        # Then user password must not be replaced",
            "        self.assertTrue(check_password('test', user.hash_password))",
            "",
            "    @parameterized.expand(",
            "        [",
            "            'puy3qjRWjpCn',",
            "            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',",
            "            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',",
            "        ]",
            "    )",
            "    def test_create_admin_user_with_password(self, new_password):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again with a password",
            "        user = UserObject.create_admin_user(self.USERNAME, new_password)",
            "        user.commit()",
            "        # Then user password get replaced",
            "        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on June 30, 2022",
            "",
            "Module to test `user` model.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import os",
            "from io import StringIO, open",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject",
            "from rdiffweb.core.passwd import check_password",
            "",
            "",
            "class UserObjectTest(rdiffweb.test.WebCase):",
            "    def _read_ssh_key(self):",
            "        \"\"\"Readthe pub key from test packages\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.readline()",
            "",
            "    def _read_authorized_keys(self):",
            "        \"\"\"Read the content of test_authorized_keys\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.read()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def test_add_user(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_updated_by_listener(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        # Given a listener with side effet",
            "        def change_user_obj(userobj):",
            "            userobj.user_root = '/new/value'",
            "",
            "        self.listener.user_added.side_effect = change_user_obj",
            "        # When adding user",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Then lister get called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "        # Then object was updated by listener",
            "        self.assertEqual('/new/value', userobj.user_root)",
            "",
            "    def test_add_user_with_duplicate(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('denise')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_duplicate_caseinsensitive(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('dEnIse')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_password(self):",
            "        \"\"\"Add user to database with password.\"\"\"",
            "        userobj = UserObject.add_user('jo', 'password')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('jo'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_delete_admin_user(self):",
            "        # Trying to delete admin user should raise an error.",
            "        userobj = UserObject.get_user('admin')",
            "        with self.assertRaises(ValueError):",
            "            userobj.delete()",
            "",
            "    def test_users(self):",
            "        # Check admin exists",
            "        self.assertEqual(1, UserObject.query.count())",
            "        # Create user.",
            "        user = UserObject.add_user('annik')",
            "        user.commit()",
            "        users = UserObject.query.all()",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual('annik', users[1].username)",
            "        # Then 2 user exists",
            "        self.assertEqual(2, UserObject.query.count())",
            "",
            "    def test_get_user(self):",
            "        # Create new user",
            "        user = UserObject.add_user('bernie', 'my-password')",
            "        user.user_root = self.testcases",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.email = 'bernie@gmail.com'",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        user.repo_objs[0].maxage = -1",
            "        user.repo_objs[1].maxage = 3",
            "        user.commit()",
            "",
            "        # Get user record.",
            "        obj = UserObject.get_user('bernie')",
            "        self.assertIsNotNone(obj)",
            "        self.assertEqual('bernie', obj.username)",
            "        self.assertEqual('bernie@gmail.com', obj.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))",
            "        self.assertEqual(self.testcases, obj.user_root)",
            "        self.assertEqual(True, obj.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)",
            "",
            "        # Get repo object",
            "        self.assertEqual('broker-repo', obj.repo_objs[0].name)",
            "        self.assertEqual(-1, obj.repo_objs[0].maxage)",
            "        self.assertEqual('testcases', obj.repo_objs[1].name)",
            "        self.assertEqual(3, obj.repo_objs[1].maxage)",
            "",
            "    def test_get_user_case_insensitive(self):",
            "        userobj1 = UserObject.get_user(self.USERNAME)",
            "        userobj2 = UserObject.get_user(self.USERNAME.lower())",
            "        userobj3 = UserObject.get_user(self.USERNAME.upper())",
            "        self.assertEqual(userobj1, userobj2)",
            "        self.assertEqual(userobj2, userobj3)",
            "",
            "    def test_get_user_with_invalid_user(self):",
            "        self.assertIsNone(UserObject.get_user('invalid'))",
            "",
            "    def test_get_set(self):",
            "        user = UserObject.add_user('larry', 'password')",
            "        user.add().commit()",
            "",
            "        self.assertEqual('', user.email)",
            "        self.assertEqual([], user.repo_objs)",
            "        self.assertEqual('', user.user_root)",
            "        self.assertEqual(False, user.is_admin)",
            "        self.assertEqual(UserObject.USER_ROLE, user.role)",
            "",
            "        user.user_root = self.testcases",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(",
            "            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}",
            "        )",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.email = 'larry@gmail.com'",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})",
            "        self.listener.user_attr_changed.reset_mock()",
            "",
            "        self.assertEqual('larry@gmail.com', user.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        self.assertEqual(self.testcases, user.user_root)",
            "        self.assertEqual(True, user.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, user.role)",
            "",
            "    def test_set_role_null(self):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        user.add().commit()",
            "        # When trying to set the role to null",
            "        user.role = None",
            "        # Then an exception is raised",
            "        with self.assertRaises(Exception):",
            "            user.add().commit()",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, False),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_admin(self, role, expected_is_admin):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_admin, user.is_admin)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, True),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_maintainer(self, role, expected_is_maintainer):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_maintainer, user.is_maintainer)",
            "",
            "    def test_set_password_update(self):",
            "        # Given a user in database with a password",
            "        userobj = UserObject.add_user('annik', 'password')",
            "        userobj.commit()",
            "        self.listener.user_password_changed.reset_mock()",
            "        # When updating the user's password",
            "        userobj.set_password('new_password')",
            "        userobj.commit()",
            "        # Then password is SSHA",
            "        self.assertTrue(check_password('new_password', userobj.hash_password))",
            "        # Check if listener called",
            "        self.listener.user_password_changed.assert_called_once_with(userobj)",
            "",
            "    def test_delete_user(self):",
            "        # Given an existing user in database",
            "        userobj = UserObject.add_user('vicky')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('vicky'))",
            "        # When deleting that user",
            "        userobj.delete()",
            "        userobj.commit()",
            "        # Then user it no longer in database",
            "        self.assertIsNone(UserObject.get_user('vicky'))",
            "        # Then listner was called",
            "        self.listener.user_deleted.assert_called_once_with('vicky')",
            "",
            "    def test_set_password_empty(self):",
            "        \"\"\"Expect error when trying to update password of invalid user.\"\"\"",
            "        userobj = UserObject.add_user('john')",
            "        userobj.commit()",
            "        with self.assertRaises(ValueError):",
            "            self.assertFalse(userobj.set_password(''))",
            "",
            "    def test_disk_quota(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.disk_quota",
            "",
            "    def test_disk_usage(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        disk_usage = userobj.disk_usage",
            "        self.assertIsInstance(disk_usage, int)",
            "",
            "    def test_add_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user without an authorizedkey file.",
            "        \"\"\"",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys), \"expecting one key\")",
            "        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)",
            "",
            "    def test_add_authorizedkey_duplicate(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "        # Add the same key",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            userobj.add_authorizedkey(key)",
            "            userobj.commit()",
            "",
            "    def test_add_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user with an authorizedkey file.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "",
            "        # Create empty authorized_keys file",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        open(filename, 'a').close()",
            "",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        with open(filename, 'r') as fh:",
            "            self.assertEqual(key, fh.read())",
            "",
            "    def test_delete_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user without authorizedkey file.",
            "        \"\"\"",
            "        # Update user with ssh keys.",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for k in authorizedkeys.read(StringIO(data)):",
            "            try:",
            "                userobj.add_authorizedkey(k.getvalue())",
            "            except ValueError:",
            "                # Some ssh key in the testing file are not valid.",
            "                pass",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(2, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys))",
            "",
            "    def test_delete_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user with authorizedkey file.",
            "        \"\"\"",
            "        # Create authorized_keys file",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        with open(filename, 'w') as f:",
            "            f.write(data)",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(5, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(4, len(keys))",
            "",
            "    def test_repo_objs(self):",
            "        # Given a user with a list of repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        repos = sorted(userobj.repo_objs, key=lambda r: r.name)",
            "        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])",
            "        # When deleting a repository empty list",
            "        repos[1].delete()",
            "        repos[1].commit()",
            "        # Then the repository is removed from the list.",
            "        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_without_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos()",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_single_repo(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.user_root = os.path.join(self.testcases, 'testcases')",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_empty_userroot(self):",
            "        # Given a user with valid repositories relative to root",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for repo in userobj.repo_objs:",
            "            repo.repopath = self.testcases[1:] + '/' + repo.repopath",
            "            repo.add().commit()",
            "        userobj.user_root = '/'",
            "        userobj.add().commit()",
            "        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))",
            "        # When updating it's userroot directory to an empty value",
            "        userobj.user_root = ''",
            "        userobj.add().commit()",
            "        UserObject.session.expire_all()",
            "        # Then close session",
            "        cherrypy.tools.db.on_end_resource()",
            "        # Then repo status is \"broken\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertFalse(userobj.valid_user_root())",
            "        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])",
            "",
            "",
            "# password: test",
            "@parameterized_class(",
            "    [",
            "        {",
            "            'default_config': {",
            "                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': 'test',",
            "            }",
            "        },",
            "    ]",
            ")",
            "class UserObjectWithAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def test_create_admin_user(self):",
            "        # Given admin-password is configure",
            "        # When database get created",
            "        # Then admin user get created with 'test' password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertIsNotNone(userobj)",
            "        self.assertTrue(check_password('test', userobj.hash_password))",
            "",
            "        # Given admin-password is configure",
            "        # When trying to update admin password",
            "        # Then an exception is raised",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        with self.assertRaises(ValueError):",
            "            userobj.set_password('newpassword')",
            "",
            "",
            "class UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def tearDown(self):",
            "        # Do nothing - We need to makre sure the database is not drop.",
            "        pass",
            "",
            "    def test_create_admin_user_without_password(self):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again",
            "        user = UserObject.create_admin_user(self.USERNAME, None)",
            "        user.commit()",
            "        # Then user password must not be replaced",
            "        self.assertTrue(check_password('test', user.hash_password))",
            "",
            "    @parameterized.expand(",
            "        [",
            "            'puy3qjRWjpCn',",
            "            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',",
            "            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',",
            "        ]",
            "    )",
            "    def test_create_admin_user_with_password(self, new_password):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again with a password",
            "        user = UserObject.create_admin_user(self.USERNAME, new_password)",
            "        user.commit()",
            "        # Then user password get replaced",
            "        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures",
            "rdiffweb.core.model.tests.test_user.UserObjectTest.self"
        ]
    },
    "rdiffweb/core/tests/test_rdw_templating.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " class UrlForTest(WebCase):"
            },
            "1": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     @property"
            },
            "2": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     def repo_obj(self):"
            },
            "3": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = UserObject.query.filter(UserObject.username == 'admin').first()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        user = UserObject.get_user('admin')"
            },
            "5": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         return RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()"
            },
            "6": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     def test_url_for_absolute_path(self):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import unittest",
            "",
            "import cherrypy",
            "",
            "from rdiffweb.core.librdiff import RdiffTime",
            "from rdiffweb.core.model import RepoObject, UserObject",
            "from rdiffweb.core.rdw_templating import _ParentEntry, attrib, do_format_lastupdated, list_parents, url_for",
            "from rdiffweb.test import WebCase",
            "",
            "",
            "class TemplateManagerTest(unittest.TestCase):",
            "    def test_attrib(self):",
            "        # Single value",
            "        self.assertEqual('id=\"row\"', attrib(id='row'))",
            "        # Single value with quote",
            "        self.assertEqual('id=\"val&lt;ue&quot;with&quot;qu&gt;ot&amp;e\"', attrib(id='val<ue\"with\"qu>ot&e'))",
            "        # Multi attribute",
            "        self.assertEqual('id=\"row\" type=\"table\"', attrib(type='table', id='row'))",
            "        # Attribute with list",
            "        self.assertEqual('type=\"table container\"', attrib(type=['table', 'container']))",
            "        # Attribute with class",
            "        self.assertEqual('class=\"table container\"', attrib(**{'class': ['table', 'container']}))",
            "        # Boolean expressions",
            "        self.assertEqual('id=\"active\"', attrib(id=[False, 'active', False]))",
            "        self.assertEqual('data=\"coucou\" id=\"active\"', attrib(type=False, id=[False, 'active', False], data='coucou'))",
            "        active = True",
            "        self.assertEqual('id=\"active\"', attrib(id=[active and 'active']))",
            "        active = False",
            "        self.assertEqual('', attrib(id=[active and 'active']))",
            "",
            "        # With True",
            "        self.assertEqual('selected', attrib(selected=True))",
            "",
            "        # Bytes",
            "        self.assertEqual('selected=\"text\"', attrib(selected=b'text'))",
            "",
            "        # Newstr",
            "        self.assertEqual('selected=\"text\"', attrib(selected=str('text')))",
            "",
            "        self.assertEqual('value=\"0\"', attrib(value=0))",
            "",
            "    def test_url_for(self):",
            "        # Check backward compatibility",
            "        self.assertEqual(cherrypy.server.base() + '/', url_for('/'))",
            "        self.assertEqual(cherrypy.server.base() + '/browse', url_for('browse'))",
            "        self.assertEqual(cherrypy.server.base() + '/browse/testcases', url_for('browse', b'testcases'))",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/testcases/Revisions', url_for('browse', b'testcases', b'Revisions')",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640',",
            "            url_for('restore', b'testcases', b'Revisions', date=1454448640),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640&kind=tar.gz',",
            "            url_for('restore', b'testcases', b'Revisions', date=1454448640, kind='tar.gz'),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/testcases/R%C3%A9pertoire',",
            "            url_for('browse', b'testcases', b'R\\xc3\\xa9pertoire'),",
            "        )",
            "        # Check if multi path is supported.",
            "        self.assertEqual(cherrypy.server.base() + '/admin/logs', url_for('admin/logs'))",
            "        self.assertEqual(cherrypy.server.base() + '/admin/logs/backup.log', url_for('admin/logs', 'backup.log'))",
            "",
            "    def test_do_format_lastupdated(self):",
            "        self.assertEqual('23 seconds ago', do_format_lastupdated(1591978823, now=1591978846))",
            "        self.assertEqual('23 seconds ago', do_format_lastupdated(RdiffTime(value=1591978823), now=1591978846))",
            "        self.assertEqual('8 minutes ago', do_format_lastupdated(RdiffTime(value=1591978324), now=1591978846))",
            "        self.assertEqual('2 hours ago', do_format_lastupdated(RdiffTime(value=1591971646), now=1591978846))",
            "        self.assertEqual('2 days ago', do_format_lastupdated(RdiffTime(value=1591805524), now=1591978846))",
            "        self.assertEqual('4 weeks ago', do_format_lastupdated(RdiffTime(value=1589127124), now=1591978846))",
            "        self.assertEqual('5 months ago', do_format_lastupdated(RdiffTime(value=1578672724), now=1591978846))",
            "        self.assertEqual('4 years ago', do_format_lastupdated(RdiffTime(value=1452442324), now=1591978846))",
            "",
            "",
            "class ListParentsTest(WebCase):",
            "    def test_list_parents_with_root_dir(self):",
            "        repo, path = RepoObject.get_repo_path(b'admin/testcases', as_user=UserObject.get_user('admin'))",
            "        self.assertEqual(list_parents(repo, path), [_ParentEntry(path=b'', display_name='testcases')])",
            "",
            "    def test_list_parents_with_root_subdir(self):",
            "        repo, path = RepoObject.get_repo_path(b'admin/testcases/Revisions', as_user=UserObject.get_user('admin'))",
            "        self.assertEqual(",
            "            list_parents(repo, path),",
            "            [",
            "                _ParentEntry(path=b'', display_name='testcases'),",
            "                _ParentEntry(path=b'Revisions', display_name='Revisions'),",
            "            ],",
            "        )",
            "",
            "",
            "class UrlForTest(WebCase):",
            "    @property",
            "    def repo_obj(self):",
            "        user = UserObject.query.filter(UserObject.username == 'admin').first()",
            "        return RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "",
            "    def test_url_for_absolute_path(self):",
            "        self.assertEqual(cherrypy.server.base() + '/static/js/jquery.min.js', url_for('/static/js/jquery.min.js'))",
            "",
            "    def test_url_for_browse(self):",
            "        \"\"\"Check creation of url\"\"\"",
            "        self.assertEqual(cherrypy.server.base() + '/browse/admin/testcases', url_for('browse', self.repo_obj))",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/admin/testcases/Revisions', url_for('browse', self.repo_obj, b'Revisions')",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/admin/testcases/Revisions?restore=True',",
            "            url_for('browse', self.repo_obj, b'Revisions', restore=True),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base()",
            "            + '/browse/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial',",
            "            url_for(",
            "                'browse',",
            "                self.repo_obj,",
            "                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',",
            "            ),",
            "        )",
            "",
            "    def test_url_for_graphs(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/graphs/files/admin/testcases', url_for('graphs', 'files', self.repo_obj)",
            "        )",
            "",
            "    def test_url_for_history(self):",
            "        \"\"\"Check creation of url\"\"\"",
            "        self.assertEqual(cherrypy.server.base() + '/history/admin/testcases', url_for('history', self.repo_obj))",
            "",
            "    def test_url_for_restore(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',",
            "            url_for('restore', self.repo_obj, date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',",
            "            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021&kind=tar.gz',",
            "            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021), kind='tar.gz'),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases/Revisions?date=1414967021',",
            "            url_for('restore', self.repo_obj, b'Revisions', date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base()",
            "            + '/restore/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial?date=1414967021',",
            "            url_for(",
            "                'restore',",
            "                self.repo_obj,",
            "                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',",
            "                date=RdiffTime(1414967021),",
            "            ),",
            "        )",
            "",
            "    def test_url_for_status(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/status?date=1414967021', url_for('status', date=RdiffTime(1414967021))",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/status/admin/testcases?date=1414967021',",
            "            url_for('status', self.repo_obj, date=RdiffTime(1414967021)),",
            "        )",
            "",
            "    def test_url_for_with_none(self):",
            "        self.assertEqual(cherrypy.server.base() + '/logs', url_for('logs', date=None))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import unittest",
            "",
            "import cherrypy",
            "",
            "from rdiffweb.core.librdiff import RdiffTime",
            "from rdiffweb.core.model import RepoObject, UserObject",
            "from rdiffweb.core.rdw_templating import _ParentEntry, attrib, do_format_lastupdated, list_parents, url_for",
            "from rdiffweb.test import WebCase",
            "",
            "",
            "class TemplateManagerTest(unittest.TestCase):",
            "    def test_attrib(self):",
            "        # Single value",
            "        self.assertEqual('id=\"row\"', attrib(id='row'))",
            "        # Single value with quote",
            "        self.assertEqual('id=\"val&lt;ue&quot;with&quot;qu&gt;ot&amp;e\"', attrib(id='val<ue\"with\"qu>ot&e'))",
            "        # Multi attribute",
            "        self.assertEqual('id=\"row\" type=\"table\"', attrib(type='table', id='row'))",
            "        # Attribute with list",
            "        self.assertEqual('type=\"table container\"', attrib(type=['table', 'container']))",
            "        # Attribute with class",
            "        self.assertEqual('class=\"table container\"', attrib(**{'class': ['table', 'container']}))",
            "        # Boolean expressions",
            "        self.assertEqual('id=\"active\"', attrib(id=[False, 'active', False]))",
            "        self.assertEqual('data=\"coucou\" id=\"active\"', attrib(type=False, id=[False, 'active', False], data='coucou'))",
            "        active = True",
            "        self.assertEqual('id=\"active\"', attrib(id=[active and 'active']))",
            "        active = False",
            "        self.assertEqual('', attrib(id=[active and 'active']))",
            "",
            "        # With True",
            "        self.assertEqual('selected', attrib(selected=True))",
            "",
            "        # Bytes",
            "        self.assertEqual('selected=\"text\"', attrib(selected=b'text'))",
            "",
            "        # Newstr",
            "        self.assertEqual('selected=\"text\"', attrib(selected=str('text')))",
            "",
            "        self.assertEqual('value=\"0\"', attrib(value=0))",
            "",
            "    def test_url_for(self):",
            "        # Check backward compatibility",
            "        self.assertEqual(cherrypy.server.base() + '/', url_for('/'))",
            "        self.assertEqual(cherrypy.server.base() + '/browse', url_for('browse'))",
            "        self.assertEqual(cherrypy.server.base() + '/browse/testcases', url_for('browse', b'testcases'))",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/testcases/Revisions', url_for('browse', b'testcases', b'Revisions')",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640',",
            "            url_for('restore', b'testcases', b'Revisions', date=1454448640),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/testcases/Revisions?date=1454448640&kind=tar.gz',",
            "            url_for('restore', b'testcases', b'Revisions', date=1454448640, kind='tar.gz'),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/testcases/R%C3%A9pertoire',",
            "            url_for('browse', b'testcases', b'R\\xc3\\xa9pertoire'),",
            "        )",
            "        # Check if multi path is supported.",
            "        self.assertEqual(cherrypy.server.base() + '/admin/logs', url_for('admin/logs'))",
            "        self.assertEqual(cherrypy.server.base() + '/admin/logs/backup.log', url_for('admin/logs', 'backup.log'))",
            "",
            "    def test_do_format_lastupdated(self):",
            "        self.assertEqual('23 seconds ago', do_format_lastupdated(1591978823, now=1591978846))",
            "        self.assertEqual('23 seconds ago', do_format_lastupdated(RdiffTime(value=1591978823), now=1591978846))",
            "        self.assertEqual('8 minutes ago', do_format_lastupdated(RdiffTime(value=1591978324), now=1591978846))",
            "        self.assertEqual('2 hours ago', do_format_lastupdated(RdiffTime(value=1591971646), now=1591978846))",
            "        self.assertEqual('2 days ago', do_format_lastupdated(RdiffTime(value=1591805524), now=1591978846))",
            "        self.assertEqual('4 weeks ago', do_format_lastupdated(RdiffTime(value=1589127124), now=1591978846))",
            "        self.assertEqual('5 months ago', do_format_lastupdated(RdiffTime(value=1578672724), now=1591978846))",
            "        self.assertEqual('4 years ago', do_format_lastupdated(RdiffTime(value=1452442324), now=1591978846))",
            "",
            "",
            "class ListParentsTest(WebCase):",
            "    def test_list_parents_with_root_dir(self):",
            "        repo, path = RepoObject.get_repo_path(b'admin/testcases', as_user=UserObject.get_user('admin'))",
            "        self.assertEqual(list_parents(repo, path), [_ParentEntry(path=b'', display_name='testcases')])",
            "",
            "    def test_list_parents_with_root_subdir(self):",
            "        repo, path = RepoObject.get_repo_path(b'admin/testcases/Revisions', as_user=UserObject.get_user('admin'))",
            "        self.assertEqual(",
            "            list_parents(repo, path),",
            "            [",
            "                _ParentEntry(path=b'', display_name='testcases'),",
            "                _ParentEntry(path=b'Revisions', display_name='Revisions'),",
            "            ],",
            "        )",
            "",
            "",
            "class UrlForTest(WebCase):",
            "    @property",
            "    def repo_obj(self):",
            "        user = UserObject.get_user('admin')",
            "        return RepoObject.query.filter(RepoObject.user == user, RepoObject.repopath == self.REPO).first()",
            "",
            "    def test_url_for_absolute_path(self):",
            "        self.assertEqual(cherrypy.server.base() + '/static/js/jquery.min.js', url_for('/static/js/jquery.min.js'))",
            "",
            "    def test_url_for_browse(self):",
            "        \"\"\"Check creation of url\"\"\"",
            "        self.assertEqual(cherrypy.server.base() + '/browse/admin/testcases', url_for('browse', self.repo_obj))",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/admin/testcases/Revisions', url_for('browse', self.repo_obj, b'Revisions')",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/browse/admin/testcases/Revisions?restore=True',",
            "            url_for('browse', self.repo_obj, b'Revisions', restore=True),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base()",
            "            + '/browse/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial',",
            "            url_for(",
            "                'browse',",
            "                self.repo_obj,",
            "                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',",
            "            ),",
            "        )",
            "",
            "    def test_url_for_graphs(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/graphs/files/admin/testcases', url_for('graphs', 'files', self.repo_obj)",
            "        )",
            "",
            "    def test_url_for_history(self):",
            "        \"\"\"Check creation of url\"\"\"",
            "        self.assertEqual(cherrypy.server.base() + '/history/admin/testcases', url_for('history', self.repo_obj))",
            "",
            "    def test_url_for_restore(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',",
            "            url_for('restore', self.repo_obj, date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021',",
            "            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases?date=1414967021&kind=tar.gz',",
            "            url_for('restore', self.repo_obj, b'', date=RdiffTime(1414967021), kind='tar.gz'),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/restore/admin/testcases/Revisions?date=1414967021',",
            "            url_for('restore', self.repo_obj, b'Revisions', date=RdiffTime(1414967021)),",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base()",
            "            + '/restore/admin/testcases/R%C3%A9pertoire%20%28%40vec%29%20%7Bc%C3%A0ra%C3%A7t%23%C3%A8r%C3%AB%7D%20%24%C3%A9p%C3%AAcial?date=1414967021',",
            "            url_for(",
            "                'restore',",
            "                self.repo_obj,",
            "                b'R\\xc3\\xa9pertoire (@vec) {c\\xc3\\xa0ra\\xc3\\xa7t#\\xc3\\xa8r\\xc3\\xab} $\\xc3\\xa9p\\xc3\\xaacial',",
            "                date=RdiffTime(1414967021),",
            "            ),",
            "        )",
            "",
            "    def test_url_for_status(self):",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/status?date=1414967021', url_for('status', date=RdiffTime(1414967021))",
            "        )",
            "        self.assertEqual(",
            "            cherrypy.server.base() + '/status/admin/testcases?date=1414967021',",
            "            url_for('status', self.repo_obj, date=RdiffTime(1414967021)),",
            "        )",
            "",
            "    def test_url_for_with_none(self):",
            "        self.assertEqual(cherrypy.server.base() + '/logs', url_for('logs', date=None))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "113": [
                "UrlForTest",
                "repo_obj"
            ]
        },
        "addLocation": []
    }
}