{
    "src/wiki/core/markdown/mdx/codehilite.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from textwrap import dedent"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+"
            },
            "2": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import logging"
            },
            "3": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import re"
            },
            "4": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from markdown.treeprocessors import Treeprocessor"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from wiki.core.markdown import add_to_registry"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     FENCED_BLOCK_RE = re.compile("
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-(?P<fence>^(?:~{3,}|`{3,}))[ ]*         # Opening ``` or ~~~"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-(\\{?\\.?(?P<lang>[a-zA-Z0-9_+-]*))?[ ]*  # Optional {, and lang"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# Optional highlight lines, single- or double-quote-delimited"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-(hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot))?[ ]*"
            },
            "20": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-}?[ ]*\\n                                # Optional closing }"
            },
            "21": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-(?P<code>.*?)(?<=\\n)"
            },
            "22": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-(?P=fence)[ ]*$\"\"\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        dedent("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            r\"\"\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            (?P<fence>^(?:~{3,}|`{3,}))[ ]*                          # opening fence"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            ((\\{(?P<attrs>[^\\}\\n]*)\\})|                              # (optional {attrs} or"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            (\\.?(?P<lang>[\\w#.+-]*)[ ]*)?                            # optional (.)lang"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            (hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot)[ ]*)?) # optional hl_lines)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            \\n                                                       # newline (end of opening fence)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            (?P<code>.*?)(?<=\\n)                                     # the code block"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            (?P=fence)[ ]*$                                          # closing fence"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        \"\"\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        ),"
            },
            "34": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         re.MULTILINE | re.DOTALL | re.VERBOSE,"
            },
            "35": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     )"
            },
            "36": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     CODE_WRAP = \"<pre>%s</pre>\""
            }
        },
        "frontPatchFile": [
            "import logging",
            "import re",
            "",
            "from markdown.extensions.codehilite import CodeHilite",
            "from markdown.extensions.codehilite import CodeHiliteExtension",
            "from markdown.preprocessors import Preprocessor",
            "from markdown.treeprocessors import Treeprocessor",
            "from wiki.core.markdown import add_to_registry",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def highlight(code, config, tab_length, lang=None):",
            "    code = CodeHilite(",
            "        code,",
            "        linenums=config[\"linenums\"],",
            "        guess_lang=config[\"guess_lang\"],",
            "        css_class=config[\"css_class\"],",
            "        style=config[\"pygments_style\"],",
            "        noclasses=config[\"noclasses\"],",
            "        tab_length=tab_length,",
            "        use_pygments=config[\"use_pygments\"],",
            "        lang=lang,",
            "    )",
            "    html = code.hilite()",
            "    html = \"\"\"<div class=\"codehilite-wrap\">{}</div>\"\"\".format(html)",
            "    return html",
            "",
            "",
            "class WikiFencedBlockPreprocessor(Preprocessor):",
            "    \"\"\"",
            "    This is a replacement of markdown.extensions.fenced_code which will",
            "    directly and without configuration options invoke the vanilla CodeHilite",
            "    extension.",
            "    \"\"\"",
            "",
            "    FENCED_BLOCK_RE = re.compile(",
            "        r\"\"\"",
            "(?P<fence>^(?:~{3,}|`{3,}))[ ]*         # Opening ``` or ~~~",
            "(\\{?\\.?(?P<lang>[a-zA-Z0-9_+-]*))?[ ]*  # Optional {, and lang",
            "# Optional highlight lines, single- or double-quote-delimited",
            "(hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot))?[ ]*",
            "}?[ ]*\\n                                # Optional closing }",
            "(?P<code>.*?)(?<=\\n)",
            "(?P=fence)[ ]*$\"\"\",",
            "        re.MULTILINE | re.DOTALL | re.VERBOSE,",
            "    )",
            "    CODE_WRAP = \"<pre>%s</pre>\"",
            "",
            "    def __init__(self, md):",
            "        super().__init__(md)",
            "",
            "        self.checked_for_codehilite = False",
            "        self.codehilite_conf = {}",
            "",
            "    def run(self, lines):",
            "        \"\"\"Match and store Fenced Code Blocks in the HtmlStash.\"\"\"",
            "",
            "        text = \"\\n\".join(lines)",
            "        while 1:",
            "            m = self.FENCED_BLOCK_RE.search(text)",
            "            if m:",
            "                lang = \"\"",
            "                if m.group(\"lang\"):",
            "                    lang = m.group(\"lang\")",
            "                html = highlight(",
            "                    m.group(\"code\"), self.config, self.md.tab_length, lang=lang",
            "                )",
            "                placeholder = self.md.htmlStash.store(html)",
            "                text = \"%s\\n%s\\n%s\" % (",
            "                    text[: m.start()],",
            "                    placeholder,",
            "                    text[m.end() :],",
            "                )",
            "            else:",
            "                break",
            "        return text.split(\"\\n\")",
            "",
            "",
            "class HiliteTreeprocessor(Treeprocessor):",
            "    \"\"\"Hilight source code in code blocks.\"\"\"",
            "",
            "    def code_unescape(self, text):",
            "        \"\"\"Unescape &, <, > and \" characters.\"\"\"",
            "        text = text.replace(\"&amp;\", \"&\")",
            "        text = text.replace(\"&lt;\", \"<\")",
            "        text = text.replace(\"&gt;\", \">\")",
            "        text = text.replace(\"&quot;\", '\"')",
            "        return text",
            "",
            "    def run(self, root):",
            "        \"\"\"Find code blocks and store in htmlStash.\"\"\"",
            "        blocks = root.iter(\"pre\")",
            "        for block in blocks:",
            "            if len(block) == 1 and block[0].tag == \"code\":",
            "                html = highlight(",
            "                    self.code_unescape(block[0].text),",
            "                    self.config,",
            "                    self.md.tab_length,",
            "                )",
            "                placeholder = self.md.htmlStash.store(html)",
            "                # Clear codeblock in etree instance",
            "                block.clear()",
            "                # Change to p element which will later",
            "                # be removed when inserting raw html",
            "                block.tag = \"p\"",
            "                block.text = placeholder",
            "",
            "",
            "class WikiCodeHiliteExtension(CodeHiliteExtension):",
            "    \"\"\"",
            "    markdown.extensions.codehilite cannot configure container tags but forces",
            "    code to be in <table></table>, so we had to overwrite some of the code",
            "    because it's hard to extend...",
            "    \"\"\"",
            "",
            "    def extendMarkdown(self, md):",
            "        \"\"\"Add HilitePostprocessor to Markdown instance.\"\"\"",
            "        hiliter = HiliteTreeprocessor(md)",
            "        hiliter.config = self.getConfigs()",
            "        if \"hilite\" in md.treeprocessors:",
            "            logger.warning(",
            "                \"Replacing existing 'hilite' extension - please remove \"",
            "                \"'codehilite' from WIKI_MARKDOWN_KWARGS\"",
            "            )",
            "            # del md.treeprocessors[\"hilite\"]",
            "            md.treeprocessors.deregister(\"hilite\")",
            "",
            "        add_to_registry(md.treeprocessors, \"hilite\", hiliter, \"<inline\")",
            "",
            "        if \"fenced_code_block\" in md.preprocessors:",
            "            logger.warning(",
            "                \"Replacing existing 'fenced_code_block' extension - please remove \"",
            "                \"'fenced_code_block' or 'extras' from WIKI_MARKDOWN_KWARGS\"",
            "            )",
            "            # del md.preprocessors[\"fenced_code_block\"]",
            "            md.preprocessors.deregister(\"fenced_code_block\")",
            "        hiliter = WikiFencedBlockPreprocessor(md)",
            "        hiliter.config = self.getConfigs()",
            "",
            "        add_to_registry(",
            "            md.preprocessors,",
            "            \"fenced_code_block\",",
            "            hiliter,",
            "            \">normalize_whitespace\",",
            "        )",
            "",
            "        md.registerExtension(self)",
            "",
            "",
            "def makeExtension(*args, **kwargs):",
            "    \"\"\"Return an instance of the extension.\"\"\"",
            "    return WikiCodeHiliteExtension(*args, **kwargs)"
        ],
        "afterPatchFile": [
            "from textwrap import dedent",
            "",
            "import logging",
            "import re",
            "",
            "from markdown.extensions.codehilite import CodeHilite",
            "from markdown.extensions.codehilite import CodeHiliteExtension",
            "from markdown.preprocessors import Preprocessor",
            "from markdown.treeprocessors import Treeprocessor",
            "from wiki.core.markdown import add_to_registry",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def highlight(code, config, tab_length, lang=None):",
            "    code = CodeHilite(",
            "        code,",
            "        linenums=config[\"linenums\"],",
            "        guess_lang=config[\"guess_lang\"],",
            "        css_class=config[\"css_class\"],",
            "        style=config[\"pygments_style\"],",
            "        noclasses=config[\"noclasses\"],",
            "        tab_length=tab_length,",
            "        use_pygments=config[\"use_pygments\"],",
            "        lang=lang,",
            "    )",
            "    html = code.hilite()",
            "    html = \"\"\"<div class=\"codehilite-wrap\">{}</div>\"\"\".format(html)",
            "    return html",
            "",
            "",
            "class WikiFencedBlockPreprocessor(Preprocessor):",
            "    \"\"\"",
            "    This is a replacement of markdown.extensions.fenced_code which will",
            "    directly and without configuration options invoke the vanilla CodeHilite",
            "    extension.",
            "    \"\"\"",
            "",
            "    FENCED_BLOCK_RE = re.compile(",
            "        dedent(",
            "            r\"\"\"",
            "            (?P<fence>^(?:~{3,}|`{3,}))[ ]*                          # opening fence",
            "            ((\\{(?P<attrs>[^\\}\\n]*)\\})|                              # (optional {attrs} or",
            "            (\\.?(?P<lang>[\\w#.+-]*)[ ]*)?                            # optional (.)lang",
            "            (hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot)[ ]*)?) # optional hl_lines)",
            "            \\n                                                       # newline (end of opening fence)",
            "            (?P<code>.*?)(?<=\\n)                                     # the code block",
            "            (?P=fence)[ ]*$                                          # closing fence",
            "        \"\"\"",
            "        ),",
            "        re.MULTILINE | re.DOTALL | re.VERBOSE,",
            "    )",
            "    CODE_WRAP = \"<pre>%s</pre>\"",
            "",
            "    def __init__(self, md):",
            "        super().__init__(md)",
            "",
            "        self.checked_for_codehilite = False",
            "        self.codehilite_conf = {}",
            "",
            "    def run(self, lines):",
            "        \"\"\"Match and store Fenced Code Blocks in the HtmlStash.\"\"\"",
            "",
            "        text = \"\\n\".join(lines)",
            "        while 1:",
            "            m = self.FENCED_BLOCK_RE.search(text)",
            "            if m:",
            "                lang = \"\"",
            "                if m.group(\"lang\"):",
            "                    lang = m.group(\"lang\")",
            "                html = highlight(",
            "                    m.group(\"code\"), self.config, self.md.tab_length, lang=lang",
            "                )",
            "                placeholder = self.md.htmlStash.store(html)",
            "                text = \"%s\\n%s\\n%s\" % (",
            "                    text[: m.start()],",
            "                    placeholder,",
            "                    text[m.end() :],",
            "                )",
            "            else:",
            "                break",
            "        return text.split(\"\\n\")",
            "",
            "",
            "class HiliteTreeprocessor(Treeprocessor):",
            "    \"\"\"Hilight source code in code blocks.\"\"\"",
            "",
            "    def code_unescape(self, text):",
            "        \"\"\"Unescape &, <, > and \" characters.\"\"\"",
            "        text = text.replace(\"&amp;\", \"&\")",
            "        text = text.replace(\"&lt;\", \"<\")",
            "        text = text.replace(\"&gt;\", \">\")",
            "        text = text.replace(\"&quot;\", '\"')",
            "        return text",
            "",
            "    def run(self, root):",
            "        \"\"\"Find code blocks and store in htmlStash.\"\"\"",
            "        blocks = root.iter(\"pre\")",
            "        for block in blocks:",
            "            if len(block) == 1 and block[0].tag == \"code\":",
            "                html = highlight(",
            "                    self.code_unescape(block[0].text),",
            "                    self.config,",
            "                    self.md.tab_length,",
            "                )",
            "                placeholder = self.md.htmlStash.store(html)",
            "                # Clear codeblock in etree instance",
            "                block.clear()",
            "                # Change to p element which will later",
            "                # be removed when inserting raw html",
            "                block.tag = \"p\"",
            "                block.text = placeholder",
            "",
            "",
            "class WikiCodeHiliteExtension(CodeHiliteExtension):",
            "    \"\"\"",
            "    markdown.extensions.codehilite cannot configure container tags but forces",
            "    code to be in <table></table>, so we had to overwrite some of the code",
            "    because it's hard to extend...",
            "    \"\"\"",
            "",
            "    def extendMarkdown(self, md):",
            "        \"\"\"Add HilitePostprocessor to Markdown instance.\"\"\"",
            "        hiliter = HiliteTreeprocessor(md)",
            "        hiliter.config = self.getConfigs()",
            "        if \"hilite\" in md.treeprocessors:",
            "            logger.warning(",
            "                \"Replacing existing 'hilite' extension - please remove \"",
            "                \"'codehilite' from WIKI_MARKDOWN_KWARGS\"",
            "            )",
            "            # del md.treeprocessors[\"hilite\"]",
            "            md.treeprocessors.deregister(\"hilite\")",
            "",
            "        add_to_registry(md.treeprocessors, \"hilite\", hiliter, \"<inline\")",
            "",
            "        if \"fenced_code_block\" in md.preprocessors:",
            "            logger.warning(",
            "                \"Replacing existing 'fenced_code_block' extension - please remove \"",
            "                \"'fenced_code_block' or 'extras' from WIKI_MARKDOWN_KWARGS\"",
            "            )",
            "            # del md.preprocessors[\"fenced_code_block\"]",
            "            md.preprocessors.deregister(\"fenced_code_block\")",
            "        hiliter = WikiFencedBlockPreprocessor(md)",
            "        hiliter.config = self.getConfigs()",
            "",
            "        add_to_registry(",
            "            md.preprocessors,",
            "            \"fenced_code_block\",",
            "            hiliter,",
            "            \">normalize_whitespace\",",
            "        )",
            "",
            "        md.registerExtension(self)",
            "",
            "",
            "def makeExtension(*args, **kwargs):",
            "    \"\"\"Return an instance of the extension.\"\"\"",
            "    return WikiCodeHiliteExtension(*args, **kwargs)"
        ],
        "action": [
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "WikiFencedBlockPreprocessor"
            ],
            "39": [
                "WikiFencedBlockPreprocessor"
            ],
            "40": [
                "WikiFencedBlockPreprocessor"
            ],
            "41": [
                "WikiFencedBlockPreprocessor"
            ],
            "42": [
                "WikiFencedBlockPreprocessor"
            ],
            "43": [
                "WikiFencedBlockPreprocessor"
            ],
            "44": [
                "WikiFencedBlockPreprocessor"
            ],
            "45": [
                "WikiFencedBlockPreprocessor"
            ]
        },
        "addLocation": []
    },
    "src/wiki/plugins/macros/mdx/macro.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " # http://stackoverflow.com/questions/430759/regex-for-managing-escaped-characters-for-items-like-string-literals"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " re_sq_short = r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\""
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-MACRO_RE = r\"(\\[(?P<macro>\\w+)(?P<kwargs>\\s\\w+\\:.+)*\\])\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+MACRO_RE = ("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    r\"\"\"\\[(?P<macro>\\w+)(?P<kwargs>(\\s+\\w+\\:([^\\:\\]\\s]+|'[^']+'))+)*\\]\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " KWARG_RE = re.compile("
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     r\"\\s*(?P<arg>\\w+)(:(?P<value>([^\\']+|%s)))?\" % re_sq_short, re.IGNORECASE"
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " )"
            },
            "12": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         kwargs = m.group(\"kwargs\")"
            },
            "13": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         if not kwargs:"
            },
            "14": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             return getattr(self, macro)()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         kwargs_dict = {}"
            },
            "17": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         for kwarg in KWARG_RE.finditer(kwargs):"
            },
            "18": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             arg = kwarg.group(\"arg\")"
            },
            "19": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             value = kwarg.group(\"value\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "             if value is None:"
            },
            "22": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "                 value = True"
            },
            "23": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             if isinstance(value, str):"
            }
        },
        "frontPatchFile": [
            "import re",
            "",
            "import markdown",
            "from django.template.loader import render_to_string",
            "from django.utils.translation import gettext as _",
            "from wiki.core.markdown import add_to_registry",
            "from wiki.plugins.macros import settings",
            "from wiki.plugins.macros.mdx import toc",
            "",
            "# See:",
            "# http://stackoverflow.com/questions/430759/regex-for-managing-escaped-characters-for-items-like-string-literals",
            "re_sq_short = r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\"",
            "",
            "MACRO_RE = r\"(\\[(?P<macro>\\w+)(?P<kwargs>\\s\\w+\\:.+)*\\])\"",
            "KWARG_RE = re.compile(",
            "    r\"\\s*(?P<arg>\\w+)(:(?P<value>([^\\']+|%s)))?\" % re_sq_short, re.IGNORECASE",
            ")",
            "",
            "",
            "class MacroExtension(markdown.Extension):",
            "",
            "    \"\"\"Macro plugin markdown extension for django-wiki.\"\"\"",
            "",
            "    def extendMarkdown(self, md):",
            "        add_to_registry(",
            "            md.inlinePatterns, \"dw-macros\", MacroPattern(MACRO_RE, md), \">link\"",
            "        )",
            "",
            "",
            "class MacroPattern(markdown.inlinepatterns.Pattern):",
            "",
            "    \"\"\"django-wiki macro preprocessor - parse text for various [some_macro] and",
            "    [some_macro (kw:arg)*] references.\"\"\"",
            "",
            "    def __init__(self, pattern, md=None):",
            "        \"\"\"Override init in order to add IGNORECASE flag\"\"\"",
            "        super().__init__(pattern, md=md)",
            "        self.compiled_re = re.compile(",
            "            r\"^(.*?)%s(.*)$\" % pattern,",
            "            flags=re.DOTALL | re.UNICODE | re.IGNORECASE,",
            "        )",
            "",
            "    def handleMatch(self, m):",
            "        macro = m.group(\"macro\").strip().lower()",
            "        if macro not in settings.METHODS or not hasattr(self, macro):",
            "            return m.group(2)",
            "",
            "        kwargs = m.group(\"kwargs\")",
            "        if not kwargs:",
            "            return getattr(self, macro)()",
            "        kwargs_dict = {}",
            "        for kwarg in KWARG_RE.finditer(kwargs):",
            "            arg = kwarg.group(\"arg\")",
            "            value = kwarg.group(\"value\")",
            "            if value is None:",
            "                value = True",
            "            if isinstance(value, str):",
            "                # If value is enclosed with ': Remove and",
            "                # remove escape sequences",
            "                if value.startswith(\"'\") and len(value) > 2:",
            "                    value = value[1:-1]",
            "                    value = value.replace(\"\\\\\\\\\", \"\u00a4KEEPME\u00a4\")",
            "                    value = value.replace(\"\\\\\", \"\")",
            "                    value = value.replace(\"\u00a4KEEPME\u00a4\", \"\\\\\")",
            "            kwargs_dict[str(arg)] = value",
            "        return getattr(self, macro)(**kwargs_dict)",
            "",
            "    def article_list(self, depth=\"2\"):",
            "        html = render_to_string(",
            "            \"wiki/plugins/macros/article_list.html\",",
            "            context={",
            "                \"article_children\": self.md.article.get_children(",
            "                    article__current_revision__deleted=False",
            "                ),",
            "                \"depth\": int(depth) + 1,",
            "            },",
            "        )",
            "        return self.md.htmlStash.store(html)",
            "",
            "    article_list.meta = {",
            "        \"short_description\": _(\"Article list\"),",
            "        \"help_text\": _(\"Insert a list of articles in this level.\"),",
            "        \"example_code\": \"[article_list depth:2]\",",
            "        \"args\": {\"depth\": _(\"Maximum depth to show levels for.\")},",
            "    }",
            "",
            "    def toc(self, **kwargs):",
            "        toc.WikiTreeProcessorClass.CACHED_KWARGS = kwargs",
            "        return \"[TOC]\"",
            "",
            "    toc.meta = {",
            "        \"short_description\": _(\"Table of contents\"),",
            "        \"help_text\": _(\"Insert a table of contents matching the headings.\"),",
            "        \"example_code\": \"[TOC] or [TOC toc_depth:1]\",",
            "        \"args\": {",
            "            \"title\": _(",
            "                \"Title to insert in the Table of Contents\u2019 <div>. Defaults to Contents.\"",
            "            ),",
            "            \"baselevel\": _(\"Base level for headers. Defaults to 1.\"),",
            "            \"separator\": _(",
            "                \"Word separator. Character which replaces white space in id. Defaults to \u201c-\u201d.\"",
            "            ),",
            "            \"anchorlink\": _(",
            "                \"Set to True to cause all headers to link to themselves. Default is False.\"",
            "            ),",
            "            \"anchorlink_class\": _(",
            "                \"CSS class(es) used for the link. Defaults to toclink.\"",
            "            ),",
            "            \"permalink\": _(",
            "                \"Set to True or a string to generate permanent links at the end of each header. Useful with Sphinx style sheets.\"",
            "            ),",
            "            \"permalink_class\": _(",
            "                \"CSS class(es) used for the link. Defaults to headerlink.\"",
            "            ),",
            "            \"permalink_title\": _(",
            "                \"Title attribute of the permanent link. Defaults to Permanent link.\"",
            "            ),",
            "            \"toc_depth\": _(",
            "                \"Define the range of section levels to include in the Table of Contents. A single integer (b) defines the bottom section \"",
            "                \"level (<h1>..<hb>) only. A string consisting of two digits separated by a hyphen in between ('2-5'), define the top (t) \"",
            "                \"and the bottom (b) (<ht>..<hb>). Defaults to 6 (bottom).\"",
            "            ),",
            "        },",
            "    }",
            "",
            "    def wikilink(self):",
            "        return \"\"",
            "",
            "    wikilink.meta = {",
            "        \"short_description\": _(\"WikiLinks\"),",
            "        \"help_text\": _(",
            "            \"Insert a link to another wiki page with a short notation.\"",
            "        ),",
            "        \"example_code\": \"[[WikiLink]]\",",
            "        \"args\": {},",
            "    }",
            "",
            "",
            "def makeExtension(*args, **kwargs):",
            "    \"\"\"Return an instance of the extension.\"\"\"",
            "    return MacroExtension(*args, **kwargs)"
        ],
        "afterPatchFile": [
            "import re",
            "",
            "import markdown",
            "from django.template.loader import render_to_string",
            "from django.utils.translation import gettext as _",
            "from wiki.core.markdown import add_to_registry",
            "from wiki.plugins.macros import settings",
            "from wiki.plugins.macros.mdx import toc",
            "",
            "# See:",
            "# http://stackoverflow.com/questions/430759/regex-for-managing-escaped-characters-for-items-like-string-literals",
            "re_sq_short = r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\"",
            "",
            "",
            "MACRO_RE = (",
            "    r\"\"\"\\[(?P<macro>\\w+)(?P<kwargs>(\\s+\\w+\\:([^\\:\\]\\s]+|'[^']+'))+)*\\]\"\"\"",
            ")",
            "",
            "KWARG_RE = re.compile(",
            "    r\"\\s*(?P<arg>\\w+)(:(?P<value>([^\\']+|%s)))?\" % re_sq_short, re.IGNORECASE",
            ")",
            "",
            "",
            "class MacroExtension(markdown.Extension):",
            "",
            "    \"\"\"Macro plugin markdown extension for django-wiki.\"\"\"",
            "",
            "    def extendMarkdown(self, md):",
            "        add_to_registry(",
            "            md.inlinePatterns, \"dw-macros\", MacroPattern(MACRO_RE, md), \">link\"",
            "        )",
            "",
            "",
            "class MacroPattern(markdown.inlinepatterns.Pattern):",
            "",
            "    \"\"\"django-wiki macro preprocessor - parse text for various [some_macro] and",
            "    [some_macro (kw:arg)*] references.\"\"\"",
            "",
            "    def __init__(self, pattern, md=None):",
            "        \"\"\"Override init in order to add IGNORECASE flag\"\"\"",
            "        super().__init__(pattern, md=md)",
            "        self.compiled_re = re.compile(",
            "            r\"^(.*?)%s(.*)$\" % pattern,",
            "            flags=re.DOTALL | re.UNICODE | re.IGNORECASE,",
            "        )",
            "",
            "    def handleMatch(self, m):",
            "        macro = m.group(\"macro\").strip().lower()",
            "        if macro not in settings.METHODS or not hasattr(self, macro):",
            "            return m.group(2)",
            "",
            "        kwargs = m.group(\"kwargs\")",
            "        if not kwargs:",
            "            return getattr(self, macro)()",
            "",
            "        kwargs_dict = {}",
            "        for kwarg in KWARG_RE.finditer(kwargs):",
            "            arg = kwarg.group(\"arg\")",
            "            value = kwarg.group(\"value\")",
            "",
            "            if value is None:",
            "                value = True",
            "            if isinstance(value, str):",
            "                # If value is enclosed with ': Remove and",
            "                # remove escape sequences",
            "                if value.startswith(\"'\") and len(value) > 2:",
            "                    value = value[1:-1]",
            "                    value = value.replace(\"\\\\\\\\\", \"\u00a4KEEPME\u00a4\")",
            "                    value = value.replace(\"\\\\\", \"\")",
            "                    value = value.replace(\"\u00a4KEEPME\u00a4\", \"\\\\\")",
            "            kwargs_dict[str(arg)] = value",
            "        return getattr(self, macro)(**kwargs_dict)",
            "",
            "    def article_list(self, depth=\"2\"):",
            "        html = render_to_string(",
            "            \"wiki/plugins/macros/article_list.html\",",
            "            context={",
            "                \"article_children\": self.md.article.get_children(",
            "                    article__current_revision__deleted=False",
            "                ),",
            "                \"depth\": int(depth) + 1,",
            "            },",
            "        )",
            "        return self.md.htmlStash.store(html)",
            "",
            "    article_list.meta = {",
            "        \"short_description\": _(\"Article list\"),",
            "        \"help_text\": _(\"Insert a list of articles in this level.\"),",
            "        \"example_code\": \"[article_list depth:2]\",",
            "        \"args\": {\"depth\": _(\"Maximum depth to show levels for.\")},",
            "    }",
            "",
            "    def toc(self, **kwargs):",
            "        toc.WikiTreeProcessorClass.CACHED_KWARGS = kwargs",
            "        return \"[TOC]\"",
            "",
            "    toc.meta = {",
            "        \"short_description\": _(\"Table of contents\"),",
            "        \"help_text\": _(\"Insert a table of contents matching the headings.\"),",
            "        \"example_code\": \"[TOC] or [TOC toc_depth:1]\",",
            "        \"args\": {",
            "            \"title\": _(",
            "                \"Title to insert in the Table of Contents\u2019 <div>. Defaults to Contents.\"",
            "            ),",
            "            \"baselevel\": _(\"Base level for headers. Defaults to 1.\"),",
            "            \"separator\": _(",
            "                \"Word separator. Character which replaces white space in id. Defaults to \u201c-\u201d.\"",
            "            ),",
            "            \"anchorlink\": _(",
            "                \"Set to True to cause all headers to link to themselves. Default is False.\"",
            "            ),",
            "            \"anchorlink_class\": _(",
            "                \"CSS class(es) used for the link. Defaults to toclink.\"",
            "            ),",
            "            \"permalink\": _(",
            "                \"Set to True or a string to generate permanent links at the end of each header. Useful with Sphinx style sheets.\"",
            "            ),",
            "            \"permalink_class\": _(",
            "                \"CSS class(es) used for the link. Defaults to headerlink.\"",
            "            ),",
            "            \"permalink_title\": _(",
            "                \"Title attribute of the permanent link. Defaults to Permanent link.\"",
            "            ),",
            "            \"toc_depth\": _(",
            "                \"Define the range of section levels to include in the Table of Contents. A single integer (b) defines the bottom section \"",
            "                \"level (<h1>..<hb>) only. A string consisting of two digits separated by a hyphen in between ('2-5'), define the top (t) \"",
            "                \"and the bottom (b) (<ht>..<hb>). Defaults to 6 (bottom).\"",
            "            ),",
            "        },",
            "    }",
            "",
            "    def wikilink(self):",
            "        return \"\"",
            "",
            "    wikilink.meta = {",
            "        \"short_description\": _(\"WikiLinks\"),",
            "        \"help_text\": _(",
            "            \"Insert a link to another wiki page with a short notation.\"",
            "        ),",
            "        \"example_code\": \"[[WikiLink]]\",",
            "        \"args\": {},",
            "    }",
            "",
            "",
            "def makeExtension(*args, **kwargs):",
            "    \"\"\"Return an instance of the extension.\"\"\"",
            "    return MacroExtension(*args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [
                "MACRO_RE"
            ]
        },
        "addLocation": []
    },
    "src/wiki/templatetags/wiki_tags.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         before = \" \".join(before_words)"
            },
            "1": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         after = \" \".join(after_words)"
            },
            "2": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         html = (\"%s %s %s\" % (before, striptags(match), after)).strip()"
            },
            "3": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        kw_p = re.compile(r\"(\\S*%s\\S*)\" % keyword, re.IGNORECASE)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        kw_p = re.compile(r\"(\\S*%s\\S*)\" % re.escape(keyword), re.IGNORECASE)"
            },
            "5": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         html = kw_p.sub(r\"<strong>\\1</strong>\", html)"
            },
            "6": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         return mark_safe(html)"
            }
        },
        "frontPatchFile": [
            "import re",
            "from urllib.parse import quote as urlquote",
            "",
            "from django import template",
            "from django.apps import apps",
            "from django.conf import settings as django_settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.db.models import Model",
            "from django.forms import BaseForm",
            "from django.template.defaultfilters import striptags",
            "from django.utils.safestring import mark_safe",
            "from wiki import models",
            "from wiki.conf import settings",
            "from wiki.core.plugins import registry as plugin_registry",
            "",
            "register = template.Library()",
            "",
            "",
            "# Cache for looking up objects for articles... article_for_object is",
            "# called more than once per page in multiple template blocks.",
            "_cache = {}",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def article_for_object(context, obj):",
            "    if not isinstance(obj, Model):",
            "        raise TypeError(",
            "            \"A Wiki article can only be associated to a Django Model \"",
            "            \"instance, not %s\" % type(obj)",
            "        )",
            "",
            "    content_type = ContentType.objects.get_for_model(obj)",
            "",
            "    # TODO: This is disabled for now, as it should only fire once per request",
            "    # Maybe store cache in the request object?",
            "    if True or obj not in _cache:",
            "        try:",
            "            article = models.ArticleForObject.objects.get(",
            "                content_type=content_type, object_id=obj.pk",
            "            ).article",
            "        except models.ArticleForObject.DoesNotExist:",
            "            article = None",
            "        _cache[obj] = article",
            "    return _cache[obj]",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/render.html\", takes_context=True)",
            "def wiki_render(context, article, preview_content=None):",
            "    if preview_content:",
            "        content = article.render(preview_content=preview_content)",
            "    elif article.current_revision:",
            "        content = article.get_cached_content(user=context.get(\"user\"))",
            "    else:",
            "        content = None",
            "",
            "    context.update(",
            "        {",
            "            \"article\": article,",
            "            \"content\": content,",
            "            \"preview\": preview_content is not None,",
            "            \"plugins\": plugin_registry.get_plugins(),",
            "            \"STATIC_URL\": django_settings.STATIC_URL,",
            "            \"CACHE_TIMEOUT\": settings.CACHE_TIMEOUT,",
            "        }",
            "    )",
            "    return context",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/form.html\", takes_context=True)",
            "def wiki_form(context, form_obj):",
            "    if not isinstance(form_obj, BaseForm):",
            "        raise TypeError(",
            "            \"Error including form, it's not a form, it's a %s\" % type(form_obj)",
            "        )",
            "    context.update({\"form\": form_obj})",
            "    return context",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/messages.html\", takes_context=True)",
            "def wiki_messages(context):",
            "    messages = context.get(\"messages\", [])",
            "    for message in messages:",
            "        message.css_class = settings.MESSAGE_TAG_CSS_CLASS[message.level]",
            "    context.update({\"messages\": messages})",
            "    return context",
            "",
            "",
            "# XXX html strong tag is hardcoded",
            "@register.filter",
            "def get_content_snippet(content, keyword, max_words=30):",
            "    \"\"\"",
            "    Takes some text. Removes html tags and newlines from it.",
            "    If keyword in this text - returns a short text snippet",
            "    with keyword wrapped into strong tag and max_words // 2 before and after it.",
            "    If no keyword - return text[:max_words].",
            "    \"\"\"",
            "",
            "    def clean_text(content):",
            "        \"\"\"",
            "        Removes tags, newlines and spaces from content.",
            "        Return array of words.",
            "        \"\"\"",
            "",
            "        # remove html tags",
            "        content = striptags(content)",
            "        # remove whitespace",
            "        words = content.split()",
            "",
            "        return words",
            "",
            "    max_words = int(max_words)",
            "",
            "    match_position = content.lower().find(keyword.lower())",
            "",
            "    if match_position != -1:",
            "        try:",
            "            match_start = content.rindex(\" \", 0, match_position) + 1",
            "        except ValueError:",
            "            match_start = 0",
            "        try:",
            "            match_end = content.index(\" \", match_position + len(keyword))",
            "        except ValueError:",
            "            match_end = len(content)",
            "        all_before = clean_text(content[:match_start])",
            "        match = content[match_start:match_end]",
            "        all_after = clean_text(content[match_end:])",
            "        before_words = all_before[-max_words // 2 :]",
            "        after_words = all_after[: max_words - len(before_words)]",
            "        before = \" \".join(before_words)",
            "        after = \" \".join(after_words)",
            "        html = (\"%s %s %s\" % (before, striptags(match), after)).strip()",
            "        kw_p = re.compile(r\"(\\S*%s\\S*)\" % keyword, re.IGNORECASE)",
            "        html = kw_p.sub(r\"<strong>\\1</strong>\", html)",
            "",
            "        return mark_safe(html)",
            "",
            "    return \" \".join(clean_text(content)[:max_words])",
            "",
            "",
            "@register.filter",
            "def can_read(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can read article.",
            "    \"\"\"",
            "    return obj.can_read(user)",
            "",
            "",
            "@register.filter",
            "def can_write(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can write article.",
            "    \"\"\"",
            "    return obj.can_write(user)",
            "",
            "",
            "@register.filter",
            "def can_delete(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can delete article.",
            "    \"\"\"",
            "    return obj.can_delete(user)",
            "",
            "",
            "@register.filter",
            "def can_moderate(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can moderate article.",
            "    \"\"\"",
            "    return obj.can_moderate(user)",
            "",
            "",
            "@register.filter",
            "def is_locked(model):",
            "    \"\"\"",
            "    Check if article is locked.",
            "    \"\"\"",
            "    return model.current_revision and model.current_revision.locked",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def login_url(context):",
            "    request = context[\"request\"]",
            "    qs = request.META.get(\"QUERY_STRING\", \"\")",
            "    if qs:",
            "        qs = urlquote(\"?\" + qs)",
            "    else:",
            "        qs = \"\"",
            "    return settings.LOGIN_URL + \"?next=\" + request.path + qs",
            "",
            "",
            "@register.filter",
            "def plugin_enabled(plugin_name):",
            "    \"\"\"",
            "    Example: {% if 'wiki.plugins.notifications'|plugin_enabled %}",
            "",
            "    :param: plugin_name: String specifying the full name of the plugin, e.g.",
            "                         'wiki.plugins.attachments'",
            "    \"\"\"",
            "    return apps.is_installed(plugin_name)",
            "",
            "",
            "@register.filter",
            "def wiki_settings(name):",
            "    return getattr(settings, name, \"\")",
            "",
            "",
            "@register.filter",
            "def starts_with(value, arg):",
            "    return value.startswith(arg)"
        ],
        "afterPatchFile": [
            "import re",
            "from urllib.parse import quote as urlquote",
            "",
            "from django import template",
            "from django.apps import apps",
            "from django.conf import settings as django_settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.db.models import Model",
            "from django.forms import BaseForm",
            "from django.template.defaultfilters import striptags",
            "from django.utils.safestring import mark_safe",
            "from wiki import models",
            "from wiki.conf import settings",
            "from wiki.core.plugins import registry as plugin_registry",
            "",
            "register = template.Library()",
            "",
            "",
            "# Cache for looking up objects for articles... article_for_object is",
            "# called more than once per page in multiple template blocks.",
            "_cache = {}",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def article_for_object(context, obj):",
            "    if not isinstance(obj, Model):",
            "        raise TypeError(",
            "            \"A Wiki article can only be associated to a Django Model \"",
            "            \"instance, not %s\" % type(obj)",
            "        )",
            "",
            "    content_type = ContentType.objects.get_for_model(obj)",
            "",
            "    # TODO: This is disabled for now, as it should only fire once per request",
            "    # Maybe store cache in the request object?",
            "    if True or obj not in _cache:",
            "        try:",
            "            article = models.ArticleForObject.objects.get(",
            "                content_type=content_type, object_id=obj.pk",
            "            ).article",
            "        except models.ArticleForObject.DoesNotExist:",
            "            article = None",
            "        _cache[obj] = article",
            "    return _cache[obj]",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/render.html\", takes_context=True)",
            "def wiki_render(context, article, preview_content=None):",
            "    if preview_content:",
            "        content = article.render(preview_content=preview_content)",
            "    elif article.current_revision:",
            "        content = article.get_cached_content(user=context.get(\"user\"))",
            "    else:",
            "        content = None",
            "",
            "    context.update(",
            "        {",
            "            \"article\": article,",
            "            \"content\": content,",
            "            \"preview\": preview_content is not None,",
            "            \"plugins\": plugin_registry.get_plugins(),",
            "            \"STATIC_URL\": django_settings.STATIC_URL,",
            "            \"CACHE_TIMEOUT\": settings.CACHE_TIMEOUT,",
            "        }",
            "    )",
            "    return context",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/form.html\", takes_context=True)",
            "def wiki_form(context, form_obj):",
            "    if not isinstance(form_obj, BaseForm):",
            "        raise TypeError(",
            "            \"Error including form, it's not a form, it's a %s\" % type(form_obj)",
            "        )",
            "    context.update({\"form\": form_obj})",
            "    return context",
            "",
            "",
            "@register.inclusion_tag(\"wiki/includes/messages.html\", takes_context=True)",
            "def wiki_messages(context):",
            "    messages = context.get(\"messages\", [])",
            "    for message in messages:",
            "        message.css_class = settings.MESSAGE_TAG_CSS_CLASS[message.level]",
            "    context.update({\"messages\": messages})",
            "    return context",
            "",
            "",
            "# XXX html strong tag is hardcoded",
            "@register.filter",
            "def get_content_snippet(content, keyword, max_words=30):",
            "    \"\"\"",
            "    Takes some text. Removes html tags and newlines from it.",
            "    If keyword in this text - returns a short text snippet",
            "    with keyword wrapped into strong tag and max_words // 2 before and after it.",
            "    If no keyword - return text[:max_words].",
            "    \"\"\"",
            "",
            "    def clean_text(content):",
            "        \"\"\"",
            "        Removes tags, newlines and spaces from content.",
            "        Return array of words.",
            "        \"\"\"",
            "",
            "        # remove html tags",
            "        content = striptags(content)",
            "        # remove whitespace",
            "        words = content.split()",
            "",
            "        return words",
            "",
            "    max_words = int(max_words)",
            "",
            "    match_position = content.lower().find(keyword.lower())",
            "",
            "    if match_position != -1:",
            "        try:",
            "            match_start = content.rindex(\" \", 0, match_position) + 1",
            "        except ValueError:",
            "            match_start = 0",
            "        try:",
            "            match_end = content.index(\" \", match_position + len(keyword))",
            "        except ValueError:",
            "            match_end = len(content)",
            "        all_before = clean_text(content[:match_start])",
            "        match = content[match_start:match_end]",
            "        all_after = clean_text(content[match_end:])",
            "        before_words = all_before[-max_words // 2 :]",
            "        after_words = all_after[: max_words - len(before_words)]",
            "        before = \" \".join(before_words)",
            "        after = \" \".join(after_words)",
            "        html = (\"%s %s %s\" % (before, striptags(match), after)).strip()",
            "        kw_p = re.compile(r\"(\\S*%s\\S*)\" % re.escape(keyword), re.IGNORECASE)",
            "        html = kw_p.sub(r\"<strong>\\1</strong>\", html)",
            "",
            "        return mark_safe(html)",
            "",
            "    return \" \".join(clean_text(content)[:max_words])",
            "",
            "",
            "@register.filter",
            "def can_read(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can read article.",
            "    \"\"\"",
            "    return obj.can_read(user)",
            "",
            "",
            "@register.filter",
            "def can_write(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can write article.",
            "    \"\"\"",
            "    return obj.can_write(user)",
            "",
            "",
            "@register.filter",
            "def can_delete(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can delete article.",
            "    \"\"\"",
            "    return obj.can_delete(user)",
            "",
            "",
            "@register.filter",
            "def can_moderate(obj, user):",
            "    \"\"\"",
            "    Takes article or related to article model.",
            "    Check if user can moderate article.",
            "    \"\"\"",
            "    return obj.can_moderate(user)",
            "",
            "",
            "@register.filter",
            "def is_locked(model):",
            "    \"\"\"",
            "    Check if article is locked.",
            "    \"\"\"",
            "    return model.current_revision and model.current_revision.locked",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def login_url(context):",
            "    request = context[\"request\"]",
            "    qs = request.META.get(\"QUERY_STRING\", \"\")",
            "    if qs:",
            "        qs = urlquote(\"?\" + qs)",
            "    else:",
            "        qs = \"\"",
            "    return settings.LOGIN_URL + \"?next=\" + request.path + qs",
            "",
            "",
            "@register.filter",
            "def plugin_enabled(plugin_name):",
            "    \"\"\"",
            "    Example: {% if 'wiki.plugins.notifications'|plugin_enabled %}",
            "",
            "    :param: plugin_name: String specifying the full name of the plugin, e.g.",
            "                         'wiki.plugins.attachments'",
            "    \"\"\"",
            "    return apps.is_installed(plugin_name)",
            "",
            "",
            "@register.filter",
            "def wiki_settings(name):",
            "    return getattr(settings, name, \"\")",
            "",
            "",
            "@register.filter",
            "def starts_with(value, arg):",
            "    return value.startswith(arg)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "132": [
                "get_content_snippet"
            ]
        },
        "addLocation": []
    }
}