{
    "jinja2/nodes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": 604,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": 605,
                "PatchRowcode": "     def as_const(self, eval_ctx=None):"
            },
            "2": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": 606,
                "PatchRowcode": "         eval_ctx = get_eval_context(self, eval_ctx)"
            },
            "3": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if eval_ctx.volatile:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+        if eval_ctx.volatile or eval_ctx.environment.sandboxed:"
            },
            "5": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 608,
                "PatchRowcode": "             raise Impossible()"
            },
            "6": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 609,
                "PatchRowcode": "         obj = self.node.as_const(eval_ctx)"
            },
            "7": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 610,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    jinja2.nodes",
            "    ~~~~~~~~~~~~",
            "",
            "    This module implements additional nodes derived from the ast base node.",
            "",
            "    It also provides some node tree helper functions like `in_lineno` and",
            "    `get_nodes` used by the parser and translator in order to normalize",
            "    python and jinja nodes.",
            "",
            "    :copyright: (c) 2010 by the Jinja Team.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "import types",
            "import operator",
            "",
            "from collections import deque",
            "from jinja2.utils import Markup",
            "from jinja2._compat import izip, with_metaclass, text_type",
            "",
            "",
            "#: the types we support for context functions",
            "_context_function_types = (types.FunctionType, types.MethodType)",
            "",
            "",
            "_binop_to_func = {",
            "    '*':        operator.mul,",
            "    '/':        operator.truediv,",
            "    '//':       operator.floordiv,",
            "    '**':       operator.pow,",
            "    '%':        operator.mod,",
            "    '+':        operator.add,",
            "    '-':        operator.sub",
            "}",
            "",
            "_uaop_to_func = {",
            "    'not':      operator.not_,",
            "    '+':        operator.pos,",
            "    '-':        operator.neg",
            "}",
            "",
            "_cmpop_to_func = {",
            "    'eq':       operator.eq,",
            "    'ne':       operator.ne,",
            "    'gt':       operator.gt,",
            "    'gteq':     operator.ge,",
            "    'lt':       operator.lt,",
            "    'lteq':     operator.le,",
            "    'in':       lambda a, b: a in b,",
            "    'notin':    lambda a, b: a not in b",
            "}",
            "",
            "",
            "class Impossible(Exception):",
            "    \"\"\"Raised if the node could not perform a requested action.\"\"\"",
            "",
            "",
            "class NodeType(type):",
            "    \"\"\"A metaclass for nodes that handles the field and attribute",
            "    inheritance.  fields and attributes from the parent class are",
            "    automatically forwarded to the child.\"\"\"",
            "",
            "    def __new__(cls, name, bases, d):",
            "        for attr in 'fields', 'attributes':",
            "            storage = []",
            "            storage.extend(getattr(bases[0], attr, ()))",
            "            storage.extend(d.get(attr, ()))",
            "            assert len(bases) == 1, 'multiple inheritance not allowed'",
            "            assert len(storage) == len(set(storage)), 'layout conflict'",
            "            d[attr] = tuple(storage)",
            "        d.setdefault('abstract', False)",
            "        return type.__new__(cls, name, bases, d)",
            "",
            "",
            "class EvalContext(object):",
            "    \"\"\"Holds evaluation time information.  Custom attributes can be attached",
            "    to it in extensions.",
            "    \"\"\"",
            "",
            "    def __init__(self, environment, template_name=None):",
            "        self.environment = environment",
            "        if callable(environment.autoescape):",
            "            self.autoescape = environment.autoescape(template_name)",
            "        else:",
            "            self.autoescape = environment.autoescape",
            "        self.volatile = False",
            "",
            "    def save(self):",
            "        return self.__dict__.copy()",
            "",
            "    def revert(self, old):",
            "        self.__dict__.clear()",
            "        self.__dict__.update(old)",
            "",
            "",
            "def get_eval_context(node, ctx):",
            "    if ctx is None:",
            "        if node.environment is None:",
            "            raise RuntimeError('if no eval context is passed, the '",
            "                               'node must have an attached '",
            "                               'environment.')",
            "        return EvalContext(node.environment)",
            "    return ctx",
            "",
            "",
            "class Node(with_metaclass(NodeType, object)):",
            "    \"\"\"Baseclass for all Jinja2 nodes.  There are a number of nodes available",
            "    of different types.  There are four major types:",
            "",
            "    -   :class:`Stmt`: statements",
            "    -   :class:`Expr`: expressions",
            "    -   :class:`Helper`: helper nodes",
            "    -   :class:`Template`: the outermost wrapper node",
            "",
            "    All nodes have fields and attributes.  Fields may be other nodes, lists,",
            "    or arbitrary values.  Fields are passed to the constructor as regular",
            "    positional arguments, attributes as keyword arguments.  Each node has",
            "    two attributes: `lineno` (the line number of the node) and `environment`.",
            "    The `environment` attribute is set at the end of the parsing process for",
            "    all nodes automatically.",
            "    \"\"\"",
            "    fields = ()",
            "    attributes = ('lineno', 'environment')",
            "    abstract = True",
            "",
            "    def __init__(self, *fields, **attributes):",
            "        if self.abstract:",
            "            raise TypeError('abstract nodes are not instanciable')",
            "        if fields:",
            "            if len(fields) != len(self.fields):",
            "                if not self.fields:",
            "                    raise TypeError('%r takes 0 arguments' %",
            "                                    self.__class__.__name__)",
            "                raise TypeError('%r takes 0 or %d argument%s' % (",
            "                    self.__class__.__name__,",
            "                    len(self.fields),",
            "                    len(self.fields) != 1 and 's' or ''",
            "                ))",
            "            for name, arg in izip(self.fields, fields):",
            "                setattr(self, name, arg)",
            "        for attr in self.attributes:",
            "            setattr(self, attr, attributes.pop(attr, None))",
            "        if attributes:",
            "            raise TypeError('unknown attribute %r' %",
            "                            next(iter(attributes)))",
            "",
            "    def iter_fields(self, exclude=None, only=None):",
            "        \"\"\"This method iterates over all fields that are defined and yields",
            "        ``(key, value)`` tuples.  Per default all fields are returned, but",
            "        it's possible to limit that to some fields by providing the `only`",
            "        parameter or to exclude some using the `exclude` parameter.  Both",
            "        should be sets or tuples of field names.",
            "        \"\"\"",
            "        for name in self.fields:",
            "            if (exclude is only is None) or \\",
            "               (exclude is not None and name not in exclude) or \\",
            "               (only is not None and name in only):",
            "                try:",
            "                    yield name, getattr(self, name)",
            "                except AttributeError:",
            "                    pass",
            "",
            "    def iter_child_nodes(self, exclude=None, only=None):",
            "        \"\"\"Iterates over all direct child nodes of the node.  This iterates",
            "        over all fields and yields the values of they are nodes.  If the value",
            "        of a field is a list all the nodes in that list are returned.",
            "        \"\"\"",
            "        for field, item in self.iter_fields(exclude, only):",
            "            if isinstance(item, list):",
            "                for n in item:",
            "                    if isinstance(n, Node):",
            "                        yield n",
            "            elif isinstance(item, Node):",
            "                yield item",
            "",
            "    def find(self, node_type):",
            "        \"\"\"Find the first node of a given type.  If no such node exists the",
            "        return value is `None`.",
            "        \"\"\"",
            "        for result in self.find_all(node_type):",
            "            return result",
            "",
            "    def find_all(self, node_type):",
            "        \"\"\"Find all the nodes of a given type.  If the type is a tuple,",
            "        the check is performed for any of the tuple items.",
            "        \"\"\"",
            "        for child in self.iter_child_nodes():",
            "            if isinstance(child, node_type):",
            "                yield child",
            "            for result in child.find_all(node_type):",
            "                yield result",
            "",
            "    def set_ctx(self, ctx):",
            "        \"\"\"Reset the context of a node and all child nodes.  Per default the",
            "        parser will all generate nodes that have a 'load' context as it's the",
            "        most common one.  This method is used in the parser to set assignment",
            "        targets and other nodes to a store context.",
            "        \"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            if 'ctx' in node.fields:",
            "                node.ctx = ctx",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def set_lineno(self, lineno, override=False):",
            "        \"\"\"Set the line numbers of the node and children.\"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            if 'lineno' in node.attributes:",
            "                if node.lineno is None or override:",
            "                    node.lineno = lineno",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def set_environment(self, environment):",
            "        \"\"\"Set the environment for all nodes.\"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            node.environment = environment",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def __eq__(self, other):",
            "        return type(self) is type(other) and \\",
            "               tuple(self.iter_fields()) == tuple(other.iter_fields())",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    # Restore Python 2 hashing behavior on Python 3",
            "    __hash__ = object.__hash__",
            "",
            "    def __repr__(self):",
            "        return '%s(%s)' % (",
            "            self.__class__.__name__,",
            "            ', '.join('%s=%r' % (arg, getattr(self, arg, None)) for",
            "                      arg in self.fields)",
            "        )",
            "",
            "",
            "class Stmt(Node):",
            "    \"\"\"Base node for all statements.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Helper(Node):",
            "    \"\"\"Nodes that exist in a specific context only.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Template(Node):",
            "    \"\"\"Node that represents a template.  This must be the outermost node that",
            "    is passed to the compiler.",
            "    \"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "class Output(Stmt):",
            "    \"\"\"A node that holds multiple expressions which are then printed out.",
            "    This is used both for the `print` statement and the regular template data.",
            "    \"\"\"",
            "    fields = ('nodes',)",
            "",
            "",
            "class Extends(Stmt):",
            "    \"\"\"Represents an extends statement.\"\"\"",
            "    fields = ('template',)",
            "",
            "",
            "class For(Stmt):",
            "    \"\"\"The for loop.  `target` is the target for the iteration (usually a",
            "    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list",
            "    of nodes that are used as loop-body, and `else_` a list of nodes for the",
            "    `else` block.  If no else node exists it has to be an empty list.",
            "",
            "    For filtered nodes an expression can be stored as `test`, otherwise `None`.",
            "    \"\"\"",
            "    fields = ('target', 'iter', 'body', 'else_', 'test', 'recursive')",
            "",
            "",
            "class If(Stmt):",
            "    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"",
            "    fields = ('test', 'body', 'else_')",
            "",
            "",
            "class Macro(Stmt):",
            "    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of",
            "    arguments and `defaults` a list of defaults if there are any.  `body` is",
            "    a list of nodes for the macro body.",
            "    \"\"\"",
            "    fields = ('name', 'args', 'defaults', 'body')",
            "",
            "",
            "class CallBlock(Stmt):",
            "    \"\"\"Like a macro without a name but a call instead.  `call` is called with",
            "    the unnamed macro as `caller` argument this node holds.",
            "    \"\"\"",
            "    fields = ('call', 'args', 'defaults', 'body')",
            "",
            "",
            "class FilterBlock(Stmt):",
            "    \"\"\"Node for filter sections.\"\"\"",
            "    fields = ('body', 'filter')",
            "",
            "",
            "class Block(Stmt):",
            "    \"\"\"A node that represents a block.\"\"\"",
            "    fields = ('name', 'body', 'scoped')",
            "",
            "",
            "class Include(Stmt):",
            "    \"\"\"A node that represents the include tag.\"\"\"",
            "    fields = ('template', 'with_context', 'ignore_missing')",
            "",
            "",
            "class Import(Stmt):",
            "    \"\"\"A node that represents the import tag.\"\"\"",
            "    fields = ('template', 'target', 'with_context')",
            "",
            "",
            "class FromImport(Stmt):",
            "    \"\"\"A node that represents the from import tag.  It's important to not",
            "    pass unsafe names to the name attribute.  The compiler translates the",
            "    attribute lookups directly into getattr calls and does *not* use the",
            "    subscript callback of the interface.  As exported variables may not",
            "    start with double underscores (which the parser asserts) this is not a",
            "    problem for regular Jinja code, but if this node is used in an extension",
            "    extra care must be taken.",
            "",
            "    The list of names may contain tuples if aliases are wanted.",
            "    \"\"\"",
            "    fields = ('template', 'names', 'with_context')",
            "",
            "",
            "class ExprStmt(Stmt):",
            "    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"",
            "    fields = ('node',)",
            "",
            "",
            "class Assign(Stmt):",
            "    \"\"\"Assigns an expression to a target.\"\"\"",
            "    fields = ('target', 'node')",
            "",
            "",
            "class AssignBlock(Stmt):",
            "    \"\"\"Assigns a block to a target.\"\"\"",
            "    fields = ('target', 'body')",
            "",
            "",
            "class Expr(Node):",
            "    \"\"\"Baseclass for all expressions.\"\"\"",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        \"\"\"Return the value of the expression as constant or raise",
            "        :exc:`Impossible` if this was not possible.",
            "",
            "        An :class:`EvalContext` can be provided, if none is given",
            "        a default context is created which requires the nodes to have",
            "        an attached environment.",
            "",
            "        .. versionchanged:: 2.4",
            "           the `eval_ctx` parameter was added.",
            "        \"\"\"",
            "        raise Impossible()",
            "",
            "    def can_assign(self):",
            "        \"\"\"Check if it's possible to assign something to this node.\"\"\"",
            "        return False",
            "",
            "",
            "class BinExpr(Expr):",
            "    \"\"\"Baseclass for all binary expressions.\"\"\"",
            "    fields = ('left', 'right')",
            "    operator = None",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        # intercepted operators cannot be folded at compile time",
            "        if self.environment.sandboxed and \\",
            "           self.operator in self.environment.intercepted_binops:",
            "            raise Impossible()",
            "        f = _binop_to_func[self.operator]",
            "        try:",
            "            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class UnaryExpr(Expr):",
            "    \"\"\"Baseclass for all unary expressions.\"\"\"",
            "    fields = ('node',)",
            "    operator = None",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        # intercepted operators cannot be folded at compile time",
            "        if self.environment.sandboxed and \\",
            "           self.operator in self.environment.intercepted_unops:",
            "            raise Impossible()",
            "        f = _uaop_to_func[self.operator]",
            "        try:",
            "            return f(self.node.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Name(Expr):",
            "    \"\"\"Looks up a name or stores a value in a name.",
            "    The `ctx` of the node can be one of the following values:",
            "",
            "    -   `store`: store a value in the name",
            "    -   `load`: load that name",
            "    -   `param`: like `store` but if the name was defined as function parameter.",
            "    \"\"\"",
            "    fields = ('name', 'ctx')",
            "",
            "    def can_assign(self):",
            "        return self.name not in ('true', 'false', 'none',",
            "                                 'True', 'False', 'None')",
            "",
            "",
            "class Literal(Expr):",
            "    \"\"\"Baseclass for literals.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Const(Literal):",
            "    \"\"\"All constant values.  The parser will return this node for simple",
            "    constants such as ``42`` or ``\"foo\"`` but it can be used to store more",
            "    complex values such as lists too.  Only constants with a safe",
            "    representation (objects where ``eval(repr(x)) == x`` is true).",
            "    \"\"\"",
            "    fields = ('value',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        return self.value",
            "",
            "    @classmethod",
            "    def from_untrusted(cls, value, lineno=None, environment=None):",
            "        \"\"\"Return a const object if the value is representable as",
            "        constant value in the generated code, otherwise it will raise",
            "        an `Impossible` exception.",
            "        \"\"\"",
            "        from .compiler import has_safe_repr",
            "        if not has_safe_repr(value):",
            "            raise Impossible()",
            "        return cls(value, lineno=lineno, environment=environment)",
            "",
            "",
            "class TemplateData(Literal):",
            "    \"\"\"A constant template string.\"\"\"",
            "    fields = ('data',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile:",
            "            raise Impossible()",
            "        if eval_ctx.autoescape:",
            "            return Markup(self.data)",
            "        return self.data",
            "",
            "",
            "class Tuple(Literal):",
            "    \"\"\"For loop unpacking and some other things like multiple arguments",
            "    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple",
            "    is used for loading the names or storing.",
            "    \"\"\"",
            "    fields = ('items', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return tuple(x.as_const(eval_ctx) for x in self.items)",
            "",
            "    def can_assign(self):",
            "        for item in self.items:",
            "            if not item.can_assign():",
            "                return False",
            "        return True",
            "",
            "",
            "class List(Literal):",
            "    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"",
            "    fields = ('items',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return [x.as_const(eval_ctx) for x in self.items]",
            "",
            "",
            "class Dict(Literal):",
            "    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of",
            "    :class:`Pair` nodes.",
            "    \"\"\"",
            "    fields = ('items',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return dict(x.as_const(eval_ctx) for x in self.items)",
            "",
            "",
            "class Pair(Helper):",
            "    \"\"\"A key, value pair for dicts.\"\"\"",
            "    fields = ('key', 'value')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)",
            "",
            "",
            "class Keyword(Helper):",
            "    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"",
            "    fields = ('key', 'value')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.key, self.value.as_const(eval_ctx)",
            "",
            "",
            "class CondExpr(Expr):",
            "    \"\"\"A conditional expression (inline if expression).  (``{{",
            "    foo if bar else baz }}``)",
            "    \"\"\"",
            "    fields = ('test', 'expr1', 'expr2')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if self.test.as_const(eval_ctx):",
            "            return self.expr1.as_const(eval_ctx)",
            "",
            "        # if we evaluate to an undefined object, we better do that at runtime",
            "        if self.expr2 is None:",
            "            raise Impossible()",
            "",
            "        return self.expr2.as_const(eval_ctx)",
            "",
            "",
            "class Filter(Expr):",
            "    \"\"\"This node applies a filter on an expression.  `name` is the name of",
            "    the filter, the rest of the fields are the same as for :class:`Call`.",
            "",
            "    If the `node` of a filter is `None` the contents of the last buffer are",
            "    filtered.  Buffers are created by macros and filter blocks.",
            "    \"\"\"",
            "    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile or self.node is None:",
            "            raise Impossible()",
            "        # we have to be careful here because we call filter_ below.",
            "        # if this variable would be called filter, 2to3 would wrap the",
            "        # call in a list beause it is assuming we are talking about the",
            "        # builtin filter function here which no longer returns a list in",
            "        # python 3.  because of that, do not rename filter_ to filter!",
            "        filter_ = self.environment.filters.get(self.name)",
            "        if filter_ is None or getattr(filter_, 'contextfilter', False):",
            "            raise Impossible()",
            "        obj = self.node.as_const(eval_ctx)",
            "        args = [x.as_const(eval_ctx) for x in self.args]",
            "        if getattr(filter_, 'evalcontextfilter', False):",
            "            args.insert(0, eval_ctx)",
            "        elif getattr(filter_, 'environmentfilter', False):",
            "            args.insert(0, self.environment)",
            "        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)",
            "        if self.dyn_args is not None:",
            "            try:",
            "                args.extend(self.dyn_args.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        if self.dyn_kwargs is not None:",
            "            try:",
            "                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        try:",
            "            return filter_(obj, *args, **kwargs)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Test(Expr):",
            "    \"\"\"Applies a test on an expression.  `name` is the name of the test, the",
            "    rest of the fields are the same as for :class:`Call`.",
            "    \"\"\"",
            "    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "",
            "class Call(Expr):",
            "    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list",
            "    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`",
            "    and `dyn_kwargs` has to be either `None` or a node that is used as",
            "    node for dynamic positional (``*args``) or keyword (``**kwargs``)",
            "    arguments.",
            "    \"\"\"",
            "    fields = ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile:",
            "            raise Impossible()",
            "        obj = self.node.as_const(eval_ctx)",
            "",
            "        # don't evaluate context functions",
            "        args = [x.as_const(eval_ctx) for x in self.args]",
            "        if isinstance(obj, _context_function_types):",
            "            if getattr(obj, 'contextfunction', False):",
            "                raise Impossible()",
            "            elif getattr(obj, 'evalcontextfunction', False):",
            "                args.insert(0, eval_ctx)",
            "            elif getattr(obj, 'environmentfunction', False):",
            "                args.insert(0, self.environment)",
            "",
            "        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)",
            "        if self.dyn_args is not None:",
            "            try:",
            "                args.extend(self.dyn_args.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        if self.dyn_kwargs is not None:",
            "            try:",
            "                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        try:",
            "            return obj(*args, **kwargs)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Getitem(Expr):",
            "    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"",
            "    fields = ('node', 'arg', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if self.ctx != 'load':",
            "            raise Impossible()",
            "        try:",
            "            return self.environment.getitem(self.node.as_const(eval_ctx),",
            "                                            self.arg.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "    def can_assign(self):",
            "        return False",
            "",
            "",
            "class Getattr(Expr):",
            "    \"\"\"Get an attribute or item from an expression that is a ascii-only",
            "    bytestring and prefer the attribute.",
            "    \"\"\"",
            "    fields = ('node', 'attr', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        if self.ctx != 'load':",
            "            raise Impossible()",
            "        try:",
            "            eval_ctx = get_eval_context(self, eval_ctx)",
            "            return self.environment.getattr(self.node.as_const(eval_ctx),",
            "                                            self.attr)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "    def can_assign(self):",
            "        return False",
            "",
            "",
            "class Slice(Expr):",
            "    \"\"\"Represents a slice object.  This must only be used as argument for",
            "    :class:`Subscript`.",
            "    \"\"\"",
            "    fields = ('start', 'stop', 'step')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        def const(obj):",
            "            if obj is None:",
            "                return None",
            "            return obj.as_const(eval_ctx)",
            "        return slice(const(self.start), const(self.stop), const(self.step))",
            "",
            "",
            "class Concat(Expr):",
            "    \"\"\"Concatenates the list of expressions provided after converting them to",
            "    unicode.",
            "    \"\"\"",
            "    fields = ('nodes',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return ''.join(text_type(x.as_const(eval_ctx)) for x in self.nodes)",
            "",
            "",
            "class Compare(Expr):",
            "    \"\"\"Compares an expression with some other expressions.  `ops` must be a",
            "    list of :class:`Operand`\\s.",
            "    \"\"\"",
            "    fields = ('expr', 'ops')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        result = value = self.expr.as_const(eval_ctx)",
            "        try:",
            "            for op in self.ops:",
            "                new_value = op.expr.as_const(eval_ctx)",
            "                result = _cmpop_to_func[op.op](value, new_value)",
            "                value = new_value",
            "        except Exception:",
            "            raise Impossible()",
            "        return result",
            "",
            "",
            "class Operand(Helper):",
            "    \"\"\"Holds an operator and an expression.\"\"\"",
            "    fields = ('op', 'expr')",
            "",
            "if __debug__:",
            "    Operand.__doc__ += '\\nThe following operators are available: ' + \\",
            "        ', '.join(sorted('``%s``' % x for x in set(_binop_to_func) |",
            "                  set(_uaop_to_func) | set(_cmpop_to_func)))",
            "",
            "",
            "class Mul(BinExpr):",
            "    \"\"\"Multiplies the left with the right node.\"\"\"",
            "    operator = '*'",
            "",
            "",
            "class Div(BinExpr):",
            "    \"\"\"Divides the left by the right node.\"\"\"",
            "    operator = '/'",
            "",
            "",
            "class FloorDiv(BinExpr):",
            "    \"\"\"Divides the left by the right node and truncates conver the",
            "    result into an integer by truncating.",
            "    \"\"\"",
            "    operator = '//'",
            "",
            "",
            "class Add(BinExpr):",
            "    \"\"\"Add the left to the right node.\"\"\"",
            "    operator = '+'",
            "",
            "",
            "class Sub(BinExpr):",
            "    \"\"\"Subtract the right from the left node.\"\"\"",
            "    operator = '-'",
            "",
            "",
            "class Mod(BinExpr):",
            "    \"\"\"Left modulo right.\"\"\"",
            "    operator = '%'",
            "",
            "",
            "class Pow(BinExpr):",
            "    \"\"\"Left to the power of right.\"\"\"",
            "    operator = '**'",
            "",
            "",
            "class And(BinExpr):",
            "    \"\"\"Short circuited AND.\"\"\"",
            "    operator = 'and'",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)",
            "",
            "",
            "class Or(BinExpr):",
            "    \"\"\"Short circuited OR.\"\"\"",
            "    operator = 'or'",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)",
            "",
            "",
            "class Not(UnaryExpr):",
            "    \"\"\"Negate the expression.\"\"\"",
            "    operator = 'not'",
            "",
            "",
            "class Neg(UnaryExpr):",
            "    \"\"\"Make the expression negative.\"\"\"",
            "    operator = '-'",
            "",
            "",
            "class Pos(UnaryExpr):",
            "    \"\"\"Make the expression positive (noop for most expressions)\"\"\"",
            "    operator = '+'",
            "",
            "",
            "# Helpers for extensions",
            "",
            "",
            "class EnvironmentAttribute(Expr):",
            "    \"\"\"Loads an attribute from the environment object.  This is useful for",
            "    extensions that want to call a callback stored on the environment.",
            "    \"\"\"",
            "    fields = ('name',)",
            "",
            "",
            "class ExtensionAttribute(Expr):",
            "    \"\"\"Returns the attribute of an extension bound to the environment.",
            "    The identifier is the identifier of the :class:`Extension`.",
            "",
            "    This node is usually constructed by calling the",
            "    :meth:`~jinja2.ext.Extension.attr` method on an extension.",
            "    \"\"\"",
            "    fields = ('identifier', 'name')",
            "",
            "",
            "class ImportedName(Expr):",
            "    \"\"\"If created with an import name the import name is returned on node",
            "    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`",
            "    function from the cgi module on evaluation.  Imports are optimized by the",
            "    compiler so there is no need to assign them to local variables.",
            "    \"\"\"",
            "    fields = ('importname',)",
            "",
            "",
            "class InternalName(Expr):",
            "    \"\"\"An internal name in the compiler.  You cannot create these nodes",
            "    yourself but the parser provides a",
            "    :meth:`~jinja2.parser.Parser.free_identifier` method that creates",
            "    a new identifier for you.  This identifier is not available from the",
            "    template and is not threated specially by the compiler.",
            "    \"\"\"",
            "    fields = ('name',)",
            "",
            "    def __init__(self):",
            "        raise TypeError('Can\\'t create internal names.  Use the '",
            "                        '`free_identifier` method on a parser.')",
            "",
            "",
            "class MarkSafe(Expr):",
            "    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"",
            "    fields = ('expr',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return Markup(self.expr.as_const(eval_ctx))",
            "",
            "",
            "class MarkSafeIfAutoescape(Expr):",
            "    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but",
            "    only if autoescaping is active.",
            "",
            "    .. versionadded:: 2.5",
            "    \"\"\"",
            "    fields = ('expr',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile:",
            "            raise Impossible()",
            "        expr = self.expr.as_const(eval_ctx)",
            "        if eval_ctx.autoescape:",
            "            return Markup(expr)",
            "        return expr",
            "",
            "",
            "class ContextReference(Expr):",
            "    \"\"\"Returns the current template context.  It can be used like a",
            "    :class:`Name` node, with a ``'load'`` ctx and will return the",
            "    current :class:`~jinja2.runtime.Context` object.",
            "",
            "    Here an example that assigns the current template name to a",
            "    variable named `foo`::",
            "",
            "        Assign(Name('foo', ctx='store'),",
            "               Getattr(ContextReference(), 'name'))",
            "    \"\"\"",
            "",
            "",
            "class Continue(Stmt):",
            "    \"\"\"Continue a loop.\"\"\"",
            "",
            "",
            "class Break(Stmt):",
            "    \"\"\"Break a loop.\"\"\"",
            "",
            "",
            "class Scope(Stmt):",
            "    \"\"\"An artificial scope.\"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "class EvalContextModifier(Stmt):",
            "    \"\"\"Modifies the eval context.  For each option that should be modified,",
            "    a :class:`Keyword` has to be added to the :attr:`options` list.",
            "",
            "    Example to change the `autoescape` setting::",
            "",
            "        EvalContextModifier(options=[Keyword('autoescape', Const(True))])",
            "    \"\"\"",
            "    fields = ('options',)",
            "",
            "",
            "class ScopedEvalContextModifier(EvalContextModifier):",
            "    \"\"\"Modifies the eval context and reverts it later.  Works exactly like",
            "    :class:`EvalContextModifier` but will only modify the",
            "    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.",
            "    \"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "# make sure nobody creates custom nodes",
            "def _failing_new(*args, **kwargs):",
            "    raise TypeError('can\\'t create custom node types')",
            "NodeType.__new__ = staticmethod(_failing_new); del _failing_new"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    jinja2.nodes",
            "    ~~~~~~~~~~~~",
            "",
            "    This module implements additional nodes derived from the ast base node.",
            "",
            "    It also provides some node tree helper functions like `in_lineno` and",
            "    `get_nodes` used by the parser and translator in order to normalize",
            "    python and jinja nodes.",
            "",
            "    :copyright: (c) 2010 by the Jinja Team.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "import types",
            "import operator",
            "",
            "from collections import deque",
            "from jinja2.utils import Markup",
            "from jinja2._compat import izip, with_metaclass, text_type",
            "",
            "",
            "#: the types we support for context functions",
            "_context_function_types = (types.FunctionType, types.MethodType)",
            "",
            "",
            "_binop_to_func = {",
            "    '*':        operator.mul,",
            "    '/':        operator.truediv,",
            "    '//':       operator.floordiv,",
            "    '**':       operator.pow,",
            "    '%':        operator.mod,",
            "    '+':        operator.add,",
            "    '-':        operator.sub",
            "}",
            "",
            "_uaop_to_func = {",
            "    'not':      operator.not_,",
            "    '+':        operator.pos,",
            "    '-':        operator.neg",
            "}",
            "",
            "_cmpop_to_func = {",
            "    'eq':       operator.eq,",
            "    'ne':       operator.ne,",
            "    'gt':       operator.gt,",
            "    'gteq':     operator.ge,",
            "    'lt':       operator.lt,",
            "    'lteq':     operator.le,",
            "    'in':       lambda a, b: a in b,",
            "    'notin':    lambda a, b: a not in b",
            "}",
            "",
            "",
            "class Impossible(Exception):",
            "    \"\"\"Raised if the node could not perform a requested action.\"\"\"",
            "",
            "",
            "class NodeType(type):",
            "    \"\"\"A metaclass for nodes that handles the field and attribute",
            "    inheritance.  fields and attributes from the parent class are",
            "    automatically forwarded to the child.\"\"\"",
            "",
            "    def __new__(cls, name, bases, d):",
            "        for attr in 'fields', 'attributes':",
            "            storage = []",
            "            storage.extend(getattr(bases[0], attr, ()))",
            "            storage.extend(d.get(attr, ()))",
            "            assert len(bases) == 1, 'multiple inheritance not allowed'",
            "            assert len(storage) == len(set(storage)), 'layout conflict'",
            "            d[attr] = tuple(storage)",
            "        d.setdefault('abstract', False)",
            "        return type.__new__(cls, name, bases, d)",
            "",
            "",
            "class EvalContext(object):",
            "    \"\"\"Holds evaluation time information.  Custom attributes can be attached",
            "    to it in extensions.",
            "    \"\"\"",
            "",
            "    def __init__(self, environment, template_name=None):",
            "        self.environment = environment",
            "        if callable(environment.autoescape):",
            "            self.autoescape = environment.autoescape(template_name)",
            "        else:",
            "            self.autoescape = environment.autoescape",
            "        self.volatile = False",
            "",
            "    def save(self):",
            "        return self.__dict__.copy()",
            "",
            "    def revert(self, old):",
            "        self.__dict__.clear()",
            "        self.__dict__.update(old)",
            "",
            "",
            "def get_eval_context(node, ctx):",
            "    if ctx is None:",
            "        if node.environment is None:",
            "            raise RuntimeError('if no eval context is passed, the '",
            "                               'node must have an attached '",
            "                               'environment.')",
            "        return EvalContext(node.environment)",
            "    return ctx",
            "",
            "",
            "class Node(with_metaclass(NodeType, object)):",
            "    \"\"\"Baseclass for all Jinja2 nodes.  There are a number of nodes available",
            "    of different types.  There are four major types:",
            "",
            "    -   :class:`Stmt`: statements",
            "    -   :class:`Expr`: expressions",
            "    -   :class:`Helper`: helper nodes",
            "    -   :class:`Template`: the outermost wrapper node",
            "",
            "    All nodes have fields and attributes.  Fields may be other nodes, lists,",
            "    or arbitrary values.  Fields are passed to the constructor as regular",
            "    positional arguments, attributes as keyword arguments.  Each node has",
            "    two attributes: `lineno` (the line number of the node) and `environment`.",
            "    The `environment` attribute is set at the end of the parsing process for",
            "    all nodes automatically.",
            "    \"\"\"",
            "    fields = ()",
            "    attributes = ('lineno', 'environment')",
            "    abstract = True",
            "",
            "    def __init__(self, *fields, **attributes):",
            "        if self.abstract:",
            "            raise TypeError('abstract nodes are not instanciable')",
            "        if fields:",
            "            if len(fields) != len(self.fields):",
            "                if not self.fields:",
            "                    raise TypeError('%r takes 0 arguments' %",
            "                                    self.__class__.__name__)",
            "                raise TypeError('%r takes 0 or %d argument%s' % (",
            "                    self.__class__.__name__,",
            "                    len(self.fields),",
            "                    len(self.fields) != 1 and 's' or ''",
            "                ))",
            "            for name, arg in izip(self.fields, fields):",
            "                setattr(self, name, arg)",
            "        for attr in self.attributes:",
            "            setattr(self, attr, attributes.pop(attr, None))",
            "        if attributes:",
            "            raise TypeError('unknown attribute %r' %",
            "                            next(iter(attributes)))",
            "",
            "    def iter_fields(self, exclude=None, only=None):",
            "        \"\"\"This method iterates over all fields that are defined and yields",
            "        ``(key, value)`` tuples.  Per default all fields are returned, but",
            "        it's possible to limit that to some fields by providing the `only`",
            "        parameter or to exclude some using the `exclude` parameter.  Both",
            "        should be sets or tuples of field names.",
            "        \"\"\"",
            "        for name in self.fields:",
            "            if (exclude is only is None) or \\",
            "               (exclude is not None and name not in exclude) or \\",
            "               (only is not None and name in only):",
            "                try:",
            "                    yield name, getattr(self, name)",
            "                except AttributeError:",
            "                    pass",
            "",
            "    def iter_child_nodes(self, exclude=None, only=None):",
            "        \"\"\"Iterates over all direct child nodes of the node.  This iterates",
            "        over all fields and yields the values of they are nodes.  If the value",
            "        of a field is a list all the nodes in that list are returned.",
            "        \"\"\"",
            "        for field, item in self.iter_fields(exclude, only):",
            "            if isinstance(item, list):",
            "                for n in item:",
            "                    if isinstance(n, Node):",
            "                        yield n",
            "            elif isinstance(item, Node):",
            "                yield item",
            "",
            "    def find(self, node_type):",
            "        \"\"\"Find the first node of a given type.  If no such node exists the",
            "        return value is `None`.",
            "        \"\"\"",
            "        for result in self.find_all(node_type):",
            "            return result",
            "",
            "    def find_all(self, node_type):",
            "        \"\"\"Find all the nodes of a given type.  If the type is a tuple,",
            "        the check is performed for any of the tuple items.",
            "        \"\"\"",
            "        for child in self.iter_child_nodes():",
            "            if isinstance(child, node_type):",
            "                yield child",
            "            for result in child.find_all(node_type):",
            "                yield result",
            "",
            "    def set_ctx(self, ctx):",
            "        \"\"\"Reset the context of a node and all child nodes.  Per default the",
            "        parser will all generate nodes that have a 'load' context as it's the",
            "        most common one.  This method is used in the parser to set assignment",
            "        targets and other nodes to a store context.",
            "        \"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            if 'ctx' in node.fields:",
            "                node.ctx = ctx",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def set_lineno(self, lineno, override=False):",
            "        \"\"\"Set the line numbers of the node and children.\"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            if 'lineno' in node.attributes:",
            "                if node.lineno is None or override:",
            "                    node.lineno = lineno",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def set_environment(self, environment):",
            "        \"\"\"Set the environment for all nodes.\"\"\"",
            "        todo = deque([self])",
            "        while todo:",
            "            node = todo.popleft()",
            "            node.environment = environment",
            "            todo.extend(node.iter_child_nodes())",
            "        return self",
            "",
            "    def __eq__(self, other):",
            "        return type(self) is type(other) and \\",
            "               tuple(self.iter_fields()) == tuple(other.iter_fields())",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    # Restore Python 2 hashing behavior on Python 3",
            "    __hash__ = object.__hash__",
            "",
            "    def __repr__(self):",
            "        return '%s(%s)' % (",
            "            self.__class__.__name__,",
            "            ', '.join('%s=%r' % (arg, getattr(self, arg, None)) for",
            "                      arg in self.fields)",
            "        )",
            "",
            "",
            "class Stmt(Node):",
            "    \"\"\"Base node for all statements.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Helper(Node):",
            "    \"\"\"Nodes that exist in a specific context only.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Template(Node):",
            "    \"\"\"Node that represents a template.  This must be the outermost node that",
            "    is passed to the compiler.",
            "    \"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "class Output(Stmt):",
            "    \"\"\"A node that holds multiple expressions which are then printed out.",
            "    This is used both for the `print` statement and the regular template data.",
            "    \"\"\"",
            "    fields = ('nodes',)",
            "",
            "",
            "class Extends(Stmt):",
            "    \"\"\"Represents an extends statement.\"\"\"",
            "    fields = ('template',)",
            "",
            "",
            "class For(Stmt):",
            "    \"\"\"The for loop.  `target` is the target for the iteration (usually a",
            "    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list",
            "    of nodes that are used as loop-body, and `else_` a list of nodes for the",
            "    `else` block.  If no else node exists it has to be an empty list.",
            "",
            "    For filtered nodes an expression can be stored as `test`, otherwise `None`.",
            "    \"\"\"",
            "    fields = ('target', 'iter', 'body', 'else_', 'test', 'recursive')",
            "",
            "",
            "class If(Stmt):",
            "    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"",
            "    fields = ('test', 'body', 'else_')",
            "",
            "",
            "class Macro(Stmt):",
            "    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of",
            "    arguments and `defaults` a list of defaults if there are any.  `body` is",
            "    a list of nodes for the macro body.",
            "    \"\"\"",
            "    fields = ('name', 'args', 'defaults', 'body')",
            "",
            "",
            "class CallBlock(Stmt):",
            "    \"\"\"Like a macro without a name but a call instead.  `call` is called with",
            "    the unnamed macro as `caller` argument this node holds.",
            "    \"\"\"",
            "    fields = ('call', 'args', 'defaults', 'body')",
            "",
            "",
            "class FilterBlock(Stmt):",
            "    \"\"\"Node for filter sections.\"\"\"",
            "    fields = ('body', 'filter')",
            "",
            "",
            "class Block(Stmt):",
            "    \"\"\"A node that represents a block.\"\"\"",
            "    fields = ('name', 'body', 'scoped')",
            "",
            "",
            "class Include(Stmt):",
            "    \"\"\"A node that represents the include tag.\"\"\"",
            "    fields = ('template', 'with_context', 'ignore_missing')",
            "",
            "",
            "class Import(Stmt):",
            "    \"\"\"A node that represents the import tag.\"\"\"",
            "    fields = ('template', 'target', 'with_context')",
            "",
            "",
            "class FromImport(Stmt):",
            "    \"\"\"A node that represents the from import tag.  It's important to not",
            "    pass unsafe names to the name attribute.  The compiler translates the",
            "    attribute lookups directly into getattr calls and does *not* use the",
            "    subscript callback of the interface.  As exported variables may not",
            "    start with double underscores (which the parser asserts) this is not a",
            "    problem for regular Jinja code, but if this node is used in an extension",
            "    extra care must be taken.",
            "",
            "    The list of names may contain tuples if aliases are wanted.",
            "    \"\"\"",
            "    fields = ('template', 'names', 'with_context')",
            "",
            "",
            "class ExprStmt(Stmt):",
            "    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"",
            "    fields = ('node',)",
            "",
            "",
            "class Assign(Stmt):",
            "    \"\"\"Assigns an expression to a target.\"\"\"",
            "    fields = ('target', 'node')",
            "",
            "",
            "class AssignBlock(Stmt):",
            "    \"\"\"Assigns a block to a target.\"\"\"",
            "    fields = ('target', 'body')",
            "",
            "",
            "class Expr(Node):",
            "    \"\"\"Baseclass for all expressions.\"\"\"",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        \"\"\"Return the value of the expression as constant or raise",
            "        :exc:`Impossible` if this was not possible.",
            "",
            "        An :class:`EvalContext` can be provided, if none is given",
            "        a default context is created which requires the nodes to have",
            "        an attached environment.",
            "",
            "        .. versionchanged:: 2.4",
            "           the `eval_ctx` parameter was added.",
            "        \"\"\"",
            "        raise Impossible()",
            "",
            "    def can_assign(self):",
            "        \"\"\"Check if it's possible to assign something to this node.\"\"\"",
            "        return False",
            "",
            "",
            "class BinExpr(Expr):",
            "    \"\"\"Baseclass for all binary expressions.\"\"\"",
            "    fields = ('left', 'right')",
            "    operator = None",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        # intercepted operators cannot be folded at compile time",
            "        if self.environment.sandboxed and \\",
            "           self.operator in self.environment.intercepted_binops:",
            "            raise Impossible()",
            "        f = _binop_to_func[self.operator]",
            "        try:",
            "            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class UnaryExpr(Expr):",
            "    \"\"\"Baseclass for all unary expressions.\"\"\"",
            "    fields = ('node',)",
            "    operator = None",
            "    abstract = True",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        # intercepted operators cannot be folded at compile time",
            "        if self.environment.sandboxed and \\",
            "           self.operator in self.environment.intercepted_unops:",
            "            raise Impossible()",
            "        f = _uaop_to_func[self.operator]",
            "        try:",
            "            return f(self.node.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Name(Expr):",
            "    \"\"\"Looks up a name or stores a value in a name.",
            "    The `ctx` of the node can be one of the following values:",
            "",
            "    -   `store`: store a value in the name",
            "    -   `load`: load that name",
            "    -   `param`: like `store` but if the name was defined as function parameter.",
            "    \"\"\"",
            "    fields = ('name', 'ctx')",
            "",
            "    def can_assign(self):",
            "        return self.name not in ('true', 'false', 'none',",
            "                                 'True', 'False', 'None')",
            "",
            "",
            "class Literal(Expr):",
            "    \"\"\"Baseclass for literals.\"\"\"",
            "    abstract = True",
            "",
            "",
            "class Const(Literal):",
            "    \"\"\"All constant values.  The parser will return this node for simple",
            "    constants such as ``42`` or ``\"foo\"`` but it can be used to store more",
            "    complex values such as lists too.  Only constants with a safe",
            "    representation (objects where ``eval(repr(x)) == x`` is true).",
            "    \"\"\"",
            "    fields = ('value',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        return self.value",
            "",
            "    @classmethod",
            "    def from_untrusted(cls, value, lineno=None, environment=None):",
            "        \"\"\"Return a const object if the value is representable as",
            "        constant value in the generated code, otherwise it will raise",
            "        an `Impossible` exception.",
            "        \"\"\"",
            "        from .compiler import has_safe_repr",
            "        if not has_safe_repr(value):",
            "            raise Impossible()",
            "        return cls(value, lineno=lineno, environment=environment)",
            "",
            "",
            "class TemplateData(Literal):",
            "    \"\"\"A constant template string.\"\"\"",
            "    fields = ('data',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile:",
            "            raise Impossible()",
            "        if eval_ctx.autoescape:",
            "            return Markup(self.data)",
            "        return self.data",
            "",
            "",
            "class Tuple(Literal):",
            "    \"\"\"For loop unpacking and some other things like multiple arguments",
            "    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple",
            "    is used for loading the names or storing.",
            "    \"\"\"",
            "    fields = ('items', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return tuple(x.as_const(eval_ctx) for x in self.items)",
            "",
            "    def can_assign(self):",
            "        for item in self.items:",
            "            if not item.can_assign():",
            "                return False",
            "        return True",
            "",
            "",
            "class List(Literal):",
            "    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"",
            "    fields = ('items',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return [x.as_const(eval_ctx) for x in self.items]",
            "",
            "",
            "class Dict(Literal):",
            "    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of",
            "    :class:`Pair` nodes.",
            "    \"\"\"",
            "    fields = ('items',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return dict(x.as_const(eval_ctx) for x in self.items)",
            "",
            "",
            "class Pair(Helper):",
            "    \"\"\"A key, value pair for dicts.\"\"\"",
            "    fields = ('key', 'value')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)",
            "",
            "",
            "class Keyword(Helper):",
            "    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"",
            "    fields = ('key', 'value')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.key, self.value.as_const(eval_ctx)",
            "",
            "",
            "class CondExpr(Expr):",
            "    \"\"\"A conditional expression (inline if expression).  (``{{",
            "    foo if bar else baz }}``)",
            "    \"\"\"",
            "    fields = ('test', 'expr1', 'expr2')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if self.test.as_const(eval_ctx):",
            "            return self.expr1.as_const(eval_ctx)",
            "",
            "        # if we evaluate to an undefined object, we better do that at runtime",
            "        if self.expr2 is None:",
            "            raise Impossible()",
            "",
            "        return self.expr2.as_const(eval_ctx)",
            "",
            "",
            "class Filter(Expr):",
            "    \"\"\"This node applies a filter on an expression.  `name` is the name of",
            "    the filter, the rest of the fields are the same as for :class:`Call`.",
            "",
            "    If the `node` of a filter is `None` the contents of the last buffer are",
            "    filtered.  Buffers are created by macros and filter blocks.",
            "    \"\"\"",
            "    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile or self.node is None:",
            "            raise Impossible()",
            "        # we have to be careful here because we call filter_ below.",
            "        # if this variable would be called filter, 2to3 would wrap the",
            "        # call in a list beause it is assuming we are talking about the",
            "        # builtin filter function here which no longer returns a list in",
            "        # python 3.  because of that, do not rename filter_ to filter!",
            "        filter_ = self.environment.filters.get(self.name)",
            "        if filter_ is None or getattr(filter_, 'contextfilter', False):",
            "            raise Impossible()",
            "        obj = self.node.as_const(eval_ctx)",
            "        args = [x.as_const(eval_ctx) for x in self.args]",
            "        if getattr(filter_, 'evalcontextfilter', False):",
            "            args.insert(0, eval_ctx)",
            "        elif getattr(filter_, 'environmentfilter', False):",
            "            args.insert(0, self.environment)",
            "        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)",
            "        if self.dyn_args is not None:",
            "            try:",
            "                args.extend(self.dyn_args.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        if self.dyn_kwargs is not None:",
            "            try:",
            "                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        try:",
            "            return filter_(obj, *args, **kwargs)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Test(Expr):",
            "    \"\"\"Applies a test on an expression.  `name` is the name of the test, the",
            "    rest of the fields are the same as for :class:`Call`.",
            "    \"\"\"",
            "    fields = ('node', 'name', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "",
            "class Call(Expr):",
            "    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list",
            "    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`",
            "    and `dyn_kwargs` has to be either `None` or a node that is used as",
            "    node for dynamic positional (``*args``) or keyword (``**kwargs``)",
            "    arguments.",
            "    \"\"\"",
            "    fields = ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile or eval_ctx.environment.sandboxed:",
            "            raise Impossible()",
            "        obj = self.node.as_const(eval_ctx)",
            "",
            "        # don't evaluate context functions",
            "        args = [x.as_const(eval_ctx) for x in self.args]",
            "        if isinstance(obj, _context_function_types):",
            "            if getattr(obj, 'contextfunction', False):",
            "                raise Impossible()",
            "            elif getattr(obj, 'evalcontextfunction', False):",
            "                args.insert(0, eval_ctx)",
            "            elif getattr(obj, 'environmentfunction', False):",
            "                args.insert(0, self.environment)",
            "",
            "        kwargs = dict(x.as_const(eval_ctx) for x in self.kwargs)",
            "        if self.dyn_args is not None:",
            "            try:",
            "                args.extend(self.dyn_args.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        if self.dyn_kwargs is not None:",
            "            try:",
            "                kwargs.update(self.dyn_kwargs.as_const(eval_ctx))",
            "            except Exception:",
            "                raise Impossible()",
            "        try:",
            "            return obj(*args, **kwargs)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "",
            "class Getitem(Expr):",
            "    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"",
            "    fields = ('node', 'arg', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if self.ctx != 'load':",
            "            raise Impossible()",
            "        try:",
            "            return self.environment.getitem(self.node.as_const(eval_ctx),",
            "                                            self.arg.as_const(eval_ctx))",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "    def can_assign(self):",
            "        return False",
            "",
            "",
            "class Getattr(Expr):",
            "    \"\"\"Get an attribute or item from an expression that is a ascii-only",
            "    bytestring and prefer the attribute.",
            "    \"\"\"",
            "    fields = ('node', 'attr', 'ctx')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        if self.ctx != 'load':",
            "            raise Impossible()",
            "        try:",
            "            eval_ctx = get_eval_context(self, eval_ctx)",
            "            return self.environment.getattr(self.node.as_const(eval_ctx),",
            "                                            self.attr)",
            "        except Exception:",
            "            raise Impossible()",
            "",
            "    def can_assign(self):",
            "        return False",
            "",
            "",
            "class Slice(Expr):",
            "    \"\"\"Represents a slice object.  This must only be used as argument for",
            "    :class:`Subscript`.",
            "    \"\"\"",
            "    fields = ('start', 'stop', 'step')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        def const(obj):",
            "            if obj is None:",
            "                return None",
            "            return obj.as_const(eval_ctx)",
            "        return slice(const(self.start), const(self.stop), const(self.step))",
            "",
            "",
            "class Concat(Expr):",
            "    \"\"\"Concatenates the list of expressions provided after converting them to",
            "    unicode.",
            "    \"\"\"",
            "    fields = ('nodes',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return ''.join(text_type(x.as_const(eval_ctx)) for x in self.nodes)",
            "",
            "",
            "class Compare(Expr):",
            "    \"\"\"Compares an expression with some other expressions.  `ops` must be a",
            "    list of :class:`Operand`\\s.",
            "    \"\"\"",
            "    fields = ('expr', 'ops')",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        result = value = self.expr.as_const(eval_ctx)",
            "        try:",
            "            for op in self.ops:",
            "                new_value = op.expr.as_const(eval_ctx)",
            "                result = _cmpop_to_func[op.op](value, new_value)",
            "                value = new_value",
            "        except Exception:",
            "            raise Impossible()",
            "        return result",
            "",
            "",
            "class Operand(Helper):",
            "    \"\"\"Holds an operator and an expression.\"\"\"",
            "    fields = ('op', 'expr')",
            "",
            "if __debug__:",
            "    Operand.__doc__ += '\\nThe following operators are available: ' + \\",
            "        ', '.join(sorted('``%s``' % x for x in set(_binop_to_func) |",
            "                  set(_uaop_to_func) | set(_cmpop_to_func)))",
            "",
            "",
            "class Mul(BinExpr):",
            "    \"\"\"Multiplies the left with the right node.\"\"\"",
            "    operator = '*'",
            "",
            "",
            "class Div(BinExpr):",
            "    \"\"\"Divides the left by the right node.\"\"\"",
            "    operator = '/'",
            "",
            "",
            "class FloorDiv(BinExpr):",
            "    \"\"\"Divides the left by the right node and truncates conver the",
            "    result into an integer by truncating.",
            "    \"\"\"",
            "    operator = '//'",
            "",
            "",
            "class Add(BinExpr):",
            "    \"\"\"Add the left to the right node.\"\"\"",
            "    operator = '+'",
            "",
            "",
            "class Sub(BinExpr):",
            "    \"\"\"Subtract the right from the left node.\"\"\"",
            "    operator = '-'",
            "",
            "",
            "class Mod(BinExpr):",
            "    \"\"\"Left modulo right.\"\"\"",
            "    operator = '%'",
            "",
            "",
            "class Pow(BinExpr):",
            "    \"\"\"Left to the power of right.\"\"\"",
            "    operator = '**'",
            "",
            "",
            "class And(BinExpr):",
            "    \"\"\"Short circuited AND.\"\"\"",
            "    operator = 'and'",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)",
            "",
            "",
            "class Or(BinExpr):",
            "    \"\"\"Short circuited OR.\"\"\"",
            "    operator = 'or'",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)",
            "",
            "",
            "class Not(UnaryExpr):",
            "    \"\"\"Negate the expression.\"\"\"",
            "    operator = 'not'",
            "",
            "",
            "class Neg(UnaryExpr):",
            "    \"\"\"Make the expression negative.\"\"\"",
            "    operator = '-'",
            "",
            "",
            "class Pos(UnaryExpr):",
            "    \"\"\"Make the expression positive (noop for most expressions)\"\"\"",
            "    operator = '+'",
            "",
            "",
            "# Helpers for extensions",
            "",
            "",
            "class EnvironmentAttribute(Expr):",
            "    \"\"\"Loads an attribute from the environment object.  This is useful for",
            "    extensions that want to call a callback stored on the environment.",
            "    \"\"\"",
            "    fields = ('name',)",
            "",
            "",
            "class ExtensionAttribute(Expr):",
            "    \"\"\"Returns the attribute of an extension bound to the environment.",
            "    The identifier is the identifier of the :class:`Extension`.",
            "",
            "    This node is usually constructed by calling the",
            "    :meth:`~jinja2.ext.Extension.attr` method on an extension.",
            "    \"\"\"",
            "    fields = ('identifier', 'name')",
            "",
            "",
            "class ImportedName(Expr):",
            "    \"\"\"If created with an import name the import name is returned on node",
            "    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`",
            "    function from the cgi module on evaluation.  Imports are optimized by the",
            "    compiler so there is no need to assign them to local variables.",
            "    \"\"\"",
            "    fields = ('importname',)",
            "",
            "",
            "class InternalName(Expr):",
            "    \"\"\"An internal name in the compiler.  You cannot create these nodes",
            "    yourself but the parser provides a",
            "    :meth:`~jinja2.parser.Parser.free_identifier` method that creates",
            "    a new identifier for you.  This identifier is not available from the",
            "    template and is not threated specially by the compiler.",
            "    \"\"\"",
            "    fields = ('name',)",
            "",
            "    def __init__(self):",
            "        raise TypeError('Can\\'t create internal names.  Use the '",
            "                        '`free_identifier` method on a parser.')",
            "",
            "",
            "class MarkSafe(Expr):",
            "    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"",
            "    fields = ('expr',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        return Markup(self.expr.as_const(eval_ctx))",
            "",
            "",
            "class MarkSafeIfAutoescape(Expr):",
            "    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but",
            "    only if autoescaping is active.",
            "",
            "    .. versionadded:: 2.5",
            "    \"\"\"",
            "    fields = ('expr',)",
            "",
            "    def as_const(self, eval_ctx=None):",
            "        eval_ctx = get_eval_context(self, eval_ctx)",
            "        if eval_ctx.volatile:",
            "            raise Impossible()",
            "        expr = self.expr.as_const(eval_ctx)",
            "        if eval_ctx.autoescape:",
            "            return Markup(expr)",
            "        return expr",
            "",
            "",
            "class ContextReference(Expr):",
            "    \"\"\"Returns the current template context.  It can be used like a",
            "    :class:`Name` node, with a ``'load'`` ctx and will return the",
            "    current :class:`~jinja2.runtime.Context` object.",
            "",
            "    Here an example that assigns the current template name to a",
            "    variable named `foo`::",
            "",
            "        Assign(Name('foo', ctx='store'),",
            "               Getattr(ContextReference(), 'name'))",
            "    \"\"\"",
            "",
            "",
            "class Continue(Stmt):",
            "    \"\"\"Continue a loop.\"\"\"",
            "",
            "",
            "class Break(Stmt):",
            "    \"\"\"Break a loop.\"\"\"",
            "",
            "",
            "class Scope(Stmt):",
            "    \"\"\"An artificial scope.\"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "class EvalContextModifier(Stmt):",
            "    \"\"\"Modifies the eval context.  For each option that should be modified,",
            "    a :class:`Keyword` has to be added to the :attr:`options` list.",
            "",
            "    Example to change the `autoescape` setting::",
            "",
            "        EvalContextModifier(options=[Keyword('autoescape', Const(True))])",
            "    \"\"\"",
            "    fields = ('options',)",
            "",
            "",
            "class ScopedEvalContextModifier(EvalContextModifier):",
            "    \"\"\"Modifies the eval context and reverts it later.  Works exactly like",
            "    :class:`EvalContextModifier` but will only modify the",
            "    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.",
            "    \"\"\"",
            "    fields = ('body',)",
            "",
            "",
            "# make sure nobody creates custom nodes",
            "def _failing_new(*args, **kwargs):",
            "    raise TypeError('can\\'t create custom node types')",
            "NodeType.__new__ = staticmethod(_failing_new); del _failing_new"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "607": [
                "Call",
                "as_const"
            ]
        },
        "addLocation": []
    },
    "jinja2/sandbox.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import types"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import operator"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from collections import Mapping"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from jinja2.environment import Environment"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from jinja2.exceptions import SecurityError"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2._compat import string_types, PY2"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from jinja2._compat import string_types, text_type, PY2"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from jinja2.utils import Markup"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+has_format = False"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+if hasattr(text_type, 'format'):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    from markupsafe import EscapeFormatter"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    from string import Formatter"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    has_format = True"
            },
            "15": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " #: maximum number of items a range may produce"
            },
            "18": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " #: unsafe generator attirbutes."
            },
            "19": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " UNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])"
            },
            "20": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+#: unsafe attributes on coroutines"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+UNSAFE_COROUTINE_ATTRIBUTES = set(['cr_frame', 'cr_code'])"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+#: unsafe attributes on async generators"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = set(['ag_code', 'ag_frame'])"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " import warnings"
            },
            "28": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " # make sure we don't warn in python 2.6 about stuff we don't care about"
            },
            "30": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " )"
            },
            "31": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+class _MagicFormatMapping(Mapping):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    \"\"\"This class implements a dummy wrapper to fix a bug in the Python"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    standard library for string formatting."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    See http://bugs.python.org/issue13598 for information about why"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    this is necessary."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    \"\"\""
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    def __init__(self, args, kwargs):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        self._args = args"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        self._kwargs = kwargs"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        self._last_index = 0"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    def __getitem__(self, key):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        if key == '':"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+            idx = self._last_index"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            self._last_index += 1"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            try:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                return self._args[idx]"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+            except LookupError:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+                pass"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+            key = str(idx)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        return self._kwargs[key]"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    def __iter__(self):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        return iter(self._kwargs)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    def __len__(self):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        return len(self._kwargs)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+def inspect_format_method(callable):"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    if not has_format:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        return None"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    if not isinstance(callable, (types.MethodType,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                                 types.BuiltinMethodType)) or \\"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+       callable.__name__ != 'format':"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        return None"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    obj = callable.__self__"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+    if isinstance(obj, string_types):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        return obj"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " def safe_range(*args):"
            },
            "77": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     \"\"\"A range that can't generate ranges with a length of more than"
            },
            "78": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     MAX_RANGE items."
            },
            "79": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     elif isinstance(obj, types.GeneratorType):"
            },
            "80": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         if attr in UNSAFE_GENERATOR_ATTRIBUTES:"
            },
            "81": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "             return True"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+    elif hasattr(types, 'CoroutineType') and isinstance(obj, types.CoroutineType):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        if attr in UNSAFE_COROUTINE_ATTRIBUTES:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            return True"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+    elif hasattr(types, 'AsyncGeneratorType') and isinstance(obj, types.AsyncGeneratorType):"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        if attri in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            return True"
            },
            "88": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     return attr.startswith('__')"
            },
            "89": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 213,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     attributes or functions are safe to access."
            },
            "92": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "     If the template tries to access insecure code a :exc:`SecurityError` is"
            },
            "94": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    raised.  However also other exceptions may occour during the rendering so"
            },
            "95": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    the caller has to ensure that all exceptions are catched."
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    raised.  However also other exceptions may occur during the rendering so"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+    the caller has to ensure that all exceptions are caught."
            },
            "98": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "     \"\"\""
            },
            "99": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "     sandboxed = True"
            },
            "100": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             obj.__class__.__name__"
            },
            "102": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "         ), name=attribute, obj=obj, exc=SecurityError)"
            },
            "103": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 411,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+    def format_string(self, s, args, kwargs):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        \"\"\"If a format call is detected, then this is routed through this"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        method so that our safety sandbox can be used for it."
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+        \"\"\""
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+        if isinstance(s, Markup):"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+            formatter = SandboxedEscapeFormatter(self, s.escape)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        else:"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+            formatter = SandboxedFormatter(self)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        kwargs = _MagicFormatMapping(args, kwargs)"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+        rv = formatter.vformat(s, args, kwargs)"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+        return type(s)(rv)"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "     def call(__self, __context, __obj, *args, **kwargs):"
            },
            "117": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 425,
                "PatchRowcode": "         \"\"\"Call an object from sandboxed code.\"\"\""
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        fmt = inspect_format_method(__obj)"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+        if fmt is not None:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+            return __self.format_string(fmt, args, kwargs)"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+"
            },
            "122": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "         # the double prefixes are to avoid double keyword argument"
            },
            "123": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "         # errors when proxying the call."
            },
            "124": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         if not __self.is_safe_callable(__obj):"
            },
            "125": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "         if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):"
            },
            "126": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "             return False"
            },
            "127": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "         return not modifies_known_mutable(obj, attr)"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+if has_format:"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+    # This really is not a public API apparenlty."
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+    try:"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+        from _string import formatter_field_name_split"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+    except ImportError:"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        def formatter_field_name_split(field_name):"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+            return field_name._formatter_field_name_split()"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+    class SandboxedFormatterMixin(object):"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        def __init__(self, env):"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+            self._env = env"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+        def get_field(self, field_name, args, kwargs):"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+            first, rest = formatter_field_name_split(field_name)"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+            obj = self.get_value(first, args, kwargs)"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+            for is_attr, i in rest:"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+                if is_attr:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+                    obj = self._env.getattr(obj, i)"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+                else:"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+                    obj = self._env.getitem(obj, i)"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+            return obj, first"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+    class SandboxedFormatter(SandboxedFormatterMixin, Formatter):"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+        def __init__(self, env):"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+            SandboxedFormatterMixin.__init__(self, env)"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+            Formatter.__init__(self)"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+    class SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        def __init__(self, env, escape):"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+            SandboxedFormatterMixin.__init__(self, env)"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+            EscapeFormatter.__init__(self, escape)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    jinja2.sandbox",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Adds a sandbox layer to Jinja as it was the default behavior in the old",
            "    Jinja 1 releases.  This sandbox is slightly different from Jinja 1 as the",
            "    default behavior is easier to use.",
            "",
            "    The behavior can be changed by subclassing the environment.",
            "",
            "    :copyright: (c) 2010 by the Jinja Team.",
            "    :license: BSD.",
            "\"\"\"",
            "import types",
            "import operator",
            "from jinja2.environment import Environment",
            "from jinja2.exceptions import SecurityError",
            "from jinja2._compat import string_types, PY2",
            "",
            "",
            "#: maximum number of items a range may produce",
            "MAX_RANGE = 100000",
            "",
            "#: attributes of function objects that are considered unsafe.",
            "if PY2:",
            "    UNSAFE_FUNCTION_ATTRIBUTES = set(['func_closure', 'func_code', 'func_dict',",
            "                                      'func_defaults', 'func_globals'])",
            "else:",
            "    # On versions > python 2 the special attributes on functions are gone,",
            "    # but they remain on methods and generators for whatever reason.",
            "    UNSAFE_FUNCTION_ATTRIBUTES = set()",
            "",
            "",
            "#: unsafe method attributes.  function attributes are unsafe for methods too",
            "UNSAFE_METHOD_ATTRIBUTES = set(['im_class', 'im_func', 'im_self'])",
            "",
            "#: unsafe generator attirbutes.",
            "UNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])",
            "",
            "import warnings",
            "",
            "# make sure we don't warn in python 2.6 about stuff we don't care about",
            "warnings.filterwarnings('ignore', 'the sets module', DeprecationWarning,",
            "                        module='jinja2.sandbox')",
            "",
            "from collections import deque",
            "",
            "_mutable_set_types = (set,)",
            "_mutable_mapping_types = (dict,)",
            "_mutable_sequence_types = (list,)",
            "",
            "",
            "# on python 2.x we can register the user collection types",
            "try:",
            "    from UserDict import UserDict, DictMixin",
            "    from UserList import UserList",
            "    _mutable_mapping_types += (UserDict, DictMixin)",
            "    _mutable_set_types += (UserList,)",
            "except ImportError:",
            "    pass",
            "",
            "# if sets is still available, register the mutable set from there as well",
            "try:",
            "    from sets import Set",
            "    _mutable_set_types += (Set,)",
            "except ImportError:",
            "    pass",
            "",
            "#: register Python 2.6 abstract base classes",
            "try:",
            "    from collections import MutableSet, MutableMapping, MutableSequence",
            "    _mutable_set_types += (MutableSet,)",
            "    _mutable_mapping_types += (MutableMapping,)",
            "    _mutable_sequence_types += (MutableSequence,)",
            "except ImportError:",
            "    pass",
            "",
            "_mutable_spec = (",
            "    (_mutable_set_types, frozenset([",
            "        'add', 'clear', 'difference_update', 'discard', 'pop', 'remove',",
            "        'symmetric_difference_update', 'update'",
            "    ])),",
            "    (_mutable_mapping_types, frozenset([",
            "        'clear', 'pop', 'popitem', 'setdefault', 'update'",
            "    ])),",
            "    (_mutable_sequence_types, frozenset([",
            "        'append', 'reverse', 'insert', 'sort', 'extend', 'remove'",
            "    ])),",
            "    (deque, frozenset([",
            "        'append', 'appendleft', 'clear', 'extend', 'extendleft', 'pop',",
            "        'popleft', 'remove', 'rotate'",
            "    ]))",
            ")",
            "",
            "",
            "def safe_range(*args):",
            "    \"\"\"A range that can't generate ranges with a length of more than",
            "    MAX_RANGE items.",
            "    \"\"\"",
            "    rng = range(*args)",
            "    if len(rng) > MAX_RANGE:",
            "        raise OverflowError('range too big, maximum size for range is %d' %",
            "                            MAX_RANGE)",
            "    return rng",
            "",
            "",
            "def unsafe(f):",
            "    \"\"\"Marks a function or method as unsafe.",
            "",
            "    ::",
            "",
            "        @unsafe",
            "        def delete(self):",
            "            pass",
            "    \"\"\"",
            "    f.unsafe_callable = True",
            "    return f",
            "",
            "",
            "def is_internal_attribute(obj, attr):",
            "    \"\"\"Test if the attribute given is an internal python attribute.  For",
            "    example this function returns `True` for the `func_code` attribute of",
            "    python objects.  This is useful if the environment method",
            "    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.",
            "",
            "    >>> from jinja2.sandbox import is_internal_attribute",
            "    >>> is_internal_attribute(str, \"mro\")",
            "    True",
            "    >>> is_internal_attribute(str, \"upper\")",
            "    False",
            "    \"\"\"",
            "    if isinstance(obj, types.FunctionType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, types.MethodType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES or \\",
            "           attr in UNSAFE_METHOD_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, type):",
            "        if attr == 'mro':",
            "            return True",
            "    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):",
            "        return True",
            "    elif isinstance(obj, types.GeneratorType):",
            "        if attr in UNSAFE_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    return attr.startswith('__')",
            "",
            "",
            "def modifies_known_mutable(obj, attr):",
            "    \"\"\"This function checks if an attribute on a builtin mutable object",
            "    (list, dict, set or deque) would modify it if called.  It also supports",
            "    the \"user\"-versions of the objects (`sets.Set`, `UserDict.*` etc.) and",
            "    with Python 2.6 onwards the abstract base classes `MutableSet`,",
            "    `MutableMapping`, and `MutableSequence`.",
            "",
            "    >>> modifies_known_mutable({}, \"clear\")",
            "    True",
            "    >>> modifies_known_mutable({}, \"keys\")",
            "    False",
            "    >>> modifies_known_mutable([], \"append\")",
            "    True",
            "    >>> modifies_known_mutable([], \"index\")",
            "    False",
            "",
            "    If called with an unsupported object (such as unicode) `False` is",
            "    returned.",
            "",
            "    >>> modifies_known_mutable(\"foo\", \"upper\")",
            "    False",
            "    \"\"\"",
            "    for typespec, unsafe in _mutable_spec:",
            "        if isinstance(obj, typespec):",
            "            return attr in unsafe",
            "    return False",
            "",
            "",
            "class SandboxedEnvironment(Environment):",
            "    \"\"\"The sandboxed environment.  It works like the regular environment but",
            "    tells the compiler to generate sandboxed code.  Additionally subclasses of",
            "    this environment may override the methods that tell the runtime what",
            "    attributes or functions are safe to access.",
            "",
            "    If the template tries to access insecure code a :exc:`SecurityError` is",
            "    raised.  However also other exceptions may occour during the rendering so",
            "    the caller has to ensure that all exceptions are catched.",
            "    \"\"\"",
            "    sandboxed = True",
            "",
            "    #: default callback table for the binary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`binop_table`",
            "    default_binop_table = {",
            "        '+':        operator.add,",
            "        '-':        operator.sub,",
            "        '*':        operator.mul,",
            "        '/':        operator.truediv,",
            "        '//':       operator.floordiv,",
            "        '**':       operator.pow,",
            "        '%':        operator.mod",
            "    }",
            "",
            "    #: default callback table for the unary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`unop_table`",
            "    default_unop_table = {",
            "        '+':        operator.pos,",
            "        '-':        operator.neg",
            "    }",
            "",
            "    #: a set of binary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_binop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`binop_table`.",
            "    #:",
            "    #: The following binary operators are interceptable:",
            "    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_binops = frozenset()",
            "",
            "    #: a set of unary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_unop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`unop_table`.",
            "    #:",
            "    #: The following unary operators are interceptable: ``+``, ``-``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_unops = frozenset()",
            "",
            "    def intercept_unop(self, operator):",
            "        \"\"\"Called during template compilation with the name of a unary",
            "        operator to check if it should be intercepted at runtime.  If this",
            "        method returns `True`, :meth:`call_unop` is excuted for this unary",
            "        operator.  The default implementation of :meth:`call_unop` will use",
            "        the :attr:`unop_table` dictionary to perform the operator with the",
            "        same logic as the builtin one.",
            "",
            "        The following unary operators are interceptable: ``+`` and ``-``",
            "",
            "        Intercepted calls are always slower than the native operator call,",
            "        so make sure only to intercept the ones you are interested in.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return False",
            "",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        Environment.__init__(self, *args, **kwargs)",
            "        self.globals['range'] = safe_range",
            "        self.binop_table = self.default_binop_table.copy()",
            "        self.unop_table = self.default_unop_table.copy()",
            "",
            "    def is_safe_attribute(self, obj, attr, value):",
            "        \"\"\"The sandboxed environment will call this method to check if the",
            "        attribute of an object is safe to access.  Per default all attributes",
            "        starting with an underscore are considered private as well as the",
            "        special attributes of internal python objects as returned by the",
            "        :func:`is_internal_attribute` function.",
            "        \"\"\"",
            "        return not (attr.startswith('_') or is_internal_attribute(obj, attr))",
            "",
            "    def is_safe_callable(self, obj):",
            "        \"\"\"Check if an object is safely callable.  Per default a function is",
            "        considered safe unless the `unsafe_callable` attribute exists and is",
            "        True.  Override this method to alter the behavior, but this won't",
            "        affect the `unsafe` decorator from this module.",
            "        \"\"\"",
            "        return not (getattr(obj, 'unsafe_callable', False) or",
            "                    getattr(obj, 'alters_data', False))",
            "",
            "    def call_binop(self, context, operator, left, right):",
            "        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.binop_table[operator](left, right)",
            "",
            "    def call_unop(self, context, operator, arg):",
            "        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.unop_table[operator](arg)",
            "",
            "    def getitem(self, obj, argument):",
            "        \"\"\"Subscribe an object from sandboxed code.\"\"\"",
            "        try:",
            "            return obj[argument]",
            "        except (TypeError, LookupError):",
            "            if isinstance(argument, string_types):",
            "                try:",
            "                    attr = str(argument)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    try:",
            "                        value = getattr(obj, attr)",
            "                    except AttributeError:",
            "                        pass",
            "                    else:",
            "                        if self.is_safe_attribute(obj, argument, value):",
            "                            return value",
            "                        return self.unsafe_undefined(obj, argument)",
            "        return self.undefined(obj=obj, name=argument)",
            "",
            "    def getattr(self, obj, attribute):",
            "        \"\"\"Subscribe an object from sandboxed code and prefer the",
            "        attribute.  The attribute passed *must* be a bytestring.",
            "        \"\"\"",
            "        try:",
            "            value = getattr(obj, attribute)",
            "        except AttributeError:",
            "            try:",
            "                return obj[attribute]",
            "            except (TypeError, LookupError):",
            "                pass",
            "        else:",
            "            if self.is_safe_attribute(obj, attribute, value):",
            "                return value",
            "            return self.unsafe_undefined(obj, attribute)",
            "        return self.undefined(obj=obj, name=attribute)",
            "",
            "    def unsafe_undefined(self, obj, attribute):",
            "        \"\"\"Return an undefined object for unsafe attributes.\"\"\"",
            "        return self.undefined('access to attribute %r of %r '",
            "                              'object is unsafe.' % (",
            "            attribute,",
            "            obj.__class__.__name__",
            "        ), name=attribute, obj=obj, exc=SecurityError)",
            "",
            "    def call(__self, __context, __obj, *args, **kwargs):",
            "        \"\"\"Call an object from sandboxed code.\"\"\"",
            "        # the double prefixes are to avoid double keyword argument",
            "        # errors when proxying the call.",
            "        if not __self.is_safe_callable(__obj):",
            "            raise SecurityError('%r is not safely callable' % (__obj,))",
            "        return __context.call(__obj, *args, **kwargs)",
            "",
            "",
            "class ImmutableSandboxedEnvironment(SandboxedEnvironment):",
            "    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not",
            "    permit modifications on the builtin mutable objects `list`, `set`, and",
            "    `dict` by using the :func:`modifies_known_mutable` function.",
            "    \"\"\"",
            "",
            "    def is_safe_attribute(self, obj, attr, value):",
            "        if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):",
            "            return False",
            "        return not modifies_known_mutable(obj, attr)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    jinja2.sandbox",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Adds a sandbox layer to Jinja as it was the default behavior in the old",
            "    Jinja 1 releases.  This sandbox is slightly different from Jinja 1 as the",
            "    default behavior is easier to use.",
            "",
            "    The behavior can be changed by subclassing the environment.",
            "",
            "    :copyright: (c) 2010 by the Jinja Team.",
            "    :license: BSD.",
            "\"\"\"",
            "import types",
            "import operator",
            "from collections import Mapping",
            "from jinja2.environment import Environment",
            "from jinja2.exceptions import SecurityError",
            "from jinja2._compat import string_types, text_type, PY2",
            "from jinja2.utils import Markup",
            "",
            "has_format = False",
            "if hasattr(text_type, 'format'):",
            "    from markupsafe import EscapeFormatter",
            "    from string import Formatter",
            "    has_format = True",
            "",
            "",
            "#: maximum number of items a range may produce",
            "MAX_RANGE = 100000",
            "",
            "#: attributes of function objects that are considered unsafe.",
            "if PY2:",
            "    UNSAFE_FUNCTION_ATTRIBUTES = set(['func_closure', 'func_code', 'func_dict',",
            "                                      'func_defaults', 'func_globals'])",
            "else:",
            "    # On versions > python 2 the special attributes on functions are gone,",
            "    # but they remain on methods and generators for whatever reason.",
            "    UNSAFE_FUNCTION_ATTRIBUTES = set()",
            "",
            "",
            "#: unsafe method attributes.  function attributes are unsafe for methods too",
            "UNSAFE_METHOD_ATTRIBUTES = set(['im_class', 'im_func', 'im_self'])",
            "",
            "#: unsafe generator attirbutes.",
            "UNSAFE_GENERATOR_ATTRIBUTES = set(['gi_frame', 'gi_code'])",
            "",
            "#: unsafe attributes on coroutines",
            "UNSAFE_COROUTINE_ATTRIBUTES = set(['cr_frame', 'cr_code'])",
            "",
            "#: unsafe attributes on async generators",
            "UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = set(['ag_code', 'ag_frame'])",
            "",
            "import warnings",
            "",
            "# make sure we don't warn in python 2.6 about stuff we don't care about",
            "warnings.filterwarnings('ignore', 'the sets module', DeprecationWarning,",
            "                        module='jinja2.sandbox')",
            "",
            "from collections import deque",
            "",
            "_mutable_set_types = (set,)",
            "_mutable_mapping_types = (dict,)",
            "_mutable_sequence_types = (list,)",
            "",
            "",
            "# on python 2.x we can register the user collection types",
            "try:",
            "    from UserDict import UserDict, DictMixin",
            "    from UserList import UserList",
            "    _mutable_mapping_types += (UserDict, DictMixin)",
            "    _mutable_set_types += (UserList,)",
            "except ImportError:",
            "    pass",
            "",
            "# if sets is still available, register the mutable set from there as well",
            "try:",
            "    from sets import Set",
            "    _mutable_set_types += (Set,)",
            "except ImportError:",
            "    pass",
            "",
            "#: register Python 2.6 abstract base classes",
            "try:",
            "    from collections import MutableSet, MutableMapping, MutableSequence",
            "    _mutable_set_types += (MutableSet,)",
            "    _mutable_mapping_types += (MutableMapping,)",
            "    _mutable_sequence_types += (MutableSequence,)",
            "except ImportError:",
            "    pass",
            "",
            "_mutable_spec = (",
            "    (_mutable_set_types, frozenset([",
            "        'add', 'clear', 'difference_update', 'discard', 'pop', 'remove',",
            "        'symmetric_difference_update', 'update'",
            "    ])),",
            "    (_mutable_mapping_types, frozenset([",
            "        'clear', 'pop', 'popitem', 'setdefault', 'update'",
            "    ])),",
            "    (_mutable_sequence_types, frozenset([",
            "        'append', 'reverse', 'insert', 'sort', 'extend', 'remove'",
            "    ])),",
            "    (deque, frozenset([",
            "        'append', 'appendleft', 'clear', 'extend', 'extendleft', 'pop',",
            "        'popleft', 'remove', 'rotate'",
            "    ]))",
            ")",
            "",
            "",
            "class _MagicFormatMapping(Mapping):",
            "    \"\"\"This class implements a dummy wrapper to fix a bug in the Python",
            "    standard library for string formatting.",
            "",
            "    See http://bugs.python.org/issue13598 for information about why",
            "    this is necessary.",
            "    \"\"\"",
            "",
            "    def __init__(self, args, kwargs):",
            "        self._args = args",
            "        self._kwargs = kwargs",
            "        self._last_index = 0",
            "",
            "    def __getitem__(self, key):",
            "        if key == '':",
            "            idx = self._last_index",
            "            self._last_index += 1",
            "            try:",
            "                return self._args[idx]",
            "            except LookupError:",
            "                pass",
            "            key = str(idx)",
            "        return self._kwargs[key]",
            "",
            "    def __iter__(self):",
            "        return iter(self._kwargs)",
            "",
            "    def __len__(self):",
            "        return len(self._kwargs)",
            "",
            "",
            "def inspect_format_method(callable):",
            "    if not has_format:",
            "        return None",
            "    if not isinstance(callable, (types.MethodType,",
            "                                 types.BuiltinMethodType)) or \\",
            "       callable.__name__ != 'format':",
            "        return None",
            "    obj = callable.__self__",
            "    if isinstance(obj, string_types):",
            "        return obj",
            "",
            "",
            "def safe_range(*args):",
            "    \"\"\"A range that can't generate ranges with a length of more than",
            "    MAX_RANGE items.",
            "    \"\"\"",
            "    rng = range(*args)",
            "    if len(rng) > MAX_RANGE:",
            "        raise OverflowError('range too big, maximum size for range is %d' %",
            "                            MAX_RANGE)",
            "    return rng",
            "",
            "",
            "def unsafe(f):",
            "    \"\"\"Marks a function or method as unsafe.",
            "",
            "    ::",
            "",
            "        @unsafe",
            "        def delete(self):",
            "            pass",
            "    \"\"\"",
            "    f.unsafe_callable = True",
            "    return f",
            "",
            "",
            "def is_internal_attribute(obj, attr):",
            "    \"\"\"Test if the attribute given is an internal python attribute.  For",
            "    example this function returns `True` for the `func_code` attribute of",
            "    python objects.  This is useful if the environment method",
            "    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.",
            "",
            "    >>> from jinja2.sandbox import is_internal_attribute",
            "    >>> is_internal_attribute(str, \"mro\")",
            "    True",
            "    >>> is_internal_attribute(str, \"upper\")",
            "    False",
            "    \"\"\"",
            "    if isinstance(obj, types.FunctionType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, types.MethodType):",
            "        if attr in UNSAFE_FUNCTION_ATTRIBUTES or \\",
            "           attr in UNSAFE_METHOD_ATTRIBUTES:",
            "            return True",
            "    elif isinstance(obj, type):",
            "        if attr == 'mro':",
            "            return True",
            "    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):",
            "        return True",
            "    elif isinstance(obj, types.GeneratorType):",
            "        if attr in UNSAFE_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, 'CoroutineType') and isinstance(obj, types.CoroutineType):",
            "        if attr in UNSAFE_COROUTINE_ATTRIBUTES:",
            "            return True",
            "    elif hasattr(types, 'AsyncGeneratorType') and isinstance(obj, types.AsyncGeneratorType):",
            "        if attri in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:",
            "            return True",
            "    return attr.startswith('__')",
            "",
            "",
            "def modifies_known_mutable(obj, attr):",
            "    \"\"\"This function checks if an attribute on a builtin mutable object",
            "    (list, dict, set or deque) would modify it if called.  It also supports",
            "    the \"user\"-versions of the objects (`sets.Set`, `UserDict.*` etc.) and",
            "    with Python 2.6 onwards the abstract base classes `MutableSet`,",
            "    `MutableMapping`, and `MutableSequence`.",
            "",
            "    >>> modifies_known_mutable({}, \"clear\")",
            "    True",
            "    >>> modifies_known_mutable({}, \"keys\")",
            "    False",
            "    >>> modifies_known_mutable([], \"append\")",
            "    True",
            "    >>> modifies_known_mutable([], \"index\")",
            "    False",
            "",
            "    If called with an unsupported object (such as unicode) `False` is",
            "    returned.",
            "",
            "    >>> modifies_known_mutable(\"foo\", \"upper\")",
            "    False",
            "    \"\"\"",
            "    for typespec, unsafe in _mutable_spec:",
            "        if isinstance(obj, typespec):",
            "            return attr in unsafe",
            "    return False",
            "",
            "",
            "class SandboxedEnvironment(Environment):",
            "    \"\"\"The sandboxed environment.  It works like the regular environment but",
            "    tells the compiler to generate sandboxed code.  Additionally subclasses of",
            "    this environment may override the methods that tell the runtime what",
            "    attributes or functions are safe to access.",
            "",
            "    If the template tries to access insecure code a :exc:`SecurityError` is",
            "    raised.  However also other exceptions may occur during the rendering so",
            "    the caller has to ensure that all exceptions are caught.",
            "    \"\"\"",
            "    sandboxed = True",
            "",
            "    #: default callback table for the binary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`binop_table`",
            "    default_binop_table = {",
            "        '+':        operator.add,",
            "        '-':        operator.sub,",
            "        '*':        operator.mul,",
            "        '/':        operator.truediv,",
            "        '//':       operator.floordiv,",
            "        '**':       operator.pow,",
            "        '%':        operator.mod",
            "    }",
            "",
            "    #: default callback table for the unary operators.  A copy of this is",
            "    #: available on each instance of a sandboxed environment as",
            "    #: :attr:`unop_table`",
            "    default_unop_table = {",
            "        '+':        operator.pos,",
            "        '-':        operator.neg",
            "    }",
            "",
            "    #: a set of binary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_binop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`binop_table`.",
            "    #:",
            "    #: The following binary operators are interceptable:",
            "    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_binops = frozenset()",
            "",
            "    #: a set of unary operators that should be intercepted.  Each operator",
            "    #: that is added to this set (empty by default) is delegated to the",
            "    #: :meth:`call_unop` method that will perform the operator.  The default",
            "    #: operator callback is specified by :attr:`unop_table`.",
            "    #:",
            "    #: The following unary operators are interceptable: ``+``, ``-``",
            "    #:",
            "    #: The default operation form the operator table corresponds to the",
            "    #: builtin function.  Intercepted calls are always slower than the native",
            "    #: operator call, so make sure only to intercept the ones you are",
            "    #: interested in.",
            "    #:",
            "    #: .. versionadded:: 2.6",
            "    intercepted_unops = frozenset()",
            "",
            "    def intercept_unop(self, operator):",
            "        \"\"\"Called during template compilation with the name of a unary",
            "        operator to check if it should be intercepted at runtime.  If this",
            "        method returns `True`, :meth:`call_unop` is excuted for this unary",
            "        operator.  The default implementation of :meth:`call_unop` will use",
            "        the :attr:`unop_table` dictionary to perform the operator with the",
            "        same logic as the builtin one.",
            "",
            "        The following unary operators are interceptable: ``+`` and ``-``",
            "",
            "        Intercepted calls are always slower than the native operator call,",
            "        so make sure only to intercept the ones you are interested in.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return False",
            "",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        Environment.__init__(self, *args, **kwargs)",
            "        self.globals['range'] = safe_range",
            "        self.binop_table = self.default_binop_table.copy()",
            "        self.unop_table = self.default_unop_table.copy()",
            "",
            "    def is_safe_attribute(self, obj, attr, value):",
            "        \"\"\"The sandboxed environment will call this method to check if the",
            "        attribute of an object is safe to access.  Per default all attributes",
            "        starting with an underscore are considered private as well as the",
            "        special attributes of internal python objects as returned by the",
            "        :func:`is_internal_attribute` function.",
            "        \"\"\"",
            "        return not (attr.startswith('_') or is_internal_attribute(obj, attr))",
            "",
            "    def is_safe_callable(self, obj):",
            "        \"\"\"Check if an object is safely callable.  Per default a function is",
            "        considered safe unless the `unsafe_callable` attribute exists and is",
            "        True.  Override this method to alter the behavior, but this won't",
            "        affect the `unsafe` decorator from this module.",
            "        \"\"\"",
            "        return not (getattr(obj, 'unsafe_callable', False) or",
            "                    getattr(obj, 'alters_data', False))",
            "",
            "    def call_binop(self, context, operator, left, right):",
            "        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.binop_table[operator](left, right)",
            "",
            "    def call_unop(self, context, operator, arg):",
            "        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)",
            "        this function is executed instead of the builtin operator.  This can",
            "        be used to fine tune the behavior of certain operators.",
            "",
            "        .. versionadded:: 2.6",
            "        \"\"\"",
            "        return self.unop_table[operator](arg)",
            "",
            "    def getitem(self, obj, argument):",
            "        \"\"\"Subscribe an object from sandboxed code.\"\"\"",
            "        try:",
            "            return obj[argument]",
            "        except (TypeError, LookupError):",
            "            if isinstance(argument, string_types):",
            "                try:",
            "                    attr = str(argument)",
            "                except Exception:",
            "                    pass",
            "                else:",
            "                    try:",
            "                        value = getattr(obj, attr)",
            "                    except AttributeError:",
            "                        pass",
            "                    else:",
            "                        if self.is_safe_attribute(obj, argument, value):",
            "                            return value",
            "                        return self.unsafe_undefined(obj, argument)",
            "        return self.undefined(obj=obj, name=argument)",
            "",
            "    def getattr(self, obj, attribute):",
            "        \"\"\"Subscribe an object from sandboxed code and prefer the",
            "        attribute.  The attribute passed *must* be a bytestring.",
            "        \"\"\"",
            "        try:",
            "            value = getattr(obj, attribute)",
            "        except AttributeError:",
            "            try:",
            "                return obj[attribute]",
            "            except (TypeError, LookupError):",
            "                pass",
            "        else:",
            "            if self.is_safe_attribute(obj, attribute, value):",
            "                return value",
            "            return self.unsafe_undefined(obj, attribute)",
            "        return self.undefined(obj=obj, name=attribute)",
            "",
            "    def unsafe_undefined(self, obj, attribute):",
            "        \"\"\"Return an undefined object for unsafe attributes.\"\"\"",
            "        return self.undefined('access to attribute %r of %r '",
            "                              'object is unsafe.' % (",
            "            attribute,",
            "            obj.__class__.__name__",
            "        ), name=attribute, obj=obj, exc=SecurityError)",
            "",
            "    def format_string(self, s, args, kwargs):",
            "        \"\"\"If a format call is detected, then this is routed through this",
            "        method so that our safety sandbox can be used for it.",
            "        \"\"\"",
            "        if isinstance(s, Markup):",
            "            formatter = SandboxedEscapeFormatter(self, s.escape)",
            "        else:",
            "            formatter = SandboxedFormatter(self)",
            "        kwargs = _MagicFormatMapping(args, kwargs)",
            "        rv = formatter.vformat(s, args, kwargs)",
            "        return type(s)(rv)",
            "",
            "    def call(__self, __context, __obj, *args, **kwargs):",
            "        \"\"\"Call an object from sandboxed code.\"\"\"",
            "        fmt = inspect_format_method(__obj)",
            "        if fmt is not None:",
            "            return __self.format_string(fmt, args, kwargs)",
            "",
            "        # the double prefixes are to avoid double keyword argument",
            "        # errors when proxying the call.",
            "        if not __self.is_safe_callable(__obj):",
            "            raise SecurityError('%r is not safely callable' % (__obj,))",
            "        return __context.call(__obj, *args, **kwargs)",
            "",
            "",
            "class ImmutableSandboxedEnvironment(SandboxedEnvironment):",
            "    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not",
            "    permit modifications on the builtin mutable objects `list`, `set`, and",
            "    `dict` by using the :func:`modifies_known_mutable` function.",
            "    \"\"\"",
            "",
            "    def is_safe_attribute(self, obj, attr, value):",
            "        if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):",
            "            return False",
            "        return not modifies_known_mutable(obj, attr)",
            "",
            "",
            "if has_format:",
            "    # This really is not a public API apparenlty.",
            "    try:",
            "        from _string import formatter_field_name_split",
            "    except ImportError:",
            "        def formatter_field_name_split(field_name):",
            "            return field_name._formatter_field_name_split()",
            "",
            "    class SandboxedFormatterMixin(object):",
            "",
            "        def __init__(self, env):",
            "            self._env = env",
            "",
            "        def get_field(self, field_name, args, kwargs):",
            "            first, rest = formatter_field_name_split(field_name)",
            "            obj = self.get_value(first, args, kwargs)",
            "            for is_attr, i in rest:",
            "                if is_attr:",
            "                    obj = self._env.getattr(obj, i)",
            "                else:",
            "                    obj = self._env.getitem(obj, i)",
            "            return obj, first",
            "",
            "    class SandboxedFormatter(SandboxedFormatterMixin, Formatter):",
            "        def __init__(self, env):",
            "            SandboxedFormatterMixin.__init__(self, env)",
            "            Formatter.__init__(self)",
            "",
            "    class SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):",
            "        def __init__(self, env, escape):",
            "            SandboxedFormatterMixin.__init__(self, env)",
            "            EscapeFormatter.__init__(self, escape)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "19": [],
            "186": [
                "SandboxedEnvironment"
            ],
            "187": [
                "SandboxedEnvironment"
            ]
        },
        "addLocation": []
    }
}