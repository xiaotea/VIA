{
    "cps/admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1426,
                "afterPatchRowNumber": 1426,
                "PatchRowcode": "             for kobo_entry in kobo_entries:"
            },
            "1": {
                "beforePatchRowNumber": 1427,
                "afterPatchRowNumber": 1427,
                "PatchRowcode": "                 ub.session.delete(kobo_entry)"
            },
            "2": {
                "beforePatchRowNumber": 1428,
                "afterPatchRowNumber": 1428,
                "PatchRowcode": "             ub.session_commit()"
            },
            "3": {
                "beforePatchRowNumber": 1429,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.info(u\"User {} deleted\".format(content.name))"
            },
            "4": {
                "beforePatchRowNumber": 1430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return(_(u\"User '%(nick)s' deleted\", nick=content.name))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1429,
                "PatchRowcode": "+            log.info(\"User {} deleted\".format(content.name))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1430,
                "PatchRowcode": "+            return(_(\"User '%(nick)s' deleted\", nick=content.name))"
            },
            "7": {
                "beforePatchRowNumber": 1431,
                "afterPatchRowNumber": 1431,
                "PatchRowcode": "         else:"
            },
            "8": {
                "beforePatchRowNumber": 1432,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            log.warning(_(u\"Can't delete Guest User\"))"
            },
            "9": {
                "beforePatchRowNumber": 1433,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise Exception(_(u\"Can't delete Guest User\"))"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1432,
                "PatchRowcode": "+            log.warning(_(\"Can't delete Guest User\"))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1433,
                "PatchRowcode": "+            raise Exception(_(\"Can't delete Guest User\"))"
            },
            "12": {
                "beforePatchRowNumber": 1434,
                "afterPatchRowNumber": 1434,
                "PatchRowcode": "     else:"
            },
            "13": {
                "beforePatchRowNumber": 1435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        log.warning(u\"No admin user remaining, can't delete user\")"
            },
            "14": {
                "beforePatchRowNumber": 1436,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise Exception(_(u\"No admin user remaining, can't delete user\"))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1435,
                "PatchRowcode": "+        log.warning(\"No admin user remaining, can't delete user\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1436,
                "PatchRowcode": "+        raise Exception(_(\"No admin user remaining, can't delete user\"))"
            },
            "17": {
                "beforePatchRowNumber": 1437,
                "afterPatchRowNumber": 1437,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 1438,
                "afterPatchRowNumber": 1438,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 1439,
                "afterPatchRowNumber": 1439,
                "PatchRowcode": " def _handle_edit_user(to_save, content, languages, translations, kobo_support):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import base64",
            "import json",
            "import time",
            "import operator",
            "from datetime import datetime, timedelta",
            "",
            "from babel import Locale as LC",
            "from babel.dates import format_datetime",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from flask_login import login_required, current_user, logout_user, confirm_login",
            "from flask_babel import gettext as _",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services",
            "from . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from . import debug_info, _BABEL_TRANSLATIONS",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "        'ldap': bool(services.ldap),",
            "        'goodreads': bool(services.goodreads_support),",
            "        'kobo':  bool(services.kobo),",
            "        'updater': constants.UPDATER_AVAILABLE,",
            "        'gmail': bool(services.gmail)",
            "    }",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "",
            "feature_support['gdrive'] = gdrive_support",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    # make remember me function work",
            "    if current_user.is_authenticated:",
            "        confirm_login()",
            "    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:",
            "        logout_user()",
            "    g.constants = constants",
            "    g.user = current_user",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    g.shelves_access = ub.session.query(ub.Shelf).filter(",
            "        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = request.get_json().get('parameter', -1)",
            "    showtext = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            showtext['text'] = _(u'Server restarted, please reload page')",
            "        else:",
            "            showtext['text'] = _(u'Performing shutdown of server, please close window')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(showtext)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        showtext['text'] = _(u'Reconnect successful')",
            "        return json.dumps(showtext)",
            "",
            "    showtext['text'] = _(u'Unknown command')",
            "    return json.dumps(showtext), 400",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _(u'Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:    # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short', locale=get_locale())",
            "        else:",
            "            commit = version['version']",
            "",
            "    allUser = ub.session.query(ub.User).all()",
            "    email_settings = config.get_mail_settings()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,",
            "                                 feature_support=feature_support, kobo_support=kobo_support,",
            "                                 title=_(u\"Admin page\"), page=\"admin\")",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    allUser = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=allUser.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(u\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = LC.parse(user.default_language).get_language_name(get_locale())",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = babel.list_translations() + [LC('en')]",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param =='email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param =='kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User).\\",
            "                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                              ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message':_(u\"No admin user remaining, can't remove admin role\",",
            "                                                                 nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in _BABEL_TRANSLATIONS:",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.debug_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(u\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(u\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:   # Tags as template",
            "        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }",
            "                    for i,x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])",
            "@login_required",
            "def ajax_fullsync():",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        # if os.path.isabs(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "        # else:",
            "        #    cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                                gdrive_secrets['client_id'],",
            "                                gdrive_secrets['client_secret'],",
            "                                gdrive_secrets['redirect_uris'][0]",
            "                            )",
            "",
            "    # always show google drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "        or not config.config_ldap_port \\",
            "        or not config.config_ldap_dn \\",
            "        or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = {}",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir",
            "    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured:",
            "        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
            "                                            gdrive_error)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        ub.session.query(ub.Downloads).delete()",
            "        ub.session.query(ub.ArchivedBook).delete()",
            "        ub.session.query(ub.ReadBook).delete()",
            "        ub.session.query(ub.BookShelf).delete()",
            "        ub.session.query(ub.Bookmark).delete()",
            "        ub.session.query(ub.KoboReadingState).delete()",
            "        ub.session.query(ub.KoboStatistics).delete()",
            "        ub.session.query(ub.KoboSyncedBooks).delete()",
            "        ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(u\"DB is not Writeable\"), category=\"warning\")",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                             and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_converterpath\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        _config_string(to_save, \"config_goodreads_api_secret\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_goodreads_api_secret,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _configuration_result(_(\"Settings DB is not Writeable\"))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload']= config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    content.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(u\"Please fill out all fields!\"))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query User name, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(u\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
            "            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
            "            # delete KoboReadingState and all it's children",
            "            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
            "            for kobo_entry in kobo_entries:",
            "                ub.session.delete(kobo_entry)",
            "            ub.session_commit()",
            "            log.info(u\"User {} deleted\".format(content.name))",
            "            return(_(u\"User '%(nick)s' deleted\", nick=content.name))",
            "        else:",
            "            log.warning(_(u\"Can't delete Guest User\"))",
            "            raise Exception(_(u\"Can't delete Guest User\"))",
            "    else:",
            "        log.warning(u\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(u\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "        if to_save.get(\"password\"):",
            "            content.password = generate_password_hash(to_save[\"password\"])",
            "        anonymous = content.is_anonymous",
            "        content.role = constants.selected_roles(to_save)",
            "        if anonymous:",
            "            content.role |= constants.ROLE_ANONYMOUS",
            "        else:",
            "            content.role &= ~constants.ROLE_ANONYMOUS",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            if to_save.get(\"email\", content.email) != content.email:",
            "                content.email = check_email(to_save[\"email\"])",
            "            # Query User name, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\")",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_string(to_save, \"mail_server\")",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        _config_string(to_save, \"mail_login\")",
            "        _config_string(to_save, \"mail_password\")",
            "        _config_string(to_save, \"mail_from\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(u\"E-mail server settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(u\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(u\"Password for user %s reset\", message)",
            "            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(u\"An unknown error occurred. Please try again later.\")",
            "            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(u\"Please configure the SMTP mail settings first...\")",
            "            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(u\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(u\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method, locale=get_locale())",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                text = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = text",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    kindlemail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            kindlemail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = kindlemail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None    # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users', methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.debug_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        user = username.decode('utf-8')",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import base64",
            "import json",
            "import time",
            "import operator",
            "from datetime import datetime, timedelta",
            "",
            "from babel import Locale as LC",
            "from babel.dates import format_datetime",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from flask_login import login_required, current_user, logout_user, confirm_login",
            "from flask_babel import gettext as _",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services",
            "from . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from . import debug_info, _BABEL_TRANSLATIONS",
            "",
            "try:",
            "    from functools import wraps",
            "except ImportError:",
            "    pass  # We're not using Python 3",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "        'ldap': bool(services.ldap),",
            "        'goodreads': bool(services.goodreads_support),",
            "        'kobo':  bool(services.kobo),",
            "        'updater': constants.UPDATER_AVAILABLE,",
            "        'gmail': bool(services.gmail)",
            "    }",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "",
            "feature_support['gdrive'] = gdrive_support",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    # make remember me function work",
            "    if current_user.is_authenticated:",
            "        confirm_login()",
            "    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:",
            "        logout_user()",
            "    g.constants = constants",
            "    g.user = current_user",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    g.shelves_access = ub.session.query(ub.Shelf).filter(",
            "        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = request.get_json().get('parameter', -1)",
            "    showtext = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            showtext['text'] = _(u'Server restarted, please reload page')",
            "        else:",
            "            showtext['text'] = _(u'Performing shutdown of server, please close window')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(showtext)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        showtext['text'] = _(u'Reconnect successful')",
            "        return json.dumps(showtext)",
            "",
            "    showtext['text'] = _(u'Unknown command')",
            "    return json.dumps(showtext), 400",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _(u'Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:    # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short', locale=get_locale())",
            "        else:",
            "            commit = version['version']",
            "",
            "    allUser = ub.session.query(ub.User).all()",
            "    email_settings = config.get_mail_settings()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,",
            "                                 feature_support=feature_support, kobo_support=kobo_support,",
            "                                 title=_(u\"Admin page\"), page=\"admin\")",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = babel.list_translations() + [LC('en')]",
            "    allUser = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags)\\",
            "        .join(db.books_tags_link)\\",
            "        .join(db.Books)\\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag'))\\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=allUser.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(u\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    order = request.args.get(\"order\", \"\").lower()",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = LC.parse(user.default_language).get_language_name(get_locale())",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = babel.list_translations() + [LC('en')]",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param =='email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param =='kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User).\\",
            "                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                              ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message':_(u\"No admin user remaining, can't remove admin role\",",
            "                                                                 nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in _BABEL_TRANSLATIONS:",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.debug_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\",
            "              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(u\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(u\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:   # Tags as template",
            "        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }",
            "                    for i,x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])",
            "@login_required",
            "def ajax_fullsync():",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        # if os.path.isabs(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "        # else:",
            "        #    cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                                gdrive_secrets['client_id'],",
            "                                gdrive_secrets['client_secret'],",
            "                                gdrive_secrets['redirect_uris'][0]",
            "                            )",
            "",
            "    # always show google drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "        or not config.config_ldap_port \\",
            "        or not config.config_ldap_dn \\",
            "        or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = {}",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir",
            "    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured:",
            "        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
            "                                            gdrive_error)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        ub.session.query(ub.Downloads).delete()",
            "        ub.session.query(ub.ArchivedBook).delete()",
            "        ub.session.query(ub.ReadBook).delete()",
            "        ub.session.query(ub.BookShelf).delete()",
            "        ub.session.query(ub.Bookmark).delete()",
            "        ub.session.query(ub.KoboReadingState).delete()",
            "        ub.session.query(ub.KoboStatistics).delete()",
            "        ub.session.query(ub.KoboSyncedBooks).delete()",
            "        ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(u\"DB is not Writeable\"), category=\"warning\")",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                             and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_converterpath\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        _config_string(to_save, \"config_goodreads_api_secret\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_goodreads_api_secret,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        _configuration_result(_(\"Settings DB is not Writeable\"))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload']= config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    content.password = generate_password_hash(to_save[\"password\"])",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(u\"Please fill out all fields!\"))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query User name, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(u\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
            "            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
            "            # delete KoboReadingState and all it's children",
            "            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
            "            for kobo_entry in kobo_entries:",
            "                ub.session.delete(kobo_entry)",
            "            ub.session_commit()",
            "            log.info(\"User {} deleted\".format(content.name))",
            "            return(_(\"User '%(nick)s' deleted\", nick=content.name))",
            "        else:",
            "            log.warning(_(\"Can't delete Guest User\"))",
            "            raise Exception(_(\"Can't delete Guest User\"))",
            "    else:",
            "        log.warning(\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "        if to_save.get(\"password\"):",
            "            content.password = generate_password_hash(to_save[\"password\"])",
            "        anonymous = content.is_anonymous",
            "        content.role = constants.selected_roles(to_save)",
            "        if anonymous:",
            "            content.role |= constants.ROLE_ANONYMOUS",
            "        else:",
            "            content.role &= ~constants.ROLE_ANONYMOUS",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            if to_save.get(\"email\", content.email) != content.email:",
            "                content.email = check_email(to_save[\"email\"])",
            "            # Query User name, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError:",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = [LC('en')] + babel.list_translations()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\")",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_string(to_save, \"mail_server\")",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        _config_string(to_save, \"mail_login\")",
            "        _config_string(to_save, \"mail_password\")",
            "        _config_string(to_save, \"mail_from\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError):",
            "        ub.session.rollback()",
            "        log.error(\"Settings DB is not Writeable\")",
            "        flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(u\"E-mail server settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(u\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = babel.list_translations() + [LC('en')]",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(u\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(u\"Password for user %s reset\", message)",
            "            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(u\"An unknown error occurred. Please try again later.\")",
            "            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(u\"Please configure the SMTP mail settings first...\")",
            "            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(u\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(u\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method, locale=get_locale())",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                text = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = text",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    kindlemail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            kindlemail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = kindlemail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None    # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users', methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.debug_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        user = username.decode('utf-8')",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.debug_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1429": [
                "_delete_user"
            ],
            "1430": [
                "_delete_user"
            ],
            "1432": [
                "_delete_user"
            ],
            "1433": [
                "_delete_user"
            ],
            "1435": [
                "_delete_user"
            ],
            "1436": [
                "_delete_user"
            ]
        },
        "addLocation": []
    },
    "cps/editbooks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "                 else:"
            },
            "1": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "                     calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\"
            },
            "2": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "                         filter(db.Data.format == book_format).delete()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+                    kobo_sync_status.remove_synced_book(book.id, True)"
            },
            "4": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "                 calibre_db.session.commit()"
            },
            "5": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "             except Exception as ex:"
            },
            "6": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "                 log.debug_or_exception(ex)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "from functools import wraps",
            "",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "        return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "    message = _(\"You are missing permissions to delete books\")",
            "    if jsonResponse:",
            "        return json.dumps({\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                           \"type\": \"danger\",",
            "                           \"format\": \"\",",
            "                           \"message\": message})",
            "    else:",
            "        flash(message, category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "from functools import wraps",
            "",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                    kobo_sync_status.remove_synced_book(book.id, True)",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "        return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "    message = _(\"You are missing permissions to delete books\")",
            "    if jsonResponse:",
            "        return json.dumps({\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                           \"type\": \"danger\",",
            "                           \"format\": \"\",",
            "                           \"message\": message})",
            "    else:",
            "        flash(message, category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "cps.editbooks.delete_book_from_details",
            "cps.editbooks.render_delete_book_result.warning",
            "cps.admin",
            "cps.editbooks.merge_list_book",
            "cps.editbooks.delete_book_from_table.warning",
            "cps.editbooks.delete_book_ajax"
        ]
    },
    "cps/kobo_auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " @kobo_auth.route(\"/generate_auth_token/<int:user_id>\")"
            },
            "1": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " @login_required"
            },
            "2": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " def generate_auth_token(user_id):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    warning = False"
            },
            "4": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     host_list = request.host.rsplit(':')"
            },
            "5": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     if len(host_list) == 1:"
            },
            "6": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         host = ':'.join(host_list)"
            },
            "7": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     else:"
            },
            "8": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         host = ':'.join(host_list[0:-1])"
            },
            "9": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):"
            },
            "10": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')"
            },
            "11": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return render_title_template("
            },
            "12": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"generate_kobo_auth_url.html\","
            },
            "13": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            title=_(u\"Kobo Setup\"),"
            },
            "14": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warning = warning"
            },
            "15": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "16": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "17": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Invalidate any prevously generated Kobo Auth token for this user."
            },
            "18": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        auth_token = ub.session.query(ub.RemoteAuthToken).filter("
            },
            "19": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ub.RemoteAuthToken.user_id == user_id"
            },
            "20": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ).filter(ub.RemoteAuthToken.token_type==1).first()"
            },
            "21": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "22": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not auth_token:"
            },
            "23": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_token = ub.RemoteAuthToken()"
            },
            "24": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_token.user_id = user_id"
            },
            "25": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_token.expiration = datetime.max"
            },
            "26": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")"
            },
            "27": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_token.token_type = 1"
            },
            "28": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "29": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ub.session.add(auth_token)"
            },
            "30": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ub.session_commit()"
            },
            "31": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "32": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        books = calibre_db.session.query(db.Books).join(db.Data).all()"
            },
            "33": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "34": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for book in books:"
            },
            "35": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            formats = [data.format for data in book.data]"
            },
            "36": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:"
            },
            "37": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)"
            },
            "38": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return render_title_template("
            },
            "40": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"generate_kobo_auth_url.html\","
            },
            "41": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            title=_(u\"Kobo Setup\"),"
            },
            "42": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kobo_auth_url=url_for("
            },
            "43": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True"
            },
            "44": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ),"
            },
            "45": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warning = False"
            },
            "46": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f') or host == \"[::1]\":"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        warning = _('Please access Calibre-Web from non localhost to get valid api_endpoint for kobo device')"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    # Generate auth token if none is existing for this user"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    auth_token = ub.session.query(ub.RemoteAuthToken).filter("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        ub.RemoteAuthToken.user_id == user_id"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    ).filter(ub.RemoteAuthToken.token_type==1).first()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    if not auth_token:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        auth_token = ub.RemoteAuthToken()"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        auth_token.user_id = user_id"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        auth_token.expiration = datetime.max"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        auth_token.token_type = 1"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        ub.session.add(auth_token)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        ub.session_commit()"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    books = calibre_db.session.query(db.Books).join(db.Data).all()"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    for book in books:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        formats = [data.format for data in book.data]"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    return render_title_template("
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        \"generate_kobo_auth_url.html\","
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        title=_(u\"Kobo Setup\"),"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        auth_token=auth_token.auth_token,"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        warning = warning"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    )"
            },
            "78": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " @kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])"
            },
            "81": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " @login_required"
            },
            "82": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " def delete_auth_token(user_id):"
            },
            "83": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Invalidate any prevously generated Kobo Auth token for this user."
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+    # Invalidate any previously generated Kobo Auth token for this user"
            },
            "85": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\"
            },
            "86": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         .filter(ub.RemoteAuthToken.token_type==1).delete()"
            },
            "87": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"This module is used to control authentication/authorization of Kobo sync requests.",
            "This module also includes research notes into the auth protocol used by Kobo devices.",
            "",
            "Log-in:",
            "When first booting a Kobo device the user must sign into a Kobo (or affiliate) account.",
            "Upon successful sign-in, the user is redirected to",
            "    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>",
            "which serves the following response:",
            "    <script type='text/javascript'>",
            "        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';",
            "    </script>",
            "And triggers the insertion of a userKey into the device's User table.",
            "",
            "Together, the device's DeviceId and UserKey act as an *irrevocable* authentication",
            "token to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is",
            "required to authorize the API call.",
            "",
            "Changing Kobo password *does not* invalidate user keys! This is apparently a known",
            "issue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13",
            "(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints",
            "will still grant access given the userkey.)",
            "",
            "Official Kobo Store Api authorization:",
            "* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is",
            "passed in the x-kobo-userkey header, and is sufficient to authorize the API call.",
            "* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through",
            "an authorization header. To get a BearerToken, the device makes a POST request to the",
            "v1/auth/device endpoint with the secret UserKey and the device's DeviceId.",
            "* The book download endpoint passes an auth token as a URL param instead of a header.",
            "",
            "Our implementation:",
            "We pretty much ignore all of the above. To authenticate the user, we generate a random",
            "and unique token that they append to the CalibreWeb Url when setting up the api_store",
            "setting on the device.",
            "Thus, every request from the device to the api_store will hit CalibreWeb with the",
            "auth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).",
            "In addition, once authenticated we also set the login cookie on the response that will",
            "be sent back for the duration of the session to authorize subsequent API calls (in",
            "particular calls to non-Kobo specific endpoints such as the CalibreWeb book download).",
            "\"\"\"",
            "",
            "from binascii import hexlify",
            "from datetime import datetime",
            "from os import urandom",
            "from functools import wraps",
            "",
            "from flask import g, Blueprint, url_for, abort, request",
            "from flask_login import login_user, current_user, login_required",
            "from flask_babel import gettext as _",
            "",
            "from . import logger, config, calibre_db, db, helper, ub, lm",
            "from .render_template import render_title_template",
            "",
            "",
            "log = logger.create()",
            "",
            "",
            "def register_url_value_preprocessor(kobo):",
            "    @kobo.url_value_preprocessor",
            "    # pylint: disable=unused-variable",
            "    def pop_auth_token(__, values):",
            "        g.auth_token = values.pop(\"auth_token\")",
            "",
            "",
            "def disable_failed_auth_redirect_for_blueprint(bp):",
            "    lm.blueprint_login_views[bp.name] = None",
            "",
            "",
            "def get_auth_token():",
            "    if \"auth_token\" in g:",
            "        return g.get(\"auth_token\")",
            "    else:",
            "        return None",
            "",
            "",
            "def requires_kobo_auth(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        auth_token = get_auth_token()",
            "        if auth_token is not None:",
            "            user = (",
            "                ub.session.query(ub.User)",
            "                .join(ub.RemoteAuthToken)",
            "                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
            "                .first()",
            "            )",
            "            if user is not None:",
            "                login_user(user)",
            "                return f(*args, **kwargs)",
            "            log.debug(\"Received Kobo request without a recognizable auth token.\")",
            "            return abort(401)",
            "    return inner",
            "",
            "",
            "kobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")",
            "",
            "",
            "@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")",
            "@login_required",
            "def generate_auth_token(user_id):",
            "    host_list = request.host.rsplit(':')",
            "    if len(host_list) == 1:",
            "        host = ':'.join(host_list)",
            "    else:",
            "        host = ':'.join(host_list[0:-1])",
            "    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):",
            "        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            warning = warning",
            "        )",
            "    else:",
            "        # Invalidate any prevously generated Kobo Auth token for this user.",
            "        auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
            "            ub.RemoteAuthToken.user_id == user_id",
            "        ).filter(ub.RemoteAuthToken.token_type==1).first()",
            "",
            "        if not auth_token:",
            "            auth_token = ub.RemoteAuthToken()",
            "            auth_token.user_id = user_id",
            "            auth_token.expiration = datetime.max",
            "            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
            "            auth_token.token_type = 1",
            "",
            "            ub.session.add(auth_token)",
            "            ub.session_commit()",
            "",
            "        books = calibre_db.session.query(db.Books).join(db.Data).all()",
            "",
            "        for book in books:",
            "            formats = [data.format for data in book.data]",
            "            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
            "                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
            "",
            "        return render_title_template(",
            "            \"generate_kobo_auth_url.html\",",
            "            title=_(u\"Kobo Setup\"),",
            "            kobo_auth_url=url_for(",
            "                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True",
            "            ),",
            "            warning = False",
            "        )",
            "",
            "",
            "@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_auth_token(user_id):",
            "    # Invalidate any prevously generated Kobo Auth token for this user.",
            "    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\",
            "        .filter(ub.RemoteAuthToken.token_type==1).delete()",
            "",
            "    return ub.session_commit()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "\"\"\"This module is used to control authentication/authorization of Kobo sync requests.",
            "This module also includes research notes into the auth protocol used by Kobo devices.",
            "",
            "Log-in:",
            "When first booting a Kobo device the user must sign into a Kobo (or affiliate) account.",
            "Upon successful sign-in, the user is redirected to",
            "    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>",
            "which serves the following response:",
            "    <script type='text/javascript'>",
            "        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';",
            "    </script>",
            "And triggers the insertion of a userKey into the device's User table.",
            "",
            "Together, the device's DeviceId and UserKey act as an *irrevocable* authentication",
            "token to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is",
            "required to authorize the API call.",
            "",
            "Changing Kobo password *does not* invalidate user keys! This is apparently a known",
            "issue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13",
            "(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints",
            "will still grant access given the userkey.)",
            "",
            "Official Kobo Store Api authorization:",
            "* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is",
            "passed in the x-kobo-userkey header, and is sufficient to authorize the API call.",
            "* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through",
            "an authorization header. To get a BearerToken, the device makes a POST request to the",
            "v1/auth/device endpoint with the secret UserKey and the device's DeviceId.",
            "* The book download endpoint passes an auth token as a URL param instead of a header.",
            "",
            "Our implementation:",
            "We pretty much ignore all of the above. To authenticate the user, we generate a random",
            "and unique token that they append to the CalibreWeb Url when setting up the api_store",
            "setting on the device.",
            "Thus, every request from the device to the api_store will hit CalibreWeb with the",
            "auth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).",
            "In addition, once authenticated we also set the login cookie on the response that will",
            "be sent back for the duration of the session to authorize subsequent API calls (in",
            "particular calls to non-Kobo specific endpoints such as the CalibreWeb book download).",
            "\"\"\"",
            "",
            "from binascii import hexlify",
            "from datetime import datetime",
            "from os import urandom",
            "from functools import wraps",
            "",
            "from flask import g, Blueprint, url_for, abort, request",
            "from flask_login import login_user, current_user, login_required",
            "from flask_babel import gettext as _",
            "",
            "from . import logger, config, calibre_db, db, helper, ub, lm",
            "from .render_template import render_title_template",
            "",
            "",
            "log = logger.create()",
            "",
            "",
            "def register_url_value_preprocessor(kobo):",
            "    @kobo.url_value_preprocessor",
            "    # pylint: disable=unused-variable",
            "    def pop_auth_token(__, values):",
            "        g.auth_token = values.pop(\"auth_token\")",
            "",
            "",
            "def disable_failed_auth_redirect_for_blueprint(bp):",
            "    lm.blueprint_login_views[bp.name] = None",
            "",
            "",
            "def get_auth_token():",
            "    if \"auth_token\" in g:",
            "        return g.get(\"auth_token\")",
            "    else:",
            "        return None",
            "",
            "",
            "def requires_kobo_auth(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        auth_token = get_auth_token()",
            "        if auth_token is not None:",
            "            user = (",
            "                ub.session.query(ub.User)",
            "                .join(ub.RemoteAuthToken)",
            "                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
            "                .first()",
            "            )",
            "            if user is not None:",
            "                login_user(user)",
            "                return f(*args, **kwargs)",
            "            log.debug(\"Received Kobo request without a recognizable auth token.\")",
            "            return abort(401)",
            "    return inner",
            "",
            "",
            "kobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")",
            "",
            "",
            "@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")",
            "@login_required",
            "def generate_auth_token(user_id):",
            "    warning = False",
            "    host_list = request.host.rsplit(':')",
            "    if len(host_list) == 1:",
            "        host = ':'.join(host_list)",
            "    else:",
            "        host = ':'.join(host_list[0:-1])",
            "    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f') or host == \"[::1]\":",
            "        warning = _('Please access Calibre-Web from non localhost to get valid api_endpoint for kobo device')",
            "",
            "    # Generate auth token if none is existing for this user",
            "    auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
            "        ub.RemoteAuthToken.user_id == user_id",
            "    ).filter(ub.RemoteAuthToken.token_type==1).first()",
            "",
            "    if not auth_token:",
            "        auth_token = ub.RemoteAuthToken()",
            "        auth_token.user_id = user_id",
            "        auth_token.expiration = datetime.max",
            "        auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
            "        auth_token.token_type = 1",
            "",
            "        ub.session.add(auth_token)",
            "        ub.session_commit()",
            "",
            "    books = calibre_db.session.query(db.Books).join(db.Data).all()",
            "",
            "    for book in books:",
            "        formats = [data.format for data in book.data]",
            "        if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
            "            helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
            "",
            "    return render_title_template(",
            "        \"generate_kobo_auth_url.html\",",
            "        title=_(u\"Kobo Setup\"),",
            "        auth_token=auth_token.auth_token,",
            "        warning = warning",
            "    )",
            "",
            "",
            "@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_auth_token(user_id):",
            "    # Invalidate any previously generated Kobo Auth token for this user",
            "    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\",
            "        .filter(ub.RemoteAuthToken.token_type==1).delete()",
            "",
            "    return ub.session_commit()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "126": [
                "generate_auth_token"
            ],
            "127": [
                "generate_auth_token"
            ],
            "128": [
                "generate_auth_token"
            ],
            "129": [
                "generate_auth_token"
            ],
            "130": [
                "generate_auth_token"
            ],
            "131": [
                "generate_auth_token"
            ],
            "132": [
                "generate_auth_token"
            ],
            "133": [
                "generate_auth_token"
            ],
            "134": [
                "generate_auth_token"
            ],
            "135": [
                "generate_auth_token"
            ],
            "136": [
                "generate_auth_token"
            ],
            "137": [
                "generate_auth_token"
            ],
            "138": [
                "generate_auth_token"
            ],
            "139": [
                "generate_auth_token"
            ],
            "140": [
                "generate_auth_token"
            ],
            "141": [
                "generate_auth_token"
            ],
            "142": [
                "generate_auth_token"
            ],
            "143": [
                "generate_auth_token"
            ],
            "144": [
                "generate_auth_token"
            ],
            "145": [
                "generate_auth_token"
            ],
            "146": [
                "generate_auth_token"
            ],
            "147": [
                "generate_auth_token"
            ],
            "148": [
                "generate_auth_token"
            ],
            "149": [
                "generate_auth_token"
            ],
            "150": [
                "generate_auth_token"
            ],
            "151": [
                "generate_auth_token"
            ],
            "152": [
                "generate_auth_token"
            ],
            "153": [
                "generate_auth_token"
            ],
            "154": [
                "generate_auth_token"
            ],
            "155": [
                "generate_auth_token"
            ],
            "156": [
                "generate_auth_token"
            ],
            "157": [
                "generate_auth_token"
            ],
            "158": [
                "generate_auth_token"
            ],
            "159": [
                "generate_auth_token"
            ],
            "160": [
                "generate_auth_token"
            ],
            "161": [
                "generate_auth_token"
            ],
            "162": [
                "generate_auth_token"
            ],
            "163": [
                "generate_auth_token"
            ],
            "169": [
                "delete_auth_token"
            ]
        },
        "addLocation": [
            "cps.admin"
        ]
    }
}