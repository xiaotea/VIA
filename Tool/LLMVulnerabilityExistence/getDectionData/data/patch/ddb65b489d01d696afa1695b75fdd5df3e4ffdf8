{
    "waitress/parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "             if not header:"
            },
            "1": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "                 raise ParsingError(\"Invalid header\")"
            },
            "2": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            key, value = header.group('name', 'value')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            key, value = header.group(\"name\", \"value\")"
            },
            "5": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             if b\"_\" in key:"
            },
            "7": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "                 # TODO(xistence): Should we drop this request instead?"
            },
            "8": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "                 continue"
            },
            "9": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value = value.strip()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            # Only strip off whitespace that is considered valid whitespace by"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            # RFC7230, don't strip the rest"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            value = value.strip(b\" \\t\")"
            },
            "14": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             key1 = tostr(key.upper().replace(b\"-\", b\"_\"))"
            },
            "15": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "             # If a header already exists, we append subsequent values"
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             # seperated by a comma. Applications already need to handle"
            },
            "17": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "             # here"
            },
            "18": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             te = headers.pop(\"TRANSFER_ENCODING\", \"\")"
            },
            "19": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            encodings = [encoding.strip().lower() for encoding in te.split(\",\") if encoding]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            # NB: We can not just call bare strip() here because it will also"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+            # remove other non-printable characters that we explicitly do not"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+            # want removed so that if someone attempts to smuggle a request"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+            # with these characters we don't fall prey to it."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            #"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            # For example \\x85 is stripped by default, but it is not considered"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+            # valid whitespace to be stripped by RFC7230."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            encodings = ["
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+                encoding.strip(\" \\t\").lower() for encoding in te.split(\",\") if encoding"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            ]"
            },
            "31": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "             for encoding in encodings:"
            },
            "33": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "                 # Out of the transfer-codings listed in"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser",
            "",
            "This server uses asyncore to accept connections and do initial",
            "processing but threads to do work.",
            "\"\"\"",
            "import re",
            "from io import BytesIO",
            "",
            "from waitress.buffers import OverflowableBuffer",
            "from waitress.compat import tostr, unquote_bytes_to_wsgi, urlparse",
            "from waitress.receiver import ChunkedReceiver, FixedStreamReceiver",
            "from waitress.utilities import (",
            "    BadRequest,",
            "    RequestEntityTooLarge,",
            "    RequestHeaderFieldsTooLarge,",
            "    ServerNotImplemented,",
            "    find_double_newline,",
            ")",
            "from .rfc7230 import HEADER_FIELD",
            "",
            "",
            "class ParsingError(Exception):",
            "    pass",
            "",
            "",
            "class TransferEncodingNotImplemented(Exception):",
            "    pass",
            "",
            "class HTTPRequestParser(object):",
            "    \"\"\"A structure that collects the HTTP request.",
            "",
            "    Once the stream is completed, the instance is passed to",
            "    a server task constructor.",
            "    \"\"\"",
            "",
            "    completed = False  # Set once request is completed.",
            "    empty = False  # Set if no request was made.",
            "    expect_continue = False  # client sent \"Expect: 100-continue\" header",
            "    headers_finished = False  # True when headers have been read",
            "    header_plus = b\"\"",
            "    chunked = False",
            "    content_length = 0",
            "    header_bytes_received = 0",
            "    body_bytes_received = 0",
            "    body_rcv = None",
            "    version = \"1.0\"",
            "    error = None",
            "    connection_close = False",
            "",
            "    # Other attributes: first_line, header, headers, command, uri, version,",
            "    # path, query, fragment",
            "",
            "    def __init__(self, adj):",
            "        \"\"\"",
            "        adj is an Adjustments object.",
            "        \"\"\"",
            "        # headers is a mapping containing keys translated to uppercase",
            "        # with dashes turned into underscores.",
            "        self.headers = {}",
            "        self.adj = adj",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives the HTTP stream for one request.  Returns the number of",
            "        bytes consumed.  Sets the completed flag once both the header and the",
            "        body have been received.",
            "        \"\"\"",
            "        if self.completed:",
            "            return 0  # Can't consume any more.",
            "",
            "        datalen = len(data)",
            "        br = self.body_rcv",
            "        if br is None:",
            "            # In header.",
            "            max_header = self.adj.max_request_header_size",
            "",
            "            s = self.header_plus + data",
            "            index = find_double_newline(s)",
            "            consumed = 0",
            "",
            "            if index >= 0:",
            "                # If the headers have ended, and we also have part of the body",
            "                # message in data we still want to validate we aren't going",
            "                # over our limit for received headers.",
            "                self.header_bytes_received += index",
            "                consumed = datalen - (len(s) - index)",
            "            else:",
            "                self.header_bytes_received += datalen",
            "                consumed = datalen",
            "",
            "            # If the first line + headers is over the max length, we return a",
            "            # RequestHeaderFieldsTooLarge error rather than continuing to",
            "            # attempt to parse the headers.",
            "            if self.header_bytes_received >= max_header:",
            "                self.parse_header(b\"GET / HTTP/1.0\\r\\n\")",
            "                self.error = RequestHeaderFieldsTooLarge(",
            "                    \"exceeds max_header of %s\" % max_header",
            "                )",
            "                self.completed = True",
            "                return consumed",
            "",
            "            if index >= 0:",
            "                # Header finished.",
            "                header_plus = s[:index]",
            "",
            "                # Remove preceeding blank lines. This is suggested by",
            "                # https://tools.ietf.org/html/rfc7230#section-3.5 to support",
            "                # clients sending an extra CR LF after another request when",
            "                # using HTTP pipelining",
            "                header_plus = header_plus.lstrip()",
            "",
            "                if not header_plus:",
            "                    self.empty = True",
            "                    self.completed = True",
            "                else:",
            "                    try:",
            "                        self.parse_header(header_plus)",
            "                    except ParsingError as e:",
            "                        self.error = BadRequest(e.args[0])",
            "                        self.completed = True",
            "                    except TransferEncodingNotImplemented as e:",
            "                        self.error = ServerNotImplemented(e.args[0])",
            "                        self.completed = True",
            "                    else:",
            "                        if self.body_rcv is None:",
            "                            # no content-length header and not a t-e: chunked",
            "                            # request",
            "                            self.completed = True",
            "",
            "                        if self.content_length > 0:",
            "                            max_body = self.adj.max_request_body_size",
            "                            # we won't accept this request if the content-length",
            "                            # is too large",
            "",
            "                            if self.content_length >= max_body:",
            "                                self.error = RequestEntityTooLarge(",
            "                                    \"exceeds max_body of %s\" % max_body",
            "                                )",
            "                                self.completed = True",
            "                self.headers_finished = True",
            "",
            "                return consumed",
            "",
            "            # Header not finished yet.",
            "            self.header_plus = s",
            "",
            "            return datalen",
            "        else:",
            "            # In body.",
            "            consumed = br.received(data)",
            "            self.body_bytes_received += consumed",
            "            max_body = self.adj.max_request_body_size",
            "",
            "            if self.body_bytes_received >= max_body:",
            "                # this will only be raised during t-e: chunked requests",
            "                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)",
            "                self.completed = True",
            "            elif br.error:",
            "                # garbage in chunked encoding input probably",
            "                self.error = br.error",
            "                self.completed = True",
            "            elif br.completed:",
            "                # The request (with the body) is ready to use.",
            "                self.completed = True",
            "",
            "                if self.chunked:",
            "                    # We've converted the chunked transfer encoding request",
            "                    # body into a normal request body, so we know its content",
            "                    # length; set the header here.  We already popped the",
            "                    # TRANSFER_ENCODING header in parse_header, so this will",
            "                    # appear to the client to be an entirely non-chunked HTTP",
            "                    # request with a valid content-length.",
            "                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())",
            "",
            "            return consumed",
            "",
            "    def parse_header(self, header_plus):",
            "        \"\"\"",
            "        Parses the header_plus block of text (the headers plus the",
            "        first line of the request).",
            "        \"\"\"",
            "        index = header_plus.find(b\"\\r\\n\")",
            "        if index >= 0:",
            "            first_line = header_plus[:index].rstrip()",
            "            header = header_plus[index + 2 :]",
            "        else:",
            "            raise ParsingError(\"HTTP message header invalid\")",
            "",
            "        if b\"\\r\" in first_line or b\"\\n\" in first_line:",
            "            raise ParsingError(\"Bare CR or LF found in HTTP message\")",
            "",
            "        self.first_line = first_line  # for testing",
            "",
            "        lines = get_header_lines(header)",
            "",
            "        headers = self.headers",
            "        for line in lines:",
            "            header = HEADER_FIELD.match(line)",
            "",
            "            if not header:",
            "                raise ParsingError(\"Invalid header\")",
            "",
            "            key, value = header.group('name', 'value')",
            "",
            "            if b\"_\" in key:",
            "                # TODO(xistence): Should we drop this request instead?",
            "                continue",
            "",
            "            value = value.strip()",
            "            key1 = tostr(key.upper().replace(b\"-\", b\"_\"))",
            "            # If a header already exists, we append subsequent values",
            "            # seperated by a comma. Applications already need to handle",
            "            # the comma seperated values, as HTTP front ends might do",
            "            # the concatenation for you (behavior specified in RFC2616).",
            "            try:",
            "                headers[key1] += tostr(b\", \" + value)",
            "            except KeyError:",
            "                headers[key1] = tostr(value)",
            "",
            "        # command, uri, version will be bytes",
            "        command, uri, version = crack_first_line(first_line)",
            "        version = tostr(version)",
            "        command = tostr(command)",
            "        self.command = command",
            "        self.version = version",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "        self.url_scheme = self.adj.url_scheme",
            "        connection = headers.get(\"CONNECTION\", \"\")",
            "",
            "        if version == \"1.0\":",
            "            if connection.lower() != \"keep-alive\":",
            "                self.connection_close = True",
            "",
            "        if version == \"1.1\":",
            "            # since the server buffers data from chunked transfers and clients",
            "            # never need to deal with chunked requests, downstream clients",
            "            # should not see the HTTP_TRANSFER_ENCODING header; we pop it",
            "            # here",
            "            te = headers.pop(\"TRANSFER_ENCODING\", \"\")",
            "",
            "            encodings = [encoding.strip().lower() for encoding in te.split(\",\") if encoding]",
            "",
            "            for encoding in encodings:",
            "                # Out of the transfer-codings listed in",
            "                # https://tools.ietf.org/html/rfc7230#section-4 we only support",
            "                # chunked at this time.",
            "",
            "                # Note: the identity transfer-coding was removed in RFC7230:",
            "                # https://tools.ietf.org/html/rfc7230#appendix-A.2 and is thus",
            "                # not supported",
            "                if encoding not in {\"chunked\"}:",
            "                    raise TransferEncodingNotImplemented(",
            "                        \"Transfer-Encoding requested is not supported.\"",
            "                    )",
            "",
            "            if encodings and encodings[-1] == \"chunked\":",
            "                self.chunked = True",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = ChunkedReceiver(buf)",
            "            elif encodings:  # pragma: nocover",
            "                raise TransferEncodingNotImplemented(",
            "                    \"Transfer-Encoding requested is not supported.\"",
            "                )",
            "",
            "            expect = headers.get(\"EXPECT\", \"\").lower()",
            "            self.expect_continue = expect == \"100-continue\"",
            "            if connection.lower() == \"close\":",
            "                self.connection_close = True",
            "",
            "        if not self.chunked:",
            "            try:",
            "                cl = int(headers.get(\"CONTENT_LENGTH\", 0))",
            "            except ValueError:",
            "                raise ParsingError(\"Content-Length is invalid\")",
            "",
            "            self.content_length = cl",
            "            if cl > 0:",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = FixedStreamReceiver(cl, buf)",
            "",
            "    def get_body_stream(self):",
            "        body_rcv = self.body_rcv",
            "        if body_rcv is not None:",
            "            return body_rcv.getfile()",
            "        else:",
            "            return BytesIO()",
            "",
            "    def close(self):",
            "        body_rcv = self.body_rcv",
            "        if body_rcv is not None:",
            "            body_rcv.getbuf().close()",
            "",
            "",
            "def split_uri(uri):",
            "    # urlsplit handles byte input by returning bytes on py3, so",
            "    # scheme, netloc, path, query, and fragment are bytes",
            "",
            "    scheme = netloc = path = query = fragment = b\"\"",
            "",
            "    # urlsplit below will treat this as a scheme-less netloc, thereby losing",
            "    # the original intent of the request. Here we shamelessly stole 4 lines of",
            "    # code from the CPython stdlib to parse out the fragment and query but",
            "    # leave the path alone. See",
            "    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468",
            "    # and https://github.com/Pylons/waitress/issues/260",
            "",
            "    if uri[:2] == b\"//\":",
            "        path = uri",
            "",
            "        if b\"#\" in path:",
            "            path, fragment = path.split(b\"#\", 1)",
            "",
            "        if b\"?\" in path:",
            "            path, query = path.split(b\"?\", 1)",
            "    else:",
            "        try:",
            "            scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)",
            "        except UnicodeError:",
            "            raise ParsingError(\"Bad URI\")",
            "",
            "    return (",
            "        tostr(scheme),",
            "        tostr(netloc),",
            "        unquote_bytes_to_wsgi(path),",
            "        tostr(query),",
            "        tostr(fragment),",
            "    )",
            "",
            "",
            "def get_header_lines(header):",
            "    \"\"\"",
            "    Splits the header into lines, putting multi-line headers together.",
            "    \"\"\"",
            "    r = []",
            "    lines = header.split(b\"\\r\\n\")",
            "    for line in lines:",
            "        if not line:",
            "            continue",
            "",
            "        if b\"\\r\" in line or b\"\\n\" in line:",
            "            raise ParsingError('Bare CR or LF found in header line \"%s\"' % tostr(line))",
            "",
            "        if line.startswith((b\" \", b\"\\t\")):",
            "            if not r:",
            "                # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "                raise ParsingError('Malformed header line \"%s\"' % tostr(line))",
            "            r[-1] += line",
            "        else:",
            "            r.append(line)",
            "    return r",
            "",
            "",
            "first_line_re = re.compile(",
            "    b\"([^ ]+) \"",
            "    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"",
            "    b\"(( HTTP/([0-9.]+))$|$)\"",
            ")",
            "",
            "",
            "def crack_first_line(line):",
            "    m = first_line_re.match(line)",
            "    if m is not None and m.end() == len(line):",
            "        if m.group(3):",
            "            version = m.group(5)",
            "        else:",
            "            version = b\"\"",
            "        method = m.group(1)",
            "",
            "        # the request methods that are currently defined are all uppercase:",
            "        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and",
            "        # the request method is case sensitive according to",
            "        # https://tools.ietf.org/html/rfc7231#section-4.1",
            "",
            "        # By disallowing anything but uppercase methods we save poor",
            "        # unsuspecting souls from sending lowercase HTTP methods to waitress",
            "        # and having the request complete, while servers like nginx drop the",
            "        # request onto the floor.",
            "        if method != method.upper():",
            "            raise ParsingError('Malformed HTTP method \"%s\"' % tostr(method))",
            "        uri = m.group(2)",
            "        return method, uri, version",
            "    else:",
            "        return b\"\", b\"\", b\"\""
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser",
            "",
            "This server uses asyncore to accept connections and do initial",
            "processing but threads to do work.",
            "\"\"\"",
            "import re",
            "from io import BytesIO",
            "",
            "from waitress.buffers import OverflowableBuffer",
            "from waitress.compat import tostr, unquote_bytes_to_wsgi, urlparse",
            "from waitress.receiver import ChunkedReceiver, FixedStreamReceiver",
            "from waitress.utilities import (",
            "    BadRequest,",
            "    RequestEntityTooLarge,",
            "    RequestHeaderFieldsTooLarge,",
            "    ServerNotImplemented,",
            "    find_double_newline,",
            ")",
            "from .rfc7230 import HEADER_FIELD",
            "",
            "",
            "class ParsingError(Exception):",
            "    pass",
            "",
            "",
            "class TransferEncodingNotImplemented(Exception):",
            "    pass",
            "",
            "class HTTPRequestParser(object):",
            "    \"\"\"A structure that collects the HTTP request.",
            "",
            "    Once the stream is completed, the instance is passed to",
            "    a server task constructor.",
            "    \"\"\"",
            "",
            "    completed = False  # Set once request is completed.",
            "    empty = False  # Set if no request was made.",
            "    expect_continue = False  # client sent \"Expect: 100-continue\" header",
            "    headers_finished = False  # True when headers have been read",
            "    header_plus = b\"\"",
            "    chunked = False",
            "    content_length = 0",
            "    header_bytes_received = 0",
            "    body_bytes_received = 0",
            "    body_rcv = None",
            "    version = \"1.0\"",
            "    error = None",
            "    connection_close = False",
            "",
            "    # Other attributes: first_line, header, headers, command, uri, version,",
            "    # path, query, fragment",
            "",
            "    def __init__(self, adj):",
            "        \"\"\"",
            "        adj is an Adjustments object.",
            "        \"\"\"",
            "        # headers is a mapping containing keys translated to uppercase",
            "        # with dashes turned into underscores.",
            "        self.headers = {}",
            "        self.adj = adj",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives the HTTP stream for one request.  Returns the number of",
            "        bytes consumed.  Sets the completed flag once both the header and the",
            "        body have been received.",
            "        \"\"\"",
            "        if self.completed:",
            "            return 0  # Can't consume any more.",
            "",
            "        datalen = len(data)",
            "        br = self.body_rcv",
            "        if br is None:",
            "            # In header.",
            "            max_header = self.adj.max_request_header_size",
            "",
            "            s = self.header_plus + data",
            "            index = find_double_newline(s)",
            "            consumed = 0",
            "",
            "            if index >= 0:",
            "                # If the headers have ended, and we also have part of the body",
            "                # message in data we still want to validate we aren't going",
            "                # over our limit for received headers.",
            "                self.header_bytes_received += index",
            "                consumed = datalen - (len(s) - index)",
            "            else:",
            "                self.header_bytes_received += datalen",
            "                consumed = datalen",
            "",
            "            # If the first line + headers is over the max length, we return a",
            "            # RequestHeaderFieldsTooLarge error rather than continuing to",
            "            # attempt to parse the headers.",
            "            if self.header_bytes_received >= max_header:",
            "                self.parse_header(b\"GET / HTTP/1.0\\r\\n\")",
            "                self.error = RequestHeaderFieldsTooLarge(",
            "                    \"exceeds max_header of %s\" % max_header",
            "                )",
            "                self.completed = True",
            "                return consumed",
            "",
            "            if index >= 0:",
            "                # Header finished.",
            "                header_plus = s[:index]",
            "",
            "                # Remove preceeding blank lines. This is suggested by",
            "                # https://tools.ietf.org/html/rfc7230#section-3.5 to support",
            "                # clients sending an extra CR LF after another request when",
            "                # using HTTP pipelining",
            "                header_plus = header_plus.lstrip()",
            "",
            "                if not header_plus:",
            "                    self.empty = True",
            "                    self.completed = True",
            "                else:",
            "                    try:",
            "                        self.parse_header(header_plus)",
            "                    except ParsingError as e:",
            "                        self.error = BadRequest(e.args[0])",
            "                        self.completed = True",
            "                    except TransferEncodingNotImplemented as e:",
            "                        self.error = ServerNotImplemented(e.args[0])",
            "                        self.completed = True",
            "                    else:",
            "                        if self.body_rcv is None:",
            "                            # no content-length header and not a t-e: chunked",
            "                            # request",
            "                            self.completed = True",
            "",
            "                        if self.content_length > 0:",
            "                            max_body = self.adj.max_request_body_size",
            "                            # we won't accept this request if the content-length",
            "                            # is too large",
            "",
            "                            if self.content_length >= max_body:",
            "                                self.error = RequestEntityTooLarge(",
            "                                    \"exceeds max_body of %s\" % max_body",
            "                                )",
            "                                self.completed = True",
            "                self.headers_finished = True",
            "",
            "                return consumed",
            "",
            "            # Header not finished yet.",
            "            self.header_plus = s",
            "",
            "            return datalen",
            "        else:",
            "            # In body.",
            "            consumed = br.received(data)",
            "            self.body_bytes_received += consumed",
            "            max_body = self.adj.max_request_body_size",
            "",
            "            if self.body_bytes_received >= max_body:",
            "                # this will only be raised during t-e: chunked requests",
            "                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)",
            "                self.completed = True",
            "            elif br.error:",
            "                # garbage in chunked encoding input probably",
            "                self.error = br.error",
            "                self.completed = True",
            "            elif br.completed:",
            "                # The request (with the body) is ready to use.",
            "                self.completed = True",
            "",
            "                if self.chunked:",
            "                    # We've converted the chunked transfer encoding request",
            "                    # body into a normal request body, so we know its content",
            "                    # length; set the header here.  We already popped the",
            "                    # TRANSFER_ENCODING header in parse_header, so this will",
            "                    # appear to the client to be an entirely non-chunked HTTP",
            "                    # request with a valid content-length.",
            "                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())",
            "",
            "            return consumed",
            "",
            "    def parse_header(self, header_plus):",
            "        \"\"\"",
            "        Parses the header_plus block of text (the headers plus the",
            "        first line of the request).",
            "        \"\"\"",
            "        index = header_plus.find(b\"\\r\\n\")",
            "        if index >= 0:",
            "            first_line = header_plus[:index].rstrip()",
            "            header = header_plus[index + 2 :]",
            "        else:",
            "            raise ParsingError(\"HTTP message header invalid\")",
            "",
            "        if b\"\\r\" in first_line or b\"\\n\" in first_line:",
            "            raise ParsingError(\"Bare CR or LF found in HTTP message\")",
            "",
            "        self.first_line = first_line  # for testing",
            "",
            "        lines = get_header_lines(header)",
            "",
            "        headers = self.headers",
            "        for line in lines:",
            "            header = HEADER_FIELD.match(line)",
            "",
            "            if not header:",
            "                raise ParsingError(\"Invalid header\")",
            "",
            "            key, value = header.group(\"name\", \"value\")",
            "",
            "            if b\"_\" in key:",
            "                # TODO(xistence): Should we drop this request instead?",
            "                continue",
            "",
            "            # Only strip off whitespace that is considered valid whitespace by",
            "            # RFC7230, don't strip the rest",
            "            value = value.strip(b\" \\t\")",
            "            key1 = tostr(key.upper().replace(b\"-\", b\"_\"))",
            "            # If a header already exists, we append subsequent values",
            "            # seperated by a comma. Applications already need to handle",
            "            # the comma seperated values, as HTTP front ends might do",
            "            # the concatenation for you (behavior specified in RFC2616).",
            "            try:",
            "                headers[key1] += tostr(b\", \" + value)",
            "            except KeyError:",
            "                headers[key1] = tostr(value)",
            "",
            "        # command, uri, version will be bytes",
            "        command, uri, version = crack_first_line(first_line)",
            "        version = tostr(version)",
            "        command = tostr(command)",
            "        self.command = command",
            "        self.version = version",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "        self.url_scheme = self.adj.url_scheme",
            "        connection = headers.get(\"CONNECTION\", \"\")",
            "",
            "        if version == \"1.0\":",
            "            if connection.lower() != \"keep-alive\":",
            "                self.connection_close = True",
            "",
            "        if version == \"1.1\":",
            "            # since the server buffers data from chunked transfers and clients",
            "            # never need to deal with chunked requests, downstream clients",
            "            # should not see the HTTP_TRANSFER_ENCODING header; we pop it",
            "            # here",
            "            te = headers.pop(\"TRANSFER_ENCODING\", \"\")",
            "",
            "            # NB: We can not just call bare strip() here because it will also",
            "            # remove other non-printable characters that we explicitly do not",
            "            # want removed so that if someone attempts to smuggle a request",
            "            # with these characters we don't fall prey to it.",
            "            #",
            "            # For example \\x85 is stripped by default, but it is not considered",
            "            # valid whitespace to be stripped by RFC7230.",
            "            encodings = [",
            "                encoding.strip(\" \\t\").lower() for encoding in te.split(\",\") if encoding",
            "            ]",
            "",
            "            for encoding in encodings:",
            "                # Out of the transfer-codings listed in",
            "                # https://tools.ietf.org/html/rfc7230#section-4 we only support",
            "                # chunked at this time.",
            "",
            "                # Note: the identity transfer-coding was removed in RFC7230:",
            "                # https://tools.ietf.org/html/rfc7230#appendix-A.2 and is thus",
            "                # not supported",
            "                if encoding not in {\"chunked\"}:",
            "                    raise TransferEncodingNotImplemented(",
            "                        \"Transfer-Encoding requested is not supported.\"",
            "                    )",
            "",
            "            if encodings and encodings[-1] == \"chunked\":",
            "                self.chunked = True",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = ChunkedReceiver(buf)",
            "            elif encodings:  # pragma: nocover",
            "                raise TransferEncodingNotImplemented(",
            "                    \"Transfer-Encoding requested is not supported.\"",
            "                )",
            "",
            "            expect = headers.get(\"EXPECT\", \"\").lower()",
            "            self.expect_continue = expect == \"100-continue\"",
            "            if connection.lower() == \"close\":",
            "                self.connection_close = True",
            "",
            "        if not self.chunked:",
            "            try:",
            "                cl = int(headers.get(\"CONTENT_LENGTH\", 0))",
            "            except ValueError:",
            "                raise ParsingError(\"Content-Length is invalid\")",
            "",
            "            self.content_length = cl",
            "            if cl > 0:",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = FixedStreamReceiver(cl, buf)",
            "",
            "    def get_body_stream(self):",
            "        body_rcv = self.body_rcv",
            "        if body_rcv is not None:",
            "            return body_rcv.getfile()",
            "        else:",
            "            return BytesIO()",
            "",
            "    def close(self):",
            "        body_rcv = self.body_rcv",
            "        if body_rcv is not None:",
            "            body_rcv.getbuf().close()",
            "",
            "",
            "def split_uri(uri):",
            "    # urlsplit handles byte input by returning bytes on py3, so",
            "    # scheme, netloc, path, query, and fragment are bytes",
            "",
            "    scheme = netloc = path = query = fragment = b\"\"",
            "",
            "    # urlsplit below will treat this as a scheme-less netloc, thereby losing",
            "    # the original intent of the request. Here we shamelessly stole 4 lines of",
            "    # code from the CPython stdlib to parse out the fragment and query but",
            "    # leave the path alone. See",
            "    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468",
            "    # and https://github.com/Pylons/waitress/issues/260",
            "",
            "    if uri[:2] == b\"//\":",
            "        path = uri",
            "",
            "        if b\"#\" in path:",
            "            path, fragment = path.split(b\"#\", 1)",
            "",
            "        if b\"?\" in path:",
            "            path, query = path.split(b\"?\", 1)",
            "    else:",
            "        try:",
            "            scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)",
            "        except UnicodeError:",
            "            raise ParsingError(\"Bad URI\")",
            "",
            "    return (",
            "        tostr(scheme),",
            "        tostr(netloc),",
            "        unquote_bytes_to_wsgi(path),",
            "        tostr(query),",
            "        tostr(fragment),",
            "    )",
            "",
            "",
            "def get_header_lines(header):",
            "    \"\"\"",
            "    Splits the header into lines, putting multi-line headers together.",
            "    \"\"\"",
            "    r = []",
            "    lines = header.split(b\"\\r\\n\")",
            "    for line in lines:",
            "        if not line:",
            "            continue",
            "",
            "        if b\"\\r\" in line or b\"\\n\" in line:",
            "            raise ParsingError('Bare CR or LF found in header line \"%s\"' % tostr(line))",
            "",
            "        if line.startswith((b\" \", b\"\\t\")):",
            "            if not r:",
            "                # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "                raise ParsingError('Malformed header line \"%s\"' % tostr(line))",
            "            r[-1] += line",
            "        else:",
            "            r.append(line)",
            "    return r",
            "",
            "",
            "first_line_re = re.compile(",
            "    b\"([^ ]+) \"",
            "    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"",
            "    b\"(( HTTP/([0-9.]+))$|$)\"",
            ")",
            "",
            "",
            "def crack_first_line(line):",
            "    m = first_line_re.match(line)",
            "    if m is not None and m.end() == len(line):",
            "        if m.group(3):",
            "            version = m.group(5)",
            "        else:",
            "            version = b\"\"",
            "        method = m.group(1)",
            "",
            "        # the request methods that are currently defined are all uppercase:",
            "        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and",
            "        # the request method is case sensitive according to",
            "        # https://tools.ietf.org/html/rfc7231#section-4.1",
            "",
            "        # By disallowing anything but uppercase methods we save poor",
            "        # unsuspecting souls from sending lowercase HTTP methods to waitress",
            "        # and having the request complete, while servers like nginx drop the",
            "        # request onto the floor.",
            "        if method != method.upper():",
            "            raise ParsingError('Malformed HTTP method \"%s\"' % tostr(method))",
            "        uri = m.group(2)",
            "        return method, uri, version",
            "    else:",
            "        return b\"\", b\"\", b\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "216": [
                "HTTPRequestParser",
                "parse_header"
            ],
            "222": [
                "HTTPRequestParser",
                "parse_header"
            ],
            "260": [
                "HTTPRequestParser",
                "parse_header"
            ]
        },
        "addLocation": []
    },
    "waitress/tests/test_parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         else:  # pragma: nocover"
            },
            "1": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "             self.assertTrue(False)"
            },
            "2": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+    def test_parse_header_transfer_encoding_invalid_whitespace(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+        from waitress.parser import TransferEncodingNotImplemented"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding:\\x85chunked\\r\\n\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+        try:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            self.parser.parse_header(data)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        except TransferEncodingNotImplemented as e:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        else:  # pragma: nocover"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+            self.assertTrue(False)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+    def test_parse_header_transfer_encoding_invalid_unicode(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        from waitress.parser import TransferEncodingNotImplemented"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        # This is the binary encoding for the UTF-8 character"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        # https://www.compart.com/en/unicode/U+212A \"unicode character \"K\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+        # which if waitress were to accidentally do the wrong thing get"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        # lowercased to just the ascii \"k\" due to unicode collisions during"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        # transformation"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding: chun\\xe2\\x84\\xaaed\\r\\n\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        try:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            self.parser.parse_header(data)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        except TransferEncodingNotImplemented as e:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        else:  # pragma: nocover"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            self.assertTrue(False)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "     def test_parse_header_11_expect_continue(self):"
            },
            "33": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\""
            },
            "34": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "         self.parser.parse_header(data)"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser tests",
            "\"\"\"",
            "import unittest",
            "",
            "from waitress.compat import text_, tobytes",
            "",
            "",
            "class TestHTTPRequestParser(unittest.TestCase):",
            "    def setUp(self):",
            "        from waitress.parser import HTTPRequestParser",
            "        from waitress.adjustments import Adjustments",
            "",
            "        my_adj = Adjustments()",
            "        self.parser = HTTPRequestParser(my_adj)",
            "",
            "    def test_get_body_stream_None(self):",
            "        self.parser.body_recv = None",
            "        result = self.parser.get_body_stream()",
            "        self.assertEqual(result.getvalue(), b\"\")",
            "",
            "    def test_get_body_stream_nonNone(self):",
            "        body_rcv = DummyBodyStream()",
            "        self.parser.body_rcv = body_rcv",
            "        result = self.parser.get_body_stream()",
            "        self.assertEqual(result, body_rcv)",
            "",
            "    def test_received_get_no_headers(self):",
            "        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 24)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_bad_host_header(self):",
            "        from waitress.utilities import BadRequest",
            "",
            "        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 36)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.error.__class__, BadRequest)",
            "",
            "    def test_received_bad_transfer_encoding(self):",
            "        from waitress.utilities import ServerNotImplemented",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: foo\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 48)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.error.__class__, ServerNotImplemented)",
            "",
            "    def test_received_nonsense_nothing(self):",
            "        data = b\"\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 4)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_no_doublecr(self):",
            "        data = b\"GET /foobar HTTP/8.4\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 22)",
            "        self.assertFalse(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_already_completed(self):",
            "        self.parser.completed = True",
            "        result = self.parser.received(b\"a\")",
            "        self.assertEqual(result, 0)",
            "",
            "    def test_received_cl_too_large(self):",
            "        from waitress.utilities import RequestEntityTooLarge",
            "",
            "        self.parser.adj.max_request_body_size = 2",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 44)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))",
            "",
            "    def test_received_headers_too_large(self):",
            "        from waitress.utilities import RequestHeaderFieldsTooLarge",
            "",
            "        self.parser.adj.max_request_header_size = 2",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 34)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))",
            "",
            "    def test_received_body_too_large(self):",
            "        from waitress.utilities import RequestEntityTooLarge",
            "",
            "        self.parser.adj.max_request_body_size = 2",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 62)",
            "        self.parser.received(data[result:])",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))",
            "",
            "    def test_received_error_from_parser(self):",
            "        from waitress.utilities import BadRequest",
            "",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"garbage\\r\\n\"",
            "        )",
            "        # header",
            "        result = self.parser.received(data)",
            "        # body",
            "        result = self.parser.received(data[result:])",
            "        self.assertEqual(result, 9)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, BadRequest))",
            "",
            "    def test_received_chunked_completed_sets_content_length(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 62)",
            "        data = data[result:]",
            "        result = self.parser.received(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(self.parser.error is None)",
            "        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")",
            "",
            "    def test_parse_header_gardenpath(self):",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")",
            "",
            "    def test_parse_header_no_cr_in_headerplus(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_bad_content_length(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Content-Length is invalid\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_multiple_content_length(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: 10\\r\\ncontent-length: 20\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Content-Length is invalid\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_11_te_chunked(self):",
            "        # NB: test that capitalization of header value is unimportant",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")",
            "",
            "",
            "    def test_parse_header_transfer_encoding_invalid(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_transfer_encoding_invalid_multiple(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\ntransfer-encoding: chunked\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_11_expect_continue(self):",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.expect_continue, True)",
            "",
            "    def test_parse_header_connection_close(self):",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.connection_close, True)",
            "",
            "    def test_close_with_body_rcv(self):",
            "        body_rcv = DummyBodyStream()",
            "        self.parser.body_rcv = body_rcv",
            "        self.parser.close()",
            "        self.assertTrue(body_rcv.closed)",
            "",
            "    def test_close_with_no_body_rcv(self):",
            "        self.parser.body_rcv = None",
            "        self.parser.close()  # doesn't raise",
            "",
            "    def test_parse_header_lf_only(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_cr_only(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_extra_lf_in_header(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_extra_lf_in_first_line(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_whitespace(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo : bar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_whitespace_vtab(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo:\\x0bbar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_no_colon(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nnotvalid\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_folding_spacing(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\t\\x0bbaz\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_chars(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\foo: \\x0bbaz\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_empty(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nempty:\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"EMPTY\", self.parser.headers)",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"EMPTY\"], \"\")",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")",
            "",
            "    def test_parse_header_multiple_values(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever, more, please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "    def test_parse_header_multiple_values_header_folded(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more, please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "    def test_parse_header_multiple_values_header_folded_multiple(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more\\r\\nfoo: please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "",
            "",
            "class Test_split_uri(unittest.TestCase):",
            "    def _callFUT(self, uri):",
            "        from waitress.parser import split_uri",
            "",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "",
            "    def test_split_uri_unquoting_unneeded(self):",
            "        self._callFUT(b\"http://localhost:8080/abc def\")",
            "        self.assertEqual(self.path, \"/abc def\")",
            "",
            "    def test_split_uri_unquoting_needed(self):",
            "        self._callFUT(b\"http://localhost:8080/abc%20def\")",
            "        self.assertEqual(self.path, \"/abc def\")",
            "",
            "    def test_split_url_with_query(self):",
            "        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")",
            "        self.assertEqual(self.path, \"/abc\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "",
            "    def test_split_url_with_query_empty(self):",
            "        self._callFUT(b\"http://localhost:8080/abc?\")",
            "        self.assertEqual(self.path, \"/abc\")",
            "        self.assertEqual(self.query, \"\")",
            "",
            "    def test_split_url_with_fragment(self):",
            "        self._callFUT(b\"http://localhost:8080/#foo\")",
            "        self.assertEqual(self.path, \"/\")",
            "        self.assertEqual(self.fragment, \"foo\")",
            "",
            "    def test_split_url_https(self):",
            "        self._callFUT(b\"https://localhost:8080/\")",
            "        self.assertEqual(self.path, \"/\")",
            "        self.assertEqual(self.proxy_scheme, \"https\")",
            "        self.assertEqual(self.proxy_netloc, \"localhost:8080\")",
            "",
            "    def test_split_uri_unicode_error_raises_parsing_error(self):",
            "        # See https://github.com/Pylons/waitress/issues/64",
            "        from waitress.parser import ParsingError",
            "",
            "        # Either pass or throw a ParsingError, just don't throw another type of",
            "        # exception as that will cause the connection to close badly:",
            "        try:",
            "            self._callFUT(b\"/\\xd0\")",
            "        except ParsingError:",
            "            pass",
            "",
            "    def test_split_uri_path(self):",
            "        self._callFUT(b\"//testing/whatever\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"\")",
            "        self.assertEqual(self.fragment, \"\")",
            "",
            "    def test_split_uri_path_query(self):",
            "        self._callFUT(b\"//testing/whatever?a=1&b=2\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "        self.assertEqual(self.fragment, \"\")",
            "",
            "    def test_split_uri_path_query_fragment(self):",
            "        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "        self.assertEqual(self.fragment, \"fragment\")",
            "",
            "",
            "class Test_get_header_lines(unittest.TestCase):",
            "    def _callFUT(self, data):",
            "        from waitress.parser import get_header_lines",
            "",
            "        return get_header_lines(data)",
            "",
            "    def test_get_header_lines(self):",
            "        result = self._callFUT(b\"slam\\r\\nslim\")",
            "        self.assertEqual(result, [b\"slam\", b\"slim\"])",
            "",
            "    def test_get_header_lines_folded(self):",
            "        # From RFC2616:",
            "        # HTTP/1.1 header field values can be folded onto multiple lines if the",
            "        # continuation line begins with a space or horizontal tab. All linear",
            "        # white space, including folding, has the same semantics as SP. A",
            "        # recipient MAY replace any linear white space with a single SP before",
            "        # interpreting the field value or forwarding the message downstream.",
            "",
            "        # We are just preserving the whitespace that indicates folding.",
            "        result = self._callFUT(b\"slim\\r\\n slam\")",
            "        self.assertEqual(result, [b\"slim slam\"])",
            "",
            "    def test_get_header_lines_tabbed(self):",
            "        result = self._callFUT(b\"slam\\r\\n\\tslim\")",
            "        self.assertEqual(result, [b\"slam\\tslim\"])",
            "",
            "    def test_get_header_lines_malformed(self):",
            "        # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "        from waitress.parser import ParsingError",
            "",
            "        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")",
            "",
            "",
            "class Test_crack_first_line(unittest.TestCase):",
            "    def _callFUT(self, line):",
            "        from waitress.parser import crack_first_line",
            "",
            "        return crack_first_line(line)",
            "",
            "    def test_crack_first_line_matchok(self):",
            "        result = self._callFUT(b\"GET / HTTP/1.0\")",
            "        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))",
            "",
            "    def test_crack_first_line_lowercase_method(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")",
            "",
            "    def test_crack_first_line_nomatch(self):",
            "        result = self._callFUT(b\"GET / bleh\")",
            "        self.assertEqual(result, (b\"\", b\"\", b\"\"))",
            "",
            "        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")",
            "        self.assertEqual(result, (b\"\", b\"\", b\"\"))",
            "",
            "    def test_crack_first_line_missing_version(self):",
            "        result = self._callFUT(b\"GET /\")",
            "        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))",
            "",
            "",
            "class TestHTTPRequestParserIntegration(unittest.TestCase):",
            "    def setUp(self):",
            "        from waitress.parser import HTTPRequestParser",
            "        from waitress.adjustments import Adjustments",
            "",
            "        my_adj = Adjustments()",
            "        self.parser = HTTPRequestParser(my_adj)",
            "",
            "    def feed(self, data):",
            "        parser = self.parser",
            "",
            "        for n in range(100):  # make sure we never loop forever",
            "            consumed = parser.received(data)",
            "            data = data[consumed:]",
            "",
            "            if parser.completed:",
            "                return",
            "        raise ValueError(\"Looping\")  # pragma: no cover",
            "",
            "    def testSimpleGET(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"FirstName: mickey\\r\\n\"",
            "            b\"lastname: Mouse\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertTrue(parser.completed)",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(",
            "            parser.headers,",
            "            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},",
            "        )",
            "        self.assertEqual(parser.path, \"/foobar\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.query, \"\")",
            "        self.assertEqual(parser.proxy_scheme, \"\")",
            "        self.assertEqual(parser.proxy_netloc, \"\")",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")",
            "",
            "    def testComplexGET(self):",
            "        data = (",
            "            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"",
            "            b\"FirstName: mickey\\r\\n\"",
            "            b\"lastname: Mouse\\r\\n\"",
            "            b\"content-length: 10\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello mickey.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(",
            "            parser.headers,",
            "            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},",
            "        )",
            "        # path should be utf-8 encoded",
            "        self.assertEqual(",
            "            tobytes(parser.path).decode(\"utf-8\"),",
            "            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),",
            "        )",
            "        self.assertEqual(",
            "            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"",
            "        )",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")",
            "",
            "    def testProxyGET(self):",
            "        data = (",
            "            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertTrue(parser.completed)",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})",
            "        self.assertEqual(parser.path, \"/foobar\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.proxy_scheme, \"https\")",
            "        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.query, \"\")",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")",
            "",
            "    def testDuplicateHeaders(self):",
            "        # Ensure that headers with the same key get concatenated as per",
            "        # RFC2616.",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"x-forwarded-for: 10.11.12.13\\r\\n\"",
            "            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"",
            "            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        self.feed(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(",
            "            self.parser.headers,",
            "            {",
            "                \"CONTENT_LENGTH\": \"6\",",
            "                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",",
            "            },",
            "        )",
            "",
            "    def testSpoofedHeadersDropped(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"x-auth_user: bob\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        self.feed(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})",
            "",
            "",
            "class DummyBodyStream(object):",
            "    def getfile(self):",
            "        return self",
            "",
            "    def getbuf(self):",
            "        return self",
            "",
            "    def close(self):",
            "        self.closed = True"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser tests",
            "\"\"\"",
            "import unittest",
            "",
            "from waitress.compat import text_, tobytes",
            "",
            "",
            "class TestHTTPRequestParser(unittest.TestCase):",
            "    def setUp(self):",
            "        from waitress.parser import HTTPRequestParser",
            "        from waitress.adjustments import Adjustments",
            "",
            "        my_adj = Adjustments()",
            "        self.parser = HTTPRequestParser(my_adj)",
            "",
            "    def test_get_body_stream_None(self):",
            "        self.parser.body_recv = None",
            "        result = self.parser.get_body_stream()",
            "        self.assertEqual(result.getvalue(), b\"\")",
            "",
            "    def test_get_body_stream_nonNone(self):",
            "        body_rcv = DummyBodyStream()",
            "        self.parser.body_rcv = body_rcv",
            "        result = self.parser.get_body_stream()",
            "        self.assertEqual(result, body_rcv)",
            "",
            "    def test_received_get_no_headers(self):",
            "        data = b\"HTTP/1.0 GET /foobar\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 24)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_bad_host_header(self):",
            "        from waitress.utilities import BadRequest",
            "",
            "        data = b\"HTTP/1.0 GET /foobar\\r\\n Host: foo\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 36)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.error.__class__, BadRequest)",
            "",
            "    def test_received_bad_transfer_encoding(self):",
            "        from waitress.utilities import ServerNotImplemented",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: foo\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 48)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.error.__class__, ServerNotImplemented)",
            "",
            "    def test_received_nonsense_nothing(self):",
            "        data = b\"\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 4)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_no_doublecr(self):",
            "        data = b\"GET /foobar HTTP/8.4\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 22)",
            "        self.assertFalse(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {})",
            "",
            "    def test_received_already_completed(self):",
            "        self.parser.completed = True",
            "        result = self.parser.received(b\"a\")",
            "        self.assertEqual(result, 0)",
            "",
            "    def test_received_cl_too_large(self):",
            "        from waitress.utilities import RequestEntityTooLarge",
            "",
            "        self.parser.adj.max_request_body_size = 2",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nContent-Length: 10\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 44)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))",
            "",
            "    def test_received_headers_too_large(self):",
            "        from waitress.utilities import RequestHeaderFieldsTooLarge",
            "",
            "        self.parser.adj.max_request_header_size = 2",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nX-Foo: 1\\r\\n\\r\\n\"",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 34)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestHeaderFieldsTooLarge))",
            "",
            "    def test_received_body_too_large(self):",
            "        from waitress.utilities import RequestEntityTooLarge",
            "",
            "        self.parser.adj.max_request_body_size = 2",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 62)",
            "        self.parser.received(data[result:])",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, RequestEntityTooLarge))",
            "",
            "    def test_received_error_from_parser(self):",
            "        from waitress.utilities import BadRequest",
            "",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"garbage\\r\\n\"",
            "        )",
            "        # header",
            "        result = self.parser.received(data)",
            "        # body",
            "        result = self.parser.received(data[result:])",
            "        self.assertEqual(result, 9)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(isinstance(self.parser.error, BadRequest))",
            "",
            "    def test_received_chunked_completed_sets_content_length(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/1.1\\r\\n\"",
            "            b\"Transfer-Encoding: chunked\\r\\n\"",
            "            b\"X-Foo: 1\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"1d;\\r\\n\"",
            "            b\"This string has 29 characters\\r\\n\"",
            "            b\"0\\r\\n\\r\\n\"",
            "        )",
            "        result = self.parser.received(data)",
            "        self.assertEqual(result, 62)",
            "        data = data[result:]",
            "        result = self.parser.received(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertTrue(self.parser.error is None)",
            "        self.assertEqual(self.parser.headers[\"CONTENT_LENGTH\"], \"29\")",
            "",
            "    def test_parse_header_gardenpath(self):",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: bar\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.first_line, b\"GET /foobar HTTP/8.4\")",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")",
            "",
            "    def test_parse_header_no_cr_in_headerplus(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_bad_content_length(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: abc\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Content-Length is invalid\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_multiple_content_length(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\ncontent-length: 10\\r\\ncontent-length: 20\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Content-Length is invalid\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_11_te_chunked(self):",
            "        # NB: test that capitalization of header value is unimportant",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: ChUnKed\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.body_rcv.__class__.__name__, \"ChunkedReceiver\")",
            "",
            "",
            "    def test_parse_header_transfer_encoding_invalid(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_transfer_encoding_invalid_multiple(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\ntransfer-encoding: gzip\\r\\ntransfer-encoding: chunked\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_transfer_encoding_invalid_whitespace(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding:\\x85chunked\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_transfer_encoding_invalid_unicode(self):",
            "        from waitress.parser import TransferEncodingNotImplemented",
            "",
            "        # This is the binary encoding for the UTF-8 character",
            "        # https://www.compart.com/en/unicode/U+212A \"unicode character \"K\"\"",
            "        # which if waitress were to accidentally do the wrong thing get",
            "        # lowercased to just the ascii \"k\" due to unicode collisions during",
            "        # transformation",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nTransfer-Encoding: chun\\xe2\\x84\\xaaed\\r\\n\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except TransferEncodingNotImplemented as e:",
            "            self.assertIn(\"Transfer-Encoding requested is not supported.\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_11_expect_continue(self):",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nexpect: 100-continue\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.expect_continue, True)",
            "",
            "    def test_parse_header_connection_close(self):",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nConnection: close\\r\\n\"",
            "        self.parser.parse_header(data)",
            "        self.assertEqual(self.parser.connection_close, True)",
            "",
            "    def test_close_with_body_rcv(self):",
            "        body_rcv = DummyBodyStream()",
            "        self.parser.body_rcv = body_rcv",
            "        self.parser.close()",
            "        self.assertTrue(body_rcv.closed)",
            "",
            "    def test_close_with_no_body_rcv(self):",
            "        self.parser.body_rcv = None",
            "        self.parser.close()  # doesn't raise",
            "",
            "    def test_parse_header_lf_only(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\nfoo: bar\"",
            "",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_cr_only(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\rfoo: bar\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError:",
            "            pass",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_extra_lf_in_header(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo: \\nbar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Bare CR or LF found in header line\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_extra_lf_in_first_line(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar\\n HTTP/8.4\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Bare CR or LF found in HTTP message\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_whitespace(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/8.4\\r\\nfoo : bar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_whitespace_vtab(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo:\\x0bbar\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_no_colon(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nnotvalid\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_folding_spacing(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\t\\x0bbaz\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_invalid_chars(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\n\\foo: \\x0bbaz\\r\\n\"",
            "        try:",
            "            self.parser.parse_header(data)",
            "        except ParsingError as e:",
            "            self.assertIn(\"Invalid header\", e.args[0])",
            "        else:  # pragma: nocover",
            "            self.assertTrue(False)",
            "",
            "    def test_parse_header_empty(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar\\r\\nempty:\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"EMPTY\", self.parser.headers)",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"EMPTY\"], \"\")",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar\")",
            "",
            "    def test_parse_header_multiple_values(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever, more, please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "    def test_parse_header_multiple_values_header_folded(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more, please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "    def test_parse_header_multiple_values_header_folded_multiple(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        data = b\"GET /foobar HTTP/1.1\\r\\nfoo: bar, whatever,\\r\\n more\\r\\nfoo: please, yes\\r\\n\"",
            "        self.parser.parse_header(data)",
            "",
            "        self.assertIn(\"FOO\", self.parser.headers)",
            "        self.assertEqual(self.parser.headers[\"FOO\"], \"bar, whatever, more, please, yes\")",
            "",
            "",
            "",
            "class Test_split_uri(unittest.TestCase):",
            "    def _callFUT(self, uri):",
            "        from waitress.parser import split_uri",
            "",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "",
            "    def test_split_uri_unquoting_unneeded(self):",
            "        self._callFUT(b\"http://localhost:8080/abc def\")",
            "        self.assertEqual(self.path, \"/abc def\")",
            "",
            "    def test_split_uri_unquoting_needed(self):",
            "        self._callFUT(b\"http://localhost:8080/abc%20def\")",
            "        self.assertEqual(self.path, \"/abc def\")",
            "",
            "    def test_split_url_with_query(self):",
            "        self._callFUT(b\"http://localhost:8080/abc?a=1&b=2\")",
            "        self.assertEqual(self.path, \"/abc\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "",
            "    def test_split_url_with_query_empty(self):",
            "        self._callFUT(b\"http://localhost:8080/abc?\")",
            "        self.assertEqual(self.path, \"/abc\")",
            "        self.assertEqual(self.query, \"\")",
            "",
            "    def test_split_url_with_fragment(self):",
            "        self._callFUT(b\"http://localhost:8080/#foo\")",
            "        self.assertEqual(self.path, \"/\")",
            "        self.assertEqual(self.fragment, \"foo\")",
            "",
            "    def test_split_url_https(self):",
            "        self._callFUT(b\"https://localhost:8080/\")",
            "        self.assertEqual(self.path, \"/\")",
            "        self.assertEqual(self.proxy_scheme, \"https\")",
            "        self.assertEqual(self.proxy_netloc, \"localhost:8080\")",
            "",
            "    def test_split_uri_unicode_error_raises_parsing_error(self):",
            "        # See https://github.com/Pylons/waitress/issues/64",
            "        from waitress.parser import ParsingError",
            "",
            "        # Either pass or throw a ParsingError, just don't throw another type of",
            "        # exception as that will cause the connection to close badly:",
            "        try:",
            "            self._callFUT(b\"/\\xd0\")",
            "        except ParsingError:",
            "            pass",
            "",
            "    def test_split_uri_path(self):",
            "        self._callFUT(b\"//testing/whatever\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"\")",
            "        self.assertEqual(self.fragment, \"\")",
            "",
            "    def test_split_uri_path_query(self):",
            "        self._callFUT(b\"//testing/whatever?a=1&b=2\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "        self.assertEqual(self.fragment, \"\")",
            "",
            "    def test_split_uri_path_query_fragment(self):",
            "        self._callFUT(b\"//testing/whatever?a=1&b=2#fragment\")",
            "        self.assertEqual(self.path, \"//testing/whatever\")",
            "        self.assertEqual(self.proxy_scheme, \"\")",
            "        self.assertEqual(self.proxy_netloc, \"\")",
            "        self.assertEqual(self.query, \"a=1&b=2\")",
            "        self.assertEqual(self.fragment, \"fragment\")",
            "",
            "",
            "class Test_get_header_lines(unittest.TestCase):",
            "    def _callFUT(self, data):",
            "        from waitress.parser import get_header_lines",
            "",
            "        return get_header_lines(data)",
            "",
            "    def test_get_header_lines(self):",
            "        result = self._callFUT(b\"slam\\r\\nslim\")",
            "        self.assertEqual(result, [b\"slam\", b\"slim\"])",
            "",
            "    def test_get_header_lines_folded(self):",
            "        # From RFC2616:",
            "        # HTTP/1.1 header field values can be folded onto multiple lines if the",
            "        # continuation line begins with a space or horizontal tab. All linear",
            "        # white space, including folding, has the same semantics as SP. A",
            "        # recipient MAY replace any linear white space with a single SP before",
            "        # interpreting the field value or forwarding the message downstream.",
            "",
            "        # We are just preserving the whitespace that indicates folding.",
            "        result = self._callFUT(b\"slim\\r\\n slam\")",
            "        self.assertEqual(result, [b\"slim slam\"])",
            "",
            "    def test_get_header_lines_tabbed(self):",
            "        result = self._callFUT(b\"slam\\r\\n\\tslim\")",
            "        self.assertEqual(result, [b\"slam\\tslim\"])",
            "",
            "    def test_get_header_lines_malformed(self):",
            "        # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "        from waitress.parser import ParsingError",
            "",
            "        self.assertRaises(ParsingError, self._callFUT, b\" Host: localhost\\r\\n\\r\\n\")",
            "",
            "",
            "class Test_crack_first_line(unittest.TestCase):",
            "    def _callFUT(self, line):",
            "        from waitress.parser import crack_first_line",
            "",
            "        return crack_first_line(line)",
            "",
            "    def test_crack_first_line_matchok(self):",
            "        result = self._callFUT(b\"GET / HTTP/1.0\")",
            "        self.assertEqual(result, (b\"GET\", b\"/\", b\"1.0\"))",
            "",
            "    def test_crack_first_line_lowercase_method(self):",
            "        from waitress.parser import ParsingError",
            "",
            "        self.assertRaises(ParsingError, self._callFUT, b\"get / HTTP/1.0\")",
            "",
            "    def test_crack_first_line_nomatch(self):",
            "        result = self._callFUT(b\"GET / bleh\")",
            "        self.assertEqual(result, (b\"\", b\"\", b\"\"))",
            "",
            "        result = self._callFUT(b\"GET /info?txtAirPlay&txtRAOP RTSP/1.0\")",
            "        self.assertEqual(result, (b\"\", b\"\", b\"\"))",
            "",
            "    def test_crack_first_line_missing_version(self):",
            "        result = self._callFUT(b\"GET /\")",
            "        self.assertEqual(result, (b\"GET\", b\"/\", b\"\"))",
            "",
            "",
            "class TestHTTPRequestParserIntegration(unittest.TestCase):",
            "    def setUp(self):",
            "        from waitress.parser import HTTPRequestParser",
            "        from waitress.adjustments import Adjustments",
            "",
            "        my_adj = Adjustments()",
            "        self.parser = HTTPRequestParser(my_adj)",
            "",
            "    def feed(self, data):",
            "        parser = self.parser",
            "",
            "        for n in range(100):  # make sure we never loop forever",
            "            consumed = parser.received(data)",
            "            data = data[consumed:]",
            "",
            "            if parser.completed:",
            "                return",
            "        raise ValueError(\"Looping\")  # pragma: no cover",
            "",
            "    def testSimpleGET(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"FirstName: mickey\\r\\n\"",
            "            b\"lastname: Mouse\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertTrue(parser.completed)",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(",
            "            parser.headers,",
            "            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"6\",},",
            "        )",
            "        self.assertEqual(parser.path, \"/foobar\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.query, \"\")",
            "        self.assertEqual(parser.proxy_scheme, \"\")",
            "        self.assertEqual(parser.proxy_netloc, \"\")",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")",
            "",
            "    def testComplexGET(self):",
            "        data = (",
            "            b\"GET /foo/a+%2B%2F%C3%A4%3D%26a%3Aint?d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6 HTTP/8.4\\r\\n\"",
            "            b\"FirstName: mickey\\r\\n\"",
            "            b\"lastname: Mouse\\r\\n\"",
            "            b\"content-length: 10\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello mickey.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(",
            "            parser.headers,",
            "            {\"FIRSTNAME\": \"mickey\", \"LASTNAME\": \"Mouse\", \"CONTENT_LENGTH\": \"10\"},",
            "        )",
            "        # path should be utf-8 encoded",
            "        self.assertEqual(",
            "            tobytes(parser.path).decode(\"utf-8\"),",
            "            text_(b\"/foo/a++/\\xc3\\xa4=&a:int\", \"utf-8\"),",
            "        )",
            "        self.assertEqual(",
            "            parser.query, \"d=b+%2B%2F%3D%26b%3Aint&c+%2B%2F%3D%26c%3Aint=6\"",
            "        )",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello mick\")",
            "",
            "    def testProxyGET(self):",
            "        data = (",
            "            b\"GET https://example.com:8080/foobar HTTP/8.4\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        parser = self.parser",
            "        self.feed(data)",
            "        self.assertTrue(parser.completed)",
            "        self.assertEqual(parser.version, \"8.4\")",
            "        self.assertFalse(parser.empty)",
            "        self.assertEqual(parser.headers, {\"CONTENT_LENGTH\": \"6\"})",
            "        self.assertEqual(parser.path, \"/foobar\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.proxy_scheme, \"https\")",
            "        self.assertEqual(parser.proxy_netloc, \"example.com:8080\")",
            "        self.assertEqual(parser.command, \"GET\")",
            "        self.assertEqual(parser.query, \"\")",
            "        self.assertEqual(parser.get_body_stream().getvalue(), b\"Hello.\")",
            "",
            "    def testDuplicateHeaders(self):",
            "        # Ensure that headers with the same key get concatenated as per",
            "        # RFC2616.",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"x-forwarded-for: 10.11.12.13\\r\\n\"",
            "            b\"x-forwarded-for: unknown,127.0.0.1\\r\\n\"",
            "            b\"X-Forwarded_for: 255.255.255.255\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        self.feed(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(",
            "            self.parser.headers,",
            "            {",
            "                \"CONTENT_LENGTH\": \"6\",",
            "                \"X_FORWARDED_FOR\": \"10.11.12.13, unknown,127.0.0.1\",",
            "            },",
            "        )",
            "",
            "    def testSpoofedHeadersDropped(self):",
            "        data = (",
            "            b\"GET /foobar HTTP/8.4\\r\\n\"",
            "            b\"x-auth_user: bob\\r\\n\"",
            "            b\"content-length: 6\\r\\n\"",
            "            b\"\\r\\n\"",
            "            b\"Hello.\"",
            "        )",
            "        self.feed(data)",
            "        self.assertTrue(self.parser.completed)",
            "        self.assertEqual(self.parser.headers, {\"CONTENT_LENGTH\": \"6\",})",
            "",
            "",
            "class DummyBodyStream(object):",
            "    def getfile(self):",
            "        return self",
            "",
            "    def getbuf(self):",
            "        return self",
            "",
            "    def close(self):",
            "        self.closed = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes",
            "waitress.tests.test_parser.TestHTTPRequestParser.self"
        ]
    }
}