{
    "src/priority/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from .priority import (  # noqa"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": "     Stream, PriorityTree, DeadlockError, PriorityLoop, DuplicateStreamError,"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    MissingStreamError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+    MissingStreamError, TooManyStreamsError"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " )"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "priority: HTTP/2 priority implementation for Python",
            "\"\"\"",
            "from .priority import (  # noqa",
            "    Stream, PriorityTree, DeadlockError, PriorityLoop, DuplicateStreamError,",
            "    MissingStreamError",
            ")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "priority: HTTP/2 priority implementation for Python",
            "\"\"\"",
            "from .priority import (  # noqa",
            "    Stream, PriorityTree, DeadlockError, PriorityLoop, DuplicateStreamError,",
            "    MissingStreamError, TooManyStreamsError",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "7": []
        },
        "addLocation": []
    },
    "src/priority/priority.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     pass"
            },
            "1": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+class TooManyStreamsError(Exception):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    An attempt was made to insert a dangerous number of streams into the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    priority tree at the same time."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    .. versionadded:: 1.2.0"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    pass"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " class Stream(object):"
            },
            "14": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     Priority information for a given stream."
            },
            "16": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "     A HTTP/2 Priority Tree."
            },
            "17": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     This tree stores HTTP/2 streams according to their HTTP/2 priorities."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+    .. versionchanged:: 1.2.0"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+       Added ``maximum_streams`` keyword argument."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+    :param maximum_streams: The maximum number of streams that may be active in"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        the priority tree at any one time. If this number is exceeded, the"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        priority tree will raise a :class:`TooManyStreamsError"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        <priority.TooManyStreamsError>` and will refuse to insert the stream."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        This parameter exists to defend against the possibility of DoS attack"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        by attempting to overfill the priority tree. If any endpoint is"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        attempting to manage the priority of this many streams at once it is"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        probably trying to screw with you, so it is sensible to simply refuse"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        to play ball at that point."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        While we allow the user to configure this, we don't really *expect*"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        them too, unless they want to be even more conservative than we are by"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        default."
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+    :type maximum_streams: ``int``"
            },
            "38": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "     \"\"\""
            },
            "39": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    def __init__(self, maximum_streams=1000):"
            },
            "41": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         # This flat array keeps hold of all the streams that are logically"
            },
            "42": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         # dependent on stream 0."
            },
            "43": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         self._root_stream = Stream(stream_id=0, weight=1)"
            },
            "44": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         self._root_stream.active = False"
            },
            "45": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         self._streams = {0: self._root_stream}"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        self._maximum_streams = maximum_streams"
            },
            "47": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "     def _exclusive_insert(self, parent_stream, inserted_stream):"
            },
            "49": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         \"\"\""
            },
            "50": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "         if stream_id in self._streams:"
            },
            "51": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "             raise DuplicateStreamError(\"Stream %d already in tree\" % stream_id)"
            },
            "52": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        if (len(self._streams) + 1) > self._maximum_streams:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            raise TooManyStreamsError("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+                \"Refusing to insert %d streams into priority tree at once\" % ("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+                    self._maximum_streams + 1"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+                )"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            )"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         stream = Stream(stream_id, weight)"
            },
            "61": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 274,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "         if exclusive:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "priority/tree",
            "~~~~~~~~~~~~~",
            "",
            "Implementation of the Priority tree data structure.",
            "\"\"\"",
            "from __future__ import division",
            "",
            "import heapq",
            "import sys",
            "",
            "",
            "PY3 = sys.version_info[0] == 3",
            "",
            "",
            "class DeadlockError(Exception):",
            "    \"\"\"",
            "    Raised when there are no streams that can make progress: all streams are",
            "    blocked.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class PriorityLoop(Exception):",
            "    \"\"\"",
            "    An unexpected priority loop has been detected. The tree is invalid.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class DuplicateStreamError(Exception):",
            "    \"\"\"",
            "    An attempt was made to insert a stream that already exists.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class MissingStreamError(KeyError, Exception):",
            "    \"\"\"",
            "    An operation was attempted on a stream that is not present in the tree.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Stream(object):",
            "    \"\"\"",
            "    Priority information for a given stream.",
            "",
            "    :param stream_id: The stream ID for the new stream.",
            "    :param weight: (optional) The stream weight. Defaults to 16.",
            "    \"\"\"",
            "    def __init__(self, stream_id, weight=16):",
            "        self.stream_id = stream_id",
            "        self.weight = weight",
            "        self.children = []",
            "        self.parent = None",
            "        self.child_queue = []",
            "        self.active = True",
            "        self.last_weight = 0",
            "        self._deficit = 0",
            "",
            "    def add_child(self, child):",
            "        \"\"\"",
            "        Add a stream that depends on this one.",
            "",
            "        :param child: A ``Stream`` object that depends on this one.",
            "        \"\"\"",
            "        child.parent = self",
            "        self.children.append(child)",
            "        heapq.heappush(self.child_queue, (self.last_weight, child))",
            "",
            "    def add_child_exclusive(self, child):",
            "        \"\"\"",
            "        Add a stream that exclusively depends on this one.",
            "",
            "        :param child: A ``Stream`` object that exclusively depends on this one.",
            "        \"\"\"",
            "        old_children = self.children",
            "        self.children = []",
            "        self.child_queue = []",
            "        self.last_weight = 0",
            "        self.add_child(child)",
            "",
            "        for old_child in old_children:",
            "            child.add_child(old_child)",
            "",
            "    def remove_child(self, child, strip_children=True):",
            "        \"\"\"",
            "        Removes a child stream from this stream. This is a potentially somewhat",
            "        expensive operation.",
            "",
            "        :param child: The child stream to remove.",
            "        :param strip_children: Whether children of the removed stream should",
            "            become children of this stream.",
            "        \"\"\"",
            "        # To do this we do the following:",
            "        #",
            "        # - remove the child stream from the list of children",
            "        # - build a new priority queue, filtering out the child when we find",
            "        #   it in the old one",
            "        self.children.remove(child)",
            "",
            "        new_queue = []",
            "",
            "        while self.child_queue:",
            "            level, stream = heapq.heappop(self.child_queue)",
            "            if stream == child:",
            "                continue",
            "",
            "            heapq.heappush(new_queue, (level, stream))",
            "",
            "        self.child_queue = new_queue",
            "",
            "        if strip_children:",
            "            for new_child in child.children:",
            "                self.add_child(new_child)",
            "",
            "    def schedule(self):",
            "        \"\"\"",
            "        Returns the stream ID of the next child to schedule. Potentially",
            "        recurses down the tree of priorities.",
            "        \"\"\"",
            "        # Cannot be called on active streams.",
            "        assert not self.active",
            "",
            "        next_stream = None",
            "        popped_streams = []",
            "",
            "        # Spin looking for the next active stream. Everything we pop off has",
            "        # to be rescheduled, even if it turns out none of them were active at",
            "        # this time.",
            "        try:",
            "            while next_stream is None:",
            "                # If the queue is empty, immediately fail.",
            "                val = heapq.heappop(self.child_queue)",
            "                popped_streams.append(val)",
            "                level, child = val",
            "",
            "                if child.active:",
            "                    next_stream = child.stream_id",
            "                else:",
            "                    # Guard against the possibility that the child also has no",
            "                    # suitable children.",
            "                    try:",
            "                        next_stream = child.schedule()",
            "                    except IndexError:",
            "                        continue",
            "        finally:",
            "            for level, child in popped_streams:",
            "                self.last_weight = level",
            "                level += (256 + child._deficit) // child.weight",
            "                child._deficit = (256 + child._deficit) % child.weight",
            "                heapq.heappush(self.child_queue, (level, child))",
            "",
            "        return next_stream",
            "",
            "    # Custom repr",
            "    def __repr__(self):",
            "        return \"Stream<id=%d, weight=%d>\" % (self.stream_id, self.weight)",
            "",
            "    # Custom comparison",
            "    def __eq__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return False",
            "",
            "        return self.stream_id == other.stream_id",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    def __lt__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id < other.stream_id",
            "",
            "    def __le__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id <= other.stream_id",
            "",
            "    def __gt__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id > other.stream_id",
            "",
            "    def __ge__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id >= other.stream_id",
            "",
            "",
            "class PriorityTree(object):",
            "    \"\"\"",
            "    A HTTP/2 Priority Tree.",
            "",
            "    This tree stores HTTP/2 streams according to their HTTP/2 priorities.",
            "    \"\"\"",
            "    def __init__(self):",
            "        # This flat array keeps hold of all the streams that are logically",
            "        # dependent on stream 0.",
            "        self._root_stream = Stream(stream_id=0, weight=1)",
            "        self._root_stream.active = False",
            "        self._streams = {0: self._root_stream}",
            "",
            "    def _exclusive_insert(self, parent_stream, inserted_stream):",
            "        \"\"\"",
            "        Insert ``inserted_stream`` beneath ``parent_stream``, obeying the",
            "        semantics of exclusive insertion.",
            "        \"\"\"",
            "        parent_stream.add_child_exclusive(inserted_stream)",
            "",
            "    def insert_stream(self,",
            "                      stream_id,",
            "                      depends_on=None,",
            "                      weight=16,",
            "                      exclusive=False):",
            "        \"\"\"",
            "        Insert a stream into the tree.",
            "",
            "        :param stream_id: The stream ID of the stream being inserted.",
            "        :param depends_on: (optional) The ID of the stream that the new stream",
            "            depends on, if any.",
            "        :param weight: (optional) The weight to give the new stream. Defaults",
            "            to 16.",
            "        :param exclusive: (optional) Whether this new stream should be an",
            "            exclusive dependency of the parent.",
            "        \"\"\"",
            "        if stream_id in self._streams:",
            "            raise DuplicateStreamError(\"Stream %d already in tree\" % stream_id)",
            "",
            "        stream = Stream(stream_id, weight)",
            "",
            "        if exclusive:",
            "            assert depends_on is not None",
            "            parent_stream = self._streams[depends_on]",
            "            self._exclusive_insert(parent_stream, stream)",
            "            self._streams[stream_id] = stream",
            "            return",
            "",
            "        if not depends_on:",
            "            depends_on = 0",
            "",
            "        parent = self._streams[depends_on]",
            "        parent.add_child(stream)",
            "        self._streams[stream_id] = stream",
            "",
            "    def reprioritize(self,",
            "                     stream_id,",
            "                     depends_on=None,",
            "                     weight=16,",
            "                     exclusive=False):",
            "        \"\"\"",
            "        Update the priority status of a stream already in the tree.",
            "",
            "        :param stream_id: The stream ID of the stream being updated.",
            "        :param depends_on: (optional) The ID of the stream that the stream now",
            "            depends on. If ``None``, will be moved to depend on stream 0.",
            "        :param weight: (optional) The new weight to give the stream. Defaults",
            "            to 16.",
            "        :param exclusive: (optional) Whether this stream should now be an",
            "            exclusive dependency of the new parent.",
            "        \"\"\"",
            "        def stream_cycle(new_parent, current):",
            "            \"\"\"",
            "            Reports whether the new parent depends on the current stream.",
            "            \"\"\"",
            "            parent = new_parent",
            "",
            "            # Don't iterate forever, but instead assume that the tree doesn't",
            "            # get more than 100 streams deep. This should catch accidental",
            "            # tree loops. This is the definition of defensive programming.",
            "            for _ in range(100):",
            "                parent = parent.parent",
            "                if parent.stream_id == current.stream_id:",
            "                    return True",
            "                elif parent.stream_id == 0:",
            "                    return False",
            "",
            "            raise PriorityLoop(",
            "                \"Stream %d is in a priority loop.\" % new_parent.stream_id",
            "            )  # pragma: no cover",
            "",
            "        try:",
            "            current_stream = self._streams[stream_id]",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "        # Update things in a specific order to make sure the calculation",
            "        # behaves properly. Specifically, we first update the weight. Then,",
            "        # we check whether this stream is being made dependent on one of its",
            "        # own dependents. Then, we remove this stream from its current parent",
            "        # and move it to its new parent, taking its children with it.",
            "        if depends_on:",
            "            # TODO: What if we don't have the new parent?",
            "            new_parent = self._streams[depends_on]",
            "            cycle = stream_cycle(new_parent, current_stream)",
            "        else:",
            "            new_parent = self._streams[0]",
            "            cycle = False",
            "",
            "        current_stream.weight = weight",
            "",
            "        # Our new parent is currently dependent on us. We should remove it from",
            "        # its parent, and make it a child of our current parent, and then",
            "        # continue.",
            "        if cycle:",
            "            new_parent.parent.remove_child(new_parent)",
            "            current_stream.parent.add_child(new_parent)",
            "",
            "        current_stream.parent.remove_child(",
            "            current_stream, strip_children=False",
            "        )",
            "",
            "        if exclusive:",
            "            new_parent.add_child_exclusive(current_stream)",
            "        else:",
            "            new_parent.add_child(current_stream)",
            "",
            "    def remove_stream(self, stream_id):",
            "        \"\"\"",
            "        Removes a stream from the priority tree.",
            "",
            "        :param stream_id: The ID of the stream to remove.",
            "        \"\"\"",
            "        try:",
            "            child = self._streams.pop(stream_id)",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "        parent = child.parent",
            "        parent.remove_child(child)",
            "",
            "    def block(self, stream_id):",
            "        \"\"\"",
            "        Marks a given stream as blocked, with no data to send.",
            "",
            "        :param stream_id: The ID of the stream to block.",
            "        \"\"\"",
            "        try:",
            "            self._streams[stream_id].active = False",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "    def unblock(self, stream_id):",
            "        \"\"\"",
            "        Marks a given stream as unblocked, with more data to send.",
            "",
            "        :param stream_id: The ID of the stream to unblock.",
            "        \"\"\"",
            "        # When a stream becomes unblocked,",
            "        try:",
            "            self._streams[stream_id].active = True",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "    # The iterator protocol",
            "    def __iter__(self):  # pragma: no cover",
            "        return self",
            "",
            "    def __next__(self):  # pragma: no cover",
            "        try:",
            "            return self._root_stream.schedule()",
            "        except IndexError:",
            "            raise DeadlockError(\"No unblocked streams to schedule.\")",
            "",
            "    def next(self):  # pragma: no cover",
            "        return self.__next__()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "priority/tree",
            "~~~~~~~~~~~~~",
            "",
            "Implementation of the Priority tree data structure.",
            "\"\"\"",
            "from __future__ import division",
            "",
            "import heapq",
            "import sys",
            "",
            "",
            "PY3 = sys.version_info[0] == 3",
            "",
            "",
            "class DeadlockError(Exception):",
            "    \"\"\"",
            "    Raised when there are no streams that can make progress: all streams are",
            "    blocked.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class PriorityLoop(Exception):",
            "    \"\"\"",
            "    An unexpected priority loop has been detected. The tree is invalid.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class DuplicateStreamError(Exception):",
            "    \"\"\"",
            "    An attempt was made to insert a stream that already exists.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class MissingStreamError(KeyError, Exception):",
            "    \"\"\"",
            "    An operation was attempted on a stream that is not present in the tree.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class TooManyStreamsError(Exception):",
            "    \"\"\"",
            "    An attempt was made to insert a dangerous number of streams into the",
            "    priority tree at the same time.",
            "",
            "    .. versionadded:: 1.2.0",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Stream(object):",
            "    \"\"\"",
            "    Priority information for a given stream.",
            "",
            "    :param stream_id: The stream ID for the new stream.",
            "    :param weight: (optional) The stream weight. Defaults to 16.",
            "    \"\"\"",
            "    def __init__(self, stream_id, weight=16):",
            "        self.stream_id = stream_id",
            "        self.weight = weight",
            "        self.children = []",
            "        self.parent = None",
            "        self.child_queue = []",
            "        self.active = True",
            "        self.last_weight = 0",
            "        self._deficit = 0",
            "",
            "    def add_child(self, child):",
            "        \"\"\"",
            "        Add a stream that depends on this one.",
            "",
            "        :param child: A ``Stream`` object that depends on this one.",
            "        \"\"\"",
            "        child.parent = self",
            "        self.children.append(child)",
            "        heapq.heappush(self.child_queue, (self.last_weight, child))",
            "",
            "    def add_child_exclusive(self, child):",
            "        \"\"\"",
            "        Add a stream that exclusively depends on this one.",
            "",
            "        :param child: A ``Stream`` object that exclusively depends on this one.",
            "        \"\"\"",
            "        old_children = self.children",
            "        self.children = []",
            "        self.child_queue = []",
            "        self.last_weight = 0",
            "        self.add_child(child)",
            "",
            "        for old_child in old_children:",
            "            child.add_child(old_child)",
            "",
            "    def remove_child(self, child, strip_children=True):",
            "        \"\"\"",
            "        Removes a child stream from this stream. This is a potentially somewhat",
            "        expensive operation.",
            "",
            "        :param child: The child stream to remove.",
            "        :param strip_children: Whether children of the removed stream should",
            "            become children of this stream.",
            "        \"\"\"",
            "        # To do this we do the following:",
            "        #",
            "        # - remove the child stream from the list of children",
            "        # - build a new priority queue, filtering out the child when we find",
            "        #   it in the old one",
            "        self.children.remove(child)",
            "",
            "        new_queue = []",
            "",
            "        while self.child_queue:",
            "            level, stream = heapq.heappop(self.child_queue)",
            "            if stream == child:",
            "                continue",
            "",
            "            heapq.heappush(new_queue, (level, stream))",
            "",
            "        self.child_queue = new_queue",
            "",
            "        if strip_children:",
            "            for new_child in child.children:",
            "                self.add_child(new_child)",
            "",
            "    def schedule(self):",
            "        \"\"\"",
            "        Returns the stream ID of the next child to schedule. Potentially",
            "        recurses down the tree of priorities.",
            "        \"\"\"",
            "        # Cannot be called on active streams.",
            "        assert not self.active",
            "",
            "        next_stream = None",
            "        popped_streams = []",
            "",
            "        # Spin looking for the next active stream. Everything we pop off has",
            "        # to be rescheduled, even if it turns out none of them were active at",
            "        # this time.",
            "        try:",
            "            while next_stream is None:",
            "                # If the queue is empty, immediately fail.",
            "                val = heapq.heappop(self.child_queue)",
            "                popped_streams.append(val)",
            "                level, child = val",
            "",
            "                if child.active:",
            "                    next_stream = child.stream_id",
            "                else:",
            "                    # Guard against the possibility that the child also has no",
            "                    # suitable children.",
            "                    try:",
            "                        next_stream = child.schedule()",
            "                    except IndexError:",
            "                        continue",
            "        finally:",
            "            for level, child in popped_streams:",
            "                self.last_weight = level",
            "                level += (256 + child._deficit) // child.weight",
            "                child._deficit = (256 + child._deficit) % child.weight",
            "                heapq.heappush(self.child_queue, (level, child))",
            "",
            "        return next_stream",
            "",
            "    # Custom repr",
            "    def __repr__(self):",
            "        return \"Stream<id=%d, weight=%d>\" % (self.stream_id, self.weight)",
            "",
            "    # Custom comparison",
            "    def __eq__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return False",
            "",
            "        return self.stream_id == other.stream_id",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    def __lt__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id < other.stream_id",
            "",
            "    def __le__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id <= other.stream_id",
            "",
            "    def __gt__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id > other.stream_id",
            "",
            "    def __ge__(self, other):",
            "        if not isinstance(other, Stream):  # pragma: no cover",
            "            return NotImplemented",
            "",
            "        return self.stream_id >= other.stream_id",
            "",
            "",
            "class PriorityTree(object):",
            "    \"\"\"",
            "    A HTTP/2 Priority Tree.",
            "",
            "    This tree stores HTTP/2 streams according to their HTTP/2 priorities.",
            "",
            "    .. versionchanged:: 1.2.0",
            "       Added ``maximum_streams`` keyword argument.",
            "",
            "    :param maximum_streams: The maximum number of streams that may be active in",
            "        the priority tree at any one time. If this number is exceeded, the",
            "        priority tree will raise a :class:`TooManyStreamsError",
            "        <priority.TooManyStreamsError>` and will refuse to insert the stream.",
            "",
            "        This parameter exists to defend against the possibility of DoS attack",
            "        by attempting to overfill the priority tree. If any endpoint is",
            "        attempting to manage the priority of this many streams at once it is",
            "        probably trying to screw with you, so it is sensible to simply refuse",
            "        to play ball at that point.",
            "",
            "        While we allow the user to configure this, we don't really *expect*",
            "        them too, unless they want to be even more conservative than we are by",
            "        default.",
            "    :type maximum_streams: ``int``",
            "    \"\"\"",
            "    def __init__(self, maximum_streams=1000):",
            "        # This flat array keeps hold of all the streams that are logically",
            "        # dependent on stream 0.",
            "        self._root_stream = Stream(stream_id=0, weight=1)",
            "        self._root_stream.active = False",
            "        self._streams = {0: self._root_stream}",
            "        self._maximum_streams = maximum_streams",
            "",
            "    def _exclusive_insert(self, parent_stream, inserted_stream):",
            "        \"\"\"",
            "        Insert ``inserted_stream`` beneath ``parent_stream``, obeying the",
            "        semantics of exclusive insertion.",
            "        \"\"\"",
            "        parent_stream.add_child_exclusive(inserted_stream)",
            "",
            "    def insert_stream(self,",
            "                      stream_id,",
            "                      depends_on=None,",
            "                      weight=16,",
            "                      exclusive=False):",
            "        \"\"\"",
            "        Insert a stream into the tree.",
            "",
            "        :param stream_id: The stream ID of the stream being inserted.",
            "        :param depends_on: (optional) The ID of the stream that the new stream",
            "            depends on, if any.",
            "        :param weight: (optional) The weight to give the new stream. Defaults",
            "            to 16.",
            "        :param exclusive: (optional) Whether this new stream should be an",
            "            exclusive dependency of the parent.",
            "        \"\"\"",
            "        if stream_id in self._streams:",
            "            raise DuplicateStreamError(\"Stream %d already in tree\" % stream_id)",
            "",
            "        if (len(self._streams) + 1) > self._maximum_streams:",
            "            raise TooManyStreamsError(",
            "                \"Refusing to insert %d streams into priority tree at once\" % (",
            "                    self._maximum_streams + 1",
            "                )",
            "            )",
            "",
            "        stream = Stream(stream_id, weight)",
            "",
            "        if exclusive:",
            "            assert depends_on is not None",
            "            parent_stream = self._streams[depends_on]",
            "            self._exclusive_insert(parent_stream, stream)",
            "            self._streams[stream_id] = stream",
            "            return",
            "",
            "        if not depends_on:",
            "            depends_on = 0",
            "",
            "        parent = self._streams[depends_on]",
            "        parent.add_child(stream)",
            "        self._streams[stream_id] = stream",
            "",
            "    def reprioritize(self,",
            "                     stream_id,",
            "                     depends_on=None,",
            "                     weight=16,",
            "                     exclusive=False):",
            "        \"\"\"",
            "        Update the priority status of a stream already in the tree.",
            "",
            "        :param stream_id: The stream ID of the stream being updated.",
            "        :param depends_on: (optional) The ID of the stream that the stream now",
            "            depends on. If ``None``, will be moved to depend on stream 0.",
            "        :param weight: (optional) The new weight to give the stream. Defaults",
            "            to 16.",
            "        :param exclusive: (optional) Whether this stream should now be an",
            "            exclusive dependency of the new parent.",
            "        \"\"\"",
            "        def stream_cycle(new_parent, current):",
            "            \"\"\"",
            "            Reports whether the new parent depends on the current stream.",
            "            \"\"\"",
            "            parent = new_parent",
            "",
            "            # Don't iterate forever, but instead assume that the tree doesn't",
            "            # get more than 100 streams deep. This should catch accidental",
            "            # tree loops. This is the definition of defensive programming.",
            "            for _ in range(100):",
            "                parent = parent.parent",
            "                if parent.stream_id == current.stream_id:",
            "                    return True",
            "                elif parent.stream_id == 0:",
            "                    return False",
            "",
            "            raise PriorityLoop(",
            "                \"Stream %d is in a priority loop.\" % new_parent.stream_id",
            "            )  # pragma: no cover",
            "",
            "        try:",
            "            current_stream = self._streams[stream_id]",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "        # Update things in a specific order to make sure the calculation",
            "        # behaves properly. Specifically, we first update the weight. Then,",
            "        # we check whether this stream is being made dependent on one of its",
            "        # own dependents. Then, we remove this stream from its current parent",
            "        # and move it to its new parent, taking its children with it.",
            "        if depends_on:",
            "            # TODO: What if we don't have the new parent?",
            "            new_parent = self._streams[depends_on]",
            "            cycle = stream_cycle(new_parent, current_stream)",
            "        else:",
            "            new_parent = self._streams[0]",
            "            cycle = False",
            "",
            "        current_stream.weight = weight",
            "",
            "        # Our new parent is currently dependent on us. We should remove it from",
            "        # its parent, and make it a child of our current parent, and then",
            "        # continue.",
            "        if cycle:",
            "            new_parent.parent.remove_child(new_parent)",
            "            current_stream.parent.add_child(new_parent)",
            "",
            "        current_stream.parent.remove_child(",
            "            current_stream, strip_children=False",
            "        )",
            "",
            "        if exclusive:",
            "            new_parent.add_child_exclusive(current_stream)",
            "        else:",
            "            new_parent.add_child(current_stream)",
            "",
            "    def remove_stream(self, stream_id):",
            "        \"\"\"",
            "        Removes a stream from the priority tree.",
            "",
            "        :param stream_id: The ID of the stream to remove.",
            "        \"\"\"",
            "        try:",
            "            child = self._streams.pop(stream_id)",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "        parent = child.parent",
            "        parent.remove_child(child)",
            "",
            "    def block(self, stream_id):",
            "        \"\"\"",
            "        Marks a given stream as blocked, with no data to send.",
            "",
            "        :param stream_id: The ID of the stream to block.",
            "        \"\"\"",
            "        try:",
            "            self._streams[stream_id].active = False",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "    def unblock(self, stream_id):",
            "        \"\"\"",
            "        Marks a given stream as unblocked, with more data to send.",
            "",
            "        :param stream_id: The ID of the stream to unblock.",
            "        \"\"\"",
            "        # When a stream becomes unblocked,",
            "        try:",
            "            self._streams[stream_id].active = True",
            "        except KeyError:",
            "            raise MissingStreamError(\"Stream %d not in tree\" % stream_id)",
            "",
            "    # The iterator protocol",
            "    def __iter__(self):  # pragma: no cover",
            "        return self",
            "",
            "    def __next__(self):  # pragma: no cover",
            "        try:",
            "            return self._root_stream.schedule()",
            "        except IndexError:",
            "            raise DeadlockError(\"No unblocked streams to schedule.\")",
            "",
            "    def next(self):  # pragma: no cover",
            "        return self.__next__()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "203": [
                "PriorityTree",
                "__init__"
            ]
        },
        "addLocation": [
            "src.priority.priority.PriorityTree.self",
            "src.priority.priority.PriorityTree.__iter__"
        ]
    }
}