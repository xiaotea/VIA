{
    "lib/ansible/plugins/action/fetch.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import base64"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ansible.errors import AnsibleError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from ansible.errors import AnsibleActionFail, AnsibleActionSkip"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from ansible.module_utils._text import to_bytes"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ansible.module_utils.six import string_types"
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from ansible.module_utils.parsing.convert_bool import boolean"
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ansible.plugins.action import ActionBase"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ansible.utils.display import Display"
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ansible.utils.hashing import checksum, checksum_s, md5, secure_hash"
            },
            "11": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ansible.utils.path import makedirs_safe"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+from ansible.utils.path import makedirs_safe, is_subpath"
            },
            "13": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " display = Display()"
            },
            "15": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         try:"
            },
            "18": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "             if self._play_context.check_mode:"
            },
            "19": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['skipped'] = True"
            },
            "20": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['msg'] = 'check mode not (yet) supported for this module'"
            },
            "21": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return result"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                raise AnsibleActionSkip('check mode not (yet) supported for this module')"
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             source = self._task.args.get('src', None)"
            },
            "25": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dest = self._task.args.get('dest', None)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            original_dest = dest = self._task.args.get('dest', None)"
            },
            "27": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             flat = boolean(self._task.args.get('flat'), strict=False)"
            },
            "28": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "             fail_on_missing = boolean(self._task.args.get('fail_on_missing', True), strict=False)"
            },
            "29": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             validate_checksum = boolean(self._task.args.get('validate_checksum', True), strict=False)"
            },
            "30": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            msg = ''"
            },
            "32": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             # validate source and dest are strings FIXME: use basic.py and module specs"
            },
            "33": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             if not isinstance(source, string_types):"
            },
            "34": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['msg'] = \"Invalid type supplied for source option, it must be a string\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                msg = \"Invalid type supplied for source option, it must be a string\""
            },
            "36": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             if not isinstance(dest, string_types):"
            },
            "38": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['msg'] = \"Invalid type supplied for dest option, it must be a string\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                msg = \"Invalid type supplied for dest option, it must be a string\""
            },
            "40": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             if source is None or dest is None:"
            },
            "42": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['msg'] = \"src and dest are required\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                msg = \"src and dest are required\""
            },
            "44": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if result.get('msg'):"
            },
            "46": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result['failed'] = True"
            },
            "47": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return result"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            if msg:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                raise AnsibleActionFail(msg)"
            },
            "50": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             source = self._connection._shell.join_path(source)"
            },
            "52": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             source = self._remote_expand_user(source)"
            },
            "53": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                         remote_data = base64.b64decode(slurpres['content'])"
            },
            "54": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "                     if remote_data is not None:"
            },
            "55": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                         remote_checksum = checksum_s(remote_data)"
            },
            "56": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # the source path may have been expanded on the"
            },
            "57": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # target system, so we compare it here and use the"
            },
            "58": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # expanded version if it's different"
            },
            "59": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    remote_source = slurpres.get('source')"
            },
            "60": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if remote_source and remote_source != source:"
            },
            "61": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        source = remote_source"
            },
            "62": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             # calculate the destination name"
            },
            "64": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             if os.path.sep not in self._connection._shell.join_path('a', ''):"
            },
            "65": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "             else:"
            },
            "66": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "                 source_local = source"
            },
            "67": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dest = os.path.expanduser(dest)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            # ensure we only use file name, avoid relative paths"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            if not is_subpath(dest, original_dest):"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+                # TODO: ? dest = os.path.expanduser(dest.replace(('../','')))"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                raise AnsibleActionFail(\"Detected directory traversal, expected to be contained in '%s' but got '%s'\" % (original_dest, dest))"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             if flat:"
            },
            "75": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                 if os.path.isdir(to_bytes(dest, errors='surrogate_or_strict')) and not dest.endswith(os.sep):"
            },
            "76": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    result['msg'] = \"dest is an existing directory, use a trailing slash if you want to fetch src into that directory\""
            },
            "77": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    result['file'] = dest"
            },
            "78": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    result['failed'] = True"
            },
            "79": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return result"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                    raise AnsibleActionFail(\"dest is an existing directory, use a trailing slash if you want to fetch src into that directory\")"
            },
            "81": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "                 if dest.endswith(os.sep):"
            },
            "82": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                     # if the path ends with \"/\", we'll use the source filename as the"
            },
            "83": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                     # destination filename"
            },
            "84": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "                     target_name = self._play_context.remote_addr"
            },
            "85": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                 dest = \"%s/%s/%s\" % (self._loader.path_dwim(dest), target_name, source_local)"
            },
            "86": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dest = dest.replace(\"//\", \"/\")"
            },
            "88": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "89": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             if remote_checksum in ('0', '1', '2', '3', '4', '5'):"
            },
            "90": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "                 result['changed'] = False"
            },
            "91": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "                 result['file'] = source"
            },
            "92": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "                     result['msg'] += \", not transferring, ignored\""
            },
            "93": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                 return result"
            },
            "94": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            dest = os.path.normpath(dest)"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "97": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             # calculate checksum for the local file"
            },
            "98": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "             local_checksum = checksum(dest)"
            },
            "99": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "100": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "                         f.write(remote_data)"
            },
            "101": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "                         f.close()"
            },
            "102": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                     except (IOError, OSError) as e:"
            },
            "103": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        raise AnsibleError(\"Failed to fetch the file: %s\" % e)"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+                        raise AnsibleActionFail(\"Failed to fetch the file: %s\" % e)"
            },
            "105": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "                 new_checksum = secure_hash(dest)"
            },
            "106": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                 # For backwards compatibility. We'll return None on FIPS enabled systems"
            },
            "107": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "                 try:"
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import base64",
            "",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_bytes",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.plugins.action import ActionBase",
            "from ansible.utils.display import Display",
            "from ansible.utils.hashing import checksum, checksum_s, md5, secure_hash",
            "from ansible.utils.path import makedirs_safe",
            "",
            "display = Display()",
            "",
            "",
            "class ActionModule(ActionBase):",
            "",
            "    def run(self, tmp=None, task_vars=None):",
            "        ''' handler for fetch operations '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        result = super(ActionModule, self).run(tmp, task_vars)",
            "        del tmp  # tmp no longer has any effect",
            "",
            "        try:",
            "            if self._play_context.check_mode:",
            "                result['skipped'] = True",
            "                result['msg'] = 'check mode not (yet) supported for this module'",
            "                return result",
            "",
            "            source = self._task.args.get('src', None)",
            "            dest = self._task.args.get('dest', None)",
            "            flat = boolean(self._task.args.get('flat'), strict=False)",
            "            fail_on_missing = boolean(self._task.args.get('fail_on_missing', True), strict=False)",
            "            validate_checksum = boolean(self._task.args.get('validate_checksum', True), strict=False)",
            "",
            "            # validate source and dest are strings FIXME: use basic.py and module specs",
            "            if not isinstance(source, string_types):",
            "                result['msg'] = \"Invalid type supplied for source option, it must be a string\"",
            "",
            "            if not isinstance(dest, string_types):",
            "                result['msg'] = \"Invalid type supplied for dest option, it must be a string\"",
            "",
            "            if source is None or dest is None:",
            "                result['msg'] = \"src and dest are required\"",
            "",
            "            if result.get('msg'):",
            "                result['failed'] = True",
            "                return result",
            "",
            "            source = self._connection._shell.join_path(source)",
            "            source = self._remote_expand_user(source)",
            "",
            "            remote_checksum = None",
            "            if not self._connection.become:",
            "                # calculate checksum for the remote file, don't bother if using become as slurp will be used",
            "                # Force remote_checksum to follow symlinks because fetch always follows symlinks",
            "                remote_checksum = self._remote_checksum(source, all_vars=task_vars, follow=True)",
            "",
            "            # use slurp if permissions are lacking or privilege escalation is needed",
            "            remote_data = None",
            "            if remote_checksum in ('1', '2', None):",
            "                slurpres = self._execute_module(module_name='slurp', module_args=dict(src=source), task_vars=task_vars)",
            "                if slurpres.get('failed'):",
            "                    if not fail_on_missing and (slurpres.get('msg').startswith('file not found') or remote_checksum == '1'):",
            "                        result['msg'] = \"the remote file does not exist, not transferring, ignored\"",
            "                        result['file'] = source",
            "                        result['changed'] = False",
            "                    else:",
            "                        result.update(slurpres)",
            "                    return result",
            "                else:",
            "                    if slurpres['encoding'] == 'base64':",
            "                        remote_data = base64.b64decode(slurpres['content'])",
            "                    if remote_data is not None:",
            "                        remote_checksum = checksum_s(remote_data)",
            "                    # the source path may have been expanded on the",
            "                    # target system, so we compare it here and use the",
            "                    # expanded version if it's different",
            "                    remote_source = slurpres.get('source')",
            "                    if remote_source and remote_source != source:",
            "                        source = remote_source",
            "",
            "            # calculate the destination name",
            "            if os.path.sep not in self._connection._shell.join_path('a', ''):",
            "                source = self._connection._shell._unquote(source)",
            "                source_local = source.replace('\\\\', '/')",
            "            else:",
            "                source_local = source",
            "",
            "            dest = os.path.expanduser(dest)",
            "            if flat:",
            "                if os.path.isdir(to_bytes(dest, errors='surrogate_or_strict')) and not dest.endswith(os.sep):",
            "                    result['msg'] = \"dest is an existing directory, use a trailing slash if you want to fetch src into that directory\"",
            "                    result['file'] = dest",
            "                    result['failed'] = True",
            "                    return result",
            "                if dest.endswith(os.sep):",
            "                    # if the path ends with \"/\", we'll use the source filename as the",
            "                    # destination filename",
            "                    base = os.path.basename(source_local)",
            "                    dest = os.path.join(dest, base)",
            "                if not dest.startswith(\"/\"):",
            "                    # if dest does not start with \"/\", we'll assume a relative path",
            "                    dest = self._loader.path_dwim(dest)",
            "            else:",
            "                # files are saved in dest dir, with a subdir for each host, then the filename",
            "                if 'inventory_hostname' in task_vars:",
            "                    target_name = task_vars['inventory_hostname']",
            "                else:",
            "                    target_name = self._play_context.remote_addr",
            "                dest = \"%s/%s/%s\" % (self._loader.path_dwim(dest), target_name, source_local)",
            "",
            "            dest = dest.replace(\"//\", \"/\")",
            "",
            "            if remote_checksum in ('0', '1', '2', '3', '4', '5'):",
            "                result['changed'] = False",
            "                result['file'] = source",
            "                if remote_checksum == '0':",
            "                    result['msg'] = \"unable to calculate the checksum of the remote file\"",
            "                elif remote_checksum == '1':",
            "                    result['msg'] = \"the remote file does not exist\"",
            "                elif remote_checksum == '2':",
            "                    result['msg'] = \"no read permission on remote file\"",
            "                elif remote_checksum == '3':",
            "                    result['msg'] = \"remote file is a directory, fetch cannot work on directories\"",
            "                elif remote_checksum == '4':",
            "                    result['msg'] = \"python isn't present on the system.  Unable to compute checksum\"",
            "                elif remote_checksum == '5':",
            "                    result['msg'] = \"stdlib json was not found on the remote machine. Only the raw module can work without those installed\"",
            "                # Historically, these don't fail because you may want to transfer",
            "                # a log file that possibly MAY exist but keep going to fetch other",
            "                # log files. Today, this is better achieved by adding",
            "                # ignore_errors or failed_when to the task.  Control the behaviour",
            "                # via fail_when_missing",
            "                if fail_on_missing:",
            "                    result['failed'] = True",
            "                    del result['changed']",
            "                else:",
            "                    result['msg'] += \", not transferring, ignored\"",
            "                return result",
            "",
            "            # calculate checksum for the local file",
            "            local_checksum = checksum(dest)",
            "",
            "            if remote_checksum != local_checksum:",
            "                # create the containing directories, if needed",
            "                makedirs_safe(os.path.dirname(dest))",
            "",
            "                # fetch the file and check for changes",
            "                if remote_data is None:",
            "                    self._connection.fetch_file(source, dest)",
            "                else:",
            "                    try:",
            "                        f = open(to_bytes(dest, errors='surrogate_or_strict'), 'wb')",
            "                        f.write(remote_data)",
            "                        f.close()",
            "                    except (IOError, OSError) as e:",
            "                        raise AnsibleError(\"Failed to fetch the file: %s\" % e)",
            "                new_checksum = secure_hash(dest)",
            "                # For backwards compatibility. We'll return None on FIPS enabled systems",
            "                try:",
            "                    new_md5 = md5(dest)",
            "                except ValueError:",
            "                    new_md5 = None",
            "",
            "                if validate_checksum and new_checksum != remote_checksum:",
            "                    result.update(dict(failed=True, md5sum=new_md5,",
            "                                       msg=\"checksum mismatch\", file=source, dest=dest, remote_md5sum=None,",
            "                                       checksum=new_checksum, remote_checksum=remote_checksum))",
            "                else:",
            "                    result.update({'changed': True, 'md5sum': new_md5, 'dest': dest,",
            "                                   'remote_md5sum': None, 'checksum': new_checksum,",
            "                                   'remote_checksum': remote_checksum})",
            "            else:",
            "                # For backwards compatibility. We'll return None on FIPS enabled systems",
            "                try:",
            "                    local_md5 = md5(dest)",
            "                except ValueError:",
            "                    local_md5 = None",
            "                result.update(dict(changed=False, md5sum=local_md5, file=source, dest=dest, checksum=local_checksum))",
            "",
            "        finally:",
            "            self._remove_tmp_path(self._connection._shell.tmpdir)",
            "",
            "        return result"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import base64",
            "",
            "from ansible.errors import AnsibleActionFail, AnsibleActionSkip",
            "from ansible.module_utils._text import to_bytes",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.plugins.action import ActionBase",
            "from ansible.utils.display import Display",
            "from ansible.utils.hashing import checksum, checksum_s, md5, secure_hash",
            "from ansible.utils.path import makedirs_safe, is_subpath",
            "",
            "display = Display()",
            "",
            "",
            "class ActionModule(ActionBase):",
            "",
            "    def run(self, tmp=None, task_vars=None):",
            "        ''' handler for fetch operations '''",
            "        if task_vars is None:",
            "            task_vars = dict()",
            "",
            "        result = super(ActionModule, self).run(tmp, task_vars)",
            "        del tmp  # tmp no longer has any effect",
            "",
            "        try:",
            "            if self._play_context.check_mode:",
            "                raise AnsibleActionSkip('check mode not (yet) supported for this module')",
            "",
            "            source = self._task.args.get('src', None)",
            "            original_dest = dest = self._task.args.get('dest', None)",
            "            flat = boolean(self._task.args.get('flat'), strict=False)",
            "            fail_on_missing = boolean(self._task.args.get('fail_on_missing', True), strict=False)",
            "            validate_checksum = boolean(self._task.args.get('validate_checksum', True), strict=False)",
            "",
            "            msg = ''",
            "            # validate source and dest are strings FIXME: use basic.py and module specs",
            "            if not isinstance(source, string_types):",
            "                msg = \"Invalid type supplied for source option, it must be a string\"",
            "",
            "            if not isinstance(dest, string_types):",
            "                msg = \"Invalid type supplied for dest option, it must be a string\"",
            "",
            "            if source is None or dest is None:",
            "                msg = \"src and dest are required\"",
            "",
            "            if msg:",
            "                raise AnsibleActionFail(msg)",
            "",
            "            source = self._connection._shell.join_path(source)",
            "            source = self._remote_expand_user(source)",
            "",
            "            remote_checksum = None",
            "            if not self._connection.become:",
            "                # calculate checksum for the remote file, don't bother if using become as slurp will be used",
            "                # Force remote_checksum to follow symlinks because fetch always follows symlinks",
            "                remote_checksum = self._remote_checksum(source, all_vars=task_vars, follow=True)",
            "",
            "            # use slurp if permissions are lacking or privilege escalation is needed",
            "            remote_data = None",
            "            if remote_checksum in ('1', '2', None):",
            "                slurpres = self._execute_module(module_name='slurp', module_args=dict(src=source), task_vars=task_vars)",
            "                if slurpres.get('failed'):",
            "                    if not fail_on_missing and (slurpres.get('msg').startswith('file not found') or remote_checksum == '1'):",
            "                        result['msg'] = \"the remote file does not exist, not transferring, ignored\"",
            "                        result['file'] = source",
            "                        result['changed'] = False",
            "                    else:",
            "                        result.update(slurpres)",
            "                    return result",
            "                else:",
            "                    if slurpres['encoding'] == 'base64':",
            "                        remote_data = base64.b64decode(slurpres['content'])",
            "                    if remote_data is not None:",
            "                        remote_checksum = checksum_s(remote_data)",
            "",
            "            # calculate the destination name",
            "            if os.path.sep not in self._connection._shell.join_path('a', ''):",
            "                source = self._connection._shell._unquote(source)",
            "                source_local = source.replace('\\\\', '/')",
            "            else:",
            "                source_local = source",
            "",
            "            # ensure we only use file name, avoid relative paths",
            "            if not is_subpath(dest, original_dest):",
            "                # TODO: ? dest = os.path.expanduser(dest.replace(('../','')))",
            "                raise AnsibleActionFail(\"Detected directory traversal, expected to be contained in '%s' but got '%s'\" % (original_dest, dest))",
            "",
            "            if flat:",
            "                if os.path.isdir(to_bytes(dest, errors='surrogate_or_strict')) and not dest.endswith(os.sep):",
            "                    raise AnsibleActionFail(\"dest is an existing directory, use a trailing slash if you want to fetch src into that directory\")",
            "                if dest.endswith(os.sep):",
            "                    # if the path ends with \"/\", we'll use the source filename as the",
            "                    # destination filename",
            "                    base = os.path.basename(source_local)",
            "                    dest = os.path.join(dest, base)",
            "                if not dest.startswith(\"/\"):",
            "                    # if dest does not start with \"/\", we'll assume a relative path",
            "                    dest = self._loader.path_dwim(dest)",
            "            else:",
            "                # files are saved in dest dir, with a subdir for each host, then the filename",
            "                if 'inventory_hostname' in task_vars:",
            "                    target_name = task_vars['inventory_hostname']",
            "                else:",
            "                    target_name = self._play_context.remote_addr",
            "                dest = \"%s/%s/%s\" % (self._loader.path_dwim(dest), target_name, source_local)",
            "",
            "            if remote_checksum in ('0', '1', '2', '3', '4', '5'):",
            "                result['changed'] = False",
            "                result['file'] = source",
            "                if remote_checksum == '0':",
            "                    result['msg'] = \"unable to calculate the checksum of the remote file\"",
            "                elif remote_checksum == '1':",
            "                    result['msg'] = \"the remote file does not exist\"",
            "                elif remote_checksum == '2':",
            "                    result['msg'] = \"no read permission on remote file\"",
            "                elif remote_checksum == '3':",
            "                    result['msg'] = \"remote file is a directory, fetch cannot work on directories\"",
            "                elif remote_checksum == '4':",
            "                    result['msg'] = \"python isn't present on the system.  Unable to compute checksum\"",
            "                elif remote_checksum == '5':",
            "                    result['msg'] = \"stdlib json was not found on the remote machine. Only the raw module can work without those installed\"",
            "                # Historically, these don't fail because you may want to transfer",
            "                # a log file that possibly MAY exist but keep going to fetch other",
            "                # log files. Today, this is better achieved by adding",
            "                # ignore_errors or failed_when to the task.  Control the behaviour",
            "                # via fail_when_missing",
            "                if fail_on_missing:",
            "                    result['failed'] = True",
            "                    del result['changed']",
            "                else:",
            "                    result['msg'] += \", not transferring, ignored\"",
            "                return result",
            "",
            "            dest = os.path.normpath(dest)",
            "",
            "            # calculate checksum for the local file",
            "            local_checksum = checksum(dest)",
            "",
            "            if remote_checksum != local_checksum:",
            "                # create the containing directories, if needed",
            "                makedirs_safe(os.path.dirname(dest))",
            "",
            "                # fetch the file and check for changes",
            "                if remote_data is None:",
            "                    self._connection.fetch_file(source, dest)",
            "                else:",
            "                    try:",
            "                        f = open(to_bytes(dest, errors='surrogate_or_strict'), 'wb')",
            "                        f.write(remote_data)",
            "                        f.close()",
            "                    except (IOError, OSError) as e:",
            "                        raise AnsibleActionFail(\"Failed to fetch the file: %s\" % e)",
            "                new_checksum = secure_hash(dest)",
            "                # For backwards compatibility. We'll return None on FIPS enabled systems",
            "                try:",
            "                    new_md5 = md5(dest)",
            "                except ValueError:",
            "                    new_md5 = None",
            "",
            "                if validate_checksum and new_checksum != remote_checksum:",
            "                    result.update(dict(failed=True, md5sum=new_md5,",
            "                                       msg=\"checksum mismatch\", file=source, dest=dest, remote_md5sum=None,",
            "                                       checksum=new_checksum, remote_checksum=remote_checksum))",
            "                else:",
            "                    result.update({'changed': True, 'md5sum': new_md5, 'dest': dest,",
            "                                   'remote_md5sum': None, 'checksum': new_checksum,",
            "                                   'remote_checksum': remote_checksum})",
            "            else:",
            "                # For backwards compatibility. We'll return None on FIPS enabled systems",
            "                try:",
            "                    local_md5 = md5(dest)",
            "                except ValueError:",
            "                    local_md5 = None",
            "                result.update(dict(changed=False, md5sum=local_md5, file=source, dest=dest, checksum=local_checksum))",
            "",
            "        finally:",
            "            self._remove_tmp_path(self._connection._shell.tmpdir)",
            "",
            "        return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [],
            "30": [],
            "47": [
                "ActionModule",
                "run"
            ],
            "48": [
                "ActionModule",
                "run"
            ],
            "49": [
                "ActionModule",
                "run"
            ],
            "52": [
                "ActionModule",
                "run"
            ],
            "59": [
                "ActionModule",
                "run"
            ],
            "62": [
                "ActionModule",
                "run"
            ],
            "65": [
                "ActionModule",
                "run"
            ],
            "67": [
                "ActionModule",
                "run"
            ],
            "68": [
                "ActionModule",
                "run"
            ],
            "69": [
                "ActionModule",
                "run"
            ],
            "97": [
                "ActionModule",
                "run"
            ],
            "98": [
                "ActionModule",
                "run"
            ],
            "99": [
                "ActionModule",
                "run"
            ],
            "100": [
                "ActionModule",
                "run"
            ],
            "101": [
                "ActionModule",
                "run"
            ],
            "102": [
                "ActionModule",
                "run"
            ],
            "111": [
                "ActionModule",
                "run"
            ],
            "114": [
                "ActionModule",
                "run"
            ],
            "115": [
                "ActionModule",
                "run"
            ],
            "116": [
                "ActionModule",
                "run"
            ],
            "117": [
                "ActionModule",
                "run"
            ],
            "134": [
                "ActionModule",
                "run"
            ],
            "135": [
                "ActionModule",
                "run"
            ],
            "179": [
                "ActionModule",
                "run"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/plugins/connection/local.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ansible.module_utils._text import to_bytes, to_native, to_text"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from ansible.plugins.connection import ConnectionBase"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from ansible.utils.display import Display"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from ansible.utils.path import unfrackpath"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " display = Display()"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         display.debug(\"done with local.exec_command()\")"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         return (p.returncode, stdout, stderr)"
            },
            "9": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _ensure_abs(self, path):"
            },
            "11": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.isabs(path) and self.cwd is not None:"
            },
            "12": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = os.path.normpath(os.path.join(self.cwd, path))"
            },
            "13": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return path"
            },
            "14": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     def put_file(self, in_path, out_path):"
            },
            "16": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         ''' transfer a file from local to local '''"
            },
            "17": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         super(Connection, self).put_file(in_path, out_path)"
            },
            "19": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        in_path = self._ensure_abs(in_path)"
            },
            "21": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        out_path = self._ensure_abs(out_path)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        in_path = unfrackpath(in_path, basedir=self.cwd)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        out_path = unfrackpath(out_path, basedir=self.cwd)"
            },
            "24": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         display.vvv(u\"PUT {0} TO {1}\".format(in_path, out_path), host=self._play_context.remote_addr)"
            },
            "26": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):"
            }
        },
        "frontPatchFile": [
            "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# (c) 2015, 2017 Toshio Kuratomi <tkuratomi@ansible.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    connection: local",
            "    short_description: execute on controller",
            "    description:",
            "        - This connection plugin allows ansible to execute tasks on the Ansible 'controller' instead of on a remote host.",
            "    author: ansible (@core)",
            "    version_added: historical",
            "    notes:",
            "        - The remote user is ignored, the user with which the ansible CLI was executed is used instead.",
            "'''",
            "",
            "import os",
            "import shutil",
            "import subprocess",
            "import fcntl",
            "import getpass",
            "",
            "import ansible.constants as C",
            "from ansible.compat import selectors",
            "from ansible.errors import AnsibleError, AnsibleFileNotFound",
            "from ansible.module_utils.six import text_type, binary_type",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.utils.display import Display",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "    ''' Local based connections '''",
            "",
            "    transport = 'local'",
            "    has_pipelining = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "        self.cwd = None",
            "",
            "    def _connect(self):",
            "        ''' connect to the local host; nothing to do here '''",
            "",
            "        # Because we haven't made any remote connection we're running as",
            "        # the local user, rather than as whatever is configured in",
            "        # remote_user.",
            "        self._play_context.remote_user = getpass.getuser()",
            "",
            "        if not self._connected:",
            "            display.vvv(u\"ESTABLISH LOCAL CONNECTION FOR USER: {0}\".format(self._play_context.remote_user), host=self._play_context.remote_addr)",
            "            self._connected = True",
            "        return self",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        ''' run a command on the local host '''",
            "",
            "        super(Connection, self).exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "",
            "        display.debug(\"in local.exec_command()\")",
            "",
            "        executable = C.DEFAULT_EXECUTABLE.split()[0] if C.DEFAULT_EXECUTABLE else None",
            "",
            "        if not os.path.exists(to_bytes(executable, errors='surrogate_or_strict')):",
            "            raise AnsibleError(\"failed to find the executable specified %s.\"",
            "                               \" Please verify if the executable exists and re-try.\" % executable)",
            "",
            "        display.vvv(u\"EXEC {0}\".format(to_text(cmd)), host=self._play_context.remote_addr)",
            "        display.debug(\"opening command with Popen()\")",
            "",
            "        if isinstance(cmd, (text_type, binary_type)):",
            "            cmd = to_bytes(cmd)",
            "        else:",
            "            cmd = map(to_bytes, cmd)",
            "",
            "        p = subprocess.Popen(",
            "            cmd,",
            "            shell=isinstance(cmd, (text_type, binary_type)),",
            "            executable=executable,",
            "            cwd=self.cwd,",
            "            stdin=subprocess.PIPE,",
            "            stdout=subprocess.PIPE,",
            "            stderr=subprocess.PIPE,",
            "        )",
            "        display.debug(\"done running command with Popen()\")",
            "",
            "        if self.become and self.become.expect_prompt() and sudoable:",
            "            fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)",
            "            fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)",
            "            selector = selectors.DefaultSelector()",
            "            selector.register(p.stdout, selectors.EVENT_READ)",
            "            selector.register(p.stderr, selectors.EVENT_READ)",
            "",
            "            become_output = b''",
            "            try:",
            "                while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):",
            "                    events = selector.select(self._play_context.timeout)",
            "                    if not events:",
            "                        stdout, stderr = p.communicate()",
            "                        raise AnsibleError('timeout waiting for privilege escalation password prompt:\\n' + to_native(become_output))",
            "",
            "                    for key, event in events:",
            "                        if key.fileobj == p.stdout:",
            "                            chunk = p.stdout.read()",
            "                        elif key.fileobj == p.stderr:",
            "                            chunk = p.stderr.read()",
            "",
            "                    if not chunk:",
            "                        stdout, stderr = p.communicate()",
            "                        raise AnsibleError('privilege output closed while waiting for password prompt:\\n' + to_native(become_output))",
            "                    become_output += chunk",
            "            finally:",
            "                selector.close()",
            "",
            "            if not self.become.check_success(become_output):",
            "                become_pass = self.become.get_option('become_pass', playcontext=self._play_context)",
            "                p.stdin.write(to_bytes(become_pass, errors='surrogate_or_strict') + b'\\n')",
            "            fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)",
            "            fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)",
            "",
            "        display.debug(\"getting output with communicate()\")",
            "        stdout, stderr = p.communicate(in_data)",
            "        display.debug(\"done communicating\")",
            "",
            "        display.debug(\"done with local.exec_command()\")",
            "        return (p.returncode, stdout, stderr)",
            "",
            "    def _ensure_abs(self, path):",
            "        if not os.path.isabs(path) and self.cwd is not None:",
            "            path = os.path.normpath(os.path.join(self.cwd, path))",
            "        return path",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to local '''",
            "",
            "        super(Connection, self).put_file(in_path, out_path)",
            "",
            "        in_path = self._ensure_abs(in_path)",
            "        out_path = self._ensure_abs(out_path)",
            "",
            "        display.vvv(u\"PUT {0} TO {1}\".format(in_path, out_path), host=self._play_context.remote_addr)",
            "        if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):",
            "            raise AnsibleFileNotFound(\"file or module does not exist: {0}\".format(to_native(in_path)))",
            "        try:",
            "            shutil.copyfile(to_bytes(in_path, errors='surrogate_or_strict'), to_bytes(out_path, errors='surrogate_or_strict'))",
            "        except shutil.Error:",
            "            raise AnsibleError(\"failed to copy: {0} and {1} are the same\".format(to_native(in_path), to_native(out_path)))",
            "        except IOError as e:",
            "            raise AnsibleError(\"failed to transfer file to {0}: {1}\".format(to_native(out_path), to_native(e)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from local to local -- for compatibility '''",
            "",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "",
            "        display.vvv(u\"FETCH {0} TO {1}\".format(in_path, out_path), host=self._play_context.remote_addr)",
            "        self.put_file(in_path, out_path)",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        self._connected = False"
        ],
        "afterPatchFile": [
            "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>",
            "# (c) 2015, 2017 Toshio Kuratomi <tkuratomi@ansible.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "DOCUMENTATION = '''",
            "    connection: local",
            "    short_description: execute on controller",
            "    description:",
            "        - This connection plugin allows ansible to execute tasks on the Ansible 'controller' instead of on a remote host.",
            "    author: ansible (@core)",
            "    version_added: historical",
            "    notes:",
            "        - The remote user is ignored, the user with which the ansible CLI was executed is used instead.",
            "'''",
            "",
            "import os",
            "import shutil",
            "import subprocess",
            "import fcntl",
            "import getpass",
            "",
            "import ansible.constants as C",
            "from ansible.compat import selectors",
            "from ansible.errors import AnsibleError, AnsibleFileNotFound",
            "from ansible.module_utils.six import text_type, binary_type",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "from ansible.plugins.connection import ConnectionBase",
            "from ansible.utils.display import Display",
            "from ansible.utils.path import unfrackpath",
            "",
            "display = Display()",
            "",
            "",
            "class Connection(ConnectionBase):",
            "    ''' Local based connections '''",
            "",
            "    transport = 'local'",
            "    has_pipelining = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "",
            "        super(Connection, self).__init__(*args, **kwargs)",
            "        self.cwd = None",
            "",
            "    def _connect(self):",
            "        ''' connect to the local host; nothing to do here '''",
            "",
            "        # Because we haven't made any remote connection we're running as",
            "        # the local user, rather than as whatever is configured in",
            "        # remote_user.",
            "        self._play_context.remote_user = getpass.getuser()",
            "",
            "        if not self._connected:",
            "            display.vvv(u\"ESTABLISH LOCAL CONNECTION FOR USER: {0}\".format(self._play_context.remote_user), host=self._play_context.remote_addr)",
            "            self._connected = True",
            "        return self",
            "",
            "    def exec_command(self, cmd, in_data=None, sudoable=True):",
            "        ''' run a command on the local host '''",
            "",
            "        super(Connection, self).exec_command(cmd, in_data=in_data, sudoable=sudoable)",
            "",
            "        display.debug(\"in local.exec_command()\")",
            "",
            "        executable = C.DEFAULT_EXECUTABLE.split()[0] if C.DEFAULT_EXECUTABLE else None",
            "",
            "        if not os.path.exists(to_bytes(executable, errors='surrogate_or_strict')):",
            "            raise AnsibleError(\"failed to find the executable specified %s.\"",
            "                               \" Please verify if the executable exists and re-try.\" % executable)",
            "",
            "        display.vvv(u\"EXEC {0}\".format(to_text(cmd)), host=self._play_context.remote_addr)",
            "        display.debug(\"opening command with Popen()\")",
            "",
            "        if isinstance(cmd, (text_type, binary_type)):",
            "            cmd = to_bytes(cmd)",
            "        else:",
            "            cmd = map(to_bytes, cmd)",
            "",
            "        p = subprocess.Popen(",
            "            cmd,",
            "            shell=isinstance(cmd, (text_type, binary_type)),",
            "            executable=executable,",
            "            cwd=self.cwd,",
            "            stdin=subprocess.PIPE,",
            "            stdout=subprocess.PIPE,",
            "            stderr=subprocess.PIPE,",
            "        )",
            "        display.debug(\"done running command with Popen()\")",
            "",
            "        if self.become and self.become.expect_prompt() and sudoable:",
            "            fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)",
            "            fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)",
            "            selector = selectors.DefaultSelector()",
            "            selector.register(p.stdout, selectors.EVENT_READ)",
            "            selector.register(p.stderr, selectors.EVENT_READ)",
            "",
            "            become_output = b''",
            "            try:",
            "                while not self.become.check_success(become_output) and not self.become.check_password_prompt(become_output):",
            "                    events = selector.select(self._play_context.timeout)",
            "                    if not events:",
            "                        stdout, stderr = p.communicate()",
            "                        raise AnsibleError('timeout waiting for privilege escalation password prompt:\\n' + to_native(become_output))",
            "",
            "                    for key, event in events:",
            "                        if key.fileobj == p.stdout:",
            "                            chunk = p.stdout.read()",
            "                        elif key.fileobj == p.stderr:",
            "                            chunk = p.stderr.read()",
            "",
            "                    if not chunk:",
            "                        stdout, stderr = p.communicate()",
            "                        raise AnsibleError('privilege output closed while waiting for password prompt:\\n' + to_native(become_output))",
            "                    become_output += chunk",
            "            finally:",
            "                selector.close()",
            "",
            "            if not self.become.check_success(become_output):",
            "                become_pass = self.become.get_option('become_pass', playcontext=self._play_context)",
            "                p.stdin.write(to_bytes(become_pass, errors='surrogate_or_strict') + b'\\n')",
            "            fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)",
            "            fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)",
            "",
            "        display.debug(\"getting output with communicate()\")",
            "        stdout, stderr = p.communicate(in_data)",
            "        display.debug(\"done communicating\")",
            "",
            "        display.debug(\"done with local.exec_command()\")",
            "        return (p.returncode, stdout, stderr)",
            "",
            "    def put_file(self, in_path, out_path):",
            "        ''' transfer a file from local to local '''",
            "",
            "        super(Connection, self).put_file(in_path, out_path)",
            "",
            "        in_path = unfrackpath(in_path, basedir=self.cwd)",
            "        out_path = unfrackpath(out_path, basedir=self.cwd)",
            "",
            "        display.vvv(u\"PUT {0} TO {1}\".format(in_path, out_path), host=self._play_context.remote_addr)",
            "        if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):",
            "            raise AnsibleFileNotFound(\"file or module does not exist: {0}\".format(to_native(in_path)))",
            "        try:",
            "            shutil.copyfile(to_bytes(in_path, errors='surrogate_or_strict'), to_bytes(out_path, errors='surrogate_or_strict'))",
            "        except shutil.Error:",
            "            raise AnsibleError(\"failed to copy: {0} and {1} are the same\".format(to_native(in_path), to_native(out_path)))",
            "        except IOError as e:",
            "            raise AnsibleError(\"failed to transfer file to {0}: {1}\".format(to_native(out_path), to_native(e)))",
            "",
            "    def fetch_file(self, in_path, out_path):",
            "        ''' fetch a file from local to local -- for compatibility '''",
            "",
            "        super(Connection, self).fetch_file(in_path, out_path)",
            "",
            "        display.vvv(u\"FETCH {0} TO {1}\".format(in_path, out_path), host=self._play_context.remote_addr)",
            "        self.put_file(in_path, out_path)",
            "",
            "    def close(self):",
            "        ''' terminate the connection; nothing to do here '''",
            "        self._connected = False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "133": [
                "Connection",
                "_ensure_abs"
            ],
            "134": [
                "Connection",
                "_ensure_abs"
            ],
            "135": [
                "Connection",
                "_ensure_abs"
            ],
            "136": [
                "Connection",
                "_ensure_abs"
            ],
            "137": [
                "Connection"
            ],
            "143": [
                "Connection",
                "put_file"
            ],
            "144": [
                "Connection",
                "put_file"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/utils/path.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                     display.display(u'Unable to remove temporary file {0}'.format(to_text(e)))"
            },
            "1": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     except Exception:"
            },
            "2": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         pass"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+def is_subpath(child, parent):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    \"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    Compares paths to check if one is contained in the other"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    :arg: child: Path to test"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    :arg parent; Path to test against"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+     \"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    test = False"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    abs_child = unfrackpath(child, follow=False)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    abs_parent = unfrackpath(parent, follow=False)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+    c = abs_child.split(os.path.sep)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    p = abs_parent.split(os.path.sep)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    try:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        test = c[:len(p)] == p"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    except IndexError:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        # child is shorter than parent so cannot be subpath"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        pass"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    return test"
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import shutil",
            "",
            "from errno import EEXIST",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "",
            "",
            "__all__ = ['unfrackpath', 'makedirs_safe']",
            "",
            "",
            "def unfrackpath(path, follow=True, basedir=None):",
            "    '''",
            "    Returns a path that is free of symlinks (if follow=True), environment variables, relative path traversals and symbols (~)",
            "",
            "    :arg path: A byte or text string representing a path to be canonicalized",
            "    :arg follow: A boolean to indicate of symlinks should be resolved or not",
            "    :raises UnicodeDecodeError: If the canonicalized version of the path",
            "        contains non-utf8 byte sequences.",
            "    :rtype: A text string (unicode on pyyhon2, str on python3).",
            "    :returns: An absolute path with symlinks, environment variables, and tilde",
            "        expanded.  Note that this does not check whether a path exists.",
            "",
            "    example::",
            "        '$HOME/../../var/mail' becomes '/var/spool/mail'",
            "    '''",
            "",
            "    b_basedir = to_bytes(basedir, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "    if b_basedir is None:",
            "        b_basedir = to_bytes(os.getcwd(), errors='surrogate_or_strict')",
            "    elif os.path.isfile(b_basedir):",
            "        b_basedir = os.path.dirname(b_basedir)",
            "",
            "    b_final_path = os.path.expanduser(os.path.expandvars(to_bytes(path, errors='surrogate_or_strict')))",
            "",
            "    if not os.path.isabs(b_final_path):",
            "        b_final_path = os.path.join(b_basedir, b_final_path)",
            "",
            "    if follow:",
            "        b_final_path = os.path.realpath(b_final_path)",
            "",
            "    return to_text(os.path.normpath(b_final_path), errors='surrogate_or_strict')",
            "",
            "",
            "def makedirs_safe(path, mode=None):",
            "    '''",
            "    A *potentially insecure* way to ensure the existence of a directory chain. The \"safe\" in this function's name",
            "    refers only to its ability to ignore `EEXIST` in the case of multiple callers operating on the same part of",
            "    the directory chain. This function is not safe to use under world-writable locations when the first level of the",
            "    path to be created contains a predictable component. Always create a randomly-named element first if there is any",
            "    chance the parent directory might be world-writable (eg, /tmp) to prevent symlink hijacking and potential",
            "    disclosure or modification of sensitive file contents.",
            "",
            "    :arg path: A byte or text string representing a directory chain to be created",
            "    :kwarg mode: If given, the mode to set the directory to",
            "    :raises AnsibleError: If the directory cannot be created and does not already exist.",
            "    :raises UnicodeDecodeError: if the path is not decodable in the utf-8 encoding.",
            "    '''",
            "",
            "    rpath = unfrackpath(path)",
            "    b_rpath = to_bytes(rpath)",
            "    if not os.path.exists(b_rpath):",
            "        try:",
            "            if mode:",
            "                os.makedirs(b_rpath, mode)",
            "            else:",
            "                os.makedirs(b_rpath)",
            "        except OSError as e:",
            "            if e.errno != EEXIST:",
            "                raise AnsibleError(\"Unable to create local directories(%s): %s\" % (to_native(rpath), to_native(e)))",
            "",
            "",
            "def basedir(source):",
            "    \"\"\" returns directory for inventory or playbook \"\"\"",
            "    source = to_bytes(source, errors='surrogate_or_strict')",
            "    dname = None",
            "    if os.path.isdir(source):",
            "        dname = source",
            "    elif source in [None, '', '.']:",
            "        dname = os.getcwd()",
            "    elif os.path.isfile(source):",
            "        dname = os.path.dirname(source)",
            "",
            "    if dname:",
            "        # don't follow symlinks for basedir, enables source re-use",
            "        dname = os.path.abspath(dname)",
            "",
            "    return to_text(dname, errors='surrogate_or_strict')",
            "",
            "",
            "def cleanup_tmp_file(path, warn=False):",
            "    \"\"\"",
            "    Removes temporary file or directory. Optionally display a warning if unable",
            "    to remove the file or directory.",
            "",
            "    :arg path: Path to file or directory to be removed",
            "    :kwarg warn: Whether or not to display a warning when the file or directory",
            "        cannot be removed",
            "    \"\"\"",
            "    try:",
            "        if os.path.exists(path):",
            "            try:",
            "                if os.path.isdir(path):",
            "                    shutil.rmtree(path)",
            "                elif os.path.isfile(path):",
            "                    os.unlink(path)",
            "            except Exception as e:",
            "                if warn:",
            "                    # Importing here to avoid circular import",
            "                    from ansible.utils.display import Display",
            "                    display = Display()",
            "                    display.display(u'Unable to remove temporary file {0}'.format(to_text(e)))",
            "    except Exception:",
            "        pass"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import shutil",
            "",
            "from errno import EEXIST",
            "from ansible.errors import AnsibleError",
            "from ansible.module_utils._text import to_bytes, to_native, to_text",
            "",
            "",
            "__all__ = ['unfrackpath', 'makedirs_safe']",
            "",
            "",
            "def unfrackpath(path, follow=True, basedir=None):",
            "    '''",
            "    Returns a path that is free of symlinks (if follow=True), environment variables, relative path traversals and symbols (~)",
            "",
            "    :arg path: A byte or text string representing a path to be canonicalized",
            "    :arg follow: A boolean to indicate of symlinks should be resolved or not",
            "    :raises UnicodeDecodeError: If the canonicalized version of the path",
            "        contains non-utf8 byte sequences.",
            "    :rtype: A text string (unicode on pyyhon2, str on python3).",
            "    :returns: An absolute path with symlinks, environment variables, and tilde",
            "        expanded.  Note that this does not check whether a path exists.",
            "",
            "    example::",
            "        '$HOME/../../var/mail' becomes '/var/spool/mail'",
            "    '''",
            "",
            "    b_basedir = to_bytes(basedir, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "    if b_basedir is None:",
            "        b_basedir = to_bytes(os.getcwd(), errors='surrogate_or_strict')",
            "    elif os.path.isfile(b_basedir):",
            "        b_basedir = os.path.dirname(b_basedir)",
            "",
            "    b_final_path = os.path.expanduser(os.path.expandvars(to_bytes(path, errors='surrogate_or_strict')))",
            "",
            "    if not os.path.isabs(b_final_path):",
            "        b_final_path = os.path.join(b_basedir, b_final_path)",
            "",
            "    if follow:",
            "        b_final_path = os.path.realpath(b_final_path)",
            "",
            "    return to_text(os.path.normpath(b_final_path), errors='surrogate_or_strict')",
            "",
            "",
            "def makedirs_safe(path, mode=None):",
            "    '''",
            "    A *potentially insecure* way to ensure the existence of a directory chain. The \"safe\" in this function's name",
            "    refers only to its ability to ignore `EEXIST` in the case of multiple callers operating on the same part of",
            "    the directory chain. This function is not safe to use under world-writable locations when the first level of the",
            "    path to be created contains a predictable component. Always create a randomly-named element first if there is any",
            "    chance the parent directory might be world-writable (eg, /tmp) to prevent symlink hijacking and potential",
            "    disclosure or modification of sensitive file contents.",
            "",
            "    :arg path: A byte or text string representing a directory chain to be created",
            "    :kwarg mode: If given, the mode to set the directory to",
            "    :raises AnsibleError: If the directory cannot be created and does not already exist.",
            "    :raises UnicodeDecodeError: if the path is not decodable in the utf-8 encoding.",
            "    '''",
            "",
            "    rpath = unfrackpath(path)",
            "    b_rpath = to_bytes(rpath)",
            "    if not os.path.exists(b_rpath):",
            "        try:",
            "            if mode:",
            "                os.makedirs(b_rpath, mode)",
            "            else:",
            "                os.makedirs(b_rpath)",
            "        except OSError as e:",
            "            if e.errno != EEXIST:",
            "                raise AnsibleError(\"Unable to create local directories(%s): %s\" % (to_native(rpath), to_native(e)))",
            "",
            "",
            "def basedir(source):",
            "    \"\"\" returns directory for inventory or playbook \"\"\"",
            "    source = to_bytes(source, errors='surrogate_or_strict')",
            "    dname = None",
            "    if os.path.isdir(source):",
            "        dname = source",
            "    elif source in [None, '', '.']:",
            "        dname = os.getcwd()",
            "    elif os.path.isfile(source):",
            "        dname = os.path.dirname(source)",
            "",
            "    if dname:",
            "        # don't follow symlinks for basedir, enables source re-use",
            "        dname = os.path.abspath(dname)",
            "",
            "    return to_text(dname, errors='surrogate_or_strict')",
            "",
            "",
            "def cleanup_tmp_file(path, warn=False):",
            "    \"\"\"",
            "    Removes temporary file or directory. Optionally display a warning if unable",
            "    to remove the file or directory.",
            "",
            "    :arg path: Path to file or directory to be removed",
            "    :kwarg warn: Whether or not to display a warning when the file or directory",
            "        cannot be removed",
            "    \"\"\"",
            "    try:",
            "        if os.path.exists(path):",
            "            try:",
            "                if os.path.isdir(path):",
            "                    shutil.rmtree(path)",
            "                elif os.path.isfile(path):",
            "                    os.unlink(path)",
            "            except Exception as e:",
            "                if warn:",
            "                    # Importing here to avoid circular import",
            "                    from ansible.utils.display import Display",
            "                    display = Display()",
            "                    display.display(u'Unable to remove temporary file {0}'.format(to_text(e)))",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def is_subpath(child, parent):",
            "    \"\"\"",
            "    Compares paths to check if one is contained in the other",
            "    :arg: child: Path to test",
            "    :arg parent; Path to test against",
            "     \"\"\"",
            "    test = False",
            "",
            "    abs_child = unfrackpath(child, follow=False)",
            "    abs_parent = unfrackpath(parent, follow=False)",
            "",
            "    c = abs_child.split(os.path.sep)",
            "    p = abs_parent.split(os.path.sep)",
            "",
            "    try:",
            "        test = c[:len(p)] == p",
            "    except IndexError:",
            "        # child is shorter than parent so cannot be subpath",
            "        pass",
            "",
            "    return test"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litellm.utils.exception_type"
        ]
    }
}