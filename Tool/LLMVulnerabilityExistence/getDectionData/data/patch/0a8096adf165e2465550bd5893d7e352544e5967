{
    "IPython/html/files/handlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "             cur_mime = mimetypes.guess_type(name)[0]"
            },
            "1": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "             if cur_mime is not None:"
            },
            "2": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "                 self.set_header('Content-Type', cur_mime)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            else:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+                if model['format'] == 'base64':"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                    self.set_header('Content-Type', 'application/octet-stream')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                else:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                    self.set_header('Content-Type', 'text/plain')"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         "
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         if model['format'] == 'base64':"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             b64_bytes = model['content'].encode('ascii')"
            }
        },
        "frontPatchFile": [
            "\"\"\"Serve files directly from the ContentsManager.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import os",
            "import mimetypes",
            "import json",
            "import base64",
            "",
            "from tornado import web",
            "",
            "from IPython.html.base.handlers import IPythonHandler",
            "",
            "class FilesHandler(IPythonHandler):",
            "    \"\"\"serve files via ContentsManager\"\"\"",
            "",
            "    @web.authenticated",
            "    def get(self, path):",
            "        cm = self.contents_manager",
            "        if cm.is_hidden(path):",
            "            self.log.info(\"Refusing to serve hidden file, via 404 Error\")",
            "            raise web.HTTPError(404)",
            "        ",
            "        path = path.strip('/')",
            "        if '/' in path:",
            "            _, name = path.rsplit('/', 1)",
            "        else:",
            "            name = path",
            "        ",
            "        model = cm.get(path, type='file')",
            "        ",
            "        if self.get_argument(\"download\", False):",
            "            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)",
            "        ",
            "        # get mimetype from filename",
            "        if name.endswith('.ipynb'):",
            "            self.set_header('Content-Type', 'application/json')",
            "        else:",
            "            cur_mime = mimetypes.guess_type(name)[0]",
            "            if cur_mime is not None:",
            "                self.set_header('Content-Type', cur_mime)",
            "        ",
            "        if model['format'] == 'base64':",
            "            b64_bytes = model['content'].encode('ascii')",
            "            self.write(base64.decodestring(b64_bytes))",
            "        elif model['format'] == 'json':",
            "            self.write(json.dumps(model['content']))",
            "        else:",
            "            self.write(model['content'])",
            "        self.flush()",
            "",
            "default_handlers = [",
            "    (r\"/files/(.*)\", FilesHandler),",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"Serve files directly from the ContentsManager.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import os",
            "import mimetypes",
            "import json",
            "import base64",
            "",
            "from tornado import web",
            "",
            "from IPython.html.base.handlers import IPythonHandler",
            "",
            "class FilesHandler(IPythonHandler):",
            "    \"\"\"serve files via ContentsManager\"\"\"",
            "",
            "    @web.authenticated",
            "    def get(self, path):",
            "        cm = self.contents_manager",
            "        if cm.is_hidden(path):",
            "            self.log.info(\"Refusing to serve hidden file, via 404 Error\")",
            "            raise web.HTTPError(404)",
            "        ",
            "        path = path.strip('/')",
            "        if '/' in path:",
            "            _, name = path.rsplit('/', 1)",
            "        else:",
            "            name = path",
            "        ",
            "        model = cm.get(path, type='file')",
            "        ",
            "        if self.get_argument(\"download\", False):",
            "            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % name)",
            "        ",
            "        # get mimetype from filename",
            "        if name.endswith('.ipynb'):",
            "            self.set_header('Content-Type', 'application/json')",
            "        else:",
            "            cur_mime = mimetypes.guess_type(name)[0]",
            "            if cur_mime is not None:",
            "                self.set_header('Content-Type', cur_mime)",
            "            else:",
            "                if model['format'] == 'base64':",
            "                    self.set_header('Content-Type', 'application/octet-stream')",
            "                else:",
            "                    self.set_header('Content-Type', 'text/plain')",
            "        ",
            "        if model['format'] == 'base64':",
            "            b64_bytes = model['content'].encode('ascii')",
            "            self.write(base64.decodestring(b64_bytes))",
            "        elif model['format'] == 'json':",
            "            self.write(json.dumps(model['content']))",
            "        else:",
            "            self.write(model['content'])",
            "        self.flush()",
            "",
            "default_handlers = [",
            "    (r\"/files/(.*)\", FilesHandler),",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create"
        ]
    },
    "IPython/html/services/contents/filemanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         model['type'] = 'file'"
            },
            "1": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         os_path = self._get_os_path(path)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        model['mimetype'] = mimetypes.guess_type(os_path)[0]"
            },
            "4": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         if content:"
            },
            "6": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             content, format = self._read_file(os_path, format)"
            },
            "7": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            default_mime = {"
            },
            "8": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'text': 'text/plain',"
            },
            "9": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'base64': 'application/octet-stream'"
            },
            "10": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            }[format]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+            if model['mimetype'] is None:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+                default_mime = {"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                    'text': 'text/plain',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+                    'base64': 'application/octet-stream'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+                }[format]"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+                model['mimetype'] = default_mime"
            },
            "17": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "             model.update("
            },
            "19": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "                 content=content,"
            },
            "20": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "                 format=format,"
            },
            "21": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                mimetype=mimetypes.guess_type(os_path)[0] or default_mime,"
            },
            "22": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "             )"
            },
            "23": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 295,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         return model"
            }
        },
        "frontPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "",
            "import io",
            "import os",
            "import shutil",
            "import mimetypes",
            "",
            "from tornado import web",
            "",
            "from .filecheckpoints import FileCheckpoints",
            "from .fileio import FileManagerMixin",
            "from .manager import ContentsManager",
            "",
            "from IPython import nbformat",
            "from IPython.utils.importstring import import_item",
            "from IPython.utils.traitlets import Any, Unicode, Bool, TraitError",
            "from IPython.utils.py3compat import getcwd, string_types",
            "from IPython.utils import tz",
            "from IPython.html.utils import (",
            "    is_hidden,",
            "    to_api_path,",
            ")",
            "",
            "_script_exporter = None",
            "",
            "",
            "def _post_save_script(model, os_path, contents_manager, **kwargs):",
            "    \"\"\"convert notebooks to Python script after save with nbconvert",
            "",
            "    replaces `ipython notebook --script`",
            "    \"\"\"",
            "    from IPython.nbconvert.exporters.script import ScriptExporter",
            "",
            "    if model['type'] != 'notebook':",
            "        return",
            "",
            "    global _script_exporter",
            "    if _script_exporter is None:",
            "        _script_exporter = ScriptExporter(parent=contents_manager)",
            "    log = contents_manager.log",
            "",
            "    base, ext = os.path.splitext(os_path)",
            "    py_fname = base + '.py'",
            "    script, resources = _script_exporter.from_filename(os_path)",
            "    script_fname = base + resources.get('output_extension', '.txt')",
            "    log.info(\"Saving script /%s\", to_api_path(script_fname, contents_manager.root_dir))",
            "    with io.open(script_fname, 'w', encoding='utf-8') as f:",
            "        f.write(script)",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    def _root_dir_default(self):",
            "        try:",
            "            return self.parent.notebook_dir",
            "        except AttributeError:",
            "            return getcwd()",
            "",
            "    save_script = Bool(False, config=True, help='DEPRECATED, use post_save_hook')",
            "    def _save_script_changed(self):",
            "        self.log.warn(\"\"\"",
            "        `--script` is deprecated. You can trigger nbconvert via pre- or post-save hooks:",
            "",
            "            ContentsManager.pre_save_hook",
            "            FileContentsManager.post_save_hook",
            "",
            "        A post-save hook has been registered that calls:",
            "",
            "            ipython nbconvert --to script [notebook]",
            "",
            "        which behaves similarly to `--script`.",
            "        \"\"\")",
            "",
            "        self.post_save_hook = _post_save_script",
            "",
            "    post_save_hook = Any(None, config=True,",
            "        help=\"\"\"Python callable or importstring thereof",
            "",
            "        to be called on the path of a file just saved.",
            "",
            "        This can be used to process the file on disk,",
            "        such as converting the notebook to a script or HTML via nbconvert.",
            "",
            "        It will be called as (all arguments passed by keyword)::",
            "",
            "            hook(os_path=os_path, model=model, contents_manager=instance)",
            "",
            "        - path: the filesystem path to the file just written",
            "        - model: the model representing the file",
            "        - contents_manager: this ContentsManager instance",
            "        \"\"\"",
            "    )",
            "    def _post_save_hook_changed(self, name, old, new):",
            "        if new and isinstance(new, string_types):",
            "            self.post_save_hook = import_item(self.post_save_hook)",
            "        elif new:",
            "            if not callable(new):",
            "                raise TraitError(\"post_save_hook must be callable\")",
            "",
            "    def run_post_save_hook(self, model, os_path):",
            "        \"\"\"Run the post-save hook if defined, and log errors\"\"\"",
            "        if self.post_save_hook:",
            "            try:",
            "                self.log.debug(\"Running post-save hook on %s\", os_path)",
            "                self.post_save_hook(os_path=os_path, model=model, contents_manager=self)",
            "            except Exception:",
            "                self.log.error(\"Post-save hook failed on %s\", os_path, exc_info=True)",
            "",
            "    def _root_dir_changed(self, name, old, new):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        if not os.path.isabs(new):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            self.root_dir = os.path.abspath(new)",
            "            return",
            "        if not os.path.isdir(new):",
            "            raise TraitError(\"%r is not a directory\" % new)",
            "",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.stat(os_path)",
            "        last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        created = tz.utcfromtimestamp(info.st_ctime)",
            "        # Create the base model.",
            "        model = {}",
            "        model['name'] = path.rsplit('/', 1)[-1]",
            "        model['path'] = path",
            "        model['last_modified'] = last_modified",
            "        model['created'] = created",
            "        model['content'] = None",
            "        model['format'] = None",
            "        model['mimetype'] = None",
            "        try:",
            "            model['writable'] = os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            model['writable'] = False",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = u'directory does not exist: %r' % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir):",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\",",
            "                os_path",
            "            )",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model['type'] = 'directory'",
            "        if content:",
            "            model['content'] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                os_path = os.path.join(os_dir, name)",
            "                # skip over broken symlinks in listing",
            "                if not os.path.exists(os_path):",
            "                    self.log.warn(\"%s doesn't exist\", os_path)",
            "                    continue",
            "                elif not os.path.isfile(os_path) and not os.path.isdir(os_path):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "                if self.should_list(name) and not is_hidden(os_path, self.root_dir):",
            "                    contents.append(self.get(",
            "                        path='%s/%s' % (path, name),",
            "                        content=False)",
            "                    )",
            "",
            "            model['format'] = 'json'",
            "",
            "        return model",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'file'",
            "",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            default_mime = {",
            "                'text': 'text/plain',",
            "                'base64': 'application/octet-stream'",
            "            }[format]",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "                mimetype=mimetypes.guess_type(os_path)[0] or default_mime,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'notebook'",
            "        if content:",
            "            os_path = self._get_os_path(path)",
            "            nb = self._read_notebook(os_path, as_version=4)",
            "            self.mark_trusted_cells(nb, path)",
            "            model['content'] = nb",
            "            model['format'] = 'json'",
            "            self.validate_notebook_model(model)",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\" Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, u'No such file or directory: %s' % path)",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, 'directory'):",
            "                raise web.HTTPError(400,",
            "                                u'%s is a directory, not a %s' % (path, type), reason='bad type')",
            "            model = self._dir_model(path, content=content)",
            "        elif type == 'notebook' or (type is None and path.endswith('.ipynb')):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == 'directory':",
            "                raise web.HTTPError(400,",
            "                                u'%s is not a directory' % path, reason='bad type')",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=''):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir):",
            "            raise web.HTTPError(400, u'Cannot create hidden directory %r' % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, u'Not a directory: %s' % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=''):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip('/')",
            "",
            "        if 'type' not in model:",
            "            raise web.HTTPError(400, u'No file type provided')",
            "        if 'content' not in model and model['type'] != 'directory':",
            "            raise web.HTTPError(400, u'No file content provided')",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        try:",
            "            if model['type'] == 'notebook':",
            "                nb = nbformat.from_dict(model['content'])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model['type'] == 'file':",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model['content'], model.get('format'))",
            "            elif model['type'] == 'directory':",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model['type'])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(u'Error while saving file: %s %s', path, e, exc_info=True)",
            "            raise web.HTTPError(500, u'Unexpected error while saving file: %s %s' % (path, e))",
            "",
            "        validation_message = None",
            "        if model['type'] == 'notebook':",
            "            self.validate_notebook_model(model)",
            "            validation_message = model.get('message', None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model['message'] = validation_message",
            "",
            "        self.run_post_save_hook(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if os.path.isdir(os_path):",
            "            listing = os.listdir(os_path)",
            "            # Don't delete non-empty directories.",
            "            # A directory containing only leftover checkpoints is",
            "            # considered empty.",
            "            cp_dir = getattr(self.checkpoints, 'checkpoint_dir', None)",
            "            for entry in listing:",
            "                if entry != cp_dir:",
            "                    raise web.HTTPError(400, u'Directory %s not empty' % os_path)",
            "        elif not os.path.isfile(os_path):",
            "            raise web.HTTPError(404, u'File does not exist: %s' % os_path)",
            "",
            "        if os.path.isdir(os_path):",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip('/')",
            "        new_path = new_path.strip('/')",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path):",
            "            raise web.HTTPError(409, u'File already exists: %s' % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, u'Unknown error renaming file: %s %s' % (old_path, e))",
            "",
            "    def info_string(self):",
            "        return \"Serving notebooks from local directory: %s\" % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if '/' in path:",
            "            parent_dir = path.rsplit('/', 1)[0]",
            "        else:",
            "            parent_dir = ''",
            "        return parent_dir"
        ],
        "afterPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "",
            "import io",
            "import os",
            "import shutil",
            "import mimetypes",
            "",
            "from tornado import web",
            "",
            "from .filecheckpoints import FileCheckpoints",
            "from .fileio import FileManagerMixin",
            "from .manager import ContentsManager",
            "",
            "from IPython import nbformat",
            "from IPython.utils.importstring import import_item",
            "from IPython.utils.traitlets import Any, Unicode, Bool, TraitError",
            "from IPython.utils.py3compat import getcwd, string_types",
            "from IPython.utils import tz",
            "from IPython.html.utils import (",
            "    is_hidden,",
            "    to_api_path,",
            ")",
            "",
            "_script_exporter = None",
            "",
            "",
            "def _post_save_script(model, os_path, contents_manager, **kwargs):",
            "    \"\"\"convert notebooks to Python script after save with nbconvert",
            "",
            "    replaces `ipython notebook --script`",
            "    \"\"\"",
            "    from IPython.nbconvert.exporters.script import ScriptExporter",
            "",
            "    if model['type'] != 'notebook':",
            "        return",
            "",
            "    global _script_exporter",
            "    if _script_exporter is None:",
            "        _script_exporter = ScriptExporter(parent=contents_manager)",
            "    log = contents_manager.log",
            "",
            "    base, ext = os.path.splitext(os_path)",
            "    py_fname = base + '.py'",
            "    script, resources = _script_exporter.from_filename(os_path)",
            "    script_fname = base + resources.get('output_extension', '.txt')",
            "    log.info(\"Saving script /%s\", to_api_path(script_fname, contents_manager.root_dir))",
            "    with io.open(script_fname, 'w', encoding='utf-8') as f:",
            "        f.write(script)",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    def _root_dir_default(self):",
            "        try:",
            "            return self.parent.notebook_dir",
            "        except AttributeError:",
            "            return getcwd()",
            "",
            "    save_script = Bool(False, config=True, help='DEPRECATED, use post_save_hook')",
            "    def _save_script_changed(self):",
            "        self.log.warn(\"\"\"",
            "        `--script` is deprecated. You can trigger nbconvert via pre- or post-save hooks:",
            "",
            "            ContentsManager.pre_save_hook",
            "            FileContentsManager.post_save_hook",
            "",
            "        A post-save hook has been registered that calls:",
            "",
            "            ipython nbconvert --to script [notebook]",
            "",
            "        which behaves similarly to `--script`.",
            "        \"\"\")",
            "",
            "        self.post_save_hook = _post_save_script",
            "",
            "    post_save_hook = Any(None, config=True,",
            "        help=\"\"\"Python callable or importstring thereof",
            "",
            "        to be called on the path of a file just saved.",
            "",
            "        This can be used to process the file on disk,",
            "        such as converting the notebook to a script or HTML via nbconvert.",
            "",
            "        It will be called as (all arguments passed by keyword)::",
            "",
            "            hook(os_path=os_path, model=model, contents_manager=instance)",
            "",
            "        - path: the filesystem path to the file just written",
            "        - model: the model representing the file",
            "        - contents_manager: this ContentsManager instance",
            "        \"\"\"",
            "    )",
            "    def _post_save_hook_changed(self, name, old, new):",
            "        if new and isinstance(new, string_types):",
            "            self.post_save_hook = import_item(self.post_save_hook)",
            "        elif new:",
            "            if not callable(new):",
            "                raise TraitError(\"post_save_hook must be callable\")",
            "",
            "    def run_post_save_hook(self, model, os_path):",
            "        \"\"\"Run the post-save hook if defined, and log errors\"\"\"",
            "        if self.post_save_hook:",
            "            try:",
            "                self.log.debug(\"Running post-save hook on %s\", os_path)",
            "                self.post_save_hook(os_path=os_path, model=model, contents_manager=self)",
            "            except Exception:",
            "                self.log.error(\"Post-save hook failed on %s\", os_path, exc_info=True)",
            "",
            "    def _root_dir_changed(self, name, old, new):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        if not os.path.isabs(new):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            self.root_dir = os.path.abspath(new)",
            "            return",
            "        if not os.path.isdir(new):",
            "            raise TraitError(\"%r is not a directory\" % new)",
            "",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.stat(os_path)",
            "        last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        created = tz.utcfromtimestamp(info.st_ctime)",
            "        # Create the base model.",
            "        model = {}",
            "        model['name'] = path.rsplit('/', 1)[-1]",
            "        model['path'] = path",
            "        model['last_modified'] = last_modified",
            "        model['created'] = created",
            "        model['content'] = None",
            "        model['format'] = None",
            "        model['mimetype'] = None",
            "        try:",
            "            model['writable'] = os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            model['writable'] = False",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = u'directory does not exist: %r' % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir):",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\",",
            "                os_path",
            "            )",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model['type'] = 'directory'",
            "        if content:",
            "            model['content'] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                os_path = os.path.join(os_dir, name)",
            "                # skip over broken symlinks in listing",
            "                if not os.path.exists(os_path):",
            "                    self.log.warn(\"%s doesn't exist\", os_path)",
            "                    continue",
            "                elif not os.path.isfile(os_path) and not os.path.isdir(os_path):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "                if self.should_list(name) and not is_hidden(os_path, self.root_dir):",
            "                    contents.append(self.get(",
            "                        path='%s/%s' % (path, name),",
            "                        content=False)",
            "                    )",
            "",
            "            model['format'] = 'json'",
            "",
            "        return model",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'file'",
            "",
            "        os_path = self._get_os_path(path)",
            "        model['mimetype'] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            if model['mimetype'] is None:",
            "                default_mime = {",
            "                    'text': 'text/plain',",
            "                    'base64': 'application/octet-stream'",
            "                }[format]",
            "                model['mimetype'] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'notebook'",
            "        if content:",
            "            os_path = self._get_os_path(path)",
            "            nb = self._read_notebook(os_path, as_version=4)",
            "            self.mark_trusted_cells(nb, path)",
            "            model['content'] = nb",
            "            model['format'] = 'json'",
            "            self.validate_notebook_model(model)",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\" Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, u'No such file or directory: %s' % path)",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, 'directory'):",
            "                raise web.HTTPError(400,",
            "                                u'%s is a directory, not a %s' % (path, type), reason='bad type')",
            "            model = self._dir_model(path, content=content)",
            "        elif type == 'notebook' or (type is None and path.endswith('.ipynb')):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == 'directory':",
            "                raise web.HTTPError(400,",
            "                                u'%s is not a directory' % path, reason='bad type')",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=''):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir):",
            "            raise web.HTTPError(400, u'Cannot create hidden directory %r' % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, u'Not a directory: %s' % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=''):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip('/')",
            "",
            "        if 'type' not in model:",
            "            raise web.HTTPError(400, u'No file type provided')",
            "        if 'content' not in model and model['type'] != 'directory':",
            "            raise web.HTTPError(400, u'No file content provided')",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        try:",
            "            if model['type'] == 'notebook':",
            "                nb = nbformat.from_dict(model['content'])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model['type'] == 'file':",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model['content'], model.get('format'))",
            "            elif model['type'] == 'directory':",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model['type'])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(u'Error while saving file: %s %s', path, e, exc_info=True)",
            "            raise web.HTTPError(500, u'Unexpected error while saving file: %s %s' % (path, e))",
            "",
            "        validation_message = None",
            "        if model['type'] == 'notebook':",
            "            self.validate_notebook_model(model)",
            "            validation_message = model.get('message', None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model['message'] = validation_message",
            "",
            "        self.run_post_save_hook(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if os.path.isdir(os_path):",
            "            listing = os.listdir(os_path)",
            "            # Don't delete non-empty directories.",
            "            # A directory containing only leftover checkpoints is",
            "            # considered empty.",
            "            cp_dir = getattr(self.checkpoints, 'checkpoint_dir', None)",
            "            for entry in listing:",
            "                if entry != cp_dir:",
            "                    raise web.HTTPError(400, u'Directory %s not empty' % os_path)",
            "        elif not os.path.isfile(os_path):",
            "            raise web.HTTPError(404, u'File does not exist: %s' % os_path)",
            "",
            "        if os.path.isdir(os_path):",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip('/')",
            "        new_path = new_path.strip('/')",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path):",
            "            raise web.HTTPError(409, u'File already exists: %s' % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, u'Unknown error renaming file: %s %s' % (old_path, e))",
            "",
            "    def info_string(self):",
            "        return \"Serving notebooks from local directory: %s\" % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if '/' in path:",
            "            parent_dir = path.rsplit('/', 1)[0]",
            "        else:",
            "            parent_dir = ''",
            "        return parent_dir"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "283": [
                "FileContentsManager",
                "_file_model"
            ],
            "284": [
                "FileContentsManager",
                "_file_model"
            ],
            "285": [
                "FileContentsManager",
                "_file_model"
            ],
            "286": [
                "FileContentsManager",
                "_file_model"
            ],
            "291": [
                "FileContentsManager",
                "_file_model"
            ]
        },
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create",
            "IPython.html.services.contents.filemanager.FileContentsManager.get"
        ]
    },
    "IPython/html/services/contents/handlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         )"
            },
            "1": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     maybe_none_keys = ['content', 'format']"
            },
            "3": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if model['type'] == 'file':"
            },
            "4": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # mimetype should be populated only for file models"
            },
            "5": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        maybe_none_keys.append('mimetype')"
            },
            "6": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     if expect_content:"
            },
            "7": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         errors = [key for key in maybe_none_keys if model[key] is None]"
            },
            "8": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         if errors:"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tornado handlers for the contents web service.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import json",
            "",
            "from tornado import gen, web",
            "",
            "from IPython.html.utils import url_path_join, url_escape",
            "from IPython.utils.jsonutil import date_default",
            "",
            "from IPython.html.base.handlers import (",
            "    IPythonHandler, APIHandler, json_errors, path_regex,",
            ")",
            "",
            "",
            "def sort_key(model):",
            "    \"\"\"key function for case-insensitive sort by name and type\"\"\"",
            "    iname = model['name'].lower()",
            "    type_key = {",
            "        'directory' : '0',",
            "        'notebook'  : '1',",
            "        'file'      : '2',",
            "    }.get(model['type'], '9')",
            "    return u'%s%s' % (type_key, iname)",
            "",
            "",
            "def validate_model(model, expect_content):",
            "    \"\"\"",
            "    Validate a model returned by a ContentsManager method.",
            "",
            "    If expect_content is True, then we expect non-null entries for 'content'",
            "    and 'format'.",
            "    \"\"\"",
            "    required_keys = {",
            "        \"name\",",
            "        \"path\",",
            "        \"type\",",
            "        \"writable\",",
            "        \"created\",",
            "        \"last_modified\",",
            "        \"mimetype\",",
            "        \"content\",",
            "        \"format\",",
            "    }",
            "    missing = required_keys - set(model.keys())",
            "    if missing:",
            "        raise web.HTTPError(",
            "            500,",
            "            u\"Missing Model Keys: {missing}\".format(missing=missing),",
            "        )",
            "",
            "    maybe_none_keys = ['content', 'format']",
            "    if model['type'] == 'file':",
            "        # mimetype should be populated only for file models",
            "        maybe_none_keys.append('mimetype')",
            "    if expect_content:",
            "        errors = [key for key in maybe_none_keys if model[key] is None]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                u\"Keys unexpectedly None: {keys}\".format(keys=errors),",
            "            )",
            "    else:",
            "        errors = {",
            "            key: model[key]",
            "            for key in maybe_none_keys",
            "            if model[key] is not None",
            "        }",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                u\"Keys unexpectedly not None: {keys}\".format(keys=errors),",
            "            )",
            "",
            "",
            "class ContentsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = (u'GET', u'PUT', u'PATCH', u'POST', u'DELETE')",
            "",
            "    def location_url(self, path):",
            "        \"\"\"Return the full URL location of a file.",
            "",
            "        Parameters",
            "        ----------",
            "        path : unicode",
            "            The API path of the file, such as \"foo/bar.txt\".",
            "        \"\"\"",
            "        return url_escape(url_path_join(",
            "            self.base_url, 'api', 'contents', path",
            "        ))",
            "",
            "    def _finish_model(self, model, location=True):",
            "        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"",
            "        if location:",
            "            location = self.location_url(model['path'])",
            "            self.set_header('Location', location)",
            "        self.set_header('Last-Modified', model['last_modified'])",
            "        self.set_header('Content-Type', 'application/json')",
            "        self.finish(json.dumps(model, default=date_default))",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def get(self, path=''):",
            "        \"\"\"Return a model for a file or directory.",
            "",
            "        A directory model contains a list of models (without content)",
            "        of the files and directories it contains.",
            "        \"\"\"",
            "        path = path or ''",
            "        type = self.get_query_argument('type', default=None)",
            "        if type not in {None, 'directory', 'file', 'notebook'}:",
            "            raise web.HTTPError(400, u'Type %r is invalid' % type)",
            "",
            "        format = self.get_query_argument('format', default=None)",
            "        if format not in {None, 'text', 'base64'}:",
            "            raise web.HTTPError(400, u'Format %r is invalid' % format)",
            "        content = self.get_query_argument('content', default='1')",
            "        if content not in {'0', '1'}:",
            "            raise web.HTTPError(400, u'Content %r is invalid' % content)",
            "        content = int(content)",
            "        ",
            "        model = yield gen.maybe_future(self.contents_manager.get(",
            "            path=path, type=type, format=format, content=content,",
            "        ))",
            "        if model['type'] == 'directory' and content:",
            "            # group listing by type, then by name (case-insensitive)",
            "            # FIXME: sorting should be done in the frontends",
            "            model['content'].sort(key=sort_key)",
            "        validate_model(model, expect_content=content)",
            "        self._finish_model(model, location=False)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def patch(self, path=''):",
            "        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"",
            "        cm = self.contents_manager",
            "        model = self.get_json_body()",
            "        if model is None:",
            "            raise web.HTTPError(400, u'JSON body missing')",
            "        model = yield gen.maybe_future(cm.update(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _copy(self, copy_from, copy_to=None):",
            "        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"",
            "        self.log.info(u\"Copying {copy_from} to {copy_to}\".format(",
            "            copy_from=copy_from,",
            "            copy_to=copy_to or '',",
            "        ))",
            "        model = yield gen.maybe_future(self.contents_manager.copy(copy_from, copy_to))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @gen.coroutine",
            "    def _upload(self, model, path):",
            "        \"\"\"Handle upload of a new file to path\"\"\"",
            "        self.log.info(u\"Uploading file to %s\", path)",
            "        model = yield gen.maybe_future(self.contents_manager.new(model, path))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _new_untitled(self, path, type='', ext=''):",
            "        \"\"\"Create a new, empty untitled entity\"\"\"",
            "        self.log.info(u\"Creating new %s in %s\", type or 'file', path)",
            "        model = yield gen.maybe_future(self.contents_manager.new_untitled(path=path, type=type, ext=ext))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _save(self, model, path):",
            "        \"\"\"Save an existing file.\"\"\"",
            "        self.log.info(u\"Saving file at %s\", path)",
            "        model = yield gen.maybe_future(self.contents_manager.save(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path=''):",
            "        \"\"\"Create a new file in the specified path.",
            "",
            "        POST creates new files. The server always decides on the name.",
            "",
            "        POST /api/contents/path",
            "          New untitled, empty file or directory.",
            "        POST /api/contents/path",
            "          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}",
            "          New copy of OtherNotebook in path",
            "        \"\"\"",
            "",
            "        cm = self.contents_manager",
            "",
            "        if cm.file_exists(path):",
            "            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")",
            "",
            "        if not cm.dir_exists(path):",
            "            raise web.HTTPError(404, \"No such directory: %s\" % path)",
            "",
            "        model = self.get_json_body()",
            "",
            "        if model is not None:",
            "            copy_from = model.get('copy_from')",
            "            ext = model.get('ext', '')",
            "            type = model.get('type', '')",
            "            if copy_from:",
            "                yield self._copy(copy_from, path)",
            "            else:",
            "                yield self._new_untitled(path, type=type, ext=ext)",
            "        else:",
            "            yield self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def put(self, path=''):",
            "        \"\"\"Saves the file in the location specified by name and path.",
            "",
            "        PUT is very similar to POST, but the requester specifies the name,",
            "        whereas with POST, the server picks the name.",
            "",
            "        PUT /api/contents/path/Name.ipynb",
            "          Save notebook at ``path/Name.ipynb``. Notebook structure is specified",
            "          in `content` key of JSON request body. If content is not specified,",
            "          create a new empty notebook.",
            "        \"\"\"",
            "        model = self.get_json_body()",
            "        if model:",
            "            if model.get('copy_from'):",
            "                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")",
            "            exists = yield gen.maybe_future(self.contents_manager.file_exists(path))",
            "            if exists:",
            "                yield gen.maybe_future(self._save(model, path))",
            "            else:",
            "                yield gen.maybe_future(self._upload(model, path))",
            "        else:",
            "            yield gen.maybe_future(self._new_untitled(path))",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def delete(self, path=''):",
            "        \"\"\"delete a file in the given path\"\"\"",
            "        cm = self.contents_manager",
            "        self.log.warn('delete %s', path)",
            "        yield gen.maybe_future(cm.delete(path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class CheckpointsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = ('GET', 'POST')",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def get(self, path=''):",
            "        \"\"\"get lists checkpoints for a file\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoints = yield gen.maybe_future(cm.list_checkpoints(path))",
            "        data = json.dumps(checkpoints, default=date_default)",
            "        self.finish(data)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path=''):",
            "        \"\"\"post creates a new checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoint = yield gen.maybe_future(cm.create_checkpoint(path))",
            "        data = json.dumps(checkpoint, default=date_default)",
            "        location = url_path_join(self.base_url, 'api/contents',",
            "            path, 'checkpoints', checkpoint['id'])",
            "        self.set_header('Location', url_escape(location))",
            "        self.set_status(201)",
            "        self.finish(data)",
            "",
            "",
            "class ModifyCheckpointsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = ('POST', 'DELETE')",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path, checkpoint_id):",
            "        \"\"\"post restores a file from a checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        yield gen.maybe_future(cm.restore_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def delete(self, path, checkpoint_id):",
            "        \"\"\"delete clears a checkpoint for a given file\"\"\"",
            "        cm = self.contents_manager",
            "        yield gen.maybe_future(cm.delete_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class NotebooksRedirectHandler(IPythonHandler):",
            "    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"",
            "    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH', 'POST', 'DELETE')",
            "",
            "    def get(self, path):",
            "        self.log.warn(\"/api/notebooks is deprecated, use /api/contents\")",
            "        self.redirect(url_path_join(",
            "            self.base_url,",
            "            'api/contents',",
            "            path",
            "        ))",
            "",
            "    put = patch = post = delete = get",
            "",
            "",
            "#-----------------------------------------------------------------------------",
            "# URL to handler mappings",
            "#-----------------------------------------------------------------------------",
            "",
            "",
            "_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"",
            "",
            "default_handlers = [",
            "    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),",
            "    (r\"/api/contents%s/checkpoints/%s\" % (path_regex, _checkpoint_id_regex),",
            "        ModifyCheckpointsHandler),",
            "    (r\"/api/contents%s\" % path_regex, ContentsHandler),",
            "    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"Tornado handlers for the contents web service.\"\"\"",
            "",
            "# Copyright (c) IPython Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import json",
            "",
            "from tornado import gen, web",
            "",
            "from IPython.html.utils import url_path_join, url_escape",
            "from IPython.utils.jsonutil import date_default",
            "",
            "from IPython.html.base.handlers import (",
            "    IPythonHandler, APIHandler, json_errors, path_regex,",
            ")",
            "",
            "",
            "def sort_key(model):",
            "    \"\"\"key function for case-insensitive sort by name and type\"\"\"",
            "    iname = model['name'].lower()",
            "    type_key = {",
            "        'directory' : '0',",
            "        'notebook'  : '1',",
            "        'file'      : '2',",
            "    }.get(model['type'], '9')",
            "    return u'%s%s' % (type_key, iname)",
            "",
            "",
            "def validate_model(model, expect_content):",
            "    \"\"\"",
            "    Validate a model returned by a ContentsManager method.",
            "",
            "    If expect_content is True, then we expect non-null entries for 'content'",
            "    and 'format'.",
            "    \"\"\"",
            "    required_keys = {",
            "        \"name\",",
            "        \"path\",",
            "        \"type\",",
            "        \"writable\",",
            "        \"created\",",
            "        \"last_modified\",",
            "        \"mimetype\",",
            "        \"content\",",
            "        \"format\",",
            "    }",
            "    missing = required_keys - set(model.keys())",
            "    if missing:",
            "        raise web.HTTPError(",
            "            500,",
            "            u\"Missing Model Keys: {missing}\".format(missing=missing),",
            "        )",
            "",
            "    maybe_none_keys = ['content', 'format']",
            "    if expect_content:",
            "        errors = [key for key in maybe_none_keys if model[key] is None]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                u\"Keys unexpectedly None: {keys}\".format(keys=errors),",
            "            )",
            "    else:",
            "        errors = {",
            "            key: model[key]",
            "            for key in maybe_none_keys",
            "            if model[key] is not None",
            "        }",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                u\"Keys unexpectedly not None: {keys}\".format(keys=errors),",
            "            )",
            "",
            "",
            "class ContentsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = (u'GET', u'PUT', u'PATCH', u'POST', u'DELETE')",
            "",
            "    def location_url(self, path):",
            "        \"\"\"Return the full URL location of a file.",
            "",
            "        Parameters",
            "        ----------",
            "        path : unicode",
            "            The API path of the file, such as \"foo/bar.txt\".",
            "        \"\"\"",
            "        return url_escape(url_path_join(",
            "            self.base_url, 'api', 'contents', path",
            "        ))",
            "",
            "    def _finish_model(self, model, location=True):",
            "        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"",
            "        if location:",
            "            location = self.location_url(model['path'])",
            "            self.set_header('Location', location)",
            "        self.set_header('Last-Modified', model['last_modified'])",
            "        self.set_header('Content-Type', 'application/json')",
            "        self.finish(json.dumps(model, default=date_default))",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def get(self, path=''):",
            "        \"\"\"Return a model for a file or directory.",
            "",
            "        A directory model contains a list of models (without content)",
            "        of the files and directories it contains.",
            "        \"\"\"",
            "        path = path or ''",
            "        type = self.get_query_argument('type', default=None)",
            "        if type not in {None, 'directory', 'file', 'notebook'}:",
            "            raise web.HTTPError(400, u'Type %r is invalid' % type)",
            "",
            "        format = self.get_query_argument('format', default=None)",
            "        if format not in {None, 'text', 'base64'}:",
            "            raise web.HTTPError(400, u'Format %r is invalid' % format)",
            "        content = self.get_query_argument('content', default='1')",
            "        if content not in {'0', '1'}:",
            "            raise web.HTTPError(400, u'Content %r is invalid' % content)",
            "        content = int(content)",
            "        ",
            "        model = yield gen.maybe_future(self.contents_manager.get(",
            "            path=path, type=type, format=format, content=content,",
            "        ))",
            "        if model['type'] == 'directory' and content:",
            "            # group listing by type, then by name (case-insensitive)",
            "            # FIXME: sorting should be done in the frontends",
            "            model['content'].sort(key=sort_key)",
            "        validate_model(model, expect_content=content)",
            "        self._finish_model(model, location=False)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def patch(self, path=''):",
            "        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"",
            "        cm = self.contents_manager",
            "        model = self.get_json_body()",
            "        if model is None:",
            "            raise web.HTTPError(400, u'JSON body missing')",
            "        model = yield gen.maybe_future(cm.update(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _copy(self, copy_from, copy_to=None):",
            "        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"",
            "        self.log.info(u\"Copying {copy_from} to {copy_to}\".format(",
            "            copy_from=copy_from,",
            "            copy_to=copy_to or '',",
            "        ))",
            "        model = yield gen.maybe_future(self.contents_manager.copy(copy_from, copy_to))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @gen.coroutine",
            "    def _upload(self, model, path):",
            "        \"\"\"Handle upload of a new file to path\"\"\"",
            "        self.log.info(u\"Uploading file to %s\", path)",
            "        model = yield gen.maybe_future(self.contents_manager.new(model, path))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _new_untitled(self, path, type='', ext=''):",
            "        \"\"\"Create a new, empty untitled entity\"\"\"",
            "        self.log.info(u\"Creating new %s in %s\", type or 'file', path)",
            "        model = yield gen.maybe_future(self.contents_manager.new_untitled(path=path, type=type, ext=ext))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "    ",
            "    @gen.coroutine",
            "    def _save(self, model, path):",
            "        \"\"\"Save an existing file.\"\"\"",
            "        self.log.info(u\"Saving file at %s\", path)",
            "        model = yield gen.maybe_future(self.contents_manager.save(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path=''):",
            "        \"\"\"Create a new file in the specified path.",
            "",
            "        POST creates new files. The server always decides on the name.",
            "",
            "        POST /api/contents/path",
            "          New untitled, empty file or directory.",
            "        POST /api/contents/path",
            "          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}",
            "          New copy of OtherNotebook in path",
            "        \"\"\"",
            "",
            "        cm = self.contents_manager",
            "",
            "        if cm.file_exists(path):",
            "            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")",
            "",
            "        if not cm.dir_exists(path):",
            "            raise web.HTTPError(404, \"No such directory: %s\" % path)",
            "",
            "        model = self.get_json_body()",
            "",
            "        if model is not None:",
            "            copy_from = model.get('copy_from')",
            "            ext = model.get('ext', '')",
            "            type = model.get('type', '')",
            "            if copy_from:",
            "                yield self._copy(copy_from, path)",
            "            else:",
            "                yield self._new_untitled(path, type=type, ext=ext)",
            "        else:",
            "            yield self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def put(self, path=''):",
            "        \"\"\"Saves the file in the location specified by name and path.",
            "",
            "        PUT is very similar to POST, but the requester specifies the name,",
            "        whereas with POST, the server picks the name.",
            "",
            "        PUT /api/contents/path/Name.ipynb",
            "          Save notebook at ``path/Name.ipynb``. Notebook structure is specified",
            "          in `content` key of JSON request body. If content is not specified,",
            "          create a new empty notebook.",
            "        \"\"\"",
            "        model = self.get_json_body()",
            "        if model:",
            "            if model.get('copy_from'):",
            "                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")",
            "            exists = yield gen.maybe_future(self.contents_manager.file_exists(path))",
            "            if exists:",
            "                yield gen.maybe_future(self._save(model, path))",
            "            else:",
            "                yield gen.maybe_future(self._upload(model, path))",
            "        else:",
            "            yield gen.maybe_future(self._new_untitled(path))",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def delete(self, path=''):",
            "        \"\"\"delete a file in the given path\"\"\"",
            "        cm = self.contents_manager",
            "        self.log.warn('delete %s', path)",
            "        yield gen.maybe_future(cm.delete(path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class CheckpointsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = ('GET', 'POST')",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def get(self, path=''):",
            "        \"\"\"get lists checkpoints for a file\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoints = yield gen.maybe_future(cm.list_checkpoints(path))",
            "        data = json.dumps(checkpoints, default=date_default)",
            "        self.finish(data)",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path=''):",
            "        \"\"\"post creates a new checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoint = yield gen.maybe_future(cm.create_checkpoint(path))",
            "        data = json.dumps(checkpoint, default=date_default)",
            "        location = url_path_join(self.base_url, 'api/contents',",
            "            path, 'checkpoints', checkpoint['id'])",
            "        self.set_header('Location', url_escape(location))",
            "        self.set_status(201)",
            "        self.finish(data)",
            "",
            "",
            "class ModifyCheckpointsHandler(APIHandler):",
            "",
            "    SUPPORTED_METHODS = ('POST', 'DELETE')",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def post(self, path, checkpoint_id):",
            "        \"\"\"post restores a file from a checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        yield gen.maybe_future(cm.restore_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @web.authenticated",
            "    @json_errors",
            "    @gen.coroutine",
            "    def delete(self, path, checkpoint_id):",
            "        \"\"\"delete clears a checkpoint for a given file\"\"\"",
            "        cm = self.contents_manager",
            "        yield gen.maybe_future(cm.delete_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class NotebooksRedirectHandler(IPythonHandler):",
            "    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"",
            "    SUPPORTED_METHODS = ('GET', 'PUT', 'PATCH', 'POST', 'DELETE')",
            "",
            "    def get(self, path):",
            "        self.log.warn(\"/api/notebooks is deprecated, use /api/contents\")",
            "        self.redirect(url_path_join(",
            "            self.base_url,",
            "            'api/contents',",
            "            path",
            "        ))",
            "",
            "    put = patch = post = delete = get",
            "",
            "",
            "#-----------------------------------------------------------------------------",
            "# URL to handler mappings",
            "#-----------------------------------------------------------------------------",
            "",
            "",
            "_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"",
            "",
            "default_handlers = [",
            "    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),",
            "    (r\"/api/contents%s/checkpoints/%s\" % (path_regex, _checkpoint_id_regex),",
            "        ModifyCheckpointsHandler),",
            "    (r\"/api/contents%s\" % path_regex, ContentsHandler),",
            "    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "55": [
                "validate_model"
            ],
            "56": [
                "validate_model"
            ],
            "57": [
                "validate_model"
            ]
        },
        "addLocation": []
    }
}