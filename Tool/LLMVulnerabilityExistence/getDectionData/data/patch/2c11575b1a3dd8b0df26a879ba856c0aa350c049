{
    "opencanary/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import os"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import subprocess"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+"
            },
            "3": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " __version__ = \"0.9.3\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from os import PathLike"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from typing import Union"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+BIN_LOCATIONS = [\"/usr/bin\", \"/bin\", \"/usr/sbin\", \"/sbin\"]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+def _check_file_exists_and_executable(path: Union[PathLike, str]) -> bool:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    if not os.path.isfile(path):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+        return False"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    else:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+        return os.access(path, os.X_OK)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+def safe_exec(binary_name: str, args: list) -> bytes:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    \"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    Executes the given binary with the given arguments as a subprocess. What makes this safe is that the binary name"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    is not executed as an alias, and only binaries that live in trusted system locations are executed. This means that"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    only system-wide binaries are executable."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    exec_path = None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    for prefix in BIN_LOCATIONS:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        bin_path = os.path.join(prefix, binary_name)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        if _check_file_exists_and_executable(os.path.join(prefix, binary_name)):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            exec_path = bin_path"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            break"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    if exec_path is None:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        raise Exception(f\"Could not find executable ${binary_name}\")"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    else:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        return subprocess.check_output(args, shell=True, executable=exec_path)"
            }
        },
        "frontPatchFile": [
            "__version__ = \"0.9.3\""
        ],
        "afterPatchFile": [
            "import os",
            "import subprocess",
            "",
            "__version__ = \"0.9.3\"",
            "",
            "from os import PathLike",
            "from typing import Union",
            "",
            "BIN_LOCATIONS = [\"/usr/bin\", \"/bin\", \"/usr/sbin\", \"/sbin\"]",
            "",
            "",
            "def _check_file_exists_and_executable(path: Union[PathLike, str]) -> bool:",
            "    if not os.path.isfile(path):",
            "        return False",
            "    else:",
            "        return os.access(path, os.X_OK)",
            "",
            "",
            "def safe_exec(binary_name: str, args: list) -> bytes:",
            "    \"\"\"",
            "    Executes the given binary with the given arguments as a subprocess. What makes this safe is that the binary name",
            "    is not executed as an alias, and only binaries that live in trusted system locations are executed. This means that",
            "    only system-wide binaries are executable.",
            "    \"\"\"",
            "    exec_path = None",
            "    for prefix in BIN_LOCATIONS:",
            "        bin_path = os.path.join(prefix, binary_name)",
            "        if _check_file_exists_and_executable(os.path.join(prefix, binary_name)):",
            "            exec_path = bin_path",
            "            break",
            "    if exec_path is None:",
            "        raise Exception(f\"Could not find executable ${binary_name}\")",
            "    else:",
            "        return subprocess.check_output(args, shell=True, executable=exec_path)"
        ],
        "action": [
            "-1",
            "-1",
            "-1",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "label_studio.core.settings.base"
        ]
    },
    "opencanary/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import itertools"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import string"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import subprocess"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import shutil"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import re"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from os.path import expanduser"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from pkg_resources import resource_filename"
            },
            "8": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from pathlib import Path"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from . import safe_exec"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " SAMPLE_SETTINGS = resource_filename(__name__, \"data/settings.json\")"
            },
            "12": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " SETTINGS = \"opencanary.conf\""
            },
            "13": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         self.__configfile = configfile"
            },
            "14": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         files = ["
            },
            "16": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            configfile,"
            },
            "17": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"%s/.%s\" % (expanduser(\"~\"), configfile),"
            },
            "18": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             \"/etc/opencanaryd/%s\" % configfile,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            \"%s/.%s\" % (expanduser(\"~\"), configfile),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+            configfile,"
            },
            "21": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         ]"
            },
            "22": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         print("
            },
            "23": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             \"** We hope you enjoy using OpenCanary. For more open source Canary goodness, head over to canarytokens.org. **\""
            },
            "24": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "                     print(\"[-] Using config file: %s\" % fname)"
            },
            "25": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "                     self.__config = json.load(f)"
            },
            "26": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                     self.__config = expand_vars(self.__config)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                if fname is configfile:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                    print("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                        \"[-] Warning, making use of the configuration file in the immediate directory is not recommended! Suggested locations: %s\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                        % \", \".join(files[:2])"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                    )"
            },
            "32": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                 return"
            },
            "33": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             except IOError as e:"
            },
            "34": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "                 print(\"[-] Failed to open %s for reading (%s)\" % (fname, e))"
            },
            "35": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             except ValueError as e:"
            },
            "36": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "                 print(\"[-] Failed to decode json from %s (%s)\" % (fname, e))"
            },
            "37": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                subprocess.call("
            },
            "38": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"cp -r %s /var/tmp/config-err-$(date +%%s)\" % fname, shell=True"
            },
            "39": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                safe_exec(\"cp\", [\"-r\", fname, \"/var/tmp/config-err-$(date +%%s)\"])"
            },
            "41": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             except Exception as e:"
            },
            "42": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "                 print(\"[-] An error occurred loading %s (%s)\" % (fname, e))"
            },
            "43": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         if self.__config is None:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import sys",
            "import json",
            "import itertools",
            "import string",
            "import subprocess",
            "import shutil",
            "import re",
            "from os.path import expanduser",
            "from pkg_resources import resource_filename",
            "from pathlib import Path",
            "",
            "SAMPLE_SETTINGS = resource_filename(__name__, \"data/settings.json\")",
            "SETTINGS = \"opencanary.conf\"",
            "",
            "",
            "def expand_vars(var):",
            "    \"\"\"Recursively replace environment variables in a dictionary, list or string with their respective values.\"\"\"",
            "    if isinstance(var, dict):",
            "        for key, value in var.items():",
            "            var[key] = expand_vars(value)",
            "        return var",
            "    if isinstance(var, (list, set, tuple)):",
            "        return [expand_vars(v) for v in var]",
            "    if isinstance(var, (str, bytes)):",
            "        return os.path.expandvars(var)",
            "    return var",
            "",
            "",
            "def is_docker():",
            "    cgroup = Path(\"/proc/self/cgroup\")",
            "    return (",
            "        Path(\"/.dockerenv\").is_file()",
            "        or cgroup.is_file()",
            "        and \"docker\" in cgroup.read_text()",
            "    )",
            "",
            "",
            "def detectIPTables():",
            "    if shutil.which(\"iptables\"):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "SERVICE_REGEXES = {",
            "    \"ssh.version\": r\"(SSH-(2.0|1.5|1.99|1.0)-([!-,\\-./0-~]+(:?$|\\s))(?:[ -~]*)){1,253}$\",",
            "}",
            "",
            "",
            "class Config:",
            "    def __init__(self, configfile=SETTINGS):",
            "        self.__config = None",
            "        self.__configfile = configfile",
            "",
            "        files = [",
            "            configfile,",
            "            \"%s/.%s\" % (expanduser(\"~\"), configfile),",
            "            \"/etc/opencanaryd/%s\" % configfile,",
            "        ]",
            "        print(",
            "            \"** We hope you enjoy using OpenCanary. For more open source Canary goodness, head over to canarytokens.org. **\"",
            "        )",
            "        for fname in files:",
            "            try:",
            "                with open(fname, \"r\") as f:",
            "                    print(\"[-] Using config file: %s\" % fname)",
            "                    self.__config = json.load(f)",
            "                    self.__config = expand_vars(self.__config)",
            "                return",
            "            except IOError as e:",
            "                print(\"[-] Failed to open %s for reading (%s)\" % (fname, e))",
            "            except ValueError as e:",
            "                print(\"[-] Failed to decode json from %s (%s)\" % (fname, e))",
            "                subprocess.call(",
            "                    \"cp -r %s /var/tmp/config-err-$(date +%%s)\" % fname, shell=True",
            "                )",
            "            except Exception as e:",
            "                print(\"[-] An error occurred loading %s (%s)\" % (fname, e))",
            "        if self.__config is None:",
            "            print(",
            "                'No config file found. Please create one with \"opencanaryd --copyconfig\"'",
            "            )",
            "            sys.exit(1)",
            "",
            "    def moduleEnabled(self, module_name):",
            "        k = \"%s.enabled\" % module_name.lower()",
            "        if k in self.__config:",
            "            return bool(self.__config[k])",
            "        return False",
            "",
            "    def getVal(self, key, default=None):",
            "        # throw exception to caller",
            "        try:",
            "            return self.__config[key]",
            "        except KeyError as e:",
            "            if default is not None:",
            "                return default",
            "            raise e",
            "",
            "    def checkValues(self):  # noqa: C901",
            "        \"\"\"Set all the valid values in params and return a list of errors for invalid\"\"\"",
            "        params = self.__config",
            "        # test options indpenedently for validity",
            "        errors = []",
            "        for key, value in params.items():",
            "            try:",
            "                self.is_valid(key, value)",
            "            except ConfigException as e:",
            "                errors.append(e)",
            "",
            "        # Test that no ports overlap",
            "        ports = {k: int(v) for k, v in params.items() if k.endswith(\".port\")}",
            "        ports = [(port, setting) for setting, port in ports.items()]",
            "        ports.sort()",
            "",
            "        for port, settings in itertools.groupby(ports, lambda x: x[0]):",
            "            settings = list(settings)",
            "            if len(settings) > 1:",
            "                services = \", \".join([s[1].split(\".\")[0] for s in settings])",
            "                errmsg = \"More than one service uses this port (%s)\" % services",
            "                for port, setting in settings:",
            "                    errors.append(ConfigException(setting, errmsg))",
            "",
            "        return errors",
            "",
            "    def is_valid(self, key, val):  # noqa: C901",
            "        \"\"\"",
            "        Test an the validity of an individual setting",
            "        Raise config error message on failure.",
            "        TODO: delegate module tests to appropriate module",
            "        \"\"\"",
            "",
            "        if key.endswith(\".enabled\"):",
            "            if not ((val is True) or (val is False)):",
            "                raise ConfigException(",
            "                    key, \"Boolean setting is not True or False (%s)\" % val",
            "                )",
            "",
            "        if key.endswith(\".port\"):",
            "            if not isinstance(val, int):",
            "                raise ConfigException(",
            "                    key, \"Invalid port number (%s). Must be an integer.\" % val",
            "                )",
            "            if val < 1 or val > 65535:",
            "                raise ConfigException(",
            "                    key, \"Invalid port number (%s). Must be between 1 and 65535.\" % val",
            "                )",
            "        # Max length of SSH version string is 255 chars including trailing CR and LF",
            "        # https://tools.ietf.org/html/rfc4253",
            "        if key == \"ssh.version\" and len(val) > 253:",
            "            raise ConfigException(key, \"SSH version string too long (%s..)\" % val[:5])",
            "",
            "        if key == \"device.name\":",
            "            allowed_chars = string.ascii_letters + string.digits + \"+-#_\"",
            "",
            "            if len(val) > 100:",
            "                raise ConfigException(key, \"Name cannot be longer than 100 characters\")",
            "            elif len(val) < 1:",
            "                raise ConfigException(key, \"Name ought to be at least one character\")",
            "            elif any(map(lambda x: x not in allowed_chars, val)):",
            "                raise ConfigException(",
            "                    key,",
            "                    \"Please use only characters, digits, any of the following: + - # _\",",
            "                )",
            "",
            "        if key == \"device.desc\":",
            "            allowed_chars = string.ascii_letters + string.digits + \"+-#_ \"",
            "            if len(val) > 100:",
            "                raise ConfigException(key, \"Name cannot be longer than 100 characters\")",
            "            elif len(val) < 1:",
            "                raise ConfigException(key, \"Name ought to be at least one character\")",
            "            elif any(map(lambda x: x not in allowed_chars, val)):",
            "                raise ConfigException(",
            "                    key,",
            "                    \"Please use only characters, digits, spaces and any of the following: + - # _\",",
            "                )",
            "",
            "        if key in SERVICE_REGEXES.keys():",
            "            if not re.match(SERVICE_REGEXES[key], val):",
            "                raise ConfigException(key, f\"{val} is not valid.\")",
            "",
            "        return True",
            "",
            "    def __repr__(self):",
            "        return self.__config.__repr__()",
            "",
            "    def __str__(self):",
            "        return self.__config.__str__()",
            "",
            "    def toDict(self):",
            "        \"\"\"Return all settings as a dict\"\"\"",
            "        return self.__config",
            "",
            "    def toJSON(self):",
            "        \"\"\"",
            "        JSON representation of config",
            "        \"\"\"",
            "        return json.dumps(",
            "            self.__config, sort_keys=True, indent=4, separators=(\",\", \": \")",
            "        )",
            "",
            "",
            "class ConfigException(Exception):",
            "    \"\"\"Exception raised on invalid config value\"\"\"",
            "",
            "    def __init__(self, key, msg):",
            "        self.key = key",
            "        self.msg = msg",
            "",
            "    def __str__(self):",
            "        return \"%s: %s\" % (self.key, self.msg)",
            "",
            "    def __repr__(self):",
            "        return \"<%s %s (%s)>\" % (self.__class__.__name__, self.key, self.msg)",
            "",
            "",
            "config = Config()",
            "errors = config.checkValues()",
            "if errors:",
            "    for error in errors:",
            "        print(error)",
            "    sys.exit(1)"
        ],
        "afterPatchFile": [
            "import os",
            "import sys",
            "import json",
            "import itertools",
            "import string",
            "import shutil",
            "import re",
            "from os.path import expanduser",
            "from pkg_resources import resource_filename",
            "from pathlib import Path",
            "from . import safe_exec",
            "",
            "SAMPLE_SETTINGS = resource_filename(__name__, \"data/settings.json\")",
            "SETTINGS = \"opencanary.conf\"",
            "",
            "",
            "def expand_vars(var):",
            "    \"\"\"Recursively replace environment variables in a dictionary, list or string with their respective values.\"\"\"",
            "    if isinstance(var, dict):",
            "        for key, value in var.items():",
            "            var[key] = expand_vars(value)",
            "        return var",
            "    if isinstance(var, (list, set, tuple)):",
            "        return [expand_vars(v) for v in var]",
            "    if isinstance(var, (str, bytes)):",
            "        return os.path.expandvars(var)",
            "    return var",
            "",
            "",
            "def is_docker():",
            "    cgroup = Path(\"/proc/self/cgroup\")",
            "    return (",
            "        Path(\"/.dockerenv\").is_file()",
            "        or cgroup.is_file()",
            "        and \"docker\" in cgroup.read_text()",
            "    )",
            "",
            "",
            "def detectIPTables():",
            "    if shutil.which(\"iptables\"):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "SERVICE_REGEXES = {",
            "    \"ssh.version\": r\"(SSH-(2.0|1.5|1.99|1.0)-([!-,\\-./0-~]+(:?$|\\s))(?:[ -~]*)){1,253}$\",",
            "}",
            "",
            "",
            "class Config:",
            "    def __init__(self, configfile=SETTINGS):",
            "        self.__config = None",
            "        self.__configfile = configfile",
            "",
            "        files = [",
            "            \"/etc/opencanaryd/%s\" % configfile,",
            "            \"%s/.%s\" % (expanduser(\"~\"), configfile),",
            "            configfile,",
            "        ]",
            "        print(",
            "            \"** We hope you enjoy using OpenCanary. For more open source Canary goodness, head over to canarytokens.org. **\"",
            "        )",
            "        for fname in files:",
            "            try:",
            "                with open(fname, \"r\") as f:",
            "                    print(\"[-] Using config file: %s\" % fname)",
            "                    self.__config = json.load(f)",
            "                    self.__config = expand_vars(self.__config)",
            "                if fname is configfile:",
            "                    print(",
            "                        \"[-] Warning, making use of the configuration file in the immediate directory is not recommended! Suggested locations: %s\"",
            "                        % \", \".join(files[:2])",
            "                    )",
            "                return",
            "            except IOError as e:",
            "                print(\"[-] Failed to open %s for reading (%s)\" % (fname, e))",
            "            except ValueError as e:",
            "                print(\"[-] Failed to decode json from %s (%s)\" % (fname, e))",
            "                safe_exec(\"cp\", [\"-r\", fname, \"/var/tmp/config-err-$(date +%%s)\"])",
            "            except Exception as e:",
            "                print(\"[-] An error occurred loading %s (%s)\" % (fname, e))",
            "        if self.__config is None:",
            "            print(",
            "                'No config file found. Please create one with \"opencanaryd --copyconfig\"'",
            "            )",
            "            sys.exit(1)",
            "",
            "    def moduleEnabled(self, module_name):",
            "        k = \"%s.enabled\" % module_name.lower()",
            "        if k in self.__config:",
            "            return bool(self.__config[k])",
            "        return False",
            "",
            "    def getVal(self, key, default=None):",
            "        # throw exception to caller",
            "        try:",
            "            return self.__config[key]",
            "        except KeyError as e:",
            "            if default is not None:",
            "                return default",
            "            raise e",
            "",
            "    def checkValues(self):  # noqa: C901",
            "        \"\"\"Set all the valid values in params and return a list of errors for invalid\"\"\"",
            "        params = self.__config",
            "        # test options indpenedently for validity",
            "        errors = []",
            "        for key, value in params.items():",
            "            try:",
            "                self.is_valid(key, value)",
            "            except ConfigException as e:",
            "                errors.append(e)",
            "",
            "        # Test that no ports overlap",
            "        ports = {k: int(v) for k, v in params.items() if k.endswith(\".port\")}",
            "        ports = [(port, setting) for setting, port in ports.items()]",
            "        ports.sort()",
            "",
            "        for port, settings in itertools.groupby(ports, lambda x: x[0]):",
            "            settings = list(settings)",
            "            if len(settings) > 1:",
            "                services = \", \".join([s[1].split(\".\")[0] for s in settings])",
            "                errmsg = \"More than one service uses this port (%s)\" % services",
            "                for port, setting in settings:",
            "                    errors.append(ConfigException(setting, errmsg))",
            "",
            "        return errors",
            "",
            "    def is_valid(self, key, val):  # noqa: C901",
            "        \"\"\"",
            "        Test an the validity of an individual setting",
            "        Raise config error message on failure.",
            "        TODO: delegate module tests to appropriate module",
            "        \"\"\"",
            "",
            "        if key.endswith(\".enabled\"):",
            "            if not ((val is True) or (val is False)):",
            "                raise ConfigException(",
            "                    key, \"Boolean setting is not True or False (%s)\" % val",
            "                )",
            "",
            "        if key.endswith(\".port\"):",
            "            if not isinstance(val, int):",
            "                raise ConfigException(",
            "                    key, \"Invalid port number (%s). Must be an integer.\" % val",
            "                )",
            "            if val < 1 or val > 65535:",
            "                raise ConfigException(",
            "                    key, \"Invalid port number (%s). Must be between 1 and 65535.\" % val",
            "                )",
            "        # Max length of SSH version string is 255 chars including trailing CR and LF",
            "        # https://tools.ietf.org/html/rfc4253",
            "        if key == \"ssh.version\" and len(val) > 253:",
            "            raise ConfigException(key, \"SSH version string too long (%s..)\" % val[:5])",
            "",
            "        if key == \"device.name\":",
            "            allowed_chars = string.ascii_letters + string.digits + \"+-#_\"",
            "",
            "            if len(val) > 100:",
            "                raise ConfigException(key, \"Name cannot be longer than 100 characters\")",
            "            elif len(val) < 1:",
            "                raise ConfigException(key, \"Name ought to be at least one character\")",
            "            elif any(map(lambda x: x not in allowed_chars, val)):",
            "                raise ConfigException(",
            "                    key,",
            "                    \"Please use only characters, digits, any of the following: + - # _\",",
            "                )",
            "",
            "        if key == \"device.desc\":",
            "            allowed_chars = string.ascii_letters + string.digits + \"+-#_ \"",
            "            if len(val) > 100:",
            "                raise ConfigException(key, \"Name cannot be longer than 100 characters\")",
            "            elif len(val) < 1:",
            "                raise ConfigException(key, \"Name ought to be at least one character\")",
            "            elif any(map(lambda x: x not in allowed_chars, val)):",
            "                raise ConfigException(",
            "                    key,",
            "                    \"Please use only characters, digits, spaces and any of the following: + - # _\",",
            "                )",
            "",
            "        if key in SERVICE_REGEXES.keys():",
            "            if not re.match(SERVICE_REGEXES[key], val):",
            "                raise ConfigException(key, f\"{val} is not valid.\")",
            "",
            "        return True",
            "",
            "    def __repr__(self):",
            "        return self.__config.__repr__()",
            "",
            "    def __str__(self):",
            "        return self.__config.__str__()",
            "",
            "    def toDict(self):",
            "        \"\"\"Return all settings as a dict\"\"\"",
            "        return self.__config",
            "",
            "    def toJSON(self):",
            "        \"\"\"",
            "        JSON representation of config",
            "        \"\"\"",
            "        return json.dumps(",
            "            self.__config, sort_keys=True, indent=4, separators=(\",\", \": \")",
            "        )",
            "",
            "",
            "class ConfigException(Exception):",
            "    \"\"\"Exception raised on invalid config value\"\"\"",
            "",
            "    def __init__(self, key, msg):",
            "        self.key = key",
            "        self.msg = msg",
            "",
            "    def __str__(self):",
            "        return \"%s: %s\" % (self.key, self.msg)",
            "",
            "    def __repr__(self):",
            "        return \"<%s %s (%s)>\" % (self.__class__.__name__, self.key, self.msg)",
            "",
            "",
            "config = Config()",
            "errors = config.checkValues()",
            "if errors:",
            "    for error in errors:",
            "        print(error)",
            "    sys.exit(1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "57": [
                "Config",
                "__init__"
            ],
            "58": [
                "Config",
                "__init__"
            ],
            "75": [
                "Config",
                "__init__"
            ],
            "76": [
                "Config",
                "__init__"
            ],
            "77": [
                "Config",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "opencanary/modules/portscan.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from opencanary.modules import CanaryService"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from opencanary.modules import FileSystemWatcher"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from opencanary import safe_exec"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import os"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import shutil"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import subprocess"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " class SynLogWatcher(FileSystemWatcher):"
            },
            "9": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " def detectNFTables():"
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return b\"nf_tables\" in subprocess.check_output([\"iptables\", \"--version\"])"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    return b\"nf_tables\" in safe_exec(\"iptables\", [\"--version\"])"
            },
            "14": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " class CanaryPortscan(CanaryService):"
            }
        },
        "frontPatchFile": [
            "from opencanary.modules import CanaryService",
            "from opencanary.modules import FileSystemWatcher",
            "import os",
            "import shutil",
            "import subprocess",
            "",
            "",
            "class SynLogWatcher(FileSystemWatcher):",
            "    def __init__(",
            "        self, logger=None, logFile=None, ignore_localhost=False, ignore_ports=None",
            "    ):",
            "        if ignore_ports is None:",
            "            ignore_ports = []",
            "        self.logger = logger",
            "        self.ignore_localhost = ignore_localhost",
            "        self.ignore_ports = ignore_ports",
            "        FileSystemWatcher.__init__(self, fileName=logFile)",
            "",
            "    def handleLines(self, lines=None):  # noqa: C901",
            "        for line in lines:",
            "            try:",
            "                if \"canaryfw: \" in line:",
            "                    logtype = self.logger.LOG_PORT_SYN",
            "                    (rubbish, log) = line.split(\"canaryfw: \")",
            "                elif \"canarynmapNULL\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPNULL",
            "                    (rubbish, log) = line.split(\"canarynmapNULL: \")",
            "                elif \"canarynmapXMAS\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPXMAS",
            "                    (rubbish, log) = line.split(\"canarynmapXMAS: \")",
            "                elif \"canarynmapFIN\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPFIN",
            "                    (rubbish, log) = line.split(\"canarynmapFIN: \")",
            "                elif \"canarynmap: \" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPOS",
            "                    (rubbish, log) = line.split(\"canarynmap: \")",
            "                else:",
            "                    continue",
            "            except ValueError:",
            "                continue",
            "            tags = log.split(\" \")",
            "            kv = {}",
            "            for tag in tags:",
            "                if tag.find(\"=\") >= 0:",
            "                    (key, val) = tag.split(\"=\")",
            "                else:",
            "                    key = tag",
            "                    val = \"\"",
            "                kv[key] = val",
            "",
            "            # we've seen empty tags creep in. weed them out.",
            "            if \"\" in kv.keys():",
            "                kv.pop(\"\")",
            "",
            "            data = {}",
            "            data[\"src_host\"] = kv.pop(\"SRC\")",
            "            data[\"src_port\"] = kv.pop(\"SPT\")",
            "            data[\"dst_host\"] = kv.pop(\"DST\")",
            "            data[\"dst_port\"] = kv.pop(\"DPT\")",
            "            data[\"logtype\"] = logtype",
            "            data[\"logdata\"] = kv",
            "            if self.ignore_localhost and data.get(\"src_host\", False) == \"127.0.0.1\":",
            "                continue",
            "            if int(data.get(\"dst_port\", -1)) in self.ignore_ports:",
            "                continue",
            "",
            "            self.logger.log(data)",
            "",
            "",
            "def detectNFTables():",
            "    return b\"nf_tables\" in subprocess.check_output([\"iptables\", \"--version\"])",
            "",
            "",
            "class CanaryPortscan(CanaryService):",
            "    NAME = \"portscan\"",
            "",
            "    def __init__(self, config=None, logger=None):",
            "        CanaryService.__init__(self, config=config, logger=logger)",
            "        self.audit_file = config.getVal(\"portscan.logfile\", default=\"/var/log/kern.log\")",
            "        self.synrate = int(config.getVal(\"portscan.synrate\", default=5))",
            "        self.nmaposrate = int(config.getVal(\"portscan.nmaposrate\", default=\"5\"))",
            "        self.lorate = int(config.getVal(\"portscan.lorate\", default=\"3\"))",
            "        self.listen_addr = config.getVal(\"device.listen_addr\", default=\"\")",
            "        self.ignore_localhost = config.getVal(",
            "            \"portscan.ignore_localhost\", default=False",
            "        )",
            "        self.ignore_ports = config.getVal(\"portscan.ignore_ports\", default=[])",
            "        self.iptables_path = self.config.getVal(\"portscan.iptables_path\", False)",
            "        self.config = config",
            "",
            "    def getIptablesPath(self):",
            "        if self.iptables_path:",
            "            return self.iptables_path",
            "",
            "        if detectNFTables():",
            "            return shutil.which(\"iptables-legacy\")",
            "",
            "        return shutil.which(\"iptables\") or \"/sbin/iptables\"",
            "",
            "    def startYourEngines(self, reactor=None):",
            "        # Logging rules for loopback interface.",
            "        # This is separate from the canaryfw rule as the canary watchdog was",
            "        # causing console-side noise in the logs.",
            "        self.set_iptables_rules()",
            "",
            "        fs = SynLogWatcher(",
            "            logFile=self.audit_file,",
            "            logger=self.logger,",
            "            ignore_localhost=self.ignore_localhost,",
            "            ignore_ports=self.ignore_ports,",
            "        )",
            "        fs.start()",
            "",
            "    def configUpdated(",
            "        self,",
            "    ):",
            "        pass",
            "",
            "    def set_iptables_rules(self):",
            "        iptables_path = self.getIptablesPath()",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -i lo -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/hour\"'.format(",
            "                iptables_path, self.lorate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -i lo -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/hour\"'.format(",
            "                iptables_path, self.lorate",
            "            )",
            "        )",
            "",
            "        # Logging rules for canaryfw.",
            "        # We ignore loopback interface traffic as it is taken care of in above rule",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp --syn -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/second\" ! -i lo'.format(",
            "                iptables_path, self.synrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp --syn -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/second\" ! -i lo'.format(",
            "                iptables_path, self.synrate",
            "            )",
            "        )",
            "",
            "        # Match the T3 probe of the nmap OS detection based on TCP flags and TCP options string",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -m u32 --u32 \"40=0x03030A01 && 44=0x02040109 && 48=0x080Affff && 52=0xffff0000 && 56=0x00000402\" -j LOG --log-level=warning --log-prefix=\"canarynmap: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -m u32 --u32 \"40=0x03030A01 && 44=0x02040109 && 48=0x080Affff && 52=0xffff0000 && 56=0x00000402\" -j LOG --log-level=warning --log-prefix=\"canarynmap: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Null Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50000400\" -j LOG --log-level=warning --log-prefix=\"canarynmapNULL: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50000400\" -j LOG --log-level=warning --log-prefix=\"canarynmapNULL: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Xmas Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50290400\" -j LOG --log-level=warning --log-prefix=\"canarynmapXMAS: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50290400\" -j LOG --log-level=warning --log-prefix=\"canarynmapXMAS: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Fin Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50010400\" -j LOG --log-level=warning --log-prefix=\"canarynmapFIN: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50010400\" -j LOG --log-level=warning --log-prefix=\"canarynmapFIN: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )"
        ],
        "afterPatchFile": [
            "from opencanary.modules import CanaryService",
            "from opencanary.modules import FileSystemWatcher",
            "from opencanary import safe_exec",
            "import os",
            "import shutil",
            "",
            "",
            "class SynLogWatcher(FileSystemWatcher):",
            "    def __init__(",
            "        self, logger=None, logFile=None, ignore_localhost=False, ignore_ports=None",
            "    ):",
            "        if ignore_ports is None:",
            "            ignore_ports = []",
            "        self.logger = logger",
            "        self.ignore_localhost = ignore_localhost",
            "        self.ignore_ports = ignore_ports",
            "        FileSystemWatcher.__init__(self, fileName=logFile)",
            "",
            "    def handleLines(self, lines=None):  # noqa: C901",
            "        for line in lines:",
            "            try:",
            "                if \"canaryfw: \" in line:",
            "                    logtype = self.logger.LOG_PORT_SYN",
            "                    (rubbish, log) = line.split(\"canaryfw: \")",
            "                elif \"canarynmapNULL\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPNULL",
            "                    (rubbish, log) = line.split(\"canarynmapNULL: \")",
            "                elif \"canarynmapXMAS\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPXMAS",
            "                    (rubbish, log) = line.split(\"canarynmapXMAS: \")",
            "                elif \"canarynmapFIN\" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPFIN",
            "                    (rubbish, log) = line.split(\"canarynmapFIN: \")",
            "                elif \"canarynmap: \" in line:",
            "                    logtype = self.logger.LOG_PORT_NMAPOS",
            "                    (rubbish, log) = line.split(\"canarynmap: \")",
            "                else:",
            "                    continue",
            "            except ValueError:",
            "                continue",
            "            tags = log.split(\" \")",
            "            kv = {}",
            "            for tag in tags:",
            "                if tag.find(\"=\") >= 0:",
            "                    (key, val) = tag.split(\"=\")",
            "                else:",
            "                    key = tag",
            "                    val = \"\"",
            "                kv[key] = val",
            "",
            "            # we've seen empty tags creep in. weed them out.",
            "            if \"\" in kv.keys():",
            "                kv.pop(\"\")",
            "",
            "            data = {}",
            "            data[\"src_host\"] = kv.pop(\"SRC\")",
            "            data[\"src_port\"] = kv.pop(\"SPT\")",
            "            data[\"dst_host\"] = kv.pop(\"DST\")",
            "            data[\"dst_port\"] = kv.pop(\"DPT\")",
            "            data[\"logtype\"] = logtype",
            "            data[\"logdata\"] = kv",
            "            if self.ignore_localhost and data.get(\"src_host\", False) == \"127.0.0.1\":",
            "                continue",
            "            if int(data.get(\"dst_port\", -1)) in self.ignore_ports:",
            "                continue",
            "",
            "            self.logger.log(data)",
            "",
            "",
            "def detectNFTables():",
            "    return b\"nf_tables\" in safe_exec(\"iptables\", [\"--version\"])",
            "",
            "",
            "class CanaryPortscan(CanaryService):",
            "    NAME = \"portscan\"",
            "",
            "    def __init__(self, config=None, logger=None):",
            "        CanaryService.__init__(self, config=config, logger=logger)",
            "        self.audit_file = config.getVal(\"portscan.logfile\", default=\"/var/log/kern.log\")",
            "        self.synrate = int(config.getVal(\"portscan.synrate\", default=5))",
            "        self.nmaposrate = int(config.getVal(\"portscan.nmaposrate\", default=\"5\"))",
            "        self.lorate = int(config.getVal(\"portscan.lorate\", default=\"3\"))",
            "        self.listen_addr = config.getVal(\"device.listen_addr\", default=\"\")",
            "        self.ignore_localhost = config.getVal(",
            "            \"portscan.ignore_localhost\", default=False",
            "        )",
            "        self.ignore_ports = config.getVal(\"portscan.ignore_ports\", default=[])",
            "        self.iptables_path = self.config.getVal(\"portscan.iptables_path\", False)",
            "        self.config = config",
            "",
            "    def getIptablesPath(self):",
            "        if self.iptables_path:",
            "            return self.iptables_path",
            "",
            "        if detectNFTables():",
            "            return shutil.which(\"iptables-legacy\")",
            "",
            "        return shutil.which(\"iptables\") or \"/sbin/iptables\"",
            "",
            "    def startYourEngines(self, reactor=None):",
            "        # Logging rules for loopback interface.",
            "        # This is separate from the canaryfw rule as the canary watchdog was",
            "        # causing console-side noise in the logs.",
            "        self.set_iptables_rules()",
            "",
            "        fs = SynLogWatcher(",
            "            logFile=self.audit_file,",
            "            logger=self.logger,",
            "            ignore_localhost=self.ignore_localhost,",
            "            ignore_ports=self.ignore_ports,",
            "        )",
            "        fs.start()",
            "",
            "    def configUpdated(",
            "        self,",
            "    ):",
            "        pass",
            "",
            "    def set_iptables_rules(self):",
            "        iptables_path = self.getIptablesPath()",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -i lo -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/hour\"'.format(",
            "                iptables_path, self.lorate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -i lo -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/hour\"'.format(",
            "                iptables_path, self.lorate",
            "            )",
            "        )",
            "",
            "        # Logging rules for canaryfw.",
            "        # We ignore loopback interface traffic as it is taken care of in above rule",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp --syn -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/second\" ! -i lo'.format(",
            "                iptables_path, self.synrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp --syn -j LOG --log-level=warning --log-prefix=\"canaryfw: \" -m limit --limit=\"{1}/second\" ! -i lo'.format(",
            "                iptables_path, self.synrate",
            "            )",
            "        )",
            "",
            "        # Match the T3 probe of the nmap OS detection based on TCP flags and TCP options string",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -m u32 --u32 \"40=0x03030A01 && 44=0x02040109 && 48=0x080Affff && 52=0xffff0000 && 56=0x00000402\" -j LOG --log-level=warning --log-prefix=\"canarynmap: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp --tcp-flags ALL URG,PSH,SYN,FIN -m u32 --u32 \"40=0x03030A01 && 44=0x02040109 && 48=0x080Affff && 52=0xffff0000 && 56=0x00000402\" -j LOG --log-level=warning --log-prefix=\"canarynmap: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Null Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50000400\" -j LOG --log-level=warning --log-prefix=\"canarynmapNULL: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50000400\" -j LOG --log-level=warning --log-prefix=\"canarynmapNULL: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Xmas Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50290400\" -j LOG --log-level=warning --log-prefix=\"canarynmapXMAS: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50290400\" -j LOG --log-level=warning --log-prefix=\"canarynmapXMAS: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "",
            "        # Nmap Fin Scan",
            "        os.system(",
            "            'sudo {0} -t mangle -D PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50010400\" -j LOG --log-level=warning --log-prefix=\"canarynmapFIN: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )",
            "        os.system(",
            "            'sudo {0} -t mangle -A PREROUTING -p tcp -m u32 --u32 \"6&0xFF=0x6 && 0>>22&0x3C@12=0x50010400\" -j LOG --log-level=warning --log-prefix=\"canarynmapFIN: \" -m limit --limit=\"{1}/second\"'.format(",
            "                iptables_path, self.nmaposrate",
            "            )",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "71": [
                "detectNFTables"
            ]
        },
        "addLocation": []
    }
}