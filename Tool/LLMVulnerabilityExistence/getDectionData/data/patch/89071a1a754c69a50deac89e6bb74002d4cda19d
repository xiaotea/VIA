{
    "sydent/http/httpcommon.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from twisted.web._newclient import ResponseDone"
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from twisted.web.http import PotentialDataLoss"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from twisted.web.iweb import UNKNOWN_LENGTH"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from twisted.web import server"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "7": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+# Arbitrarily limited to 512 KiB."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+MAX_REQUEST_SIZE = 512 * 1024"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " class SslComponents:"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     def __init__(self, sydent):"
            },
            "14": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         self.sydent = sydent"
            },
            "15": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "                 fp = open(caCertFilename)"
            },
            "16": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "                 caCert = twisted.internet.ssl.Certificate.loadPEM(fp.read())"
            },
            "17": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                 fp.close()"
            },
            "18": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            except Exception:"
            },
            "20": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "                 logger.warn(\"Failed to open CA cert file %s\", caCertFilename)"
            },
            "21": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "                 raise"
            },
            "22": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             logger.warn(\"Using custom CA cert file: %s\", caCertFilename)"
            },
            "23": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             return twisted.internet.ssl.OpenSSLDefaultPaths()"
            },
            "24": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "27": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " class BodyExceededMaxSize(Exception):"
            },
            "28": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\""
            },
            "29": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "             # discarded anyway."
            },
            "31": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             self.transport.abortConnection()"
            },
            "32": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def connectionLost(self, reason = connectionDone) -> None:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    def connectionLost(self, reason=connectionDone) -> None:"
            },
            "35": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         # If the maximum size was already exceeded, there's nothing to do."
            },
            "36": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         if self.deferred.called:"
            },
            "37": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             return"
            },
            "38": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     response.deliverBody(_ReadBodyWithMaxSizeProtocol(d, max_size))"
            },
            "40": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     return d"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+class SizeLimitingRequest(server.Request):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    def handleContentChunk(self, data):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        if self.content.tell() + len(data) > MAX_REQUEST_SIZE:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            logger.info("
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+                \"Aborting connection from %s because the request exceeds maximum size\","
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+                self.client.host)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            self.transport.abortConnection()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            return"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        return super().handleContentChunk(data)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from io import BytesIO",
            "",
            "import twisted.internet.ssl",
            "from twisted.internet import defer, protocol",
            "from twisted.internet.protocol import connectionDone",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.iweb import UNKNOWN_LENGTH",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "class SslComponents:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        self.myPrivateCertificate = self.makeMyCertificate()",
            "        self.trustRoot = self.makeTrustRoot()",
            "",
            "    def makeMyCertificate(self):",
            "        privKeyAndCertFilename = self.sydent.cfg.get('http', 'replication.https.certfile')",
            "        if privKeyAndCertFilename == '':",
            "            logger.warn(\"No HTTPS private key / cert found: not starting replication server \"",
            "                        \"or doing replication pushes\")",
            "            return None",
            "",
            "        try:",
            "            fp = open(privKeyAndCertFilename)",
            "        except IOError:",
            "            logger.warn(\"Unable to read private key / cert file from %s: not starting the replication HTTPS server \"",
            "                        \"or doing replication pushes.\",",
            "                        privKeyAndCertFilename)",
            "            return None",
            "",
            "        authData = fp.read()",
            "        fp.close()",
            "        return twisted.internet.ssl.PrivateCertificate.loadPEM(authData)",
            "",
            "    def makeTrustRoot(self):",
            "        # If this option is specified, use a specific root CA cert. This is useful for testing when it's not",
            "        # practical to get the client cert signed by a real root CA but should never be used on a production server.",
            "        caCertFilename = self.sydent.cfg.get('http', 'replication.https.cacert')",
            "        if len(caCertFilename) > 0:",
            "            try:",
            "                fp = open(caCertFilename)",
            "                caCert = twisted.internet.ssl.Certificate.loadPEM(fp.read())",
            "                fp.close()",
            "            except:",
            "                logger.warn(\"Failed to open CA cert file %s\", caCertFilename)",
            "                raise",
            "            logger.warn(\"Using custom CA cert file: %s\", caCertFilename)",
            "            return twisted.internet._sslverify.OpenSSLCertificateAuthorities([caCert.original])",
            "        else:",
            "            return twisted.internet.ssl.OpenSSLDefaultPaths()",
            "",
            "",
            "",
            "class BodyExceededMaxSize(Exception):",
            "    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"",
            "",
            "",
            "class _DiscardBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which immediately errors upon receiving data.\"\"\"",
            "",
            "    def __init__(self, deferred):",
            "        self.deferred = deferred",
            "",
            "    def _maybe_fail(self):",
            "        \"\"\"",
            "        Report a max size exceed error and disconnect the first time this is called.",
            "        \"\"\"",
            "        if not self.deferred.called:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            self.transport.abortConnection()",
            "",
            "    def dataReceived(self, data) -> None:",
            "        self._maybe_fail()",
            "",
            "    def connectionLost(self, reason) -> None:",
            "        self._maybe_fail()",
            "",
            "",
            "class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which reads body to a stream, erroring if the body exceeds a maximum size.\"\"\"",
            "",
            "    def __init__(self, deferred, max_size):",
            "        self.stream = BytesIO()",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data) -> None:",
            "        # If the deferred was called, bail early.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        self.stream.write(data)",
            "        self.length += len(data)",
            "        # The first time the maximum size is exceeded, error and cancel the",
            "        # connection. dataReceived might be called again if data was received",
            "        # in the meantime.",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason = connectionDone) -> None:",
            "        # If the maximum size was already exceeded, there's nothing to do.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.stream.getvalue())",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.stream.getvalue())",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def read_body_with_max_size(response, max_size):",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    If the maximum file size is reached, the returned Deferred will resolve to a",
            "    Failure with a BodyExceededMaxSize exception.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the read body.",
            "    \"\"\"",
            "    d = defer.Deferred()",
            "",
            "    # If the Content-Length header gives a size larger than the maximum allowed",
            "    # size, do not bother downloading the body.",
            "    if max_size is not None and response.length != UNKNOWN_LENGTH:",
            "        if response.length > max_size:",
            "            response.deliverBody(_DiscardBodyWithMaxSizeProtocol(d))",
            "            return d",
            "",
            "    response.deliverBody(_ReadBodyWithMaxSizeProtocol(d, max_size))",
            "    return d"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from io import BytesIO",
            "",
            "import twisted.internet.ssl",
            "from twisted.internet import defer, protocol",
            "from twisted.internet.protocol import connectionDone",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.iweb import UNKNOWN_LENGTH",
            "from twisted.web import server",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "# Arbitrarily limited to 512 KiB.",
            "MAX_REQUEST_SIZE = 512 * 1024",
            "",
            "",
            "class SslComponents:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        self.myPrivateCertificate = self.makeMyCertificate()",
            "        self.trustRoot = self.makeTrustRoot()",
            "",
            "    def makeMyCertificate(self):",
            "        privKeyAndCertFilename = self.sydent.cfg.get('http', 'replication.https.certfile')",
            "        if privKeyAndCertFilename == '':",
            "            logger.warn(\"No HTTPS private key / cert found: not starting replication server \"",
            "                        \"or doing replication pushes\")",
            "            return None",
            "",
            "        try:",
            "            fp = open(privKeyAndCertFilename)",
            "        except IOError:",
            "            logger.warn(\"Unable to read private key / cert file from %s: not starting the replication HTTPS server \"",
            "                        \"or doing replication pushes.\",",
            "                        privKeyAndCertFilename)",
            "            return None",
            "",
            "        authData = fp.read()",
            "        fp.close()",
            "        return twisted.internet.ssl.PrivateCertificate.loadPEM(authData)",
            "",
            "    def makeTrustRoot(self):",
            "        # If this option is specified, use a specific root CA cert. This is useful for testing when it's not",
            "        # practical to get the client cert signed by a real root CA but should never be used on a production server.",
            "        caCertFilename = self.sydent.cfg.get('http', 'replication.https.cacert')",
            "        if len(caCertFilename) > 0:",
            "            try:",
            "                fp = open(caCertFilename)",
            "                caCert = twisted.internet.ssl.Certificate.loadPEM(fp.read())",
            "                fp.close()",
            "            except Exception:",
            "                logger.warn(\"Failed to open CA cert file %s\", caCertFilename)",
            "                raise",
            "            logger.warn(\"Using custom CA cert file: %s\", caCertFilename)",
            "            return twisted.internet._sslverify.OpenSSLCertificateAuthorities([caCert.original])",
            "        else:",
            "            return twisted.internet.ssl.OpenSSLDefaultPaths()",
            "",
            "",
            "class BodyExceededMaxSize(Exception):",
            "    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"",
            "",
            "",
            "class _DiscardBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which immediately errors upon receiving data.\"\"\"",
            "",
            "    def __init__(self, deferred):",
            "        self.deferred = deferred",
            "",
            "    def _maybe_fail(self):",
            "        \"\"\"",
            "        Report a max size exceed error and disconnect the first time this is called.",
            "        \"\"\"",
            "        if not self.deferred.called:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            self.transport.abortConnection()",
            "",
            "    def dataReceived(self, data) -> None:",
            "        self._maybe_fail()",
            "",
            "    def connectionLost(self, reason) -> None:",
            "        self._maybe_fail()",
            "",
            "",
            "class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which reads body to a stream, erroring if the body exceeds a maximum size.\"\"\"",
            "",
            "    def __init__(self, deferred, max_size):",
            "        self.stream = BytesIO()",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data) -> None:",
            "        # If the deferred was called, bail early.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        self.stream.write(data)",
            "        self.length += len(data)",
            "        # The first time the maximum size is exceeded, error and cancel the",
            "        # connection. dataReceived might be called again if data was received",
            "        # in the meantime.",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason=connectionDone) -> None:",
            "        # If the maximum size was already exceeded, there's nothing to do.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.stream.getvalue())",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.stream.getvalue())",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def read_body_with_max_size(response, max_size):",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    If the maximum file size is reached, the returned Deferred will resolve to a",
            "    Failure with a BodyExceededMaxSize exception.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the read body.",
            "    \"\"\"",
            "    d = defer.Deferred()",
            "",
            "    # If the Content-Length header gives a size larger than the maximum allowed",
            "    # size, do not bother downloading the body.",
            "    if max_size is not None and response.length != UNKNOWN_LENGTH:",
            "        if response.length > max_size:",
            "            response.deliverBody(_DiscardBodyWithMaxSizeProtocol(d))",
            "            return d",
            "",
            "    response.deliverBody(_ReadBodyWithMaxSizeProtocol(d, max_size))",
            "    return d",
            "",
            "",
            "class SizeLimitingRequest(server.Request):",
            "    def handleContentChunk(self, data):",
            "        if self.content.tell() + len(data) > MAX_REQUEST_SIZE:",
            "            logger.info(",
            "                \"Aborting connection from %s because the request exceeds maximum size\",",
            "                self.client.host)",
            "            self.transport.abortConnection()",
            "            return",
            "",
            "        return super().handleContentChunk(data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "64": [
                "SslComponents",
                "makeTrustRoot"
            ],
            "73": [],
            "126": [
                "_ReadBodyWithMaxSizeProtocol",
                "connectionLost"
            ]
        },
        "addLocation": []
    },
    "sydent/http/httpserver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from sydent.http.servlets.authenticated_unbind_threepid_servlet import ("
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     AuthenticatedUnbindThreePidServlet,"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from sydent.http.httpcommon import SizeLimitingRequest"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         v2.putChild(b'hash_details', self.sydent.servlets.hash_details)"
            },
            "8": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         self.factory = Site(root)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        self.factory.requestFactory = SizeLimitingRequest"
            },
            "11": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         self.factory.displayTracebacks = False"
            },
            "12": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     def setup(self):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.server import Site",
            "from twisted.web.resource import Resource",
            "",
            "import logging",
            "import twisted.internet.ssl",
            "",
            "from sydent.http.servlets.authenticated_bind_threepid_servlet import (",
            "    AuthenticatedBindThreePidServlet,",
            ")",
            "from sydent.http.servlets.authenticated_unbind_threepid_servlet import (",
            "    AuthenticatedUnbindThreePidServlet,",
            ")",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ClientApiHttpServer:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        root = Resource()",
            "        matrix = Resource()",
            "        identity = Resource()",
            "        api = Resource()",
            "        v1 = self.sydent.servlets.v1",
            "        v2 = self.sydent.servlets.v2",
            "",
            "        validate = Resource()",
            "        validate_v2 = Resource()",
            "        email = Resource()",
            "        email_v2 = Resource()",
            "        msisdn = Resource()",
            "        msisdn_v2 = Resource()",
            "",
            "        threepid_v1 = Resource()",
            "        threepid_v2 = Resource()",
            "        unbind = self.sydent.servlets.threepidUnbind",
            "",
            "        pubkey = Resource()",
            "        ephemeralPubkey = Resource()",
            "",
            "        root.putChild(b'_matrix', matrix)",
            "        matrix.putChild(b'identity', identity)",
            "        identity.putChild(b'api', api)",
            "        identity.putChild(b'v2', v2)",
            "        api.putChild(b'v1', v1)",
            "",
            "        validate.putChild(b'email', email)",
            "        validate.putChild(b'msisdn', msisdn)",
            "",
            "        validate_v2.putChild(b'email', email_v2)",
            "        validate_v2.putChild(b'msisdn', msisdn_v2)",
            "",
            "        v1.putChild(b'validate', validate)",
            "",
            "        v1.putChild(b'lookup', self.sydent.servlets.lookup)",
            "        v1.putChild(b'bulk_lookup', self.sydent.servlets.bulk_lookup)",
            "",
            "        v1.putChild(b'pubkey', pubkey)",
            "        pubkey.putChild(b'isvalid', self.sydent.servlets.pubkeyIsValid)",
            "        pubkey.putChild(b'ed25519:0', self.sydent.servlets.pubkey_ed25519)",
            "        pubkey.putChild(b'ephemeral', ephemeralPubkey)",
            "        ephemeralPubkey.putChild(b'isvalid', self.sydent.servlets.ephemeralPubkeyIsValid)",
            "",
            "        threepid_v2.putChild(b'getValidated3pid', self.sydent.servlets.getValidated3pidV2)",
            "        threepid_v2.putChild(b'bind', self.sydent.servlets.threepidBindV2)",
            "        threepid_v2.putChild(b'unbind', unbind)",
            "",
            "        threepid_v1.putChild(b'getValidated3pid', self.sydent.servlets.getValidated3pid)",
            "        threepid_v1.putChild(b'unbind', unbind)",
            "        if self.sydent.enable_v1_associations:",
            "            threepid_v1.putChild(b'bind', self.sydent.servlets.threepidBind)",
            "",
            "        v1.putChild(b'3pid', threepid_v1)",
            "",
            "        email.putChild(b'requestToken', self.sydent.servlets.emailRequestCode)",
            "        email.putChild(b'submitToken', self.sydent.servlets.emailValidate)",
            "",
            "        email_v2.putChild(b'requestToken', self.sydent.servlets.emailRequestCodeV2)",
            "        email_v2.putChild(b'submitToken', self.sydent.servlets.emailValidateV2)",
            "",
            "        msisdn.putChild(b'requestToken', self.sydent.servlets.msisdnRequestCode)",
            "        msisdn.putChild(b'submitToken', self.sydent.servlets.msisdnValidate)",
            "",
            "        msisdn_v2.putChild(b'requestToken', self.sydent.servlets.msisdnRequestCodeV2)",
            "        msisdn_v2.putChild(b'submitToken', self.sydent.servlets.msisdnValidateV2)",
            "",
            "        v1.putChild(b'store-invite', self.sydent.servlets.storeInviteServlet)",
            "",
            "        v1.putChild(b'sign-ed25519', self.sydent.servlets.blindlySignStuffServlet)",
            "",
            "        # v2",
            "        # note v2 loses the /api so goes on 'identity' not 'api'",
            "        identity.putChild(b'v2', v2)",
            "",
            "        # v2 exclusive APIs",
            "        v2.putChild(b'terms', self.sydent.servlets.termsServlet)",
            "        account = self.sydent.servlets.accountServlet",
            "        v2.putChild(b'account', account)",
            "        account.putChild(b'register', self.sydent.servlets.registerServlet)",
            "        account.putChild(b'logout', self.sydent.servlets.logoutServlet)",
            "",
            "        # v2 versions of existing APIs",
            "        v2.putChild(b'validate', validate_v2)",
            "        v2.putChild(b'pubkey', pubkey)",
            "        v2.putChild(b'3pid', threepid_v2)",
            "        v2.putChild(b'store-invite', self.sydent.servlets.storeInviteServletV2)",
            "        v2.putChild(b'sign-ed25519', self.sydent.servlets.blindlySignStuffServletV2)",
            "        v2.putChild(b'lookup', self.sydent.servlets.lookup_v2)",
            "        v2.putChild(b'hash_details', self.sydent.servlets.hash_details)",
            "",
            "        self.factory = Site(root)",
            "        self.factory.displayTracebacks = False",
            "",
            "    def setup(self):",
            "        httpPort = int(self.sydent.cfg.get('http', 'clientapi.http.port'))",
            "        interface = self.sydent.cfg.get('http', 'clientapi.http.bind_address')",
            "        logger.info(\"Starting Client API HTTP server on %s:%d\", interface, httpPort)",
            "        self.sydent.reactor.listenTCP(",
            "            httpPort, self.factory, interface=interface,",
            "        )",
            "",
            "",
            "class InternalApiHttpServer(object):",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "    def setup(self, interface, port):",
            "        logger.info(\"Starting Internal API HTTP server on %s:%d\", interface, port)",
            "        root = Resource()",
            "",
            "        matrix = Resource()",
            "        root.putChild(b'_matrix', matrix)",
            "",
            "        identity = Resource()",
            "        matrix.putChild(b'identity', identity)",
            "",
            "        internal = Resource()",
            "        identity.putChild(b'internal', internal)",
            "",
            "        authenticated_bind = AuthenticatedBindThreePidServlet(self.sydent)",
            "        internal.putChild(b'bind', authenticated_bind)",
            "",
            "        authenticated_unbind = AuthenticatedUnbindThreePidServlet(self.sydent)",
            "        internal.putChild(b'unbind', authenticated_unbind)",
            "",
            "        factory = Site(root)",
            "        factory.displayTracebacks = False",
            "        self.sydent.reactor.listenTCP(port, factory, interface=interface)",
            "",
            "",
            "class ReplicationHttpsServer:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        root = Resource()",
            "        matrix = Resource()",
            "        identity = Resource()",
            "",
            "        root.putChild(b'_matrix', matrix)",
            "        matrix.putChild(b'identity', identity)",
            "",
            "        replicate = Resource()",
            "        replV1 = Resource()",
            "",
            "        identity.putChild(b'replicate', replicate)",
            "        replicate.putChild(b'v1', replV1)",
            "        replV1.putChild(b'push', self.sydent.servlets.replicationPush)",
            "",
            "        self.factory = Site(root)",
            "        self.factory.displayTracebacks = False",
            "",
            "    def setup(self):",
            "        httpPort = int(self.sydent.cfg.get('http', 'replication.https.port'))",
            "        interface = self.sydent.cfg.get('http', 'replication.https.bind_address')",
            "",
            "        if self.sydent.sslComponents.myPrivateCertificate:",
            "            # We will already have logged a warn if this is absent, so don't do it again",
            "            cert = self.sydent.sslComponents.myPrivateCertificate",
            "            certOptions = twisted.internet.ssl.CertificateOptions(privateKey=cert.privateKey.original,",
            "                                                                  certificate=cert.original,",
            "                                                                  trustRoot=self.sydent.sslComponents.trustRoot)",
            "",
            "            logger.info(\"Loaded server private key and certificate!\")",
            "            logger.info(\"Starting Replication HTTPS server on %s:%d\", interface, httpPort)",
            "",
            "            self.sydent.reactor.listenSSL(httpPort, self.factory, certOptions,",
            "                                          interface=interface)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.server import Site",
            "from twisted.web.resource import Resource",
            "",
            "import logging",
            "import twisted.internet.ssl",
            "",
            "from sydent.http.servlets.authenticated_bind_threepid_servlet import (",
            "    AuthenticatedBindThreePidServlet,",
            ")",
            "from sydent.http.servlets.authenticated_unbind_threepid_servlet import (",
            "    AuthenticatedUnbindThreePidServlet,",
            ")",
            "from sydent.http.httpcommon import SizeLimitingRequest",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ClientApiHttpServer:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        root = Resource()",
            "        matrix = Resource()",
            "        identity = Resource()",
            "        api = Resource()",
            "        v1 = self.sydent.servlets.v1",
            "        v2 = self.sydent.servlets.v2",
            "",
            "        validate = Resource()",
            "        validate_v2 = Resource()",
            "        email = Resource()",
            "        email_v2 = Resource()",
            "        msisdn = Resource()",
            "        msisdn_v2 = Resource()",
            "",
            "        threepid_v1 = Resource()",
            "        threepid_v2 = Resource()",
            "        unbind = self.sydent.servlets.threepidUnbind",
            "",
            "        pubkey = Resource()",
            "        ephemeralPubkey = Resource()",
            "",
            "        root.putChild(b'_matrix', matrix)",
            "        matrix.putChild(b'identity', identity)",
            "        identity.putChild(b'api', api)",
            "        identity.putChild(b'v2', v2)",
            "        api.putChild(b'v1', v1)",
            "",
            "        validate.putChild(b'email', email)",
            "        validate.putChild(b'msisdn', msisdn)",
            "",
            "        validate_v2.putChild(b'email', email_v2)",
            "        validate_v2.putChild(b'msisdn', msisdn_v2)",
            "",
            "        v1.putChild(b'validate', validate)",
            "",
            "        v1.putChild(b'lookup', self.sydent.servlets.lookup)",
            "        v1.putChild(b'bulk_lookup', self.sydent.servlets.bulk_lookup)",
            "",
            "        v1.putChild(b'pubkey', pubkey)",
            "        pubkey.putChild(b'isvalid', self.sydent.servlets.pubkeyIsValid)",
            "        pubkey.putChild(b'ed25519:0', self.sydent.servlets.pubkey_ed25519)",
            "        pubkey.putChild(b'ephemeral', ephemeralPubkey)",
            "        ephemeralPubkey.putChild(b'isvalid', self.sydent.servlets.ephemeralPubkeyIsValid)",
            "",
            "        threepid_v2.putChild(b'getValidated3pid', self.sydent.servlets.getValidated3pidV2)",
            "        threepid_v2.putChild(b'bind', self.sydent.servlets.threepidBindV2)",
            "        threepid_v2.putChild(b'unbind', unbind)",
            "",
            "        threepid_v1.putChild(b'getValidated3pid', self.sydent.servlets.getValidated3pid)",
            "        threepid_v1.putChild(b'unbind', unbind)",
            "        if self.sydent.enable_v1_associations:",
            "            threepid_v1.putChild(b'bind', self.sydent.servlets.threepidBind)",
            "",
            "        v1.putChild(b'3pid', threepid_v1)",
            "",
            "        email.putChild(b'requestToken', self.sydent.servlets.emailRequestCode)",
            "        email.putChild(b'submitToken', self.sydent.servlets.emailValidate)",
            "",
            "        email_v2.putChild(b'requestToken', self.sydent.servlets.emailRequestCodeV2)",
            "        email_v2.putChild(b'submitToken', self.sydent.servlets.emailValidateV2)",
            "",
            "        msisdn.putChild(b'requestToken', self.sydent.servlets.msisdnRequestCode)",
            "        msisdn.putChild(b'submitToken', self.sydent.servlets.msisdnValidate)",
            "",
            "        msisdn_v2.putChild(b'requestToken', self.sydent.servlets.msisdnRequestCodeV2)",
            "        msisdn_v2.putChild(b'submitToken', self.sydent.servlets.msisdnValidateV2)",
            "",
            "        v1.putChild(b'store-invite', self.sydent.servlets.storeInviteServlet)",
            "",
            "        v1.putChild(b'sign-ed25519', self.sydent.servlets.blindlySignStuffServlet)",
            "",
            "        # v2",
            "        # note v2 loses the /api so goes on 'identity' not 'api'",
            "        identity.putChild(b'v2', v2)",
            "",
            "        # v2 exclusive APIs",
            "        v2.putChild(b'terms', self.sydent.servlets.termsServlet)",
            "        account = self.sydent.servlets.accountServlet",
            "        v2.putChild(b'account', account)",
            "        account.putChild(b'register', self.sydent.servlets.registerServlet)",
            "        account.putChild(b'logout', self.sydent.servlets.logoutServlet)",
            "",
            "        # v2 versions of existing APIs",
            "        v2.putChild(b'validate', validate_v2)",
            "        v2.putChild(b'pubkey', pubkey)",
            "        v2.putChild(b'3pid', threepid_v2)",
            "        v2.putChild(b'store-invite', self.sydent.servlets.storeInviteServletV2)",
            "        v2.putChild(b'sign-ed25519', self.sydent.servlets.blindlySignStuffServletV2)",
            "        v2.putChild(b'lookup', self.sydent.servlets.lookup_v2)",
            "        v2.putChild(b'hash_details', self.sydent.servlets.hash_details)",
            "",
            "        self.factory = Site(root)",
            "        self.factory.requestFactory = SizeLimitingRequest",
            "        self.factory.displayTracebacks = False",
            "",
            "    def setup(self):",
            "        httpPort = int(self.sydent.cfg.get('http', 'clientapi.http.port'))",
            "        interface = self.sydent.cfg.get('http', 'clientapi.http.bind_address')",
            "        logger.info(\"Starting Client API HTTP server on %s:%d\", interface, httpPort)",
            "        self.sydent.reactor.listenTCP(",
            "            httpPort, self.factory, interface=interface,",
            "        )",
            "",
            "",
            "class InternalApiHttpServer(object):",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "    def setup(self, interface, port):",
            "        logger.info(\"Starting Internal API HTTP server on %s:%d\", interface, port)",
            "        root = Resource()",
            "",
            "        matrix = Resource()",
            "        root.putChild(b'_matrix', matrix)",
            "",
            "        identity = Resource()",
            "        matrix.putChild(b'identity', identity)",
            "",
            "        internal = Resource()",
            "        identity.putChild(b'internal', internal)",
            "",
            "        authenticated_bind = AuthenticatedBindThreePidServlet(self.sydent)",
            "        internal.putChild(b'bind', authenticated_bind)",
            "",
            "        authenticated_unbind = AuthenticatedUnbindThreePidServlet(self.sydent)",
            "        internal.putChild(b'unbind', authenticated_unbind)",
            "",
            "        factory = Site(root)",
            "        factory.displayTracebacks = False",
            "        self.sydent.reactor.listenTCP(port, factory, interface=interface)",
            "",
            "",
            "class ReplicationHttpsServer:",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "",
            "        root = Resource()",
            "        matrix = Resource()",
            "        identity = Resource()",
            "",
            "        root.putChild(b'_matrix', matrix)",
            "        matrix.putChild(b'identity', identity)",
            "",
            "        replicate = Resource()",
            "        replV1 = Resource()",
            "",
            "        identity.putChild(b'replicate', replicate)",
            "        replicate.putChild(b'v1', replV1)",
            "        replV1.putChild(b'push', self.sydent.servlets.replicationPush)",
            "",
            "        self.factory = Site(root)",
            "        self.factory.displayTracebacks = False",
            "",
            "    def setup(self):",
            "        httpPort = int(self.sydent.cfg.get('http', 'replication.https.port'))",
            "        interface = self.sydent.cfg.get('http', 'replication.https.bind_address')",
            "",
            "        if self.sydent.sslComponents.myPrivateCertificate:",
            "            # We will already have logged a warn if this is absent, so don't do it again",
            "            cert = self.sydent.sslComponents.myPrivateCertificate",
            "            certOptions = twisted.internet.ssl.CertificateOptions(privateKey=cert.privateKey.original,",
            "                                                                  certificate=cert.original,",
            "                                                                  trustRoot=self.sydent.sslComponents.trustRoot)",
            "",
            "            logger.info(\"Loaded server private key and certificate!\")",
            "            logger.info(\"Starting Replication HTTPS server on %s:%d\", interface, httpPort)",
            "",
            "            self.sydent.reactor.listenSSL(httpPort, self.factory, certOptions,",
            "                                          interface=interface)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "sydent.http.httpserver.ClientApiHttpServer",
            "pypdf.generic._data_structures"
        ]
    }
}