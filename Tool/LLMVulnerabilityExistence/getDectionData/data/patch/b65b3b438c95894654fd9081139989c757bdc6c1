{
    "nonebot/internal/adapter/template.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     overload,"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " )"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from _string import formatter_field_name_split  # type: ignore"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     from .message import Message, MessageSegment"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    def formatter_field_name_split(  # noqa: F811"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        field_name: str,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    ) -> Tuple[str, List[Tuple[bool, str]]]:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        ..."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " TM = TypeVar(\"TM\", bound=\"Message\")"
            },
            "15": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " TF = TypeVar(\"TF\", str, \"Message\")"
            },
            "16": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     \u53c2\u6570:"
            },
            "18": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         template: \u6a21\u677f"
            },
            "19": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         factory: \u6d88\u606f\u7c7b\u578b\u5de5\u5382\uff0c\u9ed8\u8ba4\u4e3a `str`"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        private_getattr: \u662f\u5426\u5141\u8bb8\u5728\u6a21\u677f\u4e2d\u8bbf\u95ee\u79c1\u6709\u5c5e\u6027\uff0c\u9ed8\u8ba4\u4e3a `False`"
            },
            "21": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     \"\"\""
            },
            "22": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     @overload"
            },
            "24": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def __init__("
            },
            "25": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self: \"MessageTemplate[str]\", template: str, factory: Type[str] = str"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        self: \"MessageTemplate[str]\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        template: str,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        factory: Type[str] = str,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        private_getattr: bool = False,"
            },
            "30": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     ) -> None:"
            },
            "31": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         ..."
            },
            "32": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     @overload"
            },
            "34": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     def __init__("
            },
            "35": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self: \"MessageTemplate[TM]\", template: Union[str, TM], factory: Type[TM]"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        self: \"MessageTemplate[TM]\","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        template: Union[str, TM],"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        factory: Type[TM],"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        private_getattr: bool = False,"
            },
            "40": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     ) -> None:"
            },
            "41": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         ..."
            },
            "42": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     def __init__("
            },
            "44": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, template: Union[str, TM], factory: Union[Type[str], Type[TM]] = str"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        self,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        template: Union[str, TM],"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        factory: Union[Type[str], Type[TM]] = str,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        private_getattr: bool = False,"
            },
            "49": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     ) -> None:"
            },
            "50": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         self.template: TF = template  # type: ignore"
            },
            "51": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         self.factory: Type[TF] = factory  # type: ignore"
            },
            "52": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self.format_specs: Dict[str, FormatSpecFunc] = {}"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        self.private_getattr = private_getattr"
            },
            "54": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     def __repr__(self) -> str:"
            },
            "56": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         return f\"MessageTemplate({self.template!r}, factory={self.factory!r})\""
            },
            "57": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         return functools.reduce(self._add, results), auto_arg_index"
            },
            "59": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+    def get_field("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        self, field_name: str, args: Sequence[Any], kwargs: Mapping[str, Any]"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+    ) -> Tuple[Any, Union[int, str]]:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        first, rest = formatter_field_name_split(field_name)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        obj = self.get_value(first, args, kwargs)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        for is_attr, value in rest:"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            if not self.private_getattr and value.startswith(\"_\"):"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                raise ValueError(\"Cannot access private attribute\")"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            obj = getattr(obj, value) if is_attr else obj[value]"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        return obj, first"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     def format_field(self, value: Any, format_spec: str) -> Any:"
            },
            "74": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         formatter: Optional[FormatSpecFunc] = self.format_specs.get(format_spec)"
            },
            "75": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         if formatter is None and not issubclass(self.factory, str):"
            }
        },
        "frontPatchFile": [
            "import functools",
            "from string import Formatter",
            "from typing_extensions import TypeAlias",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Set,",
            "    Dict,",
            "    List,",
            "    Type,",
            "    Tuple,",
            "    Union,",
            "    Generic,",
            "    Mapping,",
            "    TypeVar,",
            "    Callable,",
            "    Optional,",
            "    Sequence,",
            "    cast,",
            "    overload,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from .message import Message, MessageSegment",
            "",
            "TM = TypeVar(\"TM\", bound=\"Message\")",
            "TF = TypeVar(\"TF\", str, \"Message\")",
            "",
            "FormatSpecFunc: TypeAlias = Callable[[Any], str]",
            "FormatSpecFunc_T = TypeVar(\"FormatSpecFunc_T\", bound=FormatSpecFunc)",
            "",
            "",
            "class MessageTemplate(Formatter, Generic[TF]):",
            "    \"\"\"\u6d88\u606f\u6a21\u677f\u683c\u5f0f\u5316\u5b9e\u73b0\u7c7b\u3002",
            "",
            "    \u53c2\u6570:",
            "        template: \u6a21\u677f",
            "        factory: \u6d88\u606f\u7c7b\u578b\u5de5\u5382\uff0c\u9ed8\u8ba4\u4e3a `str`",
            "    \"\"\"",
            "",
            "    @overload",
            "    def __init__(",
            "        self: \"MessageTemplate[str]\", template: str, factory: Type[str] = str",
            "    ) -> None:",
            "        ...",
            "",
            "    @overload",
            "    def __init__(",
            "        self: \"MessageTemplate[TM]\", template: Union[str, TM], factory: Type[TM]",
            "    ) -> None:",
            "        ...",
            "",
            "    def __init__(",
            "        self, template: Union[str, TM], factory: Union[Type[str], Type[TM]] = str",
            "    ) -> None:",
            "        self.template: TF = template  # type: ignore",
            "        self.factory: Type[TF] = factory  # type: ignore",
            "        self.format_specs: Dict[str, FormatSpecFunc] = {}",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"MessageTemplate({self.template!r}, factory={self.factory!r})\"",
            "",
            "    def add_format_spec(",
            "        self, spec: FormatSpecFunc_T, name: Optional[str] = None",
            "    ) -> FormatSpecFunc_T:",
            "        name = name or spec.__name__",
            "        if name in self.format_specs:",
            "            raise ValueError(f\"Format spec {name} already exists!\")",
            "        self.format_specs[name] = spec",
            "        return spec",
            "",
            "    def format(self, *args, **kwargs):",
            "        \"\"\"\u6839\u636e\u4f20\u5165\u53c2\u6570\u548c\u6a21\u677f\u751f\u6210\u6d88\u606f\u5bf9\u8c61\"\"\"",
            "        return self._format(args, kwargs)",
            "",
            "    def format_map(self, mapping: Mapping[str, Any]) -> TF:",
            "        \"\"\"\u6839\u636e\u4f20\u5165\u5b57\u5178\u548c\u6a21\u677f\u751f\u6210\u6d88\u606f\u5bf9\u8c61, \u5728\u4f20\u5165\u5b57\u6bb5\u540d\u4e0d\u662f\u6709\u6548\u6807\u8bc6\u7b26\u65f6\u6709\u7528\"\"\"",
            "        return self._format([], mapping)",
            "",
            "    def _format(self, args: Sequence[Any], kwargs: Mapping[str, Any]) -> TF:",
            "        full_message = self.factory()",
            "        used_args, arg_index = set(), 0",
            "",
            "        if isinstance(self.template, str):",
            "            msg, arg_index = self._vformat(",
            "                self.template, args, kwargs, used_args, arg_index",
            "            )",
            "            full_message += msg",
            "        elif isinstance(self.template, self.factory):",
            "            template = cast(\"Message[MessageSegment]\", self.template)",
            "            for seg in template:",
            "                if not seg.is_text():",
            "                    full_message += seg",
            "                else:",
            "                    msg, arg_index = self._vformat(",
            "                        str(seg), args, kwargs, used_args, arg_index",
            "                    )",
            "                    full_message += msg",
            "        else:",
            "            raise TypeError(\"template must be a string or instance of Message!\")",
            "",
            "        self.check_unused_args(used_args, args, kwargs)",
            "        return cast(TF, full_message)",
            "",
            "    def vformat(",
            "        self,",
            "        format_string: str,",
            "        args: Sequence[Any],",
            "        kwargs: Mapping[str, Any],",
            "    ) -> TF:",
            "        raise NotImplementedError(\"`vformat` has merged into `_format`\")",
            "",
            "    def _vformat(",
            "        self,",
            "        format_string: str,",
            "        args: Sequence[Any],",
            "        kwargs: Mapping[str, Any],",
            "        used_args: Set[Union[int, str]],",
            "        auto_arg_index: int = 0,",
            "    ) -> Tuple[TF, int]:",
            "        results: List[Any] = [self.factory()]",
            "",
            "        for literal_text, field_name, format_spec, conversion in self.parse(",
            "            format_string",
            "        ):",
            "            # output the literal text",
            "            if literal_text:",
            "                results.append(literal_text)",
            "",
            "            # if there's a field, output it",
            "            if field_name is not None:",
            "                # this is some markup, find the object and do",
            "                #  the formatting",
            "",
            "                # handle arg indexing when empty field_names are given.",
            "                if field_name == \"\":",
            "                    if auto_arg_index is False:",
            "                        raise ValueError(",
            "                            \"cannot switch from manual field specification to \"",
            "                            \"automatic field numbering\"",
            "                        )",
            "                    field_name = str(auto_arg_index)",
            "                    auto_arg_index += 1",
            "                elif field_name.isdigit():",
            "                    if auto_arg_index:",
            "                        raise ValueError(",
            "                            \"cannot switch from manual field specification to \"",
            "                            \"automatic field numbering\"",
            "                        )",
            "                    # disable auto arg incrementing, if it gets",
            "                    # used later on, then an exception will be raised",
            "                    auto_arg_index = False",
            "",
            "                # given the field_name, find the object it references",
            "                #  and the argument it came from",
            "                obj, arg_used = self.get_field(field_name, args, kwargs)",
            "                used_args.add(arg_used)",
            "",
            "                # do any conversion on the resulting object",
            "                obj = self.convert_field(obj, conversion) if conversion else obj",
            "",
            "                # format the object and append to the result",
            "                formatted_text = (",
            "                    self.format_field(obj, format_spec) if format_spec else obj",
            "                )",
            "                results.append(formatted_text)",
            "",
            "        return functools.reduce(self._add, results), auto_arg_index",
            "",
            "    def format_field(self, value: Any, format_spec: str) -> Any:",
            "        formatter: Optional[FormatSpecFunc] = self.format_specs.get(format_spec)",
            "        if formatter is None and not issubclass(self.factory, str):",
            "            segment_class: Type[\"MessageSegment\"] = self.factory.get_segment_class()",
            "            method = getattr(segment_class, format_spec, None)",
            "            if callable(method) and not cast(str, method.__name__).startswith(\"_\"):",
            "                formatter = getattr(segment_class, format_spec)",
            "        return (",
            "            super().format_field(value, format_spec)",
            "            if formatter is None",
            "            else formatter(value)",
            "        )",
            "",
            "    def _add(self, a: Any, b: Any) -> Any:",
            "        try:",
            "            return a + b",
            "        except TypeError:",
            "            return a + str(b)"
        ],
        "afterPatchFile": [
            "import functools",
            "from string import Formatter",
            "from typing_extensions import TypeAlias",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Set,",
            "    Dict,",
            "    List,",
            "    Type,",
            "    Tuple,",
            "    Union,",
            "    Generic,",
            "    Mapping,",
            "    TypeVar,",
            "    Callable,",
            "    Optional,",
            "    Sequence,",
            "    cast,",
            "    overload,",
            ")",
            "",
            "from _string import formatter_field_name_split  # type: ignore",
            "",
            "if TYPE_CHECKING:",
            "    from .message import Message, MessageSegment",
            "",
            "    def formatter_field_name_split(  # noqa: F811",
            "        field_name: str,",
            "    ) -> Tuple[str, List[Tuple[bool, str]]]:",
            "        ...",
            "",
            "",
            "TM = TypeVar(\"TM\", bound=\"Message\")",
            "TF = TypeVar(\"TF\", str, \"Message\")",
            "",
            "FormatSpecFunc: TypeAlias = Callable[[Any], str]",
            "FormatSpecFunc_T = TypeVar(\"FormatSpecFunc_T\", bound=FormatSpecFunc)",
            "",
            "",
            "class MessageTemplate(Formatter, Generic[TF]):",
            "    \"\"\"\u6d88\u606f\u6a21\u677f\u683c\u5f0f\u5316\u5b9e\u73b0\u7c7b\u3002",
            "",
            "    \u53c2\u6570:",
            "        template: \u6a21\u677f",
            "        factory: \u6d88\u606f\u7c7b\u578b\u5de5\u5382\uff0c\u9ed8\u8ba4\u4e3a `str`",
            "        private_getattr: \u662f\u5426\u5141\u8bb8\u5728\u6a21\u677f\u4e2d\u8bbf\u95ee\u79c1\u6709\u5c5e\u6027\uff0c\u9ed8\u8ba4\u4e3a `False`",
            "    \"\"\"",
            "",
            "    @overload",
            "    def __init__(",
            "        self: \"MessageTemplate[str]\",",
            "        template: str,",
            "        factory: Type[str] = str,",
            "        private_getattr: bool = False,",
            "    ) -> None:",
            "        ...",
            "",
            "    @overload",
            "    def __init__(",
            "        self: \"MessageTemplate[TM]\",",
            "        template: Union[str, TM],",
            "        factory: Type[TM],",
            "        private_getattr: bool = False,",
            "    ) -> None:",
            "        ...",
            "",
            "    def __init__(",
            "        self,",
            "        template: Union[str, TM],",
            "        factory: Union[Type[str], Type[TM]] = str,",
            "        private_getattr: bool = False,",
            "    ) -> None:",
            "        self.template: TF = template  # type: ignore",
            "        self.factory: Type[TF] = factory  # type: ignore",
            "        self.format_specs: Dict[str, FormatSpecFunc] = {}",
            "        self.private_getattr = private_getattr",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"MessageTemplate({self.template!r}, factory={self.factory!r})\"",
            "",
            "    def add_format_spec(",
            "        self, spec: FormatSpecFunc_T, name: Optional[str] = None",
            "    ) -> FormatSpecFunc_T:",
            "        name = name or spec.__name__",
            "        if name in self.format_specs:",
            "            raise ValueError(f\"Format spec {name} already exists!\")",
            "        self.format_specs[name] = spec",
            "        return spec",
            "",
            "    def format(self, *args, **kwargs):",
            "        \"\"\"\u6839\u636e\u4f20\u5165\u53c2\u6570\u548c\u6a21\u677f\u751f\u6210\u6d88\u606f\u5bf9\u8c61\"\"\"",
            "        return self._format(args, kwargs)",
            "",
            "    def format_map(self, mapping: Mapping[str, Any]) -> TF:",
            "        \"\"\"\u6839\u636e\u4f20\u5165\u5b57\u5178\u548c\u6a21\u677f\u751f\u6210\u6d88\u606f\u5bf9\u8c61, \u5728\u4f20\u5165\u5b57\u6bb5\u540d\u4e0d\u662f\u6709\u6548\u6807\u8bc6\u7b26\u65f6\u6709\u7528\"\"\"",
            "        return self._format([], mapping)",
            "",
            "    def _format(self, args: Sequence[Any], kwargs: Mapping[str, Any]) -> TF:",
            "        full_message = self.factory()",
            "        used_args, arg_index = set(), 0",
            "",
            "        if isinstance(self.template, str):",
            "            msg, arg_index = self._vformat(",
            "                self.template, args, kwargs, used_args, arg_index",
            "            )",
            "            full_message += msg",
            "        elif isinstance(self.template, self.factory):",
            "            template = cast(\"Message[MessageSegment]\", self.template)",
            "            for seg in template:",
            "                if not seg.is_text():",
            "                    full_message += seg",
            "                else:",
            "                    msg, arg_index = self._vformat(",
            "                        str(seg), args, kwargs, used_args, arg_index",
            "                    )",
            "                    full_message += msg",
            "        else:",
            "            raise TypeError(\"template must be a string or instance of Message!\")",
            "",
            "        self.check_unused_args(used_args, args, kwargs)",
            "        return cast(TF, full_message)",
            "",
            "    def vformat(",
            "        self,",
            "        format_string: str,",
            "        args: Sequence[Any],",
            "        kwargs: Mapping[str, Any],",
            "    ) -> TF:",
            "        raise NotImplementedError(\"`vformat` has merged into `_format`\")",
            "",
            "    def _vformat(",
            "        self,",
            "        format_string: str,",
            "        args: Sequence[Any],",
            "        kwargs: Mapping[str, Any],",
            "        used_args: Set[Union[int, str]],",
            "        auto_arg_index: int = 0,",
            "    ) -> Tuple[TF, int]:",
            "        results: List[Any] = [self.factory()]",
            "",
            "        for literal_text, field_name, format_spec, conversion in self.parse(",
            "            format_string",
            "        ):",
            "            # output the literal text",
            "            if literal_text:",
            "                results.append(literal_text)",
            "",
            "            # if there's a field, output it",
            "            if field_name is not None:",
            "                # this is some markup, find the object and do",
            "                #  the formatting",
            "",
            "                # handle arg indexing when empty field_names are given.",
            "                if field_name == \"\":",
            "                    if auto_arg_index is False:",
            "                        raise ValueError(",
            "                            \"cannot switch from manual field specification to \"",
            "                            \"automatic field numbering\"",
            "                        )",
            "                    field_name = str(auto_arg_index)",
            "                    auto_arg_index += 1",
            "                elif field_name.isdigit():",
            "                    if auto_arg_index:",
            "                        raise ValueError(",
            "                            \"cannot switch from manual field specification to \"",
            "                            \"automatic field numbering\"",
            "                        )",
            "                    # disable auto arg incrementing, if it gets",
            "                    # used later on, then an exception will be raised",
            "                    auto_arg_index = False",
            "",
            "                # given the field_name, find the object it references",
            "                #  and the argument it came from",
            "                obj, arg_used = self.get_field(field_name, args, kwargs)",
            "                used_args.add(arg_used)",
            "",
            "                # do any conversion on the resulting object",
            "                obj = self.convert_field(obj, conversion) if conversion else obj",
            "",
            "                # format the object and append to the result",
            "                formatted_text = (",
            "                    self.format_field(obj, format_spec) if format_spec else obj",
            "                )",
            "                results.append(formatted_text)",
            "",
            "        return functools.reduce(self._add, results), auto_arg_index",
            "",
            "    def get_field(",
            "        self, field_name: str, args: Sequence[Any], kwargs: Mapping[str, Any]",
            "    ) -> Tuple[Any, Union[int, str]]:",
            "        first, rest = formatter_field_name_split(field_name)",
            "        obj = self.get_value(first, args, kwargs)",
            "",
            "        for is_attr, value in rest:",
            "            if not self.private_getattr and value.startswith(\"_\"):",
            "                raise ValueError(\"Cannot access private attribute\")",
            "            obj = getattr(obj, value) if is_attr else obj[value]",
            "",
            "        return obj, first",
            "",
            "    def format_field(self, value: Any, format_spec: str) -> Any:",
            "        formatter: Optional[FormatSpecFunc] = self.format_specs.get(format_spec)",
            "        if formatter is None and not issubclass(self.factory, str):",
            "            segment_class: Type[\"MessageSegment\"] = self.factory.get_segment_class()",
            "            method = getattr(segment_class, format_spec, None)",
            "            if callable(method) and not cast(str, method.__name__).startswith(\"_\"):",
            "                formatter = getattr(segment_class, format_spec)",
            "        return (",
            "            super().format_field(value, format_spec)",
            "            if formatter is None",
            "            else formatter(value)",
            "        )",
            "",
            "    def _add(self, a: Any, b: Any) -> Any:",
            "        try:",
            "            return a + b",
            "        except TypeError:",
            "            return a + str(b)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "43": [
                "MessageTemplate",
                "__init__"
            ],
            "49": [
                "MessageTemplate",
                "__init__"
            ],
            "54": [
                "MessageTemplate",
                "__init__"
            ]
        },
        "addLocation": [
            "redbot.cogs.trivia.trivia",
            "nonebot.internal.adapter.template",
            "nonebot.internal.adapter.template.MessageTemplate.self"
        ]
    }
}