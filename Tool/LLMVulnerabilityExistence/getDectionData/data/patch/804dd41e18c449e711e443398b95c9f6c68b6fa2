{
    "synapse/federation/federation_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # See the License for the specific language governing permissions and"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " # limitations under the License."
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import logging"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from collections import namedtuple"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import six"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from twisted.internet import defer"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from twisted.internet.defer import DeferredList"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from synapse.api.constants import MAX_DEPTH"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from synapse.api.constants import MAX_DEPTH, EventTypes, Membership"
            },
            "12": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from synapse.api.errors import Codes, SynapseError"
            },
            "13": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from synapse.crypto.event_signing import check_event_content_hash"
            },
            "14": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from synapse.events import FrozenEvent"
            },
            "15": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from synapse.events.utils import prune_event"
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from synapse.http.servlet import assert_params_in_dict"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from synapse.types import get_domain_from_id"
            },
            "18": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from synapse.util import logcontext, unwrapFirstError"
            },
            "19": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "21": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "               * throws a SynapseError if the signature check failed."
            },
            "22": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             The deferreds run their callbacks in the sentinel logcontext."
            },
            "23": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         \"\"\""
            },
            "24": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "25": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        redacted_pdus = ["
            },
            "26": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            prune_event(pdu)"
            },
            "27": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for pdu in pdus"
            },
            "28": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]"
            },
            "29": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "30": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        deferreds = self.keyring.verify_json_objects_for_server(["
            },
            "31": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (p.origin, p.get_pdu_json())"
            },
            "32": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for p in redacted_pdus"
            },
            "33": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ])"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        deferreds = _check_sigs_on_pdus(self.keyring, pdus)"
            },
            "35": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         ctx = logcontext.LoggingContext.current_context()"
            },
            "37": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        def callback(_, pdu, redacted):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        def callback(_, pdu):"
            },
            "40": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "             with logcontext.PreserveLoggingContext(ctx):"
            },
            "41": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                 if not check_event_content_hash(pdu):"
            },
            "42": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "                     logger.warn("
            },
            "43": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "                         \"Event content has been tampered, redacting %s: %s\","
            },
            "44": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                         pdu.event_id, pdu.get_pdu_json()"
            },
            "45": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                     )"
            },
            "46": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return redacted"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                    return prune_event(pdu)"
            },
            "48": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                 if self.spam_checker.check_event_for_spam(pdu):"
            },
            "50": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                     logger.warn("
            },
            "51": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "                         \"Event contains spam, redacting %s: %s\","
            },
            "52": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "                         pdu.event_id, pdu.get_pdu_json()"
            },
            "53": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "                     )"
            },
            "54": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return redacted"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                    return prune_event(pdu)"
            },
            "56": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                 return pdu"
            },
            "58": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "                 )"
            },
            "60": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             return failure"
            },
            "61": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for deferred, pdu, redacted in zip(deferreds, pdus, redacted_pdus):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        for deferred, pdu in zip(deferreds, pdus):"
            },
            "64": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             deferred.addCallbacks("
            },
            "65": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                 callback, errback,"
            },
            "66": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                callbackArgs=[pdu, redacted],"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                callbackArgs=[pdu],"
            },
            "68": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                 errbackArgs=[pdu],"
            },
            "69": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "             )"
            },
            "70": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         return deferreds"
            },
            "72": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+class PduToCheckSig(namedtuple(\"PduToCheckSig\", ["
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    \"pdu\", \"redacted_pdu_json\", \"event_id_domain\", \"sender_domain\", \"deferreds\","
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+])):"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    pass"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+def _check_sigs_on_pdus(keyring, pdus):"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    \"\"\"Check that the given events are correctly signed"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+    Args:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        keyring (synapse.crypto.Keyring): keyring object to do the checks"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        pdus (Collection[EventBase]): the events to be checked"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    Returns:"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        List[Deferred]: a Deferred for each event in pdus, which will either succeed if"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+           the signatures are valid, or fail (with a SynapseError) if not."
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+    \"\"\""
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+    # (currently this is written assuming the v1 room structure; we'll probably want a"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+    # separate function for checking v2 rooms)"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+    # we want to check that the event is signed by:"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+    #"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+    # (a) the server which created the event_id"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+    #"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+    # (b) the sender's server."
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    #"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+    #     - except in the case of invites created from a 3pid invite, which are exempt"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+    #     from this check, because the sender has to match that of the original 3pid"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+    #     invite, but the event may come from a different HS, for reasons that I don't"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+    #     entirely grok (why do the senders have to match? and if they do, why doesn't the"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+    #     joining server ask the inviting server to do the switcheroo with"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+    #     exchange_third_party_invite?)."
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+    #"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    #     That's pretty awful, since redacting such an invite will render it invalid"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+    #     (because it will then look like a regular invite without a valid signature),"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+    #     and signatures are *supposed* to be valid whether or not an event has been"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+    #     redacted. But this isn't the worst of the ways that 3pid invites are broken."
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+    #"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    # let's start by getting the domain for each pdu, and flattening the event back"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    # to JSON."
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    pdus_to_check = ["
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        PduToCheckSig("
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            pdu=p,"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            redacted_pdu_json=prune_event(p).get_pdu_json(),"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            event_id_domain=get_domain_from_id(p.event_id),"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            sender_domain=get_domain_from_id(p.sender),"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            deferreds=[],"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        )"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        for p in pdus"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+    ]"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    # first make sure that the event is signed by the event_id's domain"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+    deferreds = keyring.verify_json_objects_for_server(["
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        (p.event_id_domain, p.redacted_pdu_json)"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        for p in pdus_to_check"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+    ])"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    for p, d in zip(pdus_to_check, deferreds):"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+        p.deferreds.append(d)"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    # now let's look for events where the sender's domain is different to the"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    # event id's domain (normally only the case for joins/leaves), and add additional"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    # checks."
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    pdus_to_check_sender = ["
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+        p for p in pdus_to_check"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        if p.sender_domain != p.event_id_domain and not _is_invite_via_3pid(p.pdu)"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    ]"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    more_deferreds = keyring.verify_json_objects_for_server(["
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        (p.sender_domain, p.redacted_pdu_json)"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        for p in pdus_to_check_sender"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    ])"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    for p, d in zip(pdus_to_check_sender, more_deferreds):"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        p.deferreds.append(d)"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+    # replace lists of deferreds with single Deferreds"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    return [_flatten_deferred_list(p.deferreds) for p in pdus_to_check]"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+def _flatten_deferred_list(deferreds):"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    \"\"\"Given a list of one or more deferreds, either return the single deferred, or"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    combine into a DeferredList."
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    \"\"\""
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    if len(deferreds) > 1:"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        return DeferredList(deferreds, fireOnOneErrback=True, consumeErrors=True)"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    else:"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        assert len(deferreds) == 1"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        return deferreds[0]"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+def _is_invite_via_3pid(event):"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    return ("
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        event.type == EventTypes.Member"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+        and event.membership == Membership.INVITE"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+        and \"third_party_invite\" in event.content"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    )"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+"
            },
            "174": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 280,
                "PatchRowcode": " def event_from_pdu_json(pdu_json, outlier=False):"
            },
            "175": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     \"\"\"Construct a FrozenEvent from an event json received over federation"
            },
            "176": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "",
            "import six",
            "",
            "from twisted.internet import defer",
            "",
            "from synapse.api.constants import MAX_DEPTH",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.crypto.event_signing import check_event_content_hash",
            "from synapse.events import FrozenEvent",
            "from synapse.events.utils import prune_event",
            "from synapse.http.servlet import assert_params_in_dict",
            "from synapse.util import logcontext, unwrapFirstError",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class FederationBase(object):",
            "    def __init__(self, hs):",
            "        self.hs = hs",
            "",
            "        self.server_name = hs.hostname",
            "        self.keyring = hs.get_keyring()",
            "        self.spam_checker = hs.get_spam_checker()",
            "        self.store = hs.get_datastore()",
            "        self._clock = hs.get_clock()",
            "",
            "    @defer.inlineCallbacks",
            "    def _check_sigs_and_hash_and_fetch(self, origin, pdus, outlier=False,",
            "                                       include_none=False):",
            "        \"\"\"Takes a list of PDUs and checks the signatures and hashs of each",
            "        one. If a PDU fails its signature check then we check if we have it in",
            "        the database and if not then request if from the originating server of",
            "        that PDU.",
            "",
            "        If a PDU fails its content hash check then it is redacted.",
            "",
            "        The given list of PDUs are not modified, instead the function returns",
            "        a new list.",
            "",
            "        Args:",
            "            pdu (list)",
            "            outlier (bool)",
            "",
            "        Returns:",
            "            Deferred : A list of PDUs that have valid signatures and hashes.",
            "        \"\"\"",
            "        deferreds = self._check_sigs_and_hashes(pdus)",
            "",
            "        @defer.inlineCallbacks",
            "        def handle_check_result(pdu, deferred):",
            "            try:",
            "                res = yield logcontext.make_deferred_yieldable(deferred)",
            "            except SynapseError:",
            "                res = None",
            "",
            "            if not res:",
            "                # Check local db.",
            "                res = yield self.store.get_event(",
            "                    pdu.event_id,",
            "                    allow_rejected=True,",
            "                    allow_none=True,",
            "                )",
            "",
            "            if not res and pdu.origin != origin:",
            "                try:",
            "                    res = yield self.get_pdu(",
            "                        destinations=[pdu.origin],",
            "                        event_id=pdu.event_id,",
            "                        outlier=outlier,",
            "                        timeout=10000,",
            "                    )",
            "                except SynapseError:",
            "                    pass",
            "",
            "            if not res:",
            "                logger.warn(",
            "                    \"Failed to find copy of %s with valid signature\",",
            "                    pdu.event_id,",
            "                )",
            "",
            "            defer.returnValue(res)",
            "",
            "        handle = logcontext.preserve_fn(handle_check_result)",
            "        deferreds2 = [",
            "            handle(pdu, deferred)",
            "            for pdu, deferred in zip(pdus, deferreds)",
            "        ]",
            "",
            "        valid_pdus = yield logcontext.make_deferred_yieldable(",
            "            defer.gatherResults(",
            "                deferreds2,",
            "                consumeErrors=True,",
            "            )",
            "        ).addErrback(unwrapFirstError)",
            "",
            "        if include_none:",
            "            defer.returnValue(valid_pdus)",
            "        else:",
            "            defer.returnValue([p for p in valid_pdus if p])",
            "",
            "    def _check_sigs_and_hash(self, pdu):",
            "        return logcontext.make_deferred_yieldable(",
            "            self._check_sigs_and_hashes([pdu])[0],",
            "        )",
            "",
            "    def _check_sigs_and_hashes(self, pdus):",
            "        \"\"\"Checks that each of the received events is correctly signed by the",
            "        sending server.",
            "",
            "        Args:",
            "            pdus (list[FrozenEvent]): the events to be checked",
            "",
            "        Returns:",
            "            list[Deferred]: for each input event, a deferred which:",
            "              * returns the original event if the checks pass",
            "              * returns a redacted version of the event (if the signature",
            "                matched but the hash did not)",
            "              * throws a SynapseError if the signature check failed.",
            "            The deferreds run their callbacks in the sentinel logcontext.",
            "        \"\"\"",
            "",
            "        redacted_pdus = [",
            "            prune_event(pdu)",
            "            for pdu in pdus",
            "        ]",
            "",
            "        deferreds = self.keyring.verify_json_objects_for_server([",
            "            (p.origin, p.get_pdu_json())",
            "            for p in redacted_pdus",
            "        ])",
            "",
            "        ctx = logcontext.LoggingContext.current_context()",
            "",
            "        def callback(_, pdu, redacted):",
            "            with logcontext.PreserveLoggingContext(ctx):",
            "                if not check_event_content_hash(pdu):",
            "                    logger.warn(",
            "                        \"Event content has been tampered, redacting %s: %s\",",
            "                        pdu.event_id, pdu.get_pdu_json()",
            "                    )",
            "                    return redacted",
            "",
            "                if self.spam_checker.check_event_for_spam(pdu):",
            "                    logger.warn(",
            "                        \"Event contains spam, redacting %s: %s\",",
            "                        pdu.event_id, pdu.get_pdu_json()",
            "                    )",
            "                    return redacted",
            "",
            "                return pdu",
            "",
            "        def errback(failure, pdu):",
            "            failure.trap(SynapseError)",
            "            with logcontext.PreserveLoggingContext(ctx):",
            "                logger.warn(",
            "                    \"Signature check failed for %s\",",
            "                    pdu.event_id,",
            "                )",
            "            return failure",
            "",
            "        for deferred, pdu, redacted in zip(deferreds, pdus, redacted_pdus):",
            "            deferred.addCallbacks(",
            "                callback, errback,",
            "                callbackArgs=[pdu, redacted],",
            "                errbackArgs=[pdu],",
            "            )",
            "",
            "        return deferreds",
            "",
            "",
            "def event_from_pdu_json(pdu_json, outlier=False):",
            "    \"\"\"Construct a FrozenEvent from an event json received over federation",
            "",
            "    Args:",
            "        pdu_json (object): pdu as received over federation",
            "        outlier (bool): True to mark this event as an outlier",
            "",
            "    Returns:",
            "        FrozenEvent",
            "",
            "    Raises:",
            "        SynapseError: if the pdu is missing required fields or is otherwise",
            "            not a valid matrix event",
            "    \"\"\"",
            "    # we could probably enforce a bunch of other fields here (room_id, sender,",
            "    # origin, etc etc)",
            "    assert_params_in_dict(pdu_json, ('event_id', 'type', 'depth'))",
            "",
            "    depth = pdu_json['depth']",
            "    if not isinstance(depth, six.integer_types):",
            "        raise SynapseError(400, \"Depth %r not an intger\" % (depth, ),",
            "                           Codes.BAD_JSON)",
            "",
            "    if depth < 0:",
            "        raise SynapseError(400, \"Depth too small\", Codes.BAD_JSON)",
            "    elif depth > MAX_DEPTH:",
            "        raise SynapseError(400, \"Depth too large\", Codes.BAD_JSON)",
            "",
            "    event = FrozenEvent(",
            "        pdu_json",
            "    )",
            "",
            "    event.internal_metadata.outlier = outlier",
            "",
            "    return event"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "from collections import namedtuple",
            "",
            "import six",
            "",
            "from twisted.internet import defer",
            "from twisted.internet.defer import DeferredList",
            "",
            "from synapse.api.constants import MAX_DEPTH, EventTypes, Membership",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.crypto.event_signing import check_event_content_hash",
            "from synapse.events import FrozenEvent",
            "from synapse.events.utils import prune_event",
            "from synapse.http.servlet import assert_params_in_dict",
            "from synapse.types import get_domain_from_id",
            "from synapse.util import logcontext, unwrapFirstError",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class FederationBase(object):",
            "    def __init__(self, hs):",
            "        self.hs = hs",
            "",
            "        self.server_name = hs.hostname",
            "        self.keyring = hs.get_keyring()",
            "        self.spam_checker = hs.get_spam_checker()",
            "        self.store = hs.get_datastore()",
            "        self._clock = hs.get_clock()",
            "",
            "    @defer.inlineCallbacks",
            "    def _check_sigs_and_hash_and_fetch(self, origin, pdus, outlier=False,",
            "                                       include_none=False):",
            "        \"\"\"Takes a list of PDUs and checks the signatures and hashs of each",
            "        one. If a PDU fails its signature check then we check if we have it in",
            "        the database and if not then request if from the originating server of",
            "        that PDU.",
            "",
            "        If a PDU fails its content hash check then it is redacted.",
            "",
            "        The given list of PDUs are not modified, instead the function returns",
            "        a new list.",
            "",
            "        Args:",
            "            pdu (list)",
            "            outlier (bool)",
            "",
            "        Returns:",
            "            Deferred : A list of PDUs that have valid signatures and hashes.",
            "        \"\"\"",
            "        deferreds = self._check_sigs_and_hashes(pdus)",
            "",
            "        @defer.inlineCallbacks",
            "        def handle_check_result(pdu, deferred):",
            "            try:",
            "                res = yield logcontext.make_deferred_yieldable(deferred)",
            "            except SynapseError:",
            "                res = None",
            "",
            "            if not res:",
            "                # Check local db.",
            "                res = yield self.store.get_event(",
            "                    pdu.event_id,",
            "                    allow_rejected=True,",
            "                    allow_none=True,",
            "                )",
            "",
            "            if not res and pdu.origin != origin:",
            "                try:",
            "                    res = yield self.get_pdu(",
            "                        destinations=[pdu.origin],",
            "                        event_id=pdu.event_id,",
            "                        outlier=outlier,",
            "                        timeout=10000,",
            "                    )",
            "                except SynapseError:",
            "                    pass",
            "",
            "            if not res:",
            "                logger.warn(",
            "                    \"Failed to find copy of %s with valid signature\",",
            "                    pdu.event_id,",
            "                )",
            "",
            "            defer.returnValue(res)",
            "",
            "        handle = logcontext.preserve_fn(handle_check_result)",
            "        deferreds2 = [",
            "            handle(pdu, deferred)",
            "            for pdu, deferred in zip(pdus, deferreds)",
            "        ]",
            "",
            "        valid_pdus = yield logcontext.make_deferred_yieldable(",
            "            defer.gatherResults(",
            "                deferreds2,",
            "                consumeErrors=True,",
            "            )",
            "        ).addErrback(unwrapFirstError)",
            "",
            "        if include_none:",
            "            defer.returnValue(valid_pdus)",
            "        else:",
            "            defer.returnValue([p for p in valid_pdus if p])",
            "",
            "    def _check_sigs_and_hash(self, pdu):",
            "        return logcontext.make_deferred_yieldable(",
            "            self._check_sigs_and_hashes([pdu])[0],",
            "        )",
            "",
            "    def _check_sigs_and_hashes(self, pdus):",
            "        \"\"\"Checks that each of the received events is correctly signed by the",
            "        sending server.",
            "",
            "        Args:",
            "            pdus (list[FrozenEvent]): the events to be checked",
            "",
            "        Returns:",
            "            list[Deferred]: for each input event, a deferred which:",
            "              * returns the original event if the checks pass",
            "              * returns a redacted version of the event (if the signature",
            "                matched but the hash did not)",
            "              * throws a SynapseError if the signature check failed.",
            "            The deferreds run their callbacks in the sentinel logcontext.",
            "        \"\"\"",
            "        deferreds = _check_sigs_on_pdus(self.keyring, pdus)",
            "",
            "        ctx = logcontext.LoggingContext.current_context()",
            "",
            "        def callback(_, pdu):",
            "            with logcontext.PreserveLoggingContext(ctx):",
            "                if not check_event_content_hash(pdu):",
            "                    logger.warn(",
            "                        \"Event content has been tampered, redacting %s: %s\",",
            "                        pdu.event_id, pdu.get_pdu_json()",
            "                    )",
            "                    return prune_event(pdu)",
            "",
            "                if self.spam_checker.check_event_for_spam(pdu):",
            "                    logger.warn(",
            "                        \"Event contains spam, redacting %s: %s\",",
            "                        pdu.event_id, pdu.get_pdu_json()",
            "                    )",
            "                    return prune_event(pdu)",
            "",
            "                return pdu",
            "",
            "        def errback(failure, pdu):",
            "            failure.trap(SynapseError)",
            "            with logcontext.PreserveLoggingContext(ctx):",
            "                logger.warn(",
            "                    \"Signature check failed for %s\",",
            "                    pdu.event_id,",
            "                )",
            "            return failure",
            "",
            "        for deferred, pdu in zip(deferreds, pdus):",
            "            deferred.addCallbacks(",
            "                callback, errback,",
            "                callbackArgs=[pdu],",
            "                errbackArgs=[pdu],",
            "            )",
            "",
            "        return deferreds",
            "",
            "",
            "class PduToCheckSig(namedtuple(\"PduToCheckSig\", [",
            "    \"pdu\", \"redacted_pdu_json\", \"event_id_domain\", \"sender_domain\", \"deferreds\",",
            "])):",
            "    pass",
            "",
            "",
            "def _check_sigs_on_pdus(keyring, pdus):",
            "    \"\"\"Check that the given events are correctly signed",
            "",
            "    Args:",
            "        keyring (synapse.crypto.Keyring): keyring object to do the checks",
            "        pdus (Collection[EventBase]): the events to be checked",
            "",
            "    Returns:",
            "        List[Deferred]: a Deferred for each event in pdus, which will either succeed if",
            "           the signatures are valid, or fail (with a SynapseError) if not.",
            "    \"\"\"",
            "",
            "    # (currently this is written assuming the v1 room structure; we'll probably want a",
            "    # separate function for checking v2 rooms)",
            "",
            "    # we want to check that the event is signed by:",
            "    #",
            "    # (a) the server which created the event_id",
            "    #",
            "    # (b) the sender's server.",
            "    #",
            "    #     - except in the case of invites created from a 3pid invite, which are exempt",
            "    #     from this check, because the sender has to match that of the original 3pid",
            "    #     invite, but the event may come from a different HS, for reasons that I don't",
            "    #     entirely grok (why do the senders have to match? and if they do, why doesn't the",
            "    #     joining server ask the inviting server to do the switcheroo with",
            "    #     exchange_third_party_invite?).",
            "    #",
            "    #     That's pretty awful, since redacting such an invite will render it invalid",
            "    #     (because it will then look like a regular invite without a valid signature),",
            "    #     and signatures are *supposed* to be valid whether or not an event has been",
            "    #     redacted. But this isn't the worst of the ways that 3pid invites are broken.",
            "    #",
            "    # let's start by getting the domain for each pdu, and flattening the event back",
            "    # to JSON.",
            "    pdus_to_check = [",
            "        PduToCheckSig(",
            "            pdu=p,",
            "            redacted_pdu_json=prune_event(p).get_pdu_json(),",
            "            event_id_domain=get_domain_from_id(p.event_id),",
            "            sender_domain=get_domain_from_id(p.sender),",
            "            deferreds=[],",
            "        )",
            "        for p in pdus",
            "    ]",
            "",
            "    # first make sure that the event is signed by the event_id's domain",
            "    deferreds = keyring.verify_json_objects_for_server([",
            "        (p.event_id_domain, p.redacted_pdu_json)",
            "        for p in pdus_to_check",
            "    ])",
            "",
            "    for p, d in zip(pdus_to_check, deferreds):",
            "        p.deferreds.append(d)",
            "",
            "    # now let's look for events where the sender's domain is different to the",
            "    # event id's domain (normally only the case for joins/leaves), and add additional",
            "    # checks.",
            "    pdus_to_check_sender = [",
            "        p for p in pdus_to_check",
            "        if p.sender_domain != p.event_id_domain and not _is_invite_via_3pid(p.pdu)",
            "    ]",
            "",
            "    more_deferreds = keyring.verify_json_objects_for_server([",
            "        (p.sender_domain, p.redacted_pdu_json)",
            "        for p in pdus_to_check_sender",
            "    ])",
            "",
            "    for p, d in zip(pdus_to_check_sender, more_deferreds):",
            "        p.deferreds.append(d)",
            "",
            "    # replace lists of deferreds with single Deferreds",
            "    return [_flatten_deferred_list(p.deferreds) for p in pdus_to_check]",
            "",
            "",
            "def _flatten_deferred_list(deferreds):",
            "    \"\"\"Given a list of one or more deferreds, either return the single deferred, or",
            "    combine into a DeferredList.",
            "    \"\"\"",
            "    if len(deferreds) > 1:",
            "        return DeferredList(deferreds, fireOnOneErrback=True, consumeErrors=True)",
            "    else:",
            "        assert len(deferreds) == 1",
            "        return deferreds[0]",
            "",
            "",
            "def _is_invite_via_3pid(event):",
            "    return (",
            "        event.type == EventTypes.Member",
            "        and event.membership == Membership.INVITE",
            "        and \"third_party_invite\" in event.content",
            "    )",
            "",
            "",
            "def event_from_pdu_json(pdu_json, outlier=False):",
            "    \"\"\"Construct a FrozenEvent from an event json received over federation",
            "",
            "    Args:",
            "        pdu_json (object): pdu as received over federation",
            "        outlier (bool): True to mark this event as an outlier",
            "",
            "    Returns:",
            "        FrozenEvent",
            "",
            "    Raises:",
            "        SynapseError: if the pdu is missing required fields or is otherwise",
            "            not a valid matrix event",
            "    \"\"\"",
            "    # we could probably enforce a bunch of other fields here (room_id, sender,",
            "    # origin, etc etc)",
            "    assert_params_in_dict(pdu_json, ('event_id', 'type', 'depth'))",
            "",
            "    depth = pdu_json['depth']",
            "    if not isinstance(depth, six.integer_types):",
            "        raise SynapseError(400, \"Depth %r not an intger\" % (depth, ),",
            "                           Codes.BAD_JSON)",
            "",
            "    if depth < 0:",
            "        raise SynapseError(400, \"Depth too small\", Codes.BAD_JSON)",
            "    elif depth > MAX_DEPTH:",
            "        raise SynapseError(400, \"Depth too large\", Codes.BAD_JSON)",
            "",
            "    event = FrozenEvent(",
            "        pdu_json",
            "    )",
            "",
            "    event.internal_metadata.outlier = outlier",
            "",
            "    return event"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "136": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "137": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "138": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "139": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "140": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "141": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "142": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "143": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "144": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "145": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "149": [
                "FederationBase",
                "_check_sigs_and_hashes",
                "callback"
            ],
            "156": [
                "FederationBase",
                "_check_sigs_and_hashes",
                "callback"
            ],
            "163": [
                "FederationBase",
                "_check_sigs_and_hashes",
                "callback"
            ],
            "176": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ],
            "179": [
                "FederationBase",
                "_check_sigs_and_hashes"
            ]
        },
        "addLocation": []
    }
}