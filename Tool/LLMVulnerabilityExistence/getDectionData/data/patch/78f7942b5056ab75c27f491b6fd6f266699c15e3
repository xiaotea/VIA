{
    "buildbot/status/web/baseweb.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         data = \"\""
            },
            "1": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         # really this is \"up to %d builds\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        html_branches = map(html.escape, branches)"
            },
            "4": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         data += \"<h1>Last %d finished builds: %s</h1>\\n\" % \\"
            },
            "5": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                (numbuilds, \", \".join(branches))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                (numbuilds, \", \".join(html_branches))"
            },
            "7": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         if builders:"
            },
            "8": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data += (\"<p>of builders: %s</p>\\n\" % (\", \".join(builders)))"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+            html_builders = map(html.escape, builders)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+            data += (\"<p>of builders: %s</p>\\n\" % (\", \".join(html_builders)))"
            },
            "11": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         data += \"<ul>\\n\""
            },
            "12": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         got = 0"
            },
            "13": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         building = False"
            },
            "14": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "                                                 numbuilds)"
            },
            "15": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         data = \"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        html_branches = map(html.escape, branches)"
            },
            "18": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         data += (\"<h1>Last %d builds of builder %s: %s</h1>\\n\" %"
            },
            "19": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                 (numbuilds, self.builder_name, \", \".join(branches)))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+                 (numbuilds, self.builder_name, \", \".join(html_branches)))"
            },
            "21": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         data += \"<ul>\\n\""
            },
            "22": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         got = 0"
            },
            "23": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         for build in g:"
            },
            "24": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         data = \"\""
            },
            "26": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        html_branches = map(html.escape, branches)"
            },
            "28": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         data += \"<h2>Latest builds: %s</h2>\\n\" % \", \".join(branches)"
            },
            "29": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "         data += \"<table>\\n\""
            },
            "30": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "",
            "import os, sys, urllib, weakref",
            "from itertools import count",
            "",
            "from zope.interface import implements",
            "from twisted.python import log",
            "from twisted.application import strports, service",
            "from twisted.web import server, distrib, static, html",
            "from twisted.spread import pb",
            "",
            "from buildbot.interfaces import IControl, IStatusReceiver",
            "",
            "from buildbot.status.web.base import HtmlResource, Box, \\",
            "     build_get_class, ICurrentBox, OneLineMixin, map_branches, \\",
            "     make_stop_form, make_force_build_form",
            "from buildbot.status.web.feeds import Rss20StatusResource, \\",
            "     Atom10StatusResource",
            "from buildbot.status.web.waterfall import WaterfallStatusResource",
            "from buildbot.status.web.grid import GridStatusResource, TransposedGridStatusResource",
            "from buildbot.status.web.changes import ChangesResource",
            "from buildbot.status.web.builder import BuildersResource",
            "from buildbot.status.web.buildstatus import BuildStatusStatusResource ",
            "from buildbot.status.web.slaves import BuildSlavesResource",
            "from buildbot.status.web.xmlrpc import XMLRPCServer",
            "from buildbot.status.web.about import AboutBuildbot",
            "from buildbot.status.web.auth import IAuth, AuthFailResource",
            "",
            "# this class contains the status services (WebStatus and the older Waterfall)",
            "# which can be put in c['status']. It also contains some of the resources",
            "# that are attached to the WebStatus at various well-known URLs, which the",
            "# admin might wish to attach (using WebStatus.putChild) at other URLs.",
            "",
            "",
            "class LastBuild(HtmlResource):",
            "    def body(self, request):",
            "        return \"missing\\n\"",
            "",
            "def getLastNBuilds(status, numbuilds, builders=[], branches=[]):",
            "    \"\"\"Return a list with the last few Builds, sorted by start time.",
            "    builder_names=None means all builders",
            "    \"\"\"",
            "",
            "    # TODO: this unsorts the list of builder names, ick",
            "    builder_names = set(status.getBuilderNames())",
            "    if builders:",
            "        builder_names = builder_names.intersection(set(builders))",
            "",
            "    # to make sure that we get everything, we must get 'numbuilds' builds",
            "    # from *each* source, then sort by ending time, then trim to the last",
            "    # 20. We could be more efficient, but it would require the same",
            "    # gnarly code that the Waterfall uses to generate one event at a",
            "    # time. TODO: factor that code out into some useful class.",
            "    events = []",
            "    for builder_name in builder_names:",
            "        builder = status.getBuilder(builder_name)",
            "        for build_number in count(1):",
            "            if build_number > numbuilds:",
            "                break # enough from this builder, move on to another",
            "            build = builder.getBuild(-build_number)",
            "            if not build:",
            "                break # no more builds here, move on to the next builder",
            "            #if not build.isFinished():",
            "            #    continue",
            "            (build_start, build_end) = build.getTimes()",
            "            event = (build_start, builder_name, build)",
            "            events.append(event)",
            "    def _sorter(a, b):",
            "        return cmp( a[:2], b[:2] )",
            "    events.sort(_sorter)",
            "    # now only return the actual build, and only return some of them",
            "    return [e[2] for e in events[-numbuilds:]]",
            "",
            "",
            "# /one_line_per_build",
            "#  accepts builder=, branch=, numbuilds=, reload=",
            "class OneLinePerBuild(HtmlResource, OneLineMixin):",
            "    \"\"\"This shows one line per build, combining all builders together. Useful",
            "    query arguments:",
            "",
            "    numbuilds=: how many lines to display",
            "    builder=: show only builds for this builder. Multiple builder= arguments",
            "              can be used to see builds from any builder in the set.",
            "    reload=: reload the page after this many seconds",
            "    \"\"\"",
            "",
            "    title = \"Recent Builds\"",
            "",
            "    def __init__(self, numbuilds=20):",
            "        HtmlResource.__init__(self)",
            "        self.numbuilds = numbuilds",
            "",
            "    def getChild(self, path, req):",
            "        status = self.getStatus(req)",
            "        builder = status.getBuilder(path)",
            "        return OneLinePerBuildOneBuilder(builder, numbuilds=self.numbuilds)",
            "",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        control = self.getControl(req)",
            "        numbuilds = int(req.args.get(\"numbuilds\", [self.numbuilds])[0])",
            "        builders = req.args.get(\"builder\", [])",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        g = status.generateFinishedBuilds(builders, map_branches(branches),",
            "                                          numbuilds, max_search=numbuilds)",
            "",
            "        data = \"\"",
            "",
            "        # really this is \"up to %d builds\"",
            "        data += \"<h1>Last %d finished builds: %s</h1>\\n\" % \\",
            "                (numbuilds, \", \".join(branches))",
            "        if builders:",
            "            data += (\"<p>of builders: %s</p>\\n\" % (\", \".join(builders)))",
            "        data += \"<ul>\\n\"",
            "        got = 0",
            "        building = False",
            "        online = 0",
            "        for build in g:",
            "            got += 1",
            "            data += \" <li>\" + self.make_line(req, build) + \"</li>\\n\"",
            "            builder_status = build.getBuilder().getState()[0]",
            "            if builder_status == \"building\":",
            "                building = True",
            "                online += 1",
            "            elif builder_status != \"offline\":",
            "                online += 1",
            "        if not got:",
            "            data += \" <li>No matching builds found</li>\\n\"",
            "        data += \"</ul>\\n\"",
            "",
            "        if control is not None:",
            "            if building:",
            "                stopURL = \"builders/_all/stop\"",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req),",
            "                                       True, \"Builds\")",
            "            if online:",
            "                forceURL = \"builders/_all/force\"",
            "                data += make_force_build_form(forceURL,",
            "                                              self.isUsingUserPasswd(req), True)",
            "",
            "        return data",
            "",
            "",
            "",
            "# /one_line_per_build/$BUILDERNAME",
            "#  accepts branch=, numbuilds=",
            "",
            "class OneLinePerBuildOneBuilder(HtmlResource, OneLineMixin):",
            "    def __init__(self, builder, numbuilds=20):",
            "        HtmlResource.__init__(self)",
            "        self.builder = builder",
            "        self.builder_name = builder.getName()",
            "        self.numbuilds = numbuilds",
            "        self.title = \"Recent Builds of %s\" % self.builder_name",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        numbuilds = int(req.args.get(\"numbuilds\", [self.numbuilds])[0])",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        # walk backwards through all builds of a single builder",
            "        g = self.builder.generateFinishedBuilds(map_branches(branches),",
            "                                                numbuilds)",
            "",
            "        data = \"\"",
            "        data += (\"<h1>Last %d builds of builder %s: %s</h1>\\n\" %",
            "                 (numbuilds, self.builder_name, \", \".join(branches)))",
            "        data += \"<ul>\\n\"",
            "        got = 0",
            "        for build in g:",
            "            got += 1",
            "            data += \" <li>\" + self.make_line(req, build) + \"</li>\\n\"",
            "        if not got:",
            "            data += \" <li>No matching builds found</li>\\n\"",
            "        data += \"</ul>\\n\"",
            "",
            "        return data",
            "",
            "# /one_box_per_builder",
            "#  accepts builder=, branch=",
            "class OneBoxPerBuilder(HtmlResource):",
            "    \"\"\"This shows a narrow table with one row per builder. The leftmost column",
            "    contains the builder name. The next column contains the results of the",
            "    most recent build. The right-hand column shows the builder's current",
            "    activity.",
            "",
            "    builder=: show only builds for this builder. Multiple builder= arguments",
            "              can be used to see builds from any builder in the set.",
            "    \"\"\"",
            "",
            "    title = \"Latest Build\"",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        control = self.getControl(req)",
            "",
            "        builders = req.args.get(\"builder\", status.getBuilderNames())",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        data = \"\"",
            "",
            "        data += \"<h2>Latest builds: %s</h2>\\n\" % \", \".join(branches)",
            "        data += \"<table>\\n\"",
            "",
            "        building = False",
            "        online = 0",
            "        base_builders_url = self.path_to_root(req) + \"builders/\"",
            "        for bn in builders:",
            "            base_builder_url = base_builders_url + urllib.quote(bn, safe='')",
            "            builder = status.getBuilder(bn)",
            "            data += \"<tr>\\n\"",
            "            data += '<td class=\"box\"><a href=\"%s\">%s</a></td>\\n' \\",
            "                  % (base_builder_url, html.escape(bn))",
            "            builds = list(builder.generateFinishedBuilds(map_branches(branches),",
            "                                                         num_builds=1))",
            "            if builds:",
            "                b = builds[0]",
            "                url = (base_builder_url + \"/builds/%d\" % b.getNumber())",
            "                try:",
            "                    label = b.getProperty(\"got_revision\")",
            "                except KeyError:",
            "                    label = None",
            "                if not label or len(str(label)) > 20:",
            "                    label = \"#%d\" % b.getNumber()",
            "                text = ['<a href=\"%s\">%s</a>' % (url, label)]",
            "                text.extend(b.getText())",
            "                box = Box(text,",
            "                          class_=\"LastBuild box %s\" % build_get_class(b))",
            "                data += box.td(align=\"center\")",
            "            else:",
            "                data += '<td class=\"LastBuild box\" >no build</td>\\n'",
            "            current_box = ICurrentBox(builder).getBox(status)",
            "            data += current_box.td(align=\"center\")",
            "",
            "            builder_status = builder.getState()[0]",
            "            if builder_status == \"building\":",
            "                building = True",
            "                online += 1",
            "            elif builder_status != \"offline\":",
            "                online += 1",
            "",
            "        data += \"</table>\\n\"",
            "",
            "        if control is not None:",
            "            if building:",
            "                stopURL = \"builders/_all/stop\"",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req),",
            "                                       True, \"Builds\")",
            "            if online:",
            "                forceURL = \"builders/_all/force\"",
            "                data += make_force_build_form(forceURL,",
            "                                              self.isUsingUserPasswd(req), True)",
            "",
            "        return data",
            "",
            "",
            "",
            "HEADER = '''",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"",
            " \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
            "",
            "<html",
            " xmlns=\"http://www.w3.org/1999/xhtml\"",
            " lang=\"en\"",
            " xml:lang=\"en\">",
            "'''",
            "",
            "HEAD_ELEMENTS = [",
            "    '<title>%(title)s</title>',",
            "    '<link href=\"%(root)sbuildbot.css\" rel=\"stylesheet\" type=\"text/css\" />',",
            "    ]",
            "BODY_ATTRS = {",
            "    'vlink': \"#800080\",",
            "    }",
            "",
            "FOOTER = '''",
            "</html>",
            "'''",
            "",
            "",
            "class WebStatus(service.MultiService):",
            "    implements(IStatusReceiver)",
            "    # TODO: IStatusReceiver is really about things which subscribe to hear",
            "    # about buildbot events. We need a different interface (perhaps a parent",
            "    # of IStatusReceiver) for status targets that don't subscribe, like the",
            "    # WebStatus class. buildbot.master.BuildMaster.loadConfig:737 asserts",
            "    # that everything in c['status'] provides IStatusReceiver, but really it",
            "    # should check that they provide IStatusTarget instead.",
            "",
            "    \"\"\"",
            "    The webserver provided by this class has the following resources:",
            "",
            "     /waterfall : the big time-oriented 'waterfall' display, with links",
            "                  to individual changes, builders, builds, steps, and logs.",
            "                  A number of query-arguments can be added to influence",
            "                  the display.",
            "     /rss : a rss feed summarizing all failed builds. The same",
            "            query-arguments used by 'waterfall' can be added to",
            "            influence the feed output.",
            "     /atom : an atom feed summarizing all failed builds. The same",
            "             query-arguments used by 'waterfall' can be added to",
            "             influence the feed output.",
            "     /grid : another summary display that shows a grid of builds, with",
            "             sourcestamps on the x axis, and builders on the y.  Query",
            "             arguments similar to those for the waterfall can be added.",
            "     /tgrid : similar to the grid display, but the commits are down the",
            "              left side, and the build hosts are across the top.",
            "     /builders/BUILDERNAME: a page summarizing the builder. This includes",
            "                            references to the Schedulers that feed it,",
            "                            any builds currently in the queue, which",
            "                            buildslaves are designated or attached, and a",
            "                            summary of the build process it uses.",
            "     /builders/BUILDERNAME/builds/NUM: a page describing a single Build",
            "     /builders/BUILDERNAME/builds/NUM/steps/STEPNAME: describes a single step",
            "     /builders/BUILDERNAME/builds/NUM/steps/STEPNAME/logs/LOGNAME: a StatusLog",
            "     /builders/BUILDERNAME/builds/NUM/tests : summarize test results",
            "     /builders/BUILDERNAME/builds/NUM/tests/TEST.NAME: results of one test",
            "     /builders/_all/{force,stop}: force a build/stop building on all builders.",
            "     /changes : summarize all ChangeSources",
            "     /changes/CHANGENUM: a page describing a single Change",
            "     /schedulers/SCHEDULERNAME: a page describing a Scheduler, including",
            "                                a description of its behavior, a list of the",
            "                                Builders it triggers, and list of the Changes",
            "                                that are queued awaiting the tree-stable",
            "                                timer, and controls to accelerate the timer.",
            "     /buildslaves : list all BuildSlaves",
            "     /buildslaves/SLAVENAME : describe a single BuildSlave",
            "     /one_line_per_build : summarize the last few builds, one line each",
            "     /one_line_per_build/BUILDERNAME : same, but only for a single builder",
            "     /one_box_per_builder : show the latest build and current activity",
            "     /about : describe this buildmaster (Buildbot and support library versions)",
            "     /xmlrpc : (not yet implemented) an XMLRPC server with build status",
            "",
            "",
            "    All URLs for pages which are not defined here are used to look",
            "    for files in PUBLIC_HTML, which defaults to BASEDIR/public_html.",
            "    This means that /robots.txt or /buildbot.css or /favicon.ico can",
            "    be placed in that directory.",
            "",
            "    If an index file (index.html, index.htm, or index, in that order) is",
            "    present in PUBLIC_HTML, it will be used for the root resource. If not,",
            "    the default behavior is to put a redirection to the /waterfall page.",
            "",
            "    All of the resources provided by this service use relative URLs to reach",
            "    each other. The only absolute links are the c['projectURL'] links at the",
            "    top and bottom of the page, and the buildbot home-page link at the",
            "    bottom.",
            "",
            "    This webserver defines class attributes on elements so they can be styled",
            "    with CSS stylesheets. All pages pull in PUBLIC_HTML/buildbot.css, and you",
            "    can cause additional stylesheets to be loaded by adding a suitable <link>",
            "    to the WebStatus instance's .head_elements attribute.",
            "",
            "    Buildbot uses some generic classes to identify the type of object, and",
            "    some more specific classes for the various kinds of those types. It does",
            "    this by specifying both in the class attributes where applicable,",
            "    separated by a space. It is important that in your CSS you declare the",
            "    more generic class styles above the more specific ones. For example,",
            "    first define a style for .Event, and below that for .SUCCESS",
            "",
            "    The following CSS class names are used:",
            "        - Activity, Event, BuildStep, LastBuild: general classes",
            "        - waiting, interlocked, building, offline, idle: Activity states",
            "        - start, running, success, failure, warnings, skipped, exception:",
            "          LastBuild and BuildStep states",
            "        - Change: box with change",
            "        - Builder: box for builder name (at top)",
            "        - Project",
            "        - Time",
            "",
            "    \"\"\"",
            "",
            "    # we are not a ComparableMixin, and therefore the webserver will be",
            "    # rebuilt every time we reconfig. This is because WebStatus.putChild()",
            "    # makes it too difficult to tell whether two instances are the same or",
            "    # not (we'd have to do a recursive traversal of all children to discover",
            "    # all the changes).",
            "",
            "    def __init__(self, http_port=None, distrib_port=None, allowForce=False,",
            "                 public_html=\"public_html\", site=None, numbuilds=20, auth=None):",
            "        \"\"\"Run a web server that provides Buildbot status.",
            "",
            "        @type  http_port: int or L{twisted.application.strports} string",
            "        @param http_port: a strports specification describing which port the",
            "                          buildbot should use for its web server, with the",
            "                          Waterfall display as the root page. For backwards",
            "                          compatibility this can also be an int. Use",
            "                          'tcp:8000' to listen on that port, or",
            "                          'tcp:12345:interface=127.0.0.1' if you only want",
            "                          local processes to connect to it (perhaps because",
            "                          you are using an HTTP reverse proxy to make the",
            "                          buildbot available to the outside world, and do not",
            "                          want to make the raw port visible).",
            "",
            "        @type  distrib_port: int or L{twisted.application.strports} string",
            "        @param distrib_port: Use this if you want to publish the Waterfall",
            "                             page using web.distrib instead. The most common",
            "                             case is to provide a string that is an absolute",
            "                             pathname to the unix socket on which the",
            "                             publisher should listen",
            "                             (C{os.path.expanduser(~/.twistd-web-pb)} will",
            "                             match the default settings of a standard",
            "                             twisted.web 'personal web server'). Another",
            "                             possibility is to pass an integer, which means",
            "                             the publisher should listen on a TCP socket,",
            "                             allowing the web server to be on a different",
            "                             machine entirely. Both forms are provided for",
            "                             backwards compatibility; the preferred form is a",
            "                             strports specification like",
            "                             'unix:/home/buildbot/.twistd-web-pb'. Providing",
            "                             a non-absolute pathname will probably confuse",
            "                             the strports parser.",
            "",
            "        @param allowForce: boolean, if True then the webserver will allow",
            "                           visitors to trigger and cancel builds",
            "",
            "        @param public_html: the path to the public_html directory for this display,",
            "                            either absolute or relative to the basedir.  The default",
            "                            is 'public_html', which selects BASEDIR/public_html.",
            "",
            "        @type site: None or L{twisted.web.server.Site}",
            "        @param site: Use this if you want to define your own object instead of",
            "                     using the default.`",
            "",
            "        @type numbuilds: int",
            "        @param numbuilds: Default number of entries in lists at the /one_line_per_build",
            "        and /builders/FOO URLs.  This default can be overriden both programatically ---",
            "        by passing the equally named argument to constructors of OneLinePerBuildOneBuilder",
            "        and OneLinePerBuild --- and via the UI, by tacking ?numbuilds=xy onto the URL.",
            "",
            "        @type auth: a L{status.web.auth.IAuth} or C{None}",
            "        @param auth: an object that performs authentication to restrict access",
            "                     to the C{allowForce} features. Ignored if C{allowForce}",
            "                     is not C{True}. If C{auth} is C{None}, people can force or",
            "                     stop builds without auth.",
            "        \"\"\"",
            "",
            "        service.MultiService.__init__(self)",
            "        if type(http_port) is int:",
            "            http_port = \"tcp:%d\" % http_port",
            "        self.http_port = http_port",
            "        if distrib_port is not None:",
            "            if type(distrib_port) is int:",
            "                distrib_port = \"tcp:%d\" % distrib_port",
            "            if distrib_port[0] in \"/~.\": # pathnames",
            "                distrib_port = \"unix:%s\" % distrib_port",
            "        self.distrib_port = distrib_port",
            "        self.allowForce = allowForce",
            "        self.public_html = public_html",
            "",
            "        if self.allowForce and auth:",
            "            assert IAuth.providedBy(auth)",
            "            self.auth = auth",
            "        else:",
            "            if auth:",
            "                log.msg(\"Warning: Ignoring authentication. allowForce must be\"",
            "                        \" set to True use this\")",
            "            self.auth = None",
            "",
            "        # If we were given a site object, go ahead and use it.",
            "        if site:",
            "            self.site = site",
            "        else:",
            "            # this will be replaced once we've been attached to a parent (and",
            "            # thus have a basedir and can reference BASEDIR)",
            "            root = static.Data(\"placeholder\", \"text/plain\")",
            "            self.site = server.Site(root)",
            "        self.childrenToBeAdded = {}",
            "",
            "        self.setupUsualPages(numbuilds=numbuilds)",
            "",
            "        # the following items are accessed by HtmlResource when it renders",
            "        # each page.",
            "        self.site.buildbot_service = self",
            "        self.header = HEADER",
            "        self.head_elements = HEAD_ELEMENTS[:]",
            "        self.body_attrs = BODY_ATTRS.copy()",
            "        self.footer = FOOTER",
            "        self.template_values = {}",
            "",
            "        # keep track of cached connections so we can break them when we shut",
            "        # down. See ticket #102 for more details.",
            "        self.channels = weakref.WeakKeyDictionary()",
            "",
            "        if self.http_port is not None:",
            "            s = strports.service(self.http_port, self.site)",
            "            s.setServiceParent(self)",
            "        if self.distrib_port is not None:",
            "            f = pb.PBServerFactory(distrib.ResourcePublisher(self.site))",
            "            s = strports.service(self.distrib_port, f)",
            "            s.setServiceParent(self)",
            "",
            "    def setupUsualPages(self, numbuilds):",
            "        #self.putChild(\"\", IndexOrWaterfallRedirection())",
            "        self.putChild(\"waterfall\", WaterfallStatusResource())",
            "        self.putChild(\"grid\", GridStatusResource())",
            "        self.putChild(\"tgrid\", TransposedGridStatusResource())",
            "        self.putChild(\"builders\", BuildersResource()) # has builds/steps/logs",
            "        self.putChild(\"changes\", ChangesResource())",
            "        self.putChild(\"buildslaves\", BuildSlavesResource())",
            "        self.putChild(\"buildstatus\", BuildStatusStatusResource())",
            "        #self.putChild(\"schedulers\", SchedulersResource())",
            "        self.putChild(\"one_line_per_build\",",
            "                      OneLinePerBuild(numbuilds=numbuilds))",
            "        self.putChild(\"one_box_per_builder\", OneBoxPerBuilder())",
            "        self.putChild(\"xmlrpc\", XMLRPCServer())",
            "        self.putChild(\"about\", AboutBuildbot())",
            "        self.putChild(\"authfail\", AuthFailResource())",
            "",
            "    def __repr__(self):",
            "        if self.http_port is None:",
            "            return \"<WebStatus on path %s at %s>\" % (self.distrib_port,",
            "                                                     hex(id(self)))",
            "        if self.distrib_port is None:",
            "            return \"<WebStatus on port %s at %s>\" % (self.http_port,",
            "                                                     hex(id(self)))",
            "        return (\"<WebStatus on port %s and path %s at %s>\" %",
            "                (self.http_port, self.distrib_port, hex(id(self))))",
            "",
            "    def setServiceParent(self, parent):",
            "        service.MultiService.setServiceParent(self, parent)",
            "",
            "        # this class keeps a *separate* link to the buildmaster, rather than",
            "        # just using self.parent, so that when we are \"disowned\" (and thus",
            "        # parent=None), any remaining HTTP clients of this WebStatus will still",
            "        # be able to get reasonable results.",
            "        self.master = parent",
            "",
            "        self.setupSite()",
            "",
            "    def setupSite(self):",
            "        # this is responsible for creating the root resource. It isn't done",
            "        # at __init__ time because we need to reference the parent's basedir.",
            "        htmldir = os.path.abspath(os.path.join(self.master.basedir, self.public_html))",
            "        if os.path.isdir(htmldir):",
            "            log.msg(\"WebStatus using (%s)\" % htmldir)",
            "        else:",
            "            log.msg(\"WebStatus: warning: %s is missing. Do you need to run\"",
            "                    \" 'buildbot upgrade-master' on this buildmaster?\" % htmldir)",
            "            # all static pages will get a 404 until upgrade-master is used to",
            "            # populate this directory. Create the directory, though, since",
            "            # otherwise we get internal server errors instead of 404s.",
            "            os.mkdir(htmldir)",
            "        root = static.File(htmldir)",
            "",
            "        for name, child_resource in self.childrenToBeAdded.iteritems():",
            "            root.putChild(name, child_resource)",
            "",
            "        status = self.getStatus()",
            "        root.putChild(\"rss\", Rss20StatusResource(status))",
            "        root.putChild(\"atom\", Atom10StatusResource(status))",
            "",
            "        self.site.resource = root",
            "",
            "    def putChild(self, name, child_resource):",
            "        \"\"\"This behaves a lot like root.putChild() . \"\"\"",
            "        self.childrenToBeAdded[name] = child_resource",
            "",
            "    def registerChannel(self, channel):",
            "        self.channels[channel] = 1 # weakrefs",
            "",
            "    def stopService(self):",
            "        for channel in self.channels:",
            "            try:",
            "                channel.transport.loseConnection()",
            "            except:",
            "                log.msg(\"WebStatus.stopService: error while disconnecting\"",
            "                        \" leftover clients\")",
            "                log.err()",
            "        return service.MultiService.stopService(self)",
            "",
            "    def getStatus(self):",
            "        return self.master.getStatus()",
            "",
            "    def getControl(self):",
            "        if self.allowForce:",
            "            return IControl(self.master)",
            "        return None",
            "",
            "    def getChangeSvc(self):",
            "        return self.master.change_svc",
            "",
            "    def getPortnum(self):",
            "        # this is for the benefit of unit tests",
            "        s = list(self)[0]",
            "        return s._port.getHost().port",
            "",
            "    def isUsingUserPasswd(self):",
            "        \"\"\"Returns boolean to indicate if this WebStatus uses authentication\"\"\"",
            "        if self.auth:",
            "            return True",
            "        return False",
            "",
            "    def authUser(self, user, passwd):",
            "        \"\"\"Check that user/passwd is a valid user/pass tuple and can should be",
            "        allowed to perform the action. If this WebStatus is not password",
            "        protected, this function returns False.\"\"\"",
            "        if not self.isUsingUserPasswd():",
            "            return False",
            "        if self.auth.authenticate(user, passwd):",
            "            return True",
            "        log.msg(\"Authentication failed for '%s': %s\" % (user,",
            "                                                        self.auth.errmsg()))",
            "        return False",
            "",
            "# resources can get access to the IStatus by calling",
            "# request.site.buildbot_service.getStatus()",
            "",
            "# this is the compatibility class for the old waterfall. It is exactly like a",
            "# regular WebStatus except that the root resource (e.g. http://buildbot.net/)",
            "# always redirects to a WaterfallStatusResource, and the old arguments are",
            "# mapped into the new resource-tree approach. In the normal WebStatus, the",
            "# root resource either redirects the browser to /waterfall or serves",
            "# PUBLIC_HTML/index.html, and favicon/robots.txt are provided by",
            "# having the admin write actual files into PUBLIC_HTML/ .",
            "",
            "# note: we don't use a util.Redirect here because HTTP requires that the",
            "# Location: header provide an absolute URI, and it's non-trivial to figure",
            "# out our absolute URI from here.",
            "",
            "class Waterfall(WebStatus):",
            "",
            "    if hasattr(sys, \"frozen\"):",
            "        # all 'data' files are in the directory of our executable",
            "        here = os.path.dirname(sys.executable)",
            "        buildbot_icon = os.path.abspath(os.path.join(here, \"buildbot.png\"))",
            "        buildbot_css = os.path.abspath(os.path.join(here, \"classic.css\"))",
            "    else:",
            "        # running from source",
            "        # the icon is sibpath(__file__, \"../buildbot.png\") . This is for",
            "        # portability.",
            "        up = os.path.dirname",
            "        buildbot_icon = os.path.abspath(os.path.join(up(up(up(__file__))),",
            "                                                     \"buildbot.png\"))",
            "        buildbot_css = os.path.abspath(os.path.join(up(__file__),",
            "                                                    \"classic.css\"))",
            "",
            "    compare_attrs = [\"http_port\", \"distrib_port\", \"allowForce\",",
            "                     \"categories\", \"css\", \"favicon\", \"robots_txt\"]",
            "",
            "    def __init__(self, http_port=None, distrib_port=None, allowForce=True,",
            "                 categories=None, css=buildbot_css, favicon=buildbot_icon,",
            "                 robots_txt=None):",
            "        import warnings",
            "        m = (\"buildbot.status.html.Waterfall is deprecated as of 0.7.6 \"",
            "             \"and will be removed from a future release. \"",
            "             \"Please use html.WebStatus instead.\")",
            "        warnings.warn(m, DeprecationWarning)",
            "",
            "        WebStatus.__init__(self, http_port, distrib_port, allowForce)",
            "        self.css = css",
            "        if css:",
            "            if os.path.exists(os.path.join(\"public_html\", \"buildbot.css\")):",
            "                # they've upgraded, so defer to that copy instead",
            "                pass",
            "            else:",
            "                data = open(css, \"rb\").read()",
            "                self.putChild(\"buildbot.css\", static.Data(data, \"text/css\"))",
            "        self.favicon = favicon",
            "        self.robots_txt = robots_txt",
            "        if favicon:",
            "            data = open(favicon, \"rb\").read()",
            "            self.putChild(\"favicon.ico\", static.Data(data, \"image/x-icon\"))",
            "        if robots_txt:",
            "            data = open(robots_txt, \"rb\").read()",
            "            self.putChild(\"robots.txt\", static.Data(data, \"text/plain\"))",
            "        self.putChild(\"\", WaterfallStatusResource(categories))"
        ],
        "afterPatchFile": [
            "",
            "import os, sys, urllib, weakref",
            "from itertools import count",
            "",
            "from zope.interface import implements",
            "from twisted.python import log",
            "from twisted.application import strports, service",
            "from twisted.web import server, distrib, static, html",
            "from twisted.spread import pb",
            "",
            "from buildbot.interfaces import IControl, IStatusReceiver",
            "",
            "from buildbot.status.web.base import HtmlResource, Box, \\",
            "     build_get_class, ICurrentBox, OneLineMixin, map_branches, \\",
            "     make_stop_form, make_force_build_form",
            "from buildbot.status.web.feeds import Rss20StatusResource, \\",
            "     Atom10StatusResource",
            "from buildbot.status.web.waterfall import WaterfallStatusResource",
            "from buildbot.status.web.grid import GridStatusResource, TransposedGridStatusResource",
            "from buildbot.status.web.changes import ChangesResource",
            "from buildbot.status.web.builder import BuildersResource",
            "from buildbot.status.web.buildstatus import BuildStatusStatusResource ",
            "from buildbot.status.web.slaves import BuildSlavesResource",
            "from buildbot.status.web.xmlrpc import XMLRPCServer",
            "from buildbot.status.web.about import AboutBuildbot",
            "from buildbot.status.web.auth import IAuth, AuthFailResource",
            "",
            "# this class contains the status services (WebStatus and the older Waterfall)",
            "# which can be put in c['status']. It also contains some of the resources",
            "# that are attached to the WebStatus at various well-known URLs, which the",
            "# admin might wish to attach (using WebStatus.putChild) at other URLs.",
            "",
            "",
            "class LastBuild(HtmlResource):",
            "    def body(self, request):",
            "        return \"missing\\n\"",
            "",
            "def getLastNBuilds(status, numbuilds, builders=[], branches=[]):",
            "    \"\"\"Return a list with the last few Builds, sorted by start time.",
            "    builder_names=None means all builders",
            "    \"\"\"",
            "",
            "    # TODO: this unsorts the list of builder names, ick",
            "    builder_names = set(status.getBuilderNames())",
            "    if builders:",
            "        builder_names = builder_names.intersection(set(builders))",
            "",
            "    # to make sure that we get everything, we must get 'numbuilds' builds",
            "    # from *each* source, then sort by ending time, then trim to the last",
            "    # 20. We could be more efficient, but it would require the same",
            "    # gnarly code that the Waterfall uses to generate one event at a",
            "    # time. TODO: factor that code out into some useful class.",
            "    events = []",
            "    for builder_name in builder_names:",
            "        builder = status.getBuilder(builder_name)",
            "        for build_number in count(1):",
            "            if build_number > numbuilds:",
            "                break # enough from this builder, move on to another",
            "            build = builder.getBuild(-build_number)",
            "            if not build:",
            "                break # no more builds here, move on to the next builder",
            "            #if not build.isFinished():",
            "            #    continue",
            "            (build_start, build_end) = build.getTimes()",
            "            event = (build_start, builder_name, build)",
            "            events.append(event)",
            "    def _sorter(a, b):",
            "        return cmp( a[:2], b[:2] )",
            "    events.sort(_sorter)",
            "    # now only return the actual build, and only return some of them",
            "    return [e[2] for e in events[-numbuilds:]]",
            "",
            "",
            "# /one_line_per_build",
            "#  accepts builder=, branch=, numbuilds=, reload=",
            "class OneLinePerBuild(HtmlResource, OneLineMixin):",
            "    \"\"\"This shows one line per build, combining all builders together. Useful",
            "    query arguments:",
            "",
            "    numbuilds=: how many lines to display",
            "    builder=: show only builds for this builder. Multiple builder= arguments",
            "              can be used to see builds from any builder in the set.",
            "    reload=: reload the page after this many seconds",
            "    \"\"\"",
            "",
            "    title = \"Recent Builds\"",
            "",
            "    def __init__(self, numbuilds=20):",
            "        HtmlResource.__init__(self)",
            "        self.numbuilds = numbuilds",
            "",
            "    def getChild(self, path, req):",
            "        status = self.getStatus(req)",
            "        builder = status.getBuilder(path)",
            "        return OneLinePerBuildOneBuilder(builder, numbuilds=self.numbuilds)",
            "",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        control = self.getControl(req)",
            "        numbuilds = int(req.args.get(\"numbuilds\", [self.numbuilds])[0])",
            "        builders = req.args.get(\"builder\", [])",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        g = status.generateFinishedBuilds(builders, map_branches(branches),",
            "                                          numbuilds, max_search=numbuilds)",
            "",
            "        data = \"\"",
            "",
            "        # really this is \"up to %d builds\"",
            "        html_branches = map(html.escape, branches)",
            "        data += \"<h1>Last %d finished builds: %s</h1>\\n\" % \\",
            "                (numbuilds, \", \".join(html_branches))",
            "        if builders:",
            "            html_builders = map(html.escape, builders)",
            "            data += (\"<p>of builders: %s</p>\\n\" % (\", \".join(html_builders)))",
            "        data += \"<ul>\\n\"",
            "        got = 0",
            "        building = False",
            "        online = 0",
            "        for build in g:",
            "            got += 1",
            "            data += \" <li>\" + self.make_line(req, build) + \"</li>\\n\"",
            "            builder_status = build.getBuilder().getState()[0]",
            "            if builder_status == \"building\":",
            "                building = True",
            "                online += 1",
            "            elif builder_status != \"offline\":",
            "                online += 1",
            "        if not got:",
            "            data += \" <li>No matching builds found</li>\\n\"",
            "        data += \"</ul>\\n\"",
            "",
            "        if control is not None:",
            "            if building:",
            "                stopURL = \"builders/_all/stop\"",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req),",
            "                                       True, \"Builds\")",
            "            if online:",
            "                forceURL = \"builders/_all/force\"",
            "                data += make_force_build_form(forceURL,",
            "                                              self.isUsingUserPasswd(req), True)",
            "",
            "        return data",
            "",
            "",
            "",
            "# /one_line_per_build/$BUILDERNAME",
            "#  accepts branch=, numbuilds=",
            "",
            "class OneLinePerBuildOneBuilder(HtmlResource, OneLineMixin):",
            "    def __init__(self, builder, numbuilds=20):",
            "        HtmlResource.__init__(self)",
            "        self.builder = builder",
            "        self.builder_name = builder.getName()",
            "        self.numbuilds = numbuilds",
            "        self.title = \"Recent Builds of %s\" % self.builder_name",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        numbuilds = int(req.args.get(\"numbuilds\", [self.numbuilds])[0])",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        # walk backwards through all builds of a single builder",
            "        g = self.builder.generateFinishedBuilds(map_branches(branches),",
            "                                                numbuilds)",
            "",
            "        data = \"\"",
            "        html_branches = map(html.escape, branches)",
            "        data += (\"<h1>Last %d builds of builder %s: %s</h1>\\n\" %",
            "                 (numbuilds, self.builder_name, \", \".join(html_branches)))",
            "        data += \"<ul>\\n\"",
            "        got = 0",
            "        for build in g:",
            "            got += 1",
            "            data += \" <li>\" + self.make_line(req, build) + \"</li>\\n\"",
            "        if not got:",
            "            data += \" <li>No matching builds found</li>\\n\"",
            "        data += \"</ul>\\n\"",
            "",
            "        return data",
            "",
            "# /one_box_per_builder",
            "#  accepts builder=, branch=",
            "class OneBoxPerBuilder(HtmlResource):",
            "    \"\"\"This shows a narrow table with one row per builder. The leftmost column",
            "    contains the builder name. The next column contains the results of the",
            "    most recent build. The right-hand column shows the builder's current",
            "    activity.",
            "",
            "    builder=: show only builds for this builder. Multiple builder= arguments",
            "              can be used to see builds from any builder in the set.",
            "    \"\"\"",
            "",
            "    title = \"Latest Build\"",
            "",
            "    def body(self, req):",
            "        status = self.getStatus(req)",
            "        control = self.getControl(req)",
            "",
            "        builders = req.args.get(\"builder\", status.getBuilderNames())",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "",
            "        data = \"\"",
            "",
            "        html_branches = map(html.escape, branches)",
            "        data += \"<h2>Latest builds: %s</h2>\\n\" % \", \".join(branches)",
            "        data += \"<table>\\n\"",
            "",
            "        building = False",
            "        online = 0",
            "        base_builders_url = self.path_to_root(req) + \"builders/\"",
            "        for bn in builders:",
            "            base_builder_url = base_builders_url + urllib.quote(bn, safe='')",
            "            builder = status.getBuilder(bn)",
            "            data += \"<tr>\\n\"",
            "            data += '<td class=\"box\"><a href=\"%s\">%s</a></td>\\n' \\",
            "                  % (base_builder_url, html.escape(bn))",
            "            builds = list(builder.generateFinishedBuilds(map_branches(branches),",
            "                                                         num_builds=1))",
            "            if builds:",
            "                b = builds[0]",
            "                url = (base_builder_url + \"/builds/%d\" % b.getNumber())",
            "                try:",
            "                    label = b.getProperty(\"got_revision\")",
            "                except KeyError:",
            "                    label = None",
            "                if not label or len(str(label)) > 20:",
            "                    label = \"#%d\" % b.getNumber()",
            "                text = ['<a href=\"%s\">%s</a>' % (url, label)]",
            "                text.extend(b.getText())",
            "                box = Box(text,",
            "                          class_=\"LastBuild box %s\" % build_get_class(b))",
            "                data += box.td(align=\"center\")",
            "            else:",
            "                data += '<td class=\"LastBuild box\" >no build</td>\\n'",
            "            current_box = ICurrentBox(builder).getBox(status)",
            "            data += current_box.td(align=\"center\")",
            "",
            "            builder_status = builder.getState()[0]",
            "            if builder_status == \"building\":",
            "                building = True",
            "                online += 1",
            "            elif builder_status != \"offline\":",
            "                online += 1",
            "",
            "        data += \"</table>\\n\"",
            "",
            "        if control is not None:",
            "            if building:",
            "                stopURL = \"builders/_all/stop\"",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req),",
            "                                       True, \"Builds\")",
            "            if online:",
            "                forceURL = \"builders/_all/force\"",
            "                data += make_force_build_form(forceURL,",
            "                                              self.isUsingUserPasswd(req), True)",
            "",
            "        return data",
            "",
            "",
            "",
            "HEADER = '''",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"",
            " \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
            "",
            "<html",
            " xmlns=\"http://www.w3.org/1999/xhtml\"",
            " lang=\"en\"",
            " xml:lang=\"en\">",
            "'''",
            "",
            "HEAD_ELEMENTS = [",
            "    '<title>%(title)s</title>',",
            "    '<link href=\"%(root)sbuildbot.css\" rel=\"stylesheet\" type=\"text/css\" />',",
            "    ]",
            "BODY_ATTRS = {",
            "    'vlink': \"#800080\",",
            "    }",
            "",
            "FOOTER = '''",
            "</html>",
            "'''",
            "",
            "",
            "class WebStatus(service.MultiService):",
            "    implements(IStatusReceiver)",
            "    # TODO: IStatusReceiver is really about things which subscribe to hear",
            "    # about buildbot events. We need a different interface (perhaps a parent",
            "    # of IStatusReceiver) for status targets that don't subscribe, like the",
            "    # WebStatus class. buildbot.master.BuildMaster.loadConfig:737 asserts",
            "    # that everything in c['status'] provides IStatusReceiver, but really it",
            "    # should check that they provide IStatusTarget instead.",
            "",
            "    \"\"\"",
            "    The webserver provided by this class has the following resources:",
            "",
            "     /waterfall : the big time-oriented 'waterfall' display, with links",
            "                  to individual changes, builders, builds, steps, and logs.",
            "                  A number of query-arguments can be added to influence",
            "                  the display.",
            "     /rss : a rss feed summarizing all failed builds. The same",
            "            query-arguments used by 'waterfall' can be added to",
            "            influence the feed output.",
            "     /atom : an atom feed summarizing all failed builds. The same",
            "             query-arguments used by 'waterfall' can be added to",
            "             influence the feed output.",
            "     /grid : another summary display that shows a grid of builds, with",
            "             sourcestamps on the x axis, and builders on the y.  Query",
            "             arguments similar to those for the waterfall can be added.",
            "     /tgrid : similar to the grid display, but the commits are down the",
            "              left side, and the build hosts are across the top.",
            "     /builders/BUILDERNAME: a page summarizing the builder. This includes",
            "                            references to the Schedulers that feed it,",
            "                            any builds currently in the queue, which",
            "                            buildslaves are designated or attached, and a",
            "                            summary of the build process it uses.",
            "     /builders/BUILDERNAME/builds/NUM: a page describing a single Build",
            "     /builders/BUILDERNAME/builds/NUM/steps/STEPNAME: describes a single step",
            "     /builders/BUILDERNAME/builds/NUM/steps/STEPNAME/logs/LOGNAME: a StatusLog",
            "     /builders/BUILDERNAME/builds/NUM/tests : summarize test results",
            "     /builders/BUILDERNAME/builds/NUM/tests/TEST.NAME: results of one test",
            "     /builders/_all/{force,stop}: force a build/stop building on all builders.",
            "     /changes : summarize all ChangeSources",
            "     /changes/CHANGENUM: a page describing a single Change",
            "     /schedulers/SCHEDULERNAME: a page describing a Scheduler, including",
            "                                a description of its behavior, a list of the",
            "                                Builders it triggers, and list of the Changes",
            "                                that are queued awaiting the tree-stable",
            "                                timer, and controls to accelerate the timer.",
            "     /buildslaves : list all BuildSlaves",
            "     /buildslaves/SLAVENAME : describe a single BuildSlave",
            "     /one_line_per_build : summarize the last few builds, one line each",
            "     /one_line_per_build/BUILDERNAME : same, but only for a single builder",
            "     /one_box_per_builder : show the latest build and current activity",
            "     /about : describe this buildmaster (Buildbot and support library versions)",
            "     /xmlrpc : (not yet implemented) an XMLRPC server with build status",
            "",
            "",
            "    All URLs for pages which are not defined here are used to look",
            "    for files in PUBLIC_HTML, which defaults to BASEDIR/public_html.",
            "    This means that /robots.txt or /buildbot.css or /favicon.ico can",
            "    be placed in that directory.",
            "",
            "    If an index file (index.html, index.htm, or index, in that order) is",
            "    present in PUBLIC_HTML, it will be used for the root resource. If not,",
            "    the default behavior is to put a redirection to the /waterfall page.",
            "",
            "    All of the resources provided by this service use relative URLs to reach",
            "    each other. The only absolute links are the c['projectURL'] links at the",
            "    top and bottom of the page, and the buildbot home-page link at the",
            "    bottom.",
            "",
            "    This webserver defines class attributes on elements so they can be styled",
            "    with CSS stylesheets. All pages pull in PUBLIC_HTML/buildbot.css, and you",
            "    can cause additional stylesheets to be loaded by adding a suitable <link>",
            "    to the WebStatus instance's .head_elements attribute.",
            "",
            "    Buildbot uses some generic classes to identify the type of object, and",
            "    some more specific classes for the various kinds of those types. It does",
            "    this by specifying both in the class attributes where applicable,",
            "    separated by a space. It is important that in your CSS you declare the",
            "    more generic class styles above the more specific ones. For example,",
            "    first define a style for .Event, and below that for .SUCCESS",
            "",
            "    The following CSS class names are used:",
            "        - Activity, Event, BuildStep, LastBuild: general classes",
            "        - waiting, interlocked, building, offline, idle: Activity states",
            "        - start, running, success, failure, warnings, skipped, exception:",
            "          LastBuild and BuildStep states",
            "        - Change: box with change",
            "        - Builder: box for builder name (at top)",
            "        - Project",
            "        - Time",
            "",
            "    \"\"\"",
            "",
            "    # we are not a ComparableMixin, and therefore the webserver will be",
            "    # rebuilt every time we reconfig. This is because WebStatus.putChild()",
            "    # makes it too difficult to tell whether two instances are the same or",
            "    # not (we'd have to do a recursive traversal of all children to discover",
            "    # all the changes).",
            "",
            "    def __init__(self, http_port=None, distrib_port=None, allowForce=False,",
            "                 public_html=\"public_html\", site=None, numbuilds=20, auth=None):",
            "        \"\"\"Run a web server that provides Buildbot status.",
            "",
            "        @type  http_port: int or L{twisted.application.strports} string",
            "        @param http_port: a strports specification describing which port the",
            "                          buildbot should use for its web server, with the",
            "                          Waterfall display as the root page. For backwards",
            "                          compatibility this can also be an int. Use",
            "                          'tcp:8000' to listen on that port, or",
            "                          'tcp:12345:interface=127.0.0.1' if you only want",
            "                          local processes to connect to it (perhaps because",
            "                          you are using an HTTP reverse proxy to make the",
            "                          buildbot available to the outside world, and do not",
            "                          want to make the raw port visible).",
            "",
            "        @type  distrib_port: int or L{twisted.application.strports} string",
            "        @param distrib_port: Use this if you want to publish the Waterfall",
            "                             page using web.distrib instead. The most common",
            "                             case is to provide a string that is an absolute",
            "                             pathname to the unix socket on which the",
            "                             publisher should listen",
            "                             (C{os.path.expanduser(~/.twistd-web-pb)} will",
            "                             match the default settings of a standard",
            "                             twisted.web 'personal web server'). Another",
            "                             possibility is to pass an integer, which means",
            "                             the publisher should listen on a TCP socket,",
            "                             allowing the web server to be on a different",
            "                             machine entirely. Both forms are provided for",
            "                             backwards compatibility; the preferred form is a",
            "                             strports specification like",
            "                             'unix:/home/buildbot/.twistd-web-pb'. Providing",
            "                             a non-absolute pathname will probably confuse",
            "                             the strports parser.",
            "",
            "        @param allowForce: boolean, if True then the webserver will allow",
            "                           visitors to trigger and cancel builds",
            "",
            "        @param public_html: the path to the public_html directory for this display,",
            "                            either absolute or relative to the basedir.  The default",
            "                            is 'public_html', which selects BASEDIR/public_html.",
            "",
            "        @type site: None or L{twisted.web.server.Site}",
            "        @param site: Use this if you want to define your own object instead of",
            "                     using the default.`",
            "",
            "        @type numbuilds: int",
            "        @param numbuilds: Default number of entries in lists at the /one_line_per_build",
            "        and /builders/FOO URLs.  This default can be overriden both programatically ---",
            "        by passing the equally named argument to constructors of OneLinePerBuildOneBuilder",
            "        and OneLinePerBuild --- and via the UI, by tacking ?numbuilds=xy onto the URL.",
            "",
            "        @type auth: a L{status.web.auth.IAuth} or C{None}",
            "        @param auth: an object that performs authentication to restrict access",
            "                     to the C{allowForce} features. Ignored if C{allowForce}",
            "                     is not C{True}. If C{auth} is C{None}, people can force or",
            "                     stop builds without auth.",
            "        \"\"\"",
            "",
            "        service.MultiService.__init__(self)",
            "        if type(http_port) is int:",
            "            http_port = \"tcp:%d\" % http_port",
            "        self.http_port = http_port",
            "        if distrib_port is not None:",
            "            if type(distrib_port) is int:",
            "                distrib_port = \"tcp:%d\" % distrib_port",
            "            if distrib_port[0] in \"/~.\": # pathnames",
            "                distrib_port = \"unix:%s\" % distrib_port",
            "        self.distrib_port = distrib_port",
            "        self.allowForce = allowForce",
            "        self.public_html = public_html",
            "",
            "        if self.allowForce and auth:",
            "            assert IAuth.providedBy(auth)",
            "            self.auth = auth",
            "        else:",
            "            if auth:",
            "                log.msg(\"Warning: Ignoring authentication. allowForce must be\"",
            "                        \" set to True use this\")",
            "            self.auth = None",
            "",
            "        # If we were given a site object, go ahead and use it.",
            "        if site:",
            "            self.site = site",
            "        else:",
            "            # this will be replaced once we've been attached to a parent (and",
            "            # thus have a basedir and can reference BASEDIR)",
            "            root = static.Data(\"placeholder\", \"text/plain\")",
            "            self.site = server.Site(root)",
            "        self.childrenToBeAdded = {}",
            "",
            "        self.setupUsualPages(numbuilds=numbuilds)",
            "",
            "        # the following items are accessed by HtmlResource when it renders",
            "        # each page.",
            "        self.site.buildbot_service = self",
            "        self.header = HEADER",
            "        self.head_elements = HEAD_ELEMENTS[:]",
            "        self.body_attrs = BODY_ATTRS.copy()",
            "        self.footer = FOOTER",
            "        self.template_values = {}",
            "",
            "        # keep track of cached connections so we can break them when we shut",
            "        # down. See ticket #102 for more details.",
            "        self.channels = weakref.WeakKeyDictionary()",
            "",
            "        if self.http_port is not None:",
            "            s = strports.service(self.http_port, self.site)",
            "            s.setServiceParent(self)",
            "        if self.distrib_port is not None:",
            "            f = pb.PBServerFactory(distrib.ResourcePublisher(self.site))",
            "            s = strports.service(self.distrib_port, f)",
            "            s.setServiceParent(self)",
            "",
            "    def setupUsualPages(self, numbuilds):",
            "        #self.putChild(\"\", IndexOrWaterfallRedirection())",
            "        self.putChild(\"waterfall\", WaterfallStatusResource())",
            "        self.putChild(\"grid\", GridStatusResource())",
            "        self.putChild(\"tgrid\", TransposedGridStatusResource())",
            "        self.putChild(\"builders\", BuildersResource()) # has builds/steps/logs",
            "        self.putChild(\"changes\", ChangesResource())",
            "        self.putChild(\"buildslaves\", BuildSlavesResource())",
            "        self.putChild(\"buildstatus\", BuildStatusStatusResource())",
            "        #self.putChild(\"schedulers\", SchedulersResource())",
            "        self.putChild(\"one_line_per_build\",",
            "                      OneLinePerBuild(numbuilds=numbuilds))",
            "        self.putChild(\"one_box_per_builder\", OneBoxPerBuilder())",
            "        self.putChild(\"xmlrpc\", XMLRPCServer())",
            "        self.putChild(\"about\", AboutBuildbot())",
            "        self.putChild(\"authfail\", AuthFailResource())",
            "",
            "    def __repr__(self):",
            "        if self.http_port is None:",
            "            return \"<WebStatus on path %s at %s>\" % (self.distrib_port,",
            "                                                     hex(id(self)))",
            "        if self.distrib_port is None:",
            "            return \"<WebStatus on port %s at %s>\" % (self.http_port,",
            "                                                     hex(id(self)))",
            "        return (\"<WebStatus on port %s and path %s at %s>\" %",
            "                (self.http_port, self.distrib_port, hex(id(self))))",
            "",
            "    def setServiceParent(self, parent):",
            "        service.MultiService.setServiceParent(self, parent)",
            "",
            "        # this class keeps a *separate* link to the buildmaster, rather than",
            "        # just using self.parent, so that when we are \"disowned\" (and thus",
            "        # parent=None), any remaining HTTP clients of this WebStatus will still",
            "        # be able to get reasonable results.",
            "        self.master = parent",
            "",
            "        self.setupSite()",
            "",
            "    def setupSite(self):",
            "        # this is responsible for creating the root resource. It isn't done",
            "        # at __init__ time because we need to reference the parent's basedir.",
            "        htmldir = os.path.abspath(os.path.join(self.master.basedir, self.public_html))",
            "        if os.path.isdir(htmldir):",
            "            log.msg(\"WebStatus using (%s)\" % htmldir)",
            "        else:",
            "            log.msg(\"WebStatus: warning: %s is missing. Do you need to run\"",
            "                    \" 'buildbot upgrade-master' on this buildmaster?\" % htmldir)",
            "            # all static pages will get a 404 until upgrade-master is used to",
            "            # populate this directory. Create the directory, though, since",
            "            # otherwise we get internal server errors instead of 404s.",
            "            os.mkdir(htmldir)",
            "        root = static.File(htmldir)",
            "",
            "        for name, child_resource in self.childrenToBeAdded.iteritems():",
            "            root.putChild(name, child_resource)",
            "",
            "        status = self.getStatus()",
            "        root.putChild(\"rss\", Rss20StatusResource(status))",
            "        root.putChild(\"atom\", Atom10StatusResource(status))",
            "",
            "        self.site.resource = root",
            "",
            "    def putChild(self, name, child_resource):",
            "        \"\"\"This behaves a lot like root.putChild() . \"\"\"",
            "        self.childrenToBeAdded[name] = child_resource",
            "",
            "    def registerChannel(self, channel):",
            "        self.channels[channel] = 1 # weakrefs",
            "",
            "    def stopService(self):",
            "        for channel in self.channels:",
            "            try:",
            "                channel.transport.loseConnection()",
            "            except:",
            "                log.msg(\"WebStatus.stopService: error while disconnecting\"",
            "                        \" leftover clients\")",
            "                log.err()",
            "        return service.MultiService.stopService(self)",
            "",
            "    def getStatus(self):",
            "        return self.master.getStatus()",
            "",
            "    def getControl(self):",
            "        if self.allowForce:",
            "            return IControl(self.master)",
            "        return None",
            "",
            "    def getChangeSvc(self):",
            "        return self.master.change_svc",
            "",
            "    def getPortnum(self):",
            "        # this is for the benefit of unit tests",
            "        s = list(self)[0]",
            "        return s._port.getHost().port",
            "",
            "    def isUsingUserPasswd(self):",
            "        \"\"\"Returns boolean to indicate if this WebStatus uses authentication\"\"\"",
            "        if self.auth:",
            "            return True",
            "        return False",
            "",
            "    def authUser(self, user, passwd):",
            "        \"\"\"Check that user/passwd is a valid user/pass tuple and can should be",
            "        allowed to perform the action. If this WebStatus is not password",
            "        protected, this function returns False.\"\"\"",
            "        if not self.isUsingUserPasswd():",
            "            return False",
            "        if self.auth.authenticate(user, passwd):",
            "            return True",
            "        log.msg(\"Authentication failed for '%s': %s\" % (user,",
            "                                                        self.auth.errmsg()))",
            "        return False",
            "",
            "# resources can get access to the IStatus by calling",
            "# request.site.buildbot_service.getStatus()",
            "",
            "# this is the compatibility class for the old waterfall. It is exactly like a",
            "# regular WebStatus except that the root resource (e.g. http://buildbot.net/)",
            "# always redirects to a WaterfallStatusResource, and the old arguments are",
            "# mapped into the new resource-tree approach. In the normal WebStatus, the",
            "# root resource either redirects the browser to /waterfall or serves",
            "# PUBLIC_HTML/index.html, and favicon/robots.txt are provided by",
            "# having the admin write actual files into PUBLIC_HTML/ .",
            "",
            "# note: we don't use a util.Redirect here because HTTP requires that the",
            "# Location: header provide an absolute URI, and it's non-trivial to figure",
            "# out our absolute URI from here.",
            "",
            "class Waterfall(WebStatus):",
            "",
            "    if hasattr(sys, \"frozen\"):",
            "        # all 'data' files are in the directory of our executable",
            "        here = os.path.dirname(sys.executable)",
            "        buildbot_icon = os.path.abspath(os.path.join(here, \"buildbot.png\"))",
            "        buildbot_css = os.path.abspath(os.path.join(here, \"classic.css\"))",
            "    else:",
            "        # running from source",
            "        # the icon is sibpath(__file__, \"../buildbot.png\") . This is for",
            "        # portability.",
            "        up = os.path.dirname",
            "        buildbot_icon = os.path.abspath(os.path.join(up(up(up(__file__))),",
            "                                                     \"buildbot.png\"))",
            "        buildbot_css = os.path.abspath(os.path.join(up(__file__),",
            "                                                    \"classic.css\"))",
            "",
            "    compare_attrs = [\"http_port\", \"distrib_port\", \"allowForce\",",
            "                     \"categories\", \"css\", \"favicon\", \"robots_txt\"]",
            "",
            "    def __init__(self, http_port=None, distrib_port=None, allowForce=True,",
            "                 categories=None, css=buildbot_css, favicon=buildbot_icon,",
            "                 robots_txt=None):",
            "        import warnings",
            "        m = (\"buildbot.status.html.Waterfall is deprecated as of 0.7.6 \"",
            "             \"and will be removed from a future release. \"",
            "             \"Please use html.WebStatus instead.\")",
            "        warnings.warn(m, DeprecationWarning)",
            "",
            "        WebStatus.__init__(self, http_port, distrib_port, allowForce)",
            "        self.css = css",
            "        if css:",
            "            if os.path.exists(os.path.join(\"public_html\", \"buildbot.css\")):",
            "                # they've upgraded, so defer to that copy instead",
            "                pass",
            "            else:",
            "                data = open(css, \"rb\").read()",
            "                self.putChild(\"buildbot.css\", static.Data(data, \"text/css\"))",
            "        self.favicon = favicon",
            "        self.robots_txt = robots_txt",
            "        if favicon:",
            "            data = open(favicon, \"rb\").read()",
            "            self.putChild(\"favicon.ico\", static.Data(data, \"image/x-icon\"))",
            "        if robots_txt:",
            "            data = open(robots_txt, \"rb\").read()",
            "            self.putChild(\"robots.txt\", static.Data(data, \"text/plain\"))",
            "        self.putChild(\"\", WaterfallStatusResource(categories))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "127": [
                "OneLinePerBuild",
                "body"
            ],
            "129": [
                "OneLinePerBuild",
                "body"
            ],
            "183": [
                "OneLinePerBuildOneBuilder",
                "body"
            ]
        },
        "addLocation": [
            "nltk.downloader.Downloader.download"
        ]
    },
    "buildbot/status/web/build.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "                 (b.getBuilder().getName(), b.getNumber()))"
            },
            "1": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         name = req.args.get(\"username\", [\"<unknown>\"])[0]"
            },
            "2": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+        # html-quote both the username and comments, just to be safe"
            },
            "4": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         reason = (\"The web-page 'stop build' button was pressed by \""
            },
            "5": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"'%s': %s\\n\" % (name, comments))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                  \"'%s': %s\\n\" % (html.escape(name), html.escape(comments)))"
            },
            "7": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         if c:"
            },
            "8": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             c.stopBuild(reason)"
            },
            "9": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         # we're at http://localhost:8080/svn-hello/builds/5/stop?[args] and"
            },
            "10": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         # we want to go to: http://localhost:8080/svn-hello"
            },
            "11": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url = req.args.get('url', ['../..'])[0]"
            },
            "12": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r = Redirect(url)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        r = Redirect(\"../..\")"
            },
            "14": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         d = defer.Deferred()"
            },
            "15": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         reactor.callLater(1, d.callback, r)"
            },
            "16": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         return DeferredResource(d)"
            },
            "17": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         name = req.args.get(\"username\", [\"<unknown>\"])[0]"
            },
            "18": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "         comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]"
            },
            "19": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         reason = (\"The web-page 'rebuild' button was pressed by \""
            },
            "20": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"'%s': %s\\n\" % (name, comments))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                  \"'%s': %s\\n\" % (html.escape(name), html.escape(comments)))"
            },
            "22": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         if not bc or not b.isFinished():"
            },
            "23": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "             log.msg(\"could not rebuild: bc=%s, isFinished=%s\""
            },
            "24": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "                     % (bc, b.isFinished()))"
            }
        },
        "frontPatchFile": [
            "",
            "from twisted.web import html",
            "from twisted.web.util import Redirect, DeferredResource",
            "from twisted.internet import defer, reactor",
            "",
            "import urllib, time",
            "from twisted.python import log",
            "from buildbot.status.web.base import HtmlResource, make_row, make_stop_form, \\",
            "     css_classes, path_to_builder, path_to_slave, make_name_user_passwd_form",
            "",
            "from buildbot.status.web.tests import TestsResource",
            "from buildbot.status.web.step import StepsResource",
            "from buildbot import version, util",
            "",
            "# /builders/$builder/builds/$buildnum",
            "class StatusResourceBuild(HtmlResource):",
            "    addSlash = True",
            "",
            "    def __init__(self, build_status, build_control, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.build_status = build_status",
            "        self.build_control = build_control",
            "        self.builder_control = builder_control",
            "",
            "    def getTitle(self, request):",
            "        return (\"Buildbot: %s Build #%d\" %",
            "                (html.escape(self.build_status.getBuilder().getName()),",
            "                 self.build_status.getNumber()))",
            "",
            "    def body(self, req):",
            "        b = self.build_status",
            "        status = self.getStatus(req)",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "        data = ('<div class=\"title\"><a href=\"%s\">%s</a></div>\\n'",
            "                % (self.path_to_root(req), projectName))",
            "        builder_name = b.getBuilder().getName()",
            "        data += (\"<h1><a href=\\\"%s\\\">Builder %s</a>: Build #%d</h1>\\n\"",
            "                 % (path_to_builder(req, b.getBuilder()),",
            "                    builder_name, b.getNumber()))",
            "",
            "        if not b.isFinished():",
            "            data += \"<h2>Build In Progress</h2>\"",
            "            when = b.getETA()",
            "            if when is not None:",
            "                when_time = time.strftime(\"%H:%M:%S\",",
            "                                          time.localtime(time.time() + when))",
            "                data += \"<div>ETA %ds (%s)</div>\\n\" % (when, when_time)",
            "",
            "            if self.build_control is not None:",
            "                stopURL = urllib.quote(req.childLink(\"stop\"))",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req))",
            "",
            "        if b.isFinished():",
            "            # Results map loosely to css_classes",
            "            results = b.getResults()",
            "            data += \"<h2>Results:</h2>\\n\"",
            "            text = \" \".join(b.getText())",
            "            data += '<span class=\"%s\">%s</span>\\n' % (css_classes[results],",
            "                                                      text)",
            "            if b.getTestResults():",
            "                url = req.childLink(\"tests\")",
            "                data += \"<h3><a href=\\\"%s\\\">test results</a></h3>\\n\" % url",
            "",
            "        ss = b.getSourceStamp()",
            "        data += \"<h2>SourceStamp:</h2>\\n\"",
            "        data += \" <ul>\\n\"",
            "        if ss.branch:",
            "            data += \"  <li>Branch: %s</li>\\n\" % html.escape(ss.branch)",
            "        if ss.revision:",
            "            data += \"  <li>Revision: %s</li>\\n\" % html.escape(str(ss.revision))",
            "        if ss.patch:",
            "            data += \"  <li>Patch: YES</li>\\n\" # TODO: provide link to .diff",
            "        if ss.changes:",
            "            data += \"  <li>Changes: see below</li>\\n\"",
            "        if (ss.branch is None and ss.revision is None and ss.patch is None",
            "            and not ss.changes):",
            "            data += \"  <li>build of most recent revision</li>\\n\"",
            "        got_revision = None",
            "        try:",
            "            got_revision = b.getProperty(\"got_revision\")",
            "        except KeyError:",
            "            pass",
            "        if got_revision:",
            "            got_revision = str(got_revision)",
            "            if len(got_revision) > 40:",
            "                got_revision = \"[revision string too long]\"",
            "            data += \"  <li>Got Revision: %s</li>\\n\" % got_revision",
            "        data += \" </ul>\\n\"",
            "",
            "        # TODO: turn this into a table, or some other sort of definition-list",
            "        # that doesn't take up quite so much vertical space",
            "        try:",
            "            slaveurl = path_to_slave(req, status.getSlave(b.getSlavename()))",
            "            data += \"<h2>Buildslave:</h2>\\n <a href=\\\"%s\\\">%s</a>\\n\" % (html.escape(slaveurl), html.escape(b.getSlavename()))",
            "        except KeyError:",
            "            data += \"<h2>Buildslave:</h2>\\n %s\\n\" % html.escape(b.getSlavename())",
            "        data += \"<h2>Reason:</h2>\\n%s\\n\" % html.escape(b.getReason())",
            "",
            "        data += \"<h2>Steps and Logfiles:</h2>\\n\"",
            "        # TODO:",
            "#        urls = self.original.getURLs()",
            "#        ex_url_class = \"BuildStep external\"",
            "#        for name, target in urls.items():",
            "#            text.append('[<a href=\"%s\" class=\"%s\">%s</a>]' %",
            "#                        (target, ex_url_class, html.escape(name)))",
            "        data += \"<ol>\\n\"",
            "        for s in b.getSteps():",
            "            name = s.getName()",
            "            time_to_run = 0",
            "            (start, end) = s.getTimes()",
            "            if start and end:",
            "              time_to_run = end - start",
            "            if s.isFinished():",
            "                css_class = css_classes[s.getResults()[0]]",
            "            elif s.isStarted():",
            "                css_class = \"running\"",
            "            else:",
            "                css_class = \"\"",
            "            data += (' <li><span class=\"%s\"><a href=\\\"%s\\\">%s</a> [%s] [%d seconds]</span>\\n'",
            "                     % (css_class, ",
            "                        req.childLink(\"steps/%s\" % urllib.quote(name)),",
            "                        name,",
            "                        \" \".join(s.getText()),",
            "                        time_to_run))",
            "            if s.getLogs():",
            "                data += \"  <ol>\\n\"",
            "                for logfile in s.getLogs():",
            "                    logname = logfile.getName()",
            "                    logurl = req.childLink(\"steps/%s/logs/%s\" %",
            "                                           (urllib.quote(name),",
            "                                            urllib.quote(logname)))",
            "                    data += (\"   <li><a href=\\\"%s\\\">%s</a></li>\\n\" %",
            "                             (logurl, logfile.getName()))",
            "                data += \"  </ol>\\n\"",
            "            data += \" </li>\\n\"",
            "        data += \"</ol>\\n\"",
            "",
            "        data += \"<h2>Build Properties:</h2>\\n\"",
            "        data += \"<table><tr><th valign=\\\"left\\\">Name</th><th valign=\\\"left\\\">Value</th><th valign=\\\"left\\\">Source</th></tr>\\n\"",
            "        for name, value, source in b.getProperties().asList():",
            "            value = str(value)",
            "            if len(value) > 500:",
            "                value = value[:500] + \" .. [property value too long]\"",
            "            data += \"<tr>\"",
            "            data += \"<td>%s</td>\" % html.escape(name)",
            "            data += \"<td>%s</td>\" % html.escape(value)",
            "            data += \"<td>%s</td>\" % html.escape(source)",
            "            data += \"</tr>\\n\"",
            "        data += \"</table>\"",
            "",
            "        data += \"<h2>Blamelist:</h2>\\n\"",
            "        if list(b.getResponsibleUsers()):",
            "            data += \" <ol>\\n\"",
            "            for who in b.getResponsibleUsers():",
            "                data += \"  <li>%s</li>\\n\" % html.escape(who)",
            "            data += \" </ol>\\n\"",
            "        else:",
            "            data += \"<div>no responsible users</div>\\n\"",
            "",
            "",
            "        (start, end) = b.getTimes()",
            "        data += \"<h2>Timing</h2>\\n\"",
            "        data += \"<table>\\n\"",
            "        data += \"<tr><td>Start</td><td>%s</td></tr>\\n\" % time.ctime(start)",
            "        if end:",
            "            data += \"<tr><td>End</td><td>%s</td></tr>\\n\" % time.ctime(end)",
            "            data += \"<tr><td>Elapsed</td><td>%s</td></tr>\\n\" % util.formatInterval(end - start)",
            "        else:",
            "            now = util.now()",
            "            data += \"<tr><td>Elapsed</td><td>%s</td></tr>\\n\" % util.formatInterval(now - start)",
            "        data += \"</table>\\n\"",
            "",
            "        if ss.changes:",
            "            data += \"<h2>All Changes</h2>\\n\"",
            "            data += \"<ol>\\n\"",
            "            for c in ss.changes:",
            "                data += \"<li>\" + c.asHTML() + \"</li>\\n\"",
            "            data += \"</ol>\\n\"",
            "            #data += html.PRE(b.changesText()) # TODO",
            "",
            "        if b.isFinished() and self.builder_control is not None:",
            "            data += \"<h3>Resubmit Build:</h3>\\n\"",
            "            # can we rebuild it exactly?",
            "            exactly = (ss.revision is not None) or b.getChanges()",
            "            if exactly:",
            "                data += (\"<p>This tree was built from a specific set of \\n\"",
            "                         \"source files, and can be rebuilt exactly</p>\\n\")",
            "            else:",
            "                data += (\"<p>This tree was built from the most recent \"",
            "                         \"revision\")",
            "                if ss.branch:",
            "                    data += \" (along some branch)\"",
            "                data += (\" and thus it might not be possible to rebuild it \\n\"",
            "                         \"exactly. Any changes that have been committed \\n\"",
            "                         \"after this build was started <b>will</b> be \\n\"",
            "                         \"included in a rebuild.</p>\\n\")",
            "            rebuildURL = urllib.quote(req.childLink(\"rebuild\"))",
            "            data += ('<form method=\"post\" action=\"%s\" class=\"command rebuild\">\\n'",
            "                     % rebuildURL)",
            "            data += make_name_user_passwd_form(self.isUsingUserPasswd(req))",
            "            data += make_row(\"Reason for re-running build:\",",
            "                             \"<input type='text' name='comments' />\")",
            "            data += '<input type=\"submit\" value=\"Rebuild\" />\\n'",
            "            data += '</form>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(req) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "",
            "        return data",
            "",
            "    def stop(self, req):",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../../authfailed\")",
            "        b = self.build_status",
            "        c = self.build_control",
            "        log.msg(\"web stopBuild of build %s:%s\" % \\",
            "                (b.getBuilder().getName(), b.getNumber()))",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        reason = (\"The web-page 'stop build' button was pressed by \"",
            "                  \"'%s': %s\\n\" % (name, comments))",
            "        if c:",
            "            c.stopBuild(reason)",
            "        # we're at http://localhost:8080/svn-hello/builds/5/stop?[args] and",
            "        # we want to go to: http://localhost:8080/svn-hello",
            "        url = req.args.get('url', ['../..'])[0]",
            "        r = Redirect(url)",
            "        d = defer.Deferred()",
            "        reactor.callLater(1, d.callback, r)",
            "        return DeferredResource(d)",
            "",
            "    def rebuild(self, req):",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../../authfailed\")",
            "        b = self.build_status",
            "        bc = self.builder_control",
            "        builder_name = b.getBuilder().getName()",
            "        log.msg(\"web rebuild of build %s:%s\" % (builder_name, b.getNumber()))",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        reason = (\"The web-page 'rebuild' button was pressed by \"",
            "                  \"'%s': %s\\n\" % (name, comments))",
            "        if not bc or not b.isFinished():",
            "            log.msg(\"could not rebuild: bc=%s, isFinished=%s\"",
            "                    % (bc, b.isFinished()))",
            "            # TODO: indicate an error",
            "        else:",
            "            bc.resubmitBuild(b, reason)",
            "        # we're at",
            "        # http://localhost:8080/builders/NAME/builds/5/rebuild?[args]",
            "        # Where should we send them?",
            "        #",
            "        # Ideally it would be to the per-build page that they just started,",
            "        # but we don't know the build number for it yet (besides, it might",
            "        # have to wait for a current build to finish). The next-most",
            "        # preferred place is somewhere that the user can see tangible",
            "        # evidence of their build starting (or to see the reason that it",
            "        # didn't start). This should be the Builder page.",
            "        r = Redirect(\"../..\") # the Builder's page",
            "        d = defer.Deferred()",
            "        reactor.callLater(1, d.callback, r)",
            "        return DeferredResource(d)",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"stop\":",
            "            return self.stop(req)",
            "        if path == \"rebuild\":",
            "            return self.rebuild(req)",
            "        if path == \"steps\":",
            "            return StepsResource(self.build_status)",
            "        if path == \"tests\":",
            "            return TestsResource(self.build_status)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "# /builders/$builder/builds",
            "class BuildsResource(HtmlResource):",
            "    addSlash = True",
            "",
            "    def __init__(self, builder_status, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.builder_status = builder_status",
            "        self.builder_control = builder_control",
            "",
            "    def getChild(self, path, req):",
            "        try:",
            "            num = int(path)",
            "        except ValueError:",
            "            num = None",
            "        if num is not None:",
            "            build_status = self.builder_status.getBuild(num)",
            "            if build_status:",
            "                if self.builder_control:",
            "                    build_control = self.builder_control.getBuild(num)",
            "                else:",
            "                    build_control = None",
            "                return StatusResourceBuild(build_status, build_control,",
            "                                           self.builder_control)",
            "",
            "        return HtmlResource.getChild(self, path, req)"
        ],
        "afterPatchFile": [
            "",
            "from twisted.web import html",
            "from twisted.web.util import Redirect, DeferredResource",
            "from twisted.internet import defer, reactor",
            "",
            "import urllib, time",
            "from twisted.python import log",
            "from buildbot.status.web.base import HtmlResource, make_row, make_stop_form, \\",
            "     css_classes, path_to_builder, path_to_slave, make_name_user_passwd_form",
            "",
            "from buildbot.status.web.tests import TestsResource",
            "from buildbot.status.web.step import StepsResource",
            "from buildbot import version, util",
            "",
            "# /builders/$builder/builds/$buildnum",
            "class StatusResourceBuild(HtmlResource):",
            "    addSlash = True",
            "",
            "    def __init__(self, build_status, build_control, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.build_status = build_status",
            "        self.build_control = build_control",
            "        self.builder_control = builder_control",
            "",
            "    def getTitle(self, request):",
            "        return (\"Buildbot: %s Build #%d\" %",
            "                (html.escape(self.build_status.getBuilder().getName()),",
            "                 self.build_status.getNumber()))",
            "",
            "    def body(self, req):",
            "        b = self.build_status",
            "        status = self.getStatus(req)",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "        data = ('<div class=\"title\"><a href=\"%s\">%s</a></div>\\n'",
            "                % (self.path_to_root(req), projectName))",
            "        builder_name = b.getBuilder().getName()",
            "        data += (\"<h1><a href=\\\"%s\\\">Builder %s</a>: Build #%d</h1>\\n\"",
            "                 % (path_to_builder(req, b.getBuilder()),",
            "                    builder_name, b.getNumber()))",
            "",
            "        if not b.isFinished():",
            "            data += \"<h2>Build In Progress</h2>\"",
            "            when = b.getETA()",
            "            if when is not None:",
            "                when_time = time.strftime(\"%H:%M:%S\",",
            "                                          time.localtime(time.time() + when))",
            "                data += \"<div>ETA %ds (%s)</div>\\n\" % (when, when_time)",
            "",
            "            if self.build_control is not None:",
            "                stopURL = urllib.quote(req.childLink(\"stop\"))",
            "                data += make_stop_form(stopURL, self.isUsingUserPasswd(req))",
            "",
            "        if b.isFinished():",
            "            # Results map loosely to css_classes",
            "            results = b.getResults()",
            "            data += \"<h2>Results:</h2>\\n\"",
            "            text = \" \".join(b.getText())",
            "            data += '<span class=\"%s\">%s</span>\\n' % (css_classes[results],",
            "                                                      text)",
            "            if b.getTestResults():",
            "                url = req.childLink(\"tests\")",
            "                data += \"<h3><a href=\\\"%s\\\">test results</a></h3>\\n\" % url",
            "",
            "        ss = b.getSourceStamp()",
            "        data += \"<h2>SourceStamp:</h2>\\n\"",
            "        data += \" <ul>\\n\"",
            "        if ss.branch:",
            "            data += \"  <li>Branch: %s</li>\\n\" % html.escape(ss.branch)",
            "        if ss.revision:",
            "            data += \"  <li>Revision: %s</li>\\n\" % html.escape(str(ss.revision))",
            "        if ss.patch:",
            "            data += \"  <li>Patch: YES</li>\\n\" # TODO: provide link to .diff",
            "        if ss.changes:",
            "            data += \"  <li>Changes: see below</li>\\n\"",
            "        if (ss.branch is None and ss.revision is None and ss.patch is None",
            "            and not ss.changes):",
            "            data += \"  <li>build of most recent revision</li>\\n\"",
            "        got_revision = None",
            "        try:",
            "            got_revision = b.getProperty(\"got_revision\")",
            "        except KeyError:",
            "            pass",
            "        if got_revision:",
            "            got_revision = str(got_revision)",
            "            if len(got_revision) > 40:",
            "                got_revision = \"[revision string too long]\"",
            "            data += \"  <li>Got Revision: %s</li>\\n\" % got_revision",
            "        data += \" </ul>\\n\"",
            "",
            "        # TODO: turn this into a table, or some other sort of definition-list",
            "        # that doesn't take up quite so much vertical space",
            "        try:",
            "            slaveurl = path_to_slave(req, status.getSlave(b.getSlavename()))",
            "            data += \"<h2>Buildslave:</h2>\\n <a href=\\\"%s\\\">%s</a>\\n\" % (html.escape(slaveurl), html.escape(b.getSlavename()))",
            "        except KeyError:",
            "            data += \"<h2>Buildslave:</h2>\\n %s\\n\" % html.escape(b.getSlavename())",
            "        data += \"<h2>Reason:</h2>\\n%s\\n\" % html.escape(b.getReason())",
            "",
            "        data += \"<h2>Steps and Logfiles:</h2>\\n\"",
            "        # TODO:",
            "#        urls = self.original.getURLs()",
            "#        ex_url_class = \"BuildStep external\"",
            "#        for name, target in urls.items():",
            "#            text.append('[<a href=\"%s\" class=\"%s\">%s</a>]' %",
            "#                        (target, ex_url_class, html.escape(name)))",
            "        data += \"<ol>\\n\"",
            "        for s in b.getSteps():",
            "            name = s.getName()",
            "            time_to_run = 0",
            "            (start, end) = s.getTimes()",
            "            if start and end:",
            "              time_to_run = end - start",
            "            if s.isFinished():",
            "                css_class = css_classes[s.getResults()[0]]",
            "            elif s.isStarted():",
            "                css_class = \"running\"",
            "            else:",
            "                css_class = \"\"",
            "            data += (' <li><span class=\"%s\"><a href=\\\"%s\\\">%s</a> [%s] [%d seconds]</span>\\n'",
            "                     % (css_class, ",
            "                        req.childLink(\"steps/%s\" % urllib.quote(name)),",
            "                        name,",
            "                        \" \".join(s.getText()),",
            "                        time_to_run))",
            "            if s.getLogs():",
            "                data += \"  <ol>\\n\"",
            "                for logfile in s.getLogs():",
            "                    logname = logfile.getName()",
            "                    logurl = req.childLink(\"steps/%s/logs/%s\" %",
            "                                           (urllib.quote(name),",
            "                                            urllib.quote(logname)))",
            "                    data += (\"   <li><a href=\\\"%s\\\">%s</a></li>\\n\" %",
            "                             (logurl, logfile.getName()))",
            "                data += \"  </ol>\\n\"",
            "            data += \" </li>\\n\"",
            "        data += \"</ol>\\n\"",
            "",
            "        data += \"<h2>Build Properties:</h2>\\n\"",
            "        data += \"<table><tr><th valign=\\\"left\\\">Name</th><th valign=\\\"left\\\">Value</th><th valign=\\\"left\\\">Source</th></tr>\\n\"",
            "        for name, value, source in b.getProperties().asList():",
            "            value = str(value)",
            "            if len(value) > 500:",
            "                value = value[:500] + \" .. [property value too long]\"",
            "            data += \"<tr>\"",
            "            data += \"<td>%s</td>\" % html.escape(name)",
            "            data += \"<td>%s</td>\" % html.escape(value)",
            "            data += \"<td>%s</td>\" % html.escape(source)",
            "            data += \"</tr>\\n\"",
            "        data += \"</table>\"",
            "",
            "        data += \"<h2>Blamelist:</h2>\\n\"",
            "        if list(b.getResponsibleUsers()):",
            "            data += \" <ol>\\n\"",
            "            for who in b.getResponsibleUsers():",
            "                data += \"  <li>%s</li>\\n\" % html.escape(who)",
            "            data += \" </ol>\\n\"",
            "        else:",
            "            data += \"<div>no responsible users</div>\\n\"",
            "",
            "",
            "        (start, end) = b.getTimes()",
            "        data += \"<h2>Timing</h2>\\n\"",
            "        data += \"<table>\\n\"",
            "        data += \"<tr><td>Start</td><td>%s</td></tr>\\n\" % time.ctime(start)",
            "        if end:",
            "            data += \"<tr><td>End</td><td>%s</td></tr>\\n\" % time.ctime(end)",
            "            data += \"<tr><td>Elapsed</td><td>%s</td></tr>\\n\" % util.formatInterval(end - start)",
            "        else:",
            "            now = util.now()",
            "            data += \"<tr><td>Elapsed</td><td>%s</td></tr>\\n\" % util.formatInterval(now - start)",
            "        data += \"</table>\\n\"",
            "",
            "        if ss.changes:",
            "            data += \"<h2>All Changes</h2>\\n\"",
            "            data += \"<ol>\\n\"",
            "            for c in ss.changes:",
            "                data += \"<li>\" + c.asHTML() + \"</li>\\n\"",
            "            data += \"</ol>\\n\"",
            "            #data += html.PRE(b.changesText()) # TODO",
            "",
            "        if b.isFinished() and self.builder_control is not None:",
            "            data += \"<h3>Resubmit Build:</h3>\\n\"",
            "            # can we rebuild it exactly?",
            "            exactly = (ss.revision is not None) or b.getChanges()",
            "            if exactly:",
            "                data += (\"<p>This tree was built from a specific set of \\n\"",
            "                         \"source files, and can be rebuilt exactly</p>\\n\")",
            "            else:",
            "                data += (\"<p>This tree was built from the most recent \"",
            "                         \"revision\")",
            "                if ss.branch:",
            "                    data += \" (along some branch)\"",
            "                data += (\" and thus it might not be possible to rebuild it \\n\"",
            "                         \"exactly. Any changes that have been committed \\n\"",
            "                         \"after this build was started <b>will</b> be \\n\"",
            "                         \"included in a rebuild.</p>\\n\")",
            "            rebuildURL = urllib.quote(req.childLink(\"rebuild\"))",
            "            data += ('<form method=\"post\" action=\"%s\" class=\"command rebuild\">\\n'",
            "                     % rebuildURL)",
            "            data += make_name_user_passwd_form(self.isUsingUserPasswd(req))",
            "            data += make_row(\"Reason for re-running build:\",",
            "                             \"<input type='text' name='comments' />\")",
            "            data += '<input type=\"submit\" value=\"Rebuild\" />\\n'",
            "            data += '</form>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(req) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "",
            "        return data",
            "",
            "    def stop(self, req):",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../../authfailed\")",
            "        b = self.build_status",
            "        c = self.build_control",
            "        log.msg(\"web stopBuild of build %s:%s\" % \\",
            "                (b.getBuilder().getName(), b.getNumber()))",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        # html-quote both the username and comments, just to be safe",
            "        reason = (\"The web-page 'stop build' button was pressed by \"",
            "                  \"'%s': %s\\n\" % (html.escape(name), html.escape(comments)))",
            "        if c:",
            "            c.stopBuild(reason)",
            "        # we're at http://localhost:8080/svn-hello/builds/5/stop?[args] and",
            "        # we want to go to: http://localhost:8080/svn-hello",
            "        r = Redirect(\"../..\")",
            "        d = defer.Deferred()",
            "        reactor.callLater(1, d.callback, r)",
            "        return DeferredResource(d)",
            "",
            "    def rebuild(self, req):",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../../authfailed\")",
            "        b = self.build_status",
            "        bc = self.builder_control",
            "        builder_name = b.getBuilder().getName()",
            "        log.msg(\"web rebuild of build %s:%s\" % (builder_name, b.getNumber()))",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        comments = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        reason = (\"The web-page 'rebuild' button was pressed by \"",
            "                  \"'%s': %s\\n\" % (html.escape(name), html.escape(comments)))",
            "        if not bc or not b.isFinished():",
            "            log.msg(\"could not rebuild: bc=%s, isFinished=%s\"",
            "                    % (bc, b.isFinished()))",
            "            # TODO: indicate an error",
            "        else:",
            "            bc.resubmitBuild(b, reason)",
            "        # we're at",
            "        # http://localhost:8080/builders/NAME/builds/5/rebuild?[args]",
            "        # Where should we send them?",
            "        #",
            "        # Ideally it would be to the per-build page that they just started,",
            "        # but we don't know the build number for it yet (besides, it might",
            "        # have to wait for a current build to finish). The next-most",
            "        # preferred place is somewhere that the user can see tangible",
            "        # evidence of their build starting (or to see the reason that it",
            "        # didn't start). This should be the Builder page.",
            "        r = Redirect(\"../..\") # the Builder's page",
            "        d = defer.Deferred()",
            "        reactor.callLater(1, d.callback, r)",
            "        return DeferredResource(d)",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"stop\":",
            "            return self.stop(req)",
            "        if path == \"rebuild\":",
            "            return self.rebuild(req)",
            "        if path == \"steps\":",
            "            return StepsResource(self.build_status)",
            "        if path == \"tests\":",
            "            return TestsResource(self.build_status)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "# /builders/$builder/builds",
            "class BuildsResource(HtmlResource):",
            "    addSlash = True",
            "",
            "    def __init__(self, builder_status, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.builder_status = builder_status",
            "        self.builder_control = builder_control",
            "",
            "    def getChild(self, path, req):",
            "        try:",
            "            num = int(path)",
            "        except ValueError:",
            "            num = None",
            "        if num is not None:",
            "            build_status = self.builder_status.getBuild(num)",
            "            if build_status:",
            "                if self.builder_control:",
            "                    build_control = self.builder_control.getBuild(num)",
            "                else:",
            "                    build_control = None",
            "                return StatusResourceBuild(build_status, build_control,",
            "                                           self.builder_control)",
            "",
            "        return HtmlResource.getChild(self, path, req)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "243": [
                "StatusResourceBuild",
                "stop"
            ],
            "248": [
                "StatusResourceBuild",
                "stop"
            ],
            "249": [
                "StatusResourceBuild",
                "stop"
            ],
            "265": [
                "StatusResourceBuild",
                "rebuild"
            ]
        },
        "addLocation": [
            "nltk.downloader.Downloader.download",
            "buildbot.status.web.build.StatusResourceBuild.getChild"
        ]
    },
    "buildbot/status/web/builder.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         data += \"<h2>Recent Builds:</h2>\\n\""
            },
            "1": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         data += \"(<a href=\\\"%s\\\">view in waterfall</a>)\\n\" % (self.path_to_root(req)+\"waterfall?show=\"+html.escape(b.getName()))"
            },
            "2": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         data += \"<ul>\\n\""
            },
            "3": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        numbuilds = req.args.get('numbuilds', ['5'])[0]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        numbuilds = int(req.args.get('numbuilds', ['5'])[0])"
            },
            "5": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         for i,build in enumerate(b.generateFinishedBuilds(num_builds=int(numbuilds))):"
            },
            "6": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             data += \" <li>\" + self.make_line(req, build, False) + \"</li>\\n\""
            },
            "7": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             if i == 0:"
            },
            "8": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         revision = req.args.get(\"revision\", [\"\"])[0]"
            },
            "9": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         r = \"The web-page 'force build' button was pressed by '%s': %s\\n\" \\"
            },
            "11": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            % (name, reason)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            % (html.escape(name), html.escape(reason))"
            },
            "13": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         log.msg(\"web forcebuild of builder '%s', branch='%s', revision='%s'\""
            },
            "14": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "                 \" by user '%s'\" % (self.builder_status.getName(), branch,"
            },
            "15": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "                                    revision, name))"
            }
        },
        "frontPatchFile": [
            "",
            "from twisted.web.error import NoResource",
            "from twisted.web import html, static",
            "from twisted.web.util import Redirect",
            "",
            "import re, urllib, time",
            "from twisted.python import log",
            "from buildbot import interfaces",
            "from buildbot.status.web.base import HtmlResource, make_row, \\",
            "     make_force_build_form, OneLineMixin, path_to_build, path_to_slave, \\",
            "     path_to_builder, path_to_change",
            "from buildbot.process.base import BuildRequest",
            "from buildbot.sourcestamp import SourceStamp",
            "",
            "from buildbot.status.web.build import BuildsResource, StatusResourceBuild",
            "from buildbot import util",
            "",
            "# /builders/$builder",
            "class StatusResourceBuilder(HtmlResource, OneLineMixin):",
            "    addSlash = True",
            "",
            "    def __init__(self, builder_status, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.builder_status = builder_status",
            "        self.builder_control = builder_control",
            "",
            "    def getTitle(self, request):",
            "        return \"Buildbot: %s\" % html.escape(self.builder_status.getName())",
            "",
            "    def build_line(self, build, req):",
            "        buildnum = build.getNumber()",
            "        buildurl = path_to_build(req, build)",
            "        data = '<a href=\"%s\">#%d</a> ' % (buildurl, buildnum)",
            "",
            "        when = build.getETA()",
            "        if when is not None:",
            "            when_time = time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(time.time() + when))",
            "            data += \"ETA %ds (%s) \" % (when, when_time)",
            "        step = build.getCurrentStep()",
            "        if step:",
            "            data += \"[%s]\" % step.getName()",
            "        else:",
            "            data += \"[waiting for Lock]\"",
            "            # TODO: is this necessarily the case?",
            "",
            "        if self.builder_control is not None:",
            "            stopURL = path_to_build(req, build) + '/stop'",
            "            data += '''",
            "<form method=\"post\" action=\"%s\" class=\"command stopbuild\" style=\"display:inline\">",
            "  <input type=\"submit\" value=\"Stop Build\" />",
            "</form>''' % stopURL",
            "        return data",
            "",
            "    def request_line(self, build_request, req):",
            "        when = time.strftime(\"%b %d %H:%M:%S\", time.localtime(build_request.getSubmitTime()))",
            "        delay = util.formatInterval(util.now() - build_request.getSubmitTime())",
            "        changes = build_request.source.changes",
            "        if changes:",
            "            change_strings = []",
            "            for c in changes:",
            "                change_strings.append(\"<a href=\\\"%s\\\">%s</a>\" % (path_to_change(req, c), c.who))",
            "            if len(change_strings) == 1:",
            "                reason = \"change by %s\" % change_strings[0]",
            "            else:",
            "                reason = \"changes by %s\" % \", \".join(change_strings)",
            "        elif build_request.source.revision:",
            "            reason = build_request.source.revision",
            "        else:",
            "            reason = \"no changes specified\"",
            "",
            "        if self.builder_control is not None:",
            "            cancelURL = path_to_builder(req, self.builder_status) + '/cancelbuild'",
            "            cancelButton = '''",
            "<form action=\"%s\" class=\"command cancelbuild\" style=\"display:inline\" method=\"post\">",
            "  <input type=\"hidden\" name=\"id\" value=\"%s\" />",
            "  <input type=\"submit\" value=\"Cancel Build\" />",
            "</form>''' % (cancelURL, id(build_request))",
            "        else:",
            "            cancelButton = \"\"",
            "        return \"<font size=\\\"-1\\\">(%s, waiting %s)</font>%s%s\" % (when, delay, cancelButton, reason)",
            "",
            "    def body(self, req):",
            "        b = self.builder_status",
            "        control = self.builder_control",
            "        status = self.getStatus(req)",
            "",
            "        slaves = b.getSlaves()",
            "        connected_slaves = [s for s in slaves if s.isConnected()]",
            "",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<a href=\"%s\">%s</a>\\n' % (self.path_to_root(req), projectName)",
            "",
            "        data += \"<h1>Builder: %s</h1>\\n\" % html.escape(b.getName())",
            "",
            "        # the first section shows builds which are currently running, if any.",
            "",
            "        current = b.getCurrentBuilds()",
            "        if current:",
            "            data += \"<h2>Currently Building:</h2>\\n\"",
            "            data += \"<ul>\\n\"",
            "            for build in current:",
            "                data += \" <li>\" + self.build_line(build, req) + \"</li>\\n\"",
            "            data += \"</ul>\\n\"",
            "        else:",
            "            data += \"<h2>no current builds</h2>\\n\"",
            "",
            "        pending = b.getPendingBuilds()",
            "        if pending:",
            "            data += \"<h2>Pending Builds:</h2>\\n\"",
            "            data += \"<ul>\\n\"",
            "            for request in pending:",
            "                data += \" <li>\" + self.request_line(request, req) + \"</li>\\n\"",
            "            data += \"</ul>\\n\"",
            "",
            "            cancelURL = path_to_builder(req, self.builder_status) + '/cancelbuild'",
            "            data += '''",
            "<form action=\"%s\" class=\"command cancelbuild\" style=\"display:inline\" method=\"post\">",
            "  <input type=\"hidden\" name=\"id\" value=\"all\" />",
            "  <input type=\"submit\" value=\"Cancel All\" />",
            "</form>''' % cancelURL",
            "        else:",
            "            data += \"<h2>no pending builds</h2>\\n\"",
            "",
            "        # Then a section with the last 5 builds, with the most recent build",
            "        # distinguished from the rest.",
            "",
            "        data += \"<h2>Recent Builds:</h2>\\n\"",
            "        data += \"(<a href=\\\"%s\\\">view in waterfall</a>)\\n\" % (self.path_to_root(req)+\"waterfall?show=\"+html.escape(b.getName()))",
            "        data += \"<ul>\\n\"",
            "        numbuilds = req.args.get('numbuilds', ['5'])[0]",
            "        for i,build in enumerate(b.generateFinishedBuilds(num_builds=int(numbuilds))):",
            "            data += \" <li>\" + self.make_line(req, build, False) + \"</li>\\n\"",
            "            if i == 0:",
            "                data += \"<br />\\n\" # separator",
            "                # TODO: or empty list?",
            "        data += \"</ul>\\n\"",
            "",
            "",
            "        data += \"<h2>Buildslaves:</h2>\\n\"",
            "        data += \"<ol>\\n\"",
            "        for slave in slaves:",
            "            slaveurl = path_to_slave(req, slave)",
            "            data += \"<li><b><a href=\\\"%s\\\">%s</a></b>: \" % (html.escape(slaveurl), html.escape(slave.getName()))",
            "            if slave.isConnected():",
            "                data += \"CONNECTED\\n\"",
            "                if slave.getAdmin():",
            "                    data += make_row(\"Admin:\", html.escape(slave.getAdmin()))",
            "                if slave.getHost():",
            "                    data += \"<span class='label'>Host info:</span>\\n\"",
            "                    data += html.PRE(slave.getHost())",
            "            else:",
            "                data += (\"NOT CONNECTED\\n\")",
            "            data += \"</li>\\n\"",
            "        data += \"</ol>\\n\"",
            "",
            "        if control is not None and connected_slaves:",
            "            forceURL = path_to_builder(req, b) + '/force'",
            "            data += make_force_build_form(forceURL, self.isUsingUserPasswd(req))",
            "        elif control is not None:",
            "            data += \"\"\"",
            "            <p>All buildslaves appear to be offline, so it's not possible",
            "            to force this build to execute at this time.</p>",
            "            \"\"\"",
            "",
            "        if control is not None:",
            "            pingURL = path_to_builder(req, b) + '/ping'",
            "            data += \"\"\"",
            "            <form method=\"post\" action=\"%s\" class='command pingbuilder'>",
            "            <p>To ping the buildslave(s), push the 'Ping' button</p>",
            "",
            "            <input type=\"submit\" value=\"Ping Builder\" />",
            "            </form>",
            "            \"\"\" % pingURL",
            "",
            "        data += self.footer(status, req)",
            "",
            "        return data",
            "",
            "    def force(self, req):",
            "        \"\"\"",
            "",
            "        Custom properties can be passed from the web form.  To do",
            "        this, subclass this class, overriding the force() method.  You",
            "        can then determine the properties (usually from form values,",
            "        by inspecting req.args), then pass them to this superclass",
            "        force method.",
            "        ",
            "        \"\"\"",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        reason = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        branch = req.args.get(\"branch\", [\"\"])[0]",
            "        revision = req.args.get(\"revision\", [\"\"])[0]",
            "",
            "        r = \"The web-page 'force build' button was pressed by '%s': %s\\n\" \\",
            "            % (name, reason)",
            "        log.msg(\"web forcebuild of builder '%s', branch='%s', revision='%s'\"",
            "                \" by user '%s'\" % (self.builder_status.getName(), branch,",
            "                                   revision, name))",
            "",
            "        if not self.builder_control:",
            "            # TODO: tell the web user that their request was denied",
            "            log.msg(\"but builder control is disabled\")",
            "            return Redirect(\"..\")",
            "",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../authfail\")",
            "",
            "        # keep weird stuff out of the branch and revision strings. TODO:",
            "        # centralize this somewhere.",
            "        if not re.match(r'^[\\w\\.\\-\\/]*$', branch):",
            "            log.msg(\"bad branch '%s'\" % branch)",
            "            return Redirect(\"..\")",
            "        if not re.match(r'^[\\w\\.\\-\\/]*$', revision):",
            "            log.msg(\"bad revision '%s'\" % revision)",
            "            return Redirect(\"..\")",
            "        if not branch:",
            "            branch = None",
            "        if not revision:",
            "            revision = None",
            "",
            "        # TODO: if we can authenticate that a particular User pushed the",
            "        # button, use their name instead of None, so they'll be informed of",
            "        # the results.",
            "        # TODO2: we can authenticate that a particular User pushed the button",
            "        # now, so someone can write this support. but it requires a",
            "        # buildbot.changes.changes.Change instance which is tedious at this",
            "        # stage to compute",
            "        s = SourceStamp(branch=branch, revision=revision)",
            "        req = BuildRequest(r, s, builderName=self.builder_status.getName())",
            "        try:",
            "            self.builder_control.requestBuildSoon(req)",
            "        except interfaces.NoSlaveError:",
            "            # TODO: tell the web user that their request could not be",
            "            # honored",
            "            pass",
            "        # send the user back to the builder page",
            "        return Redirect(\".\")",
            "",
            "    def ping(self, req):",
            "        log.msg(\"web ping of builder '%s'\" % self.builder_status.getName())",
            "        self.builder_control.ping() # TODO: there ought to be an ISlaveControl",
            "        # send the user back to the builder page",
            "        return Redirect(\".\")",
            "",
            "    def cancel(self, req):",
            "        try:",
            "            request_id = req.args.get(\"id\", [None])[0]",
            "            if request_id == \"all\":",
            "                cancel_all = True",
            "            else:",
            "                cancel_all = False",
            "                request_id = int(request_id)",
            "        except:",
            "            request_id = None",
            "        if request_id:",
            "            for build_req in self.builder_control.getPendingBuilds():",
            "                if cancel_all or id(build_req.original_request.status) == request_id:",
            "                    log.msg(\"Cancelling %s\" % build_req)",
            "                    build_req.cancel()",
            "                    if not cancel_all:",
            "                        break",
            "        return Redirect(\".\")",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"force\":",
            "            return self.force(req)",
            "        if path == \"ping\":",
            "            return self.ping(req)",
            "        if path == \"events\":",
            "            num = req.postpath.pop(0)",
            "            req.prepath.append(num)",
            "            num = int(num)",
            "            # TODO: is this dead code? .statusbag doesn't exist,right?",
            "            log.msg(\"getChild['path']: %s\" % req.uri)",
            "            return NoResource(\"events are unavailable until code gets fixed\")",
            "            filename = req.postpath.pop(0)",
            "            req.prepath.append(filename)",
            "            e = self.builder_status.getEventNumbered(num)",
            "            if not e:",
            "                return NoResource(\"No such event '%d'\" % num)",
            "            file = e.files.get(filename, None)",
            "            if file == None:",
            "                return NoResource(\"No such file '%s'\" % filename)",
            "            if type(file) == type(\"\"):",
            "                if file[:6] in (\"<HTML>\", \"<html>\"):",
            "                    return static.Data(file, \"text/html\")",
            "                return static.Data(file, \"text/plain\")",
            "            return file",
            "        if path == \"cancelbuild\":",
            "            return self.cancel(req)",
            "        if path == \"builds\":",
            "            return BuildsResource(self.builder_status, self.builder_control)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "",
            "# /builders/_all",
            "class StatusResourceAllBuilders(HtmlResource, OneLineMixin):",
            "",
            "    def __init__(self, status, control):",
            "        HtmlResource.__init__(self)",
            "        self.status = status",
            "        self.control = control",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"force\":",
            "            return self.force(req)",
            "        if path == \"stop\":",
            "            return self.stop(req)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "    def force(self, req):",
            "        for bname in self.status.getBuilderNames():",
            "            builder_status = self.status.getBuilder(bname)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(bname)",
            "            build = StatusResourceBuilder(builder_status, builder_control)",
            "            build.force(req)",
            "        # back to the welcome page",
            "        return Redirect(\"../..\")",
            "",
            "    def stop(self, req):",
            "        for bname in self.status.getBuilderNames():",
            "            builder_status = self.status.getBuilder(bname)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(bname)",
            "            (state, current_builds) = builder_status.getState()",
            "            if state != \"building\":",
            "                continue",
            "            for b in current_builds:",
            "                build_status = builder_status.getBuild(b.number)",
            "                if not build_status:",
            "                    continue",
            "                if builder_control:",
            "                    build_control = builder_control.getBuild(b.number)",
            "                else:",
            "                    build_control = None",
            "                build = StatusResourceBuild(build_status, build_control,",
            "                                            builder_control)",
            "                build.stop(req)",
            "        # go back to the welcome page",
            "        return Redirect(\"../..\")",
            "",
            "",
            "# /builders",
            "class BuildersResource(HtmlResource):",
            "    title = \"Builders\"",
            "    addSlash = True",
            "",
            "    def body(self, req):",
            "        s = self.getStatus(req)",
            "        data = \"\"",
            "        data += \"<h1>Builders</h1>\\n\"",
            "",
            "        # TODO: this is really basic. It should be expanded to include a",
            "        # brief one-line summary of the builder (perhaps with whatever the",
            "        # builder is currently doing)",
            "        data += \"<ol>\\n\"",
            "        for bname in s.getBuilderNames():",
            "            data += (' <li><a href=\"%s\">%s</a></li>\\n' %",
            "                     (req.childLink(urllib.quote(bname, safe='')),",
            "                      bname))",
            "        data += \"</ol>\\n\"",
            "",
            "        data += self.footer(s, req)",
            "",
            "        return data",
            "",
            "    def getChild(self, path, req):",
            "        s = self.getStatus(req)",
            "        if path in s.getBuilderNames():",
            "            builder_status = s.getBuilder(path)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(path)",
            "            return StatusResourceBuilder(builder_status, builder_control)",
            "        if path == \"_all\":",
            "            return StatusResourceAllBuilders(self.getStatus(req),",
            "                                             self.getControl(req))",
            "",
            "        return HtmlResource.getChild(self, path, req)"
        ],
        "afterPatchFile": [
            "",
            "from twisted.web.error import NoResource",
            "from twisted.web import html, static",
            "from twisted.web.util import Redirect",
            "",
            "import re, urllib, time",
            "from twisted.python import log",
            "from buildbot import interfaces",
            "from buildbot.status.web.base import HtmlResource, make_row, \\",
            "     make_force_build_form, OneLineMixin, path_to_build, path_to_slave, \\",
            "     path_to_builder, path_to_change",
            "from buildbot.process.base import BuildRequest",
            "from buildbot.sourcestamp import SourceStamp",
            "",
            "from buildbot.status.web.build import BuildsResource, StatusResourceBuild",
            "from buildbot import util",
            "",
            "# /builders/$builder",
            "class StatusResourceBuilder(HtmlResource, OneLineMixin):",
            "    addSlash = True",
            "",
            "    def __init__(self, builder_status, builder_control):",
            "        HtmlResource.__init__(self)",
            "        self.builder_status = builder_status",
            "        self.builder_control = builder_control",
            "",
            "    def getTitle(self, request):",
            "        return \"Buildbot: %s\" % html.escape(self.builder_status.getName())",
            "",
            "    def build_line(self, build, req):",
            "        buildnum = build.getNumber()",
            "        buildurl = path_to_build(req, build)",
            "        data = '<a href=\"%s\">#%d</a> ' % (buildurl, buildnum)",
            "",
            "        when = build.getETA()",
            "        if when is not None:",
            "            when_time = time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(time.time() + when))",
            "            data += \"ETA %ds (%s) \" % (when, when_time)",
            "        step = build.getCurrentStep()",
            "        if step:",
            "            data += \"[%s]\" % step.getName()",
            "        else:",
            "            data += \"[waiting for Lock]\"",
            "            # TODO: is this necessarily the case?",
            "",
            "        if self.builder_control is not None:",
            "            stopURL = path_to_build(req, build) + '/stop'",
            "            data += '''",
            "<form method=\"post\" action=\"%s\" class=\"command stopbuild\" style=\"display:inline\">",
            "  <input type=\"submit\" value=\"Stop Build\" />",
            "</form>''' % stopURL",
            "        return data",
            "",
            "    def request_line(self, build_request, req):",
            "        when = time.strftime(\"%b %d %H:%M:%S\", time.localtime(build_request.getSubmitTime()))",
            "        delay = util.formatInterval(util.now() - build_request.getSubmitTime())",
            "        changes = build_request.source.changes",
            "        if changes:",
            "            change_strings = []",
            "            for c in changes:",
            "                change_strings.append(\"<a href=\\\"%s\\\">%s</a>\" % (path_to_change(req, c), c.who))",
            "            if len(change_strings) == 1:",
            "                reason = \"change by %s\" % change_strings[0]",
            "            else:",
            "                reason = \"changes by %s\" % \", \".join(change_strings)",
            "        elif build_request.source.revision:",
            "            reason = build_request.source.revision",
            "        else:",
            "            reason = \"no changes specified\"",
            "",
            "        if self.builder_control is not None:",
            "            cancelURL = path_to_builder(req, self.builder_status) + '/cancelbuild'",
            "            cancelButton = '''",
            "<form action=\"%s\" class=\"command cancelbuild\" style=\"display:inline\" method=\"post\">",
            "  <input type=\"hidden\" name=\"id\" value=\"%s\" />",
            "  <input type=\"submit\" value=\"Cancel Build\" />",
            "</form>''' % (cancelURL, id(build_request))",
            "        else:",
            "            cancelButton = \"\"",
            "        return \"<font size=\\\"-1\\\">(%s, waiting %s)</font>%s%s\" % (when, delay, cancelButton, reason)",
            "",
            "    def body(self, req):",
            "        b = self.builder_status",
            "        control = self.builder_control",
            "        status = self.getStatus(req)",
            "",
            "        slaves = b.getSlaves()",
            "        connected_slaves = [s for s in slaves if s.isConnected()]",
            "",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<a href=\"%s\">%s</a>\\n' % (self.path_to_root(req), projectName)",
            "",
            "        data += \"<h1>Builder: %s</h1>\\n\" % html.escape(b.getName())",
            "",
            "        # the first section shows builds which are currently running, if any.",
            "",
            "        current = b.getCurrentBuilds()",
            "        if current:",
            "            data += \"<h2>Currently Building:</h2>\\n\"",
            "            data += \"<ul>\\n\"",
            "            for build in current:",
            "                data += \" <li>\" + self.build_line(build, req) + \"</li>\\n\"",
            "            data += \"</ul>\\n\"",
            "        else:",
            "            data += \"<h2>no current builds</h2>\\n\"",
            "",
            "        pending = b.getPendingBuilds()",
            "        if pending:",
            "            data += \"<h2>Pending Builds:</h2>\\n\"",
            "            data += \"<ul>\\n\"",
            "            for request in pending:",
            "                data += \" <li>\" + self.request_line(request, req) + \"</li>\\n\"",
            "            data += \"</ul>\\n\"",
            "",
            "            cancelURL = path_to_builder(req, self.builder_status) + '/cancelbuild'",
            "            data += '''",
            "<form action=\"%s\" class=\"command cancelbuild\" style=\"display:inline\" method=\"post\">",
            "  <input type=\"hidden\" name=\"id\" value=\"all\" />",
            "  <input type=\"submit\" value=\"Cancel All\" />",
            "</form>''' % cancelURL",
            "        else:",
            "            data += \"<h2>no pending builds</h2>\\n\"",
            "",
            "        # Then a section with the last 5 builds, with the most recent build",
            "        # distinguished from the rest.",
            "",
            "        data += \"<h2>Recent Builds:</h2>\\n\"",
            "        data += \"(<a href=\\\"%s\\\">view in waterfall</a>)\\n\" % (self.path_to_root(req)+\"waterfall?show=\"+html.escape(b.getName()))",
            "        data += \"<ul>\\n\"",
            "        numbuilds = int(req.args.get('numbuilds', ['5'])[0])",
            "        for i,build in enumerate(b.generateFinishedBuilds(num_builds=int(numbuilds))):",
            "            data += \" <li>\" + self.make_line(req, build, False) + \"</li>\\n\"",
            "            if i == 0:",
            "                data += \"<br />\\n\" # separator",
            "                # TODO: or empty list?",
            "        data += \"</ul>\\n\"",
            "",
            "",
            "        data += \"<h2>Buildslaves:</h2>\\n\"",
            "        data += \"<ol>\\n\"",
            "        for slave in slaves:",
            "            slaveurl = path_to_slave(req, slave)",
            "            data += \"<li><b><a href=\\\"%s\\\">%s</a></b>: \" % (html.escape(slaveurl), html.escape(slave.getName()))",
            "            if slave.isConnected():",
            "                data += \"CONNECTED\\n\"",
            "                if slave.getAdmin():",
            "                    data += make_row(\"Admin:\", html.escape(slave.getAdmin()))",
            "                if slave.getHost():",
            "                    data += \"<span class='label'>Host info:</span>\\n\"",
            "                    data += html.PRE(slave.getHost())",
            "            else:",
            "                data += (\"NOT CONNECTED\\n\")",
            "            data += \"</li>\\n\"",
            "        data += \"</ol>\\n\"",
            "",
            "        if control is not None and connected_slaves:",
            "            forceURL = path_to_builder(req, b) + '/force'",
            "            data += make_force_build_form(forceURL, self.isUsingUserPasswd(req))",
            "        elif control is not None:",
            "            data += \"\"\"",
            "            <p>All buildslaves appear to be offline, so it's not possible",
            "            to force this build to execute at this time.</p>",
            "            \"\"\"",
            "",
            "        if control is not None:",
            "            pingURL = path_to_builder(req, b) + '/ping'",
            "            data += \"\"\"",
            "            <form method=\"post\" action=\"%s\" class='command pingbuilder'>",
            "            <p>To ping the buildslave(s), push the 'Ping' button</p>",
            "",
            "            <input type=\"submit\" value=\"Ping Builder\" />",
            "            </form>",
            "            \"\"\" % pingURL",
            "",
            "        data += self.footer(status, req)",
            "",
            "        return data",
            "",
            "    def force(self, req):",
            "        \"\"\"",
            "",
            "        Custom properties can be passed from the web form.  To do",
            "        this, subclass this class, overriding the force() method.  You",
            "        can then determine the properties (usually from form values,",
            "        by inspecting req.args), then pass them to this superclass",
            "        force method.",
            "        ",
            "        \"\"\"",
            "        name = req.args.get(\"username\", [\"<unknown>\"])[0]",
            "        reason = req.args.get(\"comments\", [\"<no reason specified>\"])[0]",
            "        branch = req.args.get(\"branch\", [\"\"])[0]",
            "        revision = req.args.get(\"revision\", [\"\"])[0]",
            "",
            "        r = \"The web-page 'force build' button was pressed by '%s': %s\\n\" \\",
            "            % (html.escape(name), html.escape(reason))",
            "        log.msg(\"web forcebuild of builder '%s', branch='%s', revision='%s'\"",
            "                \" by user '%s'\" % (self.builder_status.getName(), branch,",
            "                                   revision, name))",
            "",
            "        if not self.builder_control:",
            "            # TODO: tell the web user that their request was denied",
            "            log.msg(\"but builder control is disabled\")",
            "            return Redirect(\"..\")",
            "",
            "        if self.isUsingUserPasswd(req):",
            "            if not self.authUser(req):",
            "                return Redirect(\"../../authfail\")",
            "",
            "        # keep weird stuff out of the branch and revision strings. TODO:",
            "        # centralize this somewhere.",
            "        if not re.match(r'^[\\w\\.\\-\\/]*$', branch):",
            "            log.msg(\"bad branch '%s'\" % branch)",
            "            return Redirect(\"..\")",
            "        if not re.match(r'^[\\w\\.\\-\\/]*$', revision):",
            "            log.msg(\"bad revision '%s'\" % revision)",
            "            return Redirect(\"..\")",
            "        if not branch:",
            "            branch = None",
            "        if not revision:",
            "            revision = None",
            "",
            "        # TODO: if we can authenticate that a particular User pushed the",
            "        # button, use their name instead of None, so they'll be informed of",
            "        # the results.",
            "        # TODO2: we can authenticate that a particular User pushed the button",
            "        # now, so someone can write this support. but it requires a",
            "        # buildbot.changes.changes.Change instance which is tedious at this",
            "        # stage to compute",
            "        s = SourceStamp(branch=branch, revision=revision)",
            "        req = BuildRequest(r, s, builderName=self.builder_status.getName())",
            "        try:",
            "            self.builder_control.requestBuildSoon(req)",
            "        except interfaces.NoSlaveError:",
            "            # TODO: tell the web user that their request could not be",
            "            # honored",
            "            pass",
            "        # send the user back to the builder page",
            "        return Redirect(\".\")",
            "",
            "    def ping(self, req):",
            "        log.msg(\"web ping of builder '%s'\" % self.builder_status.getName())",
            "        self.builder_control.ping() # TODO: there ought to be an ISlaveControl",
            "        # send the user back to the builder page",
            "        return Redirect(\".\")",
            "",
            "    def cancel(self, req):",
            "        try:",
            "            request_id = req.args.get(\"id\", [None])[0]",
            "            if request_id == \"all\":",
            "                cancel_all = True",
            "            else:",
            "                cancel_all = False",
            "                request_id = int(request_id)",
            "        except:",
            "            request_id = None",
            "        if request_id:",
            "            for build_req in self.builder_control.getPendingBuilds():",
            "                if cancel_all or id(build_req.original_request.status) == request_id:",
            "                    log.msg(\"Cancelling %s\" % build_req)",
            "                    build_req.cancel()",
            "                    if not cancel_all:",
            "                        break",
            "        return Redirect(\".\")",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"force\":",
            "            return self.force(req)",
            "        if path == \"ping\":",
            "            return self.ping(req)",
            "        if path == \"events\":",
            "            num = req.postpath.pop(0)",
            "            req.prepath.append(num)",
            "            num = int(num)",
            "            # TODO: is this dead code? .statusbag doesn't exist,right?",
            "            log.msg(\"getChild['path']: %s\" % req.uri)",
            "            return NoResource(\"events are unavailable until code gets fixed\")",
            "            filename = req.postpath.pop(0)",
            "            req.prepath.append(filename)",
            "            e = self.builder_status.getEventNumbered(num)",
            "            if not e:",
            "                return NoResource(\"No such event '%d'\" % num)",
            "            file = e.files.get(filename, None)",
            "            if file == None:",
            "                return NoResource(\"No such file '%s'\" % filename)",
            "            if type(file) == type(\"\"):",
            "                if file[:6] in (\"<HTML>\", \"<html>\"):",
            "                    return static.Data(file, \"text/html\")",
            "                return static.Data(file, \"text/plain\")",
            "            return file",
            "        if path == \"cancelbuild\":",
            "            return self.cancel(req)",
            "        if path == \"builds\":",
            "            return BuildsResource(self.builder_status, self.builder_control)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "",
            "# /builders/_all",
            "class StatusResourceAllBuilders(HtmlResource, OneLineMixin):",
            "",
            "    def __init__(self, status, control):",
            "        HtmlResource.__init__(self)",
            "        self.status = status",
            "        self.control = control",
            "",
            "    def getChild(self, path, req):",
            "        if path == \"force\":",
            "            return self.force(req)",
            "        if path == \"stop\":",
            "            return self.stop(req)",
            "",
            "        return HtmlResource.getChild(self, path, req)",
            "",
            "    def force(self, req):",
            "        for bname in self.status.getBuilderNames():",
            "            builder_status = self.status.getBuilder(bname)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(bname)",
            "            build = StatusResourceBuilder(builder_status, builder_control)",
            "            build.force(req)",
            "        # back to the welcome page",
            "        return Redirect(\"../..\")",
            "",
            "    def stop(self, req):",
            "        for bname in self.status.getBuilderNames():",
            "            builder_status = self.status.getBuilder(bname)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(bname)",
            "            (state, current_builds) = builder_status.getState()",
            "            if state != \"building\":",
            "                continue",
            "            for b in current_builds:",
            "                build_status = builder_status.getBuild(b.number)",
            "                if not build_status:",
            "                    continue",
            "                if builder_control:",
            "                    build_control = builder_control.getBuild(b.number)",
            "                else:",
            "                    build_control = None",
            "                build = StatusResourceBuild(build_status, build_control,",
            "                                            builder_control)",
            "                build.stop(req)",
            "        # go back to the welcome page",
            "        return Redirect(\"../..\")",
            "",
            "",
            "# /builders",
            "class BuildersResource(HtmlResource):",
            "    title = \"Builders\"",
            "    addSlash = True",
            "",
            "    def body(self, req):",
            "        s = self.getStatus(req)",
            "        data = \"\"",
            "        data += \"<h1>Builders</h1>\\n\"",
            "",
            "        # TODO: this is really basic. It should be expanded to include a",
            "        # brief one-line summary of the builder (perhaps with whatever the",
            "        # builder is currently doing)",
            "        data += \"<ol>\\n\"",
            "        for bname in s.getBuilderNames():",
            "            data += (' <li><a href=\"%s\">%s</a></li>\\n' %",
            "                     (req.childLink(urllib.quote(bname, safe='')),",
            "                      bname))",
            "        data += \"</ol>\\n\"",
            "",
            "        data += self.footer(s, req)",
            "",
            "        return data",
            "",
            "    def getChild(self, path, req):",
            "        s = self.getStatus(req)",
            "        if path in s.getBuilderNames():",
            "            builder_status = s.getBuilder(path)",
            "            builder_control = None",
            "            c = self.getControl(req)",
            "            if c:",
            "                builder_control = c.getBuilder(path)",
            "            return StatusResourceBuilder(builder_status, builder_control)",
            "        if path == \"_all\":",
            "            return StatusResourceAllBuilders(self.getStatus(req),",
            "                                             self.getControl(req))",
            "",
            "        return HtmlResource.getChild(self, path, req)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "132": [
                "StatusResourceBuilder",
                "body"
            ],
            "197": [
                "StatusResourceBuilder",
                "force"
            ]
        },
        "addLocation": []
    },
    "buildbot/status/web/buildstatus.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from twisted.web import html, resource"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from buildbot.status.web.base import Box"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from buildbot.status.web.base import HtmlResource"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from buildbot.status.web.base import IBox"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         number = request.args.get(\"number\", [None])[0]"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         if not name or not number:"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             return \"builder and number parameter missing\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        number = int(number)"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         # Main table for the build status."
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         data += '<table>\\n'"
            }
        },
        "frontPatchFile": [
            "from buildbot.status.web.base import Box",
            "from buildbot.status.web.base import HtmlResource",
            "from buildbot.status.web.base import IBox",
            "",
            "class BuildStatusStatusResource(HtmlResource):",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "",
            "    def head(self, request):",
            "        return \"\"",
            "",
            "    def body(self, request):",
            "        \"\"\"Display a build in the same format as the waterfall page.",
            "        The HTTP GET parameters are the builder name and the build",
            "        number.\"\"\"",
            "",
            "        status = self.getStatus(request)",
            "        data = \"\"",
            "",
            "        # Get the parameters.",
            "        name = request.args.get(\"builder\", [None])[0]",
            "        number = request.args.get(\"number\", [None])[0]",
            "        if not name or not number:",
            "            return \"builder and number parameter missing\"",
            "",
            "        # Main table for the build status.",
            "        data += '<table>\\n'",
            "",
            "        # Check if the builder in parameter exists.",
            "        try:",
            "          builder = status.getBuilder(name)",
            "        except:",
            "            return \"unknown builder\"",
            "",
            "        # Check if the build in parameter exists.",
            "        build = builder.getBuild(int(number))",
            "        if not build:",
            "            return \"unknown build %s\" % number",
            "",
            "        # Display each step, starting by the last one.",
            "        for i in range(len(build.getSteps()) - 1, -1, -1):",
            "            if build.getSteps()[i].getText():",
            "                data += \" <tr>\\n\"",
            "                data += IBox(build.getSteps()[i]).getBox(request).td(align=\"center\")",
            "                data += \" </tr>\\n\"",
            "",
            "        # Display the bottom box with the build number in it.",
            "        data += \"<tr>\"",
            "        data += IBox(build).getBox(request).td(align=\"center\")",
            "        data += \"</tr></table>\\n\"",
            "",
            "        # We want all links to display in a new tab/window instead of in the",
            "        # current one.",
            "        data = data.replace('<a ', '<a target=\"_blank\"')",
            "        return data"
        ],
        "afterPatchFile": [
            "from twisted.web import html, resource",
            "from buildbot.status.web.base import Box",
            "from buildbot.status.web.base import HtmlResource",
            "from buildbot.status.web.base import IBox",
            "",
            "class BuildStatusStatusResource(HtmlResource):",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "",
            "    def head(self, request):",
            "        return \"\"",
            "",
            "    def body(self, request):",
            "        \"\"\"Display a build in the same format as the waterfall page.",
            "        The HTTP GET parameters are the builder name and the build",
            "        number.\"\"\"",
            "",
            "        status = self.getStatus(request)",
            "        data = \"\"",
            "",
            "        # Get the parameters.",
            "        name = request.args.get(\"builder\", [None])[0]",
            "        number = request.args.get(\"number\", [None])[0]",
            "        if not name or not number:",
            "            return \"builder and number parameter missing\"",
            "        number = int(number)",
            "",
            "        # Main table for the build status.",
            "        data += '<table>\\n'",
            "",
            "        # Check if the builder in parameter exists.",
            "        try:",
            "          builder = status.getBuilder(name)",
            "        except:",
            "            return \"unknown builder\"",
            "",
            "        # Check if the build in parameter exists.",
            "        build = builder.getBuild(int(number))",
            "        if not build:",
            "            return \"unknown build %s\" % number",
            "",
            "        # Display each step, starting by the last one.",
            "        for i in range(len(build.getSteps()) - 1, -1, -1):",
            "            if build.getSteps()[i].getText():",
            "                data += \" <tr>\\n\"",
            "                data += IBox(build.getSteps()[i]).getBox(request).td(align=\"center\")",
            "                data += \" </tr>\\n\"",
            "",
            "        # Display the bottom box with the build number in it.",
            "        data += \"<tr>\"",
            "        data += IBox(build).getBox(request).td(align=\"center\")",
            "        data += \"</tr></table>\\n\"",
            "",
            "        # We want all links to display in a new tab/window instead of in the",
            "        # current one.",
            "        data = data.replace('<a ', '<a target=\"_blank\"')",
            "        return data"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nltk.downloader.Downloader.download"
        ]
    },
    "buildbot/status/web/grid.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import sys, time, os.path"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import urllib"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from twisted.web import html, resource"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from buildbot import util"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from buildbot import version"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from buildbot.status.web.base import HtmlResource"
            },
            "8": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         data += '<tr>\\n'"
            },
            "9": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)"
            },
            "10": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         if categories:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+            html_categories = map(html.escape(categories))"
            },
            "12": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "             if len(categories) > 1:"
            },
            "13": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(categories))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(html_categories))"
            },
            "15": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "             else:"
            },
            "16": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data += '\\n<br /><b>Category:</b> %s' % categories[0]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                data += '\\n<br /><b>Category:</b> %s' % html_categories[0]"
            },
            "18": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         if branch != ANYBRANCH:"
            },
            "19": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data += '\\n<br /><b>Branch:</b> %s' % (branch or 'trunk')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            data += '\\n<br /><b>Branch:</b> %s' % (html.escape(branch) or 'trunk')"
            },
            "21": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         data += '</td>\\n'"
            },
            "22": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         for stamp in stamps:"
            },
            "23": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "             data += self.stamp_td(stamp)"
            },
            "24": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         data += '<tr>\\n'"
            },
            "25": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)"
            },
            "26": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         if categories:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+            html_categories = map(html.escape(categories))"
            },
            "28": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "             if len(categories) > 1:"
            },
            "29": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(categories))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(html_categories))"
            },
            "31": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "             else:"
            },
            "32": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data += '\\n<br /><b>Category:</b> %s' % categories[0]"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+                data += '\\n<br /><b>Category:</b> %s' % html_categories[0]"
            },
            "34": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         if branch != ANYBRANCH:"
            },
            "35": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data += '\\n<br /><b>Branch:</b> %s' % (branch or 'trunk')"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+            data += '\\n<br /><b>Branch:</b> %s' % (html.escape(branch) or 'trunk')"
            },
            "37": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         data += '</td>\\n'"
            },
            "38": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 303,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         sortedBuilderNames = status.getBuilderNames()[:]"
            }
        },
        "frontPatchFile": [
            "from __future__ import generators",
            "",
            "import sys, time, os.path",
            "import urllib",
            "",
            "from buildbot import util",
            "from buildbot import version",
            "from buildbot.status.web.base import HtmlResource",
            "#from buildbot.status.web.base import Box, HtmlResource, IBox, ICurrentBox, \\",
            "#     ITopBox, td, build_get_class, path_to_build, path_to_step, map_branches",
            "from buildbot.status.web.base import build_get_class",
            "",
            "# set grid_css to the full pathname of the css file",
            "if hasattr(sys, \"frozen\"):",
            "    # all 'data' files are in the directory of our executable",
            "    here = os.path.dirname(sys.executable)",
            "    grid_css = os.path.abspath(os.path.join(here, \"grid.css\"))",
            "else:",
            "    # running from source; look for a sibling to __file__",
            "    up = os.path.dirname",
            "    grid_css = os.path.abspath(os.path.join(up(__file__), \"grid.css\"))",
            "",
            "class ANYBRANCH: pass # a flag value, used below",
            "",
            "class GridStatusMixin(object):",
            "    def getTitle(self, request):",
            "        status = self.getStatus(request)",
            "        p = status.getProjectName()",
            "        if p:",
            "            return \"BuildBot: %s\" % p",
            "        else:",
            "            return \"BuildBot\"",
            "",
            "    def getChangemaster(self, request):",
            "        # TODO: this wants to go away, access it through IStatus",
            "        return request.site.buildbot_service.getChangeSvc()",
            "",
            "    # handle reloads through an http header",
            "    # TODO: send this as a real header, rather than a tag",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "#    def setBuildmaster(self, buildmaster):",
            "#        self.status = buildmaster.getStatus()",
            "#        if self.allowForce:",
            "#            self.control = interfaces.IControl(buildmaster)",
            "#        else:",
            "#            self.control = None",
            "#        self.changemaster = buildmaster.change_svc",
            "#",
            "#        # try to set the page title",
            "#        p = self.status.getProjectName()",
            "#        if p:",
            "#            self.title = \"BuildBot: %s\" % p",
            "#",
            "    def build_td(self, request, build):",
            "        if not build:",
            "            return '<td class=\"build\">&nbsp;</td>\\n'",
            "",
            "        if build.isFinished():",
            "            # get the text and annotate the first line with a link",
            "            text = build.getText()",
            "            if not text: text = [ \"(no information)\" ]",
            "            if text == [ \"build\", \"successful\" ]: text = [ \"OK\" ]",
            "        else:",
            "            text = [ 'building' ]",
            "",
            "        name = build.getBuilder().getName()",
            "        number = build.getNumber()",
            "        url = \"builders/%s/builds/%d\" % (name, number)",
            "        text[0] = '<a href=\"%s\">%s</a>' % (url, text[0])",
            "        text = '<br />\\n'.join(text)",
            "        class_ = build_get_class(build)",
            "",
            "        return '<td class=\"build %s\">%s</td>\\n' % (class_, text)",
            "",
            "    def builder_td(self, request, builder):",
            "        state, builds = builder.getState()",
            "",
            "        # look for upcoming builds. We say the state is \"waiting\" if the",
            "        # builder is otherwise idle and there is a scheduler which tells us a",
            "        # build will be performed some time in the near future. TODO: this",
            "        # functionality used to be in BuilderStatus.. maybe this code should",
            "        # be merged back into it.",
            "        upcoming = []",
            "        builderName = builder.getName()",
            "        for s in self.getStatus(request).getSchedulers():",
            "            if builderName in s.listBuilderNames():",
            "                upcoming.extend(s.getPendingBuildTimes())",
            "        if state == \"idle\" and upcoming:",
            "            state = \"waiting\"",
            "",
            "        # TODO: for now, this pending/upcoming stuff is in the \"current",
            "        # activity\" box, but really it should go into a \"next activity\" row",
            "        # instead. The only times it should show up in \"current activity\" is",
            "        # when the builder is otherwise idle.",
            "",
            "        # are any builds pending? (waiting for a slave to be free)",
            "        url = 'builders/%s/' % urllib.quote(builder.getName(), safe='')",
            "        text = '<a href=\"%s\">%s</a>' % (url, builder.getName())",
            "        pbs = builder.getPendingBuilds()",
            "        if state != 'idle' or pbs:",
            "            if pbs:",
            "                text += \"<br />(%s with %d pending)\" % (state, len(pbs))",
            "            else:",
            "                text += \"<br />(%s)\" % state",
            "",
            "        return  '<td valign=\"center\" class=\"builder %s\">%s</td>\\n' % \\",
            "            (state, text)",
            "",
            "    def stamp_td(self, stamp):",
            "        text = stamp.getText()",
            "        return '<td valign=\"bottom\" class=\"sourcestamp\">%s</td>\\n' % \\",
            "            \"<br />\".join(text)",
            "",
            "    def getRecentSourcestamps(self, status, numBuilds, categories, branch):",
            "        \"\"\"",
            "        get a list of the most recent NUMBUILDS SourceStamp tuples, sorted",
            "        by the earliest start we've seen for them",
            "        \"\"\"",
            "        # TODO: use baseweb's getLastNBuilds?",
            "        sourcestamps = { } # { ss-tuple : earliest time }",
            "        for bn in status.getBuilderNames():",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "            build = builder.getBuild(-1)",
            "            while build:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                start = build.getTimes()[0]",
            "                build = build.getPreviousBuild()",
            "",
            "                # skip un-started builds",
            "                if not start: continue",
            "",
            "                # skip non-matching branches",
            "                if branch != ANYBRANCH and ss.branch != branch: continue",
            "",
            "                sourcestamps[ss] = min(sourcestamps.get(ss, sys.maxint), start)",
            "",
            "        # now sort those and take the NUMBUILDS most recent",
            "        sourcestamps = sourcestamps.items()",
            "        sourcestamps.sort(lambda x, y: cmp(x[1], y[1]))",
            "        sourcestamps = map(lambda tup : tup[0], sourcestamps)",
            "        sourcestamps = sourcestamps[-numBuilds:]",
            "",
            "        return sourcestamps",
            "",
            "class GridStatusResource(HtmlResource, GridStatusMixin):",
            "    # TODO: docs",
            "    status = None",
            "    control = None",
            "    changemaster = None",
            "",
            "    def __init__(self, allowForce=True, css=None):",
            "        HtmlResource.__init__(self)",
            "",
            "        self.allowForce = allowForce",
            "        self.css = css or grid_css",
            "",
            "",
            "    def body(self, request):",
            "        \"\"\"This method builds the regular grid display.",
            "        That is, build stamps across the top, build hosts down the left side",
            "        \"\"\"",
            "",
            "        # get url parameters",
            "        numBuilds = int(request.args.get(\"width\", [5])[0])",
            "        categories = request.args.get(\"category\", [])",
            "        branch = request.args.get(\"branch\", [ANYBRANCH])[0]",
            "        if branch == 'trunk': branch = None",
            "",
            "        # and the data we want to render",
            "        status = self.getStatus(request)",
            "        stamps = self.getRecentSourcestamps(status, numBuilds, categories, branch)",
            "",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<table class=\"Grid\" border=\"0\" cellspacing=\"0\">\\n'",
            "        data += '<tr>\\n'",
            "        data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)",
            "        if categories:",
            "            if len(categories) > 1:",
            "                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(categories))",
            "            else:",
            "                data += '\\n<br /><b>Category:</b> %s' % categories[0]",
            "        if branch != ANYBRANCH:",
            "            data += '\\n<br /><b>Branch:</b> %s' % (branch or 'trunk')",
            "        data += '</td>\\n'",
            "        for stamp in stamps:",
            "            data += self.stamp_td(stamp)",
            "        data += '</tr>\\n'",
            "",
            "        sortedBuilderNames = status.getBuilderNames()[:]",
            "        sortedBuilderNames.sort()",
            "        for bn in sortedBuilderNames:",
            "            builds = [None] * len(stamps)",
            "",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "",
            "            build = builder.getBuild(-1)",
            "            while build and None in builds:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                for i in range(len(stamps)):",
            "                    if ss == stamps[i] and builds[i] is None:",
            "                        builds[i] = build",
            "                build = build.getPreviousBuild()",
            "",
            "            data += '<tr>\\n'",
            "            data += self.builder_td(request, builder)",
            "            for build in builds:",
            "                data += self.build_td(request, build)",
            "            data += '</tr>\\n'",
            "",
            "        data += '</table>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data",
            "",
            "class TransposedGridStatusResource(HtmlResource, GridStatusMixin):",
            "    # TODO: docs",
            "    status = None",
            "    control = None",
            "    changemaster = None",
            "",
            "    def __init__(self, allowForce=True, css=None):",
            "        HtmlResource.__init__(self)",
            "",
            "        self.allowForce = allowForce",
            "        self.css = css or grid_css",
            "",
            "",
            "    def body(self, request):",
            "        \"\"\"This method builds the transposed grid display.",
            "        That is, build hosts across the top, ebuild stamps down the left side",
            "        \"\"\"",
            "",
            "        # get url parameters",
            "        numBuilds = int(request.args.get(\"length\", [5])[0])",
            "        categories = request.args.get(\"category\", [])",
            "        branch = request.args.get(\"branch\", [ANYBRANCH])[0]",
            "        if branch == 'trunk': branch = None",
            "",
            "        # and the data we want to render",
            "        status = self.getStatus(request)",
            "        stamps = self.getRecentSourcestamps(status, numBuilds, categories, branch)",
            "",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<table class=\"Grid\" border=\"0\" cellspacing=\"0\">\\n'",
            "        data += '<tr>\\n'",
            "        data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)",
            "        if categories:",
            "            if len(categories) > 1:",
            "                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(categories))",
            "            else:",
            "                data += '\\n<br /><b>Category:</b> %s' % categories[0]",
            "        if branch != ANYBRANCH:",
            "            data += '\\n<br /><b>Branch:</b> %s' % (branch or 'trunk')",
            "        data += '</td>\\n'",
            "",
            "        sortedBuilderNames = status.getBuilderNames()[:]",
            "        sortedBuilderNames.sort()",
            "",
            "        builder_builds = {}",
            "",
            "        for bn in sortedBuilderNames:",
            "            builds = [None] * len(stamps)",
            "",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "",
            "            build = builder.getBuild(-1)",
            "            while build and None in builds:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                for i in range(len(stamps)):",
            "                    if ss == stamps[i] and builds[i] is None:",
            "                        builds[i] = build",
            "                build = build.getPreviousBuild()",
            "",
            "            data += self.builder_td(request, builder)",
            "            builder_builds[bn] = builds",
            "",
            "        data += '</tr>\\n'",
            "",
            "        for i in range(len(stamps)):",
            "            data += '<tr>\\n'",
            "            data += self.stamp_td(stamps[i])",
            "            for bn in sortedBuilderNames:",
            "                data += self.build_td(request, builder_builds[bn][i])",
            "            data += '</tr>\\n'",
            "",
            "        data += '</table>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data"
        ],
        "afterPatchFile": [
            "from __future__ import generators",
            "",
            "import sys, time, os.path",
            "import urllib",
            "",
            "from twisted.web import html, resource",
            "",
            "from buildbot import util",
            "from buildbot import version",
            "from buildbot.status.web.base import HtmlResource",
            "#from buildbot.status.web.base import Box, HtmlResource, IBox, ICurrentBox, \\",
            "#     ITopBox, td, build_get_class, path_to_build, path_to_step, map_branches",
            "from buildbot.status.web.base import build_get_class",
            "",
            "# set grid_css to the full pathname of the css file",
            "if hasattr(sys, \"frozen\"):",
            "    # all 'data' files are in the directory of our executable",
            "    here = os.path.dirname(sys.executable)",
            "    grid_css = os.path.abspath(os.path.join(here, \"grid.css\"))",
            "else:",
            "    # running from source; look for a sibling to __file__",
            "    up = os.path.dirname",
            "    grid_css = os.path.abspath(os.path.join(up(__file__), \"grid.css\"))",
            "",
            "class ANYBRANCH: pass # a flag value, used below",
            "",
            "class GridStatusMixin(object):",
            "    def getTitle(self, request):",
            "        status = self.getStatus(request)",
            "        p = status.getProjectName()",
            "        if p:",
            "            return \"BuildBot: %s\" % p",
            "        else:",
            "            return \"BuildBot\"",
            "",
            "    def getChangemaster(self, request):",
            "        # TODO: this wants to go away, access it through IStatus",
            "        return request.site.buildbot_service.getChangeSvc()",
            "",
            "    # handle reloads through an http header",
            "    # TODO: send this as a real header, rather than a tag",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "#    def setBuildmaster(self, buildmaster):",
            "#        self.status = buildmaster.getStatus()",
            "#        if self.allowForce:",
            "#            self.control = interfaces.IControl(buildmaster)",
            "#        else:",
            "#            self.control = None",
            "#        self.changemaster = buildmaster.change_svc",
            "#",
            "#        # try to set the page title",
            "#        p = self.status.getProjectName()",
            "#        if p:",
            "#            self.title = \"BuildBot: %s\" % p",
            "#",
            "    def build_td(self, request, build):",
            "        if not build:",
            "            return '<td class=\"build\">&nbsp;</td>\\n'",
            "",
            "        if build.isFinished():",
            "            # get the text and annotate the first line with a link",
            "            text = build.getText()",
            "            if not text: text = [ \"(no information)\" ]",
            "            if text == [ \"build\", \"successful\" ]: text = [ \"OK\" ]",
            "        else:",
            "            text = [ 'building' ]",
            "",
            "        name = build.getBuilder().getName()",
            "        number = build.getNumber()",
            "        url = \"builders/%s/builds/%d\" % (name, number)",
            "        text[0] = '<a href=\"%s\">%s</a>' % (url, text[0])",
            "        text = '<br />\\n'.join(text)",
            "        class_ = build_get_class(build)",
            "",
            "        return '<td class=\"build %s\">%s</td>\\n' % (class_, text)",
            "",
            "    def builder_td(self, request, builder):",
            "        state, builds = builder.getState()",
            "",
            "        # look for upcoming builds. We say the state is \"waiting\" if the",
            "        # builder is otherwise idle and there is a scheduler which tells us a",
            "        # build will be performed some time in the near future. TODO: this",
            "        # functionality used to be in BuilderStatus.. maybe this code should",
            "        # be merged back into it.",
            "        upcoming = []",
            "        builderName = builder.getName()",
            "        for s in self.getStatus(request).getSchedulers():",
            "            if builderName in s.listBuilderNames():",
            "                upcoming.extend(s.getPendingBuildTimes())",
            "        if state == \"idle\" and upcoming:",
            "            state = \"waiting\"",
            "",
            "        # TODO: for now, this pending/upcoming stuff is in the \"current",
            "        # activity\" box, but really it should go into a \"next activity\" row",
            "        # instead. The only times it should show up in \"current activity\" is",
            "        # when the builder is otherwise idle.",
            "",
            "        # are any builds pending? (waiting for a slave to be free)",
            "        url = 'builders/%s/' % urllib.quote(builder.getName(), safe='')",
            "        text = '<a href=\"%s\">%s</a>' % (url, builder.getName())",
            "        pbs = builder.getPendingBuilds()",
            "        if state != 'idle' or pbs:",
            "            if pbs:",
            "                text += \"<br />(%s with %d pending)\" % (state, len(pbs))",
            "            else:",
            "                text += \"<br />(%s)\" % state",
            "",
            "        return  '<td valign=\"center\" class=\"builder %s\">%s</td>\\n' % \\",
            "            (state, text)",
            "",
            "    def stamp_td(self, stamp):",
            "        text = stamp.getText()",
            "        return '<td valign=\"bottom\" class=\"sourcestamp\">%s</td>\\n' % \\",
            "            \"<br />\".join(text)",
            "",
            "    def getRecentSourcestamps(self, status, numBuilds, categories, branch):",
            "        \"\"\"",
            "        get a list of the most recent NUMBUILDS SourceStamp tuples, sorted",
            "        by the earliest start we've seen for them",
            "        \"\"\"",
            "        # TODO: use baseweb's getLastNBuilds?",
            "        sourcestamps = { } # { ss-tuple : earliest time }",
            "        for bn in status.getBuilderNames():",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "            build = builder.getBuild(-1)",
            "            while build:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                start = build.getTimes()[0]",
            "                build = build.getPreviousBuild()",
            "",
            "                # skip un-started builds",
            "                if not start: continue",
            "",
            "                # skip non-matching branches",
            "                if branch != ANYBRANCH and ss.branch != branch: continue",
            "",
            "                sourcestamps[ss] = min(sourcestamps.get(ss, sys.maxint), start)",
            "",
            "        # now sort those and take the NUMBUILDS most recent",
            "        sourcestamps = sourcestamps.items()",
            "        sourcestamps.sort(lambda x, y: cmp(x[1], y[1]))",
            "        sourcestamps = map(lambda tup : tup[0], sourcestamps)",
            "        sourcestamps = sourcestamps[-numBuilds:]",
            "",
            "        return sourcestamps",
            "",
            "class GridStatusResource(HtmlResource, GridStatusMixin):",
            "    # TODO: docs",
            "    status = None",
            "    control = None",
            "    changemaster = None",
            "",
            "    def __init__(self, allowForce=True, css=None):",
            "        HtmlResource.__init__(self)",
            "",
            "        self.allowForce = allowForce",
            "        self.css = css or grid_css",
            "",
            "",
            "    def body(self, request):",
            "        \"\"\"This method builds the regular grid display.",
            "        That is, build stamps across the top, build hosts down the left side",
            "        \"\"\"",
            "",
            "        # get url parameters",
            "        numBuilds = int(request.args.get(\"width\", [5])[0])",
            "        categories = request.args.get(\"category\", [])",
            "        branch = request.args.get(\"branch\", [ANYBRANCH])[0]",
            "        if branch == 'trunk': branch = None",
            "",
            "        # and the data we want to render",
            "        status = self.getStatus(request)",
            "        stamps = self.getRecentSourcestamps(status, numBuilds, categories, branch)",
            "",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<table class=\"Grid\" border=\"0\" cellspacing=\"0\">\\n'",
            "        data += '<tr>\\n'",
            "        data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)",
            "        if categories:",
            "            html_categories = map(html.escape(categories))",
            "            if len(categories) > 1:",
            "                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(html_categories))",
            "            else:",
            "                data += '\\n<br /><b>Category:</b> %s' % html_categories[0]",
            "        if branch != ANYBRANCH:",
            "            data += '\\n<br /><b>Branch:</b> %s' % (html.escape(branch) or 'trunk')",
            "        data += '</td>\\n'",
            "        for stamp in stamps:",
            "            data += self.stamp_td(stamp)",
            "        data += '</tr>\\n'",
            "",
            "        sortedBuilderNames = status.getBuilderNames()[:]",
            "        sortedBuilderNames.sort()",
            "        for bn in sortedBuilderNames:",
            "            builds = [None] * len(stamps)",
            "",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "",
            "            build = builder.getBuild(-1)",
            "            while build and None in builds:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                for i in range(len(stamps)):",
            "                    if ss == stamps[i] and builds[i] is None:",
            "                        builds[i] = build",
            "                build = build.getPreviousBuild()",
            "",
            "            data += '<tr>\\n'",
            "            data += self.builder_td(request, builder)",
            "            for build in builds:",
            "                data += self.build_td(request, build)",
            "            data += '</tr>\\n'",
            "",
            "        data += '</table>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data",
            "",
            "class TransposedGridStatusResource(HtmlResource, GridStatusMixin):",
            "    # TODO: docs",
            "    status = None",
            "    control = None",
            "    changemaster = None",
            "",
            "    def __init__(self, allowForce=True, css=None):",
            "        HtmlResource.__init__(self)",
            "",
            "        self.allowForce = allowForce",
            "        self.css = css or grid_css",
            "",
            "",
            "    def body(self, request):",
            "        \"\"\"This method builds the transposed grid display.",
            "        That is, build hosts across the top, ebuild stamps down the left side",
            "        \"\"\"",
            "",
            "        # get url parameters",
            "        numBuilds = int(request.args.get(\"length\", [5])[0])",
            "        categories = request.args.get(\"category\", [])",
            "        branch = request.args.get(\"branch\", [ANYBRANCH])[0]",
            "        if branch == 'trunk': branch = None",
            "",
            "        # and the data we want to render",
            "        status = self.getStatus(request)",
            "        stamps = self.getRecentSourcestamps(status, numBuilds, categories, branch)",
            "",
            "        projectURL = status.getProjectURL()",
            "        projectName = status.getProjectName()",
            "",
            "        data = '<table class=\"Grid\" border=\"0\" cellspacing=\"0\">\\n'",
            "        data += '<tr>\\n'",
            "        data += '<td class=\"title\"><a href=\"%s\">%s</a>' % (projectURL, projectName)",
            "        if categories:",
            "            html_categories = map(html.escape(categories))",
            "            if len(categories) > 1:",
            "                data += '\\n<br /><b>Categories:</b><br/>%s' % ('<br/>'.join(html_categories))",
            "            else:",
            "                data += '\\n<br /><b>Category:</b> %s' % html_categories[0]",
            "        if branch != ANYBRANCH:",
            "            data += '\\n<br /><b>Branch:</b> %s' % (html.escape(branch) or 'trunk')",
            "        data += '</td>\\n'",
            "",
            "        sortedBuilderNames = status.getBuilderNames()[:]",
            "        sortedBuilderNames.sort()",
            "",
            "        builder_builds = {}",
            "",
            "        for bn in sortedBuilderNames:",
            "            builds = [None] * len(stamps)",
            "",
            "            builder = status.getBuilder(bn)",
            "            if categories and builder.category not in categories:",
            "                continue",
            "",
            "            build = builder.getBuild(-1)",
            "            while build and None in builds:",
            "                ss = build.getSourceStamp(absolute=True)",
            "                for i in range(len(stamps)):",
            "                    if ss == stamps[i] and builds[i] is None:",
            "                        builds[i] = build",
            "                build = build.getPreviousBuild()",
            "",
            "            data += self.builder_td(request, builder)",
            "            builder_builds[bn] = builds",
            "",
            "        data += '</tr>\\n'",
            "",
            "        for i in range(len(stamps)):",
            "            data += '<tr>\\n'",
            "            data += self.stamp_td(stamps[i])",
            "            for bn in sortedBuilderNames:",
            "                data += self.build_td(request, builder_builds[bn][i])",
            "            data += '</tr>\\n'",
            "",
            "        data += '</table>\\n'",
            "",
            "        # TODO: this stuff should be generated by a template of some sort",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "        data += \"<br />\\n\"",
            "",
            "        data += '<a href=\"http://buildbot.sourceforge.net/\">Buildbot</a>'",
            "        data += \"-%s \" % version",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += \"<a href=\\\"%s\\\">%s</a> project.\" % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "198": [
                "GridStatusResource",
                "body"
            ],
            "200": [
                "GridStatusResource",
                "body"
            ],
            "202": [
                "GridStatusResource",
                "body"
            ],
            "293": [
                "TransposedGridStatusResource",
                "body"
            ],
            "295": [
                "TransposedGridStatusResource",
                "body"
            ],
            "297": [
                "TransposedGridStatusResource",
                "body"
            ]
        },
        "addLocation": [
            "buildbot.status.web.grid.GridStatusResource.body.builds",
            "nltk.downloader.Downloader.download"
        ]
    },
    "buildbot/status/web/waterfall.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "                                     '<input type=\"text\" name=\"branch\" '"
            },
            "1": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "                                     'value=\"%s\">'"
            },
            "2": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "                                     '</td></tr>\\n'"
            },
            "3": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    ) % (b,)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+                                    ) % (html.escape(b),)"
            },
            "5": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         show_branches_input += '</table>\\n'"
            },
            "6": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 361,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "         # this has a set of toggle-buttons to let the user choose the"
            },
            "8": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "                     newargs[k].append(v)"
            },
            "9": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "                 else:"
            },
            "10": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "                     newargs[k] = [v]"
            },
            "11": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            newquery = \"&\".join([\"%s=%s\" % (k, urllib.quote(v))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 587,
                "PatchRowcode": "+            newquery = \"&\".join([\"%s=%s\" % (urllib.quote(k), urllib.quote(v))"
            },
            "13": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 588,
                "PatchRowcode": "                                  for k in newargs"
            },
            "14": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 589,
                "PatchRowcode": "                                  for v in newargs[k]"
            },
            "15": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": 590,
                "PatchRowcode": "                                  ])"
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: buildbot.test.test_web -*-",
            "",
            "from zope.interface import implements",
            "from twisted.python import log, components",
            "from twisted.web import html",
            "import urllib",
            "",
            "import time",
            "import operator",
            "",
            "from buildbot import interfaces, util",
            "from buildbot import version",
            "from buildbot.status import builder",
            "",
            "from buildbot.status.web.base import Box, HtmlResource, IBox, ICurrentBox, \\",
            "     ITopBox, td, build_get_class, path_to_build, path_to_step, map_branches",
            "",
            "",
            "",
            "class CurrentBox(components.Adapter):",
            "    # this provides the \"current activity\" box, just above the builder name",
            "    implements(ICurrentBox)",
            "",
            "    def formatETA(self, prefix, eta):",
            "        if eta is None:",
            "            return []",
            "        if eta < 60:",
            "            return [\"< 1 min\"]",
            "        eta_parts = [\"~\"]",
            "        eta_secs = eta",
            "        if eta_secs > 3600:",
            "            eta_parts.append(\"%d hrs\" % (eta_secs / 3600))",
            "            eta_secs %= 3600",
            "        if eta_secs > 60:",
            "            eta_parts.append(\"%d mins\" % (eta_secs / 60))",
            "            eta_secs %= 60",
            "        abstime = time.strftime(\"%H:%M\", time.localtime(util.now()+eta))",
            "        return [prefix, \" \".join(eta_parts), \"at %s\" % abstime]",
            "",
            "    def getBox(self, status):",
            "        # getState() returns offline, idle, or building",
            "        state, builds = self.original.getState()",
            "",
            "        # look for upcoming builds. We say the state is \"waiting\" if the",
            "        # builder is otherwise idle and there is a scheduler which tells us a",
            "        # build will be performed some time in the near future. TODO: this",
            "        # functionality used to be in BuilderStatus.. maybe this code should",
            "        # be merged back into it.",
            "        upcoming = []",
            "        builderName = self.original.getName()",
            "        for s in status.getSchedulers():",
            "            if builderName in s.listBuilderNames():",
            "                upcoming.extend(s.getPendingBuildTimes())",
            "        if state == \"idle\" and upcoming:",
            "            state = \"waiting\"",
            "",
            "        if state == \"building\":",
            "            text = [\"building\"]",
            "            if builds:",
            "                for b in builds:",
            "                    eta = b.getETA()",
            "                    text.extend(self.formatETA(\"ETA in\", eta))",
            "        elif state == \"offline\":",
            "            text = [\"offline\"]",
            "        elif state == \"idle\":",
            "            text = [\"idle\"]",
            "        elif state == \"waiting\":",
            "            text = [\"waiting\"]",
            "        else:",
            "            # just in case I add a state and forget to update this",
            "            text = [state]",
            "",
            "        # TODO: for now, this pending/upcoming stuff is in the \"current",
            "        # activity\" box, but really it should go into a \"next activity\" row",
            "        # instead. The only times it should show up in \"current activity\" is",
            "        # when the builder is otherwise idle.",
            "",
            "        # are any builds pending? (waiting for a slave to be free)",
            "        pbs = self.original.getPendingBuilds()",
            "        if pbs:",
            "            text.append(\"%d pending\" % len(pbs))",
            "        for t in upcoming:",
            "            eta = t - util.now()",
            "            text.extend(self.formatETA(\"next in\", eta))",
            "        return Box(text, class_=\"Activity \" + state)",
            "",
            "components.registerAdapter(CurrentBox, builder.BuilderStatus, ICurrentBox)",
            "",
            "",
            "class BuildTopBox(components.Adapter):",
            "    # this provides a per-builder box at the very top of the display,",
            "    # showing the results of the most recent build",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        assert interfaces.IBuilderStatus(self.original)",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "        builder = self.original",
            "        builds = list(builder.generateFinishedBuilds(map_branches(branches),",
            "                                                     num_builds=1))",
            "        if not builds:",
            "            return Box([\"none\"], class_=\"LastBuild\")",
            "        b = builds[0]",
            "        name = b.getBuilder().getName()",
            "        number = b.getNumber()",
            "        url = path_to_build(req, b)",
            "        text = b.getText()",
            "        tests_failed = b.getSummaryStatistic('tests-failed', operator.add, 0)",
            "        if tests_failed: text.extend([\"Failed tests: %d\" % tests_failed])",
            "        # TODO: maybe add logs?",
            "        # TODO: add link to the per-build page at 'url'",
            "        class_ = build_get_class(b)",
            "        return Box(text, class_=\"LastBuild %s\" % class_)",
            "components.registerAdapter(BuildTopBox, builder.BuilderStatus, ITopBox)",
            "",
            "class BuildBox(components.Adapter):",
            "    # this provides the yellow \"starting line\" box for each build",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        b = self.original",
            "        number = b.getNumber()",
            "        url = path_to_build(req, b)",
            "        reason = b.getReason()",
            "        text = ('<a title=\"Reason: %s\" href=\"%s\">Build %d</a>'",
            "                % (html.escape(reason), url, number))",
            "        class_ = \"start\"",
            "        if b.isFinished() and not b.getSteps():",
            "            # the steps have been pruned, so there won't be any indication",
            "            # of whether it succeeded or failed.",
            "            class_ = build_get_class(b)",
            "        return Box([text], class_=\"BuildStep \" + class_)",
            "components.registerAdapter(BuildBox, builder.BuildStatus, IBox)",
            "",
            "class StepBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        urlbase = path_to_step(req, self.original)",
            "        text = self.original.getText()",
            "        if text is None:",
            "            log.msg(\"getText() gave None\", urlbase)",
            "            text = []",
            "        text = text[:]",
            "        logs = self.original.getLogs()",
            "        for num in range(len(logs)):",
            "            name = logs[num].getName()",
            "            if logs[num].hasContents():",
            "                url = urlbase + \"/logs/%s\" % urllib.quote(name)",
            "                text.append(\"<a href=\\\"%s\\\">%s</a>\" % (url, html.escape(name)))",
            "            else:",
            "                text.append(html.escape(name))",
            "        urls = self.original.getURLs()",
            "        ex_url_class = \"BuildStep external\"",
            "        for name, target in urls.items():",
            "            text.append('[<a href=\"%s\" class=\"%s\">%s</a>]' %",
            "                        (target, ex_url_class, html.escape(name)))",
            "        class_ = \"BuildStep \" + build_get_class(self.original)",
            "        return Box(text, class_=class_)",
            "components.registerAdapter(StepBox, builder.BuildStepStatus, IBox)",
            "",
            "",
            "class EventBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        text = self.original.getText()",
            "        class_ = \"Event\"",
            "        return Box(text, class_=class_)",
            "components.registerAdapter(EventBox, builder.Event, IBox)",
            "        ",
            "",
            "class Spacer:",
            "    implements(interfaces.IStatusEvent)",
            "",
            "    def __init__(self, start, finish):",
            "        self.started = start",
            "        self.finished = finish",
            "",
            "    def getTimes(self):",
            "        return (self.started, self.finished)",
            "    def getText(self):",
            "        return []",
            "",
            "class SpacerBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        #b = Box([\"spacer\"], \"white\")",
            "        b = Box([])",
            "        b.spacer = True",
            "        return b",
            "components.registerAdapter(SpacerBox, Spacer, IBox)",
            "    ",
            "def insertGaps(g, lastEventTime, idleGap=2):",
            "    debug = False",
            "",
            "    e = g.next()",
            "    starts, finishes = e.getTimes()",
            "    if debug: log.msg(\"E0\", starts, finishes)",
            "    if finishes == 0:",
            "        finishes = starts",
            "    if debug: log.msg(\"E1 finishes=%s, gap=%s, lET=%s\" % \\",
            "                      (finishes, idleGap, lastEventTime))",
            "    if finishes is not None and finishes + idleGap < lastEventTime:",
            "        if debug: log.msg(\" spacer0\")",
            "        yield Spacer(finishes, lastEventTime)",
            "",
            "    followingEventStarts = starts",
            "    if debug: log.msg(\" fES0\", starts)",
            "    yield e",
            "",
            "    while 1:",
            "        e = g.next()",
            "        starts, finishes = e.getTimes()",
            "        if debug: log.msg(\"E2\", starts, finishes)",
            "        if finishes == 0:",
            "            finishes = starts",
            "        if finishes is not None and finishes + idleGap < followingEventStarts:",
            "            # there is a gap between the end of this event and the beginning",
            "            # of the next one. Insert an idle event so the waterfall display",
            "            # shows a gap here.",
            "            if debug:",
            "                log.msg(\" finishes=%s, gap=%s, fES=%s\" % \\",
            "                        (finishes, idleGap, followingEventStarts))",
            "            yield Spacer(finishes, followingEventStarts)",
            "        yield e",
            "        followingEventStarts = starts",
            "        if debug: log.msg(\" fES1\", starts)",
            "",
            "HELP = '''",
            "<form action=\"../waterfall\" method=\"GET\">",
            "",
            "<h1>The Waterfall Display</h1>",
            "",
            "<p>The Waterfall display can be controlled by adding query arguments to the",
            "URL. For example, if your Waterfall is accessed via the URL",
            "<tt>http://buildbot.example.org:8080</tt>, then you could add a",
            "<tt>branch=</tt> argument (described below) by going to",
            "<tt>http://buildbot.example.org:8080?branch=beta4</tt> instead. Remember that",
            "query arguments are separated from each other with ampersands, but they are",
            "separated from the main URL with a question mark, so to add a",
            "<tt>branch=</tt> and two <tt>builder=</tt> arguments, you would use",
            "<tt>http://buildbot.example.org:8080?branch=beta4&amp;builder=unix&amp;builder=macos</tt>.</p>",
            "",
            "<h2>Limiting the Displayed Interval</h2>",
            "",
            "<p>The <tt>last_time=</tt> argument is a unix timestamp (seconds since the",
            "start of 1970) that will be used as an upper bound on the interval of events",
            "displayed: nothing will be shown that is more recent than the given time.",
            "When no argument is provided, all events up to and including the most recent",
            "steps are included.</p>",
            "",
            "<p>The <tt>first_time=</tt> argument provides the lower bound. No events will",
            "be displayed that occurred <b>before</b> this timestamp. Instead of providing",
            "<tt>first_time=</tt>, you can provide <tt>show_time=</tt>: in this case,",
            "<tt>first_time</tt> will be set equal to <tt>last_time</tt> minus",
            "<tt>show_time</tt>. <tt>show_time</tt> overrides <tt>first_time</tt>.</p>",
            "",
            "<p>The display normally shows the latest 200 events that occurred in the",
            "given interval, where each timestamp on the left hand edge counts as a single",
            "event. You can add a <tt>num_events=</tt> argument to override this this.</p>",
            "",
            "<h2>Hiding non-Build events</h2>",
            "",
            "<p>By passing <tt>show_events=false</tt>, you can remove the \"buildslave",
            "attached\", \"buildslave detached\", and \"builder reconfigured\" events that",
            "appear in-between the actual builds.</p>",
            "",
            "%(show_events_input)s",
            "",
            "<h2>Showing only the Builders with failures</h2>",
            "",
            "<p>By adding the <tt>failures_only=true</tt> argument, the display will be limited",
            "to showing builders that are currently failing. A builder is considered",
            "failing if the last finished build was not successful, a step in the current",
            "build(s) failed, or if the builder is offline.",
            "",
            "%(failures_only_input)s",
            "",
            "<h2>Showing only Certain Branches</h2>",
            "",
            "<p>If you provide one or more <tt>branch=</tt> arguments, the display will be",
            "limited to builds that used one of the given branches. If no <tt>branch=</tt>",
            "arguments are given, builds from all branches will be displayed.</p>",
            "",
            "Erase the text from these \"Show Branch:\" boxes to remove that branch filter.",
            "",
            "%(show_branches_input)s",
            "",
            "<h2>Limiting the Builders that are Displayed</h2>",
            "",
            "<p>By adding one or more <tt>builder=</tt> arguments, the display will be",
            "limited to showing builds that ran on the given builders. This serves to",
            "limit the display to the specific named columns. If no <tt>builder=</tt>",
            "arguments are provided, all Builders will be displayed.</p>",
            "",
            "<p>To view a Waterfall page with only a subset of Builders displayed, select",
            "the Builders you are interested in here.</p>",
            "",
            "%(show_builders_input)s",
            "",
            "",
            "<h2>Auto-reloading the Page</h2>",
            "",
            "<p>Adding a <tt>reload=</tt> argument will cause the page to automatically",
            "reload itself after that many seconds.</p>",
            "",
            "%(show_reload_input)s",
            "",
            "<h2>Reload Waterfall Page</h2>",
            "",
            "<input type=\"submit\" value=\"View Waterfall\" />",
            "</form>",
            "'''",
            "",
            "class WaterfallHelp(HtmlResource):",
            "    title = \"Waterfall Help\"",
            "",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "        self.categories = categories",
            "",
            "    def body(self, request):",
            "        data = ''",
            "        status = self.getStatus(request)",
            "",
            "        showEvents_checked = 'checked=\"checked\"'",
            "        if request.args.get(\"show_events\", [\"true\"])[0].lower() == \"true\":",
            "            showEvents_checked = ''",
            "        show_events_input = ('<p>'",
            "                             '<input type=\"checkbox\" name=\"show_events\" '",
            "                             'value=\"false\" %s>'",
            "                             'Hide non-Build events'",
            "                             '</p>\\n'",
            "                             ) % showEvents_checked",
            "",
            "        failuresOnly_checked = ''",
            "        if request.args.get(\"failures_only\", [\"false\"])[0].lower() == \"true\":",
            "            failuresOnly_checked = 'checked=\"checked\"'",
            "        failures_only_input = ('<p>'",
            "                               '<input type=\"checkbox\" name=\"failures_only\" '",
            "                               'value=\"true\" %s>'",
            "                               'Show failures only'",
            "                               '</p>\\n'",
            "                               ) % failuresOnly_checked",
            "",
            "        branches = [b",
            "                    for b in request.args.get(\"branch\", [])",
            "                    if b]",
            "        branches.append('')",
            "        show_branches_input = '<table>\\n'",
            "        for b in branches:",
            "            show_branches_input += ('<tr>'",
            "                                    '<td>Show Branch: '",
            "                                    '<input type=\"text\" name=\"branch\" '",
            "                                    'value=\"%s\">'",
            "                                    '</td></tr>\\n'",
            "                                    ) % (b,)",
            "        show_branches_input += '</table>\\n'",
            "",
            "        # this has a set of toggle-buttons to let the user choose the",
            "        # builders",
            "        showBuilders = request.args.get(\"show\", [])",
            "        showBuilders.extend(request.args.get(\"builder\", []))",
            "        allBuilders = status.getBuilderNames(categories=self.categories)",
            "",
            "        show_builders_input = '<table>\\n'",
            "        for bn in allBuilders:",
            "            checked = \"\"",
            "            if bn in showBuilders:",
            "                checked = 'checked=\"checked\"'",
            "            show_builders_input += ('<tr>'",
            "                                    '<td><input type=\"checkbox\"'",
            "                                    ' name=\"builder\" '",
            "                                    'value=\"%s\" %s></td> '",
            "                                    '<td>%s</td></tr>\\n'",
            "                                    ) % (bn, checked, bn)",
            "        show_builders_input += '</table>\\n'",
            "",
            "        # a couple of radio-button selectors for refresh time will appear",
            "        # just after that text",
            "        show_reload_input = '<table>\\n'",
            "        times = [(\"none\", \"None\"),",
            "                 (\"60\", \"60 seconds\"),",
            "                 (\"300\", \"5 minutes\"),",
            "                 (\"600\", \"10 minutes\"),",
            "                 ]",
            "        current_reload_time = request.args.get(\"reload\", [\"none\"])",
            "        if current_reload_time:",
            "            current_reload_time = current_reload_time[0]",
            "        if current_reload_time not in [t[0] for t in times]:",
            "            times.insert(0, (current_reload_time, current_reload_time) )",
            "        for value, name in times:",
            "            checked = \"\"",
            "            if value == current_reload_time:",
            "                checked = 'checked=\"checked\"'",
            "            show_reload_input += ('<tr>'",
            "                                  '<td><input type=\"radio\" name=\"reload\" '",
            "                                  'value=\"%s\" %s></td> '",
            "                                  '<td>%s</td></tr>\\n'",
            "                                  ) % (value, checked, name)",
            "        show_reload_input += '</table>\\n'",
            "",
            "        fields = {\"show_events_input\": show_events_input,",
            "                  \"show_branches_input\": show_branches_input,",
            "                  \"show_builders_input\": show_builders_input,",
            "                  \"show_reload_input\": show_reload_input,",
            "                  \"failures_only_input\": failures_only_input,",
            "                  }",
            "        data += HELP % fields",
            "        return data",
            "",
            "class WaterfallStatusResource(HtmlResource):",
            "    \"\"\"This builds the main status page, with the waterfall display, and",
            "    all child pages.\"\"\"",
            "",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "        self.categories = categories",
            "        self.putChild(\"help\", WaterfallHelp(categories))",
            "",
            "    def getTitle(self, request):",
            "        status = self.getStatus(request)",
            "        p = status.getProjectName()",
            "        if p:",
            "            return \"BuildBot: %s\" % p",
            "        else:",
            "            return \"BuildBot\"",
            "",
            "    def getChangemaster(self, request):",
            "        # TODO: this wants to go away, access it through IStatus",
            "        return request.site.buildbot_service.getChangeSvc()",
            "",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "    def isSuccess(self, builderStatus):",
            "        # Helper function to return True if the builder is not failing.",
            "        # The function will return false if the current state is \"offline\",",
            "        # the last build was not successful, or if a step from the current",
            "        # build(s) failed.",
            "",
            "        # Make sure the builder is online.",
            "        if builderStatus.getState()[0] == 'offline':",
            "            return False",
            "",
            "        # Look at the last finished build to see if it was success or not.",
            "        lastBuild = builderStatus.getLastFinishedBuild()",
            "        if lastBuild and lastBuild.getResults() != builder.SUCCESS:",
            "            return False",
            "",
            "        # Check all the current builds to see if one step is already",
            "        # failing.",
            "        currentBuilds = builderStatus.getCurrentBuilds()",
            "        if currentBuilds:",
            "            for build in currentBuilds:",
            "                for step in build.getSteps():",
            "                    if step.getResults()[0] == builder.FAILURE:",
            "                        return False",
            "",
            "        # The last finished build was successful, and all the current builds",
            "        # don't have any failed steps.",
            "        return True",
            "",
            "    def body(self, request):",
            "        \"This method builds the main waterfall display.\"",
            "",
            "        status = self.getStatus(request)",
            "        data = ''",
            "",
            "        projectName = status.getProjectName()",
            "        projectURL = status.getProjectURL()",
            "",
            "        phase = request.args.get(\"phase\",[\"2\"])",
            "        phase = int(phase[0])",
            "",
            "        # we start with all Builders available to this Waterfall: this is",
            "        # limited by the config-file -time categories= argument, and defaults",
            "        # to all defined Builders.",
            "        allBuilderNames = status.getBuilderNames(categories=self.categories)",
            "        builders = [status.getBuilder(name) for name in allBuilderNames]",
            "",
            "        # but if the URL has one or more builder= arguments (or the old show=",
            "        # argument, which is still accepted for backwards compatibility), we",
            "        # use that set of builders instead. We still don't show anything",
            "        # outside the config-file time set limited by categories=.",
            "        showBuilders = request.args.get(\"show\", [])",
            "        showBuilders.extend(request.args.get(\"builder\", []))",
            "        if showBuilders:",
            "            builders = [b for b in builders if b.name in showBuilders]",
            "",
            "        # now, if the URL has one or category= arguments, use them as a",
            "        # filter: only show those builders which belong to one of the given",
            "        # categories.",
            "        showCategories = request.args.get(\"category\", [])",
            "        if showCategories:",
            "            builders = [b for b in builders if b.category in showCategories]",
            "",
            "        # If the URL has the failures_only=true argument, we remove all the",
            "        # builders that are not currently red or won't be turning red at the end",
            "        # of their current run.",
            "        failuresOnly = request.args.get(\"failures_only\", [\"false\"])[0]",
            "        if failuresOnly.lower() == \"true\":",
            "            builders = [b for b in builders if not self.isSuccess(b)]",
            "",
            "        builderNames = [b.name for b in builders]",
            "",
            "        if phase == -1:",
            "            return self.body0(request, builders)",
            "        (changeNames, builderNames, timestamps, eventGrid, sourceEvents) = \\",
            "                      self.buildGrid(request, builders)",
            "        if phase == 0:",
            "            return self.phase0(request, (changeNames + builderNames),",
            "                               timestamps, eventGrid)",
            "        # start the table: top-header material",
            "        data += '<table border=\"0\" cellspacing=\"0\">\\n'",
            "",
            "        if projectName and projectURL:",
            "            # TODO: this is going to look really ugly",
            "            topleft = '<a href=\"%s\">%s</a><br />last build' % \\",
            "                      (projectURL, projectName)",
            "        else:",
            "            topleft = \"last build\"",
            "        data += ' <tr class=\"LastBuild\">\\n'",
            "        data += td(topleft, align=\"right\", colspan=2, class_=\"Project\")",
            "        for b in builders:",
            "            box = ITopBox(b).getBox(request)",
            "            data += box.td(align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        data += ' <tr class=\"Activity\">\\n'",
            "        data += td('current activity', align='right', colspan=2)",
            "        for b in builders:",
            "            box = ICurrentBox(b).getBox(status)",
            "            data += box.td(align=\"center\")",
            "        data += \" </tr>\\n\"",
            "        ",
            "        data += \" <tr>\\n\"",
            "        TZ = time.tzname[time.localtime()[-1]]",
            "        data += td(\"time (%s)\" % TZ, align=\"center\", class_=\"Time\")",
            "        data += td('<a href=\"%s\">changes</a>' % request.childLink(\"../changes\"),",
            "                   align=\"center\", class_=\"Change\")",
            "        for name in builderNames:",
            "            safename = urllib.quote(name, safe='')",
            "            data += td('<a href=\"%s\">%s</a>' %",
            "                       (request.childLink(\"../builders/%s\" % safename), name),",
            "                       align=\"center\", class_=\"Builder\")",
            "        data += \" </tr>\\n\"",
            "",
            "        if phase == 1:",
            "            f = self.phase1",
            "        else:",
            "            f = self.phase2",
            "        data += f(request, changeNames + builderNames, timestamps, eventGrid,",
            "                  sourceEvents)",
            "",
            "        data += \"</table>\\n\"",
            "",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        def with_args(req, remove_args=[], new_args=[], new_path=None):",
            "            # sigh, nevow makes this sort of manipulation easier",
            "            newargs = req.args.copy()",
            "            for argname in remove_args:",
            "                newargs[argname] = []",
            "            if \"branch\" in newargs:",
            "                newargs[\"branch\"] = [b for b in newargs[\"branch\"] if b]",
            "            for k,v in new_args:",
            "                if k in newargs:",
            "                    newargs[k].append(v)",
            "                else:",
            "                    newargs[k] = [v]",
            "            newquery = \"&\".join([\"%s=%s\" % (k, urllib.quote(v))",
            "                                 for k in newargs",
            "                                 for v in newargs[k]",
            "                                 ])",
            "            if new_path:",
            "                new_url = new_path",
            "            elif req.prepath:",
            "                new_url = req.prepath[-1]",
            "            else:",
            "                new_url = ''",
            "            if newquery:",
            "                new_url += \"?\" + newquery",
            "            return new_url",
            "",
            "        if timestamps:",
            "            bottom = timestamps[-1]",
            "            nextpage = with_args(request, [\"last_time\"],",
            "                                 [(\"last_time\", str(int(bottom)))])",
            "            data += '[<a href=\"%s\">next page</a>]\\n' % nextpage",
            "",
            "        helpurl = self.path_to_root(request) + \"waterfall/help\"",
            "        helppage = with_args(request, new_path=helpurl)",
            "        data += '[<a href=\"%s\">help</a>]\\n' % helppage",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "",
            "        if self.get_reload_time(request) is not None:",
            "            no_reload_page = with_args(request, remove_args=[\"reload\"])",
            "            data += '[<a href=\"%s\">Stop Reloading</a>]\\n' % no_reload_page",
            "",
            "        data += \"<br />\\n\"",
            "",
            "",
            "        bburl = \"http://buildbot.net/?bb-ver=%s\" % urllib.quote(version)",
            "        data += '<a href=\"%s\">Buildbot-%s</a> ' % (bburl, version)",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += '<a href=\"%s\">%s</a> project.' % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        # TODO: push this to the right edge, if possible",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data",
            "",
            "    def body0(self, request, builders):",
            "        # build the waterfall display",
            "        data = \"\"",
            "        data += \"<h2>Basic display</h2>\\n\"",
            "        data += '<p>See <a href=\"%s\">here</a>' % request.childLink(\"../waterfall\")",
            "        data += \" for the waterfall display</p>\\n\"",
            "                ",
            "        data += '<table border=\"0\" cellspacing=\"0\">\\n'",
            "        names = map(lambda builder: builder.name, builders)",
            "",
            "        # the top row is two blank spaces, then the top-level status boxes",
            "        data += \" <tr>\\n\"",
            "        data += td(\"\", colspan=2)",
            "        for b in builders:",
            "            text = \"\"",
            "            state, builds = b.getState()",
            "            if state != \"offline\":",
            "                text += \"%s<br />\\n\" % state #b.getCurrentBig().text[0]",
            "            else:",
            "                text += \"OFFLINE<br />\\n\"",
            "            data += td(text, align=\"center\")",
            "",
            "        # the next row has the column headers: time, changes, builder names",
            "        data += \" <tr>\\n\"",
            "        data += td(\"Time\", align=\"center\")",
            "        data += td(\"Changes\", align=\"center\")",
            "        for name in names:",
            "            data += td('<a href=\"%s\">%s</a>' %",
            "                       (request.childLink(\"../\" + urllib.quote(name)), name),",
            "                       align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        # all further rows involve timestamps, commit events, and build events",
            "        data += \" <tr>\\n\"",
            "        data += td(\"04:00\", align=\"bottom\")",
            "        data += td(\"fred\", align=\"center\")",
            "        for name in names:",
            "            data += td(\"stuff\", align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        data += \"</table>\\n\"",
            "        return data",
            "    ",
            "    def buildGrid(self, request, builders):",
            "        debug = False",
            "        # TODO: see if we can use a cached copy",
            "",
            "        showEvents = False",
            "        if request.args.get(\"show_events\", [\"true\"])[0].lower() == \"true\":",
            "            showEvents = True",
            "        filterCategories = request.args.get('category', [])",
            "        filterBranches = [b for b in request.args.get(\"branch\", []) if b]",
            "        filterBranches = map_branches(filterBranches)",
            "        maxTime = int(request.args.get(\"last_time\", [util.now()])[0])",
            "        if \"show_time\" in request.args:",
            "            minTime = maxTime - int(request.args[\"show_time\"][0])",
            "        elif \"first_time\" in request.args:",
            "            minTime = int(request.args[\"first_time\"][0])",
            "        else:",
            "            minTime = None",
            "        spanLength = 10  # ten-second chunks",
            "        maxPageLen = int(request.args.get(\"num_events\", [200])[0])",
            "",
            "        # first step is to walk backwards in time, asking each column",
            "        # (commit, all builders) if they have any events there. Build up the",
            "        # array of events, and stop when we have a reasonable number.",
            "            ",
            "        commit_source = self.getChangemaster(request)",
            "",
            "        lastEventTime = util.now()",
            "        sources = [commit_source] + builders",
            "        changeNames = [\"changes\"]",
            "        builderNames = map(lambda builder: builder.getName(), builders)",
            "        sourceNames = changeNames + builderNames",
            "        sourceEvents = []",
            "        sourceGenerators = []",
            "",
            "        def get_event_from(g):",
            "            try:",
            "                while True:",
            "                    e = g.next()",
            "                    # e might be builder.BuildStepStatus,",
            "                    # builder.BuildStatus, builder.Event,",
            "                    # waterfall.Spacer(builder.Event), or changes.Change .",
            "                    # The showEvents=False flag means we should hide",
            "                    # builder.Event .",
            "                    if not showEvents and isinstance(e, builder.Event):",
            "                        continue",
            "                    break",
            "                event = interfaces.IStatusEvent(e)",
            "                if debug:",
            "                    log.msg(\"gen %s gave1 %s\" % (g, event.getText()))",
            "            except StopIteration:",
            "                event = None",
            "            return event",
            "",
            "        for s in sources:",
            "            gen = insertGaps(s.eventGenerator(filterBranches, filterCategories), lastEventTime)",
            "            sourceGenerators.append(gen)",
            "            # get the first event",
            "            sourceEvents.append(get_event_from(gen))",
            "        eventGrid = []",
            "        timestamps = []",
            "",
            "        lastEventTime = 0",
            "        for e in sourceEvents:",
            "            if e and e.getTimes()[0] > lastEventTime:",
            "                lastEventTime = e.getTimes()[0]",
            "        if lastEventTime == 0:",
            "            lastEventTime = util.now()",
            "",
            "        spanStart = lastEventTime - spanLength",
            "        debugGather = 0",
            "",
            "        while 1:",
            "            if debugGather: log.msg(\"checking (%s,]\" % spanStart)",
            "            # the tableau of potential events is in sourceEvents[]. The",
            "            # window crawls backwards, and we examine one source at a time.",
            "            # If the source's top-most event is in the window, is it pushed",
            "            # onto the events[] array and the tableau is refilled. This",
            "            # continues until the tableau event is not in the window (or is",
            "            # missing).",
            "",
            "            spanEvents = [] # for all sources, in this span. row of eventGrid",
            "            firstTimestamp = None # timestamp of first event in the span",
            "            lastTimestamp = None # last pre-span event, for next span",
            "",
            "            for c in range(len(sourceGenerators)):",
            "                events = [] # for this source, in this span. cell of eventGrid",
            "                event = sourceEvents[c]",
            "                while event and spanStart < event.getTimes()[0]:",
            "                    # to look at windows that don't end with the present,",
            "                    # condition the .append on event.time <= spanFinish",
            "                    if not IBox(event, None):",
            "                        log.msg(\"BAD EVENT\", event, event.getText())",
            "                        assert 0",
            "                    if debug:",
            "                        log.msg(\"pushing\", event.getText(), event)",
            "                    events.append(event)",
            "                    starts, finishes = event.getTimes()",
            "                    firstTimestamp = util.earlier(firstTimestamp, starts)",
            "                    event = get_event_from(sourceGenerators[c])",
            "                if debug:",
            "                    log.msg(\"finished span\")",
            "",
            "                if event:",
            "                    # this is the last pre-span event for this source",
            "                    lastTimestamp = util.later(lastTimestamp,",
            "                                               event.getTimes()[0])",
            "                if debugGather:",
            "                    log.msg(\" got %s from %s\" % (events, sourceNames[c]))",
            "                sourceEvents[c] = event # refill the tableau",
            "                spanEvents.append(events)",
            "",
            "            # only show events older than maxTime. This makes it possible to",
            "            # visit a page that shows what it would be like to scroll off the",
            "            # bottom of this one.",
            "            if firstTimestamp is not None and firstTimestamp <= maxTime:",
            "                eventGrid.append(spanEvents)",
            "                timestamps.append(firstTimestamp)",
            "",
            "            if lastTimestamp:",
            "                spanStart = lastTimestamp - spanLength",
            "            else:",
            "                # no more events",
            "                break",
            "            if minTime is not None and lastTimestamp < minTime:",
            "                break",
            "",
            "            if len(timestamps) > maxPageLen:",
            "                break",
            "            ",
            "            ",
            "            # now loop",
            "            ",
            "        # loop is finished. now we have eventGrid[] and timestamps[]",
            "        if debugGather: log.msg(\"finished loop\")",
            "        assert(len(timestamps) == len(eventGrid))",
            "        return (changeNames, builderNames, timestamps, eventGrid, sourceEvents)",
            "    ",
            "    def phase0(self, request, sourceNames, timestamps, eventGrid):",
            "        # phase0 rendering",
            "        if not timestamps:",
            "            return \"no events\"",
            "        data = \"\"",
            "        for r in range(0, len(timestamps)):",
            "            data += \"<p>\\n\"",
            "            data += \"[%s]<br />\" % timestamps[r]",
            "            row = eventGrid[r]",
            "            assert(len(row) == len(sourceNames))",
            "            for c in range(0, len(row)):",
            "                if row[c]:",
            "                    data += \"<b>%s</b><br />\\n\" % sourceNames[c]",
            "                    for e in row[c]:",
            "                        log.msg(\"Event\", r, c, sourceNames[c], e.getText())",
            "                        lognames = [loog.getName() for loog in e.getLogs()]",
            "                        data += \"%s: %s: %s<br />\" % (e.getText(),",
            "                                                         e.getTimes()[0],",
            "                                                         lognames)",
            "                else:",
            "                    data += \"<b>%s</b> [none]<br />\\n\" % sourceNames[c]",
            "        return data",
            "    ",
            "    def phase1(self, request, sourceNames, timestamps, eventGrid,",
            "               sourceEvents):",
            "        # phase1 rendering: table, but boxes do not overlap",
            "        data = \"\"",
            "        if not timestamps:",
            "            return data",
            "        lastDate = None",
            "        for r in range(0, len(timestamps)):",
            "            chunkstrip = eventGrid[r]",
            "            # chunkstrip is a horizontal strip of event blocks. Each block",
            "            # is a vertical list of events, all for the same source.",
            "            assert(len(chunkstrip) == len(sourceNames))",
            "            maxRows = reduce(lambda x,y: max(x,y),",
            "                             map(lambda x: len(x), chunkstrip))",
            "            for i in range(maxRows):",
            "                data += \" <tr>\\n\";",
            "                if i == 0:",
            "                    stuff = []",
            "                    # add the date at the beginning, and each time it changes",
            "                    today = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                          time.localtime(timestamps[r]))",
            "                    todayday = time.strftime(\"<b>%a</b>\",",
            "                                             time.localtime(timestamps[r]))",
            "                    if today != lastDate:",
            "                        stuff.append(todayday)",
            "                        stuff.append(today)",
            "                        lastDate = today",
            "                    stuff.append(",
            "                        time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(timestamps[r])))",
            "                    data += td(stuff, valign=\"bottom\", align=\"center\",",
            "                               rowspan=maxRows, class_=\"Time\")",
            "                for c in range(0, len(chunkstrip)):",
            "                    block = chunkstrip[c]",
            "                    assert(block != None) # should be [] instead",
            "                    # bottom-justify",
            "                    offset = maxRows - len(block)",
            "                    if i < offset:",
            "                        data += td(\"\")",
            "                    else:",
            "                        e = block[i-offset]",
            "                        box = IBox(e).getBox(request)",
            "                        box.parms[\"show_idle\"] = 1",
            "                        data += box.td(valign=\"top\", align=\"center\")",
            "                data += \" </tr>\\n\"",
            "        ",
            "        return data",
            "    ",
            "    def phase2(self, request, sourceNames, timestamps, eventGrid,",
            "               sourceEvents):",
            "        data = \"\"",
            "        if not timestamps:",
            "            return data",
            "        # first pass: figure out the height of the chunks, populate grid",
            "        grid = []",
            "        for i in range(1+len(sourceNames)):",
            "            grid.append([])",
            "        # grid is a list of columns, one for the timestamps, and one per",
            "        # event source. Each column is exactly the same height. Each element",
            "        # of the list is a single <td> box.",
            "        lastDate = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                 time.localtime(util.now()))",
            "        for r in range(0, len(timestamps)):",
            "            chunkstrip = eventGrid[r]",
            "            # chunkstrip is a horizontal strip of event blocks. Each block",
            "            # is a vertical list of events, all for the same source.",
            "            assert(len(chunkstrip) == len(sourceNames))",
            "            maxRows = reduce(lambda x,y: max(x,y),",
            "                             map(lambda x: len(x), chunkstrip))",
            "            for i in range(maxRows):",
            "                if i != maxRows-1:",
            "                    grid[0].append(None)",
            "                else:",
            "                    # timestamp goes at the bottom of the chunk",
            "                    stuff = []",
            "                    # add the date at the beginning (if it is not the same as",
            "                    # today's date), and each time it changes",
            "                    todayday = time.strftime(\"<b>%a</b>\",",
            "                                             time.localtime(timestamps[r]))",
            "                    today = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                          time.localtime(timestamps[r]))",
            "                    if today != lastDate:",
            "                        stuff.append(todayday)",
            "                        stuff.append(today)",
            "                        lastDate = today",
            "                    stuff.append(",
            "                        time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(timestamps[r])))",
            "                    grid[0].append(Box(text=stuff, class_=\"Time\",",
            "                                       valign=\"bottom\", align=\"center\"))",
            "",
            "            # at this point the timestamp column has been populated with",
            "            # maxRows boxes, most None but the last one has the time string",
            "            for c in range(0, len(chunkstrip)):",
            "                block = chunkstrip[c]",
            "                assert(block != None) # should be [] instead",
            "                for i in range(maxRows - len(block)):",
            "                    # fill top of chunk with blank space",
            "                    grid[c+1].append(None)",
            "                for i in range(len(block)):",
            "                    # so the events are bottom-justified",
            "                    b = IBox(block[i]).getBox(request)",
            "                    b.parms['valign'] = \"top\"",
            "                    b.parms['align'] = \"center\"",
            "                    grid[c+1].append(b)",
            "            # now all the other columns have maxRows new boxes too",
            "        # populate the last row, if empty",
            "        gridlen = len(grid[0])",
            "        for i in range(len(grid)):",
            "            strip = grid[i]",
            "            assert(len(strip) == gridlen)",
            "            if strip[-1] == None:",
            "                if sourceEvents[i-1]:",
            "                    filler = IBox(sourceEvents[i-1]).getBox(request)",
            "                else:",
            "                    # this can happen if you delete part of the build history",
            "                    filler = Box(text=[\"?\"], align=\"center\")",
            "                strip[-1] = filler",
            "            strip[-1].parms['rowspan'] = 1",
            "        # second pass: bubble the events upwards to un-occupied locations",
            "        # Every square of the grid that has a None in it needs to have",
            "        # something else take its place.",
            "        noBubble = request.args.get(\"nobubble\",['0'])",
            "        noBubble = int(noBubble[0])",
            "        if not noBubble:",
            "            for col in range(len(grid)):",
            "                strip = grid[col]",
            "                if col == 1: # changes are handled differently",
            "                    for i in range(2, len(strip)+1):",
            "                        # only merge empty boxes. Don't bubble commit boxes.",
            "                        if strip[-i] == None:",
            "                            next = strip[-i+1]",
            "                            assert(next)",
            "                            if next:",
            "                                #if not next.event:",
            "                                if next.spacer:",
            "                                    # bubble the empty box up",
            "                                    strip[-i] = next",
            "                                    strip[-i].parms['rowspan'] += 1",
            "                                    strip[-i+1] = None",
            "                                else:",
            "                                    # we are above a commit box. Leave it",
            "                                    # be, and turn the current box into an",
            "                                    # empty one",
            "                                    strip[-i] = Box([], rowspan=1,",
            "                                                    comment=\"commit bubble\")",
            "                                    strip[-i].spacer = True",
            "                            else:",
            "                                # we are above another empty box, which",
            "                                # somehow wasn't already converted.",
            "                                # Shouldn't happen",
            "                                pass",
            "                else:",
            "                    for i in range(2, len(strip)+1):",
            "                        # strip[-i] will go from next-to-last back to first",
            "                        if strip[-i] == None:",
            "                            # bubble previous item up",
            "                            assert(strip[-i+1] != None)",
            "                            strip[-i] = strip[-i+1]",
            "                            strip[-i].parms['rowspan'] += 1",
            "                            strip[-i+1] = None",
            "                        else:",
            "                            strip[-i].parms['rowspan'] = 1",
            "        # third pass: render the HTML table",
            "        for i in range(gridlen):",
            "            data += \" <tr>\\n\";",
            "            for strip in grid:",
            "                b = strip[i]",
            "                if b:",
            "                    # convert data to a unicode string, whacking any non-ASCII characters it might contain",
            "                    s = b.td()",
            "                    if isinstance(s, unicode):",
            "                        s = s.encode(\"utf-8\", \"replace\")",
            "                    data += s",
            "                else:",
            "                    if noBubble:",
            "                        data += td([])",
            "                # Nones are left empty, rowspan should make it all fit",
            "            data += \" </tr>\\n\"",
            "        return data"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: buildbot.test.test_web -*-",
            "",
            "from zope.interface import implements",
            "from twisted.python import log, components",
            "from twisted.web import html",
            "import urllib",
            "",
            "import time",
            "import operator",
            "",
            "from buildbot import interfaces, util",
            "from buildbot import version",
            "from buildbot.status import builder",
            "",
            "from buildbot.status.web.base import Box, HtmlResource, IBox, ICurrentBox, \\",
            "     ITopBox, td, build_get_class, path_to_build, path_to_step, map_branches",
            "",
            "",
            "",
            "class CurrentBox(components.Adapter):",
            "    # this provides the \"current activity\" box, just above the builder name",
            "    implements(ICurrentBox)",
            "",
            "    def formatETA(self, prefix, eta):",
            "        if eta is None:",
            "            return []",
            "        if eta < 60:",
            "            return [\"< 1 min\"]",
            "        eta_parts = [\"~\"]",
            "        eta_secs = eta",
            "        if eta_secs > 3600:",
            "            eta_parts.append(\"%d hrs\" % (eta_secs / 3600))",
            "            eta_secs %= 3600",
            "        if eta_secs > 60:",
            "            eta_parts.append(\"%d mins\" % (eta_secs / 60))",
            "            eta_secs %= 60",
            "        abstime = time.strftime(\"%H:%M\", time.localtime(util.now()+eta))",
            "        return [prefix, \" \".join(eta_parts), \"at %s\" % abstime]",
            "",
            "    def getBox(self, status):",
            "        # getState() returns offline, idle, or building",
            "        state, builds = self.original.getState()",
            "",
            "        # look for upcoming builds. We say the state is \"waiting\" if the",
            "        # builder is otherwise idle and there is a scheduler which tells us a",
            "        # build will be performed some time in the near future. TODO: this",
            "        # functionality used to be in BuilderStatus.. maybe this code should",
            "        # be merged back into it.",
            "        upcoming = []",
            "        builderName = self.original.getName()",
            "        for s in status.getSchedulers():",
            "            if builderName in s.listBuilderNames():",
            "                upcoming.extend(s.getPendingBuildTimes())",
            "        if state == \"idle\" and upcoming:",
            "            state = \"waiting\"",
            "",
            "        if state == \"building\":",
            "            text = [\"building\"]",
            "            if builds:",
            "                for b in builds:",
            "                    eta = b.getETA()",
            "                    text.extend(self.formatETA(\"ETA in\", eta))",
            "        elif state == \"offline\":",
            "            text = [\"offline\"]",
            "        elif state == \"idle\":",
            "            text = [\"idle\"]",
            "        elif state == \"waiting\":",
            "            text = [\"waiting\"]",
            "        else:",
            "            # just in case I add a state and forget to update this",
            "            text = [state]",
            "",
            "        # TODO: for now, this pending/upcoming stuff is in the \"current",
            "        # activity\" box, but really it should go into a \"next activity\" row",
            "        # instead. The only times it should show up in \"current activity\" is",
            "        # when the builder is otherwise idle.",
            "",
            "        # are any builds pending? (waiting for a slave to be free)",
            "        pbs = self.original.getPendingBuilds()",
            "        if pbs:",
            "            text.append(\"%d pending\" % len(pbs))",
            "        for t in upcoming:",
            "            eta = t - util.now()",
            "            text.extend(self.formatETA(\"next in\", eta))",
            "        return Box(text, class_=\"Activity \" + state)",
            "",
            "components.registerAdapter(CurrentBox, builder.BuilderStatus, ICurrentBox)",
            "",
            "",
            "class BuildTopBox(components.Adapter):",
            "    # this provides a per-builder box at the very top of the display,",
            "    # showing the results of the most recent build",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        assert interfaces.IBuilderStatus(self.original)",
            "        branches = [b for b in req.args.get(\"branch\", []) if b]",
            "        builder = self.original",
            "        builds = list(builder.generateFinishedBuilds(map_branches(branches),",
            "                                                     num_builds=1))",
            "        if not builds:",
            "            return Box([\"none\"], class_=\"LastBuild\")",
            "        b = builds[0]",
            "        name = b.getBuilder().getName()",
            "        number = b.getNumber()",
            "        url = path_to_build(req, b)",
            "        text = b.getText()",
            "        tests_failed = b.getSummaryStatistic('tests-failed', operator.add, 0)",
            "        if tests_failed: text.extend([\"Failed tests: %d\" % tests_failed])",
            "        # TODO: maybe add logs?",
            "        # TODO: add link to the per-build page at 'url'",
            "        class_ = build_get_class(b)",
            "        return Box(text, class_=\"LastBuild %s\" % class_)",
            "components.registerAdapter(BuildTopBox, builder.BuilderStatus, ITopBox)",
            "",
            "class BuildBox(components.Adapter):",
            "    # this provides the yellow \"starting line\" box for each build",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        b = self.original",
            "        number = b.getNumber()",
            "        url = path_to_build(req, b)",
            "        reason = b.getReason()",
            "        text = ('<a title=\"Reason: %s\" href=\"%s\">Build %d</a>'",
            "                % (html.escape(reason), url, number))",
            "        class_ = \"start\"",
            "        if b.isFinished() and not b.getSteps():",
            "            # the steps have been pruned, so there won't be any indication",
            "            # of whether it succeeded or failed.",
            "            class_ = build_get_class(b)",
            "        return Box([text], class_=\"BuildStep \" + class_)",
            "components.registerAdapter(BuildBox, builder.BuildStatus, IBox)",
            "",
            "class StepBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        urlbase = path_to_step(req, self.original)",
            "        text = self.original.getText()",
            "        if text is None:",
            "            log.msg(\"getText() gave None\", urlbase)",
            "            text = []",
            "        text = text[:]",
            "        logs = self.original.getLogs()",
            "        for num in range(len(logs)):",
            "            name = logs[num].getName()",
            "            if logs[num].hasContents():",
            "                url = urlbase + \"/logs/%s\" % urllib.quote(name)",
            "                text.append(\"<a href=\\\"%s\\\">%s</a>\" % (url, html.escape(name)))",
            "            else:",
            "                text.append(html.escape(name))",
            "        urls = self.original.getURLs()",
            "        ex_url_class = \"BuildStep external\"",
            "        for name, target in urls.items():",
            "            text.append('[<a href=\"%s\" class=\"%s\">%s</a>]' %",
            "                        (target, ex_url_class, html.escape(name)))",
            "        class_ = \"BuildStep \" + build_get_class(self.original)",
            "        return Box(text, class_=class_)",
            "components.registerAdapter(StepBox, builder.BuildStepStatus, IBox)",
            "",
            "",
            "class EventBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        text = self.original.getText()",
            "        class_ = \"Event\"",
            "        return Box(text, class_=class_)",
            "components.registerAdapter(EventBox, builder.Event, IBox)",
            "        ",
            "",
            "class Spacer:",
            "    implements(interfaces.IStatusEvent)",
            "",
            "    def __init__(self, start, finish):",
            "        self.started = start",
            "        self.finished = finish",
            "",
            "    def getTimes(self):",
            "        return (self.started, self.finished)",
            "    def getText(self):",
            "        return []",
            "",
            "class SpacerBox(components.Adapter):",
            "    implements(IBox)",
            "",
            "    def getBox(self, req):",
            "        #b = Box([\"spacer\"], \"white\")",
            "        b = Box([])",
            "        b.spacer = True",
            "        return b",
            "components.registerAdapter(SpacerBox, Spacer, IBox)",
            "    ",
            "def insertGaps(g, lastEventTime, idleGap=2):",
            "    debug = False",
            "",
            "    e = g.next()",
            "    starts, finishes = e.getTimes()",
            "    if debug: log.msg(\"E0\", starts, finishes)",
            "    if finishes == 0:",
            "        finishes = starts",
            "    if debug: log.msg(\"E1 finishes=%s, gap=%s, lET=%s\" % \\",
            "                      (finishes, idleGap, lastEventTime))",
            "    if finishes is not None and finishes + idleGap < lastEventTime:",
            "        if debug: log.msg(\" spacer0\")",
            "        yield Spacer(finishes, lastEventTime)",
            "",
            "    followingEventStarts = starts",
            "    if debug: log.msg(\" fES0\", starts)",
            "    yield e",
            "",
            "    while 1:",
            "        e = g.next()",
            "        starts, finishes = e.getTimes()",
            "        if debug: log.msg(\"E2\", starts, finishes)",
            "        if finishes == 0:",
            "            finishes = starts",
            "        if finishes is not None and finishes + idleGap < followingEventStarts:",
            "            # there is a gap between the end of this event and the beginning",
            "            # of the next one. Insert an idle event so the waterfall display",
            "            # shows a gap here.",
            "            if debug:",
            "                log.msg(\" finishes=%s, gap=%s, fES=%s\" % \\",
            "                        (finishes, idleGap, followingEventStarts))",
            "            yield Spacer(finishes, followingEventStarts)",
            "        yield e",
            "        followingEventStarts = starts",
            "        if debug: log.msg(\" fES1\", starts)",
            "",
            "HELP = '''",
            "<form action=\"../waterfall\" method=\"GET\">",
            "",
            "<h1>The Waterfall Display</h1>",
            "",
            "<p>The Waterfall display can be controlled by adding query arguments to the",
            "URL. For example, if your Waterfall is accessed via the URL",
            "<tt>http://buildbot.example.org:8080</tt>, then you could add a",
            "<tt>branch=</tt> argument (described below) by going to",
            "<tt>http://buildbot.example.org:8080?branch=beta4</tt> instead. Remember that",
            "query arguments are separated from each other with ampersands, but they are",
            "separated from the main URL with a question mark, so to add a",
            "<tt>branch=</tt> and two <tt>builder=</tt> arguments, you would use",
            "<tt>http://buildbot.example.org:8080?branch=beta4&amp;builder=unix&amp;builder=macos</tt>.</p>",
            "",
            "<h2>Limiting the Displayed Interval</h2>",
            "",
            "<p>The <tt>last_time=</tt> argument is a unix timestamp (seconds since the",
            "start of 1970) that will be used as an upper bound on the interval of events",
            "displayed: nothing will be shown that is more recent than the given time.",
            "When no argument is provided, all events up to and including the most recent",
            "steps are included.</p>",
            "",
            "<p>The <tt>first_time=</tt> argument provides the lower bound. No events will",
            "be displayed that occurred <b>before</b> this timestamp. Instead of providing",
            "<tt>first_time=</tt>, you can provide <tt>show_time=</tt>: in this case,",
            "<tt>first_time</tt> will be set equal to <tt>last_time</tt> minus",
            "<tt>show_time</tt>. <tt>show_time</tt> overrides <tt>first_time</tt>.</p>",
            "",
            "<p>The display normally shows the latest 200 events that occurred in the",
            "given interval, where each timestamp on the left hand edge counts as a single",
            "event. You can add a <tt>num_events=</tt> argument to override this this.</p>",
            "",
            "<h2>Hiding non-Build events</h2>",
            "",
            "<p>By passing <tt>show_events=false</tt>, you can remove the \"buildslave",
            "attached\", \"buildslave detached\", and \"builder reconfigured\" events that",
            "appear in-between the actual builds.</p>",
            "",
            "%(show_events_input)s",
            "",
            "<h2>Showing only the Builders with failures</h2>",
            "",
            "<p>By adding the <tt>failures_only=true</tt> argument, the display will be limited",
            "to showing builders that are currently failing. A builder is considered",
            "failing if the last finished build was not successful, a step in the current",
            "build(s) failed, or if the builder is offline.",
            "",
            "%(failures_only_input)s",
            "",
            "<h2>Showing only Certain Branches</h2>",
            "",
            "<p>If you provide one or more <tt>branch=</tt> arguments, the display will be",
            "limited to builds that used one of the given branches. If no <tt>branch=</tt>",
            "arguments are given, builds from all branches will be displayed.</p>",
            "",
            "Erase the text from these \"Show Branch:\" boxes to remove that branch filter.",
            "",
            "%(show_branches_input)s",
            "",
            "<h2>Limiting the Builders that are Displayed</h2>",
            "",
            "<p>By adding one or more <tt>builder=</tt> arguments, the display will be",
            "limited to showing builds that ran on the given builders. This serves to",
            "limit the display to the specific named columns. If no <tt>builder=</tt>",
            "arguments are provided, all Builders will be displayed.</p>",
            "",
            "<p>To view a Waterfall page with only a subset of Builders displayed, select",
            "the Builders you are interested in here.</p>",
            "",
            "%(show_builders_input)s",
            "",
            "",
            "<h2>Auto-reloading the Page</h2>",
            "",
            "<p>Adding a <tt>reload=</tt> argument will cause the page to automatically",
            "reload itself after that many seconds.</p>",
            "",
            "%(show_reload_input)s",
            "",
            "<h2>Reload Waterfall Page</h2>",
            "",
            "<input type=\"submit\" value=\"View Waterfall\" />",
            "</form>",
            "'''",
            "",
            "class WaterfallHelp(HtmlResource):",
            "    title = \"Waterfall Help\"",
            "",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "        self.categories = categories",
            "",
            "    def body(self, request):",
            "        data = ''",
            "        status = self.getStatus(request)",
            "",
            "        showEvents_checked = 'checked=\"checked\"'",
            "        if request.args.get(\"show_events\", [\"true\"])[0].lower() == \"true\":",
            "            showEvents_checked = ''",
            "        show_events_input = ('<p>'",
            "                             '<input type=\"checkbox\" name=\"show_events\" '",
            "                             'value=\"false\" %s>'",
            "                             'Hide non-Build events'",
            "                             '</p>\\n'",
            "                             ) % showEvents_checked",
            "",
            "        failuresOnly_checked = ''",
            "        if request.args.get(\"failures_only\", [\"false\"])[0].lower() == \"true\":",
            "            failuresOnly_checked = 'checked=\"checked\"'",
            "        failures_only_input = ('<p>'",
            "                               '<input type=\"checkbox\" name=\"failures_only\" '",
            "                               'value=\"true\" %s>'",
            "                               'Show failures only'",
            "                               '</p>\\n'",
            "                               ) % failuresOnly_checked",
            "",
            "        branches = [b",
            "                    for b in request.args.get(\"branch\", [])",
            "                    if b]",
            "        branches.append('')",
            "        show_branches_input = '<table>\\n'",
            "        for b in branches:",
            "            show_branches_input += ('<tr>'",
            "                                    '<td>Show Branch: '",
            "                                    '<input type=\"text\" name=\"branch\" '",
            "                                    'value=\"%s\">'",
            "                                    '</td></tr>\\n'",
            "                                    ) % (html.escape(b),)",
            "        show_branches_input += '</table>\\n'",
            "",
            "        # this has a set of toggle-buttons to let the user choose the",
            "        # builders",
            "        showBuilders = request.args.get(\"show\", [])",
            "        showBuilders.extend(request.args.get(\"builder\", []))",
            "        allBuilders = status.getBuilderNames(categories=self.categories)",
            "",
            "        show_builders_input = '<table>\\n'",
            "        for bn in allBuilders:",
            "            checked = \"\"",
            "            if bn in showBuilders:",
            "                checked = 'checked=\"checked\"'",
            "            show_builders_input += ('<tr>'",
            "                                    '<td><input type=\"checkbox\"'",
            "                                    ' name=\"builder\" '",
            "                                    'value=\"%s\" %s></td> '",
            "                                    '<td>%s</td></tr>\\n'",
            "                                    ) % (bn, checked, bn)",
            "        show_builders_input += '</table>\\n'",
            "",
            "        # a couple of radio-button selectors for refresh time will appear",
            "        # just after that text",
            "        show_reload_input = '<table>\\n'",
            "        times = [(\"none\", \"None\"),",
            "                 (\"60\", \"60 seconds\"),",
            "                 (\"300\", \"5 minutes\"),",
            "                 (\"600\", \"10 minutes\"),",
            "                 ]",
            "        current_reload_time = request.args.get(\"reload\", [\"none\"])",
            "        if current_reload_time:",
            "            current_reload_time = current_reload_time[0]",
            "        if current_reload_time not in [t[0] for t in times]:",
            "            times.insert(0, (current_reload_time, current_reload_time) )",
            "        for value, name in times:",
            "            checked = \"\"",
            "            if value == current_reload_time:",
            "                checked = 'checked=\"checked\"'",
            "            show_reload_input += ('<tr>'",
            "                                  '<td><input type=\"radio\" name=\"reload\" '",
            "                                  'value=\"%s\" %s></td> '",
            "                                  '<td>%s</td></tr>\\n'",
            "                                  ) % (value, checked, name)",
            "        show_reload_input += '</table>\\n'",
            "",
            "        fields = {\"show_events_input\": show_events_input,",
            "                  \"show_branches_input\": show_branches_input,",
            "                  \"show_builders_input\": show_builders_input,",
            "                  \"show_reload_input\": show_reload_input,",
            "                  \"failures_only_input\": failures_only_input,",
            "                  }",
            "        data += HELP % fields",
            "        return data",
            "",
            "class WaterfallStatusResource(HtmlResource):",
            "    \"\"\"This builds the main status page, with the waterfall display, and",
            "    all child pages.\"\"\"",
            "",
            "    def __init__(self, categories=None):",
            "        HtmlResource.__init__(self)",
            "        self.categories = categories",
            "        self.putChild(\"help\", WaterfallHelp(categories))",
            "",
            "    def getTitle(self, request):",
            "        status = self.getStatus(request)",
            "        p = status.getProjectName()",
            "        if p:",
            "            return \"BuildBot: %s\" % p",
            "        else:",
            "            return \"BuildBot\"",
            "",
            "    def getChangemaster(self, request):",
            "        # TODO: this wants to go away, access it through IStatus",
            "        return request.site.buildbot_service.getChangeSvc()",
            "",
            "    def get_reload_time(self, request):",
            "        if \"reload\" in request.args:",
            "            try:",
            "                reload_time = int(request.args[\"reload\"][0])",
            "                return max(reload_time, 15)",
            "            except ValueError:",
            "                pass",
            "        return None",
            "",
            "    def head(self, request):",
            "        head = ''",
            "        reload_time = self.get_reload_time(request)",
            "        if reload_time is not None:",
            "            head += '<meta http-equiv=\"refresh\" content=\"%d\">\\n' % reload_time",
            "        return head",
            "",
            "    def isSuccess(self, builderStatus):",
            "        # Helper function to return True if the builder is not failing.",
            "        # The function will return false if the current state is \"offline\",",
            "        # the last build was not successful, or if a step from the current",
            "        # build(s) failed.",
            "",
            "        # Make sure the builder is online.",
            "        if builderStatus.getState()[0] == 'offline':",
            "            return False",
            "",
            "        # Look at the last finished build to see if it was success or not.",
            "        lastBuild = builderStatus.getLastFinishedBuild()",
            "        if lastBuild and lastBuild.getResults() != builder.SUCCESS:",
            "            return False",
            "",
            "        # Check all the current builds to see if one step is already",
            "        # failing.",
            "        currentBuilds = builderStatus.getCurrentBuilds()",
            "        if currentBuilds:",
            "            for build in currentBuilds:",
            "                for step in build.getSteps():",
            "                    if step.getResults()[0] == builder.FAILURE:",
            "                        return False",
            "",
            "        # The last finished build was successful, and all the current builds",
            "        # don't have any failed steps.",
            "        return True",
            "",
            "    def body(self, request):",
            "        \"This method builds the main waterfall display.\"",
            "",
            "        status = self.getStatus(request)",
            "        data = ''",
            "",
            "        projectName = status.getProjectName()",
            "        projectURL = status.getProjectURL()",
            "",
            "        phase = request.args.get(\"phase\",[\"2\"])",
            "        phase = int(phase[0])",
            "",
            "        # we start with all Builders available to this Waterfall: this is",
            "        # limited by the config-file -time categories= argument, and defaults",
            "        # to all defined Builders.",
            "        allBuilderNames = status.getBuilderNames(categories=self.categories)",
            "        builders = [status.getBuilder(name) for name in allBuilderNames]",
            "",
            "        # but if the URL has one or more builder= arguments (or the old show=",
            "        # argument, which is still accepted for backwards compatibility), we",
            "        # use that set of builders instead. We still don't show anything",
            "        # outside the config-file time set limited by categories=.",
            "        showBuilders = request.args.get(\"show\", [])",
            "        showBuilders.extend(request.args.get(\"builder\", []))",
            "        if showBuilders:",
            "            builders = [b for b in builders if b.name in showBuilders]",
            "",
            "        # now, if the URL has one or category= arguments, use them as a",
            "        # filter: only show those builders which belong to one of the given",
            "        # categories.",
            "        showCategories = request.args.get(\"category\", [])",
            "        if showCategories:",
            "            builders = [b for b in builders if b.category in showCategories]",
            "",
            "        # If the URL has the failures_only=true argument, we remove all the",
            "        # builders that are not currently red or won't be turning red at the end",
            "        # of their current run.",
            "        failuresOnly = request.args.get(\"failures_only\", [\"false\"])[0]",
            "        if failuresOnly.lower() == \"true\":",
            "            builders = [b for b in builders if not self.isSuccess(b)]",
            "",
            "        builderNames = [b.name for b in builders]",
            "",
            "        if phase == -1:",
            "            return self.body0(request, builders)",
            "        (changeNames, builderNames, timestamps, eventGrid, sourceEvents) = \\",
            "                      self.buildGrid(request, builders)",
            "        if phase == 0:",
            "            return self.phase0(request, (changeNames + builderNames),",
            "                               timestamps, eventGrid)",
            "        # start the table: top-header material",
            "        data += '<table border=\"0\" cellspacing=\"0\">\\n'",
            "",
            "        if projectName and projectURL:",
            "            # TODO: this is going to look really ugly",
            "            topleft = '<a href=\"%s\">%s</a><br />last build' % \\",
            "                      (projectURL, projectName)",
            "        else:",
            "            topleft = \"last build\"",
            "        data += ' <tr class=\"LastBuild\">\\n'",
            "        data += td(topleft, align=\"right\", colspan=2, class_=\"Project\")",
            "        for b in builders:",
            "            box = ITopBox(b).getBox(request)",
            "            data += box.td(align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        data += ' <tr class=\"Activity\">\\n'",
            "        data += td('current activity', align='right', colspan=2)",
            "        for b in builders:",
            "            box = ICurrentBox(b).getBox(status)",
            "            data += box.td(align=\"center\")",
            "        data += \" </tr>\\n\"",
            "        ",
            "        data += \" <tr>\\n\"",
            "        TZ = time.tzname[time.localtime()[-1]]",
            "        data += td(\"time (%s)\" % TZ, align=\"center\", class_=\"Time\")",
            "        data += td('<a href=\"%s\">changes</a>' % request.childLink(\"../changes\"),",
            "                   align=\"center\", class_=\"Change\")",
            "        for name in builderNames:",
            "            safename = urllib.quote(name, safe='')",
            "            data += td('<a href=\"%s\">%s</a>' %",
            "                       (request.childLink(\"../builders/%s\" % safename), name),",
            "                       align=\"center\", class_=\"Builder\")",
            "        data += \" </tr>\\n\"",
            "",
            "        if phase == 1:",
            "            f = self.phase1",
            "        else:",
            "            f = self.phase2",
            "        data += f(request, changeNames + builderNames, timestamps, eventGrid,",
            "                  sourceEvents)",
            "",
            "        data += \"</table>\\n\"",
            "",
            "        data += '<hr /><div class=\"footer\">\\n'",
            "",
            "        def with_args(req, remove_args=[], new_args=[], new_path=None):",
            "            # sigh, nevow makes this sort of manipulation easier",
            "            newargs = req.args.copy()",
            "            for argname in remove_args:",
            "                newargs[argname] = []",
            "            if \"branch\" in newargs:",
            "                newargs[\"branch\"] = [b for b in newargs[\"branch\"] if b]",
            "            for k,v in new_args:",
            "                if k in newargs:",
            "                    newargs[k].append(v)",
            "                else:",
            "                    newargs[k] = [v]",
            "            newquery = \"&\".join([\"%s=%s\" % (urllib.quote(k), urllib.quote(v))",
            "                                 for k in newargs",
            "                                 for v in newargs[k]",
            "                                 ])",
            "            if new_path:",
            "                new_url = new_path",
            "            elif req.prepath:",
            "                new_url = req.prepath[-1]",
            "            else:",
            "                new_url = ''",
            "            if newquery:",
            "                new_url += \"?\" + newquery",
            "            return new_url",
            "",
            "        if timestamps:",
            "            bottom = timestamps[-1]",
            "            nextpage = with_args(request, [\"last_time\"],",
            "                                 [(\"last_time\", str(int(bottom)))])",
            "            data += '[<a href=\"%s\">next page</a>]\\n' % nextpage",
            "",
            "        helpurl = self.path_to_root(request) + \"waterfall/help\"",
            "        helppage = with_args(request, new_path=helpurl)",
            "        data += '[<a href=\"%s\">help</a>]\\n' % helppage",
            "",
            "        welcomeurl = self.path_to_root(request) + \"index.html\"",
            "        data += '[<a href=\"%s\">welcome</a>]\\n' % welcomeurl",
            "",
            "        if self.get_reload_time(request) is not None:",
            "            no_reload_page = with_args(request, remove_args=[\"reload\"])",
            "            data += '[<a href=\"%s\">Stop Reloading</a>]\\n' % no_reload_page",
            "",
            "        data += \"<br />\\n\"",
            "",
            "",
            "        bburl = \"http://buildbot.net/?bb-ver=%s\" % urllib.quote(version)",
            "        data += '<a href=\"%s\">Buildbot-%s</a> ' % (bburl, version)",
            "        if projectName:",
            "            data += \"working for the \"",
            "            if projectURL:",
            "                data += '<a href=\"%s\">%s</a> project.' % (projectURL,",
            "                                                            projectName)",
            "            else:",
            "                data += \"%s project.\" % projectName",
            "        data += \"<br />\\n\"",
            "        # TODO: push this to the right edge, if possible",
            "        data += (\"Page built: \" +",
            "                 time.strftime(\"%a %d %b %Y %H:%M:%S\",",
            "                               time.localtime(util.now()))",
            "                 + \"\\n\")",
            "        data += '</div>\\n'",
            "        return data",
            "",
            "    def body0(self, request, builders):",
            "        # build the waterfall display",
            "        data = \"\"",
            "        data += \"<h2>Basic display</h2>\\n\"",
            "        data += '<p>See <a href=\"%s\">here</a>' % request.childLink(\"../waterfall\")",
            "        data += \" for the waterfall display</p>\\n\"",
            "                ",
            "        data += '<table border=\"0\" cellspacing=\"0\">\\n'",
            "        names = map(lambda builder: builder.name, builders)",
            "",
            "        # the top row is two blank spaces, then the top-level status boxes",
            "        data += \" <tr>\\n\"",
            "        data += td(\"\", colspan=2)",
            "        for b in builders:",
            "            text = \"\"",
            "            state, builds = b.getState()",
            "            if state != \"offline\":",
            "                text += \"%s<br />\\n\" % state #b.getCurrentBig().text[0]",
            "            else:",
            "                text += \"OFFLINE<br />\\n\"",
            "            data += td(text, align=\"center\")",
            "",
            "        # the next row has the column headers: time, changes, builder names",
            "        data += \" <tr>\\n\"",
            "        data += td(\"Time\", align=\"center\")",
            "        data += td(\"Changes\", align=\"center\")",
            "        for name in names:",
            "            data += td('<a href=\"%s\">%s</a>' %",
            "                       (request.childLink(\"../\" + urllib.quote(name)), name),",
            "                       align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        # all further rows involve timestamps, commit events, and build events",
            "        data += \" <tr>\\n\"",
            "        data += td(\"04:00\", align=\"bottom\")",
            "        data += td(\"fred\", align=\"center\")",
            "        for name in names:",
            "            data += td(\"stuff\", align=\"center\")",
            "        data += \" </tr>\\n\"",
            "",
            "        data += \"</table>\\n\"",
            "        return data",
            "    ",
            "    def buildGrid(self, request, builders):",
            "        debug = False",
            "        # TODO: see if we can use a cached copy",
            "",
            "        showEvents = False",
            "        if request.args.get(\"show_events\", [\"true\"])[0].lower() == \"true\":",
            "            showEvents = True",
            "        filterCategories = request.args.get('category', [])",
            "        filterBranches = [b for b in request.args.get(\"branch\", []) if b]",
            "        filterBranches = map_branches(filterBranches)",
            "        maxTime = int(request.args.get(\"last_time\", [util.now()])[0])",
            "        if \"show_time\" in request.args:",
            "            minTime = maxTime - int(request.args[\"show_time\"][0])",
            "        elif \"first_time\" in request.args:",
            "            minTime = int(request.args[\"first_time\"][0])",
            "        else:",
            "            minTime = None",
            "        spanLength = 10  # ten-second chunks",
            "        maxPageLen = int(request.args.get(\"num_events\", [200])[0])",
            "",
            "        # first step is to walk backwards in time, asking each column",
            "        # (commit, all builders) if they have any events there. Build up the",
            "        # array of events, and stop when we have a reasonable number.",
            "            ",
            "        commit_source = self.getChangemaster(request)",
            "",
            "        lastEventTime = util.now()",
            "        sources = [commit_source] + builders",
            "        changeNames = [\"changes\"]",
            "        builderNames = map(lambda builder: builder.getName(), builders)",
            "        sourceNames = changeNames + builderNames",
            "        sourceEvents = []",
            "        sourceGenerators = []",
            "",
            "        def get_event_from(g):",
            "            try:",
            "                while True:",
            "                    e = g.next()",
            "                    # e might be builder.BuildStepStatus,",
            "                    # builder.BuildStatus, builder.Event,",
            "                    # waterfall.Spacer(builder.Event), or changes.Change .",
            "                    # The showEvents=False flag means we should hide",
            "                    # builder.Event .",
            "                    if not showEvents and isinstance(e, builder.Event):",
            "                        continue",
            "                    break",
            "                event = interfaces.IStatusEvent(e)",
            "                if debug:",
            "                    log.msg(\"gen %s gave1 %s\" % (g, event.getText()))",
            "            except StopIteration:",
            "                event = None",
            "            return event",
            "",
            "        for s in sources:",
            "            gen = insertGaps(s.eventGenerator(filterBranches, filterCategories), lastEventTime)",
            "            sourceGenerators.append(gen)",
            "            # get the first event",
            "            sourceEvents.append(get_event_from(gen))",
            "        eventGrid = []",
            "        timestamps = []",
            "",
            "        lastEventTime = 0",
            "        for e in sourceEvents:",
            "            if e and e.getTimes()[0] > lastEventTime:",
            "                lastEventTime = e.getTimes()[0]",
            "        if lastEventTime == 0:",
            "            lastEventTime = util.now()",
            "",
            "        spanStart = lastEventTime - spanLength",
            "        debugGather = 0",
            "",
            "        while 1:",
            "            if debugGather: log.msg(\"checking (%s,]\" % spanStart)",
            "            # the tableau of potential events is in sourceEvents[]. The",
            "            # window crawls backwards, and we examine one source at a time.",
            "            # If the source's top-most event is in the window, is it pushed",
            "            # onto the events[] array and the tableau is refilled. This",
            "            # continues until the tableau event is not in the window (or is",
            "            # missing).",
            "",
            "            spanEvents = [] # for all sources, in this span. row of eventGrid",
            "            firstTimestamp = None # timestamp of first event in the span",
            "            lastTimestamp = None # last pre-span event, for next span",
            "",
            "            for c in range(len(sourceGenerators)):",
            "                events = [] # for this source, in this span. cell of eventGrid",
            "                event = sourceEvents[c]",
            "                while event and spanStart < event.getTimes()[0]:",
            "                    # to look at windows that don't end with the present,",
            "                    # condition the .append on event.time <= spanFinish",
            "                    if not IBox(event, None):",
            "                        log.msg(\"BAD EVENT\", event, event.getText())",
            "                        assert 0",
            "                    if debug:",
            "                        log.msg(\"pushing\", event.getText(), event)",
            "                    events.append(event)",
            "                    starts, finishes = event.getTimes()",
            "                    firstTimestamp = util.earlier(firstTimestamp, starts)",
            "                    event = get_event_from(sourceGenerators[c])",
            "                if debug:",
            "                    log.msg(\"finished span\")",
            "",
            "                if event:",
            "                    # this is the last pre-span event for this source",
            "                    lastTimestamp = util.later(lastTimestamp,",
            "                                               event.getTimes()[0])",
            "                if debugGather:",
            "                    log.msg(\" got %s from %s\" % (events, sourceNames[c]))",
            "                sourceEvents[c] = event # refill the tableau",
            "                spanEvents.append(events)",
            "",
            "            # only show events older than maxTime. This makes it possible to",
            "            # visit a page that shows what it would be like to scroll off the",
            "            # bottom of this one.",
            "            if firstTimestamp is not None and firstTimestamp <= maxTime:",
            "                eventGrid.append(spanEvents)",
            "                timestamps.append(firstTimestamp)",
            "",
            "            if lastTimestamp:",
            "                spanStart = lastTimestamp - spanLength",
            "            else:",
            "                # no more events",
            "                break",
            "            if minTime is not None and lastTimestamp < minTime:",
            "                break",
            "",
            "            if len(timestamps) > maxPageLen:",
            "                break",
            "            ",
            "            ",
            "            # now loop",
            "            ",
            "        # loop is finished. now we have eventGrid[] and timestamps[]",
            "        if debugGather: log.msg(\"finished loop\")",
            "        assert(len(timestamps) == len(eventGrid))",
            "        return (changeNames, builderNames, timestamps, eventGrid, sourceEvents)",
            "    ",
            "    def phase0(self, request, sourceNames, timestamps, eventGrid):",
            "        # phase0 rendering",
            "        if not timestamps:",
            "            return \"no events\"",
            "        data = \"\"",
            "        for r in range(0, len(timestamps)):",
            "            data += \"<p>\\n\"",
            "            data += \"[%s]<br />\" % timestamps[r]",
            "            row = eventGrid[r]",
            "            assert(len(row) == len(sourceNames))",
            "            for c in range(0, len(row)):",
            "                if row[c]:",
            "                    data += \"<b>%s</b><br />\\n\" % sourceNames[c]",
            "                    for e in row[c]:",
            "                        log.msg(\"Event\", r, c, sourceNames[c], e.getText())",
            "                        lognames = [loog.getName() for loog in e.getLogs()]",
            "                        data += \"%s: %s: %s<br />\" % (e.getText(),",
            "                                                         e.getTimes()[0],",
            "                                                         lognames)",
            "                else:",
            "                    data += \"<b>%s</b> [none]<br />\\n\" % sourceNames[c]",
            "        return data",
            "    ",
            "    def phase1(self, request, sourceNames, timestamps, eventGrid,",
            "               sourceEvents):",
            "        # phase1 rendering: table, but boxes do not overlap",
            "        data = \"\"",
            "        if not timestamps:",
            "            return data",
            "        lastDate = None",
            "        for r in range(0, len(timestamps)):",
            "            chunkstrip = eventGrid[r]",
            "            # chunkstrip is a horizontal strip of event blocks. Each block",
            "            # is a vertical list of events, all for the same source.",
            "            assert(len(chunkstrip) == len(sourceNames))",
            "            maxRows = reduce(lambda x,y: max(x,y),",
            "                             map(lambda x: len(x), chunkstrip))",
            "            for i in range(maxRows):",
            "                data += \" <tr>\\n\";",
            "                if i == 0:",
            "                    stuff = []",
            "                    # add the date at the beginning, and each time it changes",
            "                    today = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                          time.localtime(timestamps[r]))",
            "                    todayday = time.strftime(\"<b>%a</b>\",",
            "                                             time.localtime(timestamps[r]))",
            "                    if today != lastDate:",
            "                        stuff.append(todayday)",
            "                        stuff.append(today)",
            "                        lastDate = today",
            "                    stuff.append(",
            "                        time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(timestamps[r])))",
            "                    data += td(stuff, valign=\"bottom\", align=\"center\",",
            "                               rowspan=maxRows, class_=\"Time\")",
            "                for c in range(0, len(chunkstrip)):",
            "                    block = chunkstrip[c]",
            "                    assert(block != None) # should be [] instead",
            "                    # bottom-justify",
            "                    offset = maxRows - len(block)",
            "                    if i < offset:",
            "                        data += td(\"\")",
            "                    else:",
            "                        e = block[i-offset]",
            "                        box = IBox(e).getBox(request)",
            "                        box.parms[\"show_idle\"] = 1",
            "                        data += box.td(valign=\"top\", align=\"center\")",
            "                data += \" </tr>\\n\"",
            "        ",
            "        return data",
            "    ",
            "    def phase2(self, request, sourceNames, timestamps, eventGrid,",
            "               sourceEvents):",
            "        data = \"\"",
            "        if not timestamps:",
            "            return data",
            "        # first pass: figure out the height of the chunks, populate grid",
            "        grid = []",
            "        for i in range(1+len(sourceNames)):",
            "            grid.append([])",
            "        # grid is a list of columns, one for the timestamps, and one per",
            "        # event source. Each column is exactly the same height. Each element",
            "        # of the list is a single <td> box.",
            "        lastDate = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                 time.localtime(util.now()))",
            "        for r in range(0, len(timestamps)):",
            "            chunkstrip = eventGrid[r]",
            "            # chunkstrip is a horizontal strip of event blocks. Each block",
            "            # is a vertical list of events, all for the same source.",
            "            assert(len(chunkstrip) == len(sourceNames))",
            "            maxRows = reduce(lambda x,y: max(x,y),",
            "                             map(lambda x: len(x), chunkstrip))",
            "            for i in range(maxRows):",
            "                if i != maxRows-1:",
            "                    grid[0].append(None)",
            "                else:",
            "                    # timestamp goes at the bottom of the chunk",
            "                    stuff = []",
            "                    # add the date at the beginning (if it is not the same as",
            "                    # today's date), and each time it changes",
            "                    todayday = time.strftime(\"<b>%a</b>\",",
            "                                             time.localtime(timestamps[r]))",
            "                    today = time.strftime(\"<b>%d %b %Y</b>\",",
            "                                          time.localtime(timestamps[r]))",
            "                    if today != lastDate:",
            "                        stuff.append(todayday)",
            "                        stuff.append(today)",
            "                        lastDate = today",
            "                    stuff.append(",
            "                        time.strftime(\"%H:%M:%S\",",
            "                                      time.localtime(timestamps[r])))",
            "                    grid[0].append(Box(text=stuff, class_=\"Time\",",
            "                                       valign=\"bottom\", align=\"center\"))",
            "",
            "            # at this point the timestamp column has been populated with",
            "            # maxRows boxes, most None but the last one has the time string",
            "            for c in range(0, len(chunkstrip)):",
            "                block = chunkstrip[c]",
            "                assert(block != None) # should be [] instead",
            "                for i in range(maxRows - len(block)):",
            "                    # fill top of chunk with blank space",
            "                    grid[c+1].append(None)",
            "                for i in range(len(block)):",
            "                    # so the events are bottom-justified",
            "                    b = IBox(block[i]).getBox(request)",
            "                    b.parms['valign'] = \"top\"",
            "                    b.parms['align'] = \"center\"",
            "                    grid[c+1].append(b)",
            "            # now all the other columns have maxRows new boxes too",
            "        # populate the last row, if empty",
            "        gridlen = len(grid[0])",
            "        for i in range(len(grid)):",
            "            strip = grid[i]",
            "            assert(len(strip) == gridlen)",
            "            if strip[-1] == None:",
            "                if sourceEvents[i-1]:",
            "                    filler = IBox(sourceEvents[i-1]).getBox(request)",
            "                else:",
            "                    # this can happen if you delete part of the build history",
            "                    filler = Box(text=[\"?\"], align=\"center\")",
            "                strip[-1] = filler",
            "            strip[-1].parms['rowspan'] = 1",
            "        # second pass: bubble the events upwards to un-occupied locations",
            "        # Every square of the grid that has a None in it needs to have",
            "        # something else take its place.",
            "        noBubble = request.args.get(\"nobubble\",['0'])",
            "        noBubble = int(noBubble[0])",
            "        if not noBubble:",
            "            for col in range(len(grid)):",
            "                strip = grid[col]",
            "                if col == 1: # changes are handled differently",
            "                    for i in range(2, len(strip)+1):",
            "                        # only merge empty boxes. Don't bubble commit boxes.",
            "                        if strip[-i] == None:",
            "                            next = strip[-i+1]",
            "                            assert(next)",
            "                            if next:",
            "                                #if not next.event:",
            "                                if next.spacer:",
            "                                    # bubble the empty box up",
            "                                    strip[-i] = next",
            "                                    strip[-i].parms['rowspan'] += 1",
            "                                    strip[-i+1] = None",
            "                                else:",
            "                                    # we are above a commit box. Leave it",
            "                                    # be, and turn the current box into an",
            "                                    # empty one",
            "                                    strip[-i] = Box([], rowspan=1,",
            "                                                    comment=\"commit bubble\")",
            "                                    strip[-i].spacer = True",
            "                            else:",
            "                                # we are above another empty box, which",
            "                                # somehow wasn't already converted.",
            "                                # Shouldn't happen",
            "                                pass",
            "                else:",
            "                    for i in range(2, len(strip)+1):",
            "                        # strip[-i] will go from next-to-last back to first",
            "                        if strip[-i] == None:",
            "                            # bubble previous item up",
            "                            assert(strip[-i+1] != None)",
            "                            strip[-i] = strip[-i+1]",
            "                            strip[-i].parms['rowspan'] += 1",
            "                            strip[-i+1] = None",
            "                        else:",
            "                            strip[-i].parms['rowspan'] = 1",
            "        # third pass: render the HTML table",
            "        for i in range(gridlen):",
            "            data += \" <tr>\\n\";",
            "            for strip in grid:",
            "                b = strip[i]",
            "                if b:",
            "                    # convert data to a unicode string, whacking any non-ASCII characters it might contain",
            "                    s = b.td()",
            "                    if isinstance(s, unicode):",
            "                        s = s.encode(\"utf-8\", \"replace\")",
            "                    data += s",
            "                else:",
            "                    if noBubble:",
            "                        data += td([])",
            "                # Nones are left empty, rowspan should make it all fit",
            "            data += \" </tr>\\n\"",
            "        return data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "359": [
                "WaterfallHelp",
                "body"
            ],
            "587": [
                "WaterfallStatusResource",
                "body",
                "with_args"
            ]
        },
        "addLocation": []
    }
}