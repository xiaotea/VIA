{
    "sdk/identity/azure-identity/azure/identity/_credentials/azure_arc.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # ------------------------------------"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import functools"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import sys"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from typing import Any, Dict, Optional"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from azure.core.exceptions import ClientAuthenticationError"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             return ManagedIdentityClient("
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "                 _per_retry_policies=[ArcChallengeAuthPolicy()],"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "                 request_factory=functools.partial(_get_request, url),"
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                **kwargs"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+                **kwargs,"
            },
            "12": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             )"
            },
            "13": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         return None"
            },
            "14": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         raise ClientAuthenticationError("
            },
            "16": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             message=\"Did not receive a correct value from WWW-Authenticate header: {}\".format(header)"
            },
            "17": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         ) from ex"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    try:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        _validate_key_file(key_file)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    except ValueError as ex:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        raise ClientAuthenticationError(message=\"The key file path is invalid: {}\".format(ex)) from ex"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     with open(key_file, \"r\", encoding=\"utf-8\") as file:"
            },
            "25": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         try:"
            },
            "26": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             return file.read()"
            },
            "27": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             ) from error"
            },
            "28": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+def _get_key_file_path() -> str:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    \"\"\"Returns the expected path for the Azure Arc MSI key file based on the current platform."
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    Only Linux and Windows are supported."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    :return: The expected path."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    :rtype: str"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    :raises ValueError: If the current platform is not supported."
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    \"\"\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    if sys.platform.startswith(\"linux\"):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        return \"/var/opt/azcmagent/tokens\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    if sys.platform.startswith(\"win\"):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        program_data_path = os.environ.get(\"PROGRAMDATA\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        if not program_data_path:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    raise ValueError(f\"Azure Arc MSI is not supported on this platform {sys.platform}\")"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+def _validate_key_file(file_path: str) -> None:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    \"\"\"Validates that a given Azure Arc MSI file path is valid for use."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    A valid file will:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        1. Be in the expected path for the current platform."
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        2. Have a `.key` extension."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        3. Be at most 4096 bytes in size."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    :param str file_path: The path to the key file."
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    :raises ClientAuthenticationError: If the file path is invalid."
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    \"\"\""
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    if not file_path:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        raise ValueError(\"The file path must not be empty.\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    if not os.path.exists(file_path):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        raise ValueError(f\"The file path does not exist: {file_path}\")"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    expected_directory = _get_key_file_path()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+    if not os.path.dirname(file_path) == expected_directory:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        raise ValueError(f\"Unexpected file path from HIMDS service: {file_path}\")"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    if not file_path.endswith(\".key\"):"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        raise ValueError(\"The file path must have a '.key' extension.\")"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    if os.path.getsize(file_path) > 4096:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        raise ValueError(\"The file size must be less than or equal to 4096 bytes.\")"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " class ArcChallengeAuthPolicy(HTTPPolicy):"
            },
            "78": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     \"\"\"Policy for handling Azure Arc's challenge authentication\"\"\""
            },
            "79": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import functools",
            "import os",
            "from typing import Any, Dict, Optional",
            "",
            "from azure.core.exceptions import ClientAuthenticationError",
            "from azure.core.pipeline.transport import HttpRequest",
            "from azure.core.pipeline.policies import HTTPPolicy",
            "from azure.core.pipeline import PipelineRequest, PipelineResponse",
            "",
            "from .._constants import EnvironmentVariables",
            "from .._internal.managed_identity_base import ManagedIdentityBase",
            "from .._internal.managed_identity_client import ManagedIdentityClient",
            "",
            "",
            "class AzureArcCredential(ManagedIdentityBase):",
            "    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:",
            "        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)",
            "        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)",
            "        if url and imds:",
            "            return ManagedIdentityClient(",
            "                _per_retry_policies=[ArcChallengeAuthPolicy()],",
            "                request_factory=functools.partial(_get_request, url),",
            "                **kwargs",
            "            )",
            "        return None",
            "",
            "    def __enter__(self) -> \"AzureArcCredential\":",
            "        if self._client:",
            "            self._client.__enter__()",
            "        return self",
            "",
            "    def __exit__(self, *args: Any) -> None:",
            "        if self._client:",
            "            self._client.__exit__(*args)",
            "",
            "    def close(self) -> None:",
            "        self.__exit__()",
            "",
            "    def get_unavailable_message(self) -> str:",
            "        return \"Azure Arc managed identity configuration not found in environment\"",
            "",
            "",
            "def _get_request(url: str, scope: str, identity_config: Dict) -> HttpRequest:",
            "    if identity_config:",
            "        raise ClientAuthenticationError(",
            "            message=\"User assigned managed identities are not supported by Azure Arc. To authenticate with the system \"",
            "            \"assigned identity omit the client id when constructing the credential, and if authenticating with \"",
            "            \"DefaultAzureCredential ensure the AZURE_CLIENT_ID environment variable is not set.\"",
            "        )",
            "",
            "    request = HttpRequest(\"GET\", url)",
            "    request.format_parameters(dict({\"api-version\": \"2019-11-01\", \"resource\": scope}, **identity_config))",
            "    return request",
            "",
            "",
            "def _get_secret_key(response: PipelineResponse) -> str:",
            "    # expecting header containing path to secret key file",
            "    header = response.http_response.headers.get(\"WWW-Authenticate\")",
            "    if not header:",
            "        raise ClientAuthenticationError(message=\"Did not receive a value from WWW-Authenticate header\")",
            "",
            "    # expecting header with structure like 'Basic realm=<file path>'",
            "    try:",
            "        key_file = header.split(\"=\")[1]",
            "    except IndexError as ex:",
            "        raise ClientAuthenticationError(",
            "            message=\"Did not receive a correct value from WWW-Authenticate header: {}\".format(header)",
            "        ) from ex",
            "    with open(key_file, \"r\", encoding=\"utf-8\") as file:",
            "        try:",
            "            return file.read()",
            "        except Exception as error:  # pylint:disable=broad-except",
            "            # user is expected to have obtained read permission prior to this being called",
            "            raise ClientAuthenticationError(",
            "                message=\"Could not read file {} contents: {}\".format(key_file, error)",
            "            ) from error",
            "",
            "",
            "class ArcChallengeAuthPolicy(HTTPPolicy):",
            "    \"\"\"Policy for handling Azure Arc's challenge authentication\"\"\"",
            "",
            "    def send(self, request: PipelineRequest) -> PipelineResponse:",
            "        request.http_request.headers[\"Metadata\"] = \"true\"",
            "        response = self.next.send(request)",
            "",
            "        if response.http_response.status_code == 401:",
            "            secret_key = _get_secret_key(response)",
            "            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)",
            "            response = self.next.send(request)",
            "",
            "        return response"
        ],
        "afterPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import functools",
            "import os",
            "import sys",
            "from typing import Any, Dict, Optional",
            "",
            "from azure.core.exceptions import ClientAuthenticationError",
            "from azure.core.pipeline.transport import HttpRequest",
            "from azure.core.pipeline.policies import HTTPPolicy",
            "from azure.core.pipeline import PipelineRequest, PipelineResponse",
            "",
            "from .._constants import EnvironmentVariables",
            "from .._internal.managed_identity_base import ManagedIdentityBase",
            "from .._internal.managed_identity_client import ManagedIdentityClient",
            "",
            "",
            "class AzureArcCredential(ManagedIdentityBase):",
            "    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:",
            "        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)",
            "        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)",
            "        if url and imds:",
            "            return ManagedIdentityClient(",
            "                _per_retry_policies=[ArcChallengeAuthPolicy()],",
            "                request_factory=functools.partial(_get_request, url),",
            "                **kwargs,",
            "            )",
            "        return None",
            "",
            "    def __enter__(self) -> \"AzureArcCredential\":",
            "        if self._client:",
            "            self._client.__enter__()",
            "        return self",
            "",
            "    def __exit__(self, *args: Any) -> None:",
            "        if self._client:",
            "            self._client.__exit__(*args)",
            "",
            "    def close(self) -> None:",
            "        self.__exit__()",
            "",
            "    def get_unavailable_message(self) -> str:",
            "        return \"Azure Arc managed identity configuration not found in environment\"",
            "",
            "",
            "def _get_request(url: str, scope: str, identity_config: Dict) -> HttpRequest:",
            "    if identity_config:",
            "        raise ClientAuthenticationError(",
            "            message=\"User assigned managed identities are not supported by Azure Arc. To authenticate with the system \"",
            "            \"assigned identity omit the client id when constructing the credential, and if authenticating with \"",
            "            \"DefaultAzureCredential ensure the AZURE_CLIENT_ID environment variable is not set.\"",
            "        )",
            "",
            "    request = HttpRequest(\"GET\", url)",
            "    request.format_parameters(dict({\"api-version\": \"2019-11-01\", \"resource\": scope}, **identity_config))",
            "    return request",
            "",
            "",
            "def _get_secret_key(response: PipelineResponse) -> str:",
            "    # expecting header containing path to secret key file",
            "    header = response.http_response.headers.get(\"WWW-Authenticate\")",
            "    if not header:",
            "        raise ClientAuthenticationError(message=\"Did not receive a value from WWW-Authenticate header\")",
            "",
            "    # expecting header with structure like 'Basic realm=<file path>'",
            "    try:",
            "        key_file = header.split(\"=\")[1]",
            "    except IndexError as ex:",
            "        raise ClientAuthenticationError(",
            "            message=\"Did not receive a correct value from WWW-Authenticate header: {}\".format(header)",
            "        ) from ex",
            "",
            "    try:",
            "        _validate_key_file(key_file)",
            "    except ValueError as ex:",
            "        raise ClientAuthenticationError(message=\"The key file path is invalid: {}\".format(ex)) from ex",
            "",
            "    with open(key_file, \"r\", encoding=\"utf-8\") as file:",
            "        try:",
            "            return file.read()",
            "        except Exception as error:  # pylint:disable=broad-except",
            "            # user is expected to have obtained read permission prior to this being called",
            "            raise ClientAuthenticationError(",
            "                message=\"Could not read file {} contents: {}\".format(key_file, error)",
            "            ) from error",
            "",
            "",
            "def _get_key_file_path() -> str:",
            "    \"\"\"Returns the expected path for the Azure Arc MSI key file based on the current platform.",
            "",
            "    Only Linux and Windows are supported.",
            "",
            "    :return: The expected path.",
            "    :rtype: str",
            "    :raises ValueError: If the current platform is not supported.",
            "    \"\"\"",
            "    if sys.platform.startswith(\"linux\"):",
            "        return \"/var/opt/azcmagent/tokens\"",
            "    if sys.platform.startswith(\"win\"):",
            "        program_data_path = os.environ.get(\"PROGRAMDATA\")",
            "        if not program_data_path:",
            "            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")",
            "        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")",
            "    raise ValueError(f\"Azure Arc MSI is not supported on this platform {sys.platform}\")",
            "",
            "",
            "def _validate_key_file(file_path: str) -> None:",
            "    \"\"\"Validates that a given Azure Arc MSI file path is valid for use.",
            "",
            "    A valid file will:",
            "        1. Be in the expected path for the current platform.",
            "        2. Have a `.key` extension.",
            "        3. Be at most 4096 bytes in size.",
            "",
            "    :param str file_path: The path to the key file.",
            "    :raises ClientAuthenticationError: If the file path is invalid.",
            "    \"\"\"",
            "    if not file_path:",
            "        raise ValueError(\"The file path must not be empty.\")",
            "",
            "    if not os.path.exists(file_path):",
            "        raise ValueError(f\"The file path does not exist: {file_path}\")",
            "",
            "    expected_directory = _get_key_file_path()",
            "    if not os.path.dirname(file_path) == expected_directory:",
            "        raise ValueError(f\"Unexpected file path from HIMDS service: {file_path}\")",
            "",
            "    if not file_path.endswith(\".key\"):",
            "        raise ValueError(\"The file path must have a '.key' extension.\")",
            "",
            "    if os.path.getsize(file_path) > 4096:",
            "        raise ValueError(\"The file size must be less than or equal to 4096 bytes.\")",
            "",
            "",
            "class ArcChallengeAuthPolicy(HTTPPolicy):",
            "    \"\"\"Policy for handling Azure Arc's challenge authentication\"\"\"",
            "",
            "    def send(self, request: PipelineRequest) -> PipelineResponse:",
            "        request.http_request.headers[\"Metadata\"] = \"true\"",
            "        response = self.next.send(request)",
            "",
            "        if response.http_response.status_code == 401:",
            "            secret_key = _get_secret_key(response)",
            "            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)",
            "            response = self.next.send(request)",
            "",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "27": [
                "AzureArcCredential",
                "get_client"
            ]
        },
        "addLocation": []
    },
    "sdk/identity/azure-identity/azure/identity/_version.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # Copyright (c) Microsoft Corporation."
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # Licensed under the MIT License."
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # ------------------------------------"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VERSION = \"1.17.0\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+VERSION = \"1.17.0b2\""
            }
        },
        "frontPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "VERSION = \"1.17.0\""
        ],
        "afterPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "VERSION = \"1.17.0b2\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "5": [
                "VERSION"
            ]
        },
        "addLocation": []
    },
    "sdk/identity/azure-identity/setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     url=\"https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity\","
            },
            "1": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     keywords=\"azure, azure sdk\","
            },
            "2": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     classifiers=["
            },
            "3": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"Development Status :: 5 - Production/Stable\","
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        \"Development Status :: 4 - Beta\","
            },
            "5": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         \"Programming Language :: Python\","
            },
            "6": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         \"Programming Language :: Python :: 3 :: Only\","
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         \"Programming Language :: Python :: 3\","
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "",
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import re",
            "import os.path",
            "from io import open",
            "from setuptools import find_packages, setup",
            "",
            "PACKAGE_NAME = \"azure-identity\"",
            "PACKAGE_PPRINT_NAME = \"Identity\"",
            "",
            "package_folder_path = PACKAGE_NAME.replace(\"-\", \"/\")",
            "namespace_name = PACKAGE_NAME.replace(\"-\", \".\")",
            "",
            "with open(os.path.join(package_folder_path, \"_version.py\"), \"r\") as fd:",
            "    VERSION = re.search(r'^VERSION\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', fd.read(), re.MULTILINE).group(1)  # type: ignore",
            "if not VERSION:",
            "    raise RuntimeError(\"Cannot find version information\")",
            "",
            "with open(\"README.md\", encoding=\"utf-8\") as f:",
            "    README = f.read()",
            "with open(\"CHANGELOG.md\", encoding=\"utf-8\") as f:",
            "    CHANGELOG = f.read()",
            "",
            "setup(",
            "    name=PACKAGE_NAME,",
            "    version=VERSION,",
            "    include_package_data=True,",
            "    description=\"Microsoft Azure {} Library for Python\".format(PACKAGE_PPRINT_NAME),",
            "    long_description=README + \"\\n\\n\" + CHANGELOG,",
            "    long_description_content_type=\"text/markdown\",",
            "    license=\"MIT License\",",
            "    author=\"Microsoft Corporation\",",
            "    author_email=\"azpysdkhelp@microsoft.com\",",
            "    url=\"https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity\",",
            "    keywords=\"azure, azure sdk\",",
            "    classifiers=[",
            "        \"Development Status :: 5 - Production/Stable\",",
            "        \"Programming Language :: Python\",",
            "        \"Programming Language :: Python :: 3 :: Only\",",
            "        \"Programming Language :: Python :: 3\",",
            "        \"Programming Language :: Python :: 3.8\",",
            "        \"Programming Language :: Python :: 3.9\",",
            "        \"Programming Language :: Python :: 3.10\",",
            "        \"Programming Language :: Python :: 3.11\",",
            "        \"Programming Language :: Python :: 3.12\",",
            "        \"License :: OSI Approved :: MIT License\",",
            "    ],",
            "    zip_safe=False,",
            "    packages=find_packages(",
            "        exclude=[",
            "            \"tests\",",
            "            # Exclude packages that will be covered by PEP420 or nspkg",
            "            \"azure\",",
            "        ]",
            "    ),",
            "    python_requires=\">=3.8\",",
            "    install_requires=[",
            "        \"azure-core>=1.23.0\",",
            "        \"cryptography>=2.5\",",
            "        \"msal>=1.24.0\",",
            "        \"msal-extensions>=0.3.0\",",
            "        \"typing-extensions>=4.0.0\",",
            "    ],",
            ")"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "",
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import re",
            "import os.path",
            "from io import open",
            "from setuptools import find_packages, setup",
            "",
            "PACKAGE_NAME = \"azure-identity\"",
            "PACKAGE_PPRINT_NAME = \"Identity\"",
            "",
            "package_folder_path = PACKAGE_NAME.replace(\"-\", \"/\")",
            "namespace_name = PACKAGE_NAME.replace(\"-\", \".\")",
            "",
            "with open(os.path.join(package_folder_path, \"_version.py\"), \"r\") as fd:",
            "    VERSION = re.search(r'^VERSION\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', fd.read(), re.MULTILINE).group(1)  # type: ignore",
            "if not VERSION:",
            "    raise RuntimeError(\"Cannot find version information\")",
            "",
            "with open(\"README.md\", encoding=\"utf-8\") as f:",
            "    README = f.read()",
            "with open(\"CHANGELOG.md\", encoding=\"utf-8\") as f:",
            "    CHANGELOG = f.read()",
            "",
            "setup(",
            "    name=PACKAGE_NAME,",
            "    version=VERSION,",
            "    include_package_data=True,",
            "    description=\"Microsoft Azure {} Library for Python\".format(PACKAGE_PPRINT_NAME),",
            "    long_description=README + \"\\n\\n\" + CHANGELOG,",
            "    long_description_content_type=\"text/markdown\",",
            "    license=\"MIT License\",",
            "    author=\"Microsoft Corporation\",",
            "    author_email=\"azpysdkhelp@microsoft.com\",",
            "    url=\"https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/identity/azure-identity\",",
            "    keywords=\"azure, azure sdk\",",
            "    classifiers=[",
            "        \"Development Status :: 4 - Beta\",",
            "        \"Programming Language :: Python\",",
            "        \"Programming Language :: Python :: 3 :: Only\",",
            "        \"Programming Language :: Python :: 3\",",
            "        \"Programming Language :: Python :: 3.8\",",
            "        \"Programming Language :: Python :: 3.9\",",
            "        \"Programming Language :: Python :: 3.10\",",
            "        \"Programming Language :: Python :: 3.11\",",
            "        \"Programming Language :: Python :: 3.12\",",
            "        \"License :: OSI Approved :: MIT License\",",
            "    ],",
            "    zip_safe=False,",
            "    packages=find_packages(",
            "        exclude=[",
            "            \"tests\",",
            "            # Exclude packages that will be covered by PEP420 or nspkg",
            "            \"azure\",",
            "        ]",
            "    ),",
            "    python_requires=\">=3.8\",",
            "    install_requires=[",
            "        \"azure-core>=1.23.0\",",
            "        \"cryptography>=2.5\",",
            "        \"msal>=1.24.0\",",
            "        \"msal-extensions>=0.3.0\",",
            "        \"typing-extensions>=4.0.0\",",
            "    ],",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "41": []
        },
        "addLocation": []
    },
    "sdk/identity/azure-identity/tests/test_managed_identity.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # Licensed under the MIT License."
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # ------------------------------------"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import sys"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import time"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 883,
                "afterPatchRowNumber": 884,
                "PatchRowcode": "         \"os.environ\","
            },
            "8": {
                "beforePatchRowNumber": 884,
                "afterPatchRowNumber": 885,
                "PatchRowcode": "         {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},"
            },
            "9": {
                "beforePatchRowNumber": 885,
                "afterPatchRowNumber": 886,
                "PatchRowcode": "     ):"
            },
            "10": {
                "beforePatchRowNumber": 886,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        token = ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "11": {
                "beforePatchRowNumber": 887,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert token.token == access_token"
            },
            "12": {
                "beforePatchRowNumber": 888,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert token.expires_on == expires_on"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 888,
                "PatchRowcode": "+            token = ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 889,
                "PatchRowcode": "+            assert token.token == access_token"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 890,
                "PatchRowcode": "+            assert token.expires_on == expires_on"
            },
            "17": {
                "beforePatchRowNumber": 889,
                "afterPatchRowNumber": 891,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 890,
                "afterPatchRowNumber": 892,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 891,
                "afterPatchRowNumber": 893,
                "PatchRowcode": " def test_azure_arc_tenant_id(tmpdir):"
            },
            "20": {
                "beforePatchRowNumber": 936,
                "afterPatchRowNumber": 938,
                "PatchRowcode": "         \"os.environ\","
            },
            "21": {
                "beforePatchRowNumber": 937,
                "afterPatchRowNumber": 939,
                "PatchRowcode": "         {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},"
            },
            "22": {
                "beforePatchRowNumber": 938,
                "afterPatchRowNumber": 940,
                "PatchRowcode": "     ):"
            },
            "23": {
                "beforePatchRowNumber": 939,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")"
            },
            "24": {
                "beforePatchRowNumber": 940,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert token.token == access_token"
            },
            "25": {
                "beforePatchRowNumber": 941,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert token.expires_on == expires_on"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 941,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 942,
                "PatchRowcode": "+            token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 943,
                "PatchRowcode": "+            assert token.token == access_token"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 944,
                "PatchRowcode": "+            assert token.expires_on == expires_on"
            },
            "30": {
                "beforePatchRowNumber": 942,
                "afterPatchRowNumber": 945,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 943,
                "afterPatchRowNumber": 946,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 944,
                "afterPatchRowNumber": 947,
                "PatchRowcode": " def test_azure_arc_client_id():"
            },
            "33": {
                "beforePatchRowNumber": 950,
                "afterPatchRowNumber": 953,
                "PatchRowcode": "             EnvironmentVariables.IMDS_ENDPOINT: \"http://localhost:42\","
            },
            "34": {
                "beforePatchRowNumber": 951,
                "afterPatchRowNumber": 954,
                "PatchRowcode": "         },"
            },
            "35": {
                "beforePatchRowNumber": 952,
                "afterPatchRowNumber": 955,
                "PatchRowcode": "     ):"
            },
            "36": {
                "beforePatchRowNumber": 953,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        credential = ManagedIdentityCredential(client_id=\"some-guid\")"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 956,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 957,
                "PatchRowcode": "+            credential = ManagedIdentityCredential(client_id=\"some-guid\")"
            },
            "39": {
                "beforePatchRowNumber": 954,
                "afterPatchRowNumber": 958,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 955,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    with pytest.raises(ClientAuthenticationError):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 959,
                "PatchRowcode": "+    with pytest.raises(ClientAuthenticationError) as ex:"
            },
            "42": {
                "beforePatchRowNumber": 956,
                "afterPatchRowNumber": 960,
                "PatchRowcode": "         credential.get_token(\"scope\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 961,
                "PatchRowcode": "+    assert \"not supported\" in str(ex.value)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 962,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 963,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 964,
                "PatchRowcode": "+def test_azure_arc_key_too_large(tmp_path):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 965,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 966,
                "PatchRowcode": "+    api_version = \"2019-11-01\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 967,
                "PatchRowcode": "+    identity_endpoint = \"http://localhost:42/token\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 968,
                "PatchRowcode": "+    imds_endpoint = \"http://localhost:42\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 969,
                "PatchRowcode": "+    scope = \"scope\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 970,
                "PatchRowcode": "+    secret_key = \"X\" * 4097"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 971,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 972,
                "PatchRowcode": "+    key_file = tmp_path / \"key_file.key\""
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 973,
                "PatchRowcode": "+    key_file.write_text(secret_key)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 974,
                "PatchRowcode": "+    assert key_file.read_text() == secret_key"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 975,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 976,
                "PatchRowcode": "+    transport = validating_transport("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 977,
                "PatchRowcode": "+        requests=["
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 978,
                "PatchRowcode": "+            Request("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 979,
                "PatchRowcode": "+                base_url=identity_endpoint,"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 980,
                "PatchRowcode": "+                method=\"GET\","
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 981,
                "PatchRowcode": "+                required_headers={\"Metadata\": \"true\"},"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 982,
                "PatchRowcode": "+                required_params={\"api-version\": api_version, \"resource\": scope},"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 983,
                "PatchRowcode": "+            ),"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 984,
                "PatchRowcode": "+        ],"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 985,
                "PatchRowcode": "+        responses=["
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 986,
                "PatchRowcode": "+            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 987,
                "PatchRowcode": "+        ],"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 988,
                "PatchRowcode": "+    )"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 989,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 990,
                "PatchRowcode": "+    with mock.patch("
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 991,
                "PatchRowcode": "+        \"os.environ\","
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 992,
                "PatchRowcode": "+        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 993,
                "PatchRowcode": "+    ):"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 994,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: str(tmp_path)):"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 995,
                "PatchRowcode": "+            with pytest.raises(ClientAuthenticationError) as ex:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 996,
                "PatchRowcode": "+                ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 997,
                "PatchRowcode": "+            assert \"file size\" in str(ex.value)"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 998,
                "PatchRowcode": "+"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 999,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1000,
                "PatchRowcode": "+def test_azure_arc_key_not_exist(tmp_path):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1001,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1002,
                "PatchRowcode": "+    api_version = \"2019-11-01\""
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1003,
                "PatchRowcode": "+    identity_endpoint = \"http://localhost:42/token\""
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1004,
                "PatchRowcode": "+    imds_endpoint = \"http://localhost:42\""
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1005,
                "PatchRowcode": "+    scope = \"scope\""
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1006,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1007,
                "PatchRowcode": "+    transport = validating_transport("
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1008,
                "PatchRowcode": "+        requests=["
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1009,
                "PatchRowcode": "+            Request("
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1010,
                "PatchRowcode": "+                base_url=identity_endpoint,"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1011,
                "PatchRowcode": "+                method=\"GET\","
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1012,
                "PatchRowcode": "+                required_headers={\"Metadata\": \"true\"},"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1013,
                "PatchRowcode": "+                required_params={\"api-version\": api_version, \"resource\": scope},"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1014,
                "PatchRowcode": "+            ),"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1015,
                "PatchRowcode": "+        ],"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1016,
                "PatchRowcode": "+        responses=["
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1017,
                "PatchRowcode": "+            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm=/path/to/key_file\"}),"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1018,
                "PatchRowcode": "+        ],"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1019,
                "PatchRowcode": "+    )"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1020,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1021,
                "PatchRowcode": "+    with mock.patch("
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1022,
                "PatchRowcode": "+        \"os.environ\","
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1023,
                "PatchRowcode": "+        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1024,
                "PatchRowcode": "+    ):"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1025,
                "PatchRowcode": "+        with pytest.raises(ClientAuthenticationError) as ex:"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1026,
                "PatchRowcode": "+            ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1027,
                "PatchRowcode": "+        assert \"not exist\" in str(ex.value)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1028,
                "PatchRowcode": "+"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1029,
                "PatchRowcode": "+"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1030,
                "PatchRowcode": "+def test_azure_arc_key_invalid(tmp_path):"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1031,
                "PatchRowcode": "+"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1032,
                "PatchRowcode": "+    api_version = \"2019-11-01\""
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1033,
                "PatchRowcode": "+    identity_endpoint = \"http://localhost:42/token\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1034,
                "PatchRowcode": "+    imds_endpoint = \"http://localhost:42\""
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1035,
                "PatchRowcode": "+    scope = \"scope\""
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1036,
                "PatchRowcode": "+    key_file = tmp_path / \"key_file.txt\""
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1037,
                "PatchRowcode": "+    key_file.write_text(\"secret\")"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1038,
                "PatchRowcode": "+"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1039,
                "PatchRowcode": "+    transport = validating_transport("
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1040,
                "PatchRowcode": "+        requests=["
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1041,
                "PatchRowcode": "+            Request("
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1042,
                "PatchRowcode": "+                base_url=identity_endpoint,"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1043,
                "PatchRowcode": "+                method=\"GET\","
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1044,
                "PatchRowcode": "+                required_headers={\"Metadata\": \"true\"},"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1045,
                "PatchRowcode": "+                required_params={\"api-version\": api_version, \"resource\": scope},"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1046,
                "PatchRowcode": "+            ),"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1047,
                "PatchRowcode": "+            Request("
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1048,
                "PatchRowcode": "+                base_url=identity_endpoint,"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1049,
                "PatchRowcode": "+                method=\"GET\","
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1050,
                "PatchRowcode": "+                required_headers={\"Metadata\": \"true\"},"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1051,
                "PatchRowcode": "+                required_params={\"api-version\": api_version, \"resource\": scope},"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1052,
                "PatchRowcode": "+            ),"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1053,
                "PatchRowcode": "+        ],"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1054,
                "PatchRowcode": "+        responses=["
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "+            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1056,
                "PatchRowcode": "+            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1057,
                "PatchRowcode": "+        ],"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1058,
                "PatchRowcode": "+    )"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1059,
                "PatchRowcode": "+"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1060,
                "PatchRowcode": "+    with mock.patch("
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1061,
                "PatchRowcode": "+        \"os.environ\","
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1062,
                "PatchRowcode": "+        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1063,
                "PatchRowcode": "+    ):"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1064,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: \"/foo\"):"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1065,
                "PatchRowcode": "+            with pytest.raises(ClientAuthenticationError) as ex:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1066,
                "PatchRowcode": "+                ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1067,
                "PatchRowcode": "+            assert \"Unexpected file path\" in str(ex.value)"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1068,
                "PatchRowcode": "+"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1069,
                "PatchRowcode": "+        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: str(tmp_path)):"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1070,
                "PatchRowcode": "+            with pytest.raises(ClientAuthenticationError) as ex:"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1071,
                "PatchRowcode": "+                ManagedIdentityCredential(transport=transport).get_token(scope)"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1072,
                "PatchRowcode": "+            assert \"extension\" in str(ex.value)"
            },
            "155": {
                "beforePatchRowNumber": 957,
                "afterPatchRowNumber": 1073,
                "PatchRowcode": " "
            },
            "156": {
                "beforePatchRowNumber": 958,
                "afterPatchRowNumber": 1074,
                "PatchRowcode": " "
            },
            "157": {
                "beforePatchRowNumber": 959,
                "afterPatchRowNumber": 1075,
                "PatchRowcode": " def test_token_exchange(tmpdir):"
            }
        },
        "frontPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import os",
            "import time",
            "",
            "try:",
            "    from unittest import mock",
            "except ImportError:  # python < 3.3",
            "    import mock  # type: ignore",
            "",
            "from azure.core.credentials import AccessToken",
            "from azure.core.exceptions import ClientAuthenticationError",
            "from azure.identity import ManagedIdentityCredential",
            "from azure.identity._constants import EnvironmentVariables",
            "from azure.identity._credentials.imds import IMDS_AUTHORITY, IMDS_TOKEN_PATH",
            "from azure.identity._internal.user_agent import USER_AGENT",
            "import pytest",
            "",
            "from helpers import build_aad_response, validating_transport, mock_response, Request",
            "",
            "MANAGED_IDENTITY_ENVIRON = \"azure.identity._credentials.managed_identity.os.environ\"",
            "ALL_ENVIRONMENTS = (",
            "    {EnvironmentVariables.IDENTITY_ENDPOINT: \"...\", EnvironmentVariables.IDENTITY_HEADER: \"...\"},  # App Service",
            "    {EnvironmentVariables.MSI_ENDPOINT: \"...\"},  # Cloud Shell",
            "    {  # Service Fabric",
            "        EnvironmentVariables.IDENTITY_ENDPOINT: \"...\",",
            "        EnvironmentVariables.IDENTITY_HEADER: \"...\",",
            "        EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: \"...\",",
            "    },",
            "    {EnvironmentVariables.IDENTITY_ENDPOINT: \"...\", EnvironmentVariables.IMDS_ENDPOINT: \"...\"},  # Arc",
            "    {  # token exchange",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: \"https://localhost\",",
            "        EnvironmentVariables.AZURE_CLIENT_ID: \"...\",",
            "        EnvironmentVariables.AZURE_TENANT_ID: \"...\",",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: __file__,",
            "    },",
            "    {},  # IMDS",
            "    {EnvironmentVariables.MSI_ENDPOINT: \"...\", EnvironmentVariables.MSI_SECRET: \"...\"},  # Azure ML",
            ")",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_close(environ):",
            "    transport = mock.MagicMock()",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "    assert transport.__exit__.call_count == 0",
            "",
            "    credential.close()",
            "    assert transport.__exit__.call_count == 1",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_context_manager(environ):",
            "    transport = mock.MagicMock()",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "",
            "    with credential:",
            "        assert transport.__enter__.call_count == 1",
            "        assert transport.__exit__.call_count == 0",
            "",
            "    assert transport.__enter__.call_count == 1",
            "    assert transport.__exit__.call_count == 1",
            "",
            "",
            "def test_close_incomplete_configuration():",
            "    ManagedIdentityCredential().close()",
            "",
            "",
            "def test_context_manager_incomplete_configuration():",
            "    with ManagedIdentityCredential():",
            "        pass",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_custom_hooks(environ):",
            "    \"\"\"The credential's pipeline should include azure-core's CustomHookPolicy\"\"\"",
            "",
            "    scope = \"scope\"",
            "    expected_token = \"***\"",
            "    request_hook = mock.Mock()",
            "    response_hook = mock.Mock()",
            "    now = int(time.time())",
            "    expected_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": expected_token,",
            "            \"expires_in\": 3600,",
            "            \"expires_on\": now + 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"not_before\": now,",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(requests=[Request()] * 2, responses=[expected_response] * 2)",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, environ, clear=True):",
            "        credential = ManagedIdentityCredential(",
            "            transport=transport, raw_request_hook=request_hook, raw_response_hook=response_hook",
            "        )",
            "    credential.get_token(scope)",
            "",
            "    assert request_hook.call_count == 1",
            "    assert response_hook.call_count == 1",
            "    args, kwargs = response_hook.call_args",
            "    pipeline_response = args[0]",
            "    assert pipeline_response.http_response == expected_response",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_tenant_id(environ):",
            "    scope = \"scope\"",
            "    expected_token = \"***\"",
            "    request_hook = mock.Mock()",
            "    response_hook = mock.Mock()",
            "    now = int(time.time())",
            "    expected_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": expected_token,",
            "            \"expires_in\": 3600,",
            "            \"expires_on\": now + 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"not_before\": now,",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(requests=[Request()] * 2, responses=[expected_response] * 2)",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, environ, clear=True):",
            "        credential = ManagedIdentityCredential(",
            "            transport=transport, raw_request_hook=request_hook, raw_response_hook=response_hook",
            "        )",
            "    credential.get_token(scope)",
            "",
            "    assert request_hook.call_count == 1",
            "    assert response_hook.call_count == 1",
            "    args, kwargs = response_hook.call_args",
            "    pipeline_response = args[0]",
            "    assert pipeline_response.http_response == expected_response",
            "",
            "",
            "def test_cloud_shell():",
            "    \"\"\"Cloud Shell environment: only MSI_ENDPOINT set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    with mock.patch(\"os.environ\", {EnvironmentVariables.MSI_ENDPOINT: endpoint}):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "",
            "",
            "def test_cloud_shell_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    with mock.patch(\"os.environ\", {EnvironmentVariables.MSI_ENDPOINT: endpoint}):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token == expected_token",
            "",
            "",
            "def test_azure_ml():",
            "    \"\"\"Azure ML: MSI_ENDPOINT, MSI_SECRET set (like App Service 2017-09-01 but with a different response format)\"\"\"",
            "",
            "    expected_token = AccessToken(\"****\", int(time.time()) + 3600)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    client_id = \"client\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            ),",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope, \"clientid\": client_id},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token.token,",
            "                    \"expires_in\": 3600,",
            "                    \"expires_on\": expected_token.expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.MSI_ENDPOINT: url, EnvironmentVariables.MSI_SECRET: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "        token = ManagedIdentityCredential(transport=transport, client_id=client_id).get_token(scope)",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "",
            "def test_azure_ml_tenant_id():",
            "    expected_token = AccessToken(\"****\", int(time.time()) + 3600)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    client_id = \"client\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            ),",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope, \"clientid\": client_id},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token.token,",
            "                    \"expires_in\": 3600,",
            "                    \"expires_on\": expected_token.expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.MSI_ENDPOINT: url, EnvironmentVariables.MSI_SECRET: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "",
            "def test_cloud_shell_user_assigned_identity():",
            "    \"\"\"Cloud Shell environment: only MSI_ENDPOINT set\"\"\"",
            "",
            "    expected_token = \"****\"",
            "    expires_on = 42",
            "    client_id = \"some-guid\"",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    param_name, param_value = \"foo\", \"bar\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope, param_name: param_value},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, {EnvironmentVariables.MSI_ENDPOINT: endpoint}, clear=True):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        credential = ManagedIdentityCredential(transport=transport, identity_config={param_name: param_value})",
            "        token = credential.get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2017_09_01():",
            "    \"\"\"When the environment for 2019-08-01 is not configured, 2017-09-01 should be used.\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            )",
            "        ]",
            "        * 2,",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": \"01/01/1970 00:00:{} +00:00\".format(expires_on),  # linux format",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": \"1/1/1970 12:00:{} AM +00:00\".format(expires_on),  # windows format",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.MSI_ENDPOINT: url,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_prefers_app_service_2019_08_01():",
            "    \"\"\"When the environment is configured for both App Service versions, the credential should prefer the most recent\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2019-08-01\", \"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": str(expires_on),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    environ = {",
            "        EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "        EnvironmentVariables.IDENTITY_HEADER: secret,",
            "        EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "        EnvironmentVariables.MSI_SECRET: secret,",
            "    }",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "    assert token.token == access_token",
            "    assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2019_08_01():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    new_endpoint = \"http://localhost:42/new-token\"",
            "    secret = \"expected-secret\"",
            "    new_secret = \"new-expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(new_endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"X-IDENTITY-HEADER\"] == new_secret",
            "        assert request.headers[\"User-Agent\"] == USER_AGENT",
            "        assert request.query[\"api-version\"] == \"2019-08-01\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    # when configuration for both API versions is present, the credential should prefer the most recent",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: new_endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: new_secret,",
            "            EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope)",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2019_08_01_tenant_id():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    new_endpoint = \"http://localhost:42/new-token\"",
            "    secret = \"expected-secret\"",
            "    new_secret = \"new-expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(new_endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"X-IDENTITY-HEADER\"] == new_secret",
            "        assert request.headers[\"User-Agent\"] == USER_AGENT",
            "        assert request.query[\"api-version\"] == \"2019-08-01\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    # when configuration for both API versions is present, the credential should prefer the most recent",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: new_endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: new_secret,",
            "            EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_user_assigned_identity():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    expected_token = \"****\"",
            "    expires_on = 42",
            "    client_id = \"some-guid\"",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    param_name, param_value = \"foo\", \"bar\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2019-08-01\", \"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={",
            "                    \"api-version\": \"2019-08-01\",",
            "                    \"client_id\": client_id,",
            "                    \"resource\": scope,",
            "                    param_name: param_value,",
            "                },",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: endpoint, EnvironmentVariables.IDENTITY_HEADER: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        credential = ManagedIdentityCredential(",
            "            client_id=client_id, transport=transport, identity_config={param_name: param_value}",
            "        )",
            "        token = credential.get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_imds():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=IMDS_AUTHORITY + IMDS_TOKEN_PATH,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "    assert token == expected_token",
            "",
            "",
            "def test_imds_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=IMDS_AUTHORITY + IMDS_TOKEN_PATH,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "    assert token == expected_token",
            "",
            "",
            "def test_client_id_none():",
            "    \"\"\"the credential should ignore client_id=None\"\"\"",
            "",
            "    expected_access_token = \"****\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert \"client_id\" not in request.query",
            "        if request.data:",
            "            assert \"client_id\" not in request.body  # Cloud Shell",
            "        return mock_response(",
            "            json_payload=(build_aad_response(access_token=expected_access_token, expires_on=\"42\", resource=scope))",
            "        )",
            "",
            "    # IMDS",
            "    credential = ManagedIdentityCredential(client_id=None, transport=mock.Mock(send=send))",
            "    token = credential.get_token(scope)",
            "    assert token.token == expected_access_token",
            "",
            "    # Cloud Shell",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON, {EnvironmentVariables.MSI_ENDPOINT: \"https://localhost\"}, clear=True",
            "    ):",
            "        credential = ManagedIdentityCredential(client_id=None, transport=mock.Mock(send=send))",
            "        token = credential.get_token(scope)",
            "    assert token.token == expected_access_token",
            "",
            "",
            "def test_imds_user_assigned_identity():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = IMDS_AUTHORITY + IMDS_TOKEN_PATH",
            "    scope = \"scope\"",
            "    client_id = \"some-guid\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"client_id\": client_id,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "    assert token == expected_token",
            "",
            "",
            "def test_service_fabric():",
            "    \"\"\"Service Fabric 2019-07-01-preview\"\"\"",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    thumbprint = \"SHA1HEX\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"Secret\"] == secret",
            "        assert request.query[\"api-version\"] == \"2019-07-01-preview\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: secret,",
            "            EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: thumbprint,",
            "        },",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope)",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_service_fabric_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    thumbprint = \"SHA1HEX\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"Secret\"] == secret",
            "        assert request.query[\"api-version\"] == \"2019-07-01-preview\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: secret,",
            "            EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: thumbprint,",
            "        },",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc(tmpdir):",
            "    \"\"\"Azure Arc 2019-11-01\"\"\"",
            "    access_token = \"****\"",
            "    api_version = \"2019-11-01\"",
            "    expires_on = 42",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    secret_key = \"XXXX\"",
            "",
            "    key_file = tmpdir.mkdir(\"key\").join(\"key_file.key\")",
            "    key_file.write(secret_key)",
            "    assert key_file.read() == secret_key",
            "    key_path = os.path.join(key_file.dirname, key_file.basename)",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"Authorization\": \"Basic {}\".format(secret_key)},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            # first response gives path to authentication key",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_path)}),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc_tenant_id(tmpdir):",
            "    \"\"\"Azure Arc 2019-11-01\"\"\"",
            "    access_token = \"****\"",
            "    api_version = \"2019-11-01\"",
            "    expires_on = 42",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    secret_key = \"XXXX\"",
            "",
            "    key_file = tmpdir.mkdir(\"key\").join(\"key_file.key\")",
            "    key_file.write(secret_key)",
            "    assert key_file.read() == secret_key",
            "    key_path = os.path.join(key_file.dirname, key_file.basename)",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"Authorization\": \"Basic {}\".format(secret_key)},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            # first response gives path to authentication key",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_path)}),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc_client_id():",
            "    \"\"\"Azure Arc doesn't support user-assigned managed identity\"\"\"",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: \"http://localhost:42/token\",",
            "            EnvironmentVariables.IMDS_ENDPOINT: \"http://localhost:42\",",
            "        },",
            "    ):",
            "        credential = ManagedIdentityCredential(client_id=\"some-guid\")",
            "",
            "    with pytest.raises(ClientAuthenticationError):",
            "        credential.get_token(\"scope\")",
            "",
            "",
            "def test_token_exchange(tmpdir):",
            "    exchange_token = \"exchange-token\"",
            "    token_file = tmpdir.join(\"token\")",
            "    token_file.write(exchange_token)",
            "    access_token = \"***\"",
            "    authority = \"https://localhost\"",
            "    default_client_id = \"default_client_id\"",
            "    tenant = \"tenant_id\"",
            "    scope = \"scope\"",
            "",
            "    success_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": access_token,",
            "            \"expires_in\": 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"expires_on\": int(time.time()) + 3600,",
            "            \"not_before\": int(time.time()),",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": default_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    mock_environ = {",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "        EnvironmentVariables.AZURE_CLIENT_ID: default_client_id,",
            "        EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "    }",
            "    # credential should default to AZURE_CLIENT_ID",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "        token = credential.get_token(scope)",
            "        assert token.token == access_token",
            "",
            "    # client_id kwarg should override AZURE_CLIENT_ID",
            "    nondefault_client_id = \"non\" + default_client_id",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": nondefault_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(client_id=nondefault_client_id, transport=transport)",
            "        token = credential.get_token(scope)",
            "    assert token.token == access_token",
            "",
            "    # AZURE_CLIENT_ID may not have a value, in which case client_id is required",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": nondefault_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "            EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "            EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "        },",
            "        clear=True,",
            "    ):",
            "        with pytest.raises(ValueError):",
            "            ManagedIdentityCredential()",
            "",
            "        credential = ManagedIdentityCredential(client_id=nondefault_client_id, transport=transport)",
            "        token = credential.get_token(scope)",
            "    assert token.token == access_token",
            "",
            "",
            "def test_token_exchange_tenant_id(tmpdir):",
            "    exchange_token = \"exchange-token\"",
            "    token_file = tmpdir.join(\"token\")",
            "    token_file.write(exchange_token)",
            "    access_token = \"***\"",
            "    authority = \"https://localhost\"",
            "    default_client_id = \"default_client_id\"",
            "    tenant = \"tenant_id\"",
            "    scope = \"scope\"",
            "",
            "    success_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": access_token,",
            "            \"expires_in\": 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"expires_on\": int(time.time()) + 3600,",
            "            \"not_before\": int(time.time()),",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": default_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    mock_environ = {",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "        EnvironmentVariables.AZURE_CLIENT_ID: default_client_id,",
            "        EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "    }",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "        token = credential.get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token"
        ],
        "afterPatchFile": [
            "# ------------------------------------",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "# ------------------------------------",
            "import os",
            "import sys",
            "import time",
            "",
            "try:",
            "    from unittest import mock",
            "except ImportError:  # python < 3.3",
            "    import mock  # type: ignore",
            "",
            "from azure.core.credentials import AccessToken",
            "from azure.core.exceptions import ClientAuthenticationError",
            "from azure.identity import ManagedIdentityCredential",
            "from azure.identity._constants import EnvironmentVariables",
            "from azure.identity._credentials.imds import IMDS_AUTHORITY, IMDS_TOKEN_PATH",
            "from azure.identity._internal.user_agent import USER_AGENT",
            "import pytest",
            "",
            "from helpers import build_aad_response, validating_transport, mock_response, Request",
            "",
            "MANAGED_IDENTITY_ENVIRON = \"azure.identity._credentials.managed_identity.os.environ\"",
            "ALL_ENVIRONMENTS = (",
            "    {EnvironmentVariables.IDENTITY_ENDPOINT: \"...\", EnvironmentVariables.IDENTITY_HEADER: \"...\"},  # App Service",
            "    {EnvironmentVariables.MSI_ENDPOINT: \"...\"},  # Cloud Shell",
            "    {  # Service Fabric",
            "        EnvironmentVariables.IDENTITY_ENDPOINT: \"...\",",
            "        EnvironmentVariables.IDENTITY_HEADER: \"...\",",
            "        EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: \"...\",",
            "    },",
            "    {EnvironmentVariables.IDENTITY_ENDPOINT: \"...\", EnvironmentVariables.IMDS_ENDPOINT: \"...\"},  # Arc",
            "    {  # token exchange",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: \"https://localhost\",",
            "        EnvironmentVariables.AZURE_CLIENT_ID: \"...\",",
            "        EnvironmentVariables.AZURE_TENANT_ID: \"...\",",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: __file__,",
            "    },",
            "    {},  # IMDS",
            "    {EnvironmentVariables.MSI_ENDPOINT: \"...\", EnvironmentVariables.MSI_SECRET: \"...\"},  # Azure ML",
            ")",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_close(environ):",
            "    transport = mock.MagicMock()",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "    assert transport.__exit__.call_count == 0",
            "",
            "    credential.close()",
            "    assert transport.__exit__.call_count == 1",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_context_manager(environ):",
            "    transport = mock.MagicMock()",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "",
            "    with credential:",
            "        assert transport.__enter__.call_count == 1",
            "        assert transport.__exit__.call_count == 0",
            "",
            "    assert transport.__enter__.call_count == 1",
            "    assert transport.__exit__.call_count == 1",
            "",
            "",
            "def test_close_incomplete_configuration():",
            "    ManagedIdentityCredential().close()",
            "",
            "",
            "def test_context_manager_incomplete_configuration():",
            "    with ManagedIdentityCredential():",
            "        pass",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_custom_hooks(environ):",
            "    \"\"\"The credential's pipeline should include azure-core's CustomHookPolicy\"\"\"",
            "",
            "    scope = \"scope\"",
            "    expected_token = \"***\"",
            "    request_hook = mock.Mock()",
            "    response_hook = mock.Mock()",
            "    now = int(time.time())",
            "    expected_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": expected_token,",
            "            \"expires_in\": 3600,",
            "            \"expires_on\": now + 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"not_before\": now,",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(requests=[Request()] * 2, responses=[expected_response] * 2)",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, environ, clear=True):",
            "        credential = ManagedIdentityCredential(",
            "            transport=transport, raw_request_hook=request_hook, raw_response_hook=response_hook",
            "        )",
            "    credential.get_token(scope)",
            "",
            "    assert request_hook.call_count == 1",
            "    assert response_hook.call_count == 1",
            "    args, kwargs = response_hook.call_args",
            "    pipeline_response = args[0]",
            "    assert pipeline_response.http_response == expected_response",
            "",
            "",
            "@pytest.mark.parametrize(\"environ\", ALL_ENVIRONMENTS)",
            "def test_tenant_id(environ):",
            "    scope = \"scope\"",
            "    expected_token = \"***\"",
            "    request_hook = mock.Mock()",
            "    response_hook = mock.Mock()",
            "    now = int(time.time())",
            "    expected_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": expected_token,",
            "            \"expires_in\": 3600,",
            "            \"expires_on\": now + 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"not_before\": now,",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(requests=[Request()] * 2, responses=[expected_response] * 2)",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, environ, clear=True):",
            "        credential = ManagedIdentityCredential(",
            "            transport=transport, raw_request_hook=request_hook, raw_response_hook=response_hook",
            "        )",
            "    credential.get_token(scope)",
            "",
            "    assert request_hook.call_count == 1",
            "    assert response_hook.call_count == 1",
            "    args, kwargs = response_hook.call_args",
            "    pipeline_response = args[0]",
            "    assert pipeline_response.http_response == expected_response",
            "",
            "",
            "def test_cloud_shell():",
            "    \"\"\"Cloud Shell environment: only MSI_ENDPOINT set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    with mock.patch(\"os.environ\", {EnvironmentVariables.MSI_ENDPOINT: endpoint}):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "",
            "",
            "def test_cloud_shell_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    with mock.patch(\"os.environ\", {EnvironmentVariables.MSI_ENDPOINT: endpoint}):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token == expected_token",
            "",
            "",
            "def test_azure_ml():",
            "    \"\"\"Azure ML: MSI_ENDPOINT, MSI_SECRET set (like App Service 2017-09-01 but with a different response format)\"\"\"",
            "",
            "    expected_token = AccessToken(\"****\", int(time.time()) + 3600)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    client_id = \"client\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            ),",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope, \"clientid\": client_id},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token.token,",
            "                    \"expires_in\": 3600,",
            "                    \"expires_on\": expected_token.expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.MSI_ENDPOINT: url, EnvironmentVariables.MSI_SECRET: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "        token = ManagedIdentityCredential(transport=transport, client_id=client_id).get_token(scope)",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "",
            "def test_azure_ml_tenant_id():",
            "    expected_token = AccessToken(\"****\", int(time.time()) + 3600)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    client_id = \"client\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            ),",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope, \"clientid\": client_id},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token.token,",
            "                    \"expires_in\": 3600,",
            "                    \"expires_on\": expected_token.expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.MSI_ENDPOINT: url, EnvironmentVariables.MSI_SECRET: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == expected_token.token",
            "        assert token.expires_on == expected_token.expires_on",
            "",
            "",
            "def test_cloud_shell_user_assigned_identity():",
            "    \"\"\"Cloud Shell environment: only MSI_ENDPOINT set\"\"\"",
            "",
            "    expected_token = \"****\"",
            "    expires_on = 42",
            "    client_id = \"some-guid\"",
            "    endpoint = \"http://localhost:42/token\"",
            "    scope = \"scope\"",
            "    param_name, param_value = \"foo\", \"bar\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"POST\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_data={\"resource\": scope, param_name: param_value},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token,",
            "                    \"expires_in\": 0,",
            "                    \"expires_on\": expires_on,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(MANAGED_IDENTITY_ENVIRON, {EnvironmentVariables.MSI_ENDPOINT: endpoint}, clear=True):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        credential = ManagedIdentityCredential(transport=transport, identity_config={param_name: param_value})",
            "        token = credential.get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2017_09_01():",
            "    \"\"\"When the environment for 2019-08-01 is not configured, 2017-09-01 should be used.\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    url = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                url,",
            "                method=\"GET\",",
            "                required_headers={\"secret\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2017-09-01\", \"resource\": scope},",
            "            )",
            "        ]",
            "        * 2,",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": \"01/01/1970 00:00:{} +00:00\".format(expires_on),  # linux format",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": \"1/1/1970 12:00:{} AM +00:00\".format(expires_on),  # windows format",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.MSI_ENDPOINT: url,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_prefers_app_service_2019_08_01():",
            "    \"\"\"When the environment is configured for both App Service versions, the credential should prefer the most recent\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2019-08-01\", \"resource\": scope},",
            "            )",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": str(expires_on),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ],",
            "    )",
            "",
            "    environ = {",
            "        EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "        EnvironmentVariables.IDENTITY_HEADER: secret,",
            "        EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "        EnvironmentVariables.MSI_SECRET: secret,",
            "    }",
            "    with mock.patch.dict(\"os.environ\", environ, clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "    assert token.token == access_token",
            "    assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2019_08_01():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    new_endpoint = \"http://localhost:42/new-token\"",
            "    secret = \"expected-secret\"",
            "    new_secret = \"new-expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(new_endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"X-IDENTITY-HEADER\"] == new_secret",
            "        assert request.headers[\"User-Agent\"] == USER_AGENT",
            "        assert request.query[\"api-version\"] == \"2019-08-01\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    # when configuration for both API versions is present, the credential should prefer the most recent",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: new_endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: new_secret,",
            "            EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope)",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_2019_08_01_tenant_id():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    new_endpoint = \"http://localhost:42/new-token\"",
            "    secret = \"expected-secret\"",
            "    new_secret = \"new-expected-secret\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(new_endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"X-IDENTITY-HEADER\"] == new_secret",
            "        assert request.headers[\"User-Agent\"] == USER_AGENT",
            "        assert request.query[\"api-version\"] == \"2019-08-01\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    # when configuration for both API versions is present, the credential should prefer the most recent",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: new_endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: new_secret,",
            "            EnvironmentVariables.MSI_ENDPOINT: endpoint,",
            "            EnvironmentVariables.MSI_SECRET: secret,",
            "        },",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_app_service_user_assigned_identity():",
            "    \"\"\"App Service 2019-08-01: IDENTITY_ENDPOINT, IDENTITY_HEADER set\"\"\"",
            "",
            "    expected_token = \"****\"",
            "    expires_on = 42",
            "    client_id = \"some-guid\"",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    scope = \"scope\"",
            "    param_name, param_value = \"foo\", \"bar\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2019-08-01\", \"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"X-IDENTITY-HEADER\": secret, \"User-Agent\": USER_AGENT},",
            "                required_params={",
            "                    \"api-version\": \"2019-08-01\",",
            "                    \"client_id\": client_id,",
            "                    \"resource\": scope,",
            "                    param_name: param_value,",
            "                },",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": expected_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            )",
            "        ]",
            "        * 2,",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON,",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: endpoint, EnvironmentVariables.IDENTITY_HEADER: secret},",
            "        clear=True,",
            "    ):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "        credential = ManagedIdentityCredential(",
            "            client_id=client_id, transport=transport, identity_config={param_name: param_value}",
            "        )",
            "        token = credential.get_token(scope)",
            "        assert token.token == expected_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_imds():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=IMDS_AUTHORITY + IMDS_TOKEN_PATH,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "    assert token == expected_token",
            "",
            "",
            "def test_imds_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    scope = \"scope\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=IMDS_AUTHORITY + IMDS_TOKEN_PATH,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "    assert token == expected_token",
            "",
            "",
            "def test_client_id_none():",
            "    \"\"\"the credential should ignore client_id=None\"\"\"",
            "",
            "    expected_access_token = \"****\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert \"client_id\" not in request.query",
            "        if request.data:",
            "            assert \"client_id\" not in request.body  # Cloud Shell",
            "        return mock_response(",
            "            json_payload=(build_aad_response(access_token=expected_access_token, expires_on=\"42\", resource=scope))",
            "        )",
            "",
            "    # IMDS",
            "    credential = ManagedIdentityCredential(client_id=None, transport=mock.Mock(send=send))",
            "    token = credential.get_token(scope)",
            "    assert token.token == expected_access_token",
            "",
            "    # Cloud Shell",
            "    with mock.patch.dict(",
            "        MANAGED_IDENTITY_ENVIRON, {EnvironmentVariables.MSI_ENDPOINT: \"https://localhost\"}, clear=True",
            "    ):",
            "        credential = ManagedIdentityCredential(client_id=None, transport=mock.Mock(send=send))",
            "        token = credential.get_token(scope)",
            "    assert token.token == expected_access_token",
            "",
            "",
            "def test_imds_user_assigned_identity():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    expected_token = AccessToken(access_token, expires_on)",
            "    endpoint = IMDS_AUTHORITY + IMDS_TOKEN_PATH",
            "    scope = \"scope\"",
            "    client_id = \"some-guid\"",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"User-Agent\": USER_AGENT},",
            "                required_params={\"api-version\": \"2018-02-01\", \"client_id\": client_id, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"client_id\": client_id,",
            "                    \"expires_in\": 42,",
            "                    \"expires_on\": expires_on,",
            "                    \"ext_expires_in\": 42,",
            "                    \"not_before\": int(time.time()),",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    # ensure e.g. $MSI_ENDPOINT isn't set, so we get ImdsCredential",
            "    with mock.patch.dict(\"os.environ\", clear=True):",
            "        token = ManagedIdentityCredential(client_id=client_id, transport=transport).get_token(scope)",
            "    assert token == expected_token",
            "",
            "",
            "def test_service_fabric():",
            "    \"\"\"Service Fabric 2019-07-01-preview\"\"\"",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    thumbprint = \"SHA1HEX\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"Secret\"] == secret",
            "        assert request.query[\"api-version\"] == \"2019-07-01-preview\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: secret,",
            "            EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: thumbprint,",
            "        },",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope)",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_service_fabric_tenant_id():",
            "    access_token = \"****\"",
            "    expires_on = 42",
            "    endpoint = \"http://localhost:42/token\"",
            "    secret = \"expected-secret\"",
            "    thumbprint = \"SHA1HEX\"",
            "    scope = \"scope\"",
            "",
            "    def send(request, **kwargs):",
            "        # ensure the `claims` and `tenant_id` keywords from credential's `get_token` method don't make it to transport",
            "        assert \"claims\" not in kwargs",
            "        assert \"tenant_id\" not in kwargs",
            "        assert request.url.startswith(endpoint)",
            "        assert request.method == \"GET\"",
            "        assert request.headers[\"Secret\"] == secret",
            "        assert request.query[\"api-version\"] == \"2019-07-01-preview\"",
            "        assert request.query[\"resource\"] == scope",
            "",
            "        return mock_response(",
            "            json_payload={",
            "                \"access_token\": access_token,",
            "                \"expires_on\": str(expires_on),",
            "                \"resource\": scope,",
            "                \"token_type\": \"Bearer\",",
            "            }",
            "        )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: endpoint,",
            "            EnvironmentVariables.IDENTITY_HEADER: secret,",
            "            EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT: thumbprint,",
            "        },",
            "    ):",
            "        token = ManagedIdentityCredential(transport=mock.Mock(send=send)).get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token",
            "        assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc(tmpdir):",
            "    \"\"\"Azure Arc 2019-11-01\"\"\"",
            "    access_token = \"****\"",
            "    api_version = \"2019-11-01\"",
            "    expires_on = 42",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    secret_key = \"XXXX\"",
            "",
            "    key_file = tmpdir.mkdir(\"key\").join(\"key_file.key\")",
            "    key_file.write(secret_key)",
            "    assert key_file.read() == secret_key",
            "    key_path = os.path.join(key_file.dirname, key_file.basename)",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"Authorization\": \"Basic {}\".format(secret_key)},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            # first response gives path to authentication key",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_path)}),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):",
            "            token = ManagedIdentityCredential(transport=transport).get_token(scope)",
            "            assert token.token == access_token",
            "            assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc_tenant_id(tmpdir):",
            "    \"\"\"Azure Arc 2019-11-01\"\"\"",
            "    access_token = \"****\"",
            "    api_version = \"2019-11-01\"",
            "    expires_on = 42",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    secret_key = \"XXXX\"",
            "",
            "    key_file = tmpdir.mkdir(\"key\").join(\"key_file.key\")",
            "    key_file.write(secret_key)",
            "    assert key_file.read() == secret_key",
            "    key_path = os.path.join(key_file.dirname, key_file.basename)",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\", \"Authorization\": \"Basic {}\".format(secret_key)},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            # first response gives path to authentication key",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_path)}),",
            "            mock_response(",
            "                json_payload={",
            "                    \"access_token\": access_token,",
            "                    \"expires_on\": expires_on,",
            "                    \"resource\": scope,",
            "                    \"token_type\": \"Bearer\",",
            "                }",
            "            ),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):",
            "            token = ManagedIdentityCredential(transport=transport).get_token(scope, tenant_id=\"tenant_id\")",
            "            assert token.token == access_token",
            "            assert token.expires_on == expires_on",
            "",
            "",
            "def test_azure_arc_client_id():",
            "    \"\"\"Azure Arc doesn't support user-assigned managed identity\"\"\"",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.IDENTITY_ENDPOINT: \"http://localhost:42/token\",",
            "            EnvironmentVariables.IMDS_ENDPOINT: \"http://localhost:42\",",
            "        },",
            "    ):",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._validate_key_file\", lambda x: None):",
            "            credential = ManagedIdentityCredential(client_id=\"some-guid\")",
            "",
            "    with pytest.raises(ClientAuthenticationError) as ex:",
            "        credential.get_token(\"scope\")",
            "    assert \"not supported\" in str(ex.value)",
            "",
            "",
            "def test_azure_arc_key_too_large(tmp_path):",
            "",
            "    api_version = \"2019-11-01\"",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    secret_key = \"X\" * 4097",
            "",
            "    key_file = tmp_path / \"key_file.key\"",
            "    key_file.write_text(secret_key)",
            "    assert key_file.read_text() == secret_key",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: str(tmp_path)):",
            "            with pytest.raises(ClientAuthenticationError) as ex:",
            "                ManagedIdentityCredential(transport=transport).get_token(scope)",
            "            assert \"file size\" in str(ex.value)",
            "",
            "",
            "def test_azure_arc_key_not_exist(tmp_path):",
            "",
            "    api_version = \"2019-11-01\"",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm=/path/to/key_file\"}),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        with pytest.raises(ClientAuthenticationError) as ex:",
            "            ManagedIdentityCredential(transport=transport).get_token(scope)",
            "        assert \"not exist\" in str(ex.value)",
            "",
            "",
            "def test_azure_arc_key_invalid(tmp_path):",
            "",
            "    api_version = \"2019-11-01\"",
            "    identity_endpoint = \"http://localhost:42/token\"",
            "    imds_endpoint = \"http://localhost:42\"",
            "    scope = \"scope\"",
            "    key_file = tmp_path / \"key_file.txt\"",
            "    key_file.write_text(\"secret\")",
            "",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "            Request(",
            "                base_url=identity_endpoint,",
            "                method=\"GET\",",
            "                required_headers={\"Metadata\": \"true\"},",
            "                required_params={\"api-version\": api_version, \"resource\": scope},",
            "            ),",
            "        ],",
            "        responses=[",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),",
            "            mock_response(status_code=401, headers={\"WWW-Authenticate\": \"Basic realm={}\".format(key_file)}),",
            "        ],",
            "    )",
            "",
            "    with mock.patch(",
            "        \"os.environ\",",
            "        {EnvironmentVariables.IDENTITY_ENDPOINT: identity_endpoint, EnvironmentVariables.IMDS_ENDPOINT: imds_endpoint},",
            "    ):",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: \"/foo\"):",
            "            with pytest.raises(ClientAuthenticationError) as ex:",
            "                ManagedIdentityCredential(transport=transport).get_token(scope)",
            "            assert \"Unexpected file path\" in str(ex.value)",
            "",
            "        with mock.patch(\"azure.identity._credentials.azure_arc._get_key_file_path\", lambda: str(tmp_path)):",
            "            with pytest.raises(ClientAuthenticationError) as ex:",
            "                ManagedIdentityCredential(transport=transport).get_token(scope)",
            "            assert \"extension\" in str(ex.value)",
            "",
            "",
            "def test_token_exchange(tmpdir):",
            "    exchange_token = \"exchange-token\"",
            "    token_file = tmpdir.join(\"token\")",
            "    token_file.write(exchange_token)",
            "    access_token = \"***\"",
            "    authority = \"https://localhost\"",
            "    default_client_id = \"default_client_id\"",
            "    tenant = \"tenant_id\"",
            "    scope = \"scope\"",
            "",
            "    success_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": access_token,",
            "            \"expires_in\": 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"expires_on\": int(time.time()) + 3600,",
            "            \"not_before\": int(time.time()),",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": default_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    mock_environ = {",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "        EnvironmentVariables.AZURE_CLIENT_ID: default_client_id,",
            "        EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "    }",
            "    # credential should default to AZURE_CLIENT_ID",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "        token = credential.get_token(scope)",
            "        assert token.token == access_token",
            "",
            "    # client_id kwarg should override AZURE_CLIENT_ID",
            "    nondefault_client_id = \"non\" + default_client_id",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": nondefault_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(client_id=nondefault_client_id, transport=transport)",
            "        token = credential.get_token(scope)",
            "    assert token.token == access_token",
            "",
            "    # AZURE_CLIENT_ID may not have a value, in which case client_id is required",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": nondefault_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    with mock.patch.dict(",
            "        \"os.environ\",",
            "        {",
            "            EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "            EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "            EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "        },",
            "        clear=True,",
            "    ):",
            "        with pytest.raises(ValueError):",
            "            ManagedIdentityCredential()",
            "",
            "        credential = ManagedIdentityCredential(client_id=nondefault_client_id, transport=transport)",
            "        token = credential.get_token(scope)",
            "    assert token.token == access_token",
            "",
            "",
            "def test_token_exchange_tenant_id(tmpdir):",
            "    exchange_token = \"exchange-token\"",
            "    token_file = tmpdir.join(\"token\")",
            "    token_file.write(exchange_token)",
            "    access_token = \"***\"",
            "    authority = \"https://localhost\"",
            "    default_client_id = \"default_client_id\"",
            "    tenant = \"tenant_id\"",
            "    scope = \"scope\"",
            "",
            "    success_response = mock_response(",
            "        json_payload={",
            "            \"access_token\": access_token,",
            "            \"expires_in\": 3600,",
            "            \"ext_expires_in\": 3600,",
            "            \"expires_on\": int(time.time()) + 3600,",
            "            \"not_before\": int(time.time()),",
            "            \"resource\": scope,",
            "            \"token_type\": \"Bearer\",",
            "        }",
            "    )",
            "    transport = validating_transport(",
            "        requests=[",
            "            Request(",
            "                base_url=authority,",
            "                method=\"POST\",",
            "                required_data={",
            "                    \"client_assertion\": exchange_token,",
            "                    \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",",
            "                    \"client_id\": default_client_id,",
            "                    \"grant_type\": \"client_credentials\",",
            "                    \"scope\": scope,",
            "                },",
            "            )",
            "        ],",
            "        responses=[success_response],",
            "    )",
            "",
            "    mock_environ = {",
            "        EnvironmentVariables.AZURE_AUTHORITY_HOST: authority,",
            "        EnvironmentVariables.AZURE_CLIENT_ID: default_client_id,",
            "        EnvironmentVariables.AZURE_TENANT_ID: tenant,",
            "        EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE: token_file.strpath,",
            "    }",
            "    with mock.patch.dict(\"os.environ\", mock_environ, clear=True):",
            "        credential = ManagedIdentityCredential(transport=transport)",
            "        token = credential.get_token(scope, tenant_id=\"tenant_id\")",
            "        assert token.token == access_token"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "886": [
                "test_azure_arc"
            ],
            "887": [
                "test_azure_arc"
            ],
            "888": [
                "test_azure_arc"
            ],
            "939": [
                "test_azure_arc_tenant_id"
            ],
            "940": [
                "test_azure_arc_tenant_id"
            ],
            "941": [
                "test_azure_arc_tenant_id"
            ],
            "953": [
                "test_azure_arc_client_id"
            ],
            "955": [
                "test_azure_arc_client_id"
            ]
        },
        "addLocation": []
    }
}