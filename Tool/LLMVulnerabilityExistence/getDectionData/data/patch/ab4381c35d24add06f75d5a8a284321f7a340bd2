{
    "vantage6-server/vantage6/server/mail_service.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         with app.app_context():"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "             try:"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "                 self.mail.send(msg)"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except ConnectionRefusedError as e:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+            except Exception as e:"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "                 log.error(\"Mailserver error!\")"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "                 log.debug(e)"
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from threading import Thread",
            "from flask_mail import Message",
            "",
            "from vantage6.common import logger_name",
            "",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "class MailService:",
            "",
            "    def __init__(self, app, mail):",
            "        self.app = app",
            "        self.mail = mail",
            "",
            "    def send_async_email(self, app, msg):",
            "        with app.app_context():",
            "            try:",
            "                self.mail.send(msg)",
            "            except ConnectionRefusedError as e:",
            "                log.error(\"Mailserver error!\")",
            "                log.debug(e)",
            "",
            "    def send_email(self, subject, sender, recipients, text_body, html_body):",
            "        msg = Message(subject, sender=sender, recipients=recipients)",
            "        msg.body = text_body",
            "        msg.html = html_body",
            "        Thread(target=self.send_async_email, args=(self.app, msg)).start()"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from threading import Thread",
            "from flask_mail import Message",
            "",
            "from vantage6.common import logger_name",
            "",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "class MailService:",
            "",
            "    def __init__(self, app, mail):",
            "        self.app = app",
            "        self.mail = mail",
            "",
            "    def send_async_email(self, app, msg):",
            "        with app.app_context():",
            "            try:",
            "                self.mail.send(msg)",
            "            except Exception as e:",
            "                log.error(\"Mailserver error!\")",
            "                log.debug(e)",
            "",
            "    def send_email(self, subject, sender, recipients, text_body, html_body):",
            "        msg = Message(subject, sender=sender, recipients=recipients)",
            "        msg.body = text_body",
            "        msg.html = html_body",
            "        Thread(target=self.send_async_email, args=(self.app, msg)).start()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [
                "MailService",
                "send_async_email"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/model/user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         if has_max_attempts and td_last_login < td_max_blocked:"
            },
            "1": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             minutes_remaining = \\"
            },
            "2": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 (td_max_blocked - td_last_login).seconds // 60 + 1"
            },
            "3": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return True, ("
            },
            "4": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Your account is blocked for the next {minutes_remaining} \""
            },
            "5": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"minutes due to failed login attempts. Please wait or \""
            },
            "6": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"reactivate your account via email.\""
            },
            "7": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+            return True, minutes_remaining"
            },
            "9": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             return False, None"
            },
            "11": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import bcrypt",
            "import re",
            "import datetime as dt",
            "",
            "from typing import Union",
            "from sqlalchemy import Column, String, Integer, ForeignKey, exists, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"User (person) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "    \"\"\"",
            "    _hidden_attributes = ['password']",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)",
            "    __mapper_args__ = {",
            "        'polymorphic_identity': 'user',",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\",",
            "                         secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\",",
            "                         secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self):",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key, password):",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw) -> Union[str, None]:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        if len(pw) < 8:",
            "            return (",
            "                \"Password too short: use at least 8 characters with mixed \"",
            "                \"lowercase, uppercase, numbers and special characters\"",
            "            )",
            "        elif len(pw) > 128:",
            "            # because long passwords can be used for DoS attacks (long pw",
            "            # hashing consumes a lot of resources)",
            "            return \"Password too long: use at most 128 characters\"",
            "        elif re.search('[0-9]', pw) is None:",
            "            return \"Password should contain at least one number\"",
            "        elif re.search('[A-Z]', pw) is None:",
            "            return \"Password should contain at least one uppercase letter\"",
            "        elif re.search('[a-z]', pw) is None:",
            "            return \"Password should contain at least one lowercase letter\"",
            "        elif pw.isalnum():",
            "            return \"Password should contain at least one special character\"",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw):",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode('utf8')",
            "            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(self, max_failed_attempts: int,",
            "                   inactivation_in_minutes: int):",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        str | None",
            "            Message if user is blocked, else None",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = dt.datetime.now() - self.last_login_attempt \\",
            "            if self.last_login_attempt else None",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = \\",
            "                (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, (",
            "                f\"Your account is blocked for the next {minutes_remaining} \"",
            "                \"minutes due to failed login attempts. Please wait or \"",
            "                \"reactivate your account via email.\"",
            "            )",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_user_list(cls, filters=None):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).all()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(exists().where(cls.username == username))\\",
            "            .scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def exists(cls, field, value):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(exists().where(getattr(cls, field) == value))\\",
            "            .scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or \\",
            "            any(rule in role.rules for role in self.roles)"
        ],
        "afterPatchFile": [
            "import bcrypt",
            "import re",
            "import datetime as dt",
            "",
            "from typing import Union",
            "from sqlalchemy import Column, String, Integer, ForeignKey, exists, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"User (person) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "    \"\"\"",
            "    _hidden_attributes = ['password']",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)",
            "    __mapper_args__ = {",
            "        'polymorphic_identity': 'user',",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\",",
            "                         secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\",",
            "                         secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self):",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key, password):",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw) -> Union[str, None]:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        if len(pw) < 8:",
            "            return (",
            "                \"Password too short: use at least 8 characters with mixed \"",
            "                \"lowercase, uppercase, numbers and special characters\"",
            "            )",
            "        elif len(pw) > 128:",
            "            # because long passwords can be used for DoS attacks (long pw",
            "            # hashing consumes a lot of resources)",
            "            return \"Password too long: use at most 128 characters\"",
            "        elif re.search('[0-9]', pw) is None:",
            "            return \"Password should contain at least one number\"",
            "        elif re.search('[A-Z]', pw) is None:",
            "            return \"Password should contain at least one uppercase letter\"",
            "        elif re.search('[a-z]', pw) is None:",
            "            return \"Password should contain at least one lowercase letter\"",
            "        elif pw.isalnum():",
            "            return \"Password should contain at least one special character\"",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw):",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode('utf8')",
            "            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(self, max_failed_attempts: int,",
            "                   inactivation_in_minutes: int):",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        str | None",
            "            Message if user is blocked, else None",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = dt.datetime.now() - self.last_login_attempt \\",
            "            if self.last_login_attempt else None",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = \\",
            "                (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, minutes_remaining",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_user_list(cls, filters=None):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).all()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(exists().where(cls.username == username))\\",
            "            .scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def exists(cls, field, value):",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(exists().where(getattr(cls, field) == value))\\",
            "            .scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or \\",
            "            any(rule in role.rules for role in self.roles)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "133": [
                "User",
                "is_blocked"
            ],
            "134": [
                "User",
                "is_blocked"
            ],
            "135": [
                "User",
                "is_blocked"
            ],
            "136": [
                "User",
                "is_blocked"
            ],
            "137": [
                "User",
                "is_blocked"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/resource/token.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " Resources below '/<api_base>/token'"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from __future__ import print_function, unicode_literals"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import logging"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import datetime as dt"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import pyotp"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from typing import Union"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask import request, g"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from flask import request, g, render_template"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from flask_jwt_extended import ("
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     jwt_required,"
            },
            "14": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     create_access_token,"
            },
            "15": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         log.info(f\"Succesfull login from {username}\")"
            },
            "16": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         return ret, HTTPStatus.OK, {'jwt-token': token}"
            },
            "17": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    def user_login(self, username: str, password: str) -> Union[dict, db.User]:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        \"\"\"Returns user a message in case of failed login attempt.\"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        log.info(f\"Trying to login '{username}'\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        failed_login_msg = \"Failed to login\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        if db.User.username_exists(username):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            user = db.User.get_by_username(username)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+            pw_policy = self.config.get('password_policy', {})"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            max_failed_attempts = pw_policy.get('max_failed_attempts', 5)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            inactivation_time = pw_policy.get('inactivation_minutes', 15)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            is_blocked, min_rem = user.is_blocked(max_failed_attempts,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+                                                  inactivation_time)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            if is_blocked:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                self.notify_user_blocked(user, max_failed_attempts, min_rem)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            elif user.check_password(password):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                user.failed_login_attempts = 0"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+                user.save()"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+                return user, HTTPStatus.OK"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            else:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+                # update the number of failed login attempts"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+                user.failed_login_attempts = 1 \\"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                    if ("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                        not user.failed_login_attempts or"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                        user.failed_login_attempts >= max_failed_attempts"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                    ) else user.failed_login_attempts + 1"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                user.last_login_attempt = dt.datetime.now()"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                user.save()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+    def notify_user_blocked(self, user: db.User, max_n_attempts: int,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                            min_rem: int) -> None:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        \"\"\"Sends an email to the user when his or her account is locked\"\"\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+        if not user.email:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+            log.warning(f'User {user.username} is locked, but does not have'"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                        'an email registered. So no message has been sent.')"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        log.info(f'User {user.username} is locked')"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        template_vars = {'firstname': user.firstname,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                         'number_of_allowed_attempts': max_n_attempts,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                         'ip': request.access_route[-1],"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                         'time': dt.datetime.now(dt.timezone.utc),"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                         'time_remaining': min_rem}"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        self.mail.send_email("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            \"Your account has been temporary suspended\","
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            sender=\"support@vantage6.ai\","
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            recipients=[user.email],"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+            text_body=render_template(\"mail/blocked_account.txt\","
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                                      **template_vars),"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            html_body=render_template(\"mail/blocked_account.html\","
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+                                      **template_vars)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        )"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "     @staticmethod"
            },
            "75": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "     def validate_2fa_token(user: User, mfa_code: Union[int, str]) -> bool:"
            },
            "76": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         \"\"\""
            },
            "77": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         ---"
            },
            "78": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         description: >-"
            },
            "79": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "           Allows node to sign in using a unique API key. If the login is"
            },
            "80": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-          successful this returns a dictionairy with access and refresh tokens"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+          successful this returns a dictionary with access and refresh tokens"
            },
            "82": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "           for the node as well as a node_url and a refresh_url."
            },
            "83": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 257,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         requestBody:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "Resources below '/<api_base>/token'",
            "\"\"\"",
            "from __future__ import print_function, unicode_literals",
            "",
            "import logging",
            "import pyotp",
            "",
            "from typing import Union",
            "from flask import request, g",
            "from flask_jwt_extended import (",
            "    jwt_required,",
            "    create_access_token,",
            "    create_refresh_token,",
            "    get_jwt_identity",
            ")",
            "from http import HTTPStatus",
            "",
            "from vantage6 import server",
            "from vantage6.server import db",
            "from vantage6.server.model.user import User",
            "from vantage6.server.resource import (",
            "    with_node,",
            "    ServicesResources",
            ")",
            "from vantage6.server.resource.common.auth_helper import (",
            "  user_login, create_qr_uri",
            ")",
            "",
            "module_name = __name__.split('.')[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def setup(api, api_base, services):",
            "",
            "    path = \"/\".join([api_base, module_name])",
            "    log.info('Setting up \"{}\" and subdirectories'.format(path))",
            "",
            "    api.add_resource(",
            "        UserToken,",
            "        path+'/user',",
            "        endpoint='user_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        NodeToken,",
            "        path+'/node',",
            "        endpoint='node_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        ContainerToken,",
            "        path+'/container',",
            "        endpoint='container_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        RefreshToken,",
            "        path+'/refresh',",
            "        endpoint='refresh_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "",
            "# ------------------------------------------------------------------------------",
            "# Resources / API's",
            "# ------------------------------------------------------------------------------",
            "class UserToken(ServicesResources):",
            "    \"\"\"resource for api/token\"\"\"",
            "",
            "    def post(self):",
            "        \"\"\"Login user",
            "        ---",
            "        description: >-",
            "          Allow user to sign in by supplying a username and password. When MFA",
            "          is enabled on the server, a code is also required",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                properties:",
            "                  username:",
            "                    type: string",
            "                    description: Username of user that is logging in",
            "                  password:",
            "                    type: string",
            "                    description: User password",
            "                  mfa_code:",
            "                    type: string",
            "                    description: Two-factor authentication code. Only required",
            "                      if two-factor authentication is mandatory.",
            "",
            "        responses:",
            "          200:",
            "            description: Ok, authenticated",
            "          400:",
            "            description: Username/password combination unknown, or missing from",
            "              request body.",
            "          401:",
            "            description: Password and/or two-factor authentication token",
            "              incorrect.",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Authenticate user using username and password\")",
            "",
            "        if not request.is_json:",
            "            log.warning('Authentication failed because no JSON body was '",
            "                        'provided!')",
            "            return {\"msg\": \"Missing JSON in request\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # Check JSON body",
            "        username = request.json.get('username', None)",
            "        password = request.json.get('password', None)",
            "        if not username and password:",
            "            msg = \"Username and/or password missing in JSON body\"",
            "            log.error(msg)",
            "            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST",
            "",
            "        user, code = user_login(self.config.get(\"password_policy\", {}),",
            "                                username, password)",
            "        if code != HTTPStatus.OK:  # login failed",
            "            log.error(f\"Failed to login for user='{username}'\")",
            "            return user, code",
            "",
            "        is_mfa_enabled = self.config.get('two_factor_auth', False)",
            "        if is_mfa_enabled:",
            "            if user.otp_secret is None:",
            "                # server requires mfa but user hasn't set it up yet. Return",
            "                # an URI to generate a QR code",
            "                log.info(f'Redirecting user {username} to setup MFA')",
            "                return create_qr_uri(user), HTTPStatus.OK",
            "            else:",
            "                # 2nd authentication factor: check the OTP secret of the user",
            "                mfa_code = request.json.get('mfa_code')",
            "                if not mfa_code:",
            "                    # note: this is not treated as error, but simply guide",
            "                    # user to also fill in second factor",
            "                    return {\"msg\": \"Please include your two-factor \"",
            "                            \"authentication code\"}, HTTPStatus.OK",
            "                elif not self.validate_2fa_token(user, mfa_code):",
            "                    return {",
            "                        \"msg\": \"Your two-factor authentication code is \"",
            "                               \"incorrect!\"",
            "                    }, HTTPStatus.UNAUTHORIZED",
            "",
            "        token = create_access_token(user)",
            "",
            "        ret = {",
            "            'access_token': token,",
            "            'refresh_token': create_refresh_token(user),",
            "            'user_url': self.api.url_for(server.resource.user.User,",
            "                                         id=user.id),",
            "            'refresh_url': self.api.url_for(RefreshToken),",
            "        }",
            "",
            "        log.info(f\"Succesfull login from {username}\")",
            "        return ret, HTTPStatus.OK, {'jwt-token': token}",
            "",
            "    @staticmethod",
            "    def validate_2fa_token(user: User, mfa_code: Union[int, str]) -> bool:",
            "        \"\"\"",
            "        Check whether the 6-digit two-factor authentication code is valid",
            "",
            "        Parameters",
            "        ----------",
            "        user: User",
            "            The SQLAlchemy model of the user who is authenticating",
            "        mfa_code:",
            "            A six-digit TOTP code from an authenticator app",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "          Whether six-digit code is valid or not",
            "        \"\"\"",
            "        # the option `valid_window=1` means the code from 1 time window (30s)",
            "        # ago, is also valid. This prevents that users around the edge of",
            "        # the time window can still login successfully if server is a bit slow",
            "        return pyotp.TOTP(user.otp_secret).verify(str(mfa_code),",
            "                                                  valid_window=1)",
            "",
            "",
            "class NodeToken(ServicesResources):",
            "",
            "    def post(self):",
            "        \"\"\"Login node",
            "        ---",
            "        description: >-",
            "          Allows node to sign in using a unique API key. If the login is",
            "          successful this returns a dictionairy with access and refresh tokens",
            "          for the node as well as a node_url and a refresh_url.",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                $ref: '#/components/schemas/Node'",
            "",
            "        responses:",
            "          200:",
            "            description: Ok, authenticated",
            "          400:",
            "            description: No API key provided in request body.",
            "          401:",
            "            description: Invalid API key",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Authenticate Node using api key\")",
            "",
            "        if not request.is_json:",
            "            log.warning('Authentication failed because no JSON body was '",
            "                        'provided!')",
            "            return {\"msg\": \"Missing JSON in request\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # Check JSON body",
            "        api_key = request.json.get('api_key', None)",
            "        if not api_key:",
            "            msg = \"api_key missing in JSON body\"",
            "            log.error(msg)",
            "            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST",
            "",
            "        node = db.Node.get_by_api_key(api_key)",
            "",
            "        if not node:  # login failed",
            "            log.error(\"Api key is not recognized\")",
            "            return {\"msg\": \"Api key is not recognized!\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        token = create_access_token(node)",
            "        ret = {",
            "            'access_token': token,",
            "            'refresh_token': create_refresh_token(node),",
            "            'node_url': self.api.url_for(server.resource.node.Node,",
            "                                         id=node.id),",
            "            'refresh_url': self.api.url_for(RefreshToken),",
            "        }",
            "",
            "        log.info(f\"Succesfull login as node '{node.id}' ({node.name})\")",
            "        return ret, HTTPStatus.OK, {'jwt-token': token}",
            "",
            "",
            "class ContainerToken(ServicesResources):",
            "",
            "    @with_node",
            "    def post(self):",
            "        \"\"\"Algorithm container login",
            "        ---",
            "        description: >-",
            "          Generate token for the algorithm container of a specific task.\\n",
            "",
            "          Not available to users; only for authenticated nodes.",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                $ref: '#/components/schemas/ContainerToken'",
            "",
            "        responses:",
            "          200:",
            "            description: Container token generated",
            "          400:",
            "            description: Task does not exist or is already completed",
            "          401:",
            "            description: Key request for invalid image or task",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Creating a token for a container running on a node\")",
            "",
            "        data = request.get_json()",
            "",
            "        task_id = data.get(\"task_id\")",
            "        claim_image = data.get(\"image\")",
            "",
            "        db_task = db.Task.get(task_id)",
            "        if not db_task:",
            "            log.warning(f\"Node {g.node.id} attempts to generate key for task \"",
            "                        f\"{task_id} that does not exist\")",
            "            return {\"msg\": \"Master task does not exist!\"}, \\",
            "                HTTPStatus.BAD_REQUEST",
            "",
            "        # verify that task the token is requested for exists",
            "        if claim_image != db_task.image:",
            "            log.warning(",
            "                f\"Node {g.node.id} attempts to generate key for image \"",
            "                f\"{claim_image} that does not belong to task {task_id}.\"",
            "            )",
            "            return {\"msg\": \"Image and task do no match\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        # check if the node is in the collaboration to which the task is",
            "        # enlisted",
            "        if g.node.collaboration_id != db_task.collaboration_id:",
            "            log.warning(",
            "                f\"Node {g.node.id} attempts to generate key for task {task_id}\"",
            "                f\" which is outside its collaboration \"",
            "                f\"({g.node.collaboration_id}/{db_task.collaboration_id}).\"",
            "            )",
            "            return {\"msg\": \"You are not within the collaboration\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        # validate that the task not has been finished yet",
            "        if db_task.complete:",
            "            log.warning(f\"Node {g.node.id} attempts to generate a key for \"",
            "                        f\"completed task {task_id}\")",
            "            return {\"msg\": \"Task is already finished!\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # container identity consists of its node_id,",
            "        # task_id, collaboration_id and image_id",
            "        container = {",
            "            \"client_type\": \"container\",",
            "            \"node_id\": g.node.id,",
            "            \"organization_id\": g.node.organization_id,",
            "            \"collaboration_id\": g.node.collaboration_id,",
            "            \"task_id\": task_id,",
            "            \"image\": claim_image,",
            "            \"database\": db_task.database",
            "        }",
            "        token = create_access_token(container, expires_delta=False)",
            "",
            "        return {'container_token': token}, HTTPStatus.OK",
            "",
            "",
            "class RefreshToken(ServicesResources):",
            "",
            "    @jwt_required(refresh=True)",
            "    def post(self):",
            "        \"\"\"Refresh token",
            "        ---",
            "        description: >-",
            "          Refresh access token if the previous one is expired.\\n",
            "",
            "          Your refresh token must be present in the request headers to use",
            "          this endpoint.",
            "",
            "        responses:",
            "          200:",
            "            description: Token refreshed",
            "",
            "        security:",
            "          - bearerAuth: []",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        user_or_node_id = get_jwt_identity()",
            "        log.info(f'Refreshing token for user or node \"{user_or_node_id}\"')",
            "        user_or_node = db.Authenticatable.get(user_or_node_id)",
            "        ret = {'access_token': create_access_token(user_or_node)}",
            "",
            "        return ret, HTTPStatus.OK"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "Resources below '/<api_base>/token'",
            "\"\"\"",
            "import logging",
            "import datetime as dt",
            "import pyotp",
            "",
            "from typing import Union",
            "from flask import request, g, render_template",
            "from flask_jwt_extended import (",
            "    jwt_required,",
            "    create_access_token,",
            "    create_refresh_token,",
            "    get_jwt_identity",
            ")",
            "from http import HTTPStatus",
            "",
            "from vantage6 import server",
            "from vantage6.server import db",
            "from vantage6.server.model.user import User",
            "from vantage6.server.resource import (",
            "    with_node,",
            "    ServicesResources",
            ")",
            "from vantage6.server.resource.common.auth_helper import (",
            "  user_login, create_qr_uri",
            ")",
            "",
            "module_name = __name__.split('.')[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def setup(api, api_base, services):",
            "",
            "    path = \"/\".join([api_base, module_name])",
            "    log.info('Setting up \"{}\" and subdirectories'.format(path))",
            "",
            "    api.add_resource(",
            "        UserToken,",
            "        path+'/user',",
            "        endpoint='user_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        NodeToken,",
            "        path+'/node',",
            "        endpoint='node_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        ContainerToken,",
            "        path+'/container',",
            "        endpoint='container_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "    api.add_resource(",
            "        RefreshToken,",
            "        path+'/refresh',",
            "        endpoint='refresh_token',",
            "        methods=('POST',),",
            "        resource_class_kwargs=services",
            "    )",
            "",
            "",
            "# ------------------------------------------------------------------------------",
            "# Resources / API's",
            "# ------------------------------------------------------------------------------",
            "class UserToken(ServicesResources):",
            "    \"\"\"resource for api/token\"\"\"",
            "",
            "    def post(self):",
            "        \"\"\"Login user",
            "        ---",
            "        description: >-",
            "          Allow user to sign in by supplying a username and password. When MFA",
            "          is enabled on the server, a code is also required",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                properties:",
            "                  username:",
            "                    type: string",
            "                    description: Username of user that is logging in",
            "                  password:",
            "                    type: string",
            "                    description: User password",
            "                  mfa_code:",
            "                    type: string",
            "                    description: Two-factor authentication code. Only required",
            "                      if two-factor authentication is mandatory.",
            "",
            "        responses:",
            "          200:",
            "            description: Ok, authenticated",
            "          400:",
            "            description: Username/password combination unknown, or missing from",
            "              request body.",
            "          401:",
            "            description: Password and/or two-factor authentication token",
            "              incorrect.",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Authenticate user using username and password\")",
            "",
            "        if not request.is_json:",
            "            log.warning('Authentication failed because no JSON body was '",
            "                        'provided!')",
            "            return {\"msg\": \"Missing JSON in request\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # Check JSON body",
            "        username = request.json.get('username', None)",
            "        password = request.json.get('password', None)",
            "        if not username and password:",
            "            msg = \"Username and/or password missing in JSON body\"",
            "            log.error(msg)",
            "            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST",
            "",
            "        user, code = user_login(self.config.get(\"password_policy\", {}),",
            "                                username, password)",
            "        if code != HTTPStatus.OK:  # login failed",
            "            log.error(f\"Failed to login for user='{username}'\")",
            "            return user, code",
            "",
            "        is_mfa_enabled = self.config.get('two_factor_auth', False)",
            "        if is_mfa_enabled:",
            "            if user.otp_secret is None:",
            "                # server requires mfa but user hasn't set it up yet. Return",
            "                # an URI to generate a QR code",
            "                log.info(f'Redirecting user {username} to setup MFA')",
            "                return create_qr_uri(user), HTTPStatus.OK",
            "            else:",
            "                # 2nd authentication factor: check the OTP secret of the user",
            "                mfa_code = request.json.get('mfa_code')",
            "                if not mfa_code:",
            "                    # note: this is not treated as error, but simply guide",
            "                    # user to also fill in second factor",
            "                    return {\"msg\": \"Please include your two-factor \"",
            "                            \"authentication code\"}, HTTPStatus.OK",
            "                elif not self.validate_2fa_token(user, mfa_code):",
            "                    return {",
            "                        \"msg\": \"Your two-factor authentication code is \"",
            "                               \"incorrect!\"",
            "                    }, HTTPStatus.UNAUTHORIZED",
            "",
            "        token = create_access_token(user)",
            "",
            "        ret = {",
            "            'access_token': token,",
            "            'refresh_token': create_refresh_token(user),",
            "            'user_url': self.api.url_for(server.resource.user.User,",
            "                                         id=user.id),",
            "            'refresh_url': self.api.url_for(RefreshToken),",
            "        }",
            "",
            "        log.info(f\"Succesfull login from {username}\")",
            "        return ret, HTTPStatus.OK, {'jwt-token': token}",
            "",
            "    def user_login(self, username: str, password: str) -> Union[dict, db.User]:",
            "        \"\"\"Returns user a message in case of failed login attempt.\"\"\"",
            "        log.info(f\"Trying to login '{username}'\")",
            "        failed_login_msg = \"Failed to login\"",
            "        if db.User.username_exists(username):",
            "            user = db.User.get_by_username(username)",
            "            pw_policy = self.config.get('password_policy', {})",
            "            max_failed_attempts = pw_policy.get('max_failed_attempts', 5)",
            "            inactivation_time = pw_policy.get('inactivation_minutes', 15)",
            "",
            "            is_blocked, min_rem = user.is_blocked(max_failed_attempts,",
            "                                                  inactivation_time)",
            "            if is_blocked:",
            "                self.notify_user_blocked(user, max_failed_attempts, min_rem)",
            "                return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "            elif user.check_password(password):",
            "                user.failed_login_attempts = 0",
            "                user.save()",
            "                return user, HTTPStatus.OK",
            "            else:",
            "                # update the number of failed login attempts",
            "                user.failed_login_attempts = 1 \\",
            "                    if (",
            "                        not user.failed_login_attempts or",
            "                        user.failed_login_attempts >= max_failed_attempts",
            "                    ) else user.failed_login_attempts + 1",
            "                user.last_login_attempt = dt.datetime.now()",
            "                user.save()",
            "",
            "        return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "",
            "    def notify_user_blocked(self, user: db.User, max_n_attempts: int,",
            "                            min_rem: int) -> None:",
            "        \"\"\"Sends an email to the user when his or her account is locked\"\"\"",
            "        if not user.email:",
            "            log.warning(f'User {user.username} is locked, but does not have'",
            "                        'an email registered. So no message has been sent.')",
            "",
            "        log.info(f'User {user.username} is locked')",
            "",
            "        template_vars = {'firstname': user.firstname,",
            "                         'number_of_allowed_attempts': max_n_attempts,",
            "                         'ip': request.access_route[-1],",
            "                         'time': dt.datetime.now(dt.timezone.utc),",
            "                         'time_remaining': min_rem}",
            "",
            "        self.mail.send_email(",
            "            \"Your account has been temporary suspended\",",
            "            sender=\"support@vantage6.ai\",",
            "            recipients=[user.email],",
            "            text_body=render_template(\"mail/blocked_account.txt\",",
            "                                      **template_vars),",
            "            html_body=render_template(\"mail/blocked_account.html\",",
            "                                      **template_vars)",
            "        )",
            "",
            "    @staticmethod",
            "    def validate_2fa_token(user: User, mfa_code: Union[int, str]) -> bool:",
            "        \"\"\"",
            "        Check whether the 6-digit two-factor authentication code is valid",
            "",
            "        Parameters",
            "        ----------",
            "        user: User",
            "            The SQLAlchemy model of the user who is authenticating",
            "        mfa_code:",
            "            A six-digit TOTP code from an authenticator app",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "          Whether six-digit code is valid or not",
            "        \"\"\"",
            "        # the option `valid_window=1` means the code from 1 time window (30s)",
            "        # ago, is also valid. This prevents that users around the edge of",
            "        # the time window can still login successfully if server is a bit slow",
            "        return pyotp.TOTP(user.otp_secret).verify(str(mfa_code),",
            "                                                  valid_window=1)",
            "",
            "",
            "class NodeToken(ServicesResources):",
            "",
            "    def post(self):",
            "        \"\"\"Login node",
            "        ---",
            "        description: >-",
            "          Allows node to sign in using a unique API key. If the login is",
            "          successful this returns a dictionary with access and refresh tokens",
            "          for the node as well as a node_url and a refresh_url.",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                $ref: '#/components/schemas/Node'",
            "",
            "        responses:",
            "          200:",
            "            description: Ok, authenticated",
            "          400:",
            "            description: No API key provided in request body.",
            "          401:",
            "            description: Invalid API key",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Authenticate Node using api key\")",
            "",
            "        if not request.is_json:",
            "            log.warning('Authentication failed because no JSON body was '",
            "                        'provided!')",
            "            return {\"msg\": \"Missing JSON in request\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # Check JSON body",
            "        api_key = request.json.get('api_key', None)",
            "        if not api_key:",
            "            msg = \"api_key missing in JSON body\"",
            "            log.error(msg)",
            "            return {\"msg\": msg}, HTTPStatus.BAD_REQUEST",
            "",
            "        node = db.Node.get_by_api_key(api_key)",
            "",
            "        if not node:  # login failed",
            "            log.error(\"Api key is not recognized\")",
            "            return {\"msg\": \"Api key is not recognized!\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        token = create_access_token(node)",
            "        ret = {",
            "            'access_token': token,",
            "            'refresh_token': create_refresh_token(node),",
            "            'node_url': self.api.url_for(server.resource.node.Node,",
            "                                         id=node.id),",
            "            'refresh_url': self.api.url_for(RefreshToken),",
            "        }",
            "",
            "        log.info(f\"Succesfull login as node '{node.id}' ({node.name})\")",
            "        return ret, HTTPStatus.OK, {'jwt-token': token}",
            "",
            "",
            "class ContainerToken(ServicesResources):",
            "",
            "    @with_node",
            "    def post(self):",
            "        \"\"\"Algorithm container login",
            "        ---",
            "        description: >-",
            "          Generate token for the algorithm container of a specific task.\\n",
            "",
            "          Not available to users; only for authenticated nodes.",
            "",
            "        requestBody:",
            "          content:",
            "            application/json:",
            "              schema:",
            "                $ref: '#/components/schemas/ContainerToken'",
            "",
            "        responses:",
            "          200:",
            "            description: Container token generated",
            "          400:",
            "            description: Task does not exist or is already completed",
            "          401:",
            "            description: Key request for invalid image or task",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        log.debug(\"Creating a token for a container running on a node\")",
            "",
            "        data = request.get_json()",
            "",
            "        task_id = data.get(\"task_id\")",
            "        claim_image = data.get(\"image\")",
            "",
            "        db_task = db.Task.get(task_id)",
            "        if not db_task:",
            "            log.warning(f\"Node {g.node.id} attempts to generate key for task \"",
            "                        f\"{task_id} that does not exist\")",
            "            return {\"msg\": \"Master task does not exist!\"}, \\",
            "                HTTPStatus.BAD_REQUEST",
            "",
            "        # verify that task the token is requested for exists",
            "        if claim_image != db_task.image:",
            "            log.warning(",
            "                f\"Node {g.node.id} attempts to generate key for image \"",
            "                f\"{claim_image} that does not belong to task {task_id}.\"",
            "            )",
            "            return {\"msg\": \"Image and task do no match\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        # check if the node is in the collaboration to which the task is",
            "        # enlisted",
            "        if g.node.collaboration_id != db_task.collaboration_id:",
            "            log.warning(",
            "                f\"Node {g.node.id} attempts to generate key for task {task_id}\"",
            "                f\" which is outside its collaboration \"",
            "                f\"({g.node.collaboration_id}/{db_task.collaboration_id}).\"",
            "            )",
            "            return {\"msg\": \"You are not within the collaboration\"}, \\",
            "                HTTPStatus.UNAUTHORIZED",
            "",
            "        # validate that the task not has been finished yet",
            "        if db_task.complete:",
            "            log.warning(f\"Node {g.node.id} attempts to generate a key for \"",
            "                        f\"completed task {task_id}\")",
            "            return {\"msg\": \"Task is already finished!\"}, HTTPStatus.BAD_REQUEST",
            "",
            "        # container identity consists of its node_id,",
            "        # task_id, collaboration_id and image_id",
            "        container = {",
            "            \"client_type\": \"container\",",
            "            \"node_id\": g.node.id,",
            "            \"organization_id\": g.node.organization_id,",
            "            \"collaboration_id\": g.node.collaboration_id,",
            "            \"task_id\": task_id,",
            "            \"image\": claim_image,",
            "            \"database\": db_task.database",
            "        }",
            "        token = create_access_token(container, expires_delta=False)",
            "",
            "        return {'container_token': token}, HTTPStatus.OK",
            "",
            "",
            "class RefreshToken(ServicesResources):",
            "",
            "    @jwt_required(refresh=True)",
            "    def post(self):",
            "        \"\"\"Refresh token",
            "        ---",
            "        description: >-",
            "          Refresh access token if the previous one is expired.\\n",
            "",
            "          Your refresh token must be present in the request headers to use",
            "          this endpoint.",
            "",
            "        responses:",
            "          200:",
            "            description: Token refreshed",
            "",
            "        security:",
            "          - bearerAuth: []",
            "",
            "        tags: [\"Authentication\"]",
            "        \"\"\"",
            "        user_or_node_id = get_jwt_identity()",
            "        log.info(f'Refreshing token for user or node \"{user_or_node_id}\"')",
            "        user_or_node = db.Authenticatable.get(user_or_node_id)",
            "        ret = {'access_token': create_access_token(user_or_node)}",
            "",
            "        return ret, HTTPStatus.OK"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "6": [],
            "11": [],
            "200": [
                "NodeToken",
                "post"
            ]
        },
        "addLocation": []
    }
}