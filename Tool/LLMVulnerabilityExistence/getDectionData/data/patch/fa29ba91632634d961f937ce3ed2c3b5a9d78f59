{
    "web/pgadmin/authenticate/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import config"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import copy"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import functools"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from threading import Lock"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from flask import current_app, flash, Response, request, url_for, \\"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     session, redirect, render_template"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " _URL_WITH_NEXT_PARAM = \"{0}?next={1}\""
            },
            "8": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+class AuthLocker:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    \"\"\"Implementing lock while authentication.\"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    lock = Lock()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    def __enter__(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        self.lock.acquire()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        return self"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    def __exit__(self, type, value, traceback):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        if self.lock.locked():"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            self.lock.release()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " def get_logout_url() -> str:"
            },
            "24": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     \"\"\""
            },
            "25": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     Returns the logout url based on the current authentication method."
            },
            "26": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     Entry point for all the authentication sources."
            },
            "27": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     The user input will be validated and authenticated."
            },
            "28": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     \"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    with AuthLocker():"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        return _login()"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+def _login():"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    \"\"\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    Internal authentication process locked by a mutex."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    \"\"\""
            },
            "37": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     form = _security.forms.get('login_form').cls(request.form)"
            },
            "38": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "     if OAUTH2 in config.AUTHENTICATION_SOURCES \\"
            },
            "39": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             and 'oauth2_button' in request.form:"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Authentication.\"\"\"",
            "",
            "import config",
            "import copy",
            "import functools",
            "",
            "from flask import current_app, flash, Response, request, url_for, \\",
            "    session, redirect, render_template",
            "from flask_babel import gettext",
            "from flask_security.views import _security, _ctx",
            "from flask_security.utils import get_post_logout_redirect, logout_user,\\",
            "    config_value",
            "",
            "from flask_login import current_user",
            "from flask_socketio import disconnect, ConnectionRefusedError",
            "",
            "",
            "from pgadmin.model import db, User",
            "from pgadmin.utils import PgAdminModule, get_safe_post_login_redirect",
            "from pgadmin.utils.constants import KERBEROS, INTERNAL, OAUTH2, LDAP",
            "from pgadmin.authenticate.registry import AuthSourceRegistry",
            "",
            "MODULE_NAME = 'authenticate'",
            "auth_obj = None",
            "",
            "_URL_WITH_NEXT_PARAM = \"{0}?next={1}\"",
            "",
            "",
            "def get_logout_url() -> str:",
            "    \"\"\"",
            "    Returns the logout url based on the current authentication method.",
            "",
            "    Returns:",
            "        str: logout url",
            "    \"\"\"",
            "    BROWSER_INDEX = 'browser.index'",
            "    if config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            KERBEROS:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'kerberos.logout'), url_for(BROWSER_INDEX))",
            "    elif config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            OAUTH2:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'oauth2.logout'), url_for(BROWSER_INDEX))",
            "",
            "    return _URL_WITH_NEXT_PARAM.format(",
            "        url_for('security.logout'), url_for(BROWSER_INDEX))",
            "",
            "",
            "def socket_login_required(f):",
            "    @functools.wraps(f)",
            "    def wrapped(*args, **kwargs):",
            "        if not current_user.is_authenticated:",
            "            disconnect()",
            "            raise ConnectionRefusedError(\"Unauthorised !\")",
            "        else:",
            "            return f(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class AuthenticateModule(PgAdminModule):",
            "    def get_exposed_url_endpoints(self):",
            "        return ['authenticate.login']",
            "",
            "",
            "blueprint = AuthenticateModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "@blueprint.route('/login', endpoint='login', methods=['GET', 'POST'])",
            "def login():",
            "    \"\"\"",
            "    Entry point for all the authentication sources.",
            "    The user input will be validated and authenticated.",
            "    \"\"\"",
            "    form = _security.forms.get('login_form').cls(request.form)",
            "    if OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "            and 'oauth2_button' in request.form:",
            "        # Sending empty form as oauth2 does not require form attribute",
            "        auth_obj = AuthSourceManager({}, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "        session['auth_obj'] = auth_obj",
            "    else:",
            "        auth_obj = AuthSourceManager(form, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "",
            "    session['auth_source_manager'] = None",
            "",
            "    username = form.data['email']",
            "    user = User.query.filter_by(username=username,",
            "                                auth_source=INTERNAL).first()",
            "",
            "    if user:",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            user.locked = True",
            "        else:",
            "            user.locked = False",
            "        db.session.commit()",
            "",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            flash(gettext('Your account is locked. Please contact the '",
            "                          'Administrator.'),",
            "                  'warning')",
            "            logout_user()",
            "            return redirect(get_post_logout_redirect())",
            "",
            "    # Validate the user",
            "    if not auth_obj.validate():",
            "        for field in form.errors:",
            "            flash_login_attempt_error = None",
            "            if user and field in config.LOGIN_ATTEMPT_FIELDS:",
            "                if config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    user.login_attempts += 1",
            "                    left_attempts = \\",
            "                        config.MAX_LOGIN_ATTEMPTS - user.login_attempts",
            "                    if left_attempts > 1:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempts remaining.'.",
            "                                    format(left_attempts))",
            "                    else:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempt remaining.'.",
            "                                    format(left_attempts))",
            "                db.session.commit()",
            "            for error in form.errors[field]:",
            "                if flash_login_attempt_error:",
            "                    error = error + flash_login_attempt_error",
            "                    flash_login_attempt_error = None",
            "                flash(error, 'warning')",
            "",
            "        return redirect(get_post_logout_redirect())",
            "",
            "    # Authenticate the user",
            "    status, msg = auth_obj.authenticate()",
            "    if status:",
            "        # Login the user",
            "        status, msg = auth_obj.login()",
            "        current_auth_obj = auth_obj.as_dict()",
            "",
            "        if not status:",
            "            if current_auth_obj['current_source'] == \\",
            "                    KERBEROS:",
            "                return redirect('{0}?next={1}'.format(url_for(",
            "                    'authenticate.kerberos_login'), url_for('browser.index')))",
            "",
            "            flash(msg, 'danger')",
            "            return redirect(get_post_logout_redirect())",
            "",
            "        session['auth_source_manager'] = current_auth_obj",
            "",
            "        if user:",
            "            user.login_attempts = 0",
            "        db.session.commit()",
            "",
            "        if 'auth_obj' in session:",
            "            session.pop('auth_obj')",
            "        return redirect(get_safe_post_login_redirect())",
            "",
            "    elif isinstance(msg, Response):",
            "        return msg",
            "    elif 'oauth2_button' in request.form and not isinstance(msg, str):",
            "        return msg",
            "    if 'auth_obj' in session:",
            "        session.pop('auth_obj')",
            "    flash(msg, 'danger')",
            "    form_class = _security.forms.get('login_form').cls",
            "    form = form_class()",
            "",
            "    return _security.render_template(",
            "        config_value('LOGIN_USER_TEMPLATE'),",
            "        login_user_form=form, **_ctx('login'))",
            "",
            "",
            "class AuthSourceManager:",
            "    \"\"\"This class will manage all the authentication sources.",
            "     \"\"\"",
            "",
            "    def __init__(self, form, sources):",
            "        self.form = form",
            "        self.auth_sources = sources",
            "        self.source = None",
            "        self.source_friendly_name = INTERNAL",
            "        self.current_source = INTERNAL",
            "        self.update_auth_sources()",
            "",
            "    def as_dict(self):",
            "        \"\"\"",
            "        Returns the dictionary object representing this object.",
            "        \"\"\"",
            "",
            "        res = dict()",
            "        res['source_friendly_name'] = self.source_friendly_name",
            "        res['auth_sources'] = self.auth_sources",
            "        res['current_source'] = self.current_source",
            "",
            "        return res",
            "",
            "    def update_auth_sources(self):",
            "        for auth_src in [KERBEROS, OAUTH2]:",
            "            if auth_src in self.auth_sources:",
            "                if 'internal_button' in request.form:",
            "                    self.auth_sources.remove(auth_src)",
            "                else:",
            "                    if INTERNAL in self.auth_sources:",
            "                        self.auth_sources.remove(INTERNAL)",
            "                    if LDAP in self.auth_sources:",
            "                        self.auth_sources.remove(LDAP)",
            "",
            "    def set_current_source(self, source):",
            "        self.current_source = source",
            "",
            "    @property",
            "    def get_current_source(self):",
            "        return self.current_source",
            "",
            "    def set_source(self, source):",
            "        self.source = source",
            "",
            "    @property",
            "    def get_source(self):",
            "        return self.source",
            "",
            "    def set_source_friendly_name(self, name):",
            "        self.source_friendly_name = name",
            "",
            "    @property",
            "    def get_source_friendly_name(self):",
            "        return self.source_friendly_name",
            "",
            "    def validate(self):",
            "        \"\"\"Validate through all the sources.\"\"\"",
            "        err_msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            status, err_msg = source.validate(self.form)",
            "            if status:",
            "                return True",
            "        if err_msg:",
            "            flash(err_msg, 'warning')",
            "        return False",
            "",
            "    def authenticate(self):",
            "        \"\"\"Authenticate through all the sources.\"\"\"",
            "        status = False",
            "        msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            self.set_source(source)",
            "            current_app.logger.debug(",
            "                \"Authentication initiated via source: %s\" %",
            "                source.get_source_name())",
            "",
            "            status, msg = source.authenticate(self.form)",
            "",
            "            if status:",
            "                self.set_current_source(source.get_source_name())",
            "                if msg is not None and 'username' in msg:",
            "                    self.form._fields['email'].data = msg['username']",
            "                return status, msg",
            "",
            "        return status, msg",
            "",
            "    def login(self):",
            "        status, msg = self.source.login(self.form)",
            "        if status:",
            "            self.set_source_friendly_name(self.source.get_friendly_name())",
            "            current_app.logger.debug(",
            "                \"Authentication and Login successfully done via source : %s\" %",
            "                self.source.get_source_name())",
            "",
            "            # Set the login, logout view as per source  if available",
            "            current_app.login_manager.login_view = getattr(",
            "                self.source, 'LOGIN_VIEW', 'security.login')",
            "            current_app.login_manager.logout_view = getattr(",
            "                self.source, 'LOGOUT_VIEW', 'security.logout')",
            "",
            "        return status, msg",
            "",
            "",
            "def get_auth_sources(type):",
            "    \"\"\"Get the authenticated source object from the registry\"\"\"",
            "",
            "    auth_sources = getattr(current_app, '_pgadmin_auth_sources', None)",
            "",
            "    if auth_sources is None or not isinstance(auth_sources, dict):",
            "        auth_sources = dict()",
            "",
            "    if type in auth_sources:",
            "        return auth_sources[type]",
            "",
            "    auth_source = AuthSourceRegistry.get(type)",
            "",
            "    if auth_source is not None:",
            "        auth_sources[type] = auth_source",
            "        setattr(current_app, '_pgadmin_auth_sources', auth_sources)",
            "",
            "    return auth_source",
            "",
            "",
            "def init_app(app):",
            "    auth_sources = dict()",
            "",
            "    setattr(app, '_pgadmin_auth_sources', auth_sources)",
            "    AuthSourceRegistry.load_modules(app)",
            "",
            "    return auth_sources"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the Authentication.\"\"\"",
            "",
            "import config",
            "import copy",
            "import functools",
            "from threading import Lock",
            "",
            "from flask import current_app, flash, Response, request, url_for, \\",
            "    session, redirect, render_template",
            "from flask_babel import gettext",
            "from flask_security.views import _security, _ctx",
            "from flask_security.utils import get_post_logout_redirect, logout_user,\\",
            "    config_value",
            "",
            "from flask_login import current_user",
            "from flask_socketio import disconnect, ConnectionRefusedError",
            "",
            "",
            "from pgadmin.model import db, User",
            "from pgadmin.utils import PgAdminModule, get_safe_post_login_redirect",
            "from pgadmin.utils.constants import KERBEROS, INTERNAL, OAUTH2, LDAP",
            "from pgadmin.authenticate.registry import AuthSourceRegistry",
            "",
            "MODULE_NAME = 'authenticate'",
            "auth_obj = None",
            "",
            "_URL_WITH_NEXT_PARAM = \"{0}?next={1}\"",
            "",
            "",
            "class AuthLocker:",
            "    \"\"\"Implementing lock while authentication.\"\"\"",
            "    lock = Lock()",
            "",
            "    def __enter__(self):",
            "        self.lock.acquire()",
            "        return self",
            "",
            "    def __exit__(self, type, value, traceback):",
            "        if self.lock.locked():",
            "            self.lock.release()",
            "",
            "",
            "def get_logout_url() -> str:",
            "    \"\"\"",
            "    Returns the logout url based on the current authentication method.",
            "",
            "    Returns:",
            "        str: logout url",
            "    \"\"\"",
            "    BROWSER_INDEX = 'browser.index'",
            "    if config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            KERBEROS:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'kerberos.logout'), url_for(BROWSER_INDEX))",
            "    elif config.SERVER_MODE and\\",
            "            session['auth_source_manager']['current_source'] == \\",
            "            OAUTH2:",
            "        return _URL_WITH_NEXT_PARAM.format(url_for(",
            "            'oauth2.logout'), url_for(BROWSER_INDEX))",
            "",
            "    return _URL_WITH_NEXT_PARAM.format(",
            "        url_for('security.logout'), url_for(BROWSER_INDEX))",
            "",
            "",
            "def socket_login_required(f):",
            "    @functools.wraps(f)",
            "    def wrapped(*args, **kwargs):",
            "        if not current_user.is_authenticated:",
            "            disconnect()",
            "            raise ConnectionRefusedError(\"Unauthorised !\")",
            "        else:",
            "            return f(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class AuthenticateModule(PgAdminModule):",
            "    def get_exposed_url_endpoints(self):",
            "        return ['authenticate.login']",
            "",
            "",
            "blueprint = AuthenticateModule(MODULE_NAME, __name__, static_url_path='')",
            "",
            "",
            "@blueprint.route('/login', endpoint='login', methods=['GET', 'POST'])",
            "def login():",
            "    \"\"\"",
            "    Entry point for all the authentication sources.",
            "    The user input will be validated and authenticated.",
            "    \"\"\"",
            "    with AuthLocker():",
            "        return _login()",
            "",
            "",
            "def _login():",
            "    \"\"\"",
            "    Internal authentication process locked by a mutex.",
            "    \"\"\"",
            "    form = _security.forms.get('login_form').cls(request.form)",
            "    if OAUTH2 in config.AUTHENTICATION_SOURCES \\",
            "            and 'oauth2_button' in request.form:",
            "        # Sending empty form as oauth2 does not require form attribute",
            "        auth_obj = AuthSourceManager({}, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "        session['auth_obj'] = auth_obj",
            "    else:",
            "        auth_obj = AuthSourceManager(form, copy.deepcopy(",
            "            config.AUTHENTICATION_SOURCES))",
            "",
            "    session['auth_source_manager'] = None",
            "",
            "    username = form.data['email']",
            "    user = User.query.filter_by(username=username,",
            "                                auth_source=INTERNAL).first()",
            "",
            "    if user:",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            user.locked = True",
            "        else:",
            "            user.locked = False",
            "        db.session.commit()",
            "",
            "        if user.login_attempts >= config.MAX_LOGIN_ATTEMPTS > 0:",
            "            flash(gettext('Your account is locked. Please contact the '",
            "                          'Administrator.'),",
            "                  'warning')",
            "            logout_user()",
            "            return redirect(get_post_logout_redirect())",
            "",
            "    # Validate the user",
            "    if not auth_obj.validate():",
            "        for field in form.errors:",
            "            flash_login_attempt_error = None",
            "            if user and field in config.LOGIN_ATTEMPT_FIELDS:",
            "                if config.MAX_LOGIN_ATTEMPTS > 0:",
            "                    user.login_attempts += 1",
            "                    left_attempts = \\",
            "                        config.MAX_LOGIN_ATTEMPTS - user.login_attempts",
            "                    if left_attempts > 1:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempts remaining.'.",
            "                                    format(left_attempts))",
            "                    else:",
            "                        flash_login_attempt_error = \\",
            "                            gettext('{0} more attempt remaining.'.",
            "                                    format(left_attempts))",
            "                db.session.commit()",
            "            for error in form.errors[field]:",
            "                if flash_login_attempt_error:",
            "                    error = error + flash_login_attempt_error",
            "                    flash_login_attempt_error = None",
            "                flash(error, 'warning')",
            "",
            "        return redirect(get_post_logout_redirect())",
            "",
            "    # Authenticate the user",
            "    status, msg = auth_obj.authenticate()",
            "    if status:",
            "        # Login the user",
            "        status, msg = auth_obj.login()",
            "        current_auth_obj = auth_obj.as_dict()",
            "",
            "        if not status:",
            "            if current_auth_obj['current_source'] == \\",
            "                    KERBEROS:",
            "                return redirect('{0}?next={1}'.format(url_for(",
            "                    'authenticate.kerberos_login'), url_for('browser.index')))",
            "",
            "            flash(msg, 'danger')",
            "            return redirect(get_post_logout_redirect())",
            "",
            "        session['auth_source_manager'] = current_auth_obj",
            "",
            "        if user:",
            "            user.login_attempts = 0",
            "        db.session.commit()",
            "",
            "        if 'auth_obj' in session:",
            "            session.pop('auth_obj')",
            "        return redirect(get_safe_post_login_redirect())",
            "",
            "    elif isinstance(msg, Response):",
            "        return msg",
            "    elif 'oauth2_button' in request.form and not isinstance(msg, str):",
            "        return msg",
            "    if 'auth_obj' in session:",
            "        session.pop('auth_obj')",
            "    flash(msg, 'danger')",
            "    form_class = _security.forms.get('login_form').cls",
            "    form = form_class()",
            "",
            "    return _security.render_template(",
            "        config_value('LOGIN_USER_TEMPLATE'),",
            "        login_user_form=form, **_ctx('login'))",
            "",
            "",
            "class AuthSourceManager:",
            "    \"\"\"This class will manage all the authentication sources.",
            "     \"\"\"",
            "",
            "    def __init__(self, form, sources):",
            "        self.form = form",
            "        self.auth_sources = sources",
            "        self.source = None",
            "        self.source_friendly_name = INTERNAL",
            "        self.current_source = INTERNAL",
            "        self.update_auth_sources()",
            "",
            "    def as_dict(self):",
            "        \"\"\"",
            "        Returns the dictionary object representing this object.",
            "        \"\"\"",
            "",
            "        res = dict()",
            "        res['source_friendly_name'] = self.source_friendly_name",
            "        res['auth_sources'] = self.auth_sources",
            "        res['current_source'] = self.current_source",
            "",
            "        return res",
            "",
            "    def update_auth_sources(self):",
            "        for auth_src in [KERBEROS, OAUTH2]:",
            "            if auth_src in self.auth_sources:",
            "                if 'internal_button' in request.form:",
            "                    self.auth_sources.remove(auth_src)",
            "                else:",
            "                    if INTERNAL in self.auth_sources:",
            "                        self.auth_sources.remove(INTERNAL)",
            "                    if LDAP in self.auth_sources:",
            "                        self.auth_sources.remove(LDAP)",
            "",
            "    def set_current_source(self, source):",
            "        self.current_source = source",
            "",
            "    @property",
            "    def get_current_source(self):",
            "        return self.current_source",
            "",
            "    def set_source(self, source):",
            "        self.source = source",
            "",
            "    @property",
            "    def get_source(self):",
            "        return self.source",
            "",
            "    def set_source_friendly_name(self, name):",
            "        self.source_friendly_name = name",
            "",
            "    @property",
            "    def get_source_friendly_name(self):",
            "        return self.source_friendly_name",
            "",
            "    def validate(self):",
            "        \"\"\"Validate through all the sources.\"\"\"",
            "        err_msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            status, err_msg = source.validate(self.form)",
            "            if status:",
            "                return True",
            "        if err_msg:",
            "            flash(err_msg, 'warning')",
            "        return False",
            "",
            "    def authenticate(self):",
            "        \"\"\"Authenticate through all the sources.\"\"\"",
            "        status = False",
            "        msg = None",
            "        for src in self.auth_sources:",
            "            source = get_auth_sources(src)",
            "            self.set_source(source)",
            "            current_app.logger.debug(",
            "                \"Authentication initiated via source: %s\" %",
            "                source.get_source_name())",
            "",
            "            status, msg = source.authenticate(self.form)",
            "",
            "            if status:",
            "                self.set_current_source(source.get_source_name())",
            "                if msg is not None and 'username' in msg:",
            "                    self.form._fields['email'].data = msg['username']",
            "                return status, msg",
            "",
            "        return status, msg",
            "",
            "    def login(self):",
            "        status, msg = self.source.login(self.form)",
            "        if status:",
            "            self.set_source_friendly_name(self.source.get_friendly_name())",
            "            current_app.logger.debug(",
            "                \"Authentication and Login successfully done via source : %s\" %",
            "                self.source.get_source_name())",
            "",
            "            # Set the login, logout view as per source  if available",
            "            current_app.login_manager.login_view = getattr(",
            "                self.source, 'LOGIN_VIEW', 'security.login')",
            "            current_app.login_manager.logout_view = getattr(",
            "                self.source, 'LOGOUT_VIEW', 'security.logout')",
            "",
            "        return status, msg",
            "",
            "",
            "def get_auth_sources(type):",
            "    \"\"\"Get the authenticated source object from the registry\"\"\"",
            "",
            "    auth_sources = getattr(current_app, '_pgadmin_auth_sources', None)",
            "",
            "    if auth_sources is None or not isinstance(auth_sources, dict):",
            "        auth_sources = dict()",
            "",
            "    if type in auth_sources:",
            "        return auth_sources[type]",
            "",
            "    auth_source = AuthSourceRegistry.get(type)",
            "",
            "    if auth_source is not None:",
            "        auth_sources[type] = auth_source",
            "        setattr(current_app, '_pgadmin_auth_sources', auth_sources)",
            "",
            "    return auth_source",
            "",
            "",
            "def init_app(app):",
            "    auth_sources = dict()",
            "",
            "    setattr(app, '_pgadmin_auth_sources', auth_sources)",
            "    AuthSourceRegistry.load_modules(app)",
            "",
            "    return auth_sources"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.authenticate.AuthSourceManager.form",
            "yt_dlp.YoutubeDL",
            "web.pgadmin.authenticate.AuthSourceManager.__init__.form"
        ]
    }
}