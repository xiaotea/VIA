{
    "src/Products/PageTemplates/ZRPythonExpr.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     this = ns.get('context', ns.get('here'))"
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     td.this = this"
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     request = ns.get('request', {})"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    if hasattr(request, 'taintWrapper'):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        request = request.taintWrapper()"
            },
            "5": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     td._push(request)"
            },
            "6": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     td._push(InstanceDict(td.this, td))"
            },
            "7": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     td._push(ns)"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Corporation and Contributors. All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Zope-specific Python Expression Handler",
            "",
            "Handler for Python expressions that uses the RestrictedPython package.",
            "",
            "$Id$",
            "\"\"\"",
            "from AccessControl import safe_builtins",
            "from AccessControl.ZopeGuards import guarded_getattr, get_safe_globals",
            "from RestrictedPython import compile_restricted_eval",
            "from zope.tales.tales import CompilerError",
            "from zope.tales.pythonexpr import PythonExpr",
            "",
            "class PythonExpr(PythonExpr):",
            "    _globals = get_safe_globals()",
            "    _globals['_getattr_'] = guarded_getattr",
            "    _globals['__debug__' ] = __debug__",
            "",
            "    def __init__(self, name, expr, engine):",
            "        self.text = self.expr = text = expr.strip().replace('\\n', ' ')",
            "",
            "        # Unicode expression are not handled properly by RestrictedPython",
            "        # We convert the expression to UTF-8 (ajung)",
            "        if isinstance(text, unicode):",
            "            text = text.encode('utf-8')",
            "        code, err, warn, use = compile_restricted_eval(text, ",
            "                                                       self.__class__.__name__)",
            "        if err:",
            "            raise engine.getCompilerError()('Python expression error:\\n%s' %",
            "                                            '\\n'.join(err))            ",
            "        self._varnames = use.keys()",
            "        self._code = code",
            "",
            "    def __call__(self, econtext):",
            "        __traceback_info__ = self.text",
            "        vars = self._bind_used_names(econtext, {})",
            "        vars.update(self._globals)",
            "        return eval(self._code, vars, {})",
            "",
            "class _SecureModuleImporter:",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "    def __getitem__(self, module):",
            "        mod = safe_builtins['__import__'](module)",
            "        path = module.split('.')",
            "        for name in path[1:]:",
            "            mod = getattr(mod, name)",
            "        return mod",
            "",
            "from DocumentTemplate.DT_Util import TemplateDict, InstanceDict",
            "from AccessControl.DTML import RestrictedDTML",
            "class Rtd(RestrictedDTML, TemplateDict):",
            "    this = None",
            "",
            "def call_with_ns(f, ns, arg=1):",
            "    td = Rtd()",
            "    # prefer 'context' to 'here';  fall back to 'None'",
            "    this = ns.get('context', ns.get('here'))",
            "    td.this = this",
            "    request = ns.get('request', {})",
            "    td._push(request)",
            "    td._push(InstanceDict(td.this, td))",
            "    td._push(ns)",
            "    try:",
            "        if arg==2:",
            "            return f(None, td)",
            "        else:",
            "            return f(td)",
            "    finally:",
            "        td._pop(3)"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Corporation and Contributors. All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Zope-specific Python Expression Handler",
            "",
            "Handler for Python expressions that uses the RestrictedPython package.",
            "",
            "$Id$",
            "\"\"\"",
            "from AccessControl import safe_builtins",
            "from AccessControl.ZopeGuards import guarded_getattr, get_safe_globals",
            "from RestrictedPython import compile_restricted_eval",
            "from zope.tales.tales import CompilerError",
            "from zope.tales.pythonexpr import PythonExpr",
            "",
            "class PythonExpr(PythonExpr):",
            "    _globals = get_safe_globals()",
            "    _globals['_getattr_'] = guarded_getattr",
            "    _globals['__debug__' ] = __debug__",
            "",
            "    def __init__(self, name, expr, engine):",
            "        self.text = self.expr = text = expr.strip().replace('\\n', ' ')",
            "",
            "        # Unicode expression are not handled properly by RestrictedPython",
            "        # We convert the expression to UTF-8 (ajung)",
            "        if isinstance(text, unicode):",
            "            text = text.encode('utf-8')",
            "        code, err, warn, use = compile_restricted_eval(text, ",
            "                                                       self.__class__.__name__)",
            "        if err:",
            "            raise engine.getCompilerError()('Python expression error:\\n%s' %",
            "                                            '\\n'.join(err))            ",
            "        self._varnames = use.keys()",
            "        self._code = code",
            "",
            "    def __call__(self, econtext):",
            "        __traceback_info__ = self.text",
            "        vars = self._bind_used_names(econtext, {})",
            "        vars.update(self._globals)",
            "        return eval(self._code, vars, {})",
            "",
            "class _SecureModuleImporter:",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "    def __getitem__(self, module):",
            "        mod = safe_builtins['__import__'](module)",
            "        path = module.split('.')",
            "        for name in path[1:]:",
            "            mod = getattr(mod, name)",
            "        return mod",
            "",
            "from DocumentTemplate.DT_Util import TemplateDict, InstanceDict",
            "from AccessControl.DTML import RestrictedDTML",
            "class Rtd(RestrictedDTML, TemplateDict):",
            "    this = None",
            "",
            "def call_with_ns(f, ns, arg=1):",
            "    td = Rtd()",
            "    # prefer 'context' to 'here';  fall back to 'None'",
            "    this = ns.get('context', ns.get('here'))",
            "    td.this = this",
            "    request = ns.get('request', {})",
            "    if hasattr(request, 'taintWrapper'):",
            "        request = request.taintWrapper()",
            "    td._push(request)",
            "    td._push(InstanceDict(td.this, td))",
            "    td._push(ns)",
            "    try:",
            "        if arg==2:",
            "            return f(None, td)",
            "        else:",
            "            return f(td)",
            "    finally:",
            "        td._pop(3)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.urllib3.connection"
        ]
    },
    "src/Products/PageTemplates/tests/testZRPythonExpr.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         result = call_with_ns(_find_request, names)"
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         self.assertEqual(result, {})"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    def test_call_with_request_preserves_tainting(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        from Products.PageTemplates.ZRPythonExpr import call_with_ns"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        class Request(dict):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            def taintWrapper(self):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                return {'tainted': 'found'}"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        context = ['context']"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        here = ['here']"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        names = {'context' : context, 'here': here, 'request' : Request()}"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        found = call_with_ns(lambda td: td['tainted'], names)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        self.assertEqual(found, 'found')"
            },
            "15": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "  "
            },
            "16": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " def test_suite():"
            },
            "17": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     return unittest.makeSuite(MiscTests)"
            }
        },
        "frontPatchFile": [
            "\"\"\" Unit tests for Products.PageTemplates.ZRPythonExpr",
            "",
            "$Id",
            "\"\"\"",
            "import unittest",
            "",
            "class MiscTests(unittest.TestCase):",
            "",
            "    def test_call_with_ns_prefer_context_to_here(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        context = ['context']",
            "        here = ['here']",
            "        request = {'request': 1}",
            "        names = {'context' : context, 'here': here, 'request' : request}",
            "        result = call_with_ns(lambda td: td.this, names)",
            "        self.failUnless(result is context, result)",
            "",
            "    def test_call_with_ns_no_context_or_here(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        request = {'request': 1}",
            "        names = {'request' : request}",
            "        result = call_with_ns(lambda td: td.this, names)",
            "        self.failUnless(result is None, result)",
            "",
            "    def test_call_with_ns_no_request(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        context = ['context']",
            "        here = ['here']",
            "        names = {'context' : context, 'here': here}",
            "",
            "        def _find_request(td):",
            "            ns = td._pop()              # peel off 'ns'",
            "            instance_dict = td._pop()   # peel off InstanceDict",
            "            request = td._pop()",
            "            td._push(request)",
            "            td._push(instance_dict)",
            "            td._push(ns)",
            "            return request",
            "",
            "        result = call_with_ns(_find_request, names)",
            "        self.assertEqual(result, {})",
            " ",
            "def test_suite():",
            "    return unittest.makeSuite(MiscTests)",
            "",
            "if __name__ == '__main__':",
            "    unittest.main(defaultTest='test_suite')"
        ],
        "afterPatchFile": [
            "\"\"\" Unit tests for Products.PageTemplates.ZRPythonExpr",
            "",
            "$Id",
            "\"\"\"",
            "import unittest",
            "",
            "class MiscTests(unittest.TestCase):",
            "",
            "    def test_call_with_ns_prefer_context_to_here(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        context = ['context']",
            "        here = ['here']",
            "        request = {'request': 1}",
            "        names = {'context' : context, 'here': here, 'request' : request}",
            "        result = call_with_ns(lambda td: td.this, names)",
            "        self.failUnless(result is context, result)",
            "",
            "    def test_call_with_ns_no_context_or_here(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        request = {'request': 1}",
            "        names = {'request' : request}",
            "        result = call_with_ns(lambda td: td.this, names)",
            "        self.failUnless(result is None, result)",
            "",
            "    def test_call_with_ns_no_request(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        context = ['context']",
            "        here = ['here']",
            "        names = {'context' : context, 'here': here}",
            "",
            "        def _find_request(td):",
            "            ns = td._pop()              # peel off 'ns'",
            "            instance_dict = td._pop()   # peel off InstanceDict",
            "            request = td._pop()",
            "            td._push(request)",
            "            td._push(instance_dict)",
            "            td._push(ns)",
            "            return request",
            "",
            "        result = call_with_ns(_find_request, names)",
            "        self.assertEqual(result, {})",
            "",
            "    def test_call_with_request_preserves_tainting(self):",
            "        from Products.PageTemplates.ZRPythonExpr import call_with_ns",
            "        class Request(dict):",
            "            def taintWrapper(self):",
            "                return {'tainted': 'found'}",
            "        context = ['context']",
            "        here = ['here']",
            "        names = {'context' : context, 'here': here, 'request' : Request()}",
            "",
            "        found = call_with_ns(lambda td: td['tainted'], names)",
            "        self.assertEqual(found, 'found')",
            " ",
            "def test_suite():",
            "    return unittest.makeSuite(MiscTests)",
            "",
            "if __name__ == '__main__':",
            "    unittest.main(defaultTest='test_suite')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.urllib3.connection",
            "src.Products.PageTemplates.tests.testZRPythonExpr.MiscTests.self"
        ]
    }
}