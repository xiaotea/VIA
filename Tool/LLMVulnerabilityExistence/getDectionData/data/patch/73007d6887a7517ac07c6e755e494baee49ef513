{
    "jose/jwk.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from jose.constants import ALGORITHMS"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from jose.exceptions import JWKError"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from jose.utils import base64url_decode"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from jose.utils import constant_time_string_compare"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " # PyCryptodome's RSA module doesn't have PyCrypto's _RSAobj class"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " # Instead it has a class named RsaKey, which serves the same purpose."
            },
            "7": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         return hmac.new(self.prepared_key, msg, self.hash_alg).digest()"
            },
            "8": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     def verify(self, msg, sig):"
            },
            "10": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return sig == self.sign(msg)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        return constant_time_string_compare(sig, self.sign(msg))"
            },
            "12": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " class RSAKey(Key):"
            }
        },
        "frontPatchFile": [
            "",
            "import base64",
            "import hashlib",
            "import hmac",
            "import struct",
            "import six",
            "import sys",
            "",
            "import Crypto.Hash.SHA256",
            "import Crypto.Hash.SHA384",
            "import Crypto.Hash.SHA512",
            "",
            "from Crypto.PublicKey import RSA",
            "from Crypto.Signature import PKCS1_v1_5",
            "from Crypto.Util.asn1 import DerSequence",
            "",
            "import ecdsa",
            "",
            "from jose.constants import ALGORITHMS",
            "from jose.exceptions import JWKError",
            "from jose.utils import base64url_decode",
            "",
            "# PyCryptodome's RSA module doesn't have PyCrypto's _RSAobj class",
            "# Instead it has a class named RsaKey, which serves the same purpose.",
            "if hasattr(RSA, '_RSAobj'):",
            "    _RSAKey = RSA._RSAobj",
            "else:",
            "    _RSAKey = RSA.RsaKey",
            "",
            "# Deal with integer compatibilities between Python 2 and 3.",
            "# Using `from builtins import int` is not supported on AppEngine.",
            "if sys.version_info > (3,):",
            "    long = int",
            "",
            "",
            "def int_arr_to_long(arr):",
            "    return long(''.join([\"%02x\" % byte for byte in arr]), 16)",
            "",
            "",
            "def base64_to_long(data):",
            "    if isinstance(data, six.text_type):",
            "        data = data.encode(\"ascii\")",
            "",
            "    # urlsafe_b64decode will happily convert b64encoded data",
            "    _d = base64.urlsafe_b64decode(bytes(data) + b'==')",
            "    return int_arr_to_long(struct.unpack('%sB' % len(_d), _d))",
            "",
            "",
            "def construct(key_data, algorithm=None):",
            "    \"\"\"",
            "    Construct a Key object for the given algorithm with the given",
            "    key_data.",
            "    \"\"\"",
            "",
            "    # Allow for pulling the algorithm off of the passed in jwk.",
            "    if not algorithm and isinstance(key_data, dict):",
            "        algorithm = key_data.get('alg', None)",
            "",
            "    if not algorithm:",
            "        raise JWKError('Unable to find a algorithm for key: %s' % key_data)",
            "",
            "    if algorithm in ALGORITHMS.HMAC:",
            "        return HMACKey(key_data, algorithm)",
            "",
            "    if algorithm in ALGORITHMS.RSA:",
            "        return RSAKey(key_data, algorithm)",
            "",
            "    if algorithm in ALGORITHMS.EC:",
            "        return ECKey(key_data, algorithm)",
            "",
            "",
            "def get_algorithm_object(algorithm):",
            "",
            "    algorithms = {",
            "        ALGORITHMS.HS256: HMACKey.SHA256,",
            "        ALGORITHMS.HS384: HMACKey.SHA384,",
            "        ALGORITHMS.HS512: HMACKey.SHA512,",
            "        ALGORITHMS.RS256: RSAKey.SHA256,",
            "        ALGORITHMS.RS384: RSAKey.SHA384,",
            "        ALGORITHMS.RS512: RSAKey.SHA512,",
            "        ALGORITHMS.ES256: ECKey.SHA256,",
            "        ALGORITHMS.ES384: ECKey.SHA384,",
            "        ALGORITHMS.ES512: ECKey.SHA512,",
            "    }",
            "",
            "    return algorithms.get(algorithm, None)",
            "",
            "",
            "class Key(object):",
            "    \"\"\"",
            "    A simple interface for implementing JWK keys.",
            "    \"\"\"",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        raise NotImplementedError()",
            "",
            "    def sign(self, msg):",
            "        raise NotImplementedError()",
            "",
            "    def verify(self, msg, sig):",
            "        raise NotImplementedError()",
            "",
            "",
            "class HMACKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using HMAC",
            "    and the specified hash function.",
            "    \"\"\"",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "    valid_hash_algs = ALGORITHMS.HMAC",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def __init__(self, key, algorithm):",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        if isinstance(key, dict):",
            "            self.prepared_key = self._process_jwk(key)",
            "            return",
            "",
            "        if not isinstance(key, six.string_types) and not isinstance(key, bytes):",
            "            raise JWKError('Expecting a string- or bytes-formatted key.')",
            "",
            "        if isinstance(key, six.text_type):",
            "            key = key.encode('utf-8')",
            "",
            "        invalid_strings = [",
            "            b'-----BEGIN PUBLIC KEY-----',",
            "            b'-----BEGIN CERTIFICATE-----',",
            "            b'ssh-rsa'",
            "        ]",
            "",
            "        if any([string_value in key for string_value in invalid_strings]):",
            "            raise JWKError(",
            "                'The specified key is an asymmetric key or x509 certificate and'",
            "                ' should not be used as an HMAC secret.')",
            "",
            "        self.prepared_key = key",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'oct':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'oct', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        k = jwk_dict.get('k')",
            "        k = k.encode('utf-8')",
            "        k = bytes(k)",
            "        k = base64url_decode(k)",
            "",
            "        return k",
            "",
            "    def sign(self, msg):",
            "        return hmac.new(self.prepared_key, msg, self.hash_alg).digest()",
            "",
            "    def verify(self, msg, sig):",
            "        return sig == self.sign(msg)",
            "",
            "",
            "class RSAKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using",
            "    RSASSA-PKCS-v1_5 and the specified hash function.",
            "    This class requires PyCrypto package to be installed.",
            "    This is based off of the implementation in PyJWT 0.3.2",
            "    \"\"\"",
            "",
            "    SHA256 = Crypto.Hash.SHA256",
            "    SHA384 = Crypto.Hash.SHA384",
            "    SHA512 = Crypto.Hash.SHA512",
            "    valid_hash_algs = ALGORITHMS.RSA",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def __init__(self, key, algorithm):",
            "",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        if isinstance(key, _RSAKey):",
            "            self.prepared_key = key",
            "            return",
            "",
            "        if isinstance(key, dict):",
            "            self._process_jwk(key)",
            "            return",
            "",
            "        if isinstance(key, six.string_types):",
            "            if isinstance(key, six.text_type):",
            "                key = key.encode('utf-8')",
            "",
            "            if key.startswith(b'-----BEGIN CERTIFICATE-----'):",
            "                try:",
            "                    self._process_cert(key)",
            "                except Exception as e:",
            "                    raise JWKError(e)",
            "                return",
            "",
            "            try:",
            "                self.prepared_key = RSA.importKey(key)",
            "            except Exception as e:",
            "                raise JWKError(e)",
            "            return",
            "",
            "        raise JWKError('Unable to parse an RSA_JWK from key: %s' % key)",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'RSA':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'RSA', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        e = base64_to_long(jwk_dict.get('e', 256))",
            "        n = base64_to_long(jwk_dict.get('n'))",
            "",
            "        self.prepared_key = RSA.construct((n, e))",
            "        return self.prepared_key",
            "",
            "    def _process_cert(self, key):",
            "        pemLines = key.replace(b' ', b'').split()",
            "        certDer = base64url_decode(b''.join(pemLines[1:-1]))",
            "        certSeq = DerSequence()",
            "        certSeq.decode(certDer)",
            "        tbsSeq = DerSequence()",
            "        tbsSeq.decode(certSeq[0])",
            "        self.prepared_key = RSA.importKey(tbsSeq[6])",
            "        return",
            "",
            "    def sign(self, msg):",
            "        try:",
            "            return PKCS1_v1_5.new(self.prepared_key).sign(self.hash_alg.new(msg))",
            "        except Exception as e:",
            "            raise JWKError(e)",
            "",
            "    def verify(self, msg, sig):",
            "        try:",
            "            return PKCS1_v1_5.new(self.prepared_key).verify(self.hash_alg.new(msg), sig)",
            "        except Exception as e:",
            "            raise JWKError(e)",
            "",
            "",
            "class ECKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using",
            "    ECDSA and the specified hash function",
            "",
            "    This class requires the ecdsa package to be installed.",
            "",
            "    This is based off of the implementation in PyJWT 0.3.2",
            "    \"\"\"",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "    valid_hash_algs = ALGORITHMS.EC",
            "",
            "    curve_map = {",
            "        SHA256: ecdsa.curves.NIST256p,",
            "        SHA384: ecdsa.curves.NIST384p,",
            "        SHA512: ecdsa.curves.NIST521p,",
            "    }",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "    curve = None",
            "",
            "    def __init__(self, key, algorithm):",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        self.curve = self.curve_map.get(self.hash_alg)",
            "",
            "        if isinstance(key, (ecdsa.SigningKey, ecdsa.VerifyingKey)):",
            "            self.prepared_key = key",
            "            return",
            "",
            "        if isinstance(key, dict):",
            "            self.prepared_key = self._process_jwk(key)",
            "            return",
            "",
            "        if isinstance(key, six.string_types):",
            "            if isinstance(key, six.text_type):",
            "                key = key.encode('utf-8')",
            "",
            "            # Attempt to load key. We don't know if it's",
            "            # a Signing Key or a Verifying Key, so we try",
            "            # the Verifying Key first.",
            "            try:",
            "                key = ecdsa.VerifyingKey.from_pem(key)",
            "            except ecdsa.der.UnexpectedDER:",
            "                key = ecdsa.SigningKey.from_pem(key)",
            "            except Exception as e:",
            "                raise JWKError(e)",
            "",
            "            self.prepared_key = key",
            "            return",
            "",
            "        raise JWKError('Unable to parse an ECKey from key: %s' % key)",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'EC':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'EC', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        x = base64_to_long(jwk_dict.get('x'))",
            "        y = base64_to_long(jwk_dict.get('y'))",
            "",
            "        if not ecdsa.ecdsa.point_is_valid(self.curve.generator, x, y):",
            "            raise JWKError(\"Point: %s, %s is not a valid point\" % (x, y))",
            "",
            "        point = ecdsa.ellipticcurve.Point(self.curve.curve, x, y, self.curve.order)",
            "        verifying_key = ecdsa.keys.VerifyingKey.from_public_point(point, self.curve)",
            "",
            "        return verifying_key",
            "",
            "    def sign(self, msg):",
            "        return self.prepared_key.sign(msg, hashfunc=self.hash_alg, sigencode=ecdsa.util.sigencode_string)",
            "",
            "    def verify(self, msg, sig):",
            "        try:",
            "            return self.prepared_key.verify(sig, msg, hashfunc=self.hash_alg, sigdecode=ecdsa.util.sigdecode_string)",
            "        except:",
            "            return False"
        ],
        "afterPatchFile": [
            "",
            "import base64",
            "import hashlib",
            "import hmac",
            "import struct",
            "import six",
            "import sys",
            "",
            "import Crypto.Hash.SHA256",
            "import Crypto.Hash.SHA384",
            "import Crypto.Hash.SHA512",
            "",
            "from Crypto.PublicKey import RSA",
            "from Crypto.Signature import PKCS1_v1_5",
            "from Crypto.Util.asn1 import DerSequence",
            "",
            "import ecdsa",
            "",
            "from jose.constants import ALGORITHMS",
            "from jose.exceptions import JWKError",
            "from jose.utils import base64url_decode",
            "from jose.utils import constant_time_string_compare",
            "",
            "# PyCryptodome's RSA module doesn't have PyCrypto's _RSAobj class",
            "# Instead it has a class named RsaKey, which serves the same purpose.",
            "if hasattr(RSA, '_RSAobj'):",
            "    _RSAKey = RSA._RSAobj",
            "else:",
            "    _RSAKey = RSA.RsaKey",
            "",
            "# Deal with integer compatibilities between Python 2 and 3.",
            "# Using `from builtins import int` is not supported on AppEngine.",
            "if sys.version_info > (3,):",
            "    long = int",
            "",
            "",
            "def int_arr_to_long(arr):",
            "    return long(''.join([\"%02x\" % byte for byte in arr]), 16)",
            "",
            "",
            "def base64_to_long(data):",
            "    if isinstance(data, six.text_type):",
            "        data = data.encode(\"ascii\")",
            "",
            "    # urlsafe_b64decode will happily convert b64encoded data",
            "    _d = base64.urlsafe_b64decode(bytes(data) + b'==')",
            "    return int_arr_to_long(struct.unpack('%sB' % len(_d), _d))",
            "",
            "",
            "def construct(key_data, algorithm=None):",
            "    \"\"\"",
            "    Construct a Key object for the given algorithm with the given",
            "    key_data.",
            "    \"\"\"",
            "",
            "    # Allow for pulling the algorithm off of the passed in jwk.",
            "    if not algorithm and isinstance(key_data, dict):",
            "        algorithm = key_data.get('alg', None)",
            "",
            "    if not algorithm:",
            "        raise JWKError('Unable to find a algorithm for key: %s' % key_data)",
            "",
            "    if algorithm in ALGORITHMS.HMAC:",
            "        return HMACKey(key_data, algorithm)",
            "",
            "    if algorithm in ALGORITHMS.RSA:",
            "        return RSAKey(key_data, algorithm)",
            "",
            "    if algorithm in ALGORITHMS.EC:",
            "        return ECKey(key_data, algorithm)",
            "",
            "",
            "def get_algorithm_object(algorithm):",
            "",
            "    algorithms = {",
            "        ALGORITHMS.HS256: HMACKey.SHA256,",
            "        ALGORITHMS.HS384: HMACKey.SHA384,",
            "        ALGORITHMS.HS512: HMACKey.SHA512,",
            "        ALGORITHMS.RS256: RSAKey.SHA256,",
            "        ALGORITHMS.RS384: RSAKey.SHA384,",
            "        ALGORITHMS.RS512: RSAKey.SHA512,",
            "        ALGORITHMS.ES256: ECKey.SHA256,",
            "        ALGORITHMS.ES384: ECKey.SHA384,",
            "        ALGORITHMS.ES512: ECKey.SHA512,",
            "    }",
            "",
            "    return algorithms.get(algorithm, None)",
            "",
            "",
            "class Key(object):",
            "    \"\"\"",
            "    A simple interface for implementing JWK keys.",
            "    \"\"\"",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        raise NotImplementedError()",
            "",
            "    def sign(self, msg):",
            "        raise NotImplementedError()",
            "",
            "    def verify(self, msg, sig):",
            "        raise NotImplementedError()",
            "",
            "",
            "class HMACKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using HMAC",
            "    and the specified hash function.",
            "    \"\"\"",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "    valid_hash_algs = ALGORITHMS.HMAC",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def __init__(self, key, algorithm):",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        if isinstance(key, dict):",
            "            self.prepared_key = self._process_jwk(key)",
            "            return",
            "",
            "        if not isinstance(key, six.string_types) and not isinstance(key, bytes):",
            "            raise JWKError('Expecting a string- or bytes-formatted key.')",
            "",
            "        if isinstance(key, six.text_type):",
            "            key = key.encode('utf-8')",
            "",
            "        invalid_strings = [",
            "            b'-----BEGIN PUBLIC KEY-----',",
            "            b'-----BEGIN CERTIFICATE-----',",
            "            b'ssh-rsa'",
            "        ]",
            "",
            "        if any([string_value in key for string_value in invalid_strings]):",
            "            raise JWKError(",
            "                'The specified key is an asymmetric key or x509 certificate and'",
            "                ' should not be used as an HMAC secret.')",
            "",
            "        self.prepared_key = key",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'oct':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'oct', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        k = jwk_dict.get('k')",
            "        k = k.encode('utf-8')",
            "        k = bytes(k)",
            "        k = base64url_decode(k)",
            "",
            "        return k",
            "",
            "    def sign(self, msg):",
            "        return hmac.new(self.prepared_key, msg, self.hash_alg).digest()",
            "",
            "    def verify(self, msg, sig):",
            "        return constant_time_string_compare(sig, self.sign(msg))",
            "",
            "",
            "class RSAKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using",
            "    RSASSA-PKCS-v1_5 and the specified hash function.",
            "    This class requires PyCrypto package to be installed.",
            "    This is based off of the implementation in PyJWT 0.3.2",
            "    \"\"\"",
            "",
            "    SHA256 = Crypto.Hash.SHA256",
            "    SHA384 = Crypto.Hash.SHA384",
            "    SHA512 = Crypto.Hash.SHA512",
            "    valid_hash_algs = ALGORITHMS.RSA",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "",
            "    def __init__(self, key, algorithm):",
            "",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        if isinstance(key, _RSAKey):",
            "            self.prepared_key = key",
            "            return",
            "",
            "        if isinstance(key, dict):",
            "            self._process_jwk(key)",
            "            return",
            "",
            "        if isinstance(key, six.string_types):",
            "            if isinstance(key, six.text_type):",
            "                key = key.encode('utf-8')",
            "",
            "            if key.startswith(b'-----BEGIN CERTIFICATE-----'):",
            "                try:",
            "                    self._process_cert(key)",
            "                except Exception as e:",
            "                    raise JWKError(e)",
            "                return",
            "",
            "            try:",
            "                self.prepared_key = RSA.importKey(key)",
            "            except Exception as e:",
            "                raise JWKError(e)",
            "            return",
            "",
            "        raise JWKError('Unable to parse an RSA_JWK from key: %s' % key)",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'RSA':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'RSA', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        e = base64_to_long(jwk_dict.get('e', 256))",
            "        n = base64_to_long(jwk_dict.get('n'))",
            "",
            "        self.prepared_key = RSA.construct((n, e))",
            "        return self.prepared_key",
            "",
            "    def _process_cert(self, key):",
            "        pemLines = key.replace(b' ', b'').split()",
            "        certDer = base64url_decode(b''.join(pemLines[1:-1]))",
            "        certSeq = DerSequence()",
            "        certSeq.decode(certDer)",
            "        tbsSeq = DerSequence()",
            "        tbsSeq.decode(certSeq[0])",
            "        self.prepared_key = RSA.importKey(tbsSeq[6])",
            "        return",
            "",
            "    def sign(self, msg):",
            "        try:",
            "            return PKCS1_v1_5.new(self.prepared_key).sign(self.hash_alg.new(msg))",
            "        except Exception as e:",
            "            raise JWKError(e)",
            "",
            "    def verify(self, msg, sig):",
            "        try:",
            "            return PKCS1_v1_5.new(self.prepared_key).verify(self.hash_alg.new(msg), sig)",
            "        except Exception as e:",
            "            raise JWKError(e)",
            "",
            "",
            "class ECKey(Key):",
            "    \"\"\"",
            "    Performs signing and verification operations using",
            "    ECDSA and the specified hash function",
            "",
            "    This class requires the ecdsa package to be installed.",
            "",
            "    This is based off of the implementation in PyJWT 0.3.2",
            "    \"\"\"",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "    valid_hash_algs = ALGORITHMS.EC",
            "",
            "    curve_map = {",
            "        SHA256: ecdsa.curves.NIST256p,",
            "        SHA384: ecdsa.curves.NIST384p,",
            "        SHA512: ecdsa.curves.NIST521p,",
            "    }",
            "",
            "    prepared_key = None",
            "    hash_alg = None",
            "    curve = None",
            "",
            "    def __init__(self, key, algorithm):",
            "        if algorithm not in self.valid_hash_algs:",
            "            raise JWKError('hash_alg: %s is not a valid hash algorithm' % algorithm)",
            "        self.hash_alg = get_algorithm_object(algorithm)",
            "",
            "        self.curve = self.curve_map.get(self.hash_alg)",
            "",
            "        if isinstance(key, (ecdsa.SigningKey, ecdsa.VerifyingKey)):",
            "            self.prepared_key = key",
            "            return",
            "",
            "        if isinstance(key, dict):",
            "            self.prepared_key = self._process_jwk(key)",
            "            return",
            "",
            "        if isinstance(key, six.string_types):",
            "            if isinstance(key, six.text_type):",
            "                key = key.encode('utf-8')",
            "",
            "            # Attempt to load key. We don't know if it's",
            "            # a Signing Key or a Verifying Key, so we try",
            "            # the Verifying Key first.",
            "            try:",
            "                key = ecdsa.VerifyingKey.from_pem(key)",
            "            except ecdsa.der.UnexpectedDER:",
            "                key = ecdsa.SigningKey.from_pem(key)",
            "            except Exception as e:",
            "                raise JWKError(e)",
            "",
            "            self.prepared_key = key",
            "            return",
            "",
            "        raise JWKError('Unable to parse an ECKey from key: %s' % key)",
            "",
            "    def _process_jwk(self, jwk_dict):",
            "        if not jwk_dict.get('kty') == 'EC':",
            "            raise JWKError(\"Incorrect key type.  Expected: 'EC', Recieved: %s\" % jwk_dict.get('kty'))",
            "",
            "        x = base64_to_long(jwk_dict.get('x'))",
            "        y = base64_to_long(jwk_dict.get('y'))",
            "",
            "        if not ecdsa.ecdsa.point_is_valid(self.curve.generator, x, y):",
            "            raise JWKError(\"Point: %s, %s is not a valid point\" % (x, y))",
            "",
            "        point = ecdsa.ellipticcurve.Point(self.curve.curve, x, y, self.curve.order)",
            "        verifying_key = ecdsa.keys.VerifyingKey.from_public_point(point, self.curve)",
            "",
            "        return verifying_key",
            "",
            "    def sign(self, msg):",
            "        return self.prepared_key.sign(msg, hashfunc=self.hash_alg, sigencode=ecdsa.util.sigencode_string)",
            "",
            "    def verify(self, msg, sig):",
            "        try:",
            "            return self.prepared_key.verify(sig, msg, hashfunc=self.hash_alg, sigdecode=ecdsa.util.sigdecode_string)",
            "        except:",
            "            return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "162": [
                "HMACKey",
                "verify"
            ]
        },
        "addLocation": []
    },
    "jose/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import base64"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import hmac"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " def calculate_at_hash(access_token, hash_alg):"
            },
            "6": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         delta (timedelta): A timedelta to convert to seconds."
            },
            "7": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     return delta.days * 24 * 60 * 60 + delta.seconds"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+def constant_time_string_compare(a, b):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    \"\"\"Helper for comparing string in constant time, independent"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    of the python version being used."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    Args:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        a (str): A string to compare"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        b (str): A string to compare"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    \"\"\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    try:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        return hmac.compare_digest(a, b)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    except AttributeError:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        if len(a) != len(b):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            return False"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        result = 0"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        for x, y in zip(a, b):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+            result |= ord(x) ^ ord(y)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        return result == 0"
            }
        },
        "frontPatchFile": [
            "",
            "import base64",
            "",
            "",
            "def calculate_at_hash(access_token, hash_alg):",
            "    \"\"\"Helper method for calculating an access token",
            "    hash, as described in http://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken",
            "",
            "    Its value is the base64url encoding of the left-most half of the hash of the octets",
            "    of the ASCII representation of the access_token value, where the hash algorithm",
            "    used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE",
            "    Header. For instance, if the alg is RS256, hash the access_token value with SHA-256,",
            "    then take the left-most 128 bits and base64url encode them. The at_hash value is a",
            "    case sensitive string.",
            "",
            "    Args:",
            "        access_token (str): An access token string.",
            "        hash_alg (callable): A callable returning a hash object, e.g. hashlib.sha256",
            "",
            "    \"\"\"",
            "    hash_digest = hash_alg(access_token.encode('utf-8')).digest()",
            "    cut_at = int(len(hash_digest) / 2)",
            "    truncated = hash_digest[:cut_at]",
            "    at_hash = base64url_encode(truncated)",
            "    return at_hash.decode('utf-8')",
            "",
            "",
            "def base64url_decode(input):",
            "    \"\"\"Helper method to base64url_decode a string.",
            "",
            "    Args:",
            "        input (str): A base64url_encoded string to decode.",
            "",
            "    \"\"\"",
            "    rem = len(input) % 4",
            "",
            "    if rem > 0:",
            "        input += b'=' * (4 - rem)",
            "",
            "    return base64.urlsafe_b64decode(input)",
            "",
            "",
            "def base64url_encode(input):",
            "    \"\"\"Helper method to base64url_encode a string.",
            "",
            "    Args:",
            "        input (str): A base64url_encoded string to encode.",
            "",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(input).replace(b'=', b'')",
            "",
            "",
            "def timedelta_total_seconds(delta):",
            "    \"\"\"Helper method to determine the total number of seconds",
            "    from a timedelta.",
            "",
            "    Args:",
            "        delta (timedelta): A timedelta to convert to seconds.",
            "    \"\"\"",
            "    return delta.days * 24 * 60 * 60 + delta.seconds"
        ],
        "afterPatchFile": [
            "",
            "import base64",
            "import hmac",
            "",
            "",
            "def calculate_at_hash(access_token, hash_alg):",
            "    \"\"\"Helper method for calculating an access token",
            "    hash, as described in http://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken",
            "",
            "    Its value is the base64url encoding of the left-most half of the hash of the octets",
            "    of the ASCII representation of the access_token value, where the hash algorithm",
            "    used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE",
            "    Header. For instance, if the alg is RS256, hash the access_token value with SHA-256,",
            "    then take the left-most 128 bits and base64url encode them. The at_hash value is a",
            "    case sensitive string.",
            "",
            "    Args:",
            "        access_token (str): An access token string.",
            "        hash_alg (callable): A callable returning a hash object, e.g. hashlib.sha256",
            "",
            "    \"\"\"",
            "    hash_digest = hash_alg(access_token.encode('utf-8')).digest()",
            "    cut_at = int(len(hash_digest) / 2)",
            "    truncated = hash_digest[:cut_at]",
            "    at_hash = base64url_encode(truncated)",
            "    return at_hash.decode('utf-8')",
            "",
            "",
            "def base64url_decode(input):",
            "    \"\"\"Helper method to base64url_decode a string.",
            "",
            "    Args:",
            "        input (str): A base64url_encoded string to decode.",
            "",
            "    \"\"\"",
            "    rem = len(input) % 4",
            "",
            "    if rem > 0:",
            "        input += b'=' * (4 - rem)",
            "",
            "    return base64.urlsafe_b64decode(input)",
            "",
            "",
            "def base64url_encode(input):",
            "    \"\"\"Helper method to base64url_encode a string.",
            "",
            "    Args:",
            "        input (str): A base64url_encoded string to encode.",
            "",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(input).replace(b'=', b'')",
            "",
            "",
            "def timedelta_total_seconds(delta):",
            "    \"\"\"Helper method to determine the total number of seconds",
            "    from a timedelta.",
            "",
            "    Args:",
            "        delta (timedelta): A timedelta to convert to seconds.",
            "    \"\"\"",
            "    return delta.days * 24 * 60 * 60 + delta.seconds",
            "",
            "",
            "def constant_time_string_compare(a, b):",
            "    \"\"\"Helper for comparing string in constant time, independent",
            "    of the python version being used.",
            "",
            "    Args:",
            "        a (str): A string to compare",
            "        b (str): A string to compare",
            "    \"\"\"",
            "",
            "    try:",
            "        return hmac.compare_digest(a, b)",
            "    except AttributeError:",
            "",
            "        if len(a) != len(b):",
            "            return False",
            "",
            "        result = 0",
            "",
            "        for x, y in zip(a, b):",
            "            result |= ord(x) ^ ord(y)",
            "",
            "        return result == 0"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.constants.get_config"
        ]
    }
}