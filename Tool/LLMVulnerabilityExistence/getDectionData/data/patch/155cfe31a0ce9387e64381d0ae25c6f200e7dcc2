{
    "airflow/models/dag.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " import airflow.templates"
            },
            "1": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " from airflow import settings, utils"
            },
            "2": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " from airflow.api_internal.internal_api_call import internal_api_call"
            },
            "3": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from airflow.configuration import conf, secrets_backend_list"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+from airflow.configuration import conf as airflow_conf, secrets_backend_list"
            },
            "5": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " from airflow.exceptions import ("
            },
            "6": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     AirflowDagInconsistent,"
            },
            "7": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     AirflowException,"
            },
            "8": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " from airflow.models.baseoperator import BaseOperator"
            },
            "9": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " from airflow.models.dagcode import DagCode"
            },
            "10": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " from airflow.models.dagpickle import DagPickle"
            },
            "11": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from airflow.models.dagrun import DagRun"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+from airflow.models.dagrun import RUN_ID_REGEX, DagRun"
            },
            "13": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " from airflow.models.operator import Operator"
            },
            "14": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " from airflow.models.param import DagParam, ParamsDict"
            },
            "15": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " from airflow.models.taskinstance import Context, TaskInstance, TaskInstanceKey, clear_task_instances"
            },
            "16": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "         user_defined_filters: dict | None = None,"
            },
            "17": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         default_args: dict | None = None,"
            },
            "18": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "         concurrency: int | None = None,"
            },
            "19": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_active_tasks: int = conf.getint(\"core\", \"max_active_tasks_per_dag\"),"
            },
            "20": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_active_runs: int = conf.getint(\"core\", \"max_active_runs_per_dag\"),"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        max_active_tasks: int = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\"),"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        max_active_runs: int = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\"),"
            },
            "23": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "         dagrun_timeout: timedelta | None = None,"
            },
            "24": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "         sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,"
            },
            "25": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        default_view: str = conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),"
            },
            "26": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        orientation: str = conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),"
            },
            "27": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        catchup: bool = conf.getboolean(\"scheduler\", \"catchup_by_default\"),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        default_view: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+        orientation: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+        catchup: bool = airflow_conf.getboolean(\"scheduler\", \"catchup_by_default\"),"
            },
            "31": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,"
            },
            "32": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,"
            },
            "33": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         doc_md: str | None = None,"
            },
            "34": {
                "beforePatchRowNumber": 2588,
                "afterPatchRowNumber": 2588,
                "PatchRowcode": "         mark_success=False,"
            },
            "35": {
                "beforePatchRowNumber": 2589,
                "afterPatchRowNumber": 2589,
                "PatchRowcode": "         local=False,"
            },
            "36": {
                "beforePatchRowNumber": 2590,
                "afterPatchRowNumber": 2590,
                "PatchRowcode": "         executor=None,"
            },
            "37": {
                "beforePatchRowNumber": 2591,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        donot_pickle=conf.getboolean(\"core\", \"donot_pickle\"),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2591,
                "PatchRowcode": "+        donot_pickle=airflow_conf.getboolean(\"core\", \"donot_pickle\"),"
            },
            "39": {
                "beforePatchRowNumber": 2592,
                "afterPatchRowNumber": 2592,
                "PatchRowcode": "         ignore_task_deps=False,"
            },
            "40": {
                "beforePatchRowNumber": 2593,
                "afterPatchRowNumber": 2593,
                "PatchRowcode": "         ignore_first_depends_on_past=True,"
            },
            "41": {
                "beforePatchRowNumber": 2594,
                "afterPatchRowNumber": 2594,
                "PatchRowcode": "         pool=None,"
            },
            "42": {
                "beforePatchRowNumber": 2826,
                "afterPatchRowNumber": 2826,
                "PatchRowcode": "                 \"Creating DagRun needs either `run_id` or both `run_type` and `execution_date`\""
            },
            "43": {
                "beforePatchRowNumber": 2827,
                "afterPatchRowNumber": 2827,
                "PatchRowcode": "             )"
            },
            "44": {
                "beforePatchRowNumber": 2828,
                "afterPatchRowNumber": 2828,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 2829,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if run_id and \"/\" in run_id:"
            },
            "46": {
                "beforePatchRowNumber": 2830,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warnings.warn("
            },
            "47": {
                "beforePatchRowNumber": 2831,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Using forward slash ('/') in a DAG run ID is deprecated. Note that this character \""
            },
            "48": {
                "beforePatchRowNumber": 2832,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"also makes the run impossible to retrieve via Airflow's REST API.\","
            },
            "49": {
                "beforePatchRowNumber": 2833,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                RemovedInAirflow3Warning,"
            },
            "50": {
                "beforePatchRowNumber": 2834,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                stacklevel=3,"
            },
            "51": {
                "beforePatchRowNumber": 2835,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2829,
                "PatchRowcode": "+        regex = airflow_conf.get(\"scheduler\", \"allowed_run_id_pattern\")"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2830,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2831,
                "PatchRowcode": "+        if run_id and not re.match(RUN_ID_REGEX, run_id):"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2832,
                "PatchRowcode": "+            if not regex.strip() or not re.match(regex.strip(), run_id):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2833,
                "PatchRowcode": "+                raise AirflowException("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2834,
                "PatchRowcode": "+                    f\"The provided run ID '{run_id}' is invalid. It does not match either \""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2835,
                "PatchRowcode": "+                    f\"the configured pattern: '{regex}' or the built-in pattern: '{RUN_ID_REGEX}'\""
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2836,
                "PatchRowcode": "+                )"
            },
            "60": {
                "beforePatchRowNumber": 2836,
                "afterPatchRowNumber": 2837,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 2837,
                "afterPatchRowNumber": 2838,
                "PatchRowcode": "         # create a copy of params before validating"
            },
            "62": {
                "beforePatchRowNumber": 2838,
                "afterPatchRowNumber": 2839,
                "PatchRowcode": "         copied_params = copy.deepcopy(self.params)"
            },
            "63": {
                "beforePatchRowNumber": 3125,
                "afterPatchRowNumber": 3126,
                "PatchRowcode": "     def get_default_view(self):"
            },
            "64": {
                "beforePatchRowNumber": 3126,
                "afterPatchRowNumber": 3127,
                "PatchRowcode": "         \"\"\"This is only there for backward compatible jinja2 templates.\"\"\""
            },
            "65": {
                "beforePatchRowNumber": 3127,
                "afterPatchRowNumber": 3128,
                "PatchRowcode": "         if self.default_view is None:"
            },
            "66": {
                "beforePatchRowNumber": 3128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return conf.get(\"webserver\", \"dag_default_view\").lower()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3129,
                "PatchRowcode": "+            return airflow_conf.get(\"webserver\", \"dag_default_view\").lower()"
            },
            "68": {
                "beforePatchRowNumber": 3129,
                "afterPatchRowNumber": 3130,
                "PatchRowcode": "         else:"
            },
            "69": {
                "beforePatchRowNumber": 3130,
                "afterPatchRowNumber": 3131,
                "PatchRowcode": "             return self.default_view"
            },
            "70": {
                "beforePatchRowNumber": 3131,
                "afterPatchRowNumber": 3132,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 3342,
                "afterPatchRowNumber": 3343,
                "PatchRowcode": "     root_dag_id = Column(StringID())"
            },
            "72": {
                "beforePatchRowNumber": 3343,
                "afterPatchRowNumber": 3344,
                "PatchRowcode": "     # A DAG can be paused from the UI / DB"
            },
            "73": {
                "beforePatchRowNumber": 3344,
                "afterPatchRowNumber": 3345,
                "PatchRowcode": "     # Set this default value of is_paused based on a configuration value!"
            },
            "74": {
                "beforePatchRowNumber": 3345,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    is_paused_at_creation = conf.getboolean(\"core\", \"dags_are_paused_at_creation\")"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3346,
                "PatchRowcode": "+    is_paused_at_creation = airflow_conf.getboolean(\"core\", \"dags_are_paused_at_creation\")"
            },
            "76": {
                "beforePatchRowNumber": 3346,
                "afterPatchRowNumber": 3347,
                "PatchRowcode": "     is_paused = Column(Boolean, default=is_paused_at_creation)"
            },
            "77": {
                "beforePatchRowNumber": 3347,
                "afterPatchRowNumber": 3348,
                "PatchRowcode": "     # Whether the DAG is a subdag"
            },
            "78": {
                "beforePatchRowNumber": 3348,
                "afterPatchRowNumber": 3349,
                "PatchRowcode": "     is_subdag = Column(Boolean, default=False)"
            },
            "79": {
                "beforePatchRowNumber": 3416,
                "afterPatchRowNumber": 3417,
                "PatchRowcode": "         \"TaskOutletDatasetReference\","
            },
            "80": {
                "beforePatchRowNumber": 3417,
                "afterPatchRowNumber": 3418,
                "PatchRowcode": "         cascade=\"all, delete, delete-orphan\","
            },
            "81": {
                "beforePatchRowNumber": 3418,
                "afterPatchRowNumber": 3419,
                "PatchRowcode": "     )"
            },
            "82": {
                "beforePatchRowNumber": 3419,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    NUM_DAGS_PER_DAGRUN_QUERY = conf.getint(\"scheduler\", \"max_dagruns_to_create_per_loop\", fallback=10)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3420,
                "PatchRowcode": "+    NUM_DAGS_PER_DAGRUN_QUERY = airflow_conf.getint("
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3421,
                "PatchRowcode": "+        \"scheduler\", \"max_dagruns_to_create_per_loop\", fallback=10"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3422,
                "PatchRowcode": "+    )"
            },
            "86": {
                "beforePatchRowNumber": 3420,
                "afterPatchRowNumber": 3423,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 3421,
                "afterPatchRowNumber": 3424,
                "PatchRowcode": "     def __init__(self, concurrency=None, **kwargs):"
            },
            "88": {
                "beforePatchRowNumber": 3422,
                "afterPatchRowNumber": 3425,
                "PatchRowcode": "         super().__init__(**kwargs)"
            },
            "89": {
                "beforePatchRowNumber": 3429,
                "afterPatchRowNumber": 3432,
                "PatchRowcode": "                 )"
            },
            "90": {
                "beforePatchRowNumber": 3430,
                "afterPatchRowNumber": 3433,
                "PatchRowcode": "                 self.max_active_tasks = concurrency"
            },
            "91": {
                "beforePatchRowNumber": 3431,
                "afterPatchRowNumber": 3434,
                "PatchRowcode": "             else:"
            },
            "92": {
                "beforePatchRowNumber": 3432,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.max_active_tasks = conf.getint(\"core\", \"max_active_tasks_per_dag\")"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3435,
                "PatchRowcode": "+                self.max_active_tasks = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\")"
            },
            "94": {
                "beforePatchRowNumber": 3433,
                "afterPatchRowNumber": 3436,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 3434,
                "afterPatchRowNumber": 3437,
                "PatchRowcode": "         if self.max_active_runs is None:"
            },
            "96": {
                "beforePatchRowNumber": 3435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.max_active_runs = conf.getint(\"core\", \"max_active_runs_per_dag\")"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3438,
                "PatchRowcode": "+            self.max_active_runs = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\")"
            },
            "98": {
                "beforePatchRowNumber": 3436,
                "afterPatchRowNumber": 3439,
                "PatchRowcode": " "
            },
            "99": {
                "beforePatchRowNumber": 3437,
                "afterPatchRowNumber": 3440,
                "PatchRowcode": "         if self.has_task_concurrency_limits is None:"
            },
            "100": {
                "beforePatchRowNumber": 3438,
                "afterPatchRowNumber": 3441,
                "PatchRowcode": "             # Be safe -- this will be updated later once the DAG is parsed"
            },
            "101": {
                "beforePatchRowNumber": 3510,
                "afterPatchRowNumber": 3513,
                "PatchRowcode": "         have a value."
            },
            "102": {
                "beforePatchRowNumber": 3511,
                "afterPatchRowNumber": 3514,
                "PatchRowcode": "         \"\"\""
            },
            "103": {
                "beforePatchRowNumber": 3512,
                "afterPatchRowNumber": 3515,
                "PatchRowcode": "         # This is for backwards-compatibility with old dags that don't have None as default_view"
            },
            "104": {
                "beforePatchRowNumber": 3513,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.default_view or conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower()"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3516,
                "PatchRowcode": "+        return self.default_view or airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower()"
            },
            "106": {
                "beforePatchRowNumber": 3514,
                "afterPatchRowNumber": 3517,
                "PatchRowcode": " "
            },
            "107": {
                "beforePatchRowNumber": 3515,
                "afterPatchRowNumber": 3518,
                "PatchRowcode": "     @property"
            },
            "108": {
                "beforePatchRowNumber": 3516,
                "afterPatchRowNumber": 3519,
                "PatchRowcode": "     def safe_dag_id(self):"
            },
            "109": {
                "beforePatchRowNumber": 3699,
                "afterPatchRowNumber": 3702,
                "PatchRowcode": "     user_defined_filters: dict | None = None,"
            },
            "110": {
                "beforePatchRowNumber": 3700,
                "afterPatchRowNumber": 3703,
                "PatchRowcode": "     default_args: dict | None = None,"
            },
            "111": {
                "beforePatchRowNumber": 3701,
                "afterPatchRowNumber": 3704,
                "PatchRowcode": "     concurrency: int | None = None,"
            },
            "112": {
                "beforePatchRowNumber": 3702,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    max_active_tasks: int = conf.getint(\"core\", \"max_active_tasks_per_dag\"),"
            },
            "113": {
                "beforePatchRowNumber": 3703,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    max_active_runs: int = conf.getint(\"core\", \"max_active_runs_per_dag\"),"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3705,
                "PatchRowcode": "+    max_active_tasks: int = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\"),"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3706,
                "PatchRowcode": "+    max_active_runs: int = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\"),"
            },
            "116": {
                "beforePatchRowNumber": 3704,
                "afterPatchRowNumber": 3707,
                "PatchRowcode": "     dagrun_timeout: timedelta | None = None,"
            },
            "117": {
                "beforePatchRowNumber": 3705,
                "afterPatchRowNumber": 3708,
                "PatchRowcode": "     sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,"
            },
            "118": {
                "beforePatchRowNumber": 3706,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    default_view: str = conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),"
            },
            "119": {
                "beforePatchRowNumber": 3707,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    orientation: str = conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),"
            },
            "120": {
                "beforePatchRowNumber": 3708,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    catchup: bool = conf.getboolean(\"scheduler\", \"catchup_by_default\"),"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3709,
                "PatchRowcode": "+    default_view: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3710,
                "PatchRowcode": "+    orientation: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3711,
                "PatchRowcode": "+    catchup: bool = airflow_conf.getboolean(\"scheduler\", \"catchup_by_default\"),"
            },
            "124": {
                "beforePatchRowNumber": 3709,
                "afterPatchRowNumber": 3712,
                "PatchRowcode": "     on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,"
            },
            "125": {
                "beforePatchRowNumber": 3710,
                "afterPatchRowNumber": 3713,
                "PatchRowcode": "     on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,"
            },
            "126": {
                "beforePatchRowNumber": 3711,
                "afterPatchRowNumber": 3714,
                "PatchRowcode": "     doc_md: str | None = None,"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import collections",
            "import collections.abc",
            "import copy",
            "import functools",
            "import itertools",
            "import logging",
            "import os",
            "import pathlib",
            "import pickle",
            "import sys",
            "import traceback",
            "import warnings",
            "import weakref",
            "from collections import deque",
            "from datetime import datetime, timedelta",
            "from inspect import signature",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Collection,",
            "    Container,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    Pattern,",
            "    Sequence,",
            "    Union,",
            "    cast,",
            "    overload,",
            ")",
            "from urllib.parse import urlsplit",
            "",
            "import jinja2",
            "import pendulum",
            "import re2 as re",
            "from dateutil.relativedelta import relativedelta",
            "from pendulum.tz.timezone import Timezone",
            "from sqlalchemy import (",
            "    Boolean,",
            "    Column,",
            "    ForeignKey,",
            "    Index,",
            "    Integer,",
            "    String,",
            "    Text,",
            "    and_,",
            "    case,",
            "    func,",
            "    not_,",
            "    or_,",
            "    select,",
            "    update,",
            ")",
            "from sqlalchemy.ext.associationproxy import association_proxy",
            "from sqlalchemy.orm import backref, joinedload, relationship",
            "from sqlalchemy.orm.query import Query",
            "from sqlalchemy.orm.session import Session",
            "from sqlalchemy.sql import Select, expression",
            "",
            "import airflow.templates",
            "from airflow import settings, utils",
            "from airflow.api_internal.internal_api_call import internal_api_call",
            "from airflow.configuration import conf, secrets_backend_list",
            "from airflow.exceptions import (",
            "    AirflowDagInconsistent,",
            "    AirflowException,",
            "    AirflowSkipException,",
            "    DagInvalidTriggerRule,",
            "    DuplicateTaskIdFound,",
            "    RemovedInAirflow3Warning,",
            "    TaskNotFound,",
            ")",
            "from airflow.jobs.job import run_job",
            "from airflow.models.abstractoperator import AbstractOperator",
            "from airflow.models.base import Base, StringID",
            "from airflow.models.baseoperator import BaseOperator",
            "from airflow.models.dagcode import DagCode",
            "from airflow.models.dagpickle import DagPickle",
            "from airflow.models.dagrun import DagRun",
            "from airflow.models.operator import Operator",
            "from airflow.models.param import DagParam, ParamsDict",
            "from airflow.models.taskinstance import Context, TaskInstance, TaskInstanceKey, clear_task_instances",
            "from airflow.secrets.local_filesystem import LocalFilesystemBackend",
            "from airflow.security import permissions",
            "from airflow.stats import Stats",
            "from airflow.timetables.base import DagRunInfo, DataInterval, TimeRestriction, Timetable",
            "from airflow.timetables.interval import CronDataIntervalTimetable, DeltaDataIntervalTimetable",
            "from airflow.timetables.simple import (",
            "    ContinuousTimetable,",
            "    DatasetTriggeredTimetable,",
            "    NullTimetable,",
            "    OnceTimetable,",
            ")",
            "from airflow.typing_compat import Literal",
            "from airflow.utils import timezone",
            "from airflow.utils.dag_cycle_tester import check_cycle",
            "from airflow.utils.dates import cron_presets, date_range as utils_date_range",
            "from airflow.utils.decorators import fixup_decorator_warning_stack",
            "from airflow.utils.helpers import at_most_one, exactly_one, validate_key",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import (",
            "    Interval,",
            "    UtcDateTime,",
            "    lock_rows,",
            "    skip_locked,",
            "    tuple_in_condition,",
            "    with_row_locks,",
            ")",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.types import NOTSET, ArgNotSet, DagRunType, EdgeInfoType",
            "",
            "if TYPE_CHECKING:",
            "    from types import ModuleType",
            "",
            "    from airflow.datasets import Dataset",
            "    from airflow.decorators import TaskDecoratorCollection",
            "    from airflow.models.dagbag import DagBag",
            "    from airflow.models.slamiss import SlaMiss",
            "    from airflow.utils.task_group import TaskGroup",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "DEFAULT_VIEW_PRESETS = [\"grid\", \"graph\", \"duration\", \"gantt\", \"landing_times\"]",
            "ORIENTATION_PRESETS = [\"LR\", \"TB\", \"RL\", \"BT\"]",
            "",
            "TAG_MAX_LEN = 100",
            "",
            "DagStateChangeCallback = Callable[[Context], None]",
            "ScheduleInterval = Union[None, str, timedelta, relativedelta]",
            "",
            "# FIXME: Ideally this should be Union[Literal[NOTSET], ScheduleInterval],",
            "# but Mypy cannot handle that right now. Track progress of PEP 661 for progress.",
            "# See also: https://discuss.python.org/t/9126/7",
            "ScheduleIntervalArg = Union[ArgNotSet, ScheduleInterval]",
            "ScheduleArg = Union[ArgNotSet, ScheduleInterval, Timetable, Collection[\"Dataset\"]]",
            "",
            "SLAMissCallback = Callable[[\"DAG\", str, str, List[\"SlaMiss\"], List[TaskInstance]], None]",
            "",
            "# Backward compatibility: If neither schedule_interval nor timetable is",
            "# *provided by the user*, default to a one-day interval.",
            "DEFAULT_SCHEDULE_INTERVAL = timedelta(days=1)",
            "",
            "",
            "class InconsistentDataInterval(AirflowException):",
            "    \"\"\"Exception raised when a model populates data interval fields incorrectly.",
            "",
            "    The data interval fields should either both be None (for runs scheduled",
            "    prior to AIP-39), or both be datetime (for runs scheduled after AIP-39 is",
            "    implemented). This is raised if exactly one of the fields is None.",
            "    \"\"\"",
            "",
            "    _template = (",
            "        \"Inconsistent {cls}: {start[0]}={start[1]!r}, {end[0]}={end[1]!r}, \"",
            "        \"they must be either both None or both datetime\"",
            "    )",
            "",
            "    def __init__(self, instance: Any, start_field_name: str, end_field_name: str) -> None:",
            "        self._class_name = type(instance).__name__",
            "        self._start_field = (start_field_name, getattr(instance, start_field_name))",
            "        self._end_field = (end_field_name, getattr(instance, end_field_name))",
            "",
            "    def __str__(self) -> str:",
            "        return self._template.format(cls=self._class_name, start=self._start_field, end=self._end_field)",
            "",
            "",
            "def _get_model_data_interval(",
            "    instance: Any,",
            "    start_field_name: str,",
            "    end_field_name: str,",
            ") -> DataInterval | None:",
            "    start = timezone.coerce_datetime(getattr(instance, start_field_name))",
            "    end = timezone.coerce_datetime(getattr(instance, end_field_name))",
            "    if start is None:",
            "        if end is not None:",
            "            raise InconsistentDataInterval(instance, start_field_name, end_field_name)",
            "        return None",
            "    elif end is None:",
            "        raise InconsistentDataInterval(instance, start_field_name, end_field_name)",
            "    return DataInterval(start, end)",
            "",
            "",
            "def create_timetable(interval: ScheduleIntervalArg, timezone: Timezone) -> Timetable:",
            "    \"\"\"Create a Timetable instance from a ``schedule_interval`` argument.\"\"\"",
            "    if interval is NOTSET:",
            "        return DeltaDataIntervalTimetable(DEFAULT_SCHEDULE_INTERVAL)",
            "    if interval is None:",
            "        return NullTimetable()",
            "    if interval == \"@once\":",
            "        return OnceTimetable()",
            "    if interval == \"@continuous\":",
            "        return ContinuousTimetable()",
            "    if isinstance(interval, (timedelta, relativedelta)):",
            "        return DeltaDataIntervalTimetable(interval)",
            "    if isinstance(interval, str):",
            "        return CronDataIntervalTimetable(interval, timezone)",
            "    raise ValueError(f\"{interval!r} is not a valid schedule_interval.\")",
            "",
            "",
            "def get_last_dagrun(dag_id, session, include_externally_triggered=False):",
            "    \"\"\"",
            "    Returns the last dag run for a dag, None if there was none.",
            "    Last dag run can be any type of run e.g. scheduled or backfilled.",
            "    Overridden DagRuns are ignored.",
            "    \"\"\"",
            "    DR = DagRun",
            "    query = select(DR).where(DR.dag_id == dag_id)",
            "    if not include_externally_triggered:",
            "        query = query.where(DR.external_trigger == expression.false())",
            "    query = query.order_by(DR.execution_date.desc())",
            "    return session.scalar(query.limit(1))",
            "",
            "",
            "def get_dataset_triggered_next_run_info(",
            "    dag_ids: list[str], *, session: Session",
            ") -> dict[str, dict[str, int | str]]:",
            "    \"\"\"",
            "    Given a list of dag_ids, get string representing how close any that are dataset triggered are",
            "    their next run, e.g. \"1 of 2 datasets updated\".",
            "    \"\"\"",
            "    from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue as DDRQ, DatasetModel",
            "",
            "    return {",
            "        x.dag_id: {",
            "            \"uri\": x.uri,",
            "            \"ready\": x.ready,",
            "            \"total\": x.total,",
            "        }",
            "        for x in session.execute(",
            "            select(",
            "                DagScheduleDatasetReference.dag_id,",
            "                # This is a dirty hack to workaround group by requiring an aggregate,",
            "                # since grouping by dataset is not what we want to do here...but it works",
            "                case((func.count() == 1, func.max(DatasetModel.uri)), else_=\"\").label(\"uri\"),",
            "                func.count().label(\"total\"),",
            "                func.sum(case((DDRQ.target_dag_id.is_not(None), 1), else_=0)).label(\"ready\"),",
            "            )",
            "            .join(",
            "                DDRQ,",
            "                and_(",
            "                    DDRQ.dataset_id == DagScheduleDatasetReference.dataset_id,",
            "                    DDRQ.target_dag_id == DagScheduleDatasetReference.dag_id,",
            "                ),",
            "                isouter=True,",
            "            )",
            "            .join(DatasetModel, DatasetModel.id == DagScheduleDatasetReference.dataset_id)",
            "            .group_by(DagScheduleDatasetReference.dag_id)",
            "            .where(DagScheduleDatasetReference.dag_id.in_(dag_ids))",
            "        ).all()",
            "    }",
            "",
            "",
            "@functools.total_ordering",
            "class DAG(LoggingMixin):",
            "    \"\"\"",
            "    A dag (directed acyclic graph) is a collection of tasks with directional",
            "    dependencies. A dag also has a schedule, a start date and an end date",
            "    (optional). For each schedule, (say daily or hourly), the DAG needs to run",
            "    each individual tasks as their dependencies are met. Certain tasks have",
            "    the property of depending on their own past, meaning that they can't run",
            "    until their previous schedule (and upstream tasks) are completed.",
            "",
            "    DAGs essentially act as namespaces for tasks. A task_id can only be",
            "    added once to a DAG.",
            "",
            "    Note that if you plan to use time zones all the dates provided should be pendulum",
            "    dates. See :ref:`timezone_aware_dags`.",
            "",
            "    .. versionadded:: 2.4",
            "        The *schedule* argument to specify either time-based scheduling logic",
            "        (timetable), or dataset-driven triggers.",
            "",
            "    .. deprecated:: 2.4",
            "        The arguments *schedule_interval* and *timetable*. Their functionalities",
            "        are merged into the new *schedule* argument.",
            "",
            "    :param dag_id: The id of the DAG; must consist exclusively of alphanumeric",
            "        characters, dashes, dots and underscores (all ASCII)",
            "    :param description: The description for the DAG to e.g. be shown on the webserver",
            "    :param schedule: Defines the rules according to which DAG runs are scheduled. Can",
            "        accept cron string, timedelta object, Timetable, or list of Dataset objects.",
            "        See also :doc:`/howto/timetable`.",
            "    :param start_date: The timestamp from which the scheduler will",
            "        attempt to backfill",
            "    :param end_date: A date beyond which your DAG won't run, leave to None",
            "        for open-ended scheduling",
            "    :param template_searchpath: This list of folders (non-relative)",
            "        defines where jinja will look for your templates. Order matters.",
            "        Note that jinja/airflow includes the path of your DAG file by",
            "        default",
            "    :param template_undefined: Template undefined type.",
            "    :param user_defined_macros: a dictionary of macros that will be exposed",
            "        in your jinja templates. For example, passing ``dict(foo='bar')``",
            "        to this argument allows you to ``{{ foo }}`` in all jinja",
            "        templates related to this DAG. Note that you can pass any",
            "        type of object here.",
            "    :param user_defined_filters: a dictionary of filters that will be exposed",
            "        in your jinja templates. For example, passing",
            "        ``dict(hello=lambda name: 'Hello %s' % name)`` to this argument allows",
            "        you to ``{{ 'world' | hello }}`` in all jinja templates related to",
            "        this DAG.",
            "    :param default_args: A dictionary of default parameters to be used",
            "        as constructor keyword parameters when initialising operators.",
            "        Note that operators have the same hook, and precede those defined",
            "        here, meaning that if your dict contains `'depends_on_past': True`",
            "        here and `'depends_on_past': False` in the operator's call",
            "        `default_args`, the actual value will be `False`.",
            "    :param params: a dictionary of DAG level parameters that are made",
            "        accessible in templates, namespaced under `params`. These",
            "        params can be overridden at the task level.",
            "    :param max_active_tasks: the number of task instances allowed to run",
            "        concurrently",
            "    :param max_active_runs: maximum number of active DAG runs, beyond this",
            "        number of DAG runs in a running state, the scheduler won't create",
            "        new active DAG runs",
            "    :param dagrun_timeout: specify how long a DagRun should be up before",
            "        timing out / failing, so that new DagRuns can be created.",
            "    :param sla_miss_callback: specify a function or list of functions to call when reporting SLA",
            "        timeouts. See :ref:`sla_miss_callback<concepts:sla_miss_callback>` for",
            "        more information about the function signature and parameters that are",
            "        passed to the callback.",
            "    :param default_view: Specify DAG default view (grid, graph, duration,",
            "                                                   gantt, landing_times), default grid",
            "    :param orientation: Specify DAG orientation in graph view (LR, TB, RL, BT), default LR",
            "    :param catchup: Perform scheduler catchup (or only run latest)? Defaults to True",
            "    :param on_failure_callback: A function or list of functions to be called when a DagRun of this dag fails.",
            "        A context dictionary is passed as a single parameter to this function.",
            "    :param on_success_callback: Much like the ``on_failure_callback`` except",
            "        that it is executed when the dag succeeds.",
            "    :param access_control: Specify optional DAG-level actions, e.g.,",
            "        \"{'role1': {'can_read'}, 'role2': {'can_read', 'can_edit', 'can_delete'}}\"",
            "    :param is_paused_upon_creation: Specifies if the dag is paused when created for the first time.",
            "        If the dag exists already, this flag will be ignored. If this optional parameter",
            "        is not specified, the global config setting will be used.",
            "    :param jinja_environment_kwargs: additional configuration options to be passed to Jinja",
            "        ``Environment`` for template rendering",
            "",
            "        **Example**: to avoid Jinja from removing a trailing newline from template strings ::",
            "",
            "            DAG(dag_id='my-dag',",
            "                jinja_environment_kwargs={",
            "                    'keep_trailing_newline': True,",
            "                    # some other jinja2 Environment options here",
            "                }",
            "            )",
            "",
            "        **See**: `Jinja Environment documentation",
            "        <https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment>`_",
            "",
            "    :param render_template_as_native_obj: If True, uses a Jinja ``NativeEnvironment``",
            "        to render templates as native Python types. If False, a Jinja",
            "        ``Environment`` is used to render templates as string values.",
            "    :param tags: List of tags to help filtering DAGs in the UI.",
            "    :param owner_links: Dict of owners and their links, that will be clickable on the DAGs view UI.",
            "        Can be used as an HTTP link (for example the link to your Slack channel), or a mailto link.",
            "        e.g: {\"dag_owner\": \"https://airflow.apache.org/\"}",
            "    :param auto_register: Automatically register this DAG when it is used in a ``with`` block",
            "    :param fail_stop: Fails currently running tasks when task in DAG fails.",
            "        **Warning**: A fail stop dag can only have tasks with the default trigger rule (\"all_success\").",
            "        An exception will be thrown if any task in a fail stop dag has a non default trigger rule.",
            "    \"\"\"",
            "",
            "    _comps = {",
            "        \"dag_id\",",
            "        \"task_ids\",",
            "        \"parent_dag\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"schedule_interval\",",
            "        \"fileloc\",",
            "        \"template_searchpath\",",
            "        \"last_loaded\",",
            "    }",
            "",
            "    __serialized_fields: frozenset[str] | None = None",
            "",
            "    fileloc: str",
            "    \"\"\"",
            "    File path that needs to be imported to load this DAG or subdag.",
            "",
            "    This may not be an actual file on disk in the case when this DAG is loaded",
            "    from a ZIP file or other DAG distribution format.",
            "    \"\"\"",
            "",
            "    parent_dag: DAG | None = None  # Gets set when DAGs are loaded",
            "",
            "    # NOTE: When updating arguments here, please also keep arguments in @dag()",
            "    # below in sync. (Search for 'def dag(' in this file.)",
            "    def __init__(",
            "        self,",
            "        dag_id: str,",
            "        description: str | None = None,",
            "        schedule: ScheduleArg = NOTSET,",
            "        schedule_interval: ScheduleIntervalArg = NOTSET,",
            "        timetable: Timetable | None = None,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        full_filepath: str | None = None,",
            "        template_searchpath: str | Iterable[str] | None = None,",
            "        template_undefined: type[jinja2.StrictUndefined] = jinja2.StrictUndefined,",
            "        user_defined_macros: dict | None = None,",
            "        user_defined_filters: dict | None = None,",
            "        default_args: dict | None = None,",
            "        concurrency: int | None = None,",
            "        max_active_tasks: int = conf.getint(\"core\", \"max_active_tasks_per_dag\"),",
            "        max_active_runs: int = conf.getint(\"core\", \"max_active_runs_per_dag\"),",
            "        dagrun_timeout: timedelta | None = None,",
            "        sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,",
            "        default_view: str = conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),",
            "        orientation: str = conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),",
            "        catchup: bool = conf.getboolean(\"scheduler\", \"catchup_by_default\"),",
            "        on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "        on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "        doc_md: str | None = None,",
            "        params: collections.abc.MutableMapping | None = None,",
            "        access_control: dict | None = None,",
            "        is_paused_upon_creation: bool | None = None,",
            "        jinja_environment_kwargs: dict | None = None,",
            "        render_template_as_native_obj: bool = False,",
            "        tags: list[str] | None = None,",
            "        owner_links: dict[str, str] | None = None,",
            "        auto_register: bool = True,",
            "        fail_stop: bool = False,",
            "    ):",
            "        from airflow.utils.task_group import TaskGroup",
            "",
            "        if tags and any(len(tag) > TAG_MAX_LEN for tag in tags):",
            "            raise AirflowException(f\"tag cannot be longer than {TAG_MAX_LEN} characters\")",
            "",
            "        self.owner_links = owner_links if owner_links else {}",
            "        self.user_defined_macros = user_defined_macros",
            "        self.user_defined_filters = user_defined_filters",
            "        if default_args and not isinstance(default_args, dict):",
            "            raise TypeError(\"default_args must be a dict\")",
            "        self.default_args = copy.deepcopy(default_args or {})",
            "        params = params or {}",
            "",
            "        # merging potentially conflicting default_args['params'] into params",
            "        if \"params\" in self.default_args:",
            "            params.update(self.default_args[\"params\"])",
            "            del self.default_args[\"params\"]",
            "",
            "        # check self.params and convert them into ParamsDict",
            "        self.params = ParamsDict(params)",
            "",
            "        if full_filepath:",
            "            warnings.warn(",
            "                \"Passing full_filepath to DAG() is deprecated and has no effect\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        validate_key(dag_id)",
            "",
            "        self._dag_id = dag_id",
            "        if concurrency:",
            "            # TODO: Remove in Airflow 3.0",
            "            warnings.warn(",
            "                \"The 'concurrency' parameter is deprecated. Please use 'max_active_tasks'.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            max_active_tasks = concurrency",
            "        self._max_active_tasks = max_active_tasks",
            "        self._pickle_id: int | None = None",
            "",
            "        self._description = description",
            "        # set file location to caller source path",
            "        back = sys._getframe().f_back",
            "        self.fileloc = back.f_code.co_filename if back else \"\"",
            "        self.task_dict: dict[str, Operator] = {}",
            "",
            "        # set timezone from start_date",
            "        tz = None",
            "        if start_date and start_date.tzinfo:",
            "            tzinfo = None if start_date.tzinfo else settings.TIMEZONE",
            "            tz = pendulum.instance(start_date, tz=tzinfo).timezone",
            "        elif \"start_date\" in self.default_args and self.default_args[\"start_date\"]:",
            "            date = self.default_args[\"start_date\"]",
            "            if not isinstance(date, datetime):",
            "                date = timezone.parse(date)",
            "                self.default_args[\"start_date\"] = date",
            "                start_date = date",
            "",
            "            tzinfo = None if date.tzinfo else settings.TIMEZONE",
            "            tz = pendulum.instance(date, tz=tzinfo).timezone",
            "        self.timezone = tz or settings.TIMEZONE",
            "",
            "        # Apply the timezone we settled on to end_date if it wasn't supplied",
            "        if \"end_date\" in self.default_args and self.default_args[\"end_date\"]:",
            "            if isinstance(self.default_args[\"end_date\"], str):",
            "                self.default_args[\"end_date\"] = timezone.parse(",
            "                    self.default_args[\"end_date\"], timezone=self.timezone",
            "                )",
            "",
            "        self.start_date = timezone.convert_to_utc(start_date)",
            "        self.end_date = timezone.convert_to_utc(end_date)",
            "",
            "        # also convert tasks",
            "        if \"start_date\" in self.default_args:",
            "            self.default_args[\"start_date\"] = timezone.convert_to_utc(self.default_args[\"start_date\"])",
            "        if \"end_date\" in self.default_args:",
            "            self.default_args[\"end_date\"] = timezone.convert_to_utc(self.default_args[\"end_date\"])",
            "",
            "        # sort out DAG's scheduling behavior",
            "        scheduling_args = [schedule_interval, timetable, schedule]",
            "        if not at_most_one(*scheduling_args):",
            "            raise ValueError(\"At most one allowed for args 'schedule_interval', 'timetable', and 'schedule'.\")",
            "        if schedule_interval is not NOTSET:",
            "            warnings.warn(",
            "                \"Param `schedule_interval` is deprecated and will be removed in a future release. \"",
            "                \"Please use `schedule` instead. \",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "        if timetable is not None:",
            "            warnings.warn(",
            "                \"Param `timetable` is deprecated and will be removed in a future release. \"",
            "                \"Please use `schedule` instead. \",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        self.timetable: Timetable",
            "        self.schedule_interval: ScheduleInterval",
            "        self.dataset_triggers: Collection[Dataset] = []",
            "",
            "        if isinstance(schedule, Collection) and not isinstance(schedule, str):",
            "            from airflow.datasets import Dataset",
            "",
            "            if not all(isinstance(x, Dataset) for x in schedule):",
            "                raise ValueError(\"All elements in 'schedule' should be datasets\")",
            "            self.dataset_triggers = list(schedule)",
            "        elif isinstance(schedule, Timetable):",
            "            timetable = schedule",
            "        elif schedule is not NOTSET:",
            "            schedule_interval = schedule",
            "",
            "        if self.dataset_triggers:",
            "            self.timetable = DatasetTriggeredTimetable()",
            "            self.schedule_interval = self.timetable.summary",
            "        elif timetable:",
            "            self.timetable = timetable",
            "            self.schedule_interval = self.timetable.summary",
            "        else:",
            "            if isinstance(schedule_interval, ArgNotSet):",
            "                schedule_interval = DEFAULT_SCHEDULE_INTERVAL",
            "            self.schedule_interval = schedule_interval",
            "            self.timetable = create_timetable(schedule_interval, self.timezone)",
            "",
            "        if isinstance(template_searchpath, str):",
            "            template_searchpath = [template_searchpath]",
            "        self.template_searchpath = template_searchpath",
            "        self.template_undefined = template_undefined",
            "        self.last_loaded = timezone.utcnow()",
            "        self.safe_dag_id = dag_id.replace(\".\", \"__dot__\")",
            "        self.max_active_runs = max_active_runs",
            "        if self.timetable.active_runs_limit is not None:",
            "            if self.timetable.active_runs_limit < self.max_active_runs:",
            "                raise AirflowException(",
            "                    f\"Invalid max_active_runs: {type(self.timetable)} \"",
            "                    f\"requires max_active_runs <= {self.timetable.active_runs_limit}\"",
            "                )",
            "        self.dagrun_timeout = dagrun_timeout",
            "        self.sla_miss_callback = sla_miss_callback",
            "        if default_view in DEFAULT_VIEW_PRESETS:",
            "            self._default_view: str = default_view",
            "        elif default_view == \"tree\":",
            "            warnings.warn(",
            "                \"`default_view` of 'tree' has been renamed to 'grid' -- please update your DAG\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            self._default_view = \"grid\"",
            "        else:",
            "            raise AirflowException(",
            "                f\"Invalid values of dag.default_view: only support \"",
            "                f\"{DEFAULT_VIEW_PRESETS}, but get {default_view}\"",
            "            )",
            "        if orientation in ORIENTATION_PRESETS:",
            "            self.orientation = orientation",
            "        else:",
            "            raise AirflowException(",
            "                f\"Invalid values of dag.orientation: only support \"",
            "                f\"{ORIENTATION_PRESETS}, but get {orientation}\"",
            "            )",
            "        self.catchup = catchup",
            "",
            "        self.partial = False",
            "        self.on_success_callback = on_success_callback",
            "        self.on_failure_callback = on_failure_callback",
            "",
            "        # Keeps track of any extra edge metadata (sparse; will not contain all",
            "        # edges, so do not iterate over it for that). Outer key is upstream",
            "        # task ID, inner key is downstream task ID.",
            "        self.edge_info: dict[str, dict[str, EdgeInfoType]] = {}",
            "",
            "        # To keep it in parity with Serialized DAGs",
            "        # and identify if DAG has on_*_callback without actually storing them in Serialized JSON",
            "        self.has_on_success_callback = self.on_success_callback is not None",
            "        self.has_on_failure_callback = self.on_failure_callback is not None",
            "",
            "        self._access_control = DAG._upgrade_outdated_dag_access_control(access_control)",
            "        self.is_paused_upon_creation = is_paused_upon_creation",
            "        self.auto_register = auto_register",
            "",
            "        self.fail_stop = fail_stop",
            "",
            "        self.jinja_environment_kwargs = jinja_environment_kwargs",
            "        self.render_template_as_native_obj = render_template_as_native_obj",
            "",
            "        self.doc_md = self.get_doc_md(doc_md)",
            "",
            "        self.tags = tags or []",
            "        self._task_group = TaskGroup.create_root(self)",
            "        self.validate_schedule_and_params()",
            "        wrong_links = dict(self.iter_invalid_owner_links())",
            "        if wrong_links:",
            "            raise AirflowException(",
            "                \"Wrong link format was used for the owner. Use a valid link \\n\"",
            "                f\"Bad formatted links are: {wrong_links}\"",
            "            )",
            "",
            "        # this will only be set at serialization time",
            "        # it's only use is for determining the relative",
            "        # fileloc based only on the serialize dag",
            "        self._processor_dags_folder = None",
            "",
            "    def get_doc_md(self, doc_md: str | None) -> str | None:",
            "        if doc_md is None:",
            "            return doc_md",
            "",
            "        env = self.get_template_env(force_sandboxed=True)",
            "",
            "        if not doc_md.endswith(\".md\"):",
            "            template = jinja2.Template(doc_md)",
            "        else:",
            "            try:",
            "                template = env.get_template(doc_md)",
            "            except jinja2.exceptions.TemplateNotFound:",
            "                return f\"\"\"",
            "                # Templating Error!",
            "                Not able to find the template file: `{doc_md}`.",
            "                \"\"\"",
            "",
            "        return template.render()",
            "",
            "    def _check_schedule_interval_matches_timetable(self) -> bool:",
            "        \"\"\"Check ``schedule_interval`` and ``timetable`` match.",
            "",
            "        This is done as a part of the DAG validation done before it's bagged, to",
            "        guard against the DAG's ``timetable`` (or ``schedule_interval``) from",
            "        being changed after it's created, e.g.",
            "",
            "        .. code-block:: python",
            "",
            "            dag1 = DAG(\"d1\", timetable=MyTimetable())",
            "            dag1.schedule_interval = \"@once\"",
            "",
            "            dag2 = DAG(\"d2\", schedule=\"@once\")",
            "            dag2.timetable = MyTimetable()",
            "",
            "        Validation is done by creating a timetable and check its summary matches",
            "        ``schedule_interval``. The logic is not bullet-proof, especially if a",
            "        custom timetable does not provide a useful ``summary``. But this is the",
            "        best we can do.",
            "        \"\"\"",
            "        if self.schedule_interval == self.timetable.summary:",
            "            return True",
            "        try:",
            "            timetable = create_timetable(self.schedule_interval, self.timezone)",
            "        except ValueError:",
            "            return False",
            "        return timetable.summary == self.timetable.summary",
            "",
            "    def validate(self):",
            "        \"\"\"Validate the DAG has a coherent setup.",
            "",
            "        This is called by the DAG bag before bagging the DAG.",
            "        \"\"\"",
            "        if not self._check_schedule_interval_matches_timetable():",
            "            raise AirflowDagInconsistent(",
            "                f\"inconsistent schedule: timetable {self.timetable.summary!r} \"",
            "                f\"does not match schedule_interval {self.schedule_interval!r}\",",
            "            )",
            "        self.params.validate()",
            "        self.timetable.validate()",
            "        self.validate_setup_teardown()",
            "",
            "    def validate_setup_teardown(self):",
            "        \"\"\"",
            "        Validate that setup and teardown tasks are configured properly.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        for task in self.tasks:",
            "            if not task.is_setup:",
            "                continue",
            "            if not any(x.is_teardown for x in task.downstream_list):",
            "                raise AirflowDagInconsistent(",
            "                    \"Dag has setup without teardown: dag='%s', task='%s'\", self.dag_id, task.task_id",
            "                )",
            "",
            "    def __repr__(self):",
            "        return f\"<DAG: {self.dag_id}>\"",
            "",
            "    def __eq__(self, other):",
            "        if type(self) == type(other):",
            "            # Use getattr() instead of __dict__ as __dict__ doesn't return",
            "            # correct values for properties.",
            "            return all(getattr(self, c, None) == getattr(other, c, None) for c in self._comps)",
            "        return False",
            "",
            "    def __ne__(self, other):",
            "        return not self == other",
            "",
            "    def __lt__(self, other):",
            "        return self.dag_id < other.dag_id",
            "",
            "    def __hash__(self):",
            "        hash_components = [type(self)]",
            "        for c in self._comps:",
            "            # task_ids returns a list and lists can't be hashed",
            "            if c == \"task_ids\":",
            "                val = tuple(self.task_dict.keys())",
            "            else:",
            "                val = getattr(self, c, None)",
            "            try:",
            "                hash(val)",
            "                hash_components.append(val)",
            "            except TypeError:",
            "                hash_components.append(repr(val))",
            "        return hash(tuple(hash_components))",
            "",
            "    # Context Manager -----------------------------------------------",
            "    def __enter__(self):",
            "        DagContext.push_context_managed_dag(self)",
            "        return self",
            "",
            "    def __exit__(self, _type, _value, _tb):",
            "        DagContext.pop_context_managed_dag()",
            "",
            "    # /Context Manager ----------------------------------------------",
            "",
            "    @staticmethod",
            "    def _upgrade_outdated_dag_access_control(access_control=None):",
            "        \"\"\"",
            "        Looks for outdated dag level actions (can_dag_read and can_dag_edit) in DAG",
            "        access_controls (for example, {'role1': {'can_dag_read'}, 'role2': {'can_dag_read', 'can_dag_edit'}})",
            "        and replaces them with updated actions (can_read and can_edit).",
            "        \"\"\"",
            "        if not access_control:",
            "            return None",
            "        new_perm_mapping = {",
            "            permissions.DEPRECATED_ACTION_CAN_DAG_READ: permissions.ACTION_CAN_READ,",
            "            permissions.DEPRECATED_ACTION_CAN_DAG_EDIT: permissions.ACTION_CAN_EDIT,",
            "        }",
            "        updated_access_control = {}",
            "        for role, perms in access_control.items():",
            "            updated_access_control[role] = {new_perm_mapping.get(perm, perm) for perm in perms}",
            "",
            "        if access_control != updated_access_control:",
            "            warnings.warn(",
            "                \"The 'can_dag_read' and 'can_dag_edit' permissions are deprecated. \"",
            "                \"Please use 'can_read' and 'can_edit', respectively.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=3,",
            "            )",
            "",
            "        return updated_access_control",
            "",
            "    def date_range(",
            "        self,",
            "        start_date: pendulum.DateTime,",
            "        num: int | None = None,",
            "        end_date: datetime | None = None,",
            "    ) -> list[datetime]:",
            "        message = \"`DAG.date_range()` is deprecated.\"",
            "        if num is not None:",
            "            warnings.warn(message, category=RemovedInAirflow3Warning, stacklevel=2)",
            "            with warnings.catch_warnings():",
            "                warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "                return utils_date_range(",
            "                    start_date=start_date, num=num, delta=self.normalized_schedule_interval",
            "                )",
            "        message += \" Please use `DAG.iter_dagrun_infos_between(..., align=False)` instead.\"",
            "        warnings.warn(message, category=RemovedInAirflow3Warning, stacklevel=2)",
            "        if end_date is None:",
            "            coerced_end_date = timezone.utcnow()",
            "        else:",
            "            coerced_end_date = end_date",
            "        it = self.iter_dagrun_infos_between(start_date, pendulum.instance(coerced_end_date), align=False)",
            "        return [info.logical_date for info in it]",
            "",
            "    def is_fixed_time_schedule(self):",
            "        warnings.warn(",
            "            \"`DAG.is_fixed_time_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        try:",
            "            return not self.timetable._should_fix_dst",
            "        except AttributeError:",
            "            return True",
            "",
            "    def following_schedule(self, dttm):",
            "        \"\"\"",
            "        Calculates the following schedule for this dag in UTC.",
            "",
            "        :param dttm: utc datetime",
            "        :return: utc datetime",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"`DAG.following_schedule()` is deprecated. Use `DAG.next_dagrun_info(restricted=False)` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        data_interval = self.infer_automated_data_interval(timezone.coerce_datetime(dttm))",
            "        next_info = self.next_dagrun_info(data_interval, restricted=False)",
            "        if next_info is None:",
            "            return None",
            "        return next_info.data_interval.start",
            "",
            "    def previous_schedule(self, dttm):",
            "        from airflow.timetables.interval import _DataIntervalTimetable",
            "",
            "        warnings.warn(",
            "            \"`DAG.previous_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if not isinstance(self.timetable, _DataIntervalTimetable):",
            "            return None",
            "        return self.timetable._get_prev(timezone.coerce_datetime(dttm))",
            "",
            "    def get_next_data_interval(self, dag_model: DagModel) -> DataInterval | None:",
            "        \"\"\"Get the data interval of the next scheduled run.",
            "",
            "        For compatibility, this method infers the data interval from the DAG's",
            "        schedule if the run does not have an explicit one set, which is possible",
            "        for runs created prior to AIP-39.",
            "",
            "        This function is private to Airflow core and should not be depended on as a",
            "        part of the Python API.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if self.dag_id != dag_model.dag_id:",
            "            raise ValueError(f\"Arguments refer to different DAGs: {self.dag_id} != {dag_model.dag_id}\")",
            "        if dag_model.next_dagrun is None:  # Next run not scheduled.",
            "            return None",
            "        data_interval = dag_model.next_dagrun_data_interval",
            "        if data_interval is not None:",
            "            return data_interval",
            "",
            "        # Compatibility: A run was scheduled without an explicit data interval.",
            "        # This means the run was scheduled before AIP-39 implementation. Try to",
            "        # infer from the logical date.",
            "        return self.infer_automated_data_interval(dag_model.next_dagrun)",
            "",
            "    def get_run_data_interval(self, run: DagRun) -> DataInterval:",
            "        \"\"\"Get the data interval of this run.",
            "",
            "        For compatibility, this method infers the data interval from the DAG's",
            "        schedule if the run does not have an explicit one set, which is possible for",
            "        runs created prior to AIP-39.",
            "",
            "        This function is private to Airflow core and should not be depended on as a",
            "        part of the Python API.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if run.dag_id is not None and run.dag_id != self.dag_id:",
            "            raise ValueError(f\"Arguments refer to different DAGs: {self.dag_id} != {run.dag_id}\")",
            "        data_interval = _get_model_data_interval(run, \"data_interval_start\", \"data_interval_end\")",
            "        if data_interval is not None:",
            "            return data_interval",
            "        # Compatibility: runs created before AIP-39 implementation don't have an",
            "        # explicit data interval. Try to infer from the logical date.",
            "        return self.infer_automated_data_interval(run.execution_date)",
            "",
            "    def infer_automated_data_interval(self, logical_date: datetime) -> DataInterval:",
            "        \"\"\"Infer a data interval for a run against this DAG.",
            "",
            "        This method is used to bridge runs created prior to AIP-39",
            "        implementation, which do not have an explicit data interval. Therefore,",
            "        this method only considers ``schedule_interval`` values valid prior to",
            "        Airflow 2.2.",
            "",
            "        DO NOT call this method if there is a known data interval.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        timetable_type = type(self.timetable)",
            "        if issubclass(timetable_type, (NullTimetable, OnceTimetable, DatasetTriggeredTimetable)):",
            "            return DataInterval.exact(timezone.coerce_datetime(logical_date))",
            "        start = timezone.coerce_datetime(logical_date)",
            "        if issubclass(timetable_type, CronDataIntervalTimetable):",
            "            end = cast(CronDataIntervalTimetable, self.timetable)._get_next(start)",
            "        elif issubclass(timetable_type, DeltaDataIntervalTimetable):",
            "            end = cast(DeltaDataIntervalTimetable, self.timetable)._get_next(start)",
            "        # Contributors: When the exception below is raised, you might want to",
            "        # add an 'elif' block here to handle custom timetables. Stop! The bug",
            "        # you're looking for is instead at when the DAG run (represented by",
            "        # logical_date) was created. See GH-31969 for an example:",
            "        # * Wrong fix: GH-32074 (modifies this function).",
            "        # * Correct fix: GH-32118 (modifies the DAG run creation code).",
            "        else:",
            "            raise ValueError(f\"Not a valid timetable: {self.timetable!r}\")",
            "        return DataInterval(start, end)",
            "",
            "    def next_dagrun_info(",
            "        self,",
            "        last_automated_dagrun: None | datetime | DataInterval,",
            "        *,",
            "        restricted: bool = True,",
            "    ) -> DagRunInfo | None:",
            "        \"\"\"Get information about the next DagRun of this dag after ``date_last_automated_dagrun``.",
            "",
            "        This calculates what time interval the next DagRun should operate on",
            "        (its execution date) and when it can be scheduled, according to the",
            "        dag's timetable, start_date, end_date, etc. This doesn't check max",
            "        active run or any other \"max_active_tasks\" type limits, but only",
            "        performs calculations based on the various date and interval fields of",
            "        this dag and its tasks.",
            "",
            "        :param last_automated_dagrun: The ``max(execution_date)`` of",
            "            existing \"automated\" DagRuns for this dag (scheduled or backfill,",
            "            but not manual).",
            "        :param restricted: If set to *False* (default is *True*), ignore",
            "            ``start_date``, ``end_date``, and ``catchup`` specified on the DAG",
            "            or tasks.",
            "        :return: DagRunInfo of the next dagrun, or None if a dagrun is not",
            "            going to be scheduled.",
            "        \"\"\"",
            "        # Never schedule a subdag. It will be scheduled by its parent dag.",
            "        if self.is_subdag:",
            "            return None",
            "",
            "        data_interval = None",
            "        if isinstance(last_automated_dagrun, datetime):",
            "            warnings.warn(",
            "                \"Passing a datetime to DAG.next_dagrun_info is deprecated. Use a DataInterval instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            data_interval = self.infer_automated_data_interval(",
            "                timezone.coerce_datetime(last_automated_dagrun)",
            "            )",
            "        else:",
            "            data_interval = last_automated_dagrun",
            "        if restricted:",
            "            restriction = self._time_restriction",
            "        else:",
            "            restriction = TimeRestriction(earliest=None, latest=None, catchup=True)",
            "        try:",
            "            info = self.timetable.next_dagrun_info(",
            "                last_automated_data_interval=data_interval,",
            "                restriction=restriction,",
            "            )",
            "        except Exception:",
            "            self.log.exception(",
            "                \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                data_interval,",
            "                self.dag_id,",
            "            )",
            "            info = None",
            "        return info",
            "",
            "    def next_dagrun_after_date(self, date_last_automated_dagrun: pendulum.DateTime | None):",
            "        warnings.warn(",
            "            \"`DAG.next_dagrun_after_date()` is deprecated. Please use `DAG.next_dagrun_info()` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if date_last_automated_dagrun is None:",
            "            data_interval = None",
            "        else:",
            "            data_interval = self.infer_automated_data_interval(date_last_automated_dagrun)",
            "        info = self.next_dagrun_info(data_interval)",
            "        if info is None:",
            "            return None",
            "        return info.run_after",
            "",
            "    @functools.cached_property",
            "    def _time_restriction(self) -> TimeRestriction:",
            "        start_dates = [t.start_date for t in self.tasks if t.start_date]",
            "        if self.start_date is not None:",
            "            start_dates.append(self.start_date)",
            "        earliest = None",
            "        if start_dates:",
            "            earliest = timezone.coerce_datetime(min(start_dates))",
            "        latest = self.end_date",
            "        end_dates = [t.end_date for t in self.tasks if t.end_date]",
            "        if len(end_dates) == len(self.tasks):  # not exists null end_date",
            "            if self.end_date is not None:",
            "                end_dates.append(self.end_date)",
            "            if end_dates:",
            "                latest = timezone.coerce_datetime(max(end_dates))",
            "        return TimeRestriction(earliest, latest, self.catchup)",
            "",
            "    def iter_dagrun_infos_between(",
            "        self,",
            "        earliest: pendulum.DateTime | None,",
            "        latest: pendulum.DateTime,",
            "        *,",
            "        align: bool = True,",
            "    ) -> Iterable[DagRunInfo]:",
            "        \"\"\"Yield DagRunInfo using this DAG's timetable between given interval.",
            "",
            "        DagRunInfo instances yielded if their ``logical_date`` is not earlier",
            "        than ``earliest``, nor later than ``latest``. The instances are ordered",
            "        by their ``logical_date`` from earliest to latest.",
            "",
            "        If ``align`` is ``False``, the first run will happen immediately on",
            "        ``earliest``, even if it does not fall on the logical timetable schedule.",
            "        The default is ``True``, but subdags will ignore this value and always",
            "        behave as if this is set to ``False`` for backward compatibility.",
            "",
            "        Example: A DAG is scheduled to run every midnight (``0 0 * * *``). If",
            "        ``earliest`` is ``2021-06-03 23:00:00``, the first DagRunInfo would be",
            "        ``2021-06-03 23:00:00`` if ``align=False``, and ``2021-06-04 00:00:00``",
            "        if ``align=True``.",
            "        \"\"\"",
            "        if earliest is None:",
            "            earliest = self._time_restriction.earliest",
            "        if earliest is None:",
            "            raise ValueError(\"earliest was None and we had no value in time_restriction to fallback on\")",
            "        earliest = timezone.coerce_datetime(earliest)",
            "        latest = timezone.coerce_datetime(latest)",
            "",
            "        restriction = TimeRestriction(earliest, latest, catchup=True)",
            "",
            "        # HACK: Sub-DAGs are currently scheduled differently. For example, say",
            "        # the schedule is @daily and start is 2021-06-03 22:16:00, a top-level",
            "        # DAG should be first scheduled to run on midnight 2021-06-04, but a",
            "        # sub-DAG should be first scheduled to run RIGHT NOW. We can change",
            "        # this, but since sub-DAGs are going away in 3.0 anyway, let's keep",
            "        # compatibility for now and remove this entirely later.",
            "        if self.is_subdag:",
            "            align = False",
            "",
            "        try:",
            "            info = self.timetable.next_dagrun_info(",
            "                last_automated_data_interval=None,",
            "                restriction=restriction,",
            "            )",
            "        except Exception:",
            "            self.log.exception(",
            "                \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                None,",
            "                self.dag_id,",
            "            )",
            "            info = None",
            "",
            "        if info is None:",
            "            # No runs to be scheduled between the user-supplied timeframe. But",
            "            # if align=False, \"invent\" a data interval for the timeframe itself.",
            "            if not align:",
            "                yield DagRunInfo.interval(earliest, latest)",
            "            return",
            "",
            "        # If align=False and earliest does not fall on the timetable's logical",
            "        # schedule, \"invent\" a data interval for it.",
            "        if not align and info.logical_date != earliest:",
            "            yield DagRunInfo.interval(earliest, info.data_interval.start)",
            "",
            "        # Generate naturally according to schedule.",
            "        while info is not None:",
            "            yield info",
            "            try:",
            "                info = self.timetable.next_dagrun_info(",
            "                    last_automated_data_interval=info.data_interval,",
            "                    restriction=restriction,",
            "                )",
            "            except Exception:",
            "                self.log.exception(",
            "                    \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                    info.data_interval if info else \"<NONE>\",",
            "                    self.dag_id,",
            "                )",
            "                break",
            "",
            "    def get_run_dates(self, start_date, end_date=None) -> list:",
            "        \"\"\"",
            "        Returns a list of dates between the interval received as parameter using this",
            "        dag's schedule interval. Returned dates can be used for execution dates.",
            "",
            "        :param start_date: The start date of the interval.",
            "        :param end_date: The end date of the interval. Defaults to ``timezone.utcnow()``.",
            "        :return: A list of dates within the interval following the dag's schedule.",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"`DAG.get_run_dates()` is deprecated. Please use `DAG.iter_dagrun_infos_between()` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        earliest = timezone.coerce_datetime(start_date)",
            "        if end_date is None:",
            "            latest = pendulum.now(timezone.utc)",
            "        else:",
            "            latest = timezone.coerce_datetime(end_date)",
            "        return [info.logical_date for info in self.iter_dagrun_infos_between(earliest, latest)]",
            "",
            "    def normalize_schedule(self, dttm):",
            "        warnings.warn(",
            "            \"`DAG.normalize_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "            following = self.following_schedule(dttm)",
            "        if not following:  # in case of @once",
            "            return dttm",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "            previous_of_following = self.previous_schedule(following)",
            "        if previous_of_following != dttm:",
            "            return following",
            "        return dttm",
            "",
            "    @provide_session",
            "    def get_last_dagrun(self, session=NEW_SESSION, include_externally_triggered=False):",
            "        return get_last_dagrun(",
            "            self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "        )",
            "",
            "    @provide_session",
            "    def has_dag_runs(self, session=NEW_SESSION, include_externally_triggered=True) -> bool:",
            "        return (",
            "            get_last_dagrun(",
            "                self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "            )",
            "            is not None",
            "        )",
            "",
            "    @property",
            "    def dag_id(self) -> str:",
            "        return self._dag_id",
            "",
            "    @dag_id.setter",
            "    def dag_id(self, value: str) -> None:",
            "        self._dag_id = value",
            "",
            "    @property",
            "    def is_subdag(self) -> bool:",
            "        return self.parent_dag is not None",
            "",
            "    @property",
            "    def full_filepath(self) -> str:",
            "        \"\"\"Full file path to the DAG.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"DAG.full_filepath is deprecated in favour of fileloc\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.fileloc",
            "",
            "    @full_filepath.setter",
            "    def full_filepath(self, value) -> None:",
            "        warnings.warn(",
            "            \"DAG.full_filepath is deprecated in favour of fileloc\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        self.fileloc = value",
            "",
            "    @property",
            "    def concurrency(self) -> int:",
            "        # TODO: Remove in Airflow 3.0",
            "        warnings.warn(",
            "            \"The 'DAG.concurrency' attribute is deprecated. Please use 'DAG.max_active_tasks'.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self._max_active_tasks",
            "",
            "    @concurrency.setter",
            "    def concurrency(self, value: int):",
            "        self._max_active_tasks = value",
            "",
            "    @property",
            "    def max_active_tasks(self) -> int:",
            "        return self._max_active_tasks",
            "",
            "    @max_active_tasks.setter",
            "    def max_active_tasks(self, value: int):",
            "        self._max_active_tasks = value",
            "",
            "    @property",
            "    def access_control(self):",
            "        return self._access_control",
            "",
            "    @access_control.setter",
            "    def access_control(self, value):",
            "        self._access_control = DAG._upgrade_outdated_dag_access_control(value)",
            "",
            "    @property",
            "    def description(self) -> str | None:",
            "        return self._description",
            "",
            "    @property",
            "    def default_view(self) -> str:",
            "        return self._default_view",
            "",
            "    @property",
            "    def pickle_id(self) -> int | None:",
            "        return self._pickle_id",
            "",
            "    @pickle_id.setter",
            "    def pickle_id(self, value: int) -> None:",
            "        self._pickle_id = value",
            "",
            "    def param(self, name: str, default: Any = NOTSET) -> DagParam:",
            "        \"\"\"",
            "        Return a DagParam object for current dag.",
            "",
            "        :param name: dag parameter name.",
            "        :param default: fallback value for dag parameter.",
            "        :return: DagParam instance for specified name and current dag.",
            "        \"\"\"",
            "        return DagParam(current_dag=self, name=name, default=default)",
            "",
            "    @property",
            "    def tasks(self) -> list[Operator]:",
            "        return list(self.task_dict.values())",
            "",
            "    @tasks.setter",
            "    def tasks(self, val):",
            "        raise AttributeError(\"DAG.tasks can not be modified. Use dag.add_task() instead.\")",
            "",
            "    @property",
            "    def task_ids(self) -> list[str]:",
            "        return list(self.task_dict.keys())",
            "",
            "    @property",
            "    def teardowns(self) -> list[Operator]:",
            "        return [task for task in self.tasks if getattr(task, \"is_teardown\", None)]",
            "",
            "    @property",
            "    def tasks_upstream_of_teardowns(self) -> list[Operator]:",
            "        upstream_tasks = [t.upstream_list for t in self.teardowns]",
            "        return [val for sublist in upstream_tasks for val in sublist if not getattr(val, \"is_teardown\", None)]",
            "",
            "    @property",
            "    def task_group(self) -> TaskGroup:",
            "        return self._task_group",
            "",
            "    @property",
            "    def filepath(self) -> str:",
            "        \"\"\"Relative file path to the DAG.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"filepath is deprecated, use relative_fileloc instead\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return str(self.relative_fileloc)",
            "",
            "    @property",
            "    def relative_fileloc(self) -> pathlib.Path:",
            "        \"\"\"File location of the importable dag 'file' relative to the configured DAGs folder.\"\"\"",
            "        path = pathlib.Path(self.fileloc)",
            "        try:",
            "            rel_path = path.relative_to(self._processor_dags_folder or settings.DAGS_FOLDER)",
            "            if rel_path == pathlib.Path(\".\"):",
            "                return path",
            "            else:",
            "                return rel_path",
            "        except ValueError:",
            "            # Not relative to DAGS_FOLDER.",
            "            return path",
            "",
            "    @property",
            "    def folder(self) -> str:",
            "        \"\"\"Folder location of where the DAG object is instantiated.\"\"\"",
            "        return os.path.dirname(self.fileloc)",
            "",
            "    @property",
            "    def owner(self) -> str:",
            "        \"\"\"",
            "        Return list of all owners found in DAG tasks.",
            "",
            "        :return: Comma separated list of owners in DAG tasks",
            "        \"\"\"",
            "        return \", \".join({t.owner for t in self.tasks})",
            "",
            "    @property",
            "    def allow_future_exec_dates(self) -> bool:",
            "        return settings.ALLOW_FUTURE_EXEC_DATES and not self.timetable.can_be_scheduled",
            "",
            "    @provide_session",
            "    def get_concurrency_reached(self, session=NEW_SESSION) -> bool:",
            "        \"\"\"",
            "        Returns a boolean indicating whether the max_active_tasks limit for this DAG",
            "        has been reached.",
            "        \"\"\"",
            "        TI = TaskInstance",
            "        total_tasks = session.scalar(",
            "            select(func.count(TI.task_id)).where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.state == TaskInstanceState.RUNNING,",
            "            )",
            "        )",
            "        return total_tasks >= self.max_active_tasks",
            "",
            "    @property",
            "    def concurrency_reached(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_concurrency_reached` method.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_concurrency_reached` method.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_concurrency_reached()",
            "",
            "    @provide_session",
            "    def get_is_active(self, session=NEW_SESSION) -> None:",
            "        \"\"\"Returns a boolean indicating whether this DAG is active.\"\"\"",
            "        return session.scalar(select(DagModel.is_active).where(DagModel.dag_id == self.dag_id))",
            "",
            "    @provide_session",
            "    def get_is_paused(self, session=NEW_SESSION) -> None:",
            "        \"\"\"Returns a boolean indicating whether this DAG is paused.\"\"\"",
            "        return session.scalar(select(DagModel.is_paused).where(DagModel.dag_id == self.dag_id))",
            "",
            "    @property",
            "    def is_paused(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_is_paused` method.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_is_paused` method.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_is_paused()",
            "",
            "    @property",
            "    def normalized_schedule_interval(self) -> ScheduleInterval:",
            "        warnings.warn(",
            "            \"DAG.normalized_schedule_interval() is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if isinstance(self.schedule_interval, str) and self.schedule_interval in cron_presets:",
            "            _schedule_interval: ScheduleInterval = cron_presets.get(self.schedule_interval)",
            "        elif self.schedule_interval == \"@once\":",
            "            _schedule_interval = None",
            "        else:",
            "            _schedule_interval = self.schedule_interval",
            "        return _schedule_interval",
            "",
            "    @provide_session",
            "    def handle_callback(self, dagrun, success=True, reason=None, session=NEW_SESSION):",
            "        \"\"\"",
            "        Triggers the appropriate callback depending on the value of success, namely the",
            "        on_failure_callback or on_success_callback. This method gets the context of a",
            "        single TaskInstance part of this DagRun and passes that to the callable along",
            "        with a 'reason', primarily to differentiate DagRun failures.",
            "",
            "        .. note: The logs end up in",
            "            ``$AIRFLOW_HOME/logs/scheduler/latest/PROJECT/DAG_FILE.py.log``",
            "",
            "        :param dagrun: DagRun object",
            "        :param success: Flag to specify if failure or success callback should be called",
            "        :param reason: Completion reason",
            "        :param session: Database session",
            "        \"\"\"",
            "        callbacks = self.on_success_callback if success else self.on_failure_callback",
            "        if callbacks:",
            "            callbacks = callbacks if isinstance(callbacks, list) else [callbacks]",
            "            tis = dagrun.get_task_instances(session=session)",
            "            ti = tis[-1]  # get first TaskInstance of DagRun",
            "            ti.task = self.get_task(ti.task_id)",
            "            context = ti.get_template_context(session=session)",
            "            context.update({\"reason\": reason})",
            "            for callback in callbacks:",
            "                self.log.info(\"Executing dag callback function: %s\", callback)",
            "                try:",
            "                    callback(context)",
            "                except Exception:",
            "                    self.log.exception(\"failed to invoke dag state update callback\")",
            "                    Stats.incr(\"dag.callback_exceptions\", tags={\"dag_id\": dagrun.dag_id})",
            "",
            "    def get_active_runs(self):",
            "        \"\"\"",
            "        Returns a list of dag run execution dates currently running.",
            "",
            "        :return: List of execution dates",
            "        \"\"\"",
            "        runs = DagRun.find(dag_id=self.dag_id, state=State.RUNNING)",
            "",
            "        active_dates = []",
            "        for run in runs:",
            "            active_dates.append(run.execution_date)",
            "",
            "        return active_dates",
            "",
            "    @provide_session",
            "    def get_num_active_runs(self, external_trigger=None, only_running=True, session=NEW_SESSION):",
            "        \"\"\"",
            "        Returns the number of active \"running\" dag runs.",
            "",
            "        :param external_trigger: True for externally triggered active dag runs",
            "        :param session:",
            "        :return: number greater than 0 for active dag runs",
            "        \"\"\"",
            "        query = select(func.count()).where(DagRun.dag_id == self.dag_id)",
            "        if only_running:",
            "            query = query.where(DagRun.state == DagRunState.RUNNING)",
            "        else:",
            "            query = query.where(DagRun.state.in_({DagRunState.RUNNING, DagRunState.QUEUED}))",
            "",
            "        if external_trigger is not None:",
            "            query = query.where(",
            "                DagRun.external_trigger == (expression.true() if external_trigger else expression.false())",
            "            )",
            "",
            "        return session.scalar(query)",
            "",
            "    @provide_session",
            "    def get_dagrun(",
            "        self,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        \"\"\"",
            "        Returns the dag run for a given execution date or run_id if it exists, otherwise",
            "        none.",
            "",
            "        :param execution_date: The execution date of the DagRun to find.",
            "        :param run_id: The run_id of the DagRun to find.",
            "        :param session:",
            "        :return: The DagRun if found, otherwise None.",
            "        \"\"\"",
            "        if not (execution_date or run_id):",
            "            raise TypeError(\"You must provide either the execution_date or the run_id\")",
            "        query = select(DagRun)",
            "        if execution_date:",
            "            query = query.where(DagRun.dag_id == self.dag_id, DagRun.execution_date == execution_date)",
            "        if run_id:",
            "            query = query.where(DagRun.dag_id == self.dag_id, DagRun.run_id == run_id)",
            "        return session.scalar(query)",
            "",
            "    @provide_session",
            "    def get_dagruns_between(self, start_date, end_date, session=NEW_SESSION):",
            "        \"\"\"",
            "        Returns the list of dag runs between start_date (inclusive) and end_date (inclusive).",
            "",
            "        :param start_date: The starting execution date of the DagRun to find.",
            "        :param end_date: The ending execution date of the DagRun to find.",
            "        :param session:",
            "        :return: The list of DagRuns found.",
            "        \"\"\"",
            "        dagruns = session.scalars(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date >= start_date,",
            "                DagRun.execution_date <= end_date,",
            "            )",
            "        ).all()",
            "",
            "        return dagruns",
            "",
            "    @provide_session",
            "    def get_latest_execution_date(self, session: Session = NEW_SESSION) -> pendulum.DateTime | None:",
            "        \"\"\"Returns the latest date for which at least one dag run exists.\"\"\"",
            "        return session.scalar(select(func.max(DagRun.execution_date)).where(DagRun.dag_id == self.dag_id))",
            "",
            "    @property",
            "    def latest_execution_date(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_latest_execution_date`.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_latest_execution_date`.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_latest_execution_date()",
            "",
            "    @property",
            "    def subdags(self):",
            "        \"\"\"Returns a list of the subdag objects associated to this DAG.\"\"\"",
            "        # Check SubDag for class but don't check class directly",
            "        from airflow.operators.subdag import SubDagOperator",
            "",
            "        subdag_lst = []",
            "        for task in self.tasks:",
            "            if (",
            "                isinstance(task, SubDagOperator)",
            "                or",
            "                # TODO remove in Airflow 2.0",
            "                type(task).__name__ == \"SubDagOperator\"",
            "                or task.task_type == \"SubDagOperator\"",
            "            ):",
            "                subdag_lst.append(task.subdag)",
            "                subdag_lst += task.subdag.subdags",
            "        return subdag_lst",
            "",
            "    def resolve_template_files(self):",
            "        for t in self.tasks:",
            "            t.resolve_template_files()",
            "",
            "    def get_template_env(self, *, force_sandboxed: bool = False) -> jinja2.Environment:",
            "        \"\"\"Build a Jinja2 environment.\"\"\"",
            "        # Collect directories to search for template files",
            "        searchpath = [self.folder]",
            "        if self.template_searchpath:",
            "            searchpath += self.template_searchpath",
            "",
            "        # Default values (for backward compatibility)",
            "        jinja_env_options = {",
            "            \"loader\": jinja2.FileSystemLoader(searchpath),",
            "            \"undefined\": self.template_undefined,",
            "            \"extensions\": [\"jinja2.ext.do\"],",
            "            \"cache_size\": 0,",
            "        }",
            "        if self.jinja_environment_kwargs:",
            "            jinja_env_options.update(self.jinja_environment_kwargs)",
            "        env: jinja2.Environment",
            "        if self.render_template_as_native_obj and not force_sandboxed:",
            "            env = airflow.templates.NativeEnvironment(**jinja_env_options)",
            "        else:",
            "            env = airflow.templates.SandboxedEnvironment(**jinja_env_options)",
            "",
            "        # Add any user defined items. Safe to edit globals as long as no templates are rendered yet.",
            "        # http://jinja.pocoo.org/docs/2.10/api/#jinja2.Environment.globals",
            "        if self.user_defined_macros:",
            "            env.globals.update(self.user_defined_macros)",
            "        if self.user_defined_filters:",
            "            env.filters.update(self.user_defined_filters)",
            "",
            "        return env",
            "",
            "    def set_dependency(self, upstream_task_id, downstream_task_id):",
            "        \"\"\"",
            "        Simple utility method to set dependency between two tasks that",
            "        already have been added to the DAG using add_task().",
            "        \"\"\"",
            "        self.get_task(upstream_task_id).set_downstream(self.get_task(downstream_task_id))",
            "",
            "    @provide_session",
            "    def get_task_instances_before(",
            "        self,",
            "        base_date: datetime,",
            "        num: int,",
            "        *,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"Get ``num`` task instances before (including) ``base_date``.",
            "",
            "        The returned list may contain exactly ``num`` task instances",
            "        corresponding to any DagRunType. It can have less if there are",
            "        less than ``num`` scheduled DAG runs before ``base_date``.",
            "        \"\"\"",
            "        execution_dates: list[Any] = session.execute(",
            "            select(DagRun.execution_date)",
            "            .where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date <= base_date,",
            "            )",
            "            .order_by(DagRun.execution_date.desc())",
            "            .limit(num)",
            "        ).all()",
            "",
            "        if len(execution_dates) == 0:",
            "            return self.get_task_instances(start_date=base_date, end_date=base_date, session=session)",
            "",
            "        min_date: datetime | None = execution_dates[-1]._mapping.get(",
            "            \"execution_date\"",
            "        )  # getting the last value from the list",
            "",
            "        return self.get_task_instances(start_date=min_date, end_date=base_date, session=session)",
            "",
            "    @provide_session",
            "    def get_task_instances(",
            "        self,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        state: list[TaskInstanceState] | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        if not start_date:",
            "            start_date = (timezone.utcnow() - timedelta(30)).replace(",
            "                hour=0, minute=0, second=0, microsecond=0",
            "            )",
            "",
            "        query = self._get_task_instances(",
            "            task_ids=None,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            run_id=None,",
            "            state=state or (),",
            "            include_subdags=False,",
            "            include_parentdag=False,",
            "            include_dependent_dags=False,",
            "            exclude_task_ids=(),",
            "            session=session,",
            "        )",
            "        return session.scalars(cast(Select, query).order_by(DagRun.execution_date)).all()",
            "",
            "    @overload",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = ...,",
            "    ) -> Iterable[TaskInstance]:",
            "        ...  # pragma: no cover",
            "",
            "    @overload",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        as_pk_tuple: Literal[True],",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = ...,",
            "        recursion_depth: int = ...,",
            "        max_recursion_depth: int = ...,",
            "        visited_external_tis: set[TaskInstanceKey] = ...,",
            "    ) -> set[TaskInstanceKey]:",
            "        ...  # pragma: no cover",
            "",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        as_pk_tuple: Literal[True, None] = None,",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = None,",
            "        recursion_depth: int = 0,",
            "        max_recursion_depth: int | None = None,",
            "        visited_external_tis: set[TaskInstanceKey] | None = None,",
            "    ) -> Iterable[TaskInstance] | set[TaskInstanceKey]:",
            "        TI = TaskInstance",
            "",
            "        # If we are looking at subdags/dependent dags we want to avoid UNION calls",
            "        # in SQL (it doesn't play nice with fields that have no equality operator,",
            "        # like JSON types), we instead build our result set separately.",
            "        #",
            "        # This will be empty if we are only looking at one dag, in which case",
            "        # we can return the filtered TI query object directly.",
            "        result: set[TaskInstanceKey] = set()",
            "",
            "        # Do we want full objects, or just the primary columns?",
            "        if as_pk_tuple:",
            "            tis = select(TI.dag_id, TI.task_id, TI.run_id, TI.map_index)",
            "        else:",
            "            tis = select(TaskInstance)",
            "        tis = tis.join(TaskInstance.dag_run)",
            "",
            "        if include_subdags:",
            "            # Crafting the right filter for dag_id and task_ids combo",
            "            conditions = []",
            "            for dag in self.subdags + [self]:",
            "                conditions.append(",
            "                    (TaskInstance.dag_id == dag.dag_id) & TaskInstance.task_id.in_(dag.task_ids)",
            "                )",
            "            tis = tis.where(or_(*conditions))",
            "        elif self.partial:",
            "            tis = tis.where(TaskInstance.dag_id == self.dag_id, TaskInstance.task_id.in_(self.task_ids))",
            "        else:",
            "            tis = tis.where(TaskInstance.dag_id == self.dag_id)",
            "        if run_id:",
            "            tis = tis.where(TaskInstance.run_id == run_id)",
            "        if start_date:",
            "            tis = tis.where(DagRun.execution_date >= start_date)",
            "        if task_ids is not None:",
            "            tis = tis.where(TaskInstance.ti_selector_condition(task_ids))",
            "",
            "        # This allows allow_trigger_in_future config to take affect, rather than mandating exec_date <= UTC",
            "        if end_date or not self.allow_future_exec_dates:",
            "            end_date = end_date or timezone.utcnow()",
            "            tis = tis.where(DagRun.execution_date <= end_date)",
            "",
            "        if state:",
            "            if isinstance(state, (str, TaskInstanceState)):",
            "                tis = tis.where(TaskInstance.state == state)",
            "            elif len(state) == 1:",
            "                tis = tis.where(TaskInstance.state == state[0])",
            "            else:",
            "                # this is required to deal with NULL values",
            "                if None in state:",
            "                    if all(x is None for x in state):",
            "                        tis = tis.where(TaskInstance.state.is_(None))",
            "                    else:",
            "                        not_none_state = [s for s in state if s]",
            "                        tis = tis.where(",
            "                            or_(TaskInstance.state.in_(not_none_state), TaskInstance.state.is_(None))",
            "                        )",
            "                else:",
            "                    tis = tis.where(TaskInstance.state.in_(state))",
            "",
            "        # Next, get any of them from our parent DAG (if there is one)",
            "        if include_parentdag and self.parent_dag is not None:",
            "            if visited_external_tis is None:",
            "                visited_external_tis = set()",
            "",
            "            p_dag = self.parent_dag.partial_subset(",
            "                task_ids_or_regex=r\"^{}$\".format(self.dag_id.split(\".\")[1]),",
            "                include_upstream=False,",
            "                include_downstream=True,",
            "            )",
            "            result.update(",
            "                p_dag._get_task_instances(",
            "                    task_ids=task_ids,",
            "                    start_date=start_date,",
            "                    end_date=end_date,",
            "                    run_id=None,",
            "                    state=state,",
            "                    include_subdags=include_subdags,",
            "                    include_parentdag=False,",
            "                    include_dependent_dags=include_dependent_dags,",
            "                    as_pk_tuple=True,",
            "                    exclude_task_ids=exclude_task_ids,",
            "                    session=session,",
            "                    dag_bag=dag_bag,",
            "                    recursion_depth=recursion_depth,",
            "                    max_recursion_depth=max_recursion_depth,",
            "                    visited_external_tis=visited_external_tis,",
            "                )",
            "            )",
            "",
            "        if include_dependent_dags:",
            "            # Recursively find external tasks indicated by ExternalTaskMarker",
            "            from airflow.sensors.external_task import ExternalTaskMarker",
            "",
            "            query = tis",
            "            if as_pk_tuple:",
            "                all_tis = session.execute(query).all()",
            "                condition = TI.filter_for_tis(TaskInstanceKey(*cols) for cols in all_tis)",
            "                if condition is not None:",
            "                    query = select(TI).where(condition)",
            "",
            "            if visited_external_tis is None:",
            "                visited_external_tis = set()",
            "",
            "            external_tasks = session.scalars(query.where(TI.operator == ExternalTaskMarker.__name__))",
            "",
            "            for ti in external_tasks:",
            "                ti_key = ti.key.primary",
            "                if ti_key in visited_external_tis:",
            "                    continue",
            "",
            "                visited_external_tis.add(ti_key)",
            "",
            "                task: ExternalTaskMarker = cast(ExternalTaskMarker, copy.copy(self.get_task(ti.task_id)))",
            "                ti.task = task",
            "",
            "                if max_recursion_depth is None:",
            "                    # Maximum recursion depth allowed is the recursion_depth of the first",
            "                    # ExternalTaskMarker in the tasks to be visited.",
            "                    max_recursion_depth = task.recursion_depth",
            "",
            "                if recursion_depth + 1 > max_recursion_depth:",
            "                    # Prevent cycles or accidents.",
            "                    raise AirflowException(",
            "                        f\"Maximum recursion depth {max_recursion_depth} reached for \"",
            "                        f\"{ExternalTaskMarker.__name__} {ti.task_id}. \"",
            "                        f\"Attempted to clear too many tasks or there may be a cyclic dependency.\"",
            "                    )",
            "                ti.render_templates()",
            "                external_tis = session.scalars(",
            "                    select(TI)",
            "                    .join(TI.dag_run)",
            "                    .where(",
            "                        TI.dag_id == task.external_dag_id,",
            "                        TI.task_id == task.external_task_id,",
            "                        DagRun.execution_date == pendulum.parse(task.execution_date),",
            "                    )",
            "                )",
            "",
            "                for tii in external_tis:",
            "                    if not dag_bag:",
            "                        from airflow.models.dagbag import DagBag",
            "",
            "                        dag_bag = DagBag(read_dags_from_db=True)",
            "                    external_dag = dag_bag.get_dag(tii.dag_id, session=session)",
            "                    if not external_dag:",
            "                        raise AirflowException(f\"Could not find dag {tii.dag_id}\")",
            "                    downstream = external_dag.partial_subset(",
            "                        task_ids_or_regex=[tii.task_id],",
            "                        include_upstream=False,",
            "                        include_downstream=True,",
            "                    )",
            "                    result.update(",
            "                        downstream._get_task_instances(",
            "                            task_ids=None,",
            "                            run_id=tii.run_id,",
            "                            start_date=None,",
            "                            end_date=None,",
            "                            state=state,",
            "                            include_subdags=include_subdags,",
            "                            include_dependent_dags=include_dependent_dags,",
            "                            include_parentdag=False,",
            "                            as_pk_tuple=True,",
            "                            exclude_task_ids=exclude_task_ids,",
            "                            dag_bag=dag_bag,",
            "                            session=session,",
            "                            recursion_depth=recursion_depth + 1,",
            "                            max_recursion_depth=max_recursion_depth,",
            "                            visited_external_tis=visited_external_tis,",
            "                        )",
            "                    )",
            "",
            "        if result or as_pk_tuple:",
            "            # Only execute the `ti` query if we have also collected some other results (i.e. subdags etc.)",
            "            if as_pk_tuple:",
            "                tis_query = session.execute(tis).all()",
            "                result.update(TaskInstanceKey(**cols._mapping) for cols in tis_query)",
            "            else:",
            "                result.update(ti.key for ti in session.scalars(tis))",
            "",
            "            if exclude_task_ids is not None:",
            "                result = {",
            "                    task",
            "                    for task in result",
            "                    if task.task_id not in exclude_task_ids",
            "                    and (task.task_id, task.map_index) not in exclude_task_ids",
            "                }",
            "",
            "        if as_pk_tuple:",
            "            return result",
            "        if result:",
            "            # We've been asked for objects, lets combine it all back in to a result set",
            "            ti_filters = TI.filter_for_tis(result)",
            "            if ti_filters is not None:",
            "                tis = select(TI).where(ti_filters)",
            "        elif exclude_task_ids is None:",
            "            pass  # Disable filter if not set.",
            "        elif isinstance(next(iter(exclude_task_ids), None), str):",
            "            tis = tis.where(TI.task_id.notin_(exclude_task_ids))",
            "        else:",
            "            tis = tis.where(not_(tuple_in_condition((TI.task_id, TI.map_index), exclude_task_ids)))",
            "",
            "        return tis",
            "",
            "    @provide_session",
            "    def set_task_instance_state(",
            "        self,",
            "        *,",
            "        task_id: str,",
            "        map_indexes: Collection[int] | None = None,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        state: TaskInstanceState,",
            "        upstream: bool = False,",
            "        downstream: bool = False,",
            "        future: bool = False,",
            "        past: bool = False,",
            "        commit: bool = True,",
            "        session=NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"",
            "        Set the state of a TaskInstance to the given state, and clear its downstream tasks that are",
            "        in failed or upstream_failed state.",
            "",
            "        :param task_id: Task ID of the TaskInstance",
            "        :param map_indexes: Only set TaskInstance if its map_index matches.",
            "            If None (default), all mapped TaskInstances of the task are set.",
            "        :param execution_date: Execution date of the TaskInstance",
            "        :param run_id: The run_id of the TaskInstance",
            "        :param state: State to set the TaskInstance to",
            "        :param upstream: Include all upstream tasks of the given task_id",
            "        :param downstream: Include all downstream tasks of the given task_id",
            "        :param future: Include all future TaskInstances of the given task_id",
            "        :param commit: Commit changes",
            "        :param past: Include all past TaskInstances of the given task_id",
            "        \"\"\"",
            "        from airflow.api.common.mark_tasks import set_state",
            "",
            "        if not exactly_one(execution_date, run_id):",
            "            raise ValueError(\"Exactly one of execution_date or run_id must be provided\")",
            "",
            "        task = self.get_task(task_id)",
            "        task.dag = self",
            "",
            "        tasks_to_set_state: list[Operator | tuple[Operator, int]]",
            "        if map_indexes is None:",
            "            tasks_to_set_state = [task]",
            "        else:",
            "            tasks_to_set_state = [(task, map_index) for map_index in map_indexes]",
            "",
            "        altered = set_state(",
            "            tasks=tasks_to_set_state,",
            "            execution_date=execution_date,",
            "            run_id=run_id,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "            state=state,",
            "            commit=commit,",
            "            session=session,",
            "        )",
            "",
            "        if not commit:",
            "            return altered",
            "",
            "        # Clear downstream tasks that are in failed/upstream_failed state to resume them.",
            "        # Flush the session so that the tasks marked success are reflected in the db.",
            "        session.flush()",
            "        subdag = self.partial_subset(",
            "            task_ids_or_regex={task_id},",
            "            include_downstream=True,",
            "            include_upstream=False,",
            "        )",
            "",
            "        if execution_date is None:",
            "            dag_run = session.scalars(",
            "                select(DagRun).where(DagRun.run_id == run_id, DagRun.dag_id == self.dag_id)",
            "            ).one()  # Raises an error if not found",
            "            resolve_execution_date = dag_run.execution_date",
            "        else:",
            "            resolve_execution_date = execution_date",
            "",
            "        end_date = resolve_execution_date if not future else None",
            "        start_date = resolve_execution_date if not past else None",
            "",
            "        subdag.clear(",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            include_subdags=True,",
            "            include_parentdag=True,",
            "            only_failed=True,",
            "            session=session,",
            "            # Exclude the task itself from being cleared",
            "            exclude_task_ids=frozenset({task_id}),",
            "        )",
            "",
            "        return altered",
            "",
            "    @provide_session",
            "    def set_task_group_state(",
            "        self,",
            "        *,",
            "        group_id: str,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        state: TaskInstanceState,",
            "        upstream: bool = False,",
            "        downstream: bool = False,",
            "        future: bool = False,",
            "        past: bool = False,",
            "        commit: bool = True,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"",
            "        Set the state of the TaskGroup to the given state, and clear its downstream tasks that are",
            "        in failed or upstream_failed state.",
            "",
            "        :param group_id: The group_id of the TaskGroup",
            "        :param execution_date: Execution date of the TaskInstance",
            "        :param run_id: The run_id of the TaskInstance",
            "        :param state: State to set the TaskInstance to",
            "        :param upstream: Include all upstream tasks of the given task_id",
            "        :param downstream: Include all downstream tasks of the given task_id",
            "        :param future: Include all future TaskInstances of the given task_id",
            "        :param commit: Commit changes",
            "        :param past: Include all past TaskInstances of the given task_id",
            "        :param session: new session",
            "        \"\"\"",
            "        from airflow.api.common.mark_tasks import set_state",
            "",
            "        if not exactly_one(execution_date, run_id):",
            "            raise ValueError(\"Exactly one of execution_date or run_id must be provided\")",
            "",
            "        tasks_to_set_state: list[BaseOperator | tuple[BaseOperator, int]] = []",
            "        task_ids: list[str] = []",
            "",
            "        if execution_date is None:",
            "            dag_run = session.scalars(",
            "                select(DagRun).where(DagRun.run_id == run_id, DagRun.dag_id == self.dag_id)",
            "            ).one()  # Raises an error if not found",
            "            resolve_execution_date = dag_run.execution_date",
            "        else:",
            "            resolve_execution_date = execution_date",
            "",
            "        end_date = resolve_execution_date if not future else None",
            "        start_date = resolve_execution_date if not past else None",
            "",
            "        task_group_dict = self.task_group.get_task_group_dict()",
            "        task_group = task_group_dict.get(group_id)",
            "        if task_group is None:",
            "            raise ValueError(\"TaskGroup {group_id} could not be found\")",
            "        tasks_to_set_state = [task for task in task_group.iter_tasks() if isinstance(task, BaseOperator)]",
            "        task_ids = [task.task_id for task in task_group.iter_tasks()]",
            "",
            "        dag_runs_query = session.query(DagRun.id).where(DagRun.dag_id == self.dag_id)",
            "        if start_date is None and end_date is None:",
            "            dag_runs_query = dag_runs_query.where(DagRun.execution_date == start_date)",
            "        else:",
            "            if start_date is not None:",
            "                dag_runs_query = dag_runs_query.where(DagRun.execution_date >= start_date)",
            "            if end_date is not None:",
            "                dag_runs_query = dag_runs_query.where(DagRun.execution_date <= end_date)",
            "",
            "        with lock_rows(dag_runs_query, session):",
            "            altered = set_state(",
            "                tasks=tasks_to_set_state,",
            "                execution_date=execution_date,",
            "                run_id=run_id,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=state,",
            "                commit=commit,",
            "                session=session,",
            "            )",
            "            if not commit:",
            "                return altered",
            "",
            "            # Clear downstream tasks that are in failed/upstream_failed state to resume them.",
            "            # Flush the session so that the tasks marked success are reflected in the db.",
            "            session.flush()",
            "            task_subset = self.partial_subset(",
            "                task_ids_or_regex=task_ids,",
            "                include_downstream=True,",
            "                include_upstream=False,",
            "            )",
            "",
            "            task_subset.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                include_subdags=True,",
            "                include_parentdag=True,",
            "                only_failed=True,",
            "                session=session,",
            "                # Exclude the task from the current group from being cleared",
            "                exclude_task_ids=frozenset(task_ids),",
            "            )",
            "",
            "        return altered",
            "",
            "    @property",
            "    def roots(self) -> list[Operator]:",
            "        \"\"\"Return nodes with no parents. These are first to execute and are called roots or root nodes.\"\"\"",
            "        return [task for task in self.tasks if not task.upstream_list]",
            "",
            "    @property",
            "    def leaves(self) -> list[Operator]:",
            "        \"\"\"Return nodes with no children. These are last to execute and are called leaves or leaf nodes.\"\"\"",
            "        return [task for task in self.tasks if not task.downstream_list]",
            "",
            "    def topological_sort(self, include_subdag_tasks: bool = False):",
            "        \"\"\"",
            "        Sorts tasks in topographical order, such that a task comes after any of its",
            "        upstream dependencies.",
            "",
            "        Deprecated in place of ``task_group.topological_sort``",
            "        \"\"\"",
            "        from airflow.utils.task_group import TaskGroup",
            "",
            "        def nested_topo(group):",
            "            for node in group.topological_sort(_include_subdag_tasks=include_subdag_tasks):",
            "                if isinstance(node, TaskGroup):",
            "                    yield from nested_topo(node)",
            "                else:",
            "                    yield node",
            "",
            "        return tuple(nested_topo(self.task_group))",
            "",
            "    @provide_session",
            "    def set_dag_runs_state(",
            "        self,",
            "        state: str = State.RUNNING,",
            "        session: Session = NEW_SESSION,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        dag_ids: list[str] = [],",
            "    ) -> None:",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=3,",
            "        )",
            "        dag_ids = dag_ids or [self.dag_id]",
            "        query = update(DagRun).where(DagRun.dag_id.in_(dag_ids))",
            "        if start_date:",
            "            query = query.where(DagRun.execution_date >= start_date)",
            "        if end_date:",
            "            query = query.where(DagRun.execution_date <= end_date)",
            "        session.execute(query.values(state=state).execution_options(synchronize_session=\"fetch\"))",
            "",
            "    @provide_session",
            "    def clear(",
            "        self,",
            "        task_ids: Collection[str | tuple[str, int]] | None = None,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        only_failed: bool = False,",
            "        only_running: bool = False,",
            "        confirm_prompt: bool = False,",
            "        include_subdags: bool = True,",
            "        include_parentdag: bool = True,",
            "        dag_run_state: DagRunState = DagRunState.QUEUED,",
            "        dry_run: bool = False,",
            "        session: Session = NEW_SESSION,",
            "        get_tis: bool = False,",
            "        recursion_depth: int = 0,",
            "        max_recursion_depth: int | None = None,",
            "        dag_bag: DagBag | None = None,",
            "        exclude_task_ids: frozenset[str] | frozenset[tuple[str, int]] | None = frozenset(),",
            "    ) -> int | Iterable[TaskInstance]:",
            "        \"\"\"",
            "        Clears a set of task instances associated with the current dag for",
            "        a specified date range.",
            "",
            "        :param task_ids: List of task ids or (``task_id``, ``map_index``) tuples to clear",
            "        :param start_date: The minimum execution_date to clear",
            "        :param end_date: The maximum execution_date to clear",
            "        :param only_failed: Only clear failed tasks",
            "        :param only_running: Only clear running tasks.",
            "        :param confirm_prompt: Ask for confirmation",
            "        :param include_subdags: Clear tasks in subdags and clear external tasks",
            "            indicated by ExternalTaskMarker",
            "        :param include_parentdag: Clear tasks in the parent dag of the subdag.",
            "        :param dag_run_state: state to set DagRun to. If set to False, dagrun state will not",
            "            be changed.",
            "        :param dry_run: Find the tasks to clear but don't clear them.",
            "        :param session: The sqlalchemy session to use",
            "        :param dag_bag: The DagBag used to find the dags subdags (Optional)",
            "        :param exclude_task_ids: A set of ``task_id`` or (``task_id``, ``map_index``)",
            "            tuples that should not be cleared",
            "        \"\"\"",
            "        if get_tis:",
            "            warnings.warn(",
            "                \"Passing `get_tis` to dag.clear() is deprecated. Use `dry_run` parameter instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            dry_run = True",
            "",
            "        if recursion_depth:",
            "            warnings.warn(",
            "                \"Passing `recursion_depth` to dag.clear() is deprecated.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "        if max_recursion_depth:",
            "            warnings.warn(",
            "                \"Passing `max_recursion_depth` to dag.clear() is deprecated.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        state = []",
            "        if only_failed:",
            "            state += [State.FAILED, State.UPSTREAM_FAILED]",
            "        if only_running:",
            "            # Yes, having `+=` doesn't make sense, but this was the existing behaviour",
            "            state += [State.RUNNING]",
            "",
            "        tis = self._get_task_instances(",
            "            task_ids=task_ids,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            run_id=None,",
            "            state=state,",
            "            include_subdags=include_subdags,",
            "            include_parentdag=include_parentdag,",
            "            include_dependent_dags=include_subdags,  # compat, yes this is not a typo",
            "            session=session,",
            "            dag_bag=dag_bag,",
            "            exclude_task_ids=exclude_task_ids,",
            "        )",
            "",
            "        if dry_run:",
            "            return session.scalars(tis).all()",
            "",
            "        tis = session.scalars(tis).all()",
            "",
            "        count = len(list(tis))",
            "        do_it = True",
            "        if count == 0:",
            "            return 0",
            "        if confirm_prompt:",
            "            ti_list = \"\\n\".join(str(t) for t in tis)",
            "            question = (",
            "                \"You are about to delete these {count} tasks:\\n{ti_list}\\n\\nAre you sure? [y/n]\"",
            "            ).format(count=count, ti_list=ti_list)",
            "            do_it = utils.helpers.ask_yesno(question)",
            "",
            "        if do_it:",
            "            clear_task_instances(",
            "                list(tis),",
            "                session,",
            "                dag=self,",
            "                dag_run_state=dag_run_state,",
            "            )",
            "        else:",
            "            count = 0",
            "            print(\"Cancelled, nothing was cleared.\")",
            "",
            "        session.flush()",
            "        return count",
            "",
            "    @classmethod",
            "    def clear_dags(",
            "        cls,",
            "        dags,",
            "        start_date=None,",
            "        end_date=None,",
            "        only_failed=False,",
            "        only_running=False,",
            "        confirm_prompt=False,",
            "        include_subdags=True,",
            "        include_parentdag=False,",
            "        dag_run_state=DagRunState.QUEUED,",
            "        dry_run=False,",
            "    ):",
            "        all_tis = []",
            "        for dag in dags:",
            "            tis = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                only_failed=only_failed,",
            "                only_running=only_running,",
            "                confirm_prompt=False,",
            "                include_subdags=include_subdags,",
            "                include_parentdag=include_parentdag,",
            "                dag_run_state=dag_run_state,",
            "                dry_run=True,",
            "            )",
            "            all_tis.extend(tis)",
            "",
            "        if dry_run:",
            "            return all_tis",
            "",
            "        count = len(all_tis)",
            "        do_it = True",
            "        if count == 0:",
            "            print(\"Nothing to clear.\")",
            "            return 0",
            "        if confirm_prompt:",
            "            ti_list = \"\\n\".join(str(t) for t in all_tis)",
            "            question = f\"You are about to delete these {count} tasks:\\n{ti_list}\\n\\nAre you sure? [y/n]\"",
            "            do_it = utils.helpers.ask_yesno(question)",
            "",
            "        if do_it:",
            "            for dag in dags:",
            "                dag.clear(",
            "                    start_date=start_date,",
            "                    end_date=end_date,",
            "                    only_failed=only_failed,",
            "                    only_running=only_running,",
            "                    confirm_prompt=False,",
            "                    include_subdags=include_subdags,",
            "                    dag_run_state=dag_run_state,",
            "                    dry_run=False,",
            "                )",
            "        else:",
            "            count = 0",
            "            print(\"Cancelled, nothing was cleared.\")",
            "        return count",
            "",
            "    def __deepcopy__(self, memo):",
            "        # Switcharoo to go around deepcopying objects coming through the",
            "        # backdoor",
            "        cls = self.__class__",
            "        result = cls.__new__(cls)",
            "        memo[id(self)] = result",
            "        for k, v in self.__dict__.items():",
            "            if k not in (\"user_defined_macros\", \"user_defined_filters\", \"_log\"):",
            "                setattr(result, k, copy.deepcopy(v, memo))",
            "",
            "        result.user_defined_macros = self.user_defined_macros",
            "        result.user_defined_filters = self.user_defined_filters",
            "        if hasattr(self, \"_log\"):",
            "            result._log = self._log",
            "        return result",
            "",
            "    def sub_dag(self, *args, **kwargs):",
            "        \"\"\"This method is deprecated in favor of partial_subset.\"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version. Please use partial_subset\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.partial_subset(*args, **kwargs)",
            "",
            "    def partial_subset(",
            "        self,",
            "        task_ids_or_regex: str | Pattern | Iterable[str],",
            "        include_downstream=False,",
            "        include_upstream=True,",
            "        include_direct_upstream=False,",
            "    ):",
            "        \"\"\"",
            "        Returns a subset of the current dag as a deep copy of the current dag",
            "        based on a regex that should match one or many tasks, and includes",
            "        upstream and downstream neighbours based on the flag passed.",
            "",
            "        :param task_ids_or_regex: Either a list of task_ids, or a regex to",
            "            match against task ids (as a string, or compiled regex pattern).",
            "        :param include_downstream: Include all downstream tasks of matched",
            "            tasks, in addition to matched tasks.",
            "        :param include_upstream: Include all upstream tasks of matched tasks,",
            "            in addition to matched tasks.",
            "        :param include_direct_upstream: Include all tasks directly upstream of matched",
            "            and downstream (if include_downstream = True) tasks",
            "        \"\"\"",
            "        from airflow.models.baseoperator import BaseOperator",
            "        from airflow.models.mappedoperator import MappedOperator",
            "",
            "        # deep-copying self.task_dict and self._task_group takes a long time, and we don't want all",
            "        # the tasks anyway, so we copy the tasks manually later",
            "        memo = {id(self.task_dict): None, id(self._task_group): None}",
            "        dag = copy.deepcopy(self, memo)  # type: ignore",
            "",
            "        if isinstance(task_ids_or_regex, (str, Pattern)):",
            "            matched_tasks = [t for t in self.tasks if re.findall(task_ids_or_regex, t.task_id)]",
            "        else:",
            "            matched_tasks = [t for t in self.tasks if t.task_id in task_ids_or_regex]",
            "",
            "        also_include: list[Operator] = []",
            "        for t in matched_tasks:",
            "            if include_downstream:",
            "                also_include.extend(t.get_flat_relatives(upstream=False))",
            "            if include_upstream:",
            "                also_include.extend(t.get_upstreams_follow_setups())",
            "            else:",
            "                also_include.extend(t.get_upstreams_only_setups_and_teardowns())",
            "",
            "        direct_upstreams: list[Operator] = []",
            "        if include_direct_upstream:",
            "            for t in itertools.chain(matched_tasks, also_include):",
            "                upstream = (u for u in t.upstream_list if isinstance(u, (BaseOperator, MappedOperator)))",
            "                direct_upstreams.extend(upstream)",
            "",
            "        # Compiling the unique list of tasks that made the cut",
            "        # Make sure to not recursively deepcopy the dag or task_group while copying the task.",
            "        # task_group is reset later",
            "        def _deepcopy_task(t) -> Operator:",
            "            memo.setdefault(id(t.task_group), None)",
            "            return copy.deepcopy(t, memo)",
            "",
            "        dag.task_dict = {",
            "            t.task_id: _deepcopy_task(t)",
            "            for t in itertools.chain(matched_tasks, also_include, direct_upstreams)",
            "        }",
            "",
            "        def filter_task_group(group, parent_group):",
            "            \"\"\"Exclude tasks not included in the subdag from the given TaskGroup.\"\"\"",
            "            # We want to deepcopy _most but not all_ attributes of the task group, so we create a shallow copy",
            "            # and then manually deep copy the instances. (memo argument to deepcopy only works for instances",
            "            # of classes, not \"native\" properties of an instance)",
            "            copied = copy.copy(group)",
            "",
            "            memo[id(group.children)] = {}",
            "            if parent_group:",
            "                memo[id(group.parent_group)] = parent_group",
            "            for attr, value in copied.__dict__.items():",
            "                if id(value) in memo:",
            "                    value = memo[id(value)]",
            "                else:",
            "                    value = copy.deepcopy(value, memo)",
            "                copied.__dict__[attr] = value",
            "",
            "            proxy = weakref.proxy(copied)",
            "",
            "            for child in group.children.values():",
            "                if isinstance(child, AbstractOperator):",
            "                    if child.task_id in dag.task_dict:",
            "                        task = copied.children[child.task_id] = dag.task_dict[child.task_id]",
            "                        task.task_group = proxy",
            "                    else:",
            "                        copied.used_group_ids.discard(child.task_id)",
            "                else:",
            "                    filtered_child = filter_task_group(child, proxy)",
            "",
            "                    # Only include this child TaskGroup if it is non-empty.",
            "                    if filtered_child.children:",
            "                        copied.children[child.group_id] = filtered_child",
            "",
            "            return copied",
            "",
            "        dag._task_group = filter_task_group(self.task_group, None)",
            "",
            "        # Removing upstream/downstream references to tasks and TaskGroups that did not make",
            "        # the cut.",
            "        subdag_task_groups = dag.task_group.get_task_group_dict()",
            "        for group in subdag_task_groups.values():",
            "            group.upstream_group_ids.intersection_update(subdag_task_groups)",
            "            group.downstream_group_ids.intersection_update(subdag_task_groups)",
            "            group.upstream_task_ids.intersection_update(dag.task_dict)",
            "            group.downstream_task_ids.intersection_update(dag.task_dict)",
            "",
            "        for t in dag.tasks:",
            "            # Removing upstream/downstream references to tasks that did not",
            "            # make the cut",
            "            t.upstream_task_ids.intersection_update(dag.task_dict)",
            "            t.downstream_task_ids.intersection_update(dag.task_dict)",
            "",
            "        if len(dag.tasks) < len(self.tasks):",
            "            dag.partial = True",
            "",
            "        return dag",
            "",
            "    def has_task(self, task_id: str):",
            "        return task_id in self.task_dict",
            "",
            "    def has_task_group(self, task_group_id: str) -> bool:",
            "        return task_group_id in self.task_group_dict",
            "",
            "    @functools.cached_property",
            "    def task_group_dict(self):",
            "        return {k: v for k, v in self._task_group.get_task_group_dict().items() if k is not None}",
            "",
            "    def get_task(self, task_id: str, include_subdags: bool = False) -> Operator:",
            "        if task_id in self.task_dict:",
            "            return self.task_dict[task_id]",
            "        if include_subdags:",
            "            for dag in self.subdags:",
            "                if task_id in dag.task_dict:",
            "                    return dag.task_dict[task_id]",
            "        raise TaskNotFound(f\"Task {task_id} not found\")",
            "",
            "    def pickle_info(self):",
            "        d = {}",
            "        d[\"is_picklable\"] = True",
            "        try:",
            "            dttm = timezone.utcnow()",
            "            pickled = pickle.dumps(self)",
            "            d[\"pickle_len\"] = len(pickled)",
            "            d[\"pickling_duration\"] = str(timezone.utcnow() - dttm)",
            "        except Exception as e:",
            "            self.log.debug(e)",
            "            d[\"is_picklable\"] = False",
            "            d[\"stacktrace\"] = traceback.format_exc()",
            "        return d",
            "",
            "    @provide_session",
            "    def pickle(self, session=NEW_SESSION) -> DagPickle:",
            "        dag = session.scalar(select(DagModel).where(DagModel.dag_id == self.dag_id).limit(1))",
            "        dp = None",
            "        if dag and dag.pickle_id:",
            "            dp = session.scalar(select(DagPickle).where(DagPickle.id == dag.pickle_id).limit(1))",
            "        if not dp or dp.pickle != self:",
            "            dp = DagPickle(dag=self)",
            "            session.add(dp)",
            "            self.last_pickled = timezone.utcnow()",
            "            session.commit()",
            "            self.pickle_id = dp.id",
            "",
            "        return dp",
            "",
            "    def tree_view(self) -> None:",
            "        \"\"\"Print an ASCII tree representation of the DAG.\"\"\"",
            "",
            "        def get_downstream(task, level=0):",
            "            print((\" \" * level * 4) + str(task))",
            "            level += 1",
            "            for t in task.downstream_list:",
            "                get_downstream(t, level)",
            "",
            "        for t in self.roots:",
            "            get_downstream(t)",
            "",
            "    @property",
            "    def task(self) -> TaskDecoratorCollection:",
            "        from airflow.decorators import task",
            "",
            "        return cast(\"TaskDecoratorCollection\", functools.partial(task, dag=self))",
            "",
            "    def add_task(self, task: Operator) -> None:",
            "        \"\"\"",
            "        Add a task to the DAG.",
            "",
            "        :param task: the task you want to add",
            "        \"\"\"",
            "        DagInvalidTriggerRule.check(self, task.trigger_rule)",
            "",
            "        from airflow.utils.task_group import TaskGroupContext",
            "",
            "        if not self.start_date and not task.start_date:",
            "            raise AirflowException(\"DAG is missing the start_date parameter\")",
            "        # if the task has no start date, assign it the same as the DAG",
            "        elif not task.start_date:",
            "            task.start_date = self.start_date",
            "        # otherwise, the task will start on the later of its own start date and",
            "        # the DAG's start date",
            "        elif self.start_date:",
            "            task.start_date = max(task.start_date, self.start_date)",
            "",
            "        # if the task has no end date, assign it the same as the dag",
            "        if not task.end_date:",
            "            task.end_date = self.end_date",
            "        # otherwise, the task will end on the earlier of its own end date and",
            "        # the DAG's end date",
            "        elif task.end_date and self.end_date:",
            "            task.end_date = min(task.end_date, self.end_date)",
            "",
            "        task_id = task.task_id",
            "        if not task.task_group:",
            "            task_group = TaskGroupContext.get_current_task_group(self)",
            "            if task_group:",
            "                task_id = task_group.child_id(task_id)",
            "                task_group.add(task)",
            "",
            "        if (",
            "            task_id in self.task_dict and self.task_dict[task_id] is not task",
            "        ) or task_id in self._task_group.used_group_ids:",
            "            raise DuplicateTaskIdFound(f\"Task id '{task_id}' has already been added to the DAG\")",
            "        else:",
            "            self.task_dict[task_id] = task",
            "            task.dag = self",
            "            # Add task_id to used_group_ids to prevent group_id and task_id collisions.",
            "            self._task_group.used_group_ids.add(task_id)",
            "",
            "        self.task_count = len(self.task_dict)",
            "",
            "    def add_tasks(self, tasks: Iterable[Operator]) -> None:",
            "        \"\"\"",
            "        Add a list of tasks to the DAG.",
            "",
            "        :param tasks: a lit of tasks you want to add",
            "        \"\"\"",
            "        for task in tasks:",
            "            self.add_task(task)",
            "",
            "    def _remove_task(self, task_id: str) -> None:",
            "        # This is \"private\" as removing could leave a hole in dependencies if done incorrectly, and this",
            "        # doesn't guard against that",
            "        task = self.task_dict.pop(task_id)",
            "        tg = getattr(task, \"task_group\", None)",
            "        if tg:",
            "            tg._remove(task)",
            "",
            "        self.task_count = len(self.task_dict)",
            "",
            "    def run(",
            "        self,",
            "        start_date=None,",
            "        end_date=None,",
            "        mark_success=False,",
            "        local=False,",
            "        executor=None,",
            "        donot_pickle=conf.getboolean(\"core\", \"donot_pickle\"),",
            "        ignore_task_deps=False,",
            "        ignore_first_depends_on_past=True,",
            "        pool=None,",
            "        delay_on_limit_secs=1.0,",
            "        verbose=False,",
            "        conf=None,",
            "        rerun_failed_tasks=False,",
            "        run_backwards=False,",
            "        run_at_least_once=False,",
            "        continue_on_failures=False,",
            "        disable_retry=False,",
            "    ):",
            "        \"\"\"",
            "        Runs the DAG.",
            "",
            "        :param start_date: the start date of the range to run",
            "        :param end_date: the end date of the range to run",
            "        :param mark_success: True to mark jobs as succeeded without running them",
            "        :param local: True to run the tasks using the LocalExecutor",
            "        :param executor: The executor instance to run the tasks",
            "        :param donot_pickle: True to avoid pickling DAG object and send to workers",
            "        :param ignore_task_deps: True to skip upstream tasks",
            "        :param ignore_first_depends_on_past: True to ignore depends_on_past",
            "            dependencies for the first set of tasks only",
            "        :param pool: Resource pool to use",
            "        :param delay_on_limit_secs: Time in seconds to wait before next attempt to run",
            "            dag run when max_active_runs limit has been reached",
            "        :param verbose: Make logging output more verbose",
            "        :param conf: user defined dictionary passed from CLI",
            "        :param rerun_failed_tasks:",
            "        :param run_backwards:",
            "        :param run_at_least_once: If true, always run the DAG at least once even",
            "            if no logical run exists within the time range.",
            "        \"\"\"",
            "        from airflow.jobs.backfill_job_runner import BackfillJobRunner",
            "",
            "        if not executor and local:",
            "            from airflow.executors.local_executor import LocalExecutor",
            "",
            "            executor = LocalExecutor()",
            "        elif not executor:",
            "            from airflow.executors.executor_loader import ExecutorLoader",
            "",
            "            executor = ExecutorLoader.get_default_executor()",
            "        from airflow.jobs.job import Job",
            "",
            "        job = Job(executor=executor)",
            "        job_runner = BackfillJobRunner(",
            "            job=job,",
            "            dag=self,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            mark_success=mark_success,",
            "            donot_pickle=donot_pickle,",
            "            ignore_task_deps=ignore_task_deps,",
            "            ignore_first_depends_on_past=ignore_first_depends_on_past,",
            "            pool=pool,",
            "            delay_on_limit_secs=delay_on_limit_secs,",
            "            verbose=verbose,",
            "            conf=conf,",
            "            rerun_failed_tasks=rerun_failed_tasks,",
            "            run_backwards=run_backwards,",
            "            run_at_least_once=run_at_least_once,",
            "            continue_on_failures=continue_on_failures,",
            "            disable_retry=disable_retry,",
            "        )",
            "        run_job(job=job, execute_callable=job_runner._execute)",
            "",
            "    def cli(self):",
            "        \"\"\"Exposes a CLI specific to this DAG.\"\"\"",
            "        check_cycle(self)",
            "",
            "        from airflow.cli import cli_parser",
            "",
            "        parser = cli_parser.get_parser(dag_parser=True)",
            "        args = parser.parse_args()",
            "        args.func(args, self)",
            "",
            "    @provide_session",
            "    def test(",
            "        self,",
            "        execution_date: datetime | None = None,",
            "        run_conf: dict[str, Any] | None = None,",
            "        conn_file_path: str | None = None,",
            "        variable_file_path: str | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"",
            "        Execute one single DagRun for a given DAG and execution date.",
            "",
            "        :param execution_date: execution date for the DAG run",
            "        :param run_conf: configuration to pass to newly created dagrun",
            "        :param conn_file_path: file path to a connection file in either yaml or json",
            "        :param variable_file_path: file path to a variable file in either yaml or json",
            "        :param session: database connection (optional)",
            "        \"\"\"",
            "",
            "        def add_logger_if_needed(ti: TaskInstance):",
            "            \"\"\"Add a formatted logger to the task instance.",
            "",
            "            This allows all logs to surface to the command line, instead of into",
            "            a task file. Since this is a local test run, it is much better for",
            "            the user to see logs in the command line, rather than needing to",
            "            search for a log file.",
            "",
            "            :param ti: The task instance that will receive a logger.",
            "            \"\"\"",
            "            format = logging.Formatter(\"[%(asctime)s] {%(filename)s:%(lineno)d} %(levelname)s - %(message)s\")",
            "            handler = logging.StreamHandler(sys.stdout)",
            "            handler.level = logging.INFO",
            "            handler.setFormatter(format)",
            "            # only add log handler once",
            "            if not any(isinstance(h, logging.StreamHandler) for h in ti.log.handlers):",
            "                self.log.debug(\"Adding Streamhandler to taskinstance %s\", ti.task_id)",
            "                ti.log.addHandler(handler)",
            "",
            "        if conn_file_path or variable_file_path:",
            "            local_secrets = LocalFilesystemBackend(",
            "                variables_file_path=variable_file_path, connections_file_path=conn_file_path",
            "            )",
            "            secrets_backend_list.insert(0, local_secrets)",
            "",
            "        execution_date = execution_date or timezone.utcnow()",
            "        self.log.debug(\"Clearing existing task instances for execution date %s\", execution_date)",
            "        self.clear(",
            "            start_date=execution_date,",
            "            end_date=execution_date,",
            "            dag_run_state=False,  # type: ignore",
            "            session=session,",
            "        )",
            "        self.log.debug(\"Getting dagrun for dag %s\", self.dag_id)",
            "        dr: DagRun = _get_or_create_dagrun(",
            "            dag=self,",
            "            start_date=execution_date,",
            "            execution_date=execution_date,",
            "            run_id=DagRun.generate_run_id(DagRunType.MANUAL, execution_date),",
            "            session=session,",
            "            conf=run_conf,",
            "        )",
            "",
            "        tasks = self.task_dict",
            "        self.log.debug(\"starting dagrun\")",
            "        # Instead of starting a scheduler, we run the minimal loop possible to check",
            "        # for task readiness and dependency management. This is notably faster",
            "        # than creating a BackfillJob and allows us to surface logs to the user",
            "        while dr.state == State.RUNNING:",
            "            schedulable_tis, _ = dr.update_state(session=session)",
            "            try:",
            "                for ti in schedulable_tis:",
            "                    add_logger_if_needed(ti)",
            "                    ti.task = tasks[ti.task_id]",
            "                    _run_task(ti, session=session)",
            "            except Exception:",
            "                self.log.info(",
            "                    \"Task failed. DAG will continue to run until finished and be marked as failed.\",",
            "                    exc_info=True,",
            "                )",
            "        if conn_file_path or variable_file_path:",
            "            # Remove the local variables we have added to the secrets_backend_list",
            "            secrets_backend_list.pop(0)",
            "",
            "    @provide_session",
            "    def create_dagrun(",
            "        self,",
            "        state: DagRunState,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        start_date: datetime | None = None,",
            "        external_trigger: bool | None = False,",
            "        conf: dict | None = None,",
            "        run_type: DagRunType | None = None,",
            "        session: Session = NEW_SESSION,",
            "        dag_hash: str | None = None,",
            "        creating_job_id: int | None = None,",
            "        data_interval: tuple[datetime, datetime] | None = None,",
            "    ):",
            "        \"\"\"",
            "        Creates a dag run from this dag including the tasks associated with this dag.",
            "        Returns the dag run.",
            "",
            "        :param run_id: defines the run id for this dag run",
            "        :param run_type: type of DagRun",
            "        :param execution_date: the execution date of this dag run",
            "        :param state: the state of the dag run",
            "        :param start_date: the date this dag run should be evaluated",
            "        :param external_trigger: whether this dag run is externally triggered",
            "        :param conf: Dict containing configuration/parameters to pass to the DAG",
            "        :param creating_job_id: id of the job creating this DagRun",
            "        :param session: database session",
            "        :param dag_hash: Hash of Serialized DAG",
            "        :param data_interval: Data interval of the DagRun",
            "        \"\"\"",
            "        logical_date = timezone.coerce_datetime(execution_date)",
            "",
            "        if data_interval and not isinstance(data_interval, DataInterval):",
            "            data_interval = DataInterval(*map(timezone.coerce_datetime, data_interval))",
            "",
            "        if data_interval is None and logical_date is not None:",
            "            warnings.warn(",
            "                \"Calling `DAG.create_dagrun()` without an explicit data interval is deprecated\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=3,",
            "            )",
            "            if run_type == DagRunType.MANUAL:",
            "                data_interval = self.timetable.infer_manual_data_interval(run_after=logical_date)",
            "            else:",
            "                data_interval = self.infer_automated_data_interval(logical_date)",
            "",
            "        if run_type is None or isinstance(run_type, DagRunType):",
            "            pass",
            "        elif isinstance(run_type, str):  # Compatibility: run_type used to be a str.",
            "            run_type = DagRunType(run_type)",
            "        else:",
            "            raise ValueError(f\"`run_type` should be a DagRunType, not {type(run_type)}\")",
            "",
            "        if run_id:  # Infer run_type from run_id if needed.",
            "            if not isinstance(run_id, str):",
            "                raise ValueError(f\"`run_id` should be a str, not {type(run_id)}\")",
            "            inferred_run_type = DagRunType.from_run_id(run_id)",
            "            if run_type is None:",
            "                # No explicit type given, use the inferred type.",
            "                run_type = inferred_run_type",
            "            elif run_type == DagRunType.MANUAL and inferred_run_type != DagRunType.MANUAL:",
            "                # Prevent a manual run from using an ID that looks like a scheduled run.",
            "                raise ValueError(",
            "                    f\"A {run_type.value} DAG run cannot use ID {run_id!r} since it \"",
            "                    f\"is reserved for {inferred_run_type.value} runs\"",
            "                )",
            "        elif run_type and logical_date is not None:  # Generate run_id from run_type and execution_date.",
            "            run_id = self.timetable.generate_run_id(",
            "                run_type=run_type, logical_date=logical_date, data_interval=data_interval",
            "            )",
            "        else:",
            "            raise AirflowException(",
            "                \"Creating DagRun needs either `run_id` or both `run_type` and `execution_date`\"",
            "            )",
            "",
            "        if run_id and \"/\" in run_id:",
            "            warnings.warn(",
            "                \"Using forward slash ('/') in a DAG run ID is deprecated. Note that this character \"",
            "                \"also makes the run impossible to retrieve via Airflow's REST API.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=3,",
            "            )",
            "",
            "        # create a copy of params before validating",
            "        copied_params = copy.deepcopy(self.params)",
            "        copied_params.update(conf or {})",
            "        copied_params.validate()",
            "",
            "        run = DagRun(",
            "            dag_id=self.dag_id,",
            "            run_id=run_id,",
            "            execution_date=logical_date,",
            "            start_date=start_date,",
            "            external_trigger=external_trigger,",
            "            conf=conf,",
            "            state=state,",
            "            run_type=run_type,",
            "            dag_hash=dag_hash,",
            "            creating_job_id=creating_job_id,",
            "            data_interval=data_interval,",
            "        )",
            "        session.add(run)",
            "        session.flush()",
            "",
            "        run.dag = self",
            "",
            "        # create the associated task instances",
            "        # state is None at the moment of creation",
            "        run.verify_integrity(session=session)",
            "",
            "        return run",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_sync_to_db(",
            "        cls,",
            "        dags: Collection[DAG],",
            "        session=NEW_SESSION,",
            "    ):",
            "        \"\"\"This method is deprecated in favor of bulk_write_to_db.\"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version. Please use bulk_write_to_db\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return cls.bulk_write_to_db(dags=dags, session=session)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_write_to_db(",
            "        cls,",
            "        dags: Collection[DAG],",
            "        processor_subdir: str | None = None,",
            "        session=NEW_SESSION,",
            "    ):",
            "        \"\"\"",
            "        Ensure the DagModel rows for the given dags are up-to-date in the dag table in the DB, including",
            "        calculated fields.",
            "",
            "        Note that this method can be called for both DAGs and SubDAGs. A SubDag is actually a SubDagOperator.",
            "",
            "        :param dags: the DAG objects to save to the DB",
            "        :return: None",
            "        \"\"\"",
            "        if not dags:",
            "            return",
            "",
            "        log.info(\"Sync %s DAGs\", len(dags))",
            "        dag_by_ids = {dag.dag_id: dag for dag in dags}",
            "",
            "        dag_ids = set(dag_by_ids.keys())",
            "        query = (",
            "            select(DagModel)",
            "            .options(joinedload(DagModel.tags, innerjoin=False))",
            "            .where(DagModel.dag_id.in_(dag_ids))",
            "            .options(joinedload(DagModel.schedule_dataset_references))",
            "            .options(joinedload(DagModel.task_outlet_dataset_references))",
            "        )",
            "        query = with_row_locks(query, of=DagModel, session=session)",
            "        orm_dags: list[DagModel] = session.scalars(query).unique().all()",
            "        existing_dags = {orm_dag.dag_id: orm_dag for orm_dag in orm_dags}",
            "        missing_dag_ids = dag_ids.difference(existing_dags)",
            "",
            "        for missing_dag_id in missing_dag_ids:",
            "            orm_dag = DagModel(dag_id=missing_dag_id)",
            "            dag = dag_by_ids[missing_dag_id]",
            "            if dag.is_paused_upon_creation is not None:",
            "                orm_dag.is_paused = dag.is_paused_upon_creation",
            "            orm_dag.tags = []",
            "            log.info(\"Creating ORM DAG for %s\", dag.dag_id)",
            "            session.add(orm_dag)",
            "            orm_dags.append(orm_dag)",
            "",
            "        # Get the latest dag run for each existing dag as a single query (avoid n+1 query)",
            "        most_recent_subq = (",
            "            select(DagRun.dag_id, func.max(DagRun.execution_date).label(\"max_execution_date\"))",
            "            .where(",
            "                DagRun.dag_id.in_(existing_dags),",
            "                or_(DagRun.run_type == DagRunType.BACKFILL_JOB, DagRun.run_type == DagRunType.SCHEDULED),",
            "            )",
            "            .group_by(DagRun.dag_id)",
            "            .subquery()",
            "        )",
            "        most_recent_runs_iter = session.scalars(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == most_recent_subq.c.dag_id,",
            "                DagRun.execution_date == most_recent_subq.c.max_execution_date,",
            "            )",
            "        )",
            "        most_recent_runs = {run.dag_id: run for run in most_recent_runs_iter}",
            "",
            "        # Get number of active dagruns for all dags we are processing as a single query.",
            "",
            "        num_active_runs = DagRun.active_runs_of_dags(dag_ids=existing_dags, session=session)",
            "",
            "        filelocs = []",
            "",
            "        for orm_dag in sorted(orm_dags, key=lambda d: d.dag_id):",
            "            dag = dag_by_ids[orm_dag.dag_id]",
            "            filelocs.append(dag.fileloc)",
            "            if dag.is_subdag:",
            "                orm_dag.is_subdag = True",
            "                orm_dag.fileloc = dag.parent_dag.fileloc  # type: ignore",
            "                orm_dag.root_dag_id = dag.parent_dag.dag_id  # type: ignore",
            "                orm_dag.owners = dag.parent_dag.owner  # type: ignore",
            "            else:",
            "                orm_dag.is_subdag = False",
            "                orm_dag.fileloc = dag.fileloc",
            "                orm_dag.owners = dag.owner",
            "            orm_dag.is_active = True",
            "            orm_dag.has_import_errors = False",
            "            orm_dag.last_parsed_time = timezone.utcnow()",
            "            orm_dag.default_view = dag.default_view",
            "            orm_dag.description = dag.description",
            "            orm_dag.max_active_tasks = dag.max_active_tasks",
            "            orm_dag.max_active_runs = dag.max_active_runs",
            "            orm_dag.has_task_concurrency_limits = any(",
            "                t.max_active_tis_per_dag is not None or t.max_active_tis_per_dagrun is not None",
            "                for t in dag.tasks",
            "            )",
            "            orm_dag.schedule_interval = dag.schedule_interval",
            "            orm_dag.timetable_description = dag.timetable.description",
            "            orm_dag.processor_subdir = processor_subdir",
            "",
            "            run: DagRun | None = most_recent_runs.get(dag.dag_id)",
            "            if run is None:",
            "                data_interval = None",
            "            else:",
            "                data_interval = dag.get_run_data_interval(run)",
            "            if num_active_runs.get(dag.dag_id, 0) >= orm_dag.max_active_runs:",
            "                orm_dag.next_dagrun_create_after = None",
            "            else:",
            "                orm_dag.calculate_dagrun_date_fields(dag, data_interval)",
            "",
            "            dag_tags = set(dag.tags or {})",
            "            orm_dag_tags = list(orm_dag.tags or [])",
            "            for orm_tag in orm_dag_tags:",
            "                if orm_tag.name not in dag_tags:",
            "                    session.delete(orm_tag)",
            "                    orm_dag.tags.remove(orm_tag)",
            "            orm_tag_names = {t.name for t in orm_dag_tags}",
            "            for dag_tag in dag_tags:",
            "                if dag_tag not in orm_tag_names:",
            "                    dag_tag_orm = DagTag(name=dag_tag, dag_id=dag.dag_id)",
            "                    orm_dag.tags.append(dag_tag_orm)",
            "                    session.add(dag_tag_orm)",
            "",
            "            orm_dag_links = orm_dag.dag_owner_links or []",
            "            for orm_dag_link in orm_dag_links:",
            "                if orm_dag_link not in dag.owner_links:",
            "                    session.delete(orm_dag_link)",
            "            for owner_name, owner_link in dag.owner_links.items():",
            "                dag_owner_orm = DagOwnerAttributes(dag_id=dag.dag_id, owner=owner_name, link=owner_link)",
            "                session.add(dag_owner_orm)",
            "",
            "        DagCode.bulk_sync_to_db(filelocs, session=session)",
            "",
            "        from airflow.datasets import Dataset",
            "        from airflow.models.dataset import (",
            "            DagScheduleDatasetReference,",
            "            DatasetModel,",
            "            TaskOutletDatasetReference,",
            "        )",
            "",
            "        dag_references = collections.defaultdict(set)",
            "        outlet_references = collections.defaultdict(set)",
            "        # We can't use a set here as we want to preserve order",
            "        outlet_datasets: dict[Dataset, None] = {}",
            "        input_datasets: dict[Dataset, None] = {}",
            "",
            "        # here we go through dags and tasks to check for dataset references",
            "        # if there are now None and previously there were some, we delete them",
            "        # if there are now *any*, we add them to the above data structures, and",
            "        # later we'll persist them to the database.",
            "        for dag in dags:",
            "            curr_orm_dag = existing_dags.get(dag.dag_id)",
            "            if not dag.dataset_triggers:",
            "                if curr_orm_dag and curr_orm_dag.schedule_dataset_references:",
            "                    curr_orm_dag.schedule_dataset_references = []",
            "            for dataset in dag.dataset_triggers:",
            "                dag_references[dag.dag_id].add(dataset.uri)",
            "                input_datasets[DatasetModel.from_public(dataset)] = None",
            "            curr_outlet_references = curr_orm_dag and curr_orm_dag.task_outlet_dataset_references",
            "            for task in dag.tasks:",
            "                dataset_outlets = [x for x in task.outlets or [] if isinstance(x, Dataset)]",
            "                if not dataset_outlets:",
            "                    if curr_outlet_references:",
            "                        this_task_outlet_refs = [",
            "                            x",
            "                            for x in curr_outlet_references",
            "                            if x.dag_id == dag.dag_id and x.task_id == task.task_id",
            "                        ]",
            "                        for ref in this_task_outlet_refs:",
            "                            curr_outlet_references.remove(ref)",
            "                for d in dataset_outlets:",
            "                    outlet_references[(task.dag_id, task.task_id)].add(d.uri)",
            "                    outlet_datasets[DatasetModel.from_public(d)] = None",
            "        all_datasets = outlet_datasets",
            "        all_datasets.update(input_datasets)",
            "",
            "        # store datasets",
            "        stored_datasets = {}",
            "        for dataset in all_datasets:",
            "            stored_dataset = session.scalar(",
            "                select(DatasetModel).where(DatasetModel.uri == dataset.uri).limit(1)",
            "            )",
            "            if stored_dataset:",
            "                # Some datasets may have been previously unreferenced, and therefore orphaned by the",
            "                # scheduler. But if we're here, then we have found that dataset again in our DAGs, which",
            "                # means that it is no longer an orphan, so set is_orphaned to False.",
            "                stored_dataset.is_orphaned = expression.false()",
            "                stored_datasets[stored_dataset.uri] = stored_dataset",
            "            else:",
            "                session.add(dataset)",
            "                stored_datasets[dataset.uri] = dataset",
            "",
            "        session.flush()  # this is required to ensure each dataset has its PK loaded",
            "",
            "        del all_datasets",
            "",
            "        # reconcile dag-schedule-on-dataset references",
            "        for dag_id, uri_list in dag_references.items():",
            "            dag_refs_needed = {",
            "                DagScheduleDatasetReference(dataset_id=stored_datasets[uri].id, dag_id=dag_id)",
            "                for uri in uri_list",
            "            }",
            "            dag_refs_stored = set(",
            "                existing_dags.get(dag_id)",
            "                and existing_dags.get(dag_id).schedule_dataset_references  # type: ignore",
            "                or []",
            "            )",
            "            dag_refs_to_add = {x for x in dag_refs_needed if x not in dag_refs_stored}",
            "            session.bulk_save_objects(dag_refs_to_add)",
            "            for obj in dag_refs_stored - dag_refs_needed:",
            "                session.delete(obj)",
            "",
            "        existing_task_outlet_refs_dict = collections.defaultdict(set)",
            "        for dag_id, orm_dag in existing_dags.items():",
            "            for todr in orm_dag.task_outlet_dataset_references:",
            "                existing_task_outlet_refs_dict[(dag_id, todr.task_id)].add(todr)",
            "",
            "        # reconcile task-outlet-dataset references",
            "        for (dag_id, task_id), uri_list in outlet_references.items():",
            "            task_refs_needed = {",
            "                TaskOutletDatasetReference(dataset_id=stored_datasets[uri].id, dag_id=dag_id, task_id=task_id)",
            "                for uri in uri_list",
            "            }",
            "            task_refs_stored = existing_task_outlet_refs_dict[(dag_id, task_id)]",
            "            task_refs_to_add = {x for x in task_refs_needed if x not in task_refs_stored}",
            "            session.bulk_save_objects(task_refs_to_add)",
            "            for obj in task_refs_stored - task_refs_needed:",
            "                session.delete(obj)",
            "",
            "        # Issue SQL/finish \"Unit of Work\", but let @provide_session commit (or if passed a session, let caller",
            "        # decide when to commit",
            "        session.flush()",
            "",
            "        for dag in dags:",
            "            cls.bulk_write_to_db(dag.subdags, processor_subdir=processor_subdir, session=session)",
            "",
            "    @provide_session",
            "    def sync_to_db(self, processor_subdir: str | None = None, session=NEW_SESSION):",
            "        \"\"\"",
            "        Save attributes about this DAG to the DB. Note that this method",
            "        can be called for both DAGs and SubDAGs. A SubDag is actually a",
            "        SubDagOperator.",
            "",
            "        :return: None",
            "        \"\"\"",
            "        self.bulk_write_to_db([self], processor_subdir=processor_subdir, session=session)",
            "",
            "    def get_default_view(self):",
            "        \"\"\"This is only there for backward compatible jinja2 templates.\"\"\"",
            "        if self.default_view is None:",
            "            return conf.get(\"webserver\", \"dag_default_view\").lower()",
            "        else:",
            "            return self.default_view",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def deactivate_unknown_dags(active_dag_ids, session=NEW_SESSION):",
            "        \"\"\"",
            "        Given a list of known DAGs, deactivate any other DAGs that are",
            "        marked as active in the ORM.",
            "",
            "        :param active_dag_ids: list of DAG IDs that are active",
            "        :return: None",
            "        \"\"\"",
            "        if len(active_dag_ids) == 0:",
            "            return",
            "        for dag in session.scalars(select(DagModel).where(~DagModel.dag_id.in_(active_dag_ids))).all():",
            "            dag.is_active = False",
            "            session.merge(dag)",
            "        session.commit()",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def deactivate_stale_dags(expiration_date, session=NEW_SESSION):",
            "        \"\"\"",
            "        Deactivate any DAGs that were last touched by the scheduler before",
            "        the expiration date. These DAGs were likely deleted.",
            "",
            "        :param expiration_date: set inactive DAGs that were touched before this",
            "            time",
            "        :return: None",
            "        \"\"\"",
            "        for dag in session.scalars(",
            "            select(DagModel).where(DagModel.last_parsed_time < expiration_date, DagModel.is_active)",
            "        ):",
            "            log.info(",
            "                \"Deactivating DAG ID %s since it was last touched by the scheduler at %s\",",
            "                dag.dag_id,",
            "                dag.last_parsed_time.isoformat(),",
            "            )",
            "            dag.is_active = False",
            "            session.merge(dag)",
            "            session.commit()",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def get_num_task_instances(dag_id, run_id=None, task_ids=None, states=None, session=NEW_SESSION) -> int:",
            "        \"\"\"",
            "        Returns the number of task instances in the given DAG.",
            "",
            "        :param session: ORM session",
            "        :param dag_id: ID of the DAG to get the task concurrency of",
            "        :param run_id: ID of the DAG run to get the task concurrency of",
            "        :param task_ids: A list of valid task IDs for the given DAG",
            "        :param states: A list of states to filter by if supplied",
            "        :return: The number of running tasks",
            "        \"\"\"",
            "        qry = select(func.count(TaskInstance.task_id)).where(",
            "            TaskInstance.dag_id == dag_id,",
            "        )",
            "        if run_id:",
            "            qry = qry.where(",
            "                TaskInstance.run_id == run_id,",
            "            )",
            "        if task_ids:",
            "            qry = qry.where(",
            "                TaskInstance.task_id.in_(task_ids),",
            "            )",
            "",
            "        if states:",
            "            if None in states:",
            "                if all(x is None for x in states):",
            "                    qry = qry.where(TaskInstance.state.is_(None))",
            "                else:",
            "                    not_none_states = [state for state in states if state]",
            "                    qry = qry.where(",
            "                        or_(TaskInstance.state.in_(not_none_states), TaskInstance.state.is_(None))",
            "                    )",
            "            else:",
            "                qry = qry.where(TaskInstance.state.in_(states))",
            "        return session.scalar(qry)",
            "",
            "    @classmethod",
            "    def get_serialized_fields(cls):",
            "        \"\"\"Stringified DAGs and operators contain exactly these fields.\"\"\"",
            "        if not cls.__serialized_fields:",
            "            exclusion_list = {",
            "                \"parent_dag\",",
            "                \"schedule_dataset_references\",",
            "                \"task_outlet_dataset_references\",",
            "                \"_old_context_manager_dags\",",
            "                \"safe_dag_id\",",
            "                \"last_loaded\",",
            "                \"user_defined_filters\",",
            "                \"user_defined_macros\",",
            "                \"partial\",",
            "                \"params\",",
            "                \"_pickle_id\",",
            "                \"_log\",",
            "                \"task_dict\",",
            "                \"template_searchpath\",",
            "                \"sla_miss_callback\",",
            "                \"on_success_callback\",",
            "                \"on_failure_callback\",",
            "                \"template_undefined\",",
            "                \"jinja_environment_kwargs\",",
            "                # has_on_*_callback are only stored if the value is True, as the default is False",
            "                \"has_on_success_callback\",",
            "                \"has_on_failure_callback\",",
            "                \"auto_register\",",
            "                \"fail_stop\",",
            "            }",
            "            cls.__serialized_fields = frozenset(vars(DAG(dag_id=\"test\")).keys()) - exclusion_list",
            "        return cls.__serialized_fields",
            "",
            "    def get_edge_info(self, upstream_task_id: str, downstream_task_id: str) -> EdgeInfoType:",
            "        \"\"\"",
            "        Returns edge information for the given pair of tasks if present, and",
            "        an empty edge if there is no information.",
            "        \"\"\"",
            "        # Note - older serialized DAGs may not have edge_info being a dict at all",
            "        empty = cast(EdgeInfoType, {})",
            "        if self.edge_info:",
            "            return self.edge_info.get(upstream_task_id, {}).get(downstream_task_id, empty)",
            "        else:",
            "            return empty",
            "",
            "    def set_edge_info(self, upstream_task_id: str, downstream_task_id: str, info: EdgeInfoType):",
            "        \"\"\"",
            "        Sets the given edge information on the DAG. Note that this will overwrite,",
            "        rather than merge with, existing info.",
            "        \"\"\"",
            "        self.edge_info.setdefault(upstream_task_id, {})[downstream_task_id] = info",
            "",
            "    def validate_schedule_and_params(self):",
            "        \"\"\"",
            "        Validates & raise exception if there are any Params in the DAG which neither have a default value nor",
            "        have the null in schema['type'] list, but the DAG have a schedule_interval which is not None.",
            "        \"\"\"",
            "        if not self.timetable.can_be_scheduled:",
            "            return",
            "",
            "        for k, v in self.params.items():",
            "            # As type can be an array, we would check if `null` is an allowed type or not",
            "            if not v.has_value and (\"type\" not in v.schema or \"null\" not in v.schema[\"type\"]):",
            "                raise AirflowException(",
            "                    \"DAG Schedule must be None, if there are any required params without default values\"",
            "                )",
            "",
            "    def iter_invalid_owner_links(self) -> Iterator[tuple[str, str]]:",
            "        \"\"\"Parses a given link, and verifies if it's a valid URL, or a 'mailto' link.",
            "        Returns an iterator of invalid (owner, link) pairs.",
            "        \"\"\"",
            "        for owner, link in self.owner_links.items():",
            "            result = urlsplit(link)",
            "            if result.scheme == \"mailto\":",
            "                # netloc is not existing for 'mailto' link, so we are checking that the path is parsed",
            "                if not result.path:",
            "                    yield result.path, link",
            "            elif not result.scheme or not result.netloc:",
            "                yield owner, link",
            "",
            "",
            "class DagTag(Base):",
            "    \"\"\"A tag name per dag, to allow quick filtering in the DAG view.\"\"\"",
            "",
            "    __tablename__ = \"dag_tag\"",
            "    name = Column(String(TAG_MAX_LEN), primary_key=True)",
            "    dag_id = Column(",
            "        StringID(),",
            "        ForeignKey(\"dag.dag_id\", name=\"dag_tag_dag_id_fkey\", ondelete=\"CASCADE\"),",
            "        primary_key=True,",
            "    )",
            "",
            "    def __repr__(self):",
            "        return self.name",
            "",
            "",
            "class DagOwnerAttributes(Base):",
            "    \"\"\"Table defining different owner attributes.",
            "",
            "    For example, a link for an owner that will be passed as a hyperlink to the",
            "    \"DAGs\" view.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_owner_attributes\"",
            "    dag_id = Column(",
            "        StringID(),",
            "        ForeignKey(\"dag.dag_id\", name=\"dag.dag_id\", ondelete=\"CASCADE\"),",
            "        nullable=False,",
            "        primary_key=True,",
            "    )",
            "    owner = Column(String(500), primary_key=True, nullable=False)",
            "    link = Column(String(500), nullable=False)",
            "",
            "    def __repr__(self):",
            "        return f\"<DagOwnerAttributes: dag_id={self.dag_id}, owner={self.owner}, link={self.link}>\"",
            "",
            "    @classmethod",
            "    def get_all(cls, session) -> dict[str, dict[str, str]]:",
            "        dag_links: dict = collections.defaultdict(dict)",
            "        for obj in session.scalars(select(cls)):",
            "            dag_links[obj.dag_id].update({obj.owner: obj.link})",
            "        return dag_links",
            "",
            "",
            "class DagModel(Base):",
            "    \"\"\"Table containing DAG properties.\"\"\"",
            "",
            "    __tablename__ = \"dag\"",
            "    \"\"\"",
            "    These items are stored in the database for state related information",
            "    \"\"\"",
            "    dag_id = Column(StringID(), primary_key=True)",
            "    root_dag_id = Column(StringID())",
            "    # A DAG can be paused from the UI / DB",
            "    # Set this default value of is_paused based on a configuration value!",
            "    is_paused_at_creation = conf.getboolean(\"core\", \"dags_are_paused_at_creation\")",
            "    is_paused = Column(Boolean, default=is_paused_at_creation)",
            "    # Whether the DAG is a subdag",
            "    is_subdag = Column(Boolean, default=False)",
            "    # Whether that DAG was seen on the last DagBag load",
            "    is_active = Column(Boolean, default=False)",
            "    # Last time the scheduler started",
            "    last_parsed_time = Column(UtcDateTime)",
            "    # Last time this DAG was pickled",
            "    last_pickled = Column(UtcDateTime)",
            "    # Time when the DAG last received a refresh signal",
            "    # (e.g. the DAG's \"refresh\" button was clicked in the web UI)",
            "    last_expired = Column(UtcDateTime)",
            "    # Whether (one  of) the scheduler is scheduling this DAG at the moment",
            "    scheduler_lock = Column(Boolean)",
            "    # Foreign key to the latest pickle_id",
            "    pickle_id = Column(Integer)",
            "    # The location of the file containing the DAG object",
            "    # Note: Do not depend on fileloc pointing to a file; in the case of a",
            "    # packaged DAG, it will point to the subpath of the DAG within the",
            "    # associated zip.",
            "    fileloc = Column(String(2000))",
            "    # The base directory used by Dag Processor that parsed this dag.",
            "    processor_subdir = Column(String(2000), nullable=True)",
            "    # String representing the owners",
            "    owners = Column(String(2000))",
            "    # Description of the dag",
            "    description = Column(Text)",
            "    # Default view of the DAG inside the webserver",
            "    default_view = Column(String(25))",
            "    # Schedule interval",
            "    schedule_interval = Column(Interval)",
            "    # Timetable/Schedule Interval description",
            "    timetable_description = Column(String(1000), nullable=True)",
            "    # Tags for view filter",
            "    tags = relationship(\"DagTag\", cascade=\"all, delete, delete-orphan\", backref=backref(\"dag\"))",
            "    # Dag owner links for DAGs view",
            "    dag_owner_links = relationship(",
            "        \"DagOwnerAttributes\", cascade=\"all, delete, delete-orphan\", backref=backref(\"dag\")",
            "    )",
            "",
            "    max_active_tasks = Column(Integer, nullable=False)",
            "    max_active_runs = Column(Integer, nullable=True)",
            "",
            "    has_task_concurrency_limits = Column(Boolean, nullable=False)",
            "    has_import_errors = Column(Boolean(), default=False, server_default=\"0\")",
            "",
            "    # The logical date of the next dag run.",
            "    next_dagrun = Column(UtcDateTime)",
            "",
            "    # Must be either both NULL or both datetime.",
            "    next_dagrun_data_interval_start = Column(UtcDateTime)",
            "    next_dagrun_data_interval_end = Column(UtcDateTime)",
            "",
            "    # Earliest time at which this ``next_dagrun`` can be created.",
            "    next_dagrun_create_after = Column(UtcDateTime)",
            "",
            "    __table_args__ = (",
            "        Index(\"idx_root_dag_id\", root_dag_id, unique=False),",
            "        Index(\"idx_next_dagrun_create_after\", next_dagrun_create_after, unique=False),",
            "    )",
            "",
            "    parent_dag = relationship(",
            "        \"DagModel\", remote_side=[dag_id], primaryjoin=root_dag_id == dag_id, foreign_keys=[root_dag_id]",
            "    )",
            "    schedule_dataset_references = relationship(",
            "        \"DagScheduleDatasetReference\",",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    schedule_datasets = association_proxy(\"schedule_dataset_references\", \"dataset\")",
            "    task_outlet_dataset_references = relationship(",
            "        \"TaskOutletDatasetReference\",",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    NUM_DAGS_PER_DAGRUN_QUERY = conf.getint(\"scheduler\", \"max_dagruns_to_create_per_loop\", fallback=10)",
            "",
            "    def __init__(self, concurrency=None, **kwargs):",
            "        super().__init__(**kwargs)",
            "        if self.max_active_tasks is None:",
            "            if concurrency:",
            "                warnings.warn(",
            "                    \"The 'DagModel.concurrency' parameter is deprecated. Please use 'max_active_tasks'.\",",
            "                    RemovedInAirflow3Warning,",
            "                    stacklevel=2,",
            "                )",
            "                self.max_active_tasks = concurrency",
            "            else:",
            "                self.max_active_tasks = conf.getint(\"core\", \"max_active_tasks_per_dag\")",
            "",
            "        if self.max_active_runs is None:",
            "            self.max_active_runs = conf.getint(\"core\", \"max_active_runs_per_dag\")",
            "",
            "        if self.has_task_concurrency_limits is None:",
            "            # Be safe -- this will be updated later once the DAG is parsed",
            "            self.has_task_concurrency_limits = True",
            "",
            "    def __repr__(self):",
            "        return f\"<DAG: {self.dag_id}>\"",
            "",
            "    @property",
            "    def next_dagrun_data_interval(self) -> DataInterval | None:",
            "        return _get_model_data_interval(",
            "            self,",
            "            \"next_dagrun_data_interval_start\",",
            "            \"next_dagrun_data_interval_end\",",
            "        )",
            "",
            "    @next_dagrun_data_interval.setter",
            "    def next_dagrun_data_interval(self, value: tuple[datetime, datetime] | None) -> None:",
            "        if value is None:",
            "            self.next_dagrun_data_interval_start = self.next_dagrun_data_interval_end = None",
            "        else:",
            "            self.next_dagrun_data_interval_start, self.next_dagrun_data_interval_end = value",
            "",
            "    @property",
            "    def timezone(self):",
            "        return settings.TIMEZONE",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def get_dagmodel(dag_id: str, session: Session = NEW_SESSION) -> DagModel | None:",
            "        return session.get(",
            "            DagModel,",
            "            dag_id,",
            "            options=[joinedload(DagModel.parent_dag)],",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def get_current(cls, dag_id, session=NEW_SESSION):",
            "        return session.scalar(select(cls).where(cls.dag_id == dag_id))",
            "",
            "    @provide_session",
            "    def get_last_dagrun(self, session=NEW_SESSION, include_externally_triggered=False):",
            "        return get_last_dagrun(",
            "            self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "        )",
            "",
            "    def get_is_paused(self, *, session: Session | None = None) -> bool:",
            "        \"\"\"Provide interface compatibility to 'DAG'.\"\"\"",
            "        return self.is_paused",
            "",
            "    @staticmethod",
            "    @internal_api_call",
            "    @provide_session",
            "    def get_paused_dag_ids(dag_ids: list[str], session: Session = NEW_SESSION) -> set[str]:",
            "        \"\"\"",
            "        Given a list of dag_ids, get a set of Paused Dag Ids.",
            "",
            "        :param dag_ids: List of Dag ids",
            "        :param session: ORM Session",
            "        :return: Paused Dag_ids",
            "        \"\"\"",
            "        paused_dag_ids = session.execute(",
            "            select(DagModel.dag_id)",
            "            .where(DagModel.is_paused == expression.true())",
            "            .where(DagModel.dag_id.in_(dag_ids))",
            "        )",
            "",
            "        paused_dag_ids = {paused_dag_id for paused_dag_id, in paused_dag_ids}",
            "        return paused_dag_ids",
            "",
            "    def get_default_view(self) -> str:",
            "        \"\"\"",
            "        Get the Default DAG View, returns the default config value if DagModel does not",
            "        have a value.",
            "        \"\"\"",
            "        # This is for backwards-compatibility with old dags that don't have None as default_view",
            "        return self.default_view or conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower()",
            "",
            "    @property",
            "    def safe_dag_id(self):",
            "        return self.dag_id.replace(\".\", \"__dot__\")",
            "",
            "    @property",
            "    def relative_fileloc(self) -> pathlib.Path | None:",
            "        \"\"\"File location of the importable dag 'file' relative to the configured DAGs folder.\"\"\"",
            "        if self.fileloc is None:",
            "            return None",
            "        path = pathlib.Path(self.fileloc)",
            "        try:",
            "            return path.relative_to(settings.DAGS_FOLDER)",
            "        except ValueError:",
            "            # Not relative to DAGS_FOLDER.",
            "            return path",
            "",
            "    @provide_session",
            "    def set_is_paused(self, is_paused: bool, including_subdags: bool = True, session=NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Pause/Un-pause a DAG.",
            "",
            "        :param is_paused: Is the DAG paused",
            "        :param including_subdags: whether to include the DAG's subdags",
            "        :param session: session",
            "        \"\"\"",
            "        filter_query = [",
            "            DagModel.dag_id == self.dag_id,",
            "        ]",
            "        if including_subdags:",
            "            filter_query.append(DagModel.root_dag_id == self.dag_id)",
            "        session.execute(",
            "            update(DagModel)",
            "            .where(or_(*filter_query))",
            "            .values(is_paused=is_paused)",
            "            .execution_options(synchronize_session=\"fetch\")",
            "        )",
            "        session.commit()",
            "",
            "    @classmethod",
            "    @internal_api_call",
            "    @provide_session",
            "    def deactivate_deleted_dags(",
            "        cls,",
            "        alive_dag_filelocs: Container[str],",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"",
            "        Set ``is_active=False`` on the DAGs for which the DAG files have been removed.",
            "",
            "        :param alive_dag_filelocs: file paths of alive DAGs",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        log.debug(\"Deactivating DAGs (for which DAG files are deleted) from %s table \", cls.__tablename__)",
            "        dag_models = session.scalars(select(cls).where(cls.fileloc.is_not(None)))",
            "        for dag_model in dag_models:",
            "            if dag_model.fileloc not in alive_dag_filelocs:",
            "                dag_model.is_active = False",
            "",
            "    @classmethod",
            "    def dags_needing_dagruns(cls, session: Session) -> tuple[Query, dict[str, tuple[datetime, datetime]]]:",
            "        \"\"\"",
            "        Return (and lock) a list of Dag objects that are due to create a new DagRun.",
            "",
            "        This will return a resultset of rows that is row-level-locked with a \"SELECT ... FOR UPDATE\" query,",
            "        you should ensure that any scheduling decisions are made in a single transaction -- as soon as the",
            "        transaction is committed it will be unlocked.",
            "        \"\"\"",
            "        from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue as DDRQ",
            "",
            "        # these dag ids are triggered by datasets, and they are ready to go.",
            "        dataset_triggered_dag_info = {",
            "            x.dag_id: (x.first_queued_time, x.last_queued_time)",
            "            for x in session.execute(",
            "                select(",
            "                    DagScheduleDatasetReference.dag_id,",
            "                    func.max(DDRQ.created_at).label(\"last_queued_time\"),",
            "                    func.min(DDRQ.created_at).label(\"first_queued_time\"),",
            "                )",
            "                .join(DagScheduleDatasetReference.queue_records, isouter=True)",
            "                .group_by(DagScheduleDatasetReference.dag_id)",
            "                .having(func.count() == func.sum(case((DDRQ.target_dag_id.is_not(None), 1), else_=0)))",
            "            )",
            "        }",
            "        dataset_triggered_dag_ids = set(dataset_triggered_dag_info.keys())",
            "        if dataset_triggered_dag_ids:",
            "            exclusion_list = {",
            "                x",
            "                for x in (",
            "                    session.scalars(",
            "                        select(DagModel.dag_id)",
            "                        .join(DagRun.dag_model)",
            "                        .where(DagRun.state.in_((DagRunState.QUEUED, DagRunState.RUNNING)))",
            "                        .where(DagModel.dag_id.in_(dataset_triggered_dag_ids))",
            "                        .group_by(DagModel.dag_id)",
            "                        .having(func.count() >= func.max(DagModel.max_active_runs))",
            "                    )",
            "                )",
            "            }",
            "            if exclusion_list:",
            "                dataset_triggered_dag_ids -= exclusion_list",
            "                dataset_triggered_dag_info = {",
            "                    k: v for k, v in dataset_triggered_dag_info.items() if k not in exclusion_list",
            "                }",
            "",
            "        # We limit so that _one_ scheduler doesn't try to do all the creation of dag runs",
            "        query = (",
            "            select(cls)",
            "            .where(",
            "                cls.is_paused == expression.false(),",
            "                cls.is_active == expression.true(),",
            "                cls.has_import_errors == expression.false(),",
            "                or_(",
            "                    cls.next_dagrun_create_after <= func.now(),",
            "                    cls.dag_id.in_(dataset_triggered_dag_ids),",
            "                ),",
            "            )",
            "            .order_by(cls.next_dagrun_create_after)",
            "            .limit(cls.NUM_DAGS_PER_DAGRUN_QUERY)",
            "        )",
            "",
            "        return (",
            "            session.scalars(with_row_locks(query, of=cls, session=session, **skip_locked(session=session))),",
            "            dataset_triggered_dag_info,",
            "        )",
            "",
            "    def calculate_dagrun_date_fields(",
            "        self,",
            "        dag: DAG,",
            "        most_recent_dag_run: None | datetime | DataInterval,",
            "    ) -> None:",
            "        \"\"\"",
            "        Calculate ``next_dagrun`` and `next_dagrun_create_after``.",
            "",
            "        :param dag: The DAG object",
            "        :param most_recent_dag_run: DataInterval (or datetime) of most recent run of this dag, or none",
            "            if not yet scheduled.",
            "        \"\"\"",
            "        most_recent_data_interval: DataInterval | None",
            "        if isinstance(most_recent_dag_run, datetime):",
            "            warnings.warn(",
            "                \"Passing a datetime to `DagModel.calculate_dagrun_date_fields` is deprecated. \"",
            "                \"Provide a data interval instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            most_recent_data_interval = dag.infer_automated_data_interval(most_recent_dag_run)",
            "        else:",
            "            most_recent_data_interval = most_recent_dag_run",
            "        next_dagrun_info = dag.next_dagrun_info(most_recent_data_interval)",
            "        if next_dagrun_info is None:",
            "            self.next_dagrun_data_interval = self.next_dagrun = self.next_dagrun_create_after = None",
            "        else:",
            "            self.next_dagrun_data_interval = next_dagrun_info.data_interval",
            "            self.next_dagrun = next_dagrun_info.logical_date",
            "            self.next_dagrun_create_after = next_dagrun_info.run_after",
            "",
            "        log.info(",
            "            \"Setting next_dagrun for %s to %s, run_after=%s\",",
            "            dag.dag_id,",
            "            self.next_dagrun,",
            "            self.next_dagrun_create_after,",
            "        )",
            "",
            "    @provide_session",
            "    def get_dataset_triggered_next_run_info(self, *, session=NEW_SESSION) -> dict[str, int | str] | None:",
            "        if self.schedule_interval != \"Dataset\":",
            "            return None",
            "        return get_dataset_triggered_next_run_info([self.dag_id], session=session)[self.dag_id]",
            "",
            "",
            "# NOTE: Please keep the list of arguments in sync with DAG.__init__.",
            "# Only exception: dag_id here should have a default value, but not in DAG.",
            "def dag(",
            "    dag_id: str = \"\",",
            "    description: str | None = None,",
            "    schedule: ScheduleArg = NOTSET,",
            "    schedule_interval: ScheduleIntervalArg = NOTSET,",
            "    timetable: Timetable | None = None,",
            "    start_date: datetime | None = None,",
            "    end_date: datetime | None = None,",
            "    full_filepath: str | None = None,",
            "    template_searchpath: str | Iterable[str] | None = None,",
            "    template_undefined: type[jinja2.StrictUndefined] = jinja2.StrictUndefined,",
            "    user_defined_macros: dict | None = None,",
            "    user_defined_filters: dict | None = None,",
            "    default_args: dict | None = None,",
            "    concurrency: int | None = None,",
            "    max_active_tasks: int = conf.getint(\"core\", \"max_active_tasks_per_dag\"),",
            "    max_active_runs: int = conf.getint(\"core\", \"max_active_runs_per_dag\"),",
            "    dagrun_timeout: timedelta | None = None,",
            "    sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,",
            "    default_view: str = conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),",
            "    orientation: str = conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),",
            "    catchup: bool = conf.getboolean(\"scheduler\", \"catchup_by_default\"),",
            "    on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "    on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "    doc_md: str | None = None,",
            "    params: collections.abc.MutableMapping | None = None,",
            "    access_control: dict | None = None,",
            "    is_paused_upon_creation: bool | None = None,",
            "    jinja_environment_kwargs: dict | None = None,",
            "    render_template_as_native_obj: bool = False,",
            "    tags: list[str] | None = None,",
            "    owner_links: dict[str, str] | None = None,",
            "    auto_register: bool = True,",
            "    fail_stop: bool = False,",
            ") -> Callable[[Callable], Callable[..., DAG]]:",
            "    \"\"\"",
            "    Python dag decorator. Wraps a function into an Airflow DAG.",
            "    Accepts kwargs for operator kwarg. Can be used to parameterize DAGs.",
            "",
            "    :param dag_args: Arguments for DAG object",
            "    :param dag_kwargs: Kwargs for DAG object.",
            "    \"\"\"",
            "",
            "    def wrapper(f: Callable) -> Callable[..., DAG]:",
            "        @functools.wraps(f)",
            "        def factory(*args, **kwargs):",
            "            # Generate signature for decorated function and bind the arguments when called",
            "            # we do this to extract parameters, so we can annotate them on the DAG object.",
            "            # In addition, this fails if we are missing any args/kwargs with TypeError as expected.",
            "            f_sig = signature(f).bind(*args, **kwargs)",
            "            # Apply defaults to capture default values if set.",
            "            f_sig.apply_defaults()",
            "",
            "            # Initialize DAG with bound arguments",
            "            with DAG(",
            "                dag_id or f.__name__,",
            "                description=description,",
            "                schedule_interval=schedule_interval,",
            "                timetable=timetable,",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                full_filepath=full_filepath,",
            "                template_searchpath=template_searchpath,",
            "                template_undefined=template_undefined,",
            "                user_defined_macros=user_defined_macros,",
            "                user_defined_filters=user_defined_filters,",
            "                default_args=default_args,",
            "                concurrency=concurrency,",
            "                max_active_tasks=max_active_tasks,",
            "                max_active_runs=max_active_runs,",
            "                dagrun_timeout=dagrun_timeout,",
            "                sla_miss_callback=sla_miss_callback,",
            "                default_view=default_view,",
            "                orientation=orientation,",
            "                catchup=catchup,",
            "                on_success_callback=on_success_callback,",
            "                on_failure_callback=on_failure_callback,",
            "                doc_md=doc_md,",
            "                params=params,",
            "                access_control=access_control,",
            "                is_paused_upon_creation=is_paused_upon_creation,",
            "                jinja_environment_kwargs=jinja_environment_kwargs,",
            "                render_template_as_native_obj=render_template_as_native_obj,",
            "                tags=tags,",
            "                schedule=schedule,",
            "                owner_links=owner_links,",
            "                auto_register=auto_register,",
            "                fail_stop=fail_stop,",
            "            ) as dag_obj:",
            "                # Set DAG documentation from function documentation if it exists and doc_md is not set.",
            "                if f.__doc__ and not dag_obj.doc_md:",
            "                    dag_obj.doc_md = f.__doc__",
            "",
            "                # Generate DAGParam for each function arg/kwarg and replace it for calling the function.",
            "                # All args/kwargs for function will be DAGParam object and replaced on execution time.",
            "                f_kwargs = {}",
            "                for name, value in f_sig.arguments.items():",
            "                    f_kwargs[name] = dag_obj.param(name, value)",
            "",
            "                # set file location to caller source path",
            "                back = sys._getframe().f_back",
            "                dag_obj.fileloc = back.f_code.co_filename if back else \"\"",
            "",
            "                # Invoke function to create operators in the DAG scope.",
            "                f(**f_kwargs)",
            "",
            "            # Return dag object such that it's accessible in Globals.",
            "            return dag_obj",
            "",
            "        # Ensure that warnings from inside DAG() are emitted from the caller, not here",
            "        fixup_decorator_warning_stack(factory)",
            "        return factory",
            "",
            "    return wrapper",
            "",
            "",
            "STATICA_HACK = True",
            "globals()[\"kcah_acitats\"[::-1].upper()] = False",
            "if STATICA_HACK:  # pragma: no cover",
            "    from airflow.models.serialized_dag import SerializedDagModel",
            "",
            "    DagModel.serialized_dag = relationship(SerializedDagModel)",
            "    \"\"\":sphinx-autoapi-skip:\"\"\"",
            "",
            "",
            "class DagContext:",
            "    \"\"\"",
            "    DAG context is used to keep the current DAG when DAG is used as ContextManager.",
            "",
            "    You can use DAG as context:",
            "",
            "    .. code-block:: python",
            "",
            "        with DAG(",
            "            dag_id=\"example_dag\",",
            "            default_args=default_args,",
            "            schedule=\"0 0 * * *\",",
            "            dagrun_timeout=timedelta(minutes=60),",
            "        ) as dag:",
            "            ...",
            "",
            "    If you do this the context stores the DAG and whenever new task is created, it will use",
            "    such stored DAG as the parent DAG.",
            "",
            "    \"\"\"",
            "",
            "    _context_managed_dags: collections.deque[DAG] = deque()",
            "    autoregistered_dags: set[tuple[DAG, ModuleType]] = set()",
            "    current_autoregister_module_name: str | None = None",
            "",
            "    @classmethod",
            "    def push_context_managed_dag(cls, dag: DAG):",
            "        cls._context_managed_dags.appendleft(dag)",
            "",
            "    @classmethod",
            "    def pop_context_managed_dag(cls) -> DAG | None:",
            "        dag = cls._context_managed_dags.popleft()",
            "",
            "        # In a few cases around serialization we explicitly push None in to the stack",
            "        if cls.current_autoregister_module_name is not None and dag and dag.auto_register:",
            "            mod = sys.modules[cls.current_autoregister_module_name]",
            "            cls.autoregistered_dags.add((dag, mod))",
            "",
            "        return dag",
            "",
            "    @classmethod",
            "    def get_current_dag(cls) -> DAG | None:",
            "        try:",
            "            return cls._context_managed_dags[0]",
            "        except IndexError:",
            "            return None",
            "",
            "",
            "def _run_task(ti: TaskInstance, session):",
            "    \"\"\"",
            "    Run a single task instance, and push result to Xcom for downstream tasks. Bypasses a lot of",
            "    extra steps used in `task.run` to keep our local running as fast as possible",
            "    This function is only meant for the `dag.test` function as a helper function.",
            "",
            "    Args:",
            "        ti: TaskInstance to run",
            "    \"\"\"",
            "    log.info(\"*****************************************************\")",
            "    if ti.map_index > 0:",
            "        log.info(\"Running task %s index %d\", ti.task_id, ti.map_index)",
            "    else:",
            "        log.info(\"Running task %s\", ti.task_id)",
            "    try:",
            "        ti._run_raw_task(session=session)",
            "        session.flush()",
            "        log.info(\"%s ran successfully!\", ti.task_id)",
            "    except AirflowSkipException:",
            "        log.info(\"Task Skipped, continuing\")",
            "    log.info(\"*****************************************************\")",
            "",
            "",
            "def _get_or_create_dagrun(",
            "    dag: DAG,",
            "    conf: dict[Any, Any] | None,",
            "    start_date: datetime,",
            "    execution_date: datetime,",
            "    run_id: str,",
            "    session: Session,",
            ") -> DagRun:",
            "    \"\"\"Create a DAG run, replacing an existing instance if needed to prevent collisions.",
            "",
            "    This function is only meant to be used by :meth:`DAG.test` as a helper function.",
            "",
            "    :param dag: DAG to be used to find run.",
            "    :param conf: Configuration to pass to newly created run.",
            "    :param start_date: Start date of new run.",
            "    :param execution_date: Logical date for finding an existing run.",
            "    :param run_id: Run ID for the new DAG run.",
            "",
            "    :return: The newly created DAG run.",
            "    \"\"\"",
            "    log.info(\"dagrun id: %s\", dag.dag_id)",
            "    dr: DagRun = session.scalar(",
            "        select(DagRun).where(DagRun.dag_id == dag.dag_id, DagRun.execution_date == execution_date)",
            "    )",
            "    if dr:",
            "        session.delete(dr)",
            "        session.commit()",
            "    dr = dag.create_dagrun(",
            "        state=DagRunState.RUNNING,",
            "        execution_date=execution_date,",
            "        run_id=run_id,",
            "        start_date=start_date or execution_date,",
            "        session=session,",
            "        conf=conf,",
            "    )",
            "    log.info(\"created dagrun %s\", dr)",
            "    return dr"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import collections",
            "import collections.abc",
            "import copy",
            "import functools",
            "import itertools",
            "import logging",
            "import os",
            "import pathlib",
            "import pickle",
            "import sys",
            "import traceback",
            "import warnings",
            "import weakref",
            "from collections import deque",
            "from datetime import datetime, timedelta",
            "from inspect import signature",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Collection,",
            "    Container,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    Pattern,",
            "    Sequence,",
            "    Union,",
            "    cast,",
            "    overload,",
            ")",
            "from urllib.parse import urlsplit",
            "",
            "import jinja2",
            "import pendulum",
            "import re2 as re",
            "from dateutil.relativedelta import relativedelta",
            "from pendulum.tz.timezone import Timezone",
            "from sqlalchemy import (",
            "    Boolean,",
            "    Column,",
            "    ForeignKey,",
            "    Index,",
            "    Integer,",
            "    String,",
            "    Text,",
            "    and_,",
            "    case,",
            "    func,",
            "    not_,",
            "    or_,",
            "    select,",
            "    update,",
            ")",
            "from sqlalchemy.ext.associationproxy import association_proxy",
            "from sqlalchemy.orm import backref, joinedload, relationship",
            "from sqlalchemy.orm.query import Query",
            "from sqlalchemy.orm.session import Session",
            "from sqlalchemy.sql import Select, expression",
            "",
            "import airflow.templates",
            "from airflow import settings, utils",
            "from airflow.api_internal.internal_api_call import internal_api_call",
            "from airflow.configuration import conf as airflow_conf, secrets_backend_list",
            "from airflow.exceptions import (",
            "    AirflowDagInconsistent,",
            "    AirflowException,",
            "    AirflowSkipException,",
            "    DagInvalidTriggerRule,",
            "    DuplicateTaskIdFound,",
            "    RemovedInAirflow3Warning,",
            "    TaskNotFound,",
            ")",
            "from airflow.jobs.job import run_job",
            "from airflow.models.abstractoperator import AbstractOperator",
            "from airflow.models.base import Base, StringID",
            "from airflow.models.baseoperator import BaseOperator",
            "from airflow.models.dagcode import DagCode",
            "from airflow.models.dagpickle import DagPickle",
            "from airflow.models.dagrun import RUN_ID_REGEX, DagRun",
            "from airflow.models.operator import Operator",
            "from airflow.models.param import DagParam, ParamsDict",
            "from airflow.models.taskinstance import Context, TaskInstance, TaskInstanceKey, clear_task_instances",
            "from airflow.secrets.local_filesystem import LocalFilesystemBackend",
            "from airflow.security import permissions",
            "from airflow.stats import Stats",
            "from airflow.timetables.base import DagRunInfo, DataInterval, TimeRestriction, Timetable",
            "from airflow.timetables.interval import CronDataIntervalTimetable, DeltaDataIntervalTimetable",
            "from airflow.timetables.simple import (",
            "    ContinuousTimetable,",
            "    DatasetTriggeredTimetable,",
            "    NullTimetable,",
            "    OnceTimetable,",
            ")",
            "from airflow.typing_compat import Literal",
            "from airflow.utils import timezone",
            "from airflow.utils.dag_cycle_tester import check_cycle",
            "from airflow.utils.dates import cron_presets, date_range as utils_date_range",
            "from airflow.utils.decorators import fixup_decorator_warning_stack",
            "from airflow.utils.helpers import at_most_one, exactly_one, validate_key",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import (",
            "    Interval,",
            "    UtcDateTime,",
            "    lock_rows,",
            "    skip_locked,",
            "    tuple_in_condition,",
            "    with_row_locks,",
            ")",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.types import NOTSET, ArgNotSet, DagRunType, EdgeInfoType",
            "",
            "if TYPE_CHECKING:",
            "    from types import ModuleType",
            "",
            "    from airflow.datasets import Dataset",
            "    from airflow.decorators import TaskDecoratorCollection",
            "    from airflow.models.dagbag import DagBag",
            "    from airflow.models.slamiss import SlaMiss",
            "    from airflow.utils.task_group import TaskGroup",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "DEFAULT_VIEW_PRESETS = [\"grid\", \"graph\", \"duration\", \"gantt\", \"landing_times\"]",
            "ORIENTATION_PRESETS = [\"LR\", \"TB\", \"RL\", \"BT\"]",
            "",
            "TAG_MAX_LEN = 100",
            "",
            "DagStateChangeCallback = Callable[[Context], None]",
            "ScheduleInterval = Union[None, str, timedelta, relativedelta]",
            "",
            "# FIXME: Ideally this should be Union[Literal[NOTSET], ScheduleInterval],",
            "# but Mypy cannot handle that right now. Track progress of PEP 661 for progress.",
            "# See also: https://discuss.python.org/t/9126/7",
            "ScheduleIntervalArg = Union[ArgNotSet, ScheduleInterval]",
            "ScheduleArg = Union[ArgNotSet, ScheduleInterval, Timetable, Collection[\"Dataset\"]]",
            "",
            "SLAMissCallback = Callable[[\"DAG\", str, str, List[\"SlaMiss\"], List[TaskInstance]], None]",
            "",
            "# Backward compatibility: If neither schedule_interval nor timetable is",
            "# *provided by the user*, default to a one-day interval.",
            "DEFAULT_SCHEDULE_INTERVAL = timedelta(days=1)",
            "",
            "",
            "class InconsistentDataInterval(AirflowException):",
            "    \"\"\"Exception raised when a model populates data interval fields incorrectly.",
            "",
            "    The data interval fields should either both be None (for runs scheduled",
            "    prior to AIP-39), or both be datetime (for runs scheduled after AIP-39 is",
            "    implemented). This is raised if exactly one of the fields is None.",
            "    \"\"\"",
            "",
            "    _template = (",
            "        \"Inconsistent {cls}: {start[0]}={start[1]!r}, {end[0]}={end[1]!r}, \"",
            "        \"they must be either both None or both datetime\"",
            "    )",
            "",
            "    def __init__(self, instance: Any, start_field_name: str, end_field_name: str) -> None:",
            "        self._class_name = type(instance).__name__",
            "        self._start_field = (start_field_name, getattr(instance, start_field_name))",
            "        self._end_field = (end_field_name, getattr(instance, end_field_name))",
            "",
            "    def __str__(self) -> str:",
            "        return self._template.format(cls=self._class_name, start=self._start_field, end=self._end_field)",
            "",
            "",
            "def _get_model_data_interval(",
            "    instance: Any,",
            "    start_field_name: str,",
            "    end_field_name: str,",
            ") -> DataInterval | None:",
            "    start = timezone.coerce_datetime(getattr(instance, start_field_name))",
            "    end = timezone.coerce_datetime(getattr(instance, end_field_name))",
            "    if start is None:",
            "        if end is not None:",
            "            raise InconsistentDataInterval(instance, start_field_name, end_field_name)",
            "        return None",
            "    elif end is None:",
            "        raise InconsistentDataInterval(instance, start_field_name, end_field_name)",
            "    return DataInterval(start, end)",
            "",
            "",
            "def create_timetable(interval: ScheduleIntervalArg, timezone: Timezone) -> Timetable:",
            "    \"\"\"Create a Timetable instance from a ``schedule_interval`` argument.\"\"\"",
            "    if interval is NOTSET:",
            "        return DeltaDataIntervalTimetable(DEFAULT_SCHEDULE_INTERVAL)",
            "    if interval is None:",
            "        return NullTimetable()",
            "    if interval == \"@once\":",
            "        return OnceTimetable()",
            "    if interval == \"@continuous\":",
            "        return ContinuousTimetable()",
            "    if isinstance(interval, (timedelta, relativedelta)):",
            "        return DeltaDataIntervalTimetable(interval)",
            "    if isinstance(interval, str):",
            "        return CronDataIntervalTimetable(interval, timezone)",
            "    raise ValueError(f\"{interval!r} is not a valid schedule_interval.\")",
            "",
            "",
            "def get_last_dagrun(dag_id, session, include_externally_triggered=False):",
            "    \"\"\"",
            "    Returns the last dag run for a dag, None if there was none.",
            "    Last dag run can be any type of run e.g. scheduled or backfilled.",
            "    Overridden DagRuns are ignored.",
            "    \"\"\"",
            "    DR = DagRun",
            "    query = select(DR).where(DR.dag_id == dag_id)",
            "    if not include_externally_triggered:",
            "        query = query.where(DR.external_trigger == expression.false())",
            "    query = query.order_by(DR.execution_date.desc())",
            "    return session.scalar(query.limit(1))",
            "",
            "",
            "def get_dataset_triggered_next_run_info(",
            "    dag_ids: list[str], *, session: Session",
            ") -> dict[str, dict[str, int | str]]:",
            "    \"\"\"",
            "    Given a list of dag_ids, get string representing how close any that are dataset triggered are",
            "    their next run, e.g. \"1 of 2 datasets updated\".",
            "    \"\"\"",
            "    from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue as DDRQ, DatasetModel",
            "",
            "    return {",
            "        x.dag_id: {",
            "            \"uri\": x.uri,",
            "            \"ready\": x.ready,",
            "            \"total\": x.total,",
            "        }",
            "        for x in session.execute(",
            "            select(",
            "                DagScheduleDatasetReference.dag_id,",
            "                # This is a dirty hack to workaround group by requiring an aggregate,",
            "                # since grouping by dataset is not what we want to do here...but it works",
            "                case((func.count() == 1, func.max(DatasetModel.uri)), else_=\"\").label(\"uri\"),",
            "                func.count().label(\"total\"),",
            "                func.sum(case((DDRQ.target_dag_id.is_not(None), 1), else_=0)).label(\"ready\"),",
            "            )",
            "            .join(",
            "                DDRQ,",
            "                and_(",
            "                    DDRQ.dataset_id == DagScheduleDatasetReference.dataset_id,",
            "                    DDRQ.target_dag_id == DagScheduleDatasetReference.dag_id,",
            "                ),",
            "                isouter=True,",
            "            )",
            "            .join(DatasetModel, DatasetModel.id == DagScheduleDatasetReference.dataset_id)",
            "            .group_by(DagScheduleDatasetReference.dag_id)",
            "            .where(DagScheduleDatasetReference.dag_id.in_(dag_ids))",
            "        ).all()",
            "    }",
            "",
            "",
            "@functools.total_ordering",
            "class DAG(LoggingMixin):",
            "    \"\"\"",
            "    A dag (directed acyclic graph) is a collection of tasks with directional",
            "    dependencies. A dag also has a schedule, a start date and an end date",
            "    (optional). For each schedule, (say daily or hourly), the DAG needs to run",
            "    each individual tasks as their dependencies are met. Certain tasks have",
            "    the property of depending on their own past, meaning that they can't run",
            "    until their previous schedule (and upstream tasks) are completed.",
            "",
            "    DAGs essentially act as namespaces for tasks. A task_id can only be",
            "    added once to a DAG.",
            "",
            "    Note that if you plan to use time zones all the dates provided should be pendulum",
            "    dates. See :ref:`timezone_aware_dags`.",
            "",
            "    .. versionadded:: 2.4",
            "        The *schedule* argument to specify either time-based scheduling logic",
            "        (timetable), or dataset-driven triggers.",
            "",
            "    .. deprecated:: 2.4",
            "        The arguments *schedule_interval* and *timetable*. Their functionalities",
            "        are merged into the new *schedule* argument.",
            "",
            "    :param dag_id: The id of the DAG; must consist exclusively of alphanumeric",
            "        characters, dashes, dots and underscores (all ASCII)",
            "    :param description: The description for the DAG to e.g. be shown on the webserver",
            "    :param schedule: Defines the rules according to which DAG runs are scheduled. Can",
            "        accept cron string, timedelta object, Timetable, or list of Dataset objects.",
            "        See also :doc:`/howto/timetable`.",
            "    :param start_date: The timestamp from which the scheduler will",
            "        attempt to backfill",
            "    :param end_date: A date beyond which your DAG won't run, leave to None",
            "        for open-ended scheduling",
            "    :param template_searchpath: This list of folders (non-relative)",
            "        defines where jinja will look for your templates. Order matters.",
            "        Note that jinja/airflow includes the path of your DAG file by",
            "        default",
            "    :param template_undefined: Template undefined type.",
            "    :param user_defined_macros: a dictionary of macros that will be exposed",
            "        in your jinja templates. For example, passing ``dict(foo='bar')``",
            "        to this argument allows you to ``{{ foo }}`` in all jinja",
            "        templates related to this DAG. Note that you can pass any",
            "        type of object here.",
            "    :param user_defined_filters: a dictionary of filters that will be exposed",
            "        in your jinja templates. For example, passing",
            "        ``dict(hello=lambda name: 'Hello %s' % name)`` to this argument allows",
            "        you to ``{{ 'world' | hello }}`` in all jinja templates related to",
            "        this DAG.",
            "    :param default_args: A dictionary of default parameters to be used",
            "        as constructor keyword parameters when initialising operators.",
            "        Note that operators have the same hook, and precede those defined",
            "        here, meaning that if your dict contains `'depends_on_past': True`",
            "        here and `'depends_on_past': False` in the operator's call",
            "        `default_args`, the actual value will be `False`.",
            "    :param params: a dictionary of DAG level parameters that are made",
            "        accessible in templates, namespaced under `params`. These",
            "        params can be overridden at the task level.",
            "    :param max_active_tasks: the number of task instances allowed to run",
            "        concurrently",
            "    :param max_active_runs: maximum number of active DAG runs, beyond this",
            "        number of DAG runs in a running state, the scheduler won't create",
            "        new active DAG runs",
            "    :param dagrun_timeout: specify how long a DagRun should be up before",
            "        timing out / failing, so that new DagRuns can be created.",
            "    :param sla_miss_callback: specify a function or list of functions to call when reporting SLA",
            "        timeouts. See :ref:`sla_miss_callback<concepts:sla_miss_callback>` for",
            "        more information about the function signature and parameters that are",
            "        passed to the callback.",
            "    :param default_view: Specify DAG default view (grid, graph, duration,",
            "                                                   gantt, landing_times), default grid",
            "    :param orientation: Specify DAG orientation in graph view (LR, TB, RL, BT), default LR",
            "    :param catchup: Perform scheduler catchup (or only run latest)? Defaults to True",
            "    :param on_failure_callback: A function or list of functions to be called when a DagRun of this dag fails.",
            "        A context dictionary is passed as a single parameter to this function.",
            "    :param on_success_callback: Much like the ``on_failure_callback`` except",
            "        that it is executed when the dag succeeds.",
            "    :param access_control: Specify optional DAG-level actions, e.g.,",
            "        \"{'role1': {'can_read'}, 'role2': {'can_read', 'can_edit', 'can_delete'}}\"",
            "    :param is_paused_upon_creation: Specifies if the dag is paused when created for the first time.",
            "        If the dag exists already, this flag will be ignored. If this optional parameter",
            "        is not specified, the global config setting will be used.",
            "    :param jinja_environment_kwargs: additional configuration options to be passed to Jinja",
            "        ``Environment`` for template rendering",
            "",
            "        **Example**: to avoid Jinja from removing a trailing newline from template strings ::",
            "",
            "            DAG(dag_id='my-dag',",
            "                jinja_environment_kwargs={",
            "                    'keep_trailing_newline': True,",
            "                    # some other jinja2 Environment options here",
            "                }",
            "            )",
            "",
            "        **See**: `Jinja Environment documentation",
            "        <https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Environment>`_",
            "",
            "    :param render_template_as_native_obj: If True, uses a Jinja ``NativeEnvironment``",
            "        to render templates as native Python types. If False, a Jinja",
            "        ``Environment`` is used to render templates as string values.",
            "    :param tags: List of tags to help filtering DAGs in the UI.",
            "    :param owner_links: Dict of owners and their links, that will be clickable on the DAGs view UI.",
            "        Can be used as an HTTP link (for example the link to your Slack channel), or a mailto link.",
            "        e.g: {\"dag_owner\": \"https://airflow.apache.org/\"}",
            "    :param auto_register: Automatically register this DAG when it is used in a ``with`` block",
            "    :param fail_stop: Fails currently running tasks when task in DAG fails.",
            "        **Warning**: A fail stop dag can only have tasks with the default trigger rule (\"all_success\").",
            "        An exception will be thrown if any task in a fail stop dag has a non default trigger rule.",
            "    \"\"\"",
            "",
            "    _comps = {",
            "        \"dag_id\",",
            "        \"task_ids\",",
            "        \"parent_dag\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"schedule_interval\",",
            "        \"fileloc\",",
            "        \"template_searchpath\",",
            "        \"last_loaded\",",
            "    }",
            "",
            "    __serialized_fields: frozenset[str] | None = None",
            "",
            "    fileloc: str",
            "    \"\"\"",
            "    File path that needs to be imported to load this DAG or subdag.",
            "",
            "    This may not be an actual file on disk in the case when this DAG is loaded",
            "    from a ZIP file or other DAG distribution format.",
            "    \"\"\"",
            "",
            "    parent_dag: DAG | None = None  # Gets set when DAGs are loaded",
            "",
            "    # NOTE: When updating arguments here, please also keep arguments in @dag()",
            "    # below in sync. (Search for 'def dag(' in this file.)",
            "    def __init__(",
            "        self,",
            "        dag_id: str,",
            "        description: str | None = None,",
            "        schedule: ScheduleArg = NOTSET,",
            "        schedule_interval: ScheduleIntervalArg = NOTSET,",
            "        timetable: Timetable | None = None,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        full_filepath: str | None = None,",
            "        template_searchpath: str | Iterable[str] | None = None,",
            "        template_undefined: type[jinja2.StrictUndefined] = jinja2.StrictUndefined,",
            "        user_defined_macros: dict | None = None,",
            "        user_defined_filters: dict | None = None,",
            "        default_args: dict | None = None,",
            "        concurrency: int | None = None,",
            "        max_active_tasks: int = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\"),",
            "        max_active_runs: int = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\"),",
            "        dagrun_timeout: timedelta | None = None,",
            "        sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,",
            "        default_view: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),",
            "        orientation: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),",
            "        catchup: bool = airflow_conf.getboolean(\"scheduler\", \"catchup_by_default\"),",
            "        on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "        on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "        doc_md: str | None = None,",
            "        params: collections.abc.MutableMapping | None = None,",
            "        access_control: dict | None = None,",
            "        is_paused_upon_creation: bool | None = None,",
            "        jinja_environment_kwargs: dict | None = None,",
            "        render_template_as_native_obj: bool = False,",
            "        tags: list[str] | None = None,",
            "        owner_links: dict[str, str] | None = None,",
            "        auto_register: bool = True,",
            "        fail_stop: bool = False,",
            "    ):",
            "        from airflow.utils.task_group import TaskGroup",
            "",
            "        if tags and any(len(tag) > TAG_MAX_LEN for tag in tags):",
            "            raise AirflowException(f\"tag cannot be longer than {TAG_MAX_LEN} characters\")",
            "",
            "        self.owner_links = owner_links if owner_links else {}",
            "        self.user_defined_macros = user_defined_macros",
            "        self.user_defined_filters = user_defined_filters",
            "        if default_args and not isinstance(default_args, dict):",
            "            raise TypeError(\"default_args must be a dict\")",
            "        self.default_args = copy.deepcopy(default_args or {})",
            "        params = params or {}",
            "",
            "        # merging potentially conflicting default_args['params'] into params",
            "        if \"params\" in self.default_args:",
            "            params.update(self.default_args[\"params\"])",
            "            del self.default_args[\"params\"]",
            "",
            "        # check self.params and convert them into ParamsDict",
            "        self.params = ParamsDict(params)",
            "",
            "        if full_filepath:",
            "            warnings.warn(",
            "                \"Passing full_filepath to DAG() is deprecated and has no effect\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        validate_key(dag_id)",
            "",
            "        self._dag_id = dag_id",
            "        if concurrency:",
            "            # TODO: Remove in Airflow 3.0",
            "            warnings.warn(",
            "                \"The 'concurrency' parameter is deprecated. Please use 'max_active_tasks'.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            max_active_tasks = concurrency",
            "        self._max_active_tasks = max_active_tasks",
            "        self._pickle_id: int | None = None",
            "",
            "        self._description = description",
            "        # set file location to caller source path",
            "        back = sys._getframe().f_back",
            "        self.fileloc = back.f_code.co_filename if back else \"\"",
            "        self.task_dict: dict[str, Operator] = {}",
            "",
            "        # set timezone from start_date",
            "        tz = None",
            "        if start_date and start_date.tzinfo:",
            "            tzinfo = None if start_date.tzinfo else settings.TIMEZONE",
            "            tz = pendulum.instance(start_date, tz=tzinfo).timezone",
            "        elif \"start_date\" in self.default_args and self.default_args[\"start_date\"]:",
            "            date = self.default_args[\"start_date\"]",
            "            if not isinstance(date, datetime):",
            "                date = timezone.parse(date)",
            "                self.default_args[\"start_date\"] = date",
            "                start_date = date",
            "",
            "            tzinfo = None if date.tzinfo else settings.TIMEZONE",
            "            tz = pendulum.instance(date, tz=tzinfo).timezone",
            "        self.timezone = tz or settings.TIMEZONE",
            "",
            "        # Apply the timezone we settled on to end_date if it wasn't supplied",
            "        if \"end_date\" in self.default_args and self.default_args[\"end_date\"]:",
            "            if isinstance(self.default_args[\"end_date\"], str):",
            "                self.default_args[\"end_date\"] = timezone.parse(",
            "                    self.default_args[\"end_date\"], timezone=self.timezone",
            "                )",
            "",
            "        self.start_date = timezone.convert_to_utc(start_date)",
            "        self.end_date = timezone.convert_to_utc(end_date)",
            "",
            "        # also convert tasks",
            "        if \"start_date\" in self.default_args:",
            "            self.default_args[\"start_date\"] = timezone.convert_to_utc(self.default_args[\"start_date\"])",
            "        if \"end_date\" in self.default_args:",
            "            self.default_args[\"end_date\"] = timezone.convert_to_utc(self.default_args[\"end_date\"])",
            "",
            "        # sort out DAG's scheduling behavior",
            "        scheduling_args = [schedule_interval, timetable, schedule]",
            "        if not at_most_one(*scheduling_args):",
            "            raise ValueError(\"At most one allowed for args 'schedule_interval', 'timetable', and 'schedule'.\")",
            "        if schedule_interval is not NOTSET:",
            "            warnings.warn(",
            "                \"Param `schedule_interval` is deprecated and will be removed in a future release. \"",
            "                \"Please use `schedule` instead. \",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "        if timetable is not None:",
            "            warnings.warn(",
            "                \"Param `timetable` is deprecated and will be removed in a future release. \"",
            "                \"Please use `schedule` instead. \",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        self.timetable: Timetable",
            "        self.schedule_interval: ScheduleInterval",
            "        self.dataset_triggers: Collection[Dataset] = []",
            "",
            "        if isinstance(schedule, Collection) and not isinstance(schedule, str):",
            "            from airflow.datasets import Dataset",
            "",
            "            if not all(isinstance(x, Dataset) for x in schedule):",
            "                raise ValueError(\"All elements in 'schedule' should be datasets\")",
            "            self.dataset_triggers = list(schedule)",
            "        elif isinstance(schedule, Timetable):",
            "            timetable = schedule",
            "        elif schedule is not NOTSET:",
            "            schedule_interval = schedule",
            "",
            "        if self.dataset_triggers:",
            "            self.timetable = DatasetTriggeredTimetable()",
            "            self.schedule_interval = self.timetable.summary",
            "        elif timetable:",
            "            self.timetable = timetable",
            "            self.schedule_interval = self.timetable.summary",
            "        else:",
            "            if isinstance(schedule_interval, ArgNotSet):",
            "                schedule_interval = DEFAULT_SCHEDULE_INTERVAL",
            "            self.schedule_interval = schedule_interval",
            "            self.timetable = create_timetable(schedule_interval, self.timezone)",
            "",
            "        if isinstance(template_searchpath, str):",
            "            template_searchpath = [template_searchpath]",
            "        self.template_searchpath = template_searchpath",
            "        self.template_undefined = template_undefined",
            "        self.last_loaded = timezone.utcnow()",
            "        self.safe_dag_id = dag_id.replace(\".\", \"__dot__\")",
            "        self.max_active_runs = max_active_runs",
            "        if self.timetable.active_runs_limit is not None:",
            "            if self.timetable.active_runs_limit < self.max_active_runs:",
            "                raise AirflowException(",
            "                    f\"Invalid max_active_runs: {type(self.timetable)} \"",
            "                    f\"requires max_active_runs <= {self.timetable.active_runs_limit}\"",
            "                )",
            "        self.dagrun_timeout = dagrun_timeout",
            "        self.sla_miss_callback = sla_miss_callback",
            "        if default_view in DEFAULT_VIEW_PRESETS:",
            "            self._default_view: str = default_view",
            "        elif default_view == \"tree\":",
            "            warnings.warn(",
            "                \"`default_view` of 'tree' has been renamed to 'grid' -- please update your DAG\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            self._default_view = \"grid\"",
            "        else:",
            "            raise AirflowException(",
            "                f\"Invalid values of dag.default_view: only support \"",
            "                f\"{DEFAULT_VIEW_PRESETS}, but get {default_view}\"",
            "            )",
            "        if orientation in ORIENTATION_PRESETS:",
            "            self.orientation = orientation",
            "        else:",
            "            raise AirflowException(",
            "                f\"Invalid values of dag.orientation: only support \"",
            "                f\"{ORIENTATION_PRESETS}, but get {orientation}\"",
            "            )",
            "        self.catchup = catchup",
            "",
            "        self.partial = False",
            "        self.on_success_callback = on_success_callback",
            "        self.on_failure_callback = on_failure_callback",
            "",
            "        # Keeps track of any extra edge metadata (sparse; will not contain all",
            "        # edges, so do not iterate over it for that). Outer key is upstream",
            "        # task ID, inner key is downstream task ID.",
            "        self.edge_info: dict[str, dict[str, EdgeInfoType]] = {}",
            "",
            "        # To keep it in parity with Serialized DAGs",
            "        # and identify if DAG has on_*_callback without actually storing them in Serialized JSON",
            "        self.has_on_success_callback = self.on_success_callback is not None",
            "        self.has_on_failure_callback = self.on_failure_callback is not None",
            "",
            "        self._access_control = DAG._upgrade_outdated_dag_access_control(access_control)",
            "        self.is_paused_upon_creation = is_paused_upon_creation",
            "        self.auto_register = auto_register",
            "",
            "        self.fail_stop = fail_stop",
            "",
            "        self.jinja_environment_kwargs = jinja_environment_kwargs",
            "        self.render_template_as_native_obj = render_template_as_native_obj",
            "",
            "        self.doc_md = self.get_doc_md(doc_md)",
            "",
            "        self.tags = tags or []",
            "        self._task_group = TaskGroup.create_root(self)",
            "        self.validate_schedule_and_params()",
            "        wrong_links = dict(self.iter_invalid_owner_links())",
            "        if wrong_links:",
            "            raise AirflowException(",
            "                \"Wrong link format was used for the owner. Use a valid link \\n\"",
            "                f\"Bad formatted links are: {wrong_links}\"",
            "            )",
            "",
            "        # this will only be set at serialization time",
            "        # it's only use is for determining the relative",
            "        # fileloc based only on the serialize dag",
            "        self._processor_dags_folder = None",
            "",
            "    def get_doc_md(self, doc_md: str | None) -> str | None:",
            "        if doc_md is None:",
            "            return doc_md",
            "",
            "        env = self.get_template_env(force_sandboxed=True)",
            "",
            "        if not doc_md.endswith(\".md\"):",
            "            template = jinja2.Template(doc_md)",
            "        else:",
            "            try:",
            "                template = env.get_template(doc_md)",
            "            except jinja2.exceptions.TemplateNotFound:",
            "                return f\"\"\"",
            "                # Templating Error!",
            "                Not able to find the template file: `{doc_md}`.",
            "                \"\"\"",
            "",
            "        return template.render()",
            "",
            "    def _check_schedule_interval_matches_timetable(self) -> bool:",
            "        \"\"\"Check ``schedule_interval`` and ``timetable`` match.",
            "",
            "        This is done as a part of the DAG validation done before it's bagged, to",
            "        guard against the DAG's ``timetable`` (or ``schedule_interval``) from",
            "        being changed after it's created, e.g.",
            "",
            "        .. code-block:: python",
            "",
            "            dag1 = DAG(\"d1\", timetable=MyTimetable())",
            "            dag1.schedule_interval = \"@once\"",
            "",
            "            dag2 = DAG(\"d2\", schedule=\"@once\")",
            "            dag2.timetable = MyTimetable()",
            "",
            "        Validation is done by creating a timetable and check its summary matches",
            "        ``schedule_interval``. The logic is not bullet-proof, especially if a",
            "        custom timetable does not provide a useful ``summary``. But this is the",
            "        best we can do.",
            "        \"\"\"",
            "        if self.schedule_interval == self.timetable.summary:",
            "            return True",
            "        try:",
            "            timetable = create_timetable(self.schedule_interval, self.timezone)",
            "        except ValueError:",
            "            return False",
            "        return timetable.summary == self.timetable.summary",
            "",
            "    def validate(self):",
            "        \"\"\"Validate the DAG has a coherent setup.",
            "",
            "        This is called by the DAG bag before bagging the DAG.",
            "        \"\"\"",
            "        if not self._check_schedule_interval_matches_timetable():",
            "            raise AirflowDagInconsistent(",
            "                f\"inconsistent schedule: timetable {self.timetable.summary!r} \"",
            "                f\"does not match schedule_interval {self.schedule_interval!r}\",",
            "            )",
            "        self.params.validate()",
            "        self.timetable.validate()",
            "        self.validate_setup_teardown()",
            "",
            "    def validate_setup_teardown(self):",
            "        \"\"\"",
            "        Validate that setup and teardown tasks are configured properly.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        for task in self.tasks:",
            "            if not task.is_setup:",
            "                continue",
            "            if not any(x.is_teardown for x in task.downstream_list):",
            "                raise AirflowDagInconsistent(",
            "                    \"Dag has setup without teardown: dag='%s', task='%s'\", self.dag_id, task.task_id",
            "                )",
            "",
            "    def __repr__(self):",
            "        return f\"<DAG: {self.dag_id}>\"",
            "",
            "    def __eq__(self, other):",
            "        if type(self) == type(other):",
            "            # Use getattr() instead of __dict__ as __dict__ doesn't return",
            "            # correct values for properties.",
            "            return all(getattr(self, c, None) == getattr(other, c, None) for c in self._comps)",
            "        return False",
            "",
            "    def __ne__(self, other):",
            "        return not self == other",
            "",
            "    def __lt__(self, other):",
            "        return self.dag_id < other.dag_id",
            "",
            "    def __hash__(self):",
            "        hash_components = [type(self)]",
            "        for c in self._comps:",
            "            # task_ids returns a list and lists can't be hashed",
            "            if c == \"task_ids\":",
            "                val = tuple(self.task_dict.keys())",
            "            else:",
            "                val = getattr(self, c, None)",
            "            try:",
            "                hash(val)",
            "                hash_components.append(val)",
            "            except TypeError:",
            "                hash_components.append(repr(val))",
            "        return hash(tuple(hash_components))",
            "",
            "    # Context Manager -----------------------------------------------",
            "    def __enter__(self):",
            "        DagContext.push_context_managed_dag(self)",
            "        return self",
            "",
            "    def __exit__(self, _type, _value, _tb):",
            "        DagContext.pop_context_managed_dag()",
            "",
            "    # /Context Manager ----------------------------------------------",
            "",
            "    @staticmethod",
            "    def _upgrade_outdated_dag_access_control(access_control=None):",
            "        \"\"\"",
            "        Looks for outdated dag level actions (can_dag_read and can_dag_edit) in DAG",
            "        access_controls (for example, {'role1': {'can_dag_read'}, 'role2': {'can_dag_read', 'can_dag_edit'}})",
            "        and replaces them with updated actions (can_read and can_edit).",
            "        \"\"\"",
            "        if not access_control:",
            "            return None",
            "        new_perm_mapping = {",
            "            permissions.DEPRECATED_ACTION_CAN_DAG_READ: permissions.ACTION_CAN_READ,",
            "            permissions.DEPRECATED_ACTION_CAN_DAG_EDIT: permissions.ACTION_CAN_EDIT,",
            "        }",
            "        updated_access_control = {}",
            "        for role, perms in access_control.items():",
            "            updated_access_control[role] = {new_perm_mapping.get(perm, perm) for perm in perms}",
            "",
            "        if access_control != updated_access_control:",
            "            warnings.warn(",
            "                \"The 'can_dag_read' and 'can_dag_edit' permissions are deprecated. \"",
            "                \"Please use 'can_read' and 'can_edit', respectively.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=3,",
            "            )",
            "",
            "        return updated_access_control",
            "",
            "    def date_range(",
            "        self,",
            "        start_date: pendulum.DateTime,",
            "        num: int | None = None,",
            "        end_date: datetime | None = None,",
            "    ) -> list[datetime]:",
            "        message = \"`DAG.date_range()` is deprecated.\"",
            "        if num is not None:",
            "            warnings.warn(message, category=RemovedInAirflow3Warning, stacklevel=2)",
            "            with warnings.catch_warnings():",
            "                warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "                return utils_date_range(",
            "                    start_date=start_date, num=num, delta=self.normalized_schedule_interval",
            "                )",
            "        message += \" Please use `DAG.iter_dagrun_infos_between(..., align=False)` instead.\"",
            "        warnings.warn(message, category=RemovedInAirflow3Warning, stacklevel=2)",
            "        if end_date is None:",
            "            coerced_end_date = timezone.utcnow()",
            "        else:",
            "            coerced_end_date = end_date",
            "        it = self.iter_dagrun_infos_between(start_date, pendulum.instance(coerced_end_date), align=False)",
            "        return [info.logical_date for info in it]",
            "",
            "    def is_fixed_time_schedule(self):",
            "        warnings.warn(",
            "            \"`DAG.is_fixed_time_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        try:",
            "            return not self.timetable._should_fix_dst",
            "        except AttributeError:",
            "            return True",
            "",
            "    def following_schedule(self, dttm):",
            "        \"\"\"",
            "        Calculates the following schedule for this dag in UTC.",
            "",
            "        :param dttm: utc datetime",
            "        :return: utc datetime",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"`DAG.following_schedule()` is deprecated. Use `DAG.next_dagrun_info(restricted=False)` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        data_interval = self.infer_automated_data_interval(timezone.coerce_datetime(dttm))",
            "        next_info = self.next_dagrun_info(data_interval, restricted=False)",
            "        if next_info is None:",
            "            return None",
            "        return next_info.data_interval.start",
            "",
            "    def previous_schedule(self, dttm):",
            "        from airflow.timetables.interval import _DataIntervalTimetable",
            "",
            "        warnings.warn(",
            "            \"`DAG.previous_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if not isinstance(self.timetable, _DataIntervalTimetable):",
            "            return None",
            "        return self.timetable._get_prev(timezone.coerce_datetime(dttm))",
            "",
            "    def get_next_data_interval(self, dag_model: DagModel) -> DataInterval | None:",
            "        \"\"\"Get the data interval of the next scheduled run.",
            "",
            "        For compatibility, this method infers the data interval from the DAG's",
            "        schedule if the run does not have an explicit one set, which is possible",
            "        for runs created prior to AIP-39.",
            "",
            "        This function is private to Airflow core and should not be depended on as a",
            "        part of the Python API.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if self.dag_id != dag_model.dag_id:",
            "            raise ValueError(f\"Arguments refer to different DAGs: {self.dag_id} != {dag_model.dag_id}\")",
            "        if dag_model.next_dagrun is None:  # Next run not scheduled.",
            "            return None",
            "        data_interval = dag_model.next_dagrun_data_interval",
            "        if data_interval is not None:",
            "            return data_interval",
            "",
            "        # Compatibility: A run was scheduled without an explicit data interval.",
            "        # This means the run was scheduled before AIP-39 implementation. Try to",
            "        # infer from the logical date.",
            "        return self.infer_automated_data_interval(dag_model.next_dagrun)",
            "",
            "    def get_run_data_interval(self, run: DagRun) -> DataInterval:",
            "        \"\"\"Get the data interval of this run.",
            "",
            "        For compatibility, this method infers the data interval from the DAG's",
            "        schedule if the run does not have an explicit one set, which is possible for",
            "        runs created prior to AIP-39.",
            "",
            "        This function is private to Airflow core and should not be depended on as a",
            "        part of the Python API.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if run.dag_id is not None and run.dag_id != self.dag_id:",
            "            raise ValueError(f\"Arguments refer to different DAGs: {self.dag_id} != {run.dag_id}\")",
            "        data_interval = _get_model_data_interval(run, \"data_interval_start\", \"data_interval_end\")",
            "        if data_interval is not None:",
            "            return data_interval",
            "        # Compatibility: runs created before AIP-39 implementation don't have an",
            "        # explicit data interval. Try to infer from the logical date.",
            "        return self.infer_automated_data_interval(run.execution_date)",
            "",
            "    def infer_automated_data_interval(self, logical_date: datetime) -> DataInterval:",
            "        \"\"\"Infer a data interval for a run against this DAG.",
            "",
            "        This method is used to bridge runs created prior to AIP-39",
            "        implementation, which do not have an explicit data interval. Therefore,",
            "        this method only considers ``schedule_interval`` values valid prior to",
            "        Airflow 2.2.",
            "",
            "        DO NOT call this method if there is a known data interval.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        timetable_type = type(self.timetable)",
            "        if issubclass(timetable_type, (NullTimetable, OnceTimetable, DatasetTriggeredTimetable)):",
            "            return DataInterval.exact(timezone.coerce_datetime(logical_date))",
            "        start = timezone.coerce_datetime(logical_date)",
            "        if issubclass(timetable_type, CronDataIntervalTimetable):",
            "            end = cast(CronDataIntervalTimetable, self.timetable)._get_next(start)",
            "        elif issubclass(timetable_type, DeltaDataIntervalTimetable):",
            "            end = cast(DeltaDataIntervalTimetable, self.timetable)._get_next(start)",
            "        # Contributors: When the exception below is raised, you might want to",
            "        # add an 'elif' block here to handle custom timetables. Stop! The bug",
            "        # you're looking for is instead at when the DAG run (represented by",
            "        # logical_date) was created. See GH-31969 for an example:",
            "        # * Wrong fix: GH-32074 (modifies this function).",
            "        # * Correct fix: GH-32118 (modifies the DAG run creation code).",
            "        else:",
            "            raise ValueError(f\"Not a valid timetable: {self.timetable!r}\")",
            "        return DataInterval(start, end)",
            "",
            "    def next_dagrun_info(",
            "        self,",
            "        last_automated_dagrun: None | datetime | DataInterval,",
            "        *,",
            "        restricted: bool = True,",
            "    ) -> DagRunInfo | None:",
            "        \"\"\"Get information about the next DagRun of this dag after ``date_last_automated_dagrun``.",
            "",
            "        This calculates what time interval the next DagRun should operate on",
            "        (its execution date) and when it can be scheduled, according to the",
            "        dag's timetable, start_date, end_date, etc. This doesn't check max",
            "        active run or any other \"max_active_tasks\" type limits, but only",
            "        performs calculations based on the various date and interval fields of",
            "        this dag and its tasks.",
            "",
            "        :param last_automated_dagrun: The ``max(execution_date)`` of",
            "            existing \"automated\" DagRuns for this dag (scheduled or backfill,",
            "            but not manual).",
            "        :param restricted: If set to *False* (default is *True*), ignore",
            "            ``start_date``, ``end_date``, and ``catchup`` specified on the DAG",
            "            or tasks.",
            "        :return: DagRunInfo of the next dagrun, or None if a dagrun is not",
            "            going to be scheduled.",
            "        \"\"\"",
            "        # Never schedule a subdag. It will be scheduled by its parent dag.",
            "        if self.is_subdag:",
            "            return None",
            "",
            "        data_interval = None",
            "        if isinstance(last_automated_dagrun, datetime):",
            "            warnings.warn(",
            "                \"Passing a datetime to DAG.next_dagrun_info is deprecated. Use a DataInterval instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            data_interval = self.infer_automated_data_interval(",
            "                timezone.coerce_datetime(last_automated_dagrun)",
            "            )",
            "        else:",
            "            data_interval = last_automated_dagrun",
            "        if restricted:",
            "            restriction = self._time_restriction",
            "        else:",
            "            restriction = TimeRestriction(earliest=None, latest=None, catchup=True)",
            "        try:",
            "            info = self.timetable.next_dagrun_info(",
            "                last_automated_data_interval=data_interval,",
            "                restriction=restriction,",
            "            )",
            "        except Exception:",
            "            self.log.exception(",
            "                \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                data_interval,",
            "                self.dag_id,",
            "            )",
            "            info = None",
            "        return info",
            "",
            "    def next_dagrun_after_date(self, date_last_automated_dagrun: pendulum.DateTime | None):",
            "        warnings.warn(",
            "            \"`DAG.next_dagrun_after_date()` is deprecated. Please use `DAG.next_dagrun_info()` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if date_last_automated_dagrun is None:",
            "            data_interval = None",
            "        else:",
            "            data_interval = self.infer_automated_data_interval(date_last_automated_dagrun)",
            "        info = self.next_dagrun_info(data_interval)",
            "        if info is None:",
            "            return None",
            "        return info.run_after",
            "",
            "    @functools.cached_property",
            "    def _time_restriction(self) -> TimeRestriction:",
            "        start_dates = [t.start_date for t in self.tasks if t.start_date]",
            "        if self.start_date is not None:",
            "            start_dates.append(self.start_date)",
            "        earliest = None",
            "        if start_dates:",
            "            earliest = timezone.coerce_datetime(min(start_dates))",
            "        latest = self.end_date",
            "        end_dates = [t.end_date for t in self.tasks if t.end_date]",
            "        if len(end_dates) == len(self.tasks):  # not exists null end_date",
            "            if self.end_date is not None:",
            "                end_dates.append(self.end_date)",
            "            if end_dates:",
            "                latest = timezone.coerce_datetime(max(end_dates))",
            "        return TimeRestriction(earliest, latest, self.catchup)",
            "",
            "    def iter_dagrun_infos_between(",
            "        self,",
            "        earliest: pendulum.DateTime | None,",
            "        latest: pendulum.DateTime,",
            "        *,",
            "        align: bool = True,",
            "    ) -> Iterable[DagRunInfo]:",
            "        \"\"\"Yield DagRunInfo using this DAG's timetable between given interval.",
            "",
            "        DagRunInfo instances yielded if their ``logical_date`` is not earlier",
            "        than ``earliest``, nor later than ``latest``. The instances are ordered",
            "        by their ``logical_date`` from earliest to latest.",
            "",
            "        If ``align`` is ``False``, the first run will happen immediately on",
            "        ``earliest``, even if it does not fall on the logical timetable schedule.",
            "        The default is ``True``, but subdags will ignore this value and always",
            "        behave as if this is set to ``False`` for backward compatibility.",
            "",
            "        Example: A DAG is scheduled to run every midnight (``0 0 * * *``). If",
            "        ``earliest`` is ``2021-06-03 23:00:00``, the first DagRunInfo would be",
            "        ``2021-06-03 23:00:00`` if ``align=False``, and ``2021-06-04 00:00:00``",
            "        if ``align=True``.",
            "        \"\"\"",
            "        if earliest is None:",
            "            earliest = self._time_restriction.earliest",
            "        if earliest is None:",
            "            raise ValueError(\"earliest was None and we had no value in time_restriction to fallback on\")",
            "        earliest = timezone.coerce_datetime(earliest)",
            "        latest = timezone.coerce_datetime(latest)",
            "",
            "        restriction = TimeRestriction(earliest, latest, catchup=True)",
            "",
            "        # HACK: Sub-DAGs are currently scheduled differently. For example, say",
            "        # the schedule is @daily and start is 2021-06-03 22:16:00, a top-level",
            "        # DAG should be first scheduled to run on midnight 2021-06-04, but a",
            "        # sub-DAG should be first scheduled to run RIGHT NOW. We can change",
            "        # this, but since sub-DAGs are going away in 3.0 anyway, let's keep",
            "        # compatibility for now and remove this entirely later.",
            "        if self.is_subdag:",
            "            align = False",
            "",
            "        try:",
            "            info = self.timetable.next_dagrun_info(",
            "                last_automated_data_interval=None,",
            "                restriction=restriction,",
            "            )",
            "        except Exception:",
            "            self.log.exception(",
            "                \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                None,",
            "                self.dag_id,",
            "            )",
            "            info = None",
            "",
            "        if info is None:",
            "            # No runs to be scheduled between the user-supplied timeframe. But",
            "            # if align=False, \"invent\" a data interval for the timeframe itself.",
            "            if not align:",
            "                yield DagRunInfo.interval(earliest, latest)",
            "            return",
            "",
            "        # If align=False and earliest does not fall on the timetable's logical",
            "        # schedule, \"invent\" a data interval for it.",
            "        if not align and info.logical_date != earliest:",
            "            yield DagRunInfo.interval(earliest, info.data_interval.start)",
            "",
            "        # Generate naturally according to schedule.",
            "        while info is not None:",
            "            yield info",
            "            try:",
            "                info = self.timetable.next_dagrun_info(",
            "                    last_automated_data_interval=info.data_interval,",
            "                    restriction=restriction,",
            "                )",
            "            except Exception:",
            "                self.log.exception(",
            "                    \"Failed to fetch run info after data interval %s for DAG %r\",",
            "                    info.data_interval if info else \"<NONE>\",",
            "                    self.dag_id,",
            "                )",
            "                break",
            "",
            "    def get_run_dates(self, start_date, end_date=None) -> list:",
            "        \"\"\"",
            "        Returns a list of dates between the interval received as parameter using this",
            "        dag's schedule interval. Returned dates can be used for execution dates.",
            "",
            "        :param start_date: The start date of the interval.",
            "        :param end_date: The end date of the interval. Defaults to ``timezone.utcnow()``.",
            "        :return: A list of dates within the interval following the dag's schedule.",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"`DAG.get_run_dates()` is deprecated. Please use `DAG.iter_dagrun_infos_between()` instead.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        earliest = timezone.coerce_datetime(start_date)",
            "        if end_date is None:",
            "            latest = pendulum.now(timezone.utc)",
            "        else:",
            "            latest = timezone.coerce_datetime(end_date)",
            "        return [info.logical_date for info in self.iter_dagrun_infos_between(earliest, latest)]",
            "",
            "    def normalize_schedule(self, dttm):",
            "        warnings.warn(",
            "            \"`DAG.normalize_schedule()` is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "            following = self.following_schedule(dttm)",
            "        if not following:  # in case of @once",
            "            return dttm",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "            previous_of_following = self.previous_schedule(following)",
            "        if previous_of_following != dttm:",
            "            return following",
            "        return dttm",
            "",
            "    @provide_session",
            "    def get_last_dagrun(self, session=NEW_SESSION, include_externally_triggered=False):",
            "        return get_last_dagrun(",
            "            self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "        )",
            "",
            "    @provide_session",
            "    def has_dag_runs(self, session=NEW_SESSION, include_externally_triggered=True) -> bool:",
            "        return (",
            "            get_last_dagrun(",
            "                self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "            )",
            "            is not None",
            "        )",
            "",
            "    @property",
            "    def dag_id(self) -> str:",
            "        return self._dag_id",
            "",
            "    @dag_id.setter",
            "    def dag_id(self, value: str) -> None:",
            "        self._dag_id = value",
            "",
            "    @property",
            "    def is_subdag(self) -> bool:",
            "        return self.parent_dag is not None",
            "",
            "    @property",
            "    def full_filepath(self) -> str:",
            "        \"\"\"Full file path to the DAG.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"DAG.full_filepath is deprecated in favour of fileloc\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.fileloc",
            "",
            "    @full_filepath.setter",
            "    def full_filepath(self, value) -> None:",
            "        warnings.warn(",
            "            \"DAG.full_filepath is deprecated in favour of fileloc\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        self.fileloc = value",
            "",
            "    @property",
            "    def concurrency(self) -> int:",
            "        # TODO: Remove in Airflow 3.0",
            "        warnings.warn(",
            "            \"The 'DAG.concurrency' attribute is deprecated. Please use 'DAG.max_active_tasks'.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self._max_active_tasks",
            "",
            "    @concurrency.setter",
            "    def concurrency(self, value: int):",
            "        self._max_active_tasks = value",
            "",
            "    @property",
            "    def max_active_tasks(self) -> int:",
            "        return self._max_active_tasks",
            "",
            "    @max_active_tasks.setter",
            "    def max_active_tasks(self, value: int):",
            "        self._max_active_tasks = value",
            "",
            "    @property",
            "    def access_control(self):",
            "        return self._access_control",
            "",
            "    @access_control.setter",
            "    def access_control(self, value):",
            "        self._access_control = DAG._upgrade_outdated_dag_access_control(value)",
            "",
            "    @property",
            "    def description(self) -> str | None:",
            "        return self._description",
            "",
            "    @property",
            "    def default_view(self) -> str:",
            "        return self._default_view",
            "",
            "    @property",
            "    def pickle_id(self) -> int | None:",
            "        return self._pickle_id",
            "",
            "    @pickle_id.setter",
            "    def pickle_id(self, value: int) -> None:",
            "        self._pickle_id = value",
            "",
            "    def param(self, name: str, default: Any = NOTSET) -> DagParam:",
            "        \"\"\"",
            "        Return a DagParam object for current dag.",
            "",
            "        :param name: dag parameter name.",
            "        :param default: fallback value for dag parameter.",
            "        :return: DagParam instance for specified name and current dag.",
            "        \"\"\"",
            "        return DagParam(current_dag=self, name=name, default=default)",
            "",
            "    @property",
            "    def tasks(self) -> list[Operator]:",
            "        return list(self.task_dict.values())",
            "",
            "    @tasks.setter",
            "    def tasks(self, val):",
            "        raise AttributeError(\"DAG.tasks can not be modified. Use dag.add_task() instead.\")",
            "",
            "    @property",
            "    def task_ids(self) -> list[str]:",
            "        return list(self.task_dict.keys())",
            "",
            "    @property",
            "    def teardowns(self) -> list[Operator]:",
            "        return [task for task in self.tasks if getattr(task, \"is_teardown\", None)]",
            "",
            "    @property",
            "    def tasks_upstream_of_teardowns(self) -> list[Operator]:",
            "        upstream_tasks = [t.upstream_list for t in self.teardowns]",
            "        return [val for sublist in upstream_tasks for val in sublist if not getattr(val, \"is_teardown\", None)]",
            "",
            "    @property",
            "    def task_group(self) -> TaskGroup:",
            "        return self._task_group",
            "",
            "    @property",
            "    def filepath(self) -> str:",
            "        \"\"\"Relative file path to the DAG.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"filepath is deprecated, use relative_fileloc instead\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return str(self.relative_fileloc)",
            "",
            "    @property",
            "    def relative_fileloc(self) -> pathlib.Path:",
            "        \"\"\"File location of the importable dag 'file' relative to the configured DAGs folder.\"\"\"",
            "        path = pathlib.Path(self.fileloc)",
            "        try:",
            "            rel_path = path.relative_to(self._processor_dags_folder or settings.DAGS_FOLDER)",
            "            if rel_path == pathlib.Path(\".\"):",
            "                return path",
            "            else:",
            "                return rel_path",
            "        except ValueError:",
            "            # Not relative to DAGS_FOLDER.",
            "            return path",
            "",
            "    @property",
            "    def folder(self) -> str:",
            "        \"\"\"Folder location of where the DAG object is instantiated.\"\"\"",
            "        return os.path.dirname(self.fileloc)",
            "",
            "    @property",
            "    def owner(self) -> str:",
            "        \"\"\"",
            "        Return list of all owners found in DAG tasks.",
            "",
            "        :return: Comma separated list of owners in DAG tasks",
            "        \"\"\"",
            "        return \", \".join({t.owner for t in self.tasks})",
            "",
            "    @property",
            "    def allow_future_exec_dates(self) -> bool:",
            "        return settings.ALLOW_FUTURE_EXEC_DATES and not self.timetable.can_be_scheduled",
            "",
            "    @provide_session",
            "    def get_concurrency_reached(self, session=NEW_SESSION) -> bool:",
            "        \"\"\"",
            "        Returns a boolean indicating whether the max_active_tasks limit for this DAG",
            "        has been reached.",
            "        \"\"\"",
            "        TI = TaskInstance",
            "        total_tasks = session.scalar(",
            "            select(func.count(TI.task_id)).where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.state == TaskInstanceState.RUNNING,",
            "            )",
            "        )",
            "        return total_tasks >= self.max_active_tasks",
            "",
            "    @property",
            "    def concurrency_reached(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_concurrency_reached` method.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_concurrency_reached` method.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_concurrency_reached()",
            "",
            "    @provide_session",
            "    def get_is_active(self, session=NEW_SESSION) -> None:",
            "        \"\"\"Returns a boolean indicating whether this DAG is active.\"\"\"",
            "        return session.scalar(select(DagModel.is_active).where(DagModel.dag_id == self.dag_id))",
            "",
            "    @provide_session",
            "    def get_is_paused(self, session=NEW_SESSION) -> None:",
            "        \"\"\"Returns a boolean indicating whether this DAG is paused.\"\"\"",
            "        return session.scalar(select(DagModel.is_paused).where(DagModel.dag_id == self.dag_id))",
            "",
            "    @property",
            "    def is_paused(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_is_paused` method.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_is_paused` method.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_is_paused()",
            "",
            "    @property",
            "    def normalized_schedule_interval(self) -> ScheduleInterval:",
            "        warnings.warn(",
            "            \"DAG.normalized_schedule_interval() is deprecated.\",",
            "            category=RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        if isinstance(self.schedule_interval, str) and self.schedule_interval in cron_presets:",
            "            _schedule_interval: ScheduleInterval = cron_presets.get(self.schedule_interval)",
            "        elif self.schedule_interval == \"@once\":",
            "            _schedule_interval = None",
            "        else:",
            "            _schedule_interval = self.schedule_interval",
            "        return _schedule_interval",
            "",
            "    @provide_session",
            "    def handle_callback(self, dagrun, success=True, reason=None, session=NEW_SESSION):",
            "        \"\"\"",
            "        Triggers the appropriate callback depending on the value of success, namely the",
            "        on_failure_callback or on_success_callback. This method gets the context of a",
            "        single TaskInstance part of this DagRun and passes that to the callable along",
            "        with a 'reason', primarily to differentiate DagRun failures.",
            "",
            "        .. note: The logs end up in",
            "            ``$AIRFLOW_HOME/logs/scheduler/latest/PROJECT/DAG_FILE.py.log``",
            "",
            "        :param dagrun: DagRun object",
            "        :param success: Flag to specify if failure or success callback should be called",
            "        :param reason: Completion reason",
            "        :param session: Database session",
            "        \"\"\"",
            "        callbacks = self.on_success_callback if success else self.on_failure_callback",
            "        if callbacks:",
            "            callbacks = callbacks if isinstance(callbacks, list) else [callbacks]",
            "            tis = dagrun.get_task_instances(session=session)",
            "            ti = tis[-1]  # get first TaskInstance of DagRun",
            "            ti.task = self.get_task(ti.task_id)",
            "            context = ti.get_template_context(session=session)",
            "            context.update({\"reason\": reason})",
            "            for callback in callbacks:",
            "                self.log.info(\"Executing dag callback function: %s\", callback)",
            "                try:",
            "                    callback(context)",
            "                except Exception:",
            "                    self.log.exception(\"failed to invoke dag state update callback\")",
            "                    Stats.incr(\"dag.callback_exceptions\", tags={\"dag_id\": dagrun.dag_id})",
            "",
            "    def get_active_runs(self):",
            "        \"\"\"",
            "        Returns a list of dag run execution dates currently running.",
            "",
            "        :return: List of execution dates",
            "        \"\"\"",
            "        runs = DagRun.find(dag_id=self.dag_id, state=State.RUNNING)",
            "",
            "        active_dates = []",
            "        for run in runs:",
            "            active_dates.append(run.execution_date)",
            "",
            "        return active_dates",
            "",
            "    @provide_session",
            "    def get_num_active_runs(self, external_trigger=None, only_running=True, session=NEW_SESSION):",
            "        \"\"\"",
            "        Returns the number of active \"running\" dag runs.",
            "",
            "        :param external_trigger: True for externally triggered active dag runs",
            "        :param session:",
            "        :return: number greater than 0 for active dag runs",
            "        \"\"\"",
            "        query = select(func.count()).where(DagRun.dag_id == self.dag_id)",
            "        if only_running:",
            "            query = query.where(DagRun.state == DagRunState.RUNNING)",
            "        else:",
            "            query = query.where(DagRun.state.in_({DagRunState.RUNNING, DagRunState.QUEUED}))",
            "",
            "        if external_trigger is not None:",
            "            query = query.where(",
            "                DagRun.external_trigger == (expression.true() if external_trigger else expression.false())",
            "            )",
            "",
            "        return session.scalar(query)",
            "",
            "    @provide_session",
            "    def get_dagrun(",
            "        self,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        \"\"\"",
            "        Returns the dag run for a given execution date or run_id if it exists, otherwise",
            "        none.",
            "",
            "        :param execution_date: The execution date of the DagRun to find.",
            "        :param run_id: The run_id of the DagRun to find.",
            "        :param session:",
            "        :return: The DagRun if found, otherwise None.",
            "        \"\"\"",
            "        if not (execution_date or run_id):",
            "            raise TypeError(\"You must provide either the execution_date or the run_id\")",
            "        query = select(DagRun)",
            "        if execution_date:",
            "            query = query.where(DagRun.dag_id == self.dag_id, DagRun.execution_date == execution_date)",
            "        if run_id:",
            "            query = query.where(DagRun.dag_id == self.dag_id, DagRun.run_id == run_id)",
            "        return session.scalar(query)",
            "",
            "    @provide_session",
            "    def get_dagruns_between(self, start_date, end_date, session=NEW_SESSION):",
            "        \"\"\"",
            "        Returns the list of dag runs between start_date (inclusive) and end_date (inclusive).",
            "",
            "        :param start_date: The starting execution date of the DagRun to find.",
            "        :param end_date: The ending execution date of the DagRun to find.",
            "        :param session:",
            "        :return: The list of DagRuns found.",
            "        \"\"\"",
            "        dagruns = session.scalars(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date >= start_date,",
            "                DagRun.execution_date <= end_date,",
            "            )",
            "        ).all()",
            "",
            "        return dagruns",
            "",
            "    @provide_session",
            "    def get_latest_execution_date(self, session: Session = NEW_SESSION) -> pendulum.DateTime | None:",
            "        \"\"\"Returns the latest date for which at least one dag run exists.\"\"\"",
            "        return session.scalar(select(func.max(DagRun.execution_date)).where(DagRun.dag_id == self.dag_id))",
            "",
            "    @property",
            "    def latest_execution_date(self):",
            "        \"\"\"This attribute is deprecated. Please use `airflow.models.DAG.get_latest_execution_date`.\"\"\"",
            "        warnings.warn(",
            "            \"This attribute is deprecated. Please use `airflow.models.DAG.get_latest_execution_date`.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_latest_execution_date()",
            "",
            "    @property",
            "    def subdags(self):",
            "        \"\"\"Returns a list of the subdag objects associated to this DAG.\"\"\"",
            "        # Check SubDag for class but don't check class directly",
            "        from airflow.operators.subdag import SubDagOperator",
            "",
            "        subdag_lst = []",
            "        for task in self.tasks:",
            "            if (",
            "                isinstance(task, SubDagOperator)",
            "                or",
            "                # TODO remove in Airflow 2.0",
            "                type(task).__name__ == \"SubDagOperator\"",
            "                or task.task_type == \"SubDagOperator\"",
            "            ):",
            "                subdag_lst.append(task.subdag)",
            "                subdag_lst += task.subdag.subdags",
            "        return subdag_lst",
            "",
            "    def resolve_template_files(self):",
            "        for t in self.tasks:",
            "            t.resolve_template_files()",
            "",
            "    def get_template_env(self, *, force_sandboxed: bool = False) -> jinja2.Environment:",
            "        \"\"\"Build a Jinja2 environment.\"\"\"",
            "        # Collect directories to search for template files",
            "        searchpath = [self.folder]",
            "        if self.template_searchpath:",
            "            searchpath += self.template_searchpath",
            "",
            "        # Default values (for backward compatibility)",
            "        jinja_env_options = {",
            "            \"loader\": jinja2.FileSystemLoader(searchpath),",
            "            \"undefined\": self.template_undefined,",
            "            \"extensions\": [\"jinja2.ext.do\"],",
            "            \"cache_size\": 0,",
            "        }",
            "        if self.jinja_environment_kwargs:",
            "            jinja_env_options.update(self.jinja_environment_kwargs)",
            "        env: jinja2.Environment",
            "        if self.render_template_as_native_obj and not force_sandboxed:",
            "            env = airflow.templates.NativeEnvironment(**jinja_env_options)",
            "        else:",
            "            env = airflow.templates.SandboxedEnvironment(**jinja_env_options)",
            "",
            "        # Add any user defined items. Safe to edit globals as long as no templates are rendered yet.",
            "        # http://jinja.pocoo.org/docs/2.10/api/#jinja2.Environment.globals",
            "        if self.user_defined_macros:",
            "            env.globals.update(self.user_defined_macros)",
            "        if self.user_defined_filters:",
            "            env.filters.update(self.user_defined_filters)",
            "",
            "        return env",
            "",
            "    def set_dependency(self, upstream_task_id, downstream_task_id):",
            "        \"\"\"",
            "        Simple utility method to set dependency between two tasks that",
            "        already have been added to the DAG using add_task().",
            "        \"\"\"",
            "        self.get_task(upstream_task_id).set_downstream(self.get_task(downstream_task_id))",
            "",
            "    @provide_session",
            "    def get_task_instances_before(",
            "        self,",
            "        base_date: datetime,",
            "        num: int,",
            "        *,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"Get ``num`` task instances before (including) ``base_date``.",
            "",
            "        The returned list may contain exactly ``num`` task instances",
            "        corresponding to any DagRunType. It can have less if there are",
            "        less than ``num`` scheduled DAG runs before ``base_date``.",
            "        \"\"\"",
            "        execution_dates: list[Any] = session.execute(",
            "            select(DagRun.execution_date)",
            "            .where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date <= base_date,",
            "            )",
            "            .order_by(DagRun.execution_date.desc())",
            "            .limit(num)",
            "        ).all()",
            "",
            "        if len(execution_dates) == 0:",
            "            return self.get_task_instances(start_date=base_date, end_date=base_date, session=session)",
            "",
            "        min_date: datetime | None = execution_dates[-1]._mapping.get(",
            "            \"execution_date\"",
            "        )  # getting the last value from the list",
            "",
            "        return self.get_task_instances(start_date=min_date, end_date=base_date, session=session)",
            "",
            "    @provide_session",
            "    def get_task_instances(",
            "        self,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        state: list[TaskInstanceState] | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        if not start_date:",
            "            start_date = (timezone.utcnow() - timedelta(30)).replace(",
            "                hour=0, minute=0, second=0, microsecond=0",
            "            )",
            "",
            "        query = self._get_task_instances(",
            "            task_ids=None,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            run_id=None,",
            "            state=state or (),",
            "            include_subdags=False,",
            "            include_parentdag=False,",
            "            include_dependent_dags=False,",
            "            exclude_task_ids=(),",
            "            session=session,",
            "        )",
            "        return session.scalars(cast(Select, query).order_by(DagRun.execution_date)).all()",
            "",
            "    @overload",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = ...,",
            "    ) -> Iterable[TaskInstance]:",
            "        ...  # pragma: no cover",
            "",
            "    @overload",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        as_pk_tuple: Literal[True],",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = ...,",
            "        recursion_depth: int = ...,",
            "        max_recursion_depth: int = ...,",
            "        visited_external_tis: set[TaskInstanceKey] = ...,",
            "    ) -> set[TaskInstanceKey]:",
            "        ...  # pragma: no cover",
            "",
            "    def _get_task_instances(",
            "        self,",
            "        *,",
            "        task_ids: Collection[str | tuple[str, int]] | None,",
            "        as_pk_tuple: Literal[True, None] = None,",
            "        start_date: datetime | None,",
            "        end_date: datetime | None,",
            "        run_id: str | None,",
            "        state: TaskInstanceState | Sequence[TaskInstanceState],",
            "        include_subdags: bool,",
            "        include_parentdag: bool,",
            "        include_dependent_dags: bool,",
            "        exclude_task_ids: Collection[str | tuple[str, int]] | None,",
            "        session: Session,",
            "        dag_bag: DagBag | None = None,",
            "        recursion_depth: int = 0,",
            "        max_recursion_depth: int | None = None,",
            "        visited_external_tis: set[TaskInstanceKey] | None = None,",
            "    ) -> Iterable[TaskInstance] | set[TaskInstanceKey]:",
            "        TI = TaskInstance",
            "",
            "        # If we are looking at subdags/dependent dags we want to avoid UNION calls",
            "        # in SQL (it doesn't play nice with fields that have no equality operator,",
            "        # like JSON types), we instead build our result set separately.",
            "        #",
            "        # This will be empty if we are only looking at one dag, in which case",
            "        # we can return the filtered TI query object directly.",
            "        result: set[TaskInstanceKey] = set()",
            "",
            "        # Do we want full objects, or just the primary columns?",
            "        if as_pk_tuple:",
            "            tis = select(TI.dag_id, TI.task_id, TI.run_id, TI.map_index)",
            "        else:",
            "            tis = select(TaskInstance)",
            "        tis = tis.join(TaskInstance.dag_run)",
            "",
            "        if include_subdags:",
            "            # Crafting the right filter for dag_id and task_ids combo",
            "            conditions = []",
            "            for dag in self.subdags + [self]:",
            "                conditions.append(",
            "                    (TaskInstance.dag_id == dag.dag_id) & TaskInstance.task_id.in_(dag.task_ids)",
            "                )",
            "            tis = tis.where(or_(*conditions))",
            "        elif self.partial:",
            "            tis = tis.where(TaskInstance.dag_id == self.dag_id, TaskInstance.task_id.in_(self.task_ids))",
            "        else:",
            "            tis = tis.where(TaskInstance.dag_id == self.dag_id)",
            "        if run_id:",
            "            tis = tis.where(TaskInstance.run_id == run_id)",
            "        if start_date:",
            "            tis = tis.where(DagRun.execution_date >= start_date)",
            "        if task_ids is not None:",
            "            tis = tis.where(TaskInstance.ti_selector_condition(task_ids))",
            "",
            "        # This allows allow_trigger_in_future config to take affect, rather than mandating exec_date <= UTC",
            "        if end_date or not self.allow_future_exec_dates:",
            "            end_date = end_date or timezone.utcnow()",
            "            tis = tis.where(DagRun.execution_date <= end_date)",
            "",
            "        if state:",
            "            if isinstance(state, (str, TaskInstanceState)):",
            "                tis = tis.where(TaskInstance.state == state)",
            "            elif len(state) == 1:",
            "                tis = tis.where(TaskInstance.state == state[0])",
            "            else:",
            "                # this is required to deal with NULL values",
            "                if None in state:",
            "                    if all(x is None for x in state):",
            "                        tis = tis.where(TaskInstance.state.is_(None))",
            "                    else:",
            "                        not_none_state = [s for s in state if s]",
            "                        tis = tis.where(",
            "                            or_(TaskInstance.state.in_(not_none_state), TaskInstance.state.is_(None))",
            "                        )",
            "                else:",
            "                    tis = tis.where(TaskInstance.state.in_(state))",
            "",
            "        # Next, get any of them from our parent DAG (if there is one)",
            "        if include_parentdag and self.parent_dag is not None:",
            "            if visited_external_tis is None:",
            "                visited_external_tis = set()",
            "",
            "            p_dag = self.parent_dag.partial_subset(",
            "                task_ids_or_regex=r\"^{}$\".format(self.dag_id.split(\".\")[1]),",
            "                include_upstream=False,",
            "                include_downstream=True,",
            "            )",
            "            result.update(",
            "                p_dag._get_task_instances(",
            "                    task_ids=task_ids,",
            "                    start_date=start_date,",
            "                    end_date=end_date,",
            "                    run_id=None,",
            "                    state=state,",
            "                    include_subdags=include_subdags,",
            "                    include_parentdag=False,",
            "                    include_dependent_dags=include_dependent_dags,",
            "                    as_pk_tuple=True,",
            "                    exclude_task_ids=exclude_task_ids,",
            "                    session=session,",
            "                    dag_bag=dag_bag,",
            "                    recursion_depth=recursion_depth,",
            "                    max_recursion_depth=max_recursion_depth,",
            "                    visited_external_tis=visited_external_tis,",
            "                )",
            "            )",
            "",
            "        if include_dependent_dags:",
            "            # Recursively find external tasks indicated by ExternalTaskMarker",
            "            from airflow.sensors.external_task import ExternalTaskMarker",
            "",
            "            query = tis",
            "            if as_pk_tuple:",
            "                all_tis = session.execute(query).all()",
            "                condition = TI.filter_for_tis(TaskInstanceKey(*cols) for cols in all_tis)",
            "                if condition is not None:",
            "                    query = select(TI).where(condition)",
            "",
            "            if visited_external_tis is None:",
            "                visited_external_tis = set()",
            "",
            "            external_tasks = session.scalars(query.where(TI.operator == ExternalTaskMarker.__name__))",
            "",
            "            for ti in external_tasks:",
            "                ti_key = ti.key.primary",
            "                if ti_key in visited_external_tis:",
            "                    continue",
            "",
            "                visited_external_tis.add(ti_key)",
            "",
            "                task: ExternalTaskMarker = cast(ExternalTaskMarker, copy.copy(self.get_task(ti.task_id)))",
            "                ti.task = task",
            "",
            "                if max_recursion_depth is None:",
            "                    # Maximum recursion depth allowed is the recursion_depth of the first",
            "                    # ExternalTaskMarker in the tasks to be visited.",
            "                    max_recursion_depth = task.recursion_depth",
            "",
            "                if recursion_depth + 1 > max_recursion_depth:",
            "                    # Prevent cycles or accidents.",
            "                    raise AirflowException(",
            "                        f\"Maximum recursion depth {max_recursion_depth} reached for \"",
            "                        f\"{ExternalTaskMarker.__name__} {ti.task_id}. \"",
            "                        f\"Attempted to clear too many tasks or there may be a cyclic dependency.\"",
            "                    )",
            "                ti.render_templates()",
            "                external_tis = session.scalars(",
            "                    select(TI)",
            "                    .join(TI.dag_run)",
            "                    .where(",
            "                        TI.dag_id == task.external_dag_id,",
            "                        TI.task_id == task.external_task_id,",
            "                        DagRun.execution_date == pendulum.parse(task.execution_date),",
            "                    )",
            "                )",
            "",
            "                for tii in external_tis:",
            "                    if not dag_bag:",
            "                        from airflow.models.dagbag import DagBag",
            "",
            "                        dag_bag = DagBag(read_dags_from_db=True)",
            "                    external_dag = dag_bag.get_dag(tii.dag_id, session=session)",
            "                    if not external_dag:",
            "                        raise AirflowException(f\"Could not find dag {tii.dag_id}\")",
            "                    downstream = external_dag.partial_subset(",
            "                        task_ids_or_regex=[tii.task_id],",
            "                        include_upstream=False,",
            "                        include_downstream=True,",
            "                    )",
            "                    result.update(",
            "                        downstream._get_task_instances(",
            "                            task_ids=None,",
            "                            run_id=tii.run_id,",
            "                            start_date=None,",
            "                            end_date=None,",
            "                            state=state,",
            "                            include_subdags=include_subdags,",
            "                            include_dependent_dags=include_dependent_dags,",
            "                            include_parentdag=False,",
            "                            as_pk_tuple=True,",
            "                            exclude_task_ids=exclude_task_ids,",
            "                            dag_bag=dag_bag,",
            "                            session=session,",
            "                            recursion_depth=recursion_depth + 1,",
            "                            max_recursion_depth=max_recursion_depth,",
            "                            visited_external_tis=visited_external_tis,",
            "                        )",
            "                    )",
            "",
            "        if result or as_pk_tuple:",
            "            # Only execute the `ti` query if we have also collected some other results (i.e. subdags etc.)",
            "            if as_pk_tuple:",
            "                tis_query = session.execute(tis).all()",
            "                result.update(TaskInstanceKey(**cols._mapping) for cols in tis_query)",
            "            else:",
            "                result.update(ti.key for ti in session.scalars(tis))",
            "",
            "            if exclude_task_ids is not None:",
            "                result = {",
            "                    task",
            "                    for task in result",
            "                    if task.task_id not in exclude_task_ids",
            "                    and (task.task_id, task.map_index) not in exclude_task_ids",
            "                }",
            "",
            "        if as_pk_tuple:",
            "            return result",
            "        if result:",
            "            # We've been asked for objects, lets combine it all back in to a result set",
            "            ti_filters = TI.filter_for_tis(result)",
            "            if ti_filters is not None:",
            "                tis = select(TI).where(ti_filters)",
            "        elif exclude_task_ids is None:",
            "            pass  # Disable filter if not set.",
            "        elif isinstance(next(iter(exclude_task_ids), None), str):",
            "            tis = tis.where(TI.task_id.notin_(exclude_task_ids))",
            "        else:",
            "            tis = tis.where(not_(tuple_in_condition((TI.task_id, TI.map_index), exclude_task_ids)))",
            "",
            "        return tis",
            "",
            "    @provide_session",
            "    def set_task_instance_state(",
            "        self,",
            "        *,",
            "        task_id: str,",
            "        map_indexes: Collection[int] | None = None,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        state: TaskInstanceState,",
            "        upstream: bool = False,",
            "        downstream: bool = False,",
            "        future: bool = False,",
            "        past: bool = False,",
            "        commit: bool = True,",
            "        session=NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"",
            "        Set the state of a TaskInstance to the given state, and clear its downstream tasks that are",
            "        in failed or upstream_failed state.",
            "",
            "        :param task_id: Task ID of the TaskInstance",
            "        :param map_indexes: Only set TaskInstance if its map_index matches.",
            "            If None (default), all mapped TaskInstances of the task are set.",
            "        :param execution_date: Execution date of the TaskInstance",
            "        :param run_id: The run_id of the TaskInstance",
            "        :param state: State to set the TaskInstance to",
            "        :param upstream: Include all upstream tasks of the given task_id",
            "        :param downstream: Include all downstream tasks of the given task_id",
            "        :param future: Include all future TaskInstances of the given task_id",
            "        :param commit: Commit changes",
            "        :param past: Include all past TaskInstances of the given task_id",
            "        \"\"\"",
            "        from airflow.api.common.mark_tasks import set_state",
            "",
            "        if not exactly_one(execution_date, run_id):",
            "            raise ValueError(\"Exactly one of execution_date or run_id must be provided\")",
            "",
            "        task = self.get_task(task_id)",
            "        task.dag = self",
            "",
            "        tasks_to_set_state: list[Operator | tuple[Operator, int]]",
            "        if map_indexes is None:",
            "            tasks_to_set_state = [task]",
            "        else:",
            "            tasks_to_set_state = [(task, map_index) for map_index in map_indexes]",
            "",
            "        altered = set_state(",
            "            tasks=tasks_to_set_state,",
            "            execution_date=execution_date,",
            "            run_id=run_id,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "            state=state,",
            "            commit=commit,",
            "            session=session,",
            "        )",
            "",
            "        if not commit:",
            "            return altered",
            "",
            "        # Clear downstream tasks that are in failed/upstream_failed state to resume them.",
            "        # Flush the session so that the tasks marked success are reflected in the db.",
            "        session.flush()",
            "        subdag = self.partial_subset(",
            "            task_ids_or_regex={task_id},",
            "            include_downstream=True,",
            "            include_upstream=False,",
            "        )",
            "",
            "        if execution_date is None:",
            "            dag_run = session.scalars(",
            "                select(DagRun).where(DagRun.run_id == run_id, DagRun.dag_id == self.dag_id)",
            "            ).one()  # Raises an error if not found",
            "            resolve_execution_date = dag_run.execution_date",
            "        else:",
            "            resolve_execution_date = execution_date",
            "",
            "        end_date = resolve_execution_date if not future else None",
            "        start_date = resolve_execution_date if not past else None",
            "",
            "        subdag.clear(",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            include_subdags=True,",
            "            include_parentdag=True,",
            "            only_failed=True,",
            "            session=session,",
            "            # Exclude the task itself from being cleared",
            "            exclude_task_ids=frozenset({task_id}),",
            "        )",
            "",
            "        return altered",
            "",
            "    @provide_session",
            "    def set_task_group_state(",
            "        self,",
            "        *,",
            "        group_id: str,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        state: TaskInstanceState,",
            "        upstream: bool = False,",
            "        downstream: bool = False,",
            "        future: bool = False,",
            "        past: bool = False,",
            "        commit: bool = True,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TaskInstance]:",
            "        \"\"\"",
            "        Set the state of the TaskGroup to the given state, and clear its downstream tasks that are",
            "        in failed or upstream_failed state.",
            "",
            "        :param group_id: The group_id of the TaskGroup",
            "        :param execution_date: Execution date of the TaskInstance",
            "        :param run_id: The run_id of the TaskInstance",
            "        :param state: State to set the TaskInstance to",
            "        :param upstream: Include all upstream tasks of the given task_id",
            "        :param downstream: Include all downstream tasks of the given task_id",
            "        :param future: Include all future TaskInstances of the given task_id",
            "        :param commit: Commit changes",
            "        :param past: Include all past TaskInstances of the given task_id",
            "        :param session: new session",
            "        \"\"\"",
            "        from airflow.api.common.mark_tasks import set_state",
            "",
            "        if not exactly_one(execution_date, run_id):",
            "            raise ValueError(\"Exactly one of execution_date or run_id must be provided\")",
            "",
            "        tasks_to_set_state: list[BaseOperator | tuple[BaseOperator, int]] = []",
            "        task_ids: list[str] = []",
            "",
            "        if execution_date is None:",
            "            dag_run = session.scalars(",
            "                select(DagRun).where(DagRun.run_id == run_id, DagRun.dag_id == self.dag_id)",
            "            ).one()  # Raises an error if not found",
            "            resolve_execution_date = dag_run.execution_date",
            "        else:",
            "            resolve_execution_date = execution_date",
            "",
            "        end_date = resolve_execution_date if not future else None",
            "        start_date = resolve_execution_date if not past else None",
            "",
            "        task_group_dict = self.task_group.get_task_group_dict()",
            "        task_group = task_group_dict.get(group_id)",
            "        if task_group is None:",
            "            raise ValueError(\"TaskGroup {group_id} could not be found\")",
            "        tasks_to_set_state = [task for task in task_group.iter_tasks() if isinstance(task, BaseOperator)]",
            "        task_ids = [task.task_id for task in task_group.iter_tasks()]",
            "",
            "        dag_runs_query = session.query(DagRun.id).where(DagRun.dag_id == self.dag_id)",
            "        if start_date is None and end_date is None:",
            "            dag_runs_query = dag_runs_query.where(DagRun.execution_date == start_date)",
            "        else:",
            "            if start_date is not None:",
            "                dag_runs_query = dag_runs_query.where(DagRun.execution_date >= start_date)",
            "            if end_date is not None:",
            "                dag_runs_query = dag_runs_query.where(DagRun.execution_date <= end_date)",
            "",
            "        with lock_rows(dag_runs_query, session):",
            "            altered = set_state(",
            "                tasks=tasks_to_set_state,",
            "                execution_date=execution_date,",
            "                run_id=run_id,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=state,",
            "                commit=commit,",
            "                session=session,",
            "            )",
            "            if not commit:",
            "                return altered",
            "",
            "            # Clear downstream tasks that are in failed/upstream_failed state to resume them.",
            "            # Flush the session so that the tasks marked success are reflected in the db.",
            "            session.flush()",
            "            task_subset = self.partial_subset(",
            "                task_ids_or_regex=task_ids,",
            "                include_downstream=True,",
            "                include_upstream=False,",
            "            )",
            "",
            "            task_subset.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                include_subdags=True,",
            "                include_parentdag=True,",
            "                only_failed=True,",
            "                session=session,",
            "                # Exclude the task from the current group from being cleared",
            "                exclude_task_ids=frozenset(task_ids),",
            "            )",
            "",
            "        return altered",
            "",
            "    @property",
            "    def roots(self) -> list[Operator]:",
            "        \"\"\"Return nodes with no parents. These are first to execute and are called roots or root nodes.\"\"\"",
            "        return [task for task in self.tasks if not task.upstream_list]",
            "",
            "    @property",
            "    def leaves(self) -> list[Operator]:",
            "        \"\"\"Return nodes with no children. These are last to execute and are called leaves or leaf nodes.\"\"\"",
            "        return [task for task in self.tasks if not task.downstream_list]",
            "",
            "    def topological_sort(self, include_subdag_tasks: bool = False):",
            "        \"\"\"",
            "        Sorts tasks in topographical order, such that a task comes after any of its",
            "        upstream dependencies.",
            "",
            "        Deprecated in place of ``task_group.topological_sort``",
            "        \"\"\"",
            "        from airflow.utils.task_group import TaskGroup",
            "",
            "        def nested_topo(group):",
            "            for node in group.topological_sort(_include_subdag_tasks=include_subdag_tasks):",
            "                if isinstance(node, TaskGroup):",
            "                    yield from nested_topo(node)",
            "                else:",
            "                    yield node",
            "",
            "        return tuple(nested_topo(self.task_group))",
            "",
            "    @provide_session",
            "    def set_dag_runs_state(",
            "        self,",
            "        state: str = State.RUNNING,",
            "        session: Session = NEW_SESSION,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        dag_ids: list[str] = [],",
            "    ) -> None:",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=3,",
            "        )",
            "        dag_ids = dag_ids or [self.dag_id]",
            "        query = update(DagRun).where(DagRun.dag_id.in_(dag_ids))",
            "        if start_date:",
            "            query = query.where(DagRun.execution_date >= start_date)",
            "        if end_date:",
            "            query = query.where(DagRun.execution_date <= end_date)",
            "        session.execute(query.values(state=state).execution_options(synchronize_session=\"fetch\"))",
            "",
            "    @provide_session",
            "    def clear(",
            "        self,",
            "        task_ids: Collection[str | tuple[str, int]] | None = None,",
            "        start_date: datetime | None = None,",
            "        end_date: datetime | None = None,",
            "        only_failed: bool = False,",
            "        only_running: bool = False,",
            "        confirm_prompt: bool = False,",
            "        include_subdags: bool = True,",
            "        include_parentdag: bool = True,",
            "        dag_run_state: DagRunState = DagRunState.QUEUED,",
            "        dry_run: bool = False,",
            "        session: Session = NEW_SESSION,",
            "        get_tis: bool = False,",
            "        recursion_depth: int = 0,",
            "        max_recursion_depth: int | None = None,",
            "        dag_bag: DagBag | None = None,",
            "        exclude_task_ids: frozenset[str] | frozenset[tuple[str, int]] | None = frozenset(),",
            "    ) -> int | Iterable[TaskInstance]:",
            "        \"\"\"",
            "        Clears a set of task instances associated with the current dag for",
            "        a specified date range.",
            "",
            "        :param task_ids: List of task ids or (``task_id``, ``map_index``) tuples to clear",
            "        :param start_date: The minimum execution_date to clear",
            "        :param end_date: The maximum execution_date to clear",
            "        :param only_failed: Only clear failed tasks",
            "        :param only_running: Only clear running tasks.",
            "        :param confirm_prompt: Ask for confirmation",
            "        :param include_subdags: Clear tasks in subdags and clear external tasks",
            "            indicated by ExternalTaskMarker",
            "        :param include_parentdag: Clear tasks in the parent dag of the subdag.",
            "        :param dag_run_state: state to set DagRun to. If set to False, dagrun state will not",
            "            be changed.",
            "        :param dry_run: Find the tasks to clear but don't clear them.",
            "        :param session: The sqlalchemy session to use",
            "        :param dag_bag: The DagBag used to find the dags subdags (Optional)",
            "        :param exclude_task_ids: A set of ``task_id`` or (``task_id``, ``map_index``)",
            "            tuples that should not be cleared",
            "        \"\"\"",
            "        if get_tis:",
            "            warnings.warn(",
            "                \"Passing `get_tis` to dag.clear() is deprecated. Use `dry_run` parameter instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            dry_run = True",
            "",
            "        if recursion_depth:",
            "            warnings.warn(",
            "                \"Passing `recursion_depth` to dag.clear() is deprecated.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "        if max_recursion_depth:",
            "            warnings.warn(",
            "                \"Passing `max_recursion_depth` to dag.clear() is deprecated.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        state = []",
            "        if only_failed:",
            "            state += [State.FAILED, State.UPSTREAM_FAILED]",
            "        if only_running:",
            "            # Yes, having `+=` doesn't make sense, but this was the existing behaviour",
            "            state += [State.RUNNING]",
            "",
            "        tis = self._get_task_instances(",
            "            task_ids=task_ids,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            run_id=None,",
            "            state=state,",
            "            include_subdags=include_subdags,",
            "            include_parentdag=include_parentdag,",
            "            include_dependent_dags=include_subdags,  # compat, yes this is not a typo",
            "            session=session,",
            "            dag_bag=dag_bag,",
            "            exclude_task_ids=exclude_task_ids,",
            "        )",
            "",
            "        if dry_run:",
            "            return session.scalars(tis).all()",
            "",
            "        tis = session.scalars(tis).all()",
            "",
            "        count = len(list(tis))",
            "        do_it = True",
            "        if count == 0:",
            "            return 0",
            "        if confirm_prompt:",
            "            ti_list = \"\\n\".join(str(t) for t in tis)",
            "            question = (",
            "                \"You are about to delete these {count} tasks:\\n{ti_list}\\n\\nAre you sure? [y/n]\"",
            "            ).format(count=count, ti_list=ti_list)",
            "            do_it = utils.helpers.ask_yesno(question)",
            "",
            "        if do_it:",
            "            clear_task_instances(",
            "                list(tis),",
            "                session,",
            "                dag=self,",
            "                dag_run_state=dag_run_state,",
            "            )",
            "        else:",
            "            count = 0",
            "            print(\"Cancelled, nothing was cleared.\")",
            "",
            "        session.flush()",
            "        return count",
            "",
            "    @classmethod",
            "    def clear_dags(",
            "        cls,",
            "        dags,",
            "        start_date=None,",
            "        end_date=None,",
            "        only_failed=False,",
            "        only_running=False,",
            "        confirm_prompt=False,",
            "        include_subdags=True,",
            "        include_parentdag=False,",
            "        dag_run_state=DagRunState.QUEUED,",
            "        dry_run=False,",
            "    ):",
            "        all_tis = []",
            "        for dag in dags:",
            "            tis = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                only_failed=only_failed,",
            "                only_running=only_running,",
            "                confirm_prompt=False,",
            "                include_subdags=include_subdags,",
            "                include_parentdag=include_parentdag,",
            "                dag_run_state=dag_run_state,",
            "                dry_run=True,",
            "            )",
            "            all_tis.extend(tis)",
            "",
            "        if dry_run:",
            "            return all_tis",
            "",
            "        count = len(all_tis)",
            "        do_it = True",
            "        if count == 0:",
            "            print(\"Nothing to clear.\")",
            "            return 0",
            "        if confirm_prompt:",
            "            ti_list = \"\\n\".join(str(t) for t in all_tis)",
            "            question = f\"You are about to delete these {count} tasks:\\n{ti_list}\\n\\nAre you sure? [y/n]\"",
            "            do_it = utils.helpers.ask_yesno(question)",
            "",
            "        if do_it:",
            "            for dag in dags:",
            "                dag.clear(",
            "                    start_date=start_date,",
            "                    end_date=end_date,",
            "                    only_failed=only_failed,",
            "                    only_running=only_running,",
            "                    confirm_prompt=False,",
            "                    include_subdags=include_subdags,",
            "                    dag_run_state=dag_run_state,",
            "                    dry_run=False,",
            "                )",
            "        else:",
            "            count = 0",
            "            print(\"Cancelled, nothing was cleared.\")",
            "        return count",
            "",
            "    def __deepcopy__(self, memo):",
            "        # Switcharoo to go around deepcopying objects coming through the",
            "        # backdoor",
            "        cls = self.__class__",
            "        result = cls.__new__(cls)",
            "        memo[id(self)] = result",
            "        for k, v in self.__dict__.items():",
            "            if k not in (\"user_defined_macros\", \"user_defined_filters\", \"_log\"):",
            "                setattr(result, k, copy.deepcopy(v, memo))",
            "",
            "        result.user_defined_macros = self.user_defined_macros",
            "        result.user_defined_filters = self.user_defined_filters",
            "        if hasattr(self, \"_log\"):",
            "            result._log = self._log",
            "        return result",
            "",
            "    def sub_dag(self, *args, **kwargs):",
            "        \"\"\"This method is deprecated in favor of partial_subset.\"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version. Please use partial_subset\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.partial_subset(*args, **kwargs)",
            "",
            "    def partial_subset(",
            "        self,",
            "        task_ids_or_regex: str | Pattern | Iterable[str],",
            "        include_downstream=False,",
            "        include_upstream=True,",
            "        include_direct_upstream=False,",
            "    ):",
            "        \"\"\"",
            "        Returns a subset of the current dag as a deep copy of the current dag",
            "        based on a regex that should match one or many tasks, and includes",
            "        upstream and downstream neighbours based on the flag passed.",
            "",
            "        :param task_ids_or_regex: Either a list of task_ids, or a regex to",
            "            match against task ids (as a string, or compiled regex pattern).",
            "        :param include_downstream: Include all downstream tasks of matched",
            "            tasks, in addition to matched tasks.",
            "        :param include_upstream: Include all upstream tasks of matched tasks,",
            "            in addition to matched tasks.",
            "        :param include_direct_upstream: Include all tasks directly upstream of matched",
            "            and downstream (if include_downstream = True) tasks",
            "        \"\"\"",
            "        from airflow.models.baseoperator import BaseOperator",
            "        from airflow.models.mappedoperator import MappedOperator",
            "",
            "        # deep-copying self.task_dict and self._task_group takes a long time, and we don't want all",
            "        # the tasks anyway, so we copy the tasks manually later",
            "        memo = {id(self.task_dict): None, id(self._task_group): None}",
            "        dag = copy.deepcopy(self, memo)  # type: ignore",
            "",
            "        if isinstance(task_ids_or_regex, (str, Pattern)):",
            "            matched_tasks = [t for t in self.tasks if re.findall(task_ids_or_regex, t.task_id)]",
            "        else:",
            "            matched_tasks = [t for t in self.tasks if t.task_id in task_ids_or_regex]",
            "",
            "        also_include: list[Operator] = []",
            "        for t in matched_tasks:",
            "            if include_downstream:",
            "                also_include.extend(t.get_flat_relatives(upstream=False))",
            "            if include_upstream:",
            "                also_include.extend(t.get_upstreams_follow_setups())",
            "            else:",
            "                also_include.extend(t.get_upstreams_only_setups_and_teardowns())",
            "",
            "        direct_upstreams: list[Operator] = []",
            "        if include_direct_upstream:",
            "            for t in itertools.chain(matched_tasks, also_include):",
            "                upstream = (u for u in t.upstream_list if isinstance(u, (BaseOperator, MappedOperator)))",
            "                direct_upstreams.extend(upstream)",
            "",
            "        # Compiling the unique list of tasks that made the cut",
            "        # Make sure to not recursively deepcopy the dag or task_group while copying the task.",
            "        # task_group is reset later",
            "        def _deepcopy_task(t) -> Operator:",
            "            memo.setdefault(id(t.task_group), None)",
            "            return copy.deepcopy(t, memo)",
            "",
            "        dag.task_dict = {",
            "            t.task_id: _deepcopy_task(t)",
            "            for t in itertools.chain(matched_tasks, also_include, direct_upstreams)",
            "        }",
            "",
            "        def filter_task_group(group, parent_group):",
            "            \"\"\"Exclude tasks not included in the subdag from the given TaskGroup.\"\"\"",
            "            # We want to deepcopy _most but not all_ attributes of the task group, so we create a shallow copy",
            "            # and then manually deep copy the instances. (memo argument to deepcopy only works for instances",
            "            # of classes, not \"native\" properties of an instance)",
            "            copied = copy.copy(group)",
            "",
            "            memo[id(group.children)] = {}",
            "            if parent_group:",
            "                memo[id(group.parent_group)] = parent_group",
            "            for attr, value in copied.__dict__.items():",
            "                if id(value) in memo:",
            "                    value = memo[id(value)]",
            "                else:",
            "                    value = copy.deepcopy(value, memo)",
            "                copied.__dict__[attr] = value",
            "",
            "            proxy = weakref.proxy(copied)",
            "",
            "            for child in group.children.values():",
            "                if isinstance(child, AbstractOperator):",
            "                    if child.task_id in dag.task_dict:",
            "                        task = copied.children[child.task_id] = dag.task_dict[child.task_id]",
            "                        task.task_group = proxy",
            "                    else:",
            "                        copied.used_group_ids.discard(child.task_id)",
            "                else:",
            "                    filtered_child = filter_task_group(child, proxy)",
            "",
            "                    # Only include this child TaskGroup if it is non-empty.",
            "                    if filtered_child.children:",
            "                        copied.children[child.group_id] = filtered_child",
            "",
            "            return copied",
            "",
            "        dag._task_group = filter_task_group(self.task_group, None)",
            "",
            "        # Removing upstream/downstream references to tasks and TaskGroups that did not make",
            "        # the cut.",
            "        subdag_task_groups = dag.task_group.get_task_group_dict()",
            "        for group in subdag_task_groups.values():",
            "            group.upstream_group_ids.intersection_update(subdag_task_groups)",
            "            group.downstream_group_ids.intersection_update(subdag_task_groups)",
            "            group.upstream_task_ids.intersection_update(dag.task_dict)",
            "            group.downstream_task_ids.intersection_update(dag.task_dict)",
            "",
            "        for t in dag.tasks:",
            "            # Removing upstream/downstream references to tasks that did not",
            "            # make the cut",
            "            t.upstream_task_ids.intersection_update(dag.task_dict)",
            "            t.downstream_task_ids.intersection_update(dag.task_dict)",
            "",
            "        if len(dag.tasks) < len(self.tasks):",
            "            dag.partial = True",
            "",
            "        return dag",
            "",
            "    def has_task(self, task_id: str):",
            "        return task_id in self.task_dict",
            "",
            "    def has_task_group(self, task_group_id: str) -> bool:",
            "        return task_group_id in self.task_group_dict",
            "",
            "    @functools.cached_property",
            "    def task_group_dict(self):",
            "        return {k: v for k, v in self._task_group.get_task_group_dict().items() if k is not None}",
            "",
            "    def get_task(self, task_id: str, include_subdags: bool = False) -> Operator:",
            "        if task_id in self.task_dict:",
            "            return self.task_dict[task_id]",
            "        if include_subdags:",
            "            for dag in self.subdags:",
            "                if task_id in dag.task_dict:",
            "                    return dag.task_dict[task_id]",
            "        raise TaskNotFound(f\"Task {task_id} not found\")",
            "",
            "    def pickle_info(self):",
            "        d = {}",
            "        d[\"is_picklable\"] = True",
            "        try:",
            "            dttm = timezone.utcnow()",
            "            pickled = pickle.dumps(self)",
            "            d[\"pickle_len\"] = len(pickled)",
            "            d[\"pickling_duration\"] = str(timezone.utcnow() - dttm)",
            "        except Exception as e:",
            "            self.log.debug(e)",
            "            d[\"is_picklable\"] = False",
            "            d[\"stacktrace\"] = traceback.format_exc()",
            "        return d",
            "",
            "    @provide_session",
            "    def pickle(self, session=NEW_SESSION) -> DagPickle:",
            "        dag = session.scalar(select(DagModel).where(DagModel.dag_id == self.dag_id).limit(1))",
            "        dp = None",
            "        if dag and dag.pickle_id:",
            "            dp = session.scalar(select(DagPickle).where(DagPickle.id == dag.pickle_id).limit(1))",
            "        if not dp or dp.pickle != self:",
            "            dp = DagPickle(dag=self)",
            "            session.add(dp)",
            "            self.last_pickled = timezone.utcnow()",
            "            session.commit()",
            "            self.pickle_id = dp.id",
            "",
            "        return dp",
            "",
            "    def tree_view(self) -> None:",
            "        \"\"\"Print an ASCII tree representation of the DAG.\"\"\"",
            "",
            "        def get_downstream(task, level=0):",
            "            print((\" \" * level * 4) + str(task))",
            "            level += 1",
            "            for t in task.downstream_list:",
            "                get_downstream(t, level)",
            "",
            "        for t in self.roots:",
            "            get_downstream(t)",
            "",
            "    @property",
            "    def task(self) -> TaskDecoratorCollection:",
            "        from airflow.decorators import task",
            "",
            "        return cast(\"TaskDecoratorCollection\", functools.partial(task, dag=self))",
            "",
            "    def add_task(self, task: Operator) -> None:",
            "        \"\"\"",
            "        Add a task to the DAG.",
            "",
            "        :param task: the task you want to add",
            "        \"\"\"",
            "        DagInvalidTriggerRule.check(self, task.trigger_rule)",
            "",
            "        from airflow.utils.task_group import TaskGroupContext",
            "",
            "        if not self.start_date and not task.start_date:",
            "            raise AirflowException(\"DAG is missing the start_date parameter\")",
            "        # if the task has no start date, assign it the same as the DAG",
            "        elif not task.start_date:",
            "            task.start_date = self.start_date",
            "        # otherwise, the task will start on the later of its own start date and",
            "        # the DAG's start date",
            "        elif self.start_date:",
            "            task.start_date = max(task.start_date, self.start_date)",
            "",
            "        # if the task has no end date, assign it the same as the dag",
            "        if not task.end_date:",
            "            task.end_date = self.end_date",
            "        # otherwise, the task will end on the earlier of its own end date and",
            "        # the DAG's end date",
            "        elif task.end_date and self.end_date:",
            "            task.end_date = min(task.end_date, self.end_date)",
            "",
            "        task_id = task.task_id",
            "        if not task.task_group:",
            "            task_group = TaskGroupContext.get_current_task_group(self)",
            "            if task_group:",
            "                task_id = task_group.child_id(task_id)",
            "                task_group.add(task)",
            "",
            "        if (",
            "            task_id in self.task_dict and self.task_dict[task_id] is not task",
            "        ) or task_id in self._task_group.used_group_ids:",
            "            raise DuplicateTaskIdFound(f\"Task id '{task_id}' has already been added to the DAG\")",
            "        else:",
            "            self.task_dict[task_id] = task",
            "            task.dag = self",
            "            # Add task_id to used_group_ids to prevent group_id and task_id collisions.",
            "            self._task_group.used_group_ids.add(task_id)",
            "",
            "        self.task_count = len(self.task_dict)",
            "",
            "    def add_tasks(self, tasks: Iterable[Operator]) -> None:",
            "        \"\"\"",
            "        Add a list of tasks to the DAG.",
            "",
            "        :param tasks: a lit of tasks you want to add",
            "        \"\"\"",
            "        for task in tasks:",
            "            self.add_task(task)",
            "",
            "    def _remove_task(self, task_id: str) -> None:",
            "        # This is \"private\" as removing could leave a hole in dependencies if done incorrectly, and this",
            "        # doesn't guard against that",
            "        task = self.task_dict.pop(task_id)",
            "        tg = getattr(task, \"task_group\", None)",
            "        if tg:",
            "            tg._remove(task)",
            "",
            "        self.task_count = len(self.task_dict)",
            "",
            "    def run(",
            "        self,",
            "        start_date=None,",
            "        end_date=None,",
            "        mark_success=False,",
            "        local=False,",
            "        executor=None,",
            "        donot_pickle=airflow_conf.getboolean(\"core\", \"donot_pickle\"),",
            "        ignore_task_deps=False,",
            "        ignore_first_depends_on_past=True,",
            "        pool=None,",
            "        delay_on_limit_secs=1.0,",
            "        verbose=False,",
            "        conf=None,",
            "        rerun_failed_tasks=False,",
            "        run_backwards=False,",
            "        run_at_least_once=False,",
            "        continue_on_failures=False,",
            "        disable_retry=False,",
            "    ):",
            "        \"\"\"",
            "        Runs the DAG.",
            "",
            "        :param start_date: the start date of the range to run",
            "        :param end_date: the end date of the range to run",
            "        :param mark_success: True to mark jobs as succeeded without running them",
            "        :param local: True to run the tasks using the LocalExecutor",
            "        :param executor: The executor instance to run the tasks",
            "        :param donot_pickle: True to avoid pickling DAG object and send to workers",
            "        :param ignore_task_deps: True to skip upstream tasks",
            "        :param ignore_first_depends_on_past: True to ignore depends_on_past",
            "            dependencies for the first set of tasks only",
            "        :param pool: Resource pool to use",
            "        :param delay_on_limit_secs: Time in seconds to wait before next attempt to run",
            "            dag run when max_active_runs limit has been reached",
            "        :param verbose: Make logging output more verbose",
            "        :param conf: user defined dictionary passed from CLI",
            "        :param rerun_failed_tasks:",
            "        :param run_backwards:",
            "        :param run_at_least_once: If true, always run the DAG at least once even",
            "            if no logical run exists within the time range.",
            "        \"\"\"",
            "        from airflow.jobs.backfill_job_runner import BackfillJobRunner",
            "",
            "        if not executor and local:",
            "            from airflow.executors.local_executor import LocalExecutor",
            "",
            "            executor = LocalExecutor()",
            "        elif not executor:",
            "            from airflow.executors.executor_loader import ExecutorLoader",
            "",
            "            executor = ExecutorLoader.get_default_executor()",
            "        from airflow.jobs.job import Job",
            "",
            "        job = Job(executor=executor)",
            "        job_runner = BackfillJobRunner(",
            "            job=job,",
            "            dag=self,",
            "            start_date=start_date,",
            "            end_date=end_date,",
            "            mark_success=mark_success,",
            "            donot_pickle=donot_pickle,",
            "            ignore_task_deps=ignore_task_deps,",
            "            ignore_first_depends_on_past=ignore_first_depends_on_past,",
            "            pool=pool,",
            "            delay_on_limit_secs=delay_on_limit_secs,",
            "            verbose=verbose,",
            "            conf=conf,",
            "            rerun_failed_tasks=rerun_failed_tasks,",
            "            run_backwards=run_backwards,",
            "            run_at_least_once=run_at_least_once,",
            "            continue_on_failures=continue_on_failures,",
            "            disable_retry=disable_retry,",
            "        )",
            "        run_job(job=job, execute_callable=job_runner._execute)",
            "",
            "    def cli(self):",
            "        \"\"\"Exposes a CLI specific to this DAG.\"\"\"",
            "        check_cycle(self)",
            "",
            "        from airflow.cli import cli_parser",
            "",
            "        parser = cli_parser.get_parser(dag_parser=True)",
            "        args = parser.parse_args()",
            "        args.func(args, self)",
            "",
            "    @provide_session",
            "    def test(",
            "        self,",
            "        execution_date: datetime | None = None,",
            "        run_conf: dict[str, Any] | None = None,",
            "        conn_file_path: str | None = None,",
            "        variable_file_path: str | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"",
            "        Execute one single DagRun for a given DAG and execution date.",
            "",
            "        :param execution_date: execution date for the DAG run",
            "        :param run_conf: configuration to pass to newly created dagrun",
            "        :param conn_file_path: file path to a connection file in either yaml or json",
            "        :param variable_file_path: file path to a variable file in either yaml or json",
            "        :param session: database connection (optional)",
            "        \"\"\"",
            "",
            "        def add_logger_if_needed(ti: TaskInstance):",
            "            \"\"\"Add a formatted logger to the task instance.",
            "",
            "            This allows all logs to surface to the command line, instead of into",
            "            a task file. Since this is a local test run, it is much better for",
            "            the user to see logs in the command line, rather than needing to",
            "            search for a log file.",
            "",
            "            :param ti: The task instance that will receive a logger.",
            "            \"\"\"",
            "            format = logging.Formatter(\"[%(asctime)s] {%(filename)s:%(lineno)d} %(levelname)s - %(message)s\")",
            "            handler = logging.StreamHandler(sys.stdout)",
            "            handler.level = logging.INFO",
            "            handler.setFormatter(format)",
            "            # only add log handler once",
            "            if not any(isinstance(h, logging.StreamHandler) for h in ti.log.handlers):",
            "                self.log.debug(\"Adding Streamhandler to taskinstance %s\", ti.task_id)",
            "                ti.log.addHandler(handler)",
            "",
            "        if conn_file_path or variable_file_path:",
            "            local_secrets = LocalFilesystemBackend(",
            "                variables_file_path=variable_file_path, connections_file_path=conn_file_path",
            "            )",
            "            secrets_backend_list.insert(0, local_secrets)",
            "",
            "        execution_date = execution_date or timezone.utcnow()",
            "        self.log.debug(\"Clearing existing task instances for execution date %s\", execution_date)",
            "        self.clear(",
            "            start_date=execution_date,",
            "            end_date=execution_date,",
            "            dag_run_state=False,  # type: ignore",
            "            session=session,",
            "        )",
            "        self.log.debug(\"Getting dagrun for dag %s\", self.dag_id)",
            "        dr: DagRun = _get_or_create_dagrun(",
            "            dag=self,",
            "            start_date=execution_date,",
            "            execution_date=execution_date,",
            "            run_id=DagRun.generate_run_id(DagRunType.MANUAL, execution_date),",
            "            session=session,",
            "            conf=run_conf,",
            "        )",
            "",
            "        tasks = self.task_dict",
            "        self.log.debug(\"starting dagrun\")",
            "        # Instead of starting a scheduler, we run the minimal loop possible to check",
            "        # for task readiness and dependency management. This is notably faster",
            "        # than creating a BackfillJob and allows us to surface logs to the user",
            "        while dr.state == State.RUNNING:",
            "            schedulable_tis, _ = dr.update_state(session=session)",
            "            try:",
            "                for ti in schedulable_tis:",
            "                    add_logger_if_needed(ti)",
            "                    ti.task = tasks[ti.task_id]",
            "                    _run_task(ti, session=session)",
            "            except Exception:",
            "                self.log.info(",
            "                    \"Task failed. DAG will continue to run until finished and be marked as failed.\",",
            "                    exc_info=True,",
            "                )",
            "        if conn_file_path or variable_file_path:",
            "            # Remove the local variables we have added to the secrets_backend_list",
            "            secrets_backend_list.pop(0)",
            "",
            "    @provide_session",
            "    def create_dagrun(",
            "        self,",
            "        state: DagRunState,",
            "        execution_date: datetime | None = None,",
            "        run_id: str | None = None,",
            "        start_date: datetime | None = None,",
            "        external_trigger: bool | None = False,",
            "        conf: dict | None = None,",
            "        run_type: DagRunType | None = None,",
            "        session: Session = NEW_SESSION,",
            "        dag_hash: str | None = None,",
            "        creating_job_id: int | None = None,",
            "        data_interval: tuple[datetime, datetime] | None = None,",
            "    ):",
            "        \"\"\"",
            "        Creates a dag run from this dag including the tasks associated with this dag.",
            "        Returns the dag run.",
            "",
            "        :param run_id: defines the run id for this dag run",
            "        :param run_type: type of DagRun",
            "        :param execution_date: the execution date of this dag run",
            "        :param state: the state of the dag run",
            "        :param start_date: the date this dag run should be evaluated",
            "        :param external_trigger: whether this dag run is externally triggered",
            "        :param conf: Dict containing configuration/parameters to pass to the DAG",
            "        :param creating_job_id: id of the job creating this DagRun",
            "        :param session: database session",
            "        :param dag_hash: Hash of Serialized DAG",
            "        :param data_interval: Data interval of the DagRun",
            "        \"\"\"",
            "        logical_date = timezone.coerce_datetime(execution_date)",
            "",
            "        if data_interval and not isinstance(data_interval, DataInterval):",
            "            data_interval = DataInterval(*map(timezone.coerce_datetime, data_interval))",
            "",
            "        if data_interval is None and logical_date is not None:",
            "            warnings.warn(",
            "                \"Calling `DAG.create_dagrun()` without an explicit data interval is deprecated\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=3,",
            "            )",
            "            if run_type == DagRunType.MANUAL:",
            "                data_interval = self.timetable.infer_manual_data_interval(run_after=logical_date)",
            "            else:",
            "                data_interval = self.infer_automated_data_interval(logical_date)",
            "",
            "        if run_type is None or isinstance(run_type, DagRunType):",
            "            pass",
            "        elif isinstance(run_type, str):  # Compatibility: run_type used to be a str.",
            "            run_type = DagRunType(run_type)",
            "        else:",
            "            raise ValueError(f\"`run_type` should be a DagRunType, not {type(run_type)}\")",
            "",
            "        if run_id:  # Infer run_type from run_id if needed.",
            "            if not isinstance(run_id, str):",
            "                raise ValueError(f\"`run_id` should be a str, not {type(run_id)}\")",
            "            inferred_run_type = DagRunType.from_run_id(run_id)",
            "            if run_type is None:",
            "                # No explicit type given, use the inferred type.",
            "                run_type = inferred_run_type",
            "            elif run_type == DagRunType.MANUAL and inferred_run_type != DagRunType.MANUAL:",
            "                # Prevent a manual run from using an ID that looks like a scheduled run.",
            "                raise ValueError(",
            "                    f\"A {run_type.value} DAG run cannot use ID {run_id!r} since it \"",
            "                    f\"is reserved for {inferred_run_type.value} runs\"",
            "                )",
            "        elif run_type and logical_date is not None:  # Generate run_id from run_type and execution_date.",
            "            run_id = self.timetable.generate_run_id(",
            "                run_type=run_type, logical_date=logical_date, data_interval=data_interval",
            "            )",
            "        else:",
            "            raise AirflowException(",
            "                \"Creating DagRun needs either `run_id` or both `run_type` and `execution_date`\"",
            "            )",
            "",
            "        regex = airflow_conf.get(\"scheduler\", \"allowed_run_id_pattern\")",
            "",
            "        if run_id and not re.match(RUN_ID_REGEX, run_id):",
            "            if not regex.strip() or not re.match(regex.strip(), run_id):",
            "                raise AirflowException(",
            "                    f\"The provided run ID '{run_id}' is invalid. It does not match either \"",
            "                    f\"the configured pattern: '{regex}' or the built-in pattern: '{RUN_ID_REGEX}'\"",
            "                )",
            "",
            "        # create a copy of params before validating",
            "        copied_params = copy.deepcopy(self.params)",
            "        copied_params.update(conf or {})",
            "        copied_params.validate()",
            "",
            "        run = DagRun(",
            "            dag_id=self.dag_id,",
            "            run_id=run_id,",
            "            execution_date=logical_date,",
            "            start_date=start_date,",
            "            external_trigger=external_trigger,",
            "            conf=conf,",
            "            state=state,",
            "            run_type=run_type,",
            "            dag_hash=dag_hash,",
            "            creating_job_id=creating_job_id,",
            "            data_interval=data_interval,",
            "        )",
            "        session.add(run)",
            "        session.flush()",
            "",
            "        run.dag = self",
            "",
            "        # create the associated task instances",
            "        # state is None at the moment of creation",
            "        run.verify_integrity(session=session)",
            "",
            "        return run",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_sync_to_db(",
            "        cls,",
            "        dags: Collection[DAG],",
            "        session=NEW_SESSION,",
            "    ):",
            "        \"\"\"This method is deprecated in favor of bulk_write_to_db.\"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated and will be removed in a future version. Please use bulk_write_to_db\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return cls.bulk_write_to_db(dags=dags, session=session)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_write_to_db(",
            "        cls,",
            "        dags: Collection[DAG],",
            "        processor_subdir: str | None = None,",
            "        session=NEW_SESSION,",
            "    ):",
            "        \"\"\"",
            "        Ensure the DagModel rows for the given dags are up-to-date in the dag table in the DB, including",
            "        calculated fields.",
            "",
            "        Note that this method can be called for both DAGs and SubDAGs. A SubDag is actually a SubDagOperator.",
            "",
            "        :param dags: the DAG objects to save to the DB",
            "        :return: None",
            "        \"\"\"",
            "        if not dags:",
            "            return",
            "",
            "        log.info(\"Sync %s DAGs\", len(dags))",
            "        dag_by_ids = {dag.dag_id: dag for dag in dags}",
            "",
            "        dag_ids = set(dag_by_ids.keys())",
            "        query = (",
            "            select(DagModel)",
            "            .options(joinedload(DagModel.tags, innerjoin=False))",
            "            .where(DagModel.dag_id.in_(dag_ids))",
            "            .options(joinedload(DagModel.schedule_dataset_references))",
            "            .options(joinedload(DagModel.task_outlet_dataset_references))",
            "        )",
            "        query = with_row_locks(query, of=DagModel, session=session)",
            "        orm_dags: list[DagModel] = session.scalars(query).unique().all()",
            "        existing_dags = {orm_dag.dag_id: orm_dag for orm_dag in orm_dags}",
            "        missing_dag_ids = dag_ids.difference(existing_dags)",
            "",
            "        for missing_dag_id in missing_dag_ids:",
            "            orm_dag = DagModel(dag_id=missing_dag_id)",
            "            dag = dag_by_ids[missing_dag_id]",
            "            if dag.is_paused_upon_creation is not None:",
            "                orm_dag.is_paused = dag.is_paused_upon_creation",
            "            orm_dag.tags = []",
            "            log.info(\"Creating ORM DAG for %s\", dag.dag_id)",
            "            session.add(orm_dag)",
            "            orm_dags.append(orm_dag)",
            "",
            "        # Get the latest dag run for each existing dag as a single query (avoid n+1 query)",
            "        most_recent_subq = (",
            "            select(DagRun.dag_id, func.max(DagRun.execution_date).label(\"max_execution_date\"))",
            "            .where(",
            "                DagRun.dag_id.in_(existing_dags),",
            "                or_(DagRun.run_type == DagRunType.BACKFILL_JOB, DagRun.run_type == DagRunType.SCHEDULED),",
            "            )",
            "            .group_by(DagRun.dag_id)",
            "            .subquery()",
            "        )",
            "        most_recent_runs_iter = session.scalars(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == most_recent_subq.c.dag_id,",
            "                DagRun.execution_date == most_recent_subq.c.max_execution_date,",
            "            )",
            "        )",
            "        most_recent_runs = {run.dag_id: run for run in most_recent_runs_iter}",
            "",
            "        # Get number of active dagruns for all dags we are processing as a single query.",
            "",
            "        num_active_runs = DagRun.active_runs_of_dags(dag_ids=existing_dags, session=session)",
            "",
            "        filelocs = []",
            "",
            "        for orm_dag in sorted(orm_dags, key=lambda d: d.dag_id):",
            "            dag = dag_by_ids[orm_dag.dag_id]",
            "            filelocs.append(dag.fileloc)",
            "            if dag.is_subdag:",
            "                orm_dag.is_subdag = True",
            "                orm_dag.fileloc = dag.parent_dag.fileloc  # type: ignore",
            "                orm_dag.root_dag_id = dag.parent_dag.dag_id  # type: ignore",
            "                orm_dag.owners = dag.parent_dag.owner  # type: ignore",
            "            else:",
            "                orm_dag.is_subdag = False",
            "                orm_dag.fileloc = dag.fileloc",
            "                orm_dag.owners = dag.owner",
            "            orm_dag.is_active = True",
            "            orm_dag.has_import_errors = False",
            "            orm_dag.last_parsed_time = timezone.utcnow()",
            "            orm_dag.default_view = dag.default_view",
            "            orm_dag.description = dag.description",
            "            orm_dag.max_active_tasks = dag.max_active_tasks",
            "            orm_dag.max_active_runs = dag.max_active_runs",
            "            orm_dag.has_task_concurrency_limits = any(",
            "                t.max_active_tis_per_dag is not None or t.max_active_tis_per_dagrun is not None",
            "                for t in dag.tasks",
            "            )",
            "            orm_dag.schedule_interval = dag.schedule_interval",
            "            orm_dag.timetable_description = dag.timetable.description",
            "            orm_dag.processor_subdir = processor_subdir",
            "",
            "            run: DagRun | None = most_recent_runs.get(dag.dag_id)",
            "            if run is None:",
            "                data_interval = None",
            "            else:",
            "                data_interval = dag.get_run_data_interval(run)",
            "            if num_active_runs.get(dag.dag_id, 0) >= orm_dag.max_active_runs:",
            "                orm_dag.next_dagrun_create_after = None",
            "            else:",
            "                orm_dag.calculate_dagrun_date_fields(dag, data_interval)",
            "",
            "            dag_tags = set(dag.tags or {})",
            "            orm_dag_tags = list(orm_dag.tags or [])",
            "            for orm_tag in orm_dag_tags:",
            "                if orm_tag.name not in dag_tags:",
            "                    session.delete(orm_tag)",
            "                    orm_dag.tags.remove(orm_tag)",
            "            orm_tag_names = {t.name for t in orm_dag_tags}",
            "            for dag_tag in dag_tags:",
            "                if dag_tag not in orm_tag_names:",
            "                    dag_tag_orm = DagTag(name=dag_tag, dag_id=dag.dag_id)",
            "                    orm_dag.tags.append(dag_tag_orm)",
            "                    session.add(dag_tag_orm)",
            "",
            "            orm_dag_links = orm_dag.dag_owner_links or []",
            "            for orm_dag_link in orm_dag_links:",
            "                if orm_dag_link not in dag.owner_links:",
            "                    session.delete(orm_dag_link)",
            "            for owner_name, owner_link in dag.owner_links.items():",
            "                dag_owner_orm = DagOwnerAttributes(dag_id=dag.dag_id, owner=owner_name, link=owner_link)",
            "                session.add(dag_owner_orm)",
            "",
            "        DagCode.bulk_sync_to_db(filelocs, session=session)",
            "",
            "        from airflow.datasets import Dataset",
            "        from airflow.models.dataset import (",
            "            DagScheduleDatasetReference,",
            "            DatasetModel,",
            "            TaskOutletDatasetReference,",
            "        )",
            "",
            "        dag_references = collections.defaultdict(set)",
            "        outlet_references = collections.defaultdict(set)",
            "        # We can't use a set here as we want to preserve order",
            "        outlet_datasets: dict[Dataset, None] = {}",
            "        input_datasets: dict[Dataset, None] = {}",
            "",
            "        # here we go through dags and tasks to check for dataset references",
            "        # if there are now None and previously there were some, we delete them",
            "        # if there are now *any*, we add them to the above data structures, and",
            "        # later we'll persist them to the database.",
            "        for dag in dags:",
            "            curr_orm_dag = existing_dags.get(dag.dag_id)",
            "            if not dag.dataset_triggers:",
            "                if curr_orm_dag and curr_orm_dag.schedule_dataset_references:",
            "                    curr_orm_dag.schedule_dataset_references = []",
            "            for dataset in dag.dataset_triggers:",
            "                dag_references[dag.dag_id].add(dataset.uri)",
            "                input_datasets[DatasetModel.from_public(dataset)] = None",
            "            curr_outlet_references = curr_orm_dag and curr_orm_dag.task_outlet_dataset_references",
            "            for task in dag.tasks:",
            "                dataset_outlets = [x for x in task.outlets or [] if isinstance(x, Dataset)]",
            "                if not dataset_outlets:",
            "                    if curr_outlet_references:",
            "                        this_task_outlet_refs = [",
            "                            x",
            "                            for x in curr_outlet_references",
            "                            if x.dag_id == dag.dag_id and x.task_id == task.task_id",
            "                        ]",
            "                        for ref in this_task_outlet_refs:",
            "                            curr_outlet_references.remove(ref)",
            "                for d in dataset_outlets:",
            "                    outlet_references[(task.dag_id, task.task_id)].add(d.uri)",
            "                    outlet_datasets[DatasetModel.from_public(d)] = None",
            "        all_datasets = outlet_datasets",
            "        all_datasets.update(input_datasets)",
            "",
            "        # store datasets",
            "        stored_datasets = {}",
            "        for dataset in all_datasets:",
            "            stored_dataset = session.scalar(",
            "                select(DatasetModel).where(DatasetModel.uri == dataset.uri).limit(1)",
            "            )",
            "            if stored_dataset:",
            "                # Some datasets may have been previously unreferenced, and therefore orphaned by the",
            "                # scheduler. But if we're here, then we have found that dataset again in our DAGs, which",
            "                # means that it is no longer an orphan, so set is_orphaned to False.",
            "                stored_dataset.is_orphaned = expression.false()",
            "                stored_datasets[stored_dataset.uri] = stored_dataset",
            "            else:",
            "                session.add(dataset)",
            "                stored_datasets[dataset.uri] = dataset",
            "",
            "        session.flush()  # this is required to ensure each dataset has its PK loaded",
            "",
            "        del all_datasets",
            "",
            "        # reconcile dag-schedule-on-dataset references",
            "        for dag_id, uri_list in dag_references.items():",
            "            dag_refs_needed = {",
            "                DagScheduleDatasetReference(dataset_id=stored_datasets[uri].id, dag_id=dag_id)",
            "                for uri in uri_list",
            "            }",
            "            dag_refs_stored = set(",
            "                existing_dags.get(dag_id)",
            "                and existing_dags.get(dag_id).schedule_dataset_references  # type: ignore",
            "                or []",
            "            )",
            "            dag_refs_to_add = {x for x in dag_refs_needed if x not in dag_refs_stored}",
            "            session.bulk_save_objects(dag_refs_to_add)",
            "            for obj in dag_refs_stored - dag_refs_needed:",
            "                session.delete(obj)",
            "",
            "        existing_task_outlet_refs_dict = collections.defaultdict(set)",
            "        for dag_id, orm_dag in existing_dags.items():",
            "            for todr in orm_dag.task_outlet_dataset_references:",
            "                existing_task_outlet_refs_dict[(dag_id, todr.task_id)].add(todr)",
            "",
            "        # reconcile task-outlet-dataset references",
            "        for (dag_id, task_id), uri_list in outlet_references.items():",
            "            task_refs_needed = {",
            "                TaskOutletDatasetReference(dataset_id=stored_datasets[uri].id, dag_id=dag_id, task_id=task_id)",
            "                for uri in uri_list",
            "            }",
            "            task_refs_stored = existing_task_outlet_refs_dict[(dag_id, task_id)]",
            "            task_refs_to_add = {x for x in task_refs_needed if x not in task_refs_stored}",
            "            session.bulk_save_objects(task_refs_to_add)",
            "            for obj in task_refs_stored - task_refs_needed:",
            "                session.delete(obj)",
            "",
            "        # Issue SQL/finish \"Unit of Work\", but let @provide_session commit (or if passed a session, let caller",
            "        # decide when to commit",
            "        session.flush()",
            "",
            "        for dag in dags:",
            "            cls.bulk_write_to_db(dag.subdags, processor_subdir=processor_subdir, session=session)",
            "",
            "    @provide_session",
            "    def sync_to_db(self, processor_subdir: str | None = None, session=NEW_SESSION):",
            "        \"\"\"",
            "        Save attributes about this DAG to the DB. Note that this method",
            "        can be called for both DAGs and SubDAGs. A SubDag is actually a",
            "        SubDagOperator.",
            "",
            "        :return: None",
            "        \"\"\"",
            "        self.bulk_write_to_db([self], processor_subdir=processor_subdir, session=session)",
            "",
            "    def get_default_view(self):",
            "        \"\"\"This is only there for backward compatible jinja2 templates.\"\"\"",
            "        if self.default_view is None:",
            "            return airflow_conf.get(\"webserver\", \"dag_default_view\").lower()",
            "        else:",
            "            return self.default_view",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def deactivate_unknown_dags(active_dag_ids, session=NEW_SESSION):",
            "        \"\"\"",
            "        Given a list of known DAGs, deactivate any other DAGs that are",
            "        marked as active in the ORM.",
            "",
            "        :param active_dag_ids: list of DAG IDs that are active",
            "        :return: None",
            "        \"\"\"",
            "        if len(active_dag_ids) == 0:",
            "            return",
            "        for dag in session.scalars(select(DagModel).where(~DagModel.dag_id.in_(active_dag_ids))).all():",
            "            dag.is_active = False",
            "            session.merge(dag)",
            "        session.commit()",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def deactivate_stale_dags(expiration_date, session=NEW_SESSION):",
            "        \"\"\"",
            "        Deactivate any DAGs that were last touched by the scheduler before",
            "        the expiration date. These DAGs were likely deleted.",
            "",
            "        :param expiration_date: set inactive DAGs that were touched before this",
            "            time",
            "        :return: None",
            "        \"\"\"",
            "        for dag in session.scalars(",
            "            select(DagModel).where(DagModel.last_parsed_time < expiration_date, DagModel.is_active)",
            "        ):",
            "            log.info(",
            "                \"Deactivating DAG ID %s since it was last touched by the scheduler at %s\",",
            "                dag.dag_id,",
            "                dag.last_parsed_time.isoformat(),",
            "            )",
            "            dag.is_active = False",
            "            session.merge(dag)",
            "            session.commit()",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def get_num_task_instances(dag_id, run_id=None, task_ids=None, states=None, session=NEW_SESSION) -> int:",
            "        \"\"\"",
            "        Returns the number of task instances in the given DAG.",
            "",
            "        :param session: ORM session",
            "        :param dag_id: ID of the DAG to get the task concurrency of",
            "        :param run_id: ID of the DAG run to get the task concurrency of",
            "        :param task_ids: A list of valid task IDs for the given DAG",
            "        :param states: A list of states to filter by if supplied",
            "        :return: The number of running tasks",
            "        \"\"\"",
            "        qry = select(func.count(TaskInstance.task_id)).where(",
            "            TaskInstance.dag_id == dag_id,",
            "        )",
            "        if run_id:",
            "            qry = qry.where(",
            "                TaskInstance.run_id == run_id,",
            "            )",
            "        if task_ids:",
            "            qry = qry.where(",
            "                TaskInstance.task_id.in_(task_ids),",
            "            )",
            "",
            "        if states:",
            "            if None in states:",
            "                if all(x is None for x in states):",
            "                    qry = qry.where(TaskInstance.state.is_(None))",
            "                else:",
            "                    not_none_states = [state for state in states if state]",
            "                    qry = qry.where(",
            "                        or_(TaskInstance.state.in_(not_none_states), TaskInstance.state.is_(None))",
            "                    )",
            "            else:",
            "                qry = qry.where(TaskInstance.state.in_(states))",
            "        return session.scalar(qry)",
            "",
            "    @classmethod",
            "    def get_serialized_fields(cls):",
            "        \"\"\"Stringified DAGs and operators contain exactly these fields.\"\"\"",
            "        if not cls.__serialized_fields:",
            "            exclusion_list = {",
            "                \"parent_dag\",",
            "                \"schedule_dataset_references\",",
            "                \"task_outlet_dataset_references\",",
            "                \"_old_context_manager_dags\",",
            "                \"safe_dag_id\",",
            "                \"last_loaded\",",
            "                \"user_defined_filters\",",
            "                \"user_defined_macros\",",
            "                \"partial\",",
            "                \"params\",",
            "                \"_pickle_id\",",
            "                \"_log\",",
            "                \"task_dict\",",
            "                \"template_searchpath\",",
            "                \"sla_miss_callback\",",
            "                \"on_success_callback\",",
            "                \"on_failure_callback\",",
            "                \"template_undefined\",",
            "                \"jinja_environment_kwargs\",",
            "                # has_on_*_callback are only stored if the value is True, as the default is False",
            "                \"has_on_success_callback\",",
            "                \"has_on_failure_callback\",",
            "                \"auto_register\",",
            "                \"fail_stop\",",
            "            }",
            "            cls.__serialized_fields = frozenset(vars(DAG(dag_id=\"test\")).keys()) - exclusion_list",
            "        return cls.__serialized_fields",
            "",
            "    def get_edge_info(self, upstream_task_id: str, downstream_task_id: str) -> EdgeInfoType:",
            "        \"\"\"",
            "        Returns edge information for the given pair of tasks if present, and",
            "        an empty edge if there is no information.",
            "        \"\"\"",
            "        # Note - older serialized DAGs may not have edge_info being a dict at all",
            "        empty = cast(EdgeInfoType, {})",
            "        if self.edge_info:",
            "            return self.edge_info.get(upstream_task_id, {}).get(downstream_task_id, empty)",
            "        else:",
            "            return empty",
            "",
            "    def set_edge_info(self, upstream_task_id: str, downstream_task_id: str, info: EdgeInfoType):",
            "        \"\"\"",
            "        Sets the given edge information on the DAG. Note that this will overwrite,",
            "        rather than merge with, existing info.",
            "        \"\"\"",
            "        self.edge_info.setdefault(upstream_task_id, {})[downstream_task_id] = info",
            "",
            "    def validate_schedule_and_params(self):",
            "        \"\"\"",
            "        Validates & raise exception if there are any Params in the DAG which neither have a default value nor",
            "        have the null in schema['type'] list, but the DAG have a schedule_interval which is not None.",
            "        \"\"\"",
            "        if not self.timetable.can_be_scheduled:",
            "            return",
            "",
            "        for k, v in self.params.items():",
            "            # As type can be an array, we would check if `null` is an allowed type or not",
            "            if not v.has_value and (\"type\" not in v.schema or \"null\" not in v.schema[\"type\"]):",
            "                raise AirflowException(",
            "                    \"DAG Schedule must be None, if there are any required params without default values\"",
            "                )",
            "",
            "    def iter_invalid_owner_links(self) -> Iterator[tuple[str, str]]:",
            "        \"\"\"Parses a given link, and verifies if it's a valid URL, or a 'mailto' link.",
            "        Returns an iterator of invalid (owner, link) pairs.",
            "        \"\"\"",
            "        for owner, link in self.owner_links.items():",
            "            result = urlsplit(link)",
            "            if result.scheme == \"mailto\":",
            "                # netloc is not existing for 'mailto' link, so we are checking that the path is parsed",
            "                if not result.path:",
            "                    yield result.path, link",
            "            elif not result.scheme or not result.netloc:",
            "                yield owner, link",
            "",
            "",
            "class DagTag(Base):",
            "    \"\"\"A tag name per dag, to allow quick filtering in the DAG view.\"\"\"",
            "",
            "    __tablename__ = \"dag_tag\"",
            "    name = Column(String(TAG_MAX_LEN), primary_key=True)",
            "    dag_id = Column(",
            "        StringID(),",
            "        ForeignKey(\"dag.dag_id\", name=\"dag_tag_dag_id_fkey\", ondelete=\"CASCADE\"),",
            "        primary_key=True,",
            "    )",
            "",
            "    def __repr__(self):",
            "        return self.name",
            "",
            "",
            "class DagOwnerAttributes(Base):",
            "    \"\"\"Table defining different owner attributes.",
            "",
            "    For example, a link for an owner that will be passed as a hyperlink to the",
            "    \"DAGs\" view.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_owner_attributes\"",
            "    dag_id = Column(",
            "        StringID(),",
            "        ForeignKey(\"dag.dag_id\", name=\"dag.dag_id\", ondelete=\"CASCADE\"),",
            "        nullable=False,",
            "        primary_key=True,",
            "    )",
            "    owner = Column(String(500), primary_key=True, nullable=False)",
            "    link = Column(String(500), nullable=False)",
            "",
            "    def __repr__(self):",
            "        return f\"<DagOwnerAttributes: dag_id={self.dag_id}, owner={self.owner}, link={self.link}>\"",
            "",
            "    @classmethod",
            "    def get_all(cls, session) -> dict[str, dict[str, str]]:",
            "        dag_links: dict = collections.defaultdict(dict)",
            "        for obj in session.scalars(select(cls)):",
            "            dag_links[obj.dag_id].update({obj.owner: obj.link})",
            "        return dag_links",
            "",
            "",
            "class DagModel(Base):",
            "    \"\"\"Table containing DAG properties.\"\"\"",
            "",
            "    __tablename__ = \"dag\"",
            "    \"\"\"",
            "    These items are stored in the database for state related information",
            "    \"\"\"",
            "    dag_id = Column(StringID(), primary_key=True)",
            "    root_dag_id = Column(StringID())",
            "    # A DAG can be paused from the UI / DB",
            "    # Set this default value of is_paused based on a configuration value!",
            "    is_paused_at_creation = airflow_conf.getboolean(\"core\", \"dags_are_paused_at_creation\")",
            "    is_paused = Column(Boolean, default=is_paused_at_creation)",
            "    # Whether the DAG is a subdag",
            "    is_subdag = Column(Boolean, default=False)",
            "    # Whether that DAG was seen on the last DagBag load",
            "    is_active = Column(Boolean, default=False)",
            "    # Last time the scheduler started",
            "    last_parsed_time = Column(UtcDateTime)",
            "    # Last time this DAG was pickled",
            "    last_pickled = Column(UtcDateTime)",
            "    # Time when the DAG last received a refresh signal",
            "    # (e.g. the DAG's \"refresh\" button was clicked in the web UI)",
            "    last_expired = Column(UtcDateTime)",
            "    # Whether (one  of) the scheduler is scheduling this DAG at the moment",
            "    scheduler_lock = Column(Boolean)",
            "    # Foreign key to the latest pickle_id",
            "    pickle_id = Column(Integer)",
            "    # The location of the file containing the DAG object",
            "    # Note: Do not depend on fileloc pointing to a file; in the case of a",
            "    # packaged DAG, it will point to the subpath of the DAG within the",
            "    # associated zip.",
            "    fileloc = Column(String(2000))",
            "    # The base directory used by Dag Processor that parsed this dag.",
            "    processor_subdir = Column(String(2000), nullable=True)",
            "    # String representing the owners",
            "    owners = Column(String(2000))",
            "    # Description of the dag",
            "    description = Column(Text)",
            "    # Default view of the DAG inside the webserver",
            "    default_view = Column(String(25))",
            "    # Schedule interval",
            "    schedule_interval = Column(Interval)",
            "    # Timetable/Schedule Interval description",
            "    timetable_description = Column(String(1000), nullable=True)",
            "    # Tags for view filter",
            "    tags = relationship(\"DagTag\", cascade=\"all, delete, delete-orphan\", backref=backref(\"dag\"))",
            "    # Dag owner links for DAGs view",
            "    dag_owner_links = relationship(",
            "        \"DagOwnerAttributes\", cascade=\"all, delete, delete-orphan\", backref=backref(\"dag\")",
            "    )",
            "",
            "    max_active_tasks = Column(Integer, nullable=False)",
            "    max_active_runs = Column(Integer, nullable=True)",
            "",
            "    has_task_concurrency_limits = Column(Boolean, nullable=False)",
            "    has_import_errors = Column(Boolean(), default=False, server_default=\"0\")",
            "",
            "    # The logical date of the next dag run.",
            "    next_dagrun = Column(UtcDateTime)",
            "",
            "    # Must be either both NULL or both datetime.",
            "    next_dagrun_data_interval_start = Column(UtcDateTime)",
            "    next_dagrun_data_interval_end = Column(UtcDateTime)",
            "",
            "    # Earliest time at which this ``next_dagrun`` can be created.",
            "    next_dagrun_create_after = Column(UtcDateTime)",
            "",
            "    __table_args__ = (",
            "        Index(\"idx_root_dag_id\", root_dag_id, unique=False),",
            "        Index(\"idx_next_dagrun_create_after\", next_dagrun_create_after, unique=False),",
            "    )",
            "",
            "    parent_dag = relationship(",
            "        \"DagModel\", remote_side=[dag_id], primaryjoin=root_dag_id == dag_id, foreign_keys=[root_dag_id]",
            "    )",
            "    schedule_dataset_references = relationship(",
            "        \"DagScheduleDatasetReference\",",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    schedule_datasets = association_proxy(\"schedule_dataset_references\", \"dataset\")",
            "    task_outlet_dataset_references = relationship(",
            "        \"TaskOutletDatasetReference\",",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    NUM_DAGS_PER_DAGRUN_QUERY = airflow_conf.getint(",
            "        \"scheduler\", \"max_dagruns_to_create_per_loop\", fallback=10",
            "    )",
            "",
            "    def __init__(self, concurrency=None, **kwargs):",
            "        super().__init__(**kwargs)",
            "        if self.max_active_tasks is None:",
            "            if concurrency:",
            "                warnings.warn(",
            "                    \"The 'DagModel.concurrency' parameter is deprecated. Please use 'max_active_tasks'.\",",
            "                    RemovedInAirflow3Warning,",
            "                    stacklevel=2,",
            "                )",
            "                self.max_active_tasks = concurrency",
            "            else:",
            "                self.max_active_tasks = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\")",
            "",
            "        if self.max_active_runs is None:",
            "            self.max_active_runs = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\")",
            "",
            "        if self.has_task_concurrency_limits is None:",
            "            # Be safe -- this will be updated later once the DAG is parsed",
            "            self.has_task_concurrency_limits = True",
            "",
            "    def __repr__(self):",
            "        return f\"<DAG: {self.dag_id}>\"",
            "",
            "    @property",
            "    def next_dagrun_data_interval(self) -> DataInterval | None:",
            "        return _get_model_data_interval(",
            "            self,",
            "            \"next_dagrun_data_interval_start\",",
            "            \"next_dagrun_data_interval_end\",",
            "        )",
            "",
            "    @next_dagrun_data_interval.setter",
            "    def next_dagrun_data_interval(self, value: tuple[datetime, datetime] | None) -> None:",
            "        if value is None:",
            "            self.next_dagrun_data_interval_start = self.next_dagrun_data_interval_end = None",
            "        else:",
            "            self.next_dagrun_data_interval_start, self.next_dagrun_data_interval_end = value",
            "",
            "    @property",
            "    def timezone(self):",
            "        return settings.TIMEZONE",
            "",
            "    @staticmethod",
            "    @provide_session",
            "    def get_dagmodel(dag_id: str, session: Session = NEW_SESSION) -> DagModel | None:",
            "        return session.get(",
            "            DagModel,",
            "            dag_id,",
            "            options=[joinedload(DagModel.parent_dag)],",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def get_current(cls, dag_id, session=NEW_SESSION):",
            "        return session.scalar(select(cls).where(cls.dag_id == dag_id))",
            "",
            "    @provide_session",
            "    def get_last_dagrun(self, session=NEW_SESSION, include_externally_triggered=False):",
            "        return get_last_dagrun(",
            "            self.dag_id, session=session, include_externally_triggered=include_externally_triggered",
            "        )",
            "",
            "    def get_is_paused(self, *, session: Session | None = None) -> bool:",
            "        \"\"\"Provide interface compatibility to 'DAG'.\"\"\"",
            "        return self.is_paused",
            "",
            "    @staticmethod",
            "    @internal_api_call",
            "    @provide_session",
            "    def get_paused_dag_ids(dag_ids: list[str], session: Session = NEW_SESSION) -> set[str]:",
            "        \"\"\"",
            "        Given a list of dag_ids, get a set of Paused Dag Ids.",
            "",
            "        :param dag_ids: List of Dag ids",
            "        :param session: ORM Session",
            "        :return: Paused Dag_ids",
            "        \"\"\"",
            "        paused_dag_ids = session.execute(",
            "            select(DagModel.dag_id)",
            "            .where(DagModel.is_paused == expression.true())",
            "            .where(DagModel.dag_id.in_(dag_ids))",
            "        )",
            "",
            "        paused_dag_ids = {paused_dag_id for paused_dag_id, in paused_dag_ids}",
            "        return paused_dag_ids",
            "",
            "    def get_default_view(self) -> str:",
            "        \"\"\"",
            "        Get the Default DAG View, returns the default config value if DagModel does not",
            "        have a value.",
            "        \"\"\"",
            "        # This is for backwards-compatibility with old dags that don't have None as default_view",
            "        return self.default_view or airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower()",
            "",
            "    @property",
            "    def safe_dag_id(self):",
            "        return self.dag_id.replace(\".\", \"__dot__\")",
            "",
            "    @property",
            "    def relative_fileloc(self) -> pathlib.Path | None:",
            "        \"\"\"File location of the importable dag 'file' relative to the configured DAGs folder.\"\"\"",
            "        if self.fileloc is None:",
            "            return None",
            "        path = pathlib.Path(self.fileloc)",
            "        try:",
            "            return path.relative_to(settings.DAGS_FOLDER)",
            "        except ValueError:",
            "            # Not relative to DAGS_FOLDER.",
            "            return path",
            "",
            "    @provide_session",
            "    def set_is_paused(self, is_paused: bool, including_subdags: bool = True, session=NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Pause/Un-pause a DAG.",
            "",
            "        :param is_paused: Is the DAG paused",
            "        :param including_subdags: whether to include the DAG's subdags",
            "        :param session: session",
            "        \"\"\"",
            "        filter_query = [",
            "            DagModel.dag_id == self.dag_id,",
            "        ]",
            "        if including_subdags:",
            "            filter_query.append(DagModel.root_dag_id == self.dag_id)",
            "        session.execute(",
            "            update(DagModel)",
            "            .where(or_(*filter_query))",
            "            .values(is_paused=is_paused)",
            "            .execution_options(synchronize_session=\"fetch\")",
            "        )",
            "        session.commit()",
            "",
            "    @classmethod",
            "    @internal_api_call",
            "    @provide_session",
            "    def deactivate_deleted_dags(",
            "        cls,",
            "        alive_dag_filelocs: Container[str],",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"",
            "        Set ``is_active=False`` on the DAGs for which the DAG files have been removed.",
            "",
            "        :param alive_dag_filelocs: file paths of alive DAGs",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        log.debug(\"Deactivating DAGs (for which DAG files are deleted) from %s table \", cls.__tablename__)",
            "        dag_models = session.scalars(select(cls).where(cls.fileloc.is_not(None)))",
            "        for dag_model in dag_models:",
            "            if dag_model.fileloc not in alive_dag_filelocs:",
            "                dag_model.is_active = False",
            "",
            "    @classmethod",
            "    def dags_needing_dagruns(cls, session: Session) -> tuple[Query, dict[str, tuple[datetime, datetime]]]:",
            "        \"\"\"",
            "        Return (and lock) a list of Dag objects that are due to create a new DagRun.",
            "",
            "        This will return a resultset of rows that is row-level-locked with a \"SELECT ... FOR UPDATE\" query,",
            "        you should ensure that any scheduling decisions are made in a single transaction -- as soon as the",
            "        transaction is committed it will be unlocked.",
            "        \"\"\"",
            "        from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue as DDRQ",
            "",
            "        # these dag ids are triggered by datasets, and they are ready to go.",
            "        dataset_triggered_dag_info = {",
            "            x.dag_id: (x.first_queued_time, x.last_queued_time)",
            "            for x in session.execute(",
            "                select(",
            "                    DagScheduleDatasetReference.dag_id,",
            "                    func.max(DDRQ.created_at).label(\"last_queued_time\"),",
            "                    func.min(DDRQ.created_at).label(\"first_queued_time\"),",
            "                )",
            "                .join(DagScheduleDatasetReference.queue_records, isouter=True)",
            "                .group_by(DagScheduleDatasetReference.dag_id)",
            "                .having(func.count() == func.sum(case((DDRQ.target_dag_id.is_not(None), 1), else_=0)))",
            "            )",
            "        }",
            "        dataset_triggered_dag_ids = set(dataset_triggered_dag_info.keys())",
            "        if dataset_triggered_dag_ids:",
            "            exclusion_list = {",
            "                x",
            "                for x in (",
            "                    session.scalars(",
            "                        select(DagModel.dag_id)",
            "                        .join(DagRun.dag_model)",
            "                        .where(DagRun.state.in_((DagRunState.QUEUED, DagRunState.RUNNING)))",
            "                        .where(DagModel.dag_id.in_(dataset_triggered_dag_ids))",
            "                        .group_by(DagModel.dag_id)",
            "                        .having(func.count() >= func.max(DagModel.max_active_runs))",
            "                    )",
            "                )",
            "            }",
            "            if exclusion_list:",
            "                dataset_triggered_dag_ids -= exclusion_list",
            "                dataset_triggered_dag_info = {",
            "                    k: v for k, v in dataset_triggered_dag_info.items() if k not in exclusion_list",
            "                }",
            "",
            "        # We limit so that _one_ scheduler doesn't try to do all the creation of dag runs",
            "        query = (",
            "            select(cls)",
            "            .where(",
            "                cls.is_paused == expression.false(),",
            "                cls.is_active == expression.true(),",
            "                cls.has_import_errors == expression.false(),",
            "                or_(",
            "                    cls.next_dagrun_create_after <= func.now(),",
            "                    cls.dag_id.in_(dataset_triggered_dag_ids),",
            "                ),",
            "            )",
            "            .order_by(cls.next_dagrun_create_after)",
            "            .limit(cls.NUM_DAGS_PER_DAGRUN_QUERY)",
            "        )",
            "",
            "        return (",
            "            session.scalars(with_row_locks(query, of=cls, session=session, **skip_locked(session=session))),",
            "            dataset_triggered_dag_info,",
            "        )",
            "",
            "    def calculate_dagrun_date_fields(",
            "        self,",
            "        dag: DAG,",
            "        most_recent_dag_run: None | datetime | DataInterval,",
            "    ) -> None:",
            "        \"\"\"",
            "        Calculate ``next_dagrun`` and `next_dagrun_create_after``.",
            "",
            "        :param dag: The DAG object",
            "        :param most_recent_dag_run: DataInterval (or datetime) of most recent run of this dag, or none",
            "            if not yet scheduled.",
            "        \"\"\"",
            "        most_recent_data_interval: DataInterval | None",
            "        if isinstance(most_recent_dag_run, datetime):",
            "            warnings.warn(",
            "                \"Passing a datetime to `DagModel.calculate_dagrun_date_fields` is deprecated. \"",
            "                \"Provide a data interval instead.\",",
            "                RemovedInAirflow3Warning,",
            "                stacklevel=2,",
            "            )",
            "            most_recent_data_interval = dag.infer_automated_data_interval(most_recent_dag_run)",
            "        else:",
            "            most_recent_data_interval = most_recent_dag_run",
            "        next_dagrun_info = dag.next_dagrun_info(most_recent_data_interval)",
            "        if next_dagrun_info is None:",
            "            self.next_dagrun_data_interval = self.next_dagrun = self.next_dagrun_create_after = None",
            "        else:",
            "            self.next_dagrun_data_interval = next_dagrun_info.data_interval",
            "            self.next_dagrun = next_dagrun_info.logical_date",
            "            self.next_dagrun_create_after = next_dagrun_info.run_after",
            "",
            "        log.info(",
            "            \"Setting next_dagrun for %s to %s, run_after=%s\",",
            "            dag.dag_id,",
            "            self.next_dagrun,",
            "            self.next_dagrun_create_after,",
            "        )",
            "",
            "    @provide_session",
            "    def get_dataset_triggered_next_run_info(self, *, session=NEW_SESSION) -> dict[str, int | str] | None:",
            "        if self.schedule_interval != \"Dataset\":",
            "            return None",
            "        return get_dataset_triggered_next_run_info([self.dag_id], session=session)[self.dag_id]",
            "",
            "",
            "# NOTE: Please keep the list of arguments in sync with DAG.__init__.",
            "# Only exception: dag_id here should have a default value, but not in DAG.",
            "def dag(",
            "    dag_id: str = \"\",",
            "    description: str | None = None,",
            "    schedule: ScheduleArg = NOTSET,",
            "    schedule_interval: ScheduleIntervalArg = NOTSET,",
            "    timetable: Timetable | None = None,",
            "    start_date: datetime | None = None,",
            "    end_date: datetime | None = None,",
            "    full_filepath: str | None = None,",
            "    template_searchpath: str | Iterable[str] | None = None,",
            "    template_undefined: type[jinja2.StrictUndefined] = jinja2.StrictUndefined,",
            "    user_defined_macros: dict | None = None,",
            "    user_defined_filters: dict | None = None,",
            "    default_args: dict | None = None,",
            "    concurrency: int | None = None,",
            "    max_active_tasks: int = airflow_conf.getint(\"core\", \"max_active_tasks_per_dag\"),",
            "    max_active_runs: int = airflow_conf.getint(\"core\", \"max_active_runs_per_dag\"),",
            "    dagrun_timeout: timedelta | None = None,",
            "    sla_miss_callback: None | SLAMissCallback | list[SLAMissCallback] = None,",
            "    default_view: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_default_view\").lower(),",
            "    orientation: str = airflow_conf.get_mandatory_value(\"webserver\", \"dag_orientation\"),",
            "    catchup: bool = airflow_conf.getboolean(\"scheduler\", \"catchup_by_default\"),",
            "    on_success_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "    on_failure_callback: None | DagStateChangeCallback | list[DagStateChangeCallback] = None,",
            "    doc_md: str | None = None,",
            "    params: collections.abc.MutableMapping | None = None,",
            "    access_control: dict | None = None,",
            "    is_paused_upon_creation: bool | None = None,",
            "    jinja_environment_kwargs: dict | None = None,",
            "    render_template_as_native_obj: bool = False,",
            "    tags: list[str] | None = None,",
            "    owner_links: dict[str, str] | None = None,",
            "    auto_register: bool = True,",
            "    fail_stop: bool = False,",
            ") -> Callable[[Callable], Callable[..., DAG]]:",
            "    \"\"\"",
            "    Python dag decorator. Wraps a function into an Airflow DAG.",
            "    Accepts kwargs for operator kwarg. Can be used to parameterize DAGs.",
            "",
            "    :param dag_args: Arguments for DAG object",
            "    :param dag_kwargs: Kwargs for DAG object.",
            "    \"\"\"",
            "",
            "    def wrapper(f: Callable) -> Callable[..., DAG]:",
            "        @functools.wraps(f)",
            "        def factory(*args, **kwargs):",
            "            # Generate signature for decorated function and bind the arguments when called",
            "            # we do this to extract parameters, so we can annotate them on the DAG object.",
            "            # In addition, this fails if we are missing any args/kwargs with TypeError as expected.",
            "            f_sig = signature(f).bind(*args, **kwargs)",
            "            # Apply defaults to capture default values if set.",
            "            f_sig.apply_defaults()",
            "",
            "            # Initialize DAG with bound arguments",
            "            with DAG(",
            "                dag_id or f.__name__,",
            "                description=description,",
            "                schedule_interval=schedule_interval,",
            "                timetable=timetable,",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                full_filepath=full_filepath,",
            "                template_searchpath=template_searchpath,",
            "                template_undefined=template_undefined,",
            "                user_defined_macros=user_defined_macros,",
            "                user_defined_filters=user_defined_filters,",
            "                default_args=default_args,",
            "                concurrency=concurrency,",
            "                max_active_tasks=max_active_tasks,",
            "                max_active_runs=max_active_runs,",
            "                dagrun_timeout=dagrun_timeout,",
            "                sla_miss_callback=sla_miss_callback,",
            "                default_view=default_view,",
            "                orientation=orientation,",
            "                catchup=catchup,",
            "                on_success_callback=on_success_callback,",
            "                on_failure_callback=on_failure_callback,",
            "                doc_md=doc_md,",
            "                params=params,",
            "                access_control=access_control,",
            "                is_paused_upon_creation=is_paused_upon_creation,",
            "                jinja_environment_kwargs=jinja_environment_kwargs,",
            "                render_template_as_native_obj=render_template_as_native_obj,",
            "                tags=tags,",
            "                schedule=schedule,",
            "                owner_links=owner_links,",
            "                auto_register=auto_register,",
            "                fail_stop=fail_stop,",
            "            ) as dag_obj:",
            "                # Set DAG documentation from function documentation if it exists and doc_md is not set.",
            "                if f.__doc__ and not dag_obj.doc_md:",
            "                    dag_obj.doc_md = f.__doc__",
            "",
            "                # Generate DAGParam for each function arg/kwarg and replace it for calling the function.",
            "                # All args/kwargs for function will be DAGParam object and replaced on execution time.",
            "                f_kwargs = {}",
            "                for name, value in f_sig.arguments.items():",
            "                    f_kwargs[name] = dag_obj.param(name, value)",
            "",
            "                # set file location to caller source path",
            "                back = sys._getframe().f_back",
            "                dag_obj.fileloc = back.f_code.co_filename if back else \"\"",
            "",
            "                # Invoke function to create operators in the DAG scope.",
            "                f(**f_kwargs)",
            "",
            "            # Return dag object such that it's accessible in Globals.",
            "            return dag_obj",
            "",
            "        # Ensure that warnings from inside DAG() are emitted from the caller, not here",
            "        fixup_decorator_warning_stack(factory)",
            "        return factory",
            "",
            "    return wrapper",
            "",
            "",
            "STATICA_HACK = True",
            "globals()[\"kcah_acitats\"[::-1].upper()] = False",
            "if STATICA_HACK:  # pragma: no cover",
            "    from airflow.models.serialized_dag import SerializedDagModel",
            "",
            "    DagModel.serialized_dag = relationship(SerializedDagModel)",
            "    \"\"\":sphinx-autoapi-skip:\"\"\"",
            "",
            "",
            "class DagContext:",
            "    \"\"\"",
            "    DAG context is used to keep the current DAG when DAG is used as ContextManager.",
            "",
            "    You can use DAG as context:",
            "",
            "    .. code-block:: python",
            "",
            "        with DAG(",
            "            dag_id=\"example_dag\",",
            "            default_args=default_args,",
            "            schedule=\"0 0 * * *\",",
            "            dagrun_timeout=timedelta(minutes=60),",
            "        ) as dag:",
            "            ...",
            "",
            "    If you do this the context stores the DAG and whenever new task is created, it will use",
            "    such stored DAG as the parent DAG.",
            "",
            "    \"\"\"",
            "",
            "    _context_managed_dags: collections.deque[DAG] = deque()",
            "    autoregistered_dags: set[tuple[DAG, ModuleType]] = set()",
            "    current_autoregister_module_name: str | None = None",
            "",
            "    @classmethod",
            "    def push_context_managed_dag(cls, dag: DAG):",
            "        cls._context_managed_dags.appendleft(dag)",
            "",
            "    @classmethod",
            "    def pop_context_managed_dag(cls) -> DAG | None:",
            "        dag = cls._context_managed_dags.popleft()",
            "",
            "        # In a few cases around serialization we explicitly push None in to the stack",
            "        if cls.current_autoregister_module_name is not None and dag and dag.auto_register:",
            "            mod = sys.modules[cls.current_autoregister_module_name]",
            "            cls.autoregistered_dags.add((dag, mod))",
            "",
            "        return dag",
            "",
            "    @classmethod",
            "    def get_current_dag(cls) -> DAG | None:",
            "        try:",
            "            return cls._context_managed_dags[0]",
            "        except IndexError:",
            "            return None",
            "",
            "",
            "def _run_task(ti: TaskInstance, session):",
            "    \"\"\"",
            "    Run a single task instance, and push result to Xcom for downstream tasks. Bypasses a lot of",
            "    extra steps used in `task.run` to keep our local running as fast as possible",
            "    This function is only meant for the `dag.test` function as a helper function.",
            "",
            "    Args:",
            "        ti: TaskInstance to run",
            "    \"\"\"",
            "    log.info(\"*****************************************************\")",
            "    if ti.map_index > 0:",
            "        log.info(\"Running task %s index %d\", ti.task_id, ti.map_index)",
            "    else:",
            "        log.info(\"Running task %s\", ti.task_id)",
            "    try:",
            "        ti._run_raw_task(session=session)",
            "        session.flush()",
            "        log.info(\"%s ran successfully!\", ti.task_id)",
            "    except AirflowSkipException:",
            "        log.info(\"Task Skipped, continuing\")",
            "    log.info(\"*****************************************************\")",
            "",
            "",
            "def _get_or_create_dagrun(",
            "    dag: DAG,",
            "    conf: dict[Any, Any] | None,",
            "    start_date: datetime,",
            "    execution_date: datetime,",
            "    run_id: str,",
            "    session: Session,",
            ") -> DagRun:",
            "    \"\"\"Create a DAG run, replacing an existing instance if needed to prevent collisions.",
            "",
            "    This function is only meant to be used by :meth:`DAG.test` as a helper function.",
            "",
            "    :param dag: DAG to be used to find run.",
            "    :param conf: Configuration to pass to newly created run.",
            "    :param start_date: Start date of new run.",
            "    :param execution_date: Logical date for finding an existing run.",
            "    :param run_id: Run ID for the new DAG run.",
            "",
            "    :return: The newly created DAG run.",
            "    \"\"\"",
            "    log.info(\"dagrun id: %s\", dag.dag_id)",
            "    dr: DagRun = session.scalar(",
            "        select(DagRun).where(DagRun.dag_id == dag.dag_id, DagRun.execution_date == execution_date)",
            "    )",
            "    if dr:",
            "        session.delete(dr)",
            "        session.commit()",
            "    dr = dag.create_dagrun(",
            "        state=DagRunState.RUNNING,",
            "        execution_date=execution_date,",
            "        run_id=run_id,",
            "        start_date=start_date or execution_date,",
            "        session=session,",
            "        conf=conf,",
            "    )",
            "    log.info(\"created dagrun %s\", dr)",
            "    return dr"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "83": [],
            "99": [],
            "425": [
                "DAG",
                "__init__"
            ],
            "426": [
                "DAG",
                "__init__"
            ],
            "429": [
                "DAG",
                "__init__"
            ],
            "430": [
                "DAG",
                "__init__"
            ],
            "431": [
                "DAG",
                "__init__"
            ],
            "2591": [
                "DAG",
                "run"
            ],
            "2829": [
                "DAG",
                "create_dagrun"
            ],
            "2830": [
                "DAG",
                "create_dagrun"
            ],
            "2831": [
                "DAG",
                "create_dagrun"
            ],
            "2832": [
                "DAG",
                "create_dagrun"
            ],
            "2833": [
                "DAG",
                "create_dagrun"
            ],
            "2834": [
                "DAG",
                "create_dagrun"
            ],
            "2835": [
                "DAG",
                "create_dagrun"
            ],
            "3128": [
                "DAG",
                "get_default_view"
            ],
            "3345": [
                "DagModel"
            ],
            "3419": [
                "DagModel"
            ],
            "3432": [
                "DagModel",
                "__init__"
            ],
            "3435": [
                "DagModel",
                "__init__"
            ],
            "3513": [
                "DagModel",
                "get_default_view"
            ],
            "3702": [
                "dag"
            ],
            "3703": [
                "dag"
            ],
            "3706": [
                "dag"
            ],
            "3707": [
                "dag"
            ],
            "3708": [
                "dag"
            ]
        },
        "addLocation": []
    },
    "airflow/models/dagrun.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from datetime import datetime"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, NamedTuple, Sequence, TypeVar, overload"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+import re2 as re"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from sqlalchemy import ("
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     Boolean,"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     Column,"
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " from sqlalchemy.exc import IntegrityError"
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " from sqlalchemy.ext.associationproxy import association_proxy"
            },
            "10": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy.orm import Query, Session, declared_attr, joinedload, relationship, synonym"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+from sqlalchemy.orm import Query, Session, declared_attr, joinedload, relationship, synonym, validates"
            },
            "12": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " from sqlalchemy.sql.expression import false, select, true"
            },
            "13": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from airflow import settings"
            },
            "15": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     CreatedTasks = TypeVar(\"CreatedTasks\", Iterator[\"dict[str, Any]\"], Iterator[TI])"
            },
            "16": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     TaskCreator = Callable[[Operator, Iterable[int]], CreatedTasks]"
            },
            "17": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+RUN_ID_REGEX = r\"^(?:manual|scheduled|dataset_triggered)__(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\+00:00)$\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " class TISchedulingDecision(NamedTuple):"
            },
            "22": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     \"\"\"Type of return for DagRun.task_instance_scheduling_decisions.\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             external_trigger=self.external_trigger,"
            },
            "24": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         )"
            },
            "25": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+    @validates(\"run_id\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    def validate_run_id(self, key: str, run_id: str) -> str | None:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        if not run_id:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+            return None"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        regex = airflow_conf.get(\"scheduler\", \"allowed_run_id_pattern\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        if not re.match(regex, run_id) and not re.match(RUN_ID_REGEX, run_id):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            raise ValueError("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                f\"The run_id provided '{run_id}' does not match the pattern '{regex}' or '{RUN_ID_REGEX}'\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            )"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        return run_id"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "     @property"
            },
            "38": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "     def stats_tags(self) -> dict[str, str]:"
            },
            "39": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         return prune_dict({\"dag_id\": self.dag_id, \"run_type\": self.run_type})"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import itertools",
            "import os",
            "import warnings",
            "from collections import defaultdict",
            "from datetime import datetime",
            "from typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, NamedTuple, Sequence, TypeVar, overload",
            "",
            "from sqlalchemy import (",
            "    Boolean,",
            "    Column,",
            "    ForeignKey,",
            "    ForeignKeyConstraint,",
            "    Index,",
            "    Integer,",
            "    PickleType,",
            "    PrimaryKeyConstraint,",
            "    String,",
            "    Text,",
            "    UniqueConstraint,",
            "    and_,",
            "    func,",
            "    or_,",
            "    text,",
            "    update,",
            ")",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.associationproxy import association_proxy",
            "from sqlalchemy.orm import Query, Session, declared_attr, joinedload, relationship, synonym",
            "from sqlalchemy.sql.expression import false, select, true",
            "",
            "from airflow import settings",
            "from airflow.callbacks.callback_requests import DagCallbackRequest",
            "from airflow.configuration import conf as airflow_conf",
            "from airflow.exceptions import AirflowException, RemovedInAirflow3Warning, TaskNotFound",
            "from airflow.listeners.listener import get_listener_manager",
            "from airflow.models.abstractoperator import NotMapped",
            "from airflow.models.base import Base, StringID",
            "from airflow.models.expandinput import NotFullyPopulated",
            "from airflow.models.taskinstance import TaskInstance as TI",
            "from airflow.models.tasklog import LogTemplate",
            "from airflow.stats import Stats",
            "from airflow.ti_deps.dep_context import DepContext",
            "from airflow.ti_deps.dependencies_states import SCHEDULEABLE_STATES",
            "from airflow.typing_compat import Literal",
            "from airflow.utils import timezone",
            "from airflow.utils.helpers import chunks, is_container, prune_dict",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import UtcDateTime, nulls_first, skip_locked, tuple_in_condition, with_row_locks",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.types import NOTSET, ArgNotSet, DagRunType",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.models.dag import DAG",
            "    from airflow.models.operator import Operator",
            "",
            "    CreatedTasks = TypeVar(\"CreatedTasks\", Iterator[\"dict[str, Any]\"], Iterator[TI])",
            "    TaskCreator = Callable[[Operator, Iterable[int]], CreatedTasks]",
            "",
            "",
            "class TISchedulingDecision(NamedTuple):",
            "    \"\"\"Type of return for DagRun.task_instance_scheduling_decisions.\"\"\"",
            "",
            "    tis: list[TI]",
            "    schedulable_tis: list[TI]",
            "    changed_tis: bool",
            "    unfinished_tis: list[TI]",
            "    finished_tis: list[TI]",
            "",
            "",
            "def _creator_note(val):",
            "    \"\"\"Custom creator for the ``note`` association proxy.\"\"\"",
            "    if isinstance(val, str):",
            "        return DagRunNote(content=val)",
            "    elif isinstance(val, dict):",
            "        return DagRunNote(**val)",
            "    else:",
            "        return DagRunNote(*val)",
            "",
            "",
            "class DagRun(Base, LoggingMixin):",
            "    \"\"\"Invocation instance of a DAG.",
            "",
            "    A DAG run can be created by the scheduler (i.e. scheduled runs), or by an",
            "    external trigger (i.e. manual runs).",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_run\"",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    dag_id = Column(StringID(), nullable=False)",
            "    queued_at = Column(UtcDateTime)",
            "    execution_date = Column(UtcDateTime, default=timezone.utcnow, nullable=False)",
            "    start_date = Column(UtcDateTime)",
            "    end_date = Column(UtcDateTime)",
            "    _state = Column(\"state\", String(50), default=State.QUEUED)",
            "    run_id = Column(StringID(), nullable=False)",
            "    creating_job_id = Column(Integer)",
            "    external_trigger = Column(Boolean, default=True)",
            "    run_type = Column(String(50), nullable=False)",
            "    conf = Column(PickleType)",
            "    # These two must be either both NULL or both datetime.",
            "    data_interval_start = Column(UtcDateTime)",
            "    data_interval_end = Column(UtcDateTime)",
            "    # When a scheduler last attempted to schedule TIs for this DagRun",
            "    last_scheduling_decision = Column(UtcDateTime)",
            "    dag_hash = Column(String(32))",
            "    # Foreign key to LogTemplate. DagRun rows created prior to this column's",
            "    # existence have this set to NULL. Later rows automatically populate this on",
            "    # insert to point to the latest LogTemplate entry.",
            "    log_template_id = Column(",
            "        Integer,",
            "        ForeignKey(\"log_template.id\", name=\"task_instance_log_template_id_fkey\", ondelete=\"NO ACTION\"),",
            "        default=select(func.max(LogTemplate.__table__.c.id)),",
            "    )",
            "    updated_at = Column(UtcDateTime, default=timezone.utcnow, onupdate=timezone.utcnow)",
            "",
            "    # Remove this `if` after upgrading Sphinx-AutoAPI",
            "    if not TYPE_CHECKING and \"BUILDING_AIRFLOW_DOCS\" in os.environ:",
            "        dag: DAG | None",
            "    else:",
            "        dag: DAG | None = None",
            "",
            "    __table_args__ = (",
            "        Index(\"dag_id_state\", dag_id, _state),",
            "        UniqueConstraint(\"dag_id\", \"execution_date\", name=\"dag_run_dag_id_execution_date_key\"),",
            "        UniqueConstraint(\"dag_id\", \"run_id\", name=\"dag_run_dag_id_run_id_key\"),",
            "        Index(\"idx_last_scheduling_decision\", last_scheduling_decision),",
            "        Index(\"idx_dag_run_dag_id\", dag_id),",
            "        Index(",
            "            \"idx_dag_run_running_dags\",",
            "            \"state\",",
            "            \"dag_id\",",
            "            postgresql_where=text(\"state='running'\"),",
            "            mssql_where=text(\"state='running'\"),",
            "            sqlite_where=text(\"state='running'\"),",
            "        ),",
            "        # since mysql lacks filtered/partial indices, this creates a",
            "        # duplicate index on mysql. Not the end of the world",
            "        Index(",
            "            \"idx_dag_run_queued_dags\",",
            "            \"state\",",
            "            \"dag_id\",",
            "            postgresql_where=text(\"state='queued'\"),",
            "            mssql_where=text(\"state='queued'\"),",
            "            sqlite_where=text(\"state='queued'\"),",
            "        ),",
            "    )",
            "",
            "    task_instances = relationship(",
            "        TI, back_populates=\"dag_run\", cascade=\"save-update, merge, delete, delete-orphan\"",
            "    )",
            "    dag_model = relationship(",
            "        \"DagModel\",",
            "        primaryjoin=\"foreign(DagRun.dag_id) == DagModel.dag_id\",",
            "        uselist=False,",
            "        viewonly=True,",
            "    )",
            "    dag_run_note = relationship(",
            "        \"DagRunNote\",",
            "        back_populates=\"dag_run\",",
            "        uselist=False,",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    note = association_proxy(\"dag_run_note\", \"content\", creator=_creator_note)",
            "",
            "    DEFAULT_DAGRUNS_TO_EXAMINE = airflow_conf.getint(",
            "        \"scheduler\",",
            "        \"max_dagruns_per_loop_to_schedule\",",
            "        fallback=20,",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        dag_id: str | None = None,",
            "        run_id: str | None = None,",
            "        queued_at: datetime | None | ArgNotSet = NOTSET,",
            "        execution_date: datetime | None = None,",
            "        start_date: datetime | None = None,",
            "        external_trigger: bool | None = None,",
            "        conf: Any | None = None,",
            "        state: DagRunState | None = None,",
            "        run_type: str | None = None,",
            "        dag_hash: str | None = None,",
            "        creating_job_id: int | None = None,",
            "        data_interval: tuple[datetime, datetime] | None = None,",
            "    ):",
            "        if data_interval is None:",
            "            # Legacy: Only happen for runs created prior to Airflow 2.2.",
            "            self.data_interval_start = self.data_interval_end = None",
            "        else:",
            "            self.data_interval_start, self.data_interval_end = data_interval",
            "",
            "        self.dag_id = dag_id",
            "        self.run_id = run_id",
            "        self.execution_date = execution_date",
            "        self.start_date = start_date",
            "        self.external_trigger = external_trigger",
            "        self.conf = conf or {}",
            "        if state is not None:",
            "            self.state = state",
            "        if queued_at is NOTSET:",
            "            self.queued_at = timezone.utcnow() if state == State.QUEUED else None",
            "        else:",
            "            self.queued_at = queued_at",
            "        self.run_type = run_type",
            "        self.dag_hash = dag_hash",
            "        self.creating_job_id = creating_job_id",
            "        super().__init__()",
            "",
            "    def __repr__(self):",
            "        return (",
            "            \"<DagRun {dag_id} @ {execution_date}: {run_id}, state:{state}, \"",
            "            \"queued_at: {queued_at}. externally triggered: {external_trigger}>\"",
            "        ).format(",
            "            dag_id=self.dag_id,",
            "            execution_date=self.execution_date,",
            "            run_id=self.run_id,",
            "            state=self.state,",
            "            queued_at=self.queued_at,",
            "            external_trigger=self.external_trigger,",
            "        )",
            "",
            "    @property",
            "    def stats_tags(self) -> dict[str, str]:",
            "        return prune_dict({\"dag_id\": self.dag_id, \"run_type\": self.run_type})",
            "",
            "    @property",
            "    def logical_date(self) -> datetime:",
            "        return self.execution_date",
            "",
            "    def get_state(self):",
            "        return self._state",
            "",
            "    def set_state(self, state: DagRunState):",
            "        if state not in State.dag_states:",
            "            raise ValueError(f\"invalid DagRun state: {state}\")",
            "        if self._state != state:",
            "            self._state = state",
            "            self.end_date = timezone.utcnow() if self._state in State.finished else None",
            "            if state == State.QUEUED:",
            "                self.queued_at = timezone.utcnow()",
            "",
            "    @declared_attr",
            "    def state(self):",
            "        return synonym(\"_state\", descriptor=property(self.get_state, self.set_state))",
            "",
            "    @provide_session",
            "    def refresh_from_db(self, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Reloads the current dagrun from the database.",
            "",
            "        :param session: database session",
            "        \"\"\"",
            "        dr = session.scalars(",
            "            select(DagRun).where(DagRun.dag_id == self.dag_id, DagRun.run_id == self.run_id)",
            "        ).one()",
            "        self.id = dr.id",
            "        self.state = dr.state",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def active_runs_of_dags(",
            "        cls,",
            "        dag_ids: Iterable[str] | None = None,",
            "        only_running: bool = False,",
            "        session: Session = NEW_SESSION,",
            "    ) -> dict[str, int]:",
            "        \"\"\"Get the number of active dag runs for each dag.\"\"\"",
            "        query = select(cls.dag_id, func.count(\"*\"))",
            "        if dag_ids is not None:",
            "            # 'set' called to avoid duplicate dag_ids, but converted back to 'list'",
            "            # because SQLAlchemy doesn't accept a set here.",
            "            query = query.where(cls.dag_id.in_(set(dag_ids)))",
            "        if only_running:",
            "            query = query.where(cls.state == State.RUNNING)",
            "        else:",
            "            query = query.where(cls.state.in_([State.RUNNING, State.QUEUED]))",
            "        query = query.group_by(cls.dag_id)",
            "        return {dag_id: count for dag_id, count in session.execute(query)}",
            "",
            "    @classmethod",
            "    def next_dagruns_to_examine(",
            "        cls,",
            "        state: DagRunState,",
            "        session: Session,",
            "        max_number: int | None = None,",
            "    ) -> Query:",
            "        \"\"\"",
            "        Return the next DagRuns that the scheduler should attempt to schedule.",
            "",
            "        This will return zero or more DagRun rows that are row-level-locked with a \"SELECT ... FOR UPDATE\"",
            "        query, you should ensure that any scheduling decisions are made in a single transaction -- as soon as",
            "        the transaction is committed it will be unlocked.",
            "",
            "        \"\"\"",
            "        from airflow.models.dag import DagModel",
            "",
            "        if max_number is None:",
            "            max_number = cls.DEFAULT_DAGRUNS_TO_EXAMINE",
            "",
            "        # TODO: Bake this query, it is run _A lot_",
            "        query = (",
            "            select(cls)",
            "            .with_hint(cls, \"USE INDEX (idx_dag_run_running_dags)\", dialect_name=\"mysql\")",
            "            .where(cls.state == state, cls.run_type != DagRunType.BACKFILL_JOB)",
            "            .join(DagModel, DagModel.dag_id == cls.dag_id)",
            "            .where(DagModel.is_paused == false(), DagModel.is_active == true())",
            "        )",
            "        if state == State.QUEUED:",
            "            # For dag runs in the queued state, we check if they have reached the max_active_runs limit",
            "            # and if so we drop them",
            "            running_drs = (",
            "                select(DagRun.dag_id, func.count(DagRun.state).label(\"num_running\"))",
            "                .where(DagRun.state == DagRunState.RUNNING)",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            query = query.outerjoin(running_drs, running_drs.c.dag_id == DagRun.dag_id).where(",
            "                func.coalesce(running_drs.c.num_running, 0) < DagModel.max_active_runs",
            "            )",
            "        query = query.order_by(",
            "            nulls_first(cls.last_scheduling_decision, session=session),",
            "            cls.execution_date,",
            "        )",
            "",
            "        if not settings.ALLOW_FUTURE_EXEC_DATES:",
            "            query = query.where(DagRun.execution_date <= func.now())",
            "",
            "        return session.scalars(",
            "            with_row_locks(query.limit(max_number), of=cls, session=session, **skip_locked(session=session))",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def find(",
            "        cls,",
            "        dag_id: str | list[str] | None = None,",
            "        run_id: Iterable[str] | None = None,",
            "        execution_date: datetime | Iterable[datetime] | None = None,",
            "        state: DagRunState | None = None,",
            "        external_trigger: bool | None = None,",
            "        no_backfills: bool = False,",
            "        run_type: DagRunType | None = None,",
            "        session: Session = NEW_SESSION,",
            "        execution_start_date: datetime | None = None,",
            "        execution_end_date: datetime | None = None,",
            "    ) -> list[DagRun]:",
            "        \"\"\"",
            "        Returns a set of dag runs for the given search criteria.",
            "",
            "        :param dag_id: the dag_id or list of dag_id to find dag runs for",
            "        :param run_id: defines the run id for this dag run",
            "        :param run_type: type of DagRun",
            "        :param execution_date: the execution date",
            "        :param state: the state of the dag run",
            "        :param external_trigger: whether this dag run is externally triggered",
            "        :param no_backfills: return no backfills (True), return all (False).",
            "            Defaults to False",
            "        :param session: database session",
            "        :param execution_start_date: dag run that was executed from this date",
            "        :param execution_end_date: dag run that was executed until this date",
            "        \"\"\"",
            "        qry = select(cls)",
            "        dag_ids = [dag_id] if isinstance(dag_id, str) else dag_id",
            "        if dag_ids:",
            "            qry = qry.where(cls.dag_id.in_(dag_ids))",
            "",
            "        if is_container(run_id):",
            "            qry = qry.where(cls.run_id.in_(run_id))",
            "        elif run_id is not None:",
            "            qry = qry.where(cls.run_id == run_id)",
            "        if is_container(execution_date):",
            "            qry = qry.where(cls.execution_date.in_(execution_date))",
            "        elif execution_date is not None:",
            "            qry = qry.where(cls.execution_date == execution_date)",
            "        if execution_start_date and execution_end_date:",
            "            qry = qry.where(cls.execution_date.between(execution_start_date, execution_end_date))",
            "        elif execution_start_date:",
            "            qry = qry.where(cls.execution_date >= execution_start_date)",
            "        elif execution_end_date:",
            "            qry = qry.where(cls.execution_date <= execution_end_date)",
            "        if state:",
            "            qry = qry.where(cls.state == state)",
            "        if external_trigger is not None:",
            "            qry = qry.where(cls.external_trigger == external_trigger)",
            "        if run_type:",
            "            qry = qry.where(cls.run_type == run_type)",
            "        if no_backfills:",
            "            qry = qry.where(cls.run_type != DagRunType.BACKFILL_JOB)",
            "",
            "        return session.scalars(qry.order_by(cls.execution_date)).all()",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def find_duplicate(",
            "        cls,",
            "        dag_id: str,",
            "        run_id: str,",
            "        execution_date: datetime,",
            "        session: Session = NEW_SESSION,",
            "    ) -> DagRun | None:",
            "        \"\"\"",
            "        Return an existing run for the DAG with a specific run_id or execution_date.",
            "",
            "        *None* is returned if no such DAG run is found.",
            "",
            "        :param dag_id: the dag_id to find duplicates for",
            "        :param run_id: defines the run id for this dag run",
            "        :param execution_date: the execution date",
            "        :param session: database session",
            "        \"\"\"",
            "        return session.scalars(",
            "            select(cls).where(",
            "                cls.dag_id == dag_id,",
            "                or_(cls.run_id == run_id, cls.execution_date == execution_date),",
            "            )",
            "        ).one_or_none()",
            "",
            "    @staticmethod",
            "    def generate_run_id(run_type: DagRunType, execution_date: datetime) -> str:",
            "        \"\"\"Generate Run ID based on Run Type and Execution Date.\"\"\"",
            "        # _Ensure_ run_type is a DagRunType, not just a string from user code",
            "        return DagRunType(run_type).generate_run_id(execution_date)",
            "",
            "    @provide_session",
            "    def get_task_instances(",
            "        self,",
            "        state: Iterable[TaskInstanceState | None] | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TI]:",
            "        \"\"\"Returns the task instances for this dag run.\"\"\"",
            "        tis = (",
            "            select(TI)",
            "            .options(joinedload(TI.dag_run))",
            "            .where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.run_id == self.run_id,",
            "            )",
            "        )",
            "",
            "        if state:",
            "            if isinstance(state, str):",
            "                tis = tis.where(TI.state == state)",
            "            else:",
            "                # this is required to deal with NULL values",
            "                if State.NONE in state:",
            "                    if all(x is None for x in state):",
            "                        tis = tis.where(TI.state.is_(None))",
            "                    else:",
            "                        not_none_state = [s for s in state if s]",
            "                        tis = tis.where(or_(TI.state.in_(not_none_state), TI.state.is_(None)))",
            "                else:",
            "                    tis = tis.where(TI.state.in_(state))",
            "",
            "        if self.dag and self.dag.partial:",
            "            tis = tis.where(TI.task_id.in_(self.dag.task_ids))",
            "        return session.scalars(tis).all()",
            "",
            "    @provide_session",
            "    def get_task_instance(",
            "        self,",
            "        task_id: str,",
            "        session: Session = NEW_SESSION,",
            "        *,",
            "        map_index: int = -1,",
            "    ) -> TI | None:",
            "        \"\"\"",
            "        Returns the task instance specified by task_id for this dag run.",
            "",
            "        :param task_id: the task id",
            "        :param session: Sqlalchemy ORM Session",
            "        \"\"\"",
            "        return session.scalars(",
            "            select(TI).filter_by(dag_id=self.dag_id, run_id=self.run_id, task_id=task_id, map_index=map_index)",
            "        ).one_or_none()",
            "",
            "    def get_dag(self) -> DAG:",
            "        \"\"\"",
            "        Returns the Dag associated with this DagRun.",
            "",
            "        :return: DAG",
            "        \"\"\"",
            "        if not self.dag:",
            "            raise AirflowException(f\"The DAG (.dag) for {self} needs to be set\")",
            "",
            "        return self.dag",
            "",
            "    @provide_session",
            "    def get_previous_dagrun(",
            "        self, state: DagRunState | None = None, session: Session = NEW_SESSION",
            "    ) -> DagRun | None:",
            "        \"\"\"The previous DagRun, if there is one.\"\"\"",
            "        filters = [",
            "            DagRun.dag_id == self.dag_id,",
            "            DagRun.execution_date < self.execution_date,",
            "        ]",
            "        if state is not None:",
            "            filters.append(DagRun.state == state)",
            "        return session.scalar(select(DagRun).where(*filters).order_by(DagRun.execution_date.desc()))",
            "",
            "    @provide_session",
            "    def get_previous_scheduled_dagrun(self, session: Session = NEW_SESSION) -> DagRun | None:",
            "        \"\"\"The previous, SCHEDULED DagRun, if there is one.\"\"\"",
            "        return session.scalar(",
            "            select(DagRun)",
            "            .where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date < self.execution_date,",
            "                DagRun.run_type != DagRunType.MANUAL,",
            "            )",
            "            .order_by(DagRun.execution_date.desc())",
            "        )",
            "",
            "    def _tis_for_dagrun_state(self, *, dag, tis):",
            "        \"\"\"",
            "        Return the collection of tasks that should be considered for evaluation of terminal dag run state.",
            "",
            "        Teardown tasks by default are not considered for the purpose of dag run state.  But",
            "        users may enable such consideration with on_failure_fail_dagrun.",
            "        \"\"\"",
            "",
            "        def is_effective_leaf(task):",
            "            for down_task_id in task.downstream_task_ids:",
            "                down_task = dag.get_task(down_task_id)",
            "                if not down_task.is_teardown or down_task.on_failure_fail_dagrun:",
            "                    # we found a down task that is not ignorable; not a leaf",
            "                    return False",
            "            # we found no ignorable downstreams",
            "            # evaluate whether task is itself ignorable",
            "            return not task.is_teardown or task.on_failure_fail_dagrun",
            "",
            "        leaf_task_ids = {x.task_id for x in dag.tasks if is_effective_leaf(x)}",
            "        if not leaf_task_ids:",
            "            # can happen if dag is exclusively teardown tasks",
            "            leaf_task_ids = {x.task_id for x in dag.tasks if not x.downstream_list}",
            "        leaf_tis = {ti for ti in tis if ti.task_id in leaf_task_ids if ti.state != TaskInstanceState.REMOVED}",
            "        return leaf_tis",
            "",
            "    @provide_session",
            "    def update_state(",
            "        self, session: Session = NEW_SESSION, execute_callbacks: bool = True",
            "    ) -> tuple[list[TI], DagCallbackRequest | None]:",
            "        \"\"\"",
            "        Determines the overall state of the DagRun based on the state",
            "        of its TaskInstances.",
            "",
            "        :param session: Sqlalchemy ORM Session",
            "        :param execute_callbacks: Should dag callbacks (success/failure, SLA etc.) be invoked",
            "            directly (default: true) or recorded as a pending request in the ``returned_callback`` property",
            "        :return: Tuple containing tis that can be scheduled in the current loop & `returned_callback` that",
            "            needs to be executed",
            "        \"\"\"",
            "        # Callback to execute in case of Task Failures",
            "        callback: DagCallbackRequest | None = None",
            "",
            "        class _UnfinishedStates(NamedTuple):",
            "            tis: Sequence[TI]",
            "",
            "            @classmethod",
            "            def calculate(cls, unfinished_tis: Sequence[TI]) -> _UnfinishedStates:",
            "                return cls(tis=unfinished_tis)",
            "",
            "            @property",
            "            def should_schedule(self) -> bool:",
            "                return (",
            "                    bool(self.tis)",
            "                    and all(not t.task.depends_on_past for t in self.tis)",
            "                    and all(t.task.max_active_tis_per_dag is None for t in self.tis)",
            "                    and all(t.task.max_active_tis_per_dagrun is None for t in self.tis)",
            "                    and all(t.state != TaskInstanceState.DEFERRED for t in self.tis)",
            "                )",
            "",
            "            def recalculate(self) -> _UnfinishedStates:",
            "                return self._replace(tis=[t for t in self.tis if t.state in State.unfinished])",
            "",
            "        start_dttm = timezone.utcnow()",
            "        self.last_scheduling_decision = start_dttm",
            "        with Stats.timer(",
            "            f\"dagrun.dependency-check.{self.dag_id}\",",
            "            tags=self.stats_tags,",
            "        ):",
            "            dag = self.get_dag()",
            "            info = self.task_instance_scheduling_decisions(session)",
            "",
            "            tis = info.tis",
            "            schedulable_tis = info.schedulable_tis",
            "            changed_tis = info.changed_tis",
            "            finished_tis = info.finished_tis",
            "            unfinished = _UnfinishedStates.calculate(info.unfinished_tis)",
            "",
            "            if unfinished.should_schedule:",
            "                are_runnable_tasks = schedulable_tis or changed_tis",
            "                # small speed up",
            "                if not are_runnable_tasks:",
            "                    are_runnable_tasks, changed_by_upstream = self._are_premature_tis(",
            "                        unfinished.tis, finished_tis, session",
            "                    )",
            "                    if changed_by_upstream:  # Something changed, we need to recalculate!",
            "                        unfinished = unfinished.recalculate()",
            "",
            "        tis_for_dagrun_state = self._tis_for_dagrun_state(dag=dag, tis=tis)",
            "",
            "        # if all tasks finished and at least one failed, the run failed",
            "        if not unfinished.tis and any(x.state in State.failed_states for x in tis_for_dagrun_state):",
            "            self.log.error(\"Marking run %s failed\", self)",
            "            self.set_state(DagRunState.FAILED)",
            "            self.notify_dagrun_state_changed(msg=\"task_failure\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=False, reason=\"task_failure\", session=session)",
            "            elif dag.has_on_failure_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=True,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"task_failure\",",
            "                )",
            "",
            "        # if all leaves succeeded and no unfinished tasks, the run succeeded",
            "        elif not unfinished.tis and all(x.state in State.success_states for x in tis_for_dagrun_state):",
            "            self.log.info(\"Marking run %s successful\", self)",
            "            self.set_state(DagRunState.SUCCESS)",
            "            self.notify_dagrun_state_changed(msg=\"success\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=True, reason=\"success\", session=session)",
            "            elif dag.has_on_success_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=False,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"success\",",
            "                )",
            "",
            "        # if *all tasks* are deadlocked, the run failed",
            "        elif unfinished.should_schedule and not are_runnable_tasks:",
            "            self.log.error(\"Task deadlock (no runnable tasks); marking run %s failed\", self)",
            "            self.set_state(DagRunState.FAILED)",
            "            self.notify_dagrun_state_changed(msg=\"all_tasks_deadlocked\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=False, reason=\"all_tasks_deadlocked\", session=session)",
            "            elif dag.has_on_failure_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=True,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"all_tasks_deadlocked\",",
            "                )",
            "",
            "        # finally, if the roots aren't done, the dag is still running",
            "        else:",
            "            self.set_state(DagRunState.RUNNING)",
            "",
            "        if self._state == DagRunState.FAILED or self._state == DagRunState.SUCCESS:",
            "            msg = (",
            "                \"DagRun Finished: dag_id=%s, execution_date=%s, run_id=%s, \"",
            "                \"run_start_date=%s, run_end_date=%s, run_duration=%s, \"",
            "                \"state=%s, external_trigger=%s, run_type=%s, \"",
            "                \"data_interval_start=%s, data_interval_end=%s, dag_hash=%s\"",
            "            )",
            "            self.log.info(",
            "                msg,",
            "                self.dag_id,",
            "                self.execution_date,",
            "                self.run_id,",
            "                self.start_date,",
            "                self.end_date,",
            "                (self.end_date - self.start_date).total_seconds()",
            "                if self.start_date and self.end_date",
            "                else None,",
            "                self._state,",
            "                self.external_trigger,",
            "                self.run_type,",
            "                self.data_interval_start,",
            "                self.data_interval_end,",
            "                self.dag_hash,",
            "            )",
            "            session.flush()",
            "",
            "        self._emit_true_scheduling_delay_stats_for_finished_state(finished_tis)",
            "        self._emit_duration_stats_for_finished_state()",
            "",
            "        session.merge(self)",
            "        # We do not flush here for performance reasons(It increases queries count by +20)",
            "",
            "        return schedulable_tis, callback",
            "",
            "    @provide_session",
            "    def task_instance_scheduling_decisions(self, session: Session = NEW_SESSION) -> TISchedulingDecision:",
            "        tis = self.get_task_instances(session=session, state=State.task_states)",
            "        self.log.debug(\"number of tis tasks for %s: %s task(s)\", self, len(tis))",
            "",
            "        def _filter_tis_and_exclude_removed(dag: DAG, tis: list[TI]) -> Iterable[TI]:",
            "            \"\"\"Populate ``ti.task`` while excluding those missing one, marking them as REMOVED.\"\"\"",
            "            for ti in tis:",
            "                try:",
            "                    ti.task = dag.get_task(ti.task_id)",
            "                except TaskNotFound:",
            "                    if ti.state != State.REMOVED:",
            "                        self.log.error(\"Failed to get task for ti %s. Marking it as removed.\", ti)",
            "                        ti.state = State.REMOVED",
            "                        session.flush()",
            "                else:",
            "                    yield ti",
            "",
            "        tis = list(_filter_tis_and_exclude_removed(self.get_dag(), tis))",
            "",
            "        unfinished_tis = [t for t in tis if t.state in State.unfinished]",
            "        finished_tis = [t for t in tis if t.state in State.finished]",
            "        if unfinished_tis:",
            "            schedulable_tis = [ut for ut in unfinished_tis if ut.state in SCHEDULEABLE_STATES]",
            "            self.log.debug(\"number of scheduleable tasks for %s: %s task(s)\", self, len(schedulable_tis))",
            "            schedulable_tis, changed_tis, expansion_happened = self._get_ready_tis(",
            "                schedulable_tis,",
            "                finished_tis,",
            "                session=session,",
            "            )",
            "",
            "            # During expansion, we may change some tis into non-schedulable",
            "            # states, so we need to re-compute.",
            "            if expansion_happened:",
            "                changed_tis = True",
            "                new_unfinished_tis = [t for t in unfinished_tis if t.state in State.unfinished]",
            "                finished_tis.extend(t for t in unfinished_tis if t.state in State.finished)",
            "                unfinished_tis = new_unfinished_tis",
            "        else:",
            "            schedulable_tis = []",
            "            changed_tis = False",
            "",
            "        return TISchedulingDecision(",
            "            tis=tis,",
            "            schedulable_tis=schedulable_tis,",
            "            changed_tis=changed_tis,",
            "            unfinished_tis=unfinished_tis,",
            "            finished_tis=finished_tis,",
            "        )",
            "",
            "    def notify_dagrun_state_changed(self, msg: str = \"\"):",
            "        if self.state == DagRunState.RUNNING:",
            "            get_listener_manager().hook.on_dag_run_running(dag_run=self, msg=msg)",
            "        elif self.state == DagRunState.SUCCESS:",
            "            get_listener_manager().hook.on_dag_run_success(dag_run=self, msg=msg)",
            "        elif self.state == DagRunState.FAILED:",
            "            get_listener_manager().hook.on_dag_run_failed(dag_run=self, msg=msg)",
            "        # deliberately not notifying on QUEUED",
            "        # we can't get all the state changes on SchedulerJob, BackfillJob",
            "        # or LocalTaskJob, so we don't want to \"falsely advertise\" we notify about that",
            "",
            "    def _get_ready_tis(",
            "        self,",
            "        schedulable_tis: list[TI],",
            "        finished_tis: list[TI],",
            "        session: Session,",
            "    ) -> tuple[list[TI], bool, bool]:",
            "        old_states = {}",
            "        ready_tis: list[TI] = []",
            "        changed_tis = False",
            "",
            "        if not schedulable_tis:",
            "            return ready_tis, changed_tis, False",
            "",
            "        # If we expand TIs, we need a new list so that we iterate over them too. (We can't alter",
            "        # `schedulable_tis` in place and have the `for` loop pick them up",
            "        additional_tis: list[TI] = []",
            "        dep_context = DepContext(",
            "            flag_upstream_failed=True,",
            "            ignore_unmapped_tasks=True,  # Ignore this Dep, as we will expand it if we can.",
            "            finished_tis=finished_tis,",
            "        )",
            "",
            "        def _expand_mapped_task_if_needed(ti: TI) -> Iterable[TI] | None:",
            "            \"\"\"Try to expand the ti, if needed.",
            "",
            "            If the ti needs expansion, newly created task instances are",
            "            returned as well as the original ti.",
            "            The original ti is also modified in-place and assigned the",
            "            ``map_index`` of 0.",
            "",
            "            If the ti does not need expansion, either because the task is not",
            "            mapped, or has already been expanded, *None* is returned.",
            "            \"\"\"",
            "            if ti.map_index >= 0:  # Already expanded, we're good.",
            "                return None",
            "",
            "            from airflow.models.mappedoperator import MappedOperator",
            "",
            "            if isinstance(ti.task, MappedOperator):",
            "                # If we get here, it could be that we are moving from non-mapped to mapped",
            "                # after task instance clearing or this ti is not yet expanded. Safe to clear",
            "                # the db references.",
            "                ti.clear_db_references(session=session)",
            "            try:",
            "                expanded_tis, _ = ti.task.expand_mapped_task(self.run_id, session=session)",
            "            except NotMapped:  # Not a mapped task, nothing needed.",
            "                return None",
            "            if expanded_tis:",
            "                return expanded_tis",
            "            return ()",
            "",
            "        # Check dependencies.",
            "        expansion_happened = False",
            "        # Set of task ids for which was already done _revise_map_indexes_if_mapped",
            "        revised_map_index_task_ids = set()",
            "        for schedulable in itertools.chain(schedulable_tis, additional_tis):",
            "            old_state = schedulable.state",
            "            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):",
            "                old_states[schedulable.key] = old_state",
            "                continue",
            "            # If schedulable is not yet expanded, try doing it now. This is",
            "            # called in two places: First and ideally in the mini scheduler at",
            "            # the end of LocalTaskJob, and then as an \"expansion of last resort\"",
            "            # in the scheduler to ensure that the mapped task is correctly",
            "            # expanded before executed. Also see _revise_map_indexes_if_mapped",
            "            # docstring for additional information.",
            "            new_tis = None",
            "            if schedulable.map_index < 0:",
            "                new_tis = _expand_mapped_task_if_needed(schedulable)",
            "                if new_tis is not None:",
            "                    additional_tis.extend(new_tis)",
            "                    expansion_happened = True",
            "            if new_tis is None and schedulable.state in SCHEDULEABLE_STATES:",
            "                # It's enough to revise map index once per task id,",
            "                # checking the map index for each mapped task significantly slows down scheduling",
            "                if schedulable.task.task_id not in revised_map_index_task_ids:",
            "                    ready_tis.extend(self._revise_map_indexes_if_mapped(schedulable.task, session=session))",
            "                    revised_map_index_task_ids.add(schedulable.task.task_id)",
            "                ready_tis.append(schedulable)",
            "",
            "        # Check if any ti changed state",
            "        tis_filter = TI.filter_for_tis(old_states)",
            "        if tis_filter is not None:",
            "            fresh_tis = session.scalars(select(TI).where(tis_filter)).all()",
            "            changed_tis = any(ti.state != old_states[ti.key] for ti in fresh_tis)",
            "",
            "        return ready_tis, changed_tis, expansion_happened",
            "",
            "    def _are_premature_tis(",
            "        self,",
            "        unfinished_tis: Sequence[TI],",
            "        finished_tis: list[TI],",
            "        session: Session,",
            "    ) -> tuple[bool, bool]:",
            "        dep_context = DepContext(",
            "            flag_upstream_failed=True,",
            "            ignore_in_retry_period=True,",
            "            ignore_in_reschedule_period=True,",
            "            finished_tis=finished_tis,",
            "        )",
            "        # there might be runnable tasks that are up for retry and for some reason(retry delay, etc.) are",
            "        # not ready yet, so we set the flags to count them in",
            "        return (",
            "            any(ut.are_dependencies_met(dep_context=dep_context, session=session) for ut in unfinished_tis),",
            "            dep_context.have_changed_ti_states,",
            "        )",
            "",
            "    def _emit_true_scheduling_delay_stats_for_finished_state(self, finished_tis: list[TI]) -> None:",
            "        \"\"\"Emit the true scheduling delay stats.",
            "",
            "        The true scheduling delay stats is defined as the time when the first",
            "        task in DAG starts minus the expected DAG run datetime.",
            "",
            "        This helper method is used in ``update_state`` when the state of the",
            "        DAG run is updated to a completed status (either success or failure).",
            "        It finds the first started task within the DAG, calculates the run's",
            "        expected start time based on the logical date and timetable, and gets",
            "        the delay from the difference of these two values.",
            "",
            "        The emitted data may contain outliers (e.g. when the first task was",
            "        cleared, so the second task's start date will be used), but we can get",
            "        rid of the outliers on the stats side through dashboards tooling.",
            "",
            "        Note that the stat will only be emitted for scheduler-triggered DAG runs",
            "        (i.e. when ``external_trigger`` is *False*).",
            "        \"\"\"",
            "        if self.state == TaskInstanceState.RUNNING:",
            "            return",
            "        if self.external_trigger:",
            "            return",
            "        if not finished_tis:",
            "            return",
            "",
            "        try:",
            "            dag = self.get_dag()",
            "",
            "            if not dag.timetable.periodic:",
            "                # We can't emit this metric if there is no following schedule to calculate from!",
            "                return",
            "",
            "            try:",
            "                first_start_date = min(ti.start_date for ti in finished_tis if ti.start_date)",
            "            except ValueError:  # No start dates at all.",
            "                pass",
            "            else:",
            "                # TODO: Logically, this should be DagRunInfo.run_after, but the",
            "                # information is not stored on a DagRun, only before the actual",
            "                # execution on DagModel.next_dagrun_create_after. We should add",
            "                # a field on DagRun for this instead of relying on the run",
            "                # always happening immediately after the data interval.",
            "                data_interval_end = dag.get_run_data_interval(self).end",
            "                true_delay = first_start_date - data_interval_end",
            "                if true_delay.total_seconds() > 0:",
            "                    Stats.timing(",
            "                        f\"dagrun.{dag.dag_id}.first_task_scheduling_delay\", true_delay, tags=self.stats_tags",
            "                    )",
            "                    Stats.timing(\"dagrun.first_task_scheduling_delay\", true_delay, tags=self.stats_tags)",
            "        except Exception:",
            "            self.log.warning(\"Failed to record first_task_scheduling_delay metric:\", exc_info=True)",
            "",
            "    def _emit_duration_stats_for_finished_state(self):",
            "        if self.state == State.RUNNING:",
            "            return",
            "        if self.start_date is None:",
            "            self.log.warning(\"Failed to record duration of %s: start_date is not set.\", self)",
            "            return",
            "        if self.end_date is None:",
            "            self.log.warning(\"Failed to record duration of %s: end_date is not set.\", self)",
            "            return",
            "",
            "        duration = self.end_date - self.start_date",
            "        timer_params = {\"dt\": duration, \"tags\": self.stats_tags}",
            "        Stats.timing(f\"dagrun.duration.{self.state.value}.{self.dag_id}\", **timer_params)",
            "        Stats.timing(f\"dagrun.duration.{self.state.value}\", **timer_params)",
            "",
            "    @provide_session",
            "    def verify_integrity(self, *, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Verifies the DagRun by checking for removed tasks or tasks that are not in the",
            "        database yet. It will set state to removed or add the task if required.",
            "",
            "        :missing_indexes: A dictionary of task vs indexes that are missing.",
            "        :param session: Sqlalchemy ORM Session",
            "        \"\"\"",
            "        from airflow.settings import task_instance_mutation_hook",
            "",
            "        # Set for the empty default in airflow.settings -- if it's not set this means it has been changed",
            "        # Note: Literal[True, False] instead of bool because otherwise it doesn't correctly find the overload.",
            "        hook_is_noop: Literal[True, False] = getattr(task_instance_mutation_hook, \"is_noop\", False)",
            "",
            "        dag = self.get_dag()",
            "        task_ids = self._check_for_removed_or_restored_tasks(",
            "            dag, task_instance_mutation_hook, session=session",
            "        )",
            "",
            "        def task_filter(task: Operator) -> bool:",
            "            return task.task_id not in task_ids and (",
            "                self.is_backfill",
            "                or task.start_date <= self.execution_date",
            "                and (task.end_date is None or self.execution_date <= task.end_date)",
            "            )",
            "",
            "        created_counts: dict[str, int] = defaultdict(int)",
            "        task_creator = self._get_task_creator(created_counts, task_instance_mutation_hook, hook_is_noop)",
            "",
            "        # Create the missing tasks, including mapped tasks",
            "        tasks_to_create = (task for task in dag.task_dict.values() if task_filter(task))",
            "        tis_to_create = self._create_tasks(tasks_to_create, task_creator, session=session)",
            "        self._create_task_instances(self.dag_id, tis_to_create, created_counts, hook_is_noop, session=session)",
            "",
            "    def _check_for_removed_or_restored_tasks(",
            "        self, dag: DAG, ti_mutation_hook, *, session: Session",
            "    ) -> set[str]:",
            "        \"\"\"",
            "        Check for removed tasks/restored/missing tasks.",
            "",
            "        :param dag: DAG object corresponding to the dagrun",
            "        :param ti_mutation_hook: task_instance_mutation_hook function",
            "        :param session: Sqlalchemy ORM Session",
            "",
            "        :return: Task IDs in the DAG run",
            "",
            "        \"\"\"",
            "        tis = self.get_task_instances(session=session)",
            "",
            "        # check for removed or restored tasks",
            "        task_ids = set()",
            "        for ti in tis:",
            "            ti_mutation_hook(ti)",
            "            task_ids.add(ti.task_id)",
            "            try:",
            "                task = dag.get_task(ti.task_id)",
            "",
            "                should_restore_task = (task is not None) and ti.state == State.REMOVED",
            "                if should_restore_task:",
            "                    self.log.info(\"Restoring task '%s' which was previously removed from DAG '%s'\", ti, dag)",
            "                    Stats.incr(f\"task_restored_to_dag.{dag.dag_id}\", tags=self.stats_tags)",
            "                    # Same metric with tagging",
            "                    Stats.incr(\"task_restored_to_dag\", tags={**self.stats_tags, \"dag_id\": dag.dag_id})",
            "                    ti.state = State.NONE",
            "            except AirflowException:",
            "                if ti.state == State.REMOVED:",
            "                    pass  # ti has already been removed, just ignore it",
            "                elif self.state != State.RUNNING and not dag.partial:",
            "                    self.log.warning(\"Failed to get task '%s' for dag '%s'. Marking it as removed.\", ti, dag)",
            "                    Stats.incr(f\"task_removed_from_dag.{dag.dag_id}\", tags=self.stats_tags)",
            "                    # Same metric with tagging",
            "                    Stats.incr(\"task_removed_from_dag\", tags={**self.stats_tags, \"dag_id\": dag.dag_id})",
            "                    ti.state = State.REMOVED",
            "                continue",
            "",
            "            try:",
            "                num_mapped_tis = task.get_parse_time_mapped_ti_count()",
            "            except NotMapped:",
            "                continue",
            "            except NotFullyPopulated:",
            "                # What if it is _now_ dynamically mapped, but wasn't before?",
            "                try:",
            "                    total_length = task.get_mapped_ti_count(self.run_id, session=session)",
            "                except NotFullyPopulated:",
            "                    # Not all upstreams finished, so we can't tell what should be here. Remove everything.",
            "                    if ti.map_index >= 0:",
            "                        self.log.debug(",
            "                            \"Removing the unmapped TI '%s' as the mapping can't be resolved yet\", ti",
            "                        )",
            "                        ti.state = State.REMOVED",
            "                    continue",
            "                # Upstreams finished, check there aren't any extras",
            "                if ti.map_index >= total_length:",
            "                    self.log.debug(",
            "                        \"Removing task '%s' as the map_index is longer than the resolved mapping list (%d)\",",
            "                        ti,",
            "                        total_length,",
            "                    )",
            "                    ti.state = State.REMOVED",
            "            else:",
            "                # Check if the number of mapped literals has changed, and we need to mark this TI as removed.",
            "                if ti.map_index >= num_mapped_tis:",
            "                    self.log.debug(",
            "                        \"Removing task '%s' as the map_index is longer than the literal mapping list (%s)\",",
            "                        ti,",
            "                        num_mapped_tis,",
            "                    )",
            "                    ti.state = State.REMOVED",
            "                elif ti.map_index < 0:",
            "                    self.log.debug(\"Removing the unmapped TI '%s' as the mapping can now be performed\", ti)",
            "                    ti.state = State.REMOVED",
            "",
            "        return task_ids",
            "",
            "    @overload",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[True],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[dict[str, Any]]]:",
            "        ...",
            "",
            "    @overload",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[False],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[TI]]:",
            "        ...",
            "",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[True, False],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[dict[str, Any]] | Iterator[TI]]:",
            "        \"\"\"",
            "        Get the task creator function.",
            "",
            "        This function also updates the created_counts dictionary with the number of tasks created.",
            "",
            "        :param created_counts: Dictionary of task_type -> count of created TIs",
            "        :param ti_mutation_hook: task_instance_mutation_hook function",
            "        :param hook_is_noop: Whether the task_instance_mutation_hook is a noop",
            "",
            "        \"\"\"",
            "        if hook_is_noop:",
            "",
            "            def create_ti_mapping(task: Operator, indexes: Iterable[int]) -> Iterator[dict[str, Any]]:",
            "                created_counts[task.task_type] += 1",
            "                for map_index in indexes:",
            "                    yield TI.insert_mapping(self.run_id, task, map_index=map_index)",
            "",
            "            creator = create_ti_mapping",
            "",
            "        else:",
            "",
            "            def create_ti(task: Operator, indexes: Iterable[int]) -> Iterator[TI]:",
            "                for map_index in indexes:",
            "                    ti = TI(task, run_id=self.run_id, map_index=map_index)",
            "                    ti_mutation_hook(ti)",
            "                    created_counts[ti.operator] += 1",
            "                    yield ti",
            "",
            "            creator = create_ti",
            "        return creator",
            "",
            "    def _create_tasks(",
            "        self,",
            "        tasks: Iterable[Operator],",
            "        task_creator: TaskCreator,",
            "        *,",
            "        session: Session,",
            "    ) -> CreatedTasks:",
            "        \"\"\"",
            "        Create missing tasks -- and expand any MappedOperator that _only_ have literals as input.",
            "",
            "        :param tasks: Tasks to create jobs for in the DAG run",
            "        :param task_creator: Function to create task instances",
            "        \"\"\"",
            "        map_indexes: Iterable[int]",
            "        for task in tasks:",
            "            try:",
            "                count = task.get_mapped_ti_count(self.run_id, session=session)",
            "            except (NotMapped, NotFullyPopulated):",
            "                map_indexes = (-1,)",
            "            else:",
            "                if count:",
            "                    map_indexes = range(count)",
            "                else:",
            "                    # Make sure to always create at least one ti; this will be",
            "                    # marked as REMOVED later at runtime.",
            "                    map_indexes = (-1,)",
            "            yield from task_creator(task, map_indexes)",
            "",
            "    def _create_task_instances(",
            "        self,",
            "        dag_id: str,",
            "        tasks: Iterator[dict[str, Any]] | Iterator[TI],",
            "        created_counts: dict[str, int],",
            "        hook_is_noop: bool,",
            "        *,",
            "        session: Session,",
            "    ) -> None:",
            "        \"\"\"",
            "        Create the necessary task instances from the given tasks.",
            "",
            "        :param dag_id: DAG ID associated with the dagrun",
            "        :param tasks: the tasks to create the task instances from",
            "        :param created_counts: a dictionary of number of tasks -> total ti created by the task creator",
            "        :param hook_is_noop: whether the task_instance_mutation_hook is noop",
            "        :param session: the session to use",
            "",
            "        \"\"\"",
            "        # Fetch the information we need before handling the exception to avoid",
            "        # PendingRollbackError due to the session being invalidated on exception",
            "        # see https://github.com/apache/superset/pull/530",
            "        run_id = self.run_id",
            "        try:",
            "            if hook_is_noop:",
            "                session.bulk_insert_mappings(TI, tasks)",
            "            else:",
            "                session.bulk_save_objects(tasks)",
            "",
            "            for task_type, count in created_counts.items():",
            "                Stats.incr(f\"task_instance_created_{task_type}\", count, tags=self.stats_tags)",
            "                # Same metric with tagging",
            "                Stats.incr(\"task_instance_created\", count, tags={**self.stats_tags, \"task_type\": task_type})",
            "            session.flush()",
            "        except IntegrityError:",
            "            self.log.info(",
            "                \"Hit IntegrityError while creating the TIs for %s- %s\",",
            "                dag_id,",
            "                run_id,",
            "                exc_info=True,",
            "            )",
            "            self.log.info(\"Doing session rollback.\")",
            "            # TODO[HA]: We probably need to savepoint this so we can keep the transaction alive.",
            "            session.rollback()",
            "",
            "    def _revise_map_indexes_if_mapped(self, task: Operator, *, session: Session) -> Iterator[TI]:",
            "        \"\"\"Check if task increased or reduced in length and handle appropriately.",
            "",
            "        Task instances that do not already exist are created and returned if",
            "        possible. Expansion only happens if all upstreams are ready; otherwise",
            "        we delay expansion to the \"last resort\". See comments at the call site",
            "        for more details.",
            "        \"\"\"",
            "        from airflow.settings import task_instance_mutation_hook",
            "",
            "        try:",
            "            total_length = task.get_mapped_ti_count(self.run_id, session=session)",
            "        except NotMapped:",
            "            return  # Not a mapped task, don't need to do anything.",
            "        except NotFullyPopulated:",
            "            return  # Upstreams not ready, don't need to revise this yet.",
            "",
            "        query = session.scalars(",
            "            select(TI.map_index).where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.task_id == task.task_id,",
            "                TI.run_id == self.run_id,",
            "            )",
            "        )",
            "        existing_indexes = {i for i in query}",
            "",
            "        removed_indexes = existing_indexes.difference(range(total_length))",
            "        if removed_indexes:",
            "            session.execute(",
            "                update(TI)",
            "                .where(",
            "                    TI.dag_id == self.dag_id,",
            "                    TI.task_id == task.task_id,",
            "                    TI.run_id == self.run_id,",
            "                    TI.map_index.in_(removed_indexes),",
            "                )",
            "                .values(state=TaskInstanceState.REMOVED)",
            "            )",
            "            session.flush()",
            "",
            "        for index in range(total_length):",
            "            if index in existing_indexes:",
            "                continue",
            "            ti = TI(task, run_id=self.run_id, map_index=index, state=None)",
            "            self.log.debug(\"Expanding TIs upserted %s\", ti)",
            "            task_instance_mutation_hook(ti)",
            "            ti = session.merge(ti)",
            "            ti.refresh_from_task(task)",
            "            session.flush()",
            "            yield ti",
            "",
            "    @staticmethod",
            "    def get_run(session: Session, dag_id: str, execution_date: datetime) -> DagRun | None:",
            "        \"\"\"",
            "        Get a single DAG Run.",
            "",
            "        :meta private:",
            "        :param session: Sqlalchemy ORM Session",
            "        :param dag_id: DAG ID",
            "        :param execution_date: execution date",
            "        :return: DagRun corresponding to the given dag_id and execution date",
            "            if one exists. None otherwise.",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated. Please use SQLAlchemy directly\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return session.scalar(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == dag_id,",
            "                DagRun.external_trigger == False,  # noqa",
            "                DagRun.execution_date == execution_date,",
            "            )",
            "        )",
            "",
            "    @property",
            "    def is_backfill(self) -> bool:",
            "        return self.run_type == DagRunType.BACKFILL_JOB",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def get_latest_runs(cls, session: Session = NEW_SESSION) -> list[DagRun]:",
            "        \"\"\"Returns the latest DagRun for each DAG.\"\"\"",
            "        subquery = (",
            "            select(cls.dag_id, func.max(cls.execution_date).label(\"execution_date\"))",
            "            .group_by(cls.dag_id)",
            "            .subquery()",
            "        )",
            "        return session.scalars(",
            "            select(cls).join(",
            "                subquery,",
            "                and_(cls.dag_id == subquery.c.dag_id, cls.execution_date == subquery.c.execution_date),",
            "            )",
            "        ).all()",
            "",
            "    @provide_session",
            "    def schedule_tis(",
            "        self,",
            "        schedulable_tis: Iterable[TI],",
            "        session: Session = NEW_SESSION,",
            "        max_tis_per_query: int | None = None,",
            "    ) -> int:",
            "        \"\"\"",
            "        Set the given task instances in to the scheduled state.",
            "",
            "        Each element of ``schedulable_tis`` should have it's ``task`` attribute already set.",
            "",
            "        Any EmptyOperator without callbacks or outlets is instead set straight to the success state.",
            "",
            "        All the TIs should belong to this DagRun, but this code is in the hot-path, this is not checked -- it",
            "        is the caller's responsibility to call this function only with TIs from a single dag run.",
            "        \"\"\"",
            "        # Get list of TI IDs that do not need to executed, these are",
            "        # tasks using EmptyOperator and without on_execute_callback / on_success_callback",
            "        dummy_ti_ids = []",
            "        schedulable_ti_ids = []",
            "        for ti in schedulable_tis:",
            "            if (",
            "                ti.task.inherits_from_empty_operator",
            "                and not ti.task.on_execute_callback",
            "                and not ti.task.on_success_callback",
            "                and not ti.task.outlets",
            "            ):",
            "                dummy_ti_ids.append(ti.task_id)",
            "            else:",
            "                schedulable_ti_ids.append((ti.task_id, ti.map_index))",
            "",
            "        count = 0",
            "",
            "        if schedulable_ti_ids:",
            "            schedulable_ti_ids_chunks = chunks(",
            "                schedulable_ti_ids, max_tis_per_query or len(schedulable_ti_ids)",
            "            )",
            "            for schedulable_ti_ids_chunk in schedulable_ti_ids_chunks:",
            "                count += session.execute(",
            "                    update(TI)",
            "                    .where(",
            "                        TI.dag_id == self.dag_id,",
            "                        TI.run_id == self.run_id,",
            "                        tuple_in_condition((TI.task_id, TI.map_index), schedulable_ti_ids_chunk),",
            "                    )",
            "                    .values(state=TaskInstanceState.SCHEDULED)",
            "                    .execution_options(synchronize_session=False)",
            "                ).rowcount",
            "",
            "        # Tasks using EmptyOperator should not be executed, mark them as success",
            "        if dummy_ti_ids:",
            "            dummy_ti_ids_chunks = chunks(dummy_ti_ids, max_tis_per_query or len(dummy_ti_ids))",
            "            for dummy_ti_ids_chunk in dummy_ti_ids_chunks:",
            "                count += session.execute(",
            "                    update(TI)",
            "                    .where(",
            "                        TI.dag_id == self.dag_id,",
            "                        TI.run_id == self.run_id,",
            "                        TI.task_id.in_(dummy_ti_ids_chunk),",
            "                    )",
            "                    .values(",
            "                        state=TaskInstanceState.SUCCESS,",
            "                        start_date=timezone.utcnow(),",
            "                        end_date=timezone.utcnow(),",
            "                        duration=0,",
            "                    )",
            "                    .execution_options(",
            "                        synchronize_session=False,",
            "                    )",
            "                ).rowcount",
            "",
            "        return count",
            "",
            "    @provide_session",
            "    def get_log_template(self, *, session: Session = NEW_SESSION) -> LogTemplate:",
            "        if self.log_template_id is None:  # DagRun created before LogTemplate introduction.",
            "            template = session.scalar(select(LogTemplate).order_by(LogTemplate.id))",
            "        else:",
            "            template = session.get(LogTemplate, self.log_template_id)",
            "        if template is None:",
            "            raise AirflowException(",
            "                f\"No log_template entry found for ID {self.log_template_id!r}. \"",
            "                f\"Please make sure you set up the metadatabase correctly.\"",
            "            )",
            "        return template",
            "",
            "    @provide_session",
            "    def get_log_filename_template(self, *, session: Session = NEW_SESSION) -> str:",
            "        warnings.warn(",
            "            \"This method is deprecated. Please use get_log_template instead.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_log_template(session=session).filename",
            "",
            "",
            "class DagRunNote(Base):",
            "    \"\"\"For storage of arbitrary notes concerning the dagrun instance.\"\"\"",
            "",
            "    __tablename__ = \"dag_run_note\"",
            "",
            "    user_id = Column(Integer, nullable=True)",
            "    dag_run_id = Column(Integer, primary_key=True, nullable=False)",
            "    content = Column(String(1000).with_variant(Text(1000), \"mysql\"))",
            "    created_at = Column(UtcDateTime, default=timezone.utcnow, nullable=False)",
            "    updated_at = Column(UtcDateTime, default=timezone.utcnow, onupdate=timezone.utcnow, nullable=False)",
            "",
            "    dag_run = relationship(\"DagRun\", back_populates=\"dag_run_note\")",
            "",
            "    __table_args__ = (",
            "        PrimaryKeyConstraint(\"dag_run_id\", name=\"dag_run_note_pkey\"),",
            "        ForeignKeyConstraint(",
            "            (dag_run_id,),",
            "            [\"dag_run.id\"],",
            "            name=\"dag_run_note_dr_fkey\",",
            "            ondelete=\"CASCADE\",",
            "        ),",
            "        ForeignKeyConstraint(",
            "            (user_id,),",
            "            [\"ab_user.id\"],",
            "            name=\"dag_run_note_user_fkey\",",
            "        ),",
            "    )",
            "",
            "    def __init__(self, content, user_id=None):",
            "        self.content = content",
            "        self.user_id = user_id",
            "",
            "    def __repr__(self):",
            "        prefix = f\"<{self.__class__.__name__}: {self.dag_id}.{self.dagrun_id} {self.run_id}\"",
            "        if self.map_index != -1:",
            "            prefix += f\" map_index={self.map_index}\"",
            "        return prefix + \">\""
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import itertools",
            "import os",
            "import warnings",
            "from collections import defaultdict",
            "from datetime import datetime",
            "from typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, NamedTuple, Sequence, TypeVar, overload",
            "",
            "import re2 as re",
            "from sqlalchemy import (",
            "    Boolean,",
            "    Column,",
            "    ForeignKey,",
            "    ForeignKeyConstraint,",
            "    Index,",
            "    Integer,",
            "    PickleType,",
            "    PrimaryKeyConstraint,",
            "    String,",
            "    Text,",
            "    UniqueConstraint,",
            "    and_,",
            "    func,",
            "    or_,",
            "    text,",
            "    update,",
            ")",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.associationproxy import association_proxy",
            "from sqlalchemy.orm import Query, Session, declared_attr, joinedload, relationship, synonym, validates",
            "from sqlalchemy.sql.expression import false, select, true",
            "",
            "from airflow import settings",
            "from airflow.callbacks.callback_requests import DagCallbackRequest",
            "from airflow.configuration import conf as airflow_conf",
            "from airflow.exceptions import AirflowException, RemovedInAirflow3Warning, TaskNotFound",
            "from airflow.listeners.listener import get_listener_manager",
            "from airflow.models.abstractoperator import NotMapped",
            "from airflow.models.base import Base, StringID",
            "from airflow.models.expandinput import NotFullyPopulated",
            "from airflow.models.taskinstance import TaskInstance as TI",
            "from airflow.models.tasklog import LogTemplate",
            "from airflow.stats import Stats",
            "from airflow.ti_deps.dep_context import DepContext",
            "from airflow.ti_deps.dependencies_states import SCHEDULEABLE_STATES",
            "from airflow.typing_compat import Literal",
            "from airflow.utils import timezone",
            "from airflow.utils.helpers import chunks, is_container, prune_dict",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import UtcDateTime, nulls_first, skip_locked, tuple_in_condition, with_row_locks",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.types import NOTSET, ArgNotSet, DagRunType",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.models.dag import DAG",
            "    from airflow.models.operator import Operator",
            "",
            "    CreatedTasks = TypeVar(\"CreatedTasks\", Iterator[\"dict[str, Any]\"], Iterator[TI])",
            "    TaskCreator = Callable[[Operator, Iterable[int]], CreatedTasks]",
            "",
            "RUN_ID_REGEX = r\"^(?:manual|scheduled|dataset_triggered)__(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\+00:00)$\"",
            "",
            "",
            "class TISchedulingDecision(NamedTuple):",
            "    \"\"\"Type of return for DagRun.task_instance_scheduling_decisions.\"\"\"",
            "",
            "    tis: list[TI]",
            "    schedulable_tis: list[TI]",
            "    changed_tis: bool",
            "    unfinished_tis: list[TI]",
            "    finished_tis: list[TI]",
            "",
            "",
            "def _creator_note(val):",
            "    \"\"\"Custom creator for the ``note`` association proxy.\"\"\"",
            "    if isinstance(val, str):",
            "        return DagRunNote(content=val)",
            "    elif isinstance(val, dict):",
            "        return DagRunNote(**val)",
            "    else:",
            "        return DagRunNote(*val)",
            "",
            "",
            "class DagRun(Base, LoggingMixin):",
            "    \"\"\"Invocation instance of a DAG.",
            "",
            "    A DAG run can be created by the scheduler (i.e. scheduled runs), or by an",
            "    external trigger (i.e. manual runs).",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_run\"",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    dag_id = Column(StringID(), nullable=False)",
            "    queued_at = Column(UtcDateTime)",
            "    execution_date = Column(UtcDateTime, default=timezone.utcnow, nullable=False)",
            "    start_date = Column(UtcDateTime)",
            "    end_date = Column(UtcDateTime)",
            "    _state = Column(\"state\", String(50), default=State.QUEUED)",
            "    run_id = Column(StringID(), nullable=False)",
            "    creating_job_id = Column(Integer)",
            "    external_trigger = Column(Boolean, default=True)",
            "    run_type = Column(String(50), nullable=False)",
            "    conf = Column(PickleType)",
            "    # These two must be either both NULL or both datetime.",
            "    data_interval_start = Column(UtcDateTime)",
            "    data_interval_end = Column(UtcDateTime)",
            "    # When a scheduler last attempted to schedule TIs for this DagRun",
            "    last_scheduling_decision = Column(UtcDateTime)",
            "    dag_hash = Column(String(32))",
            "    # Foreign key to LogTemplate. DagRun rows created prior to this column's",
            "    # existence have this set to NULL. Later rows automatically populate this on",
            "    # insert to point to the latest LogTemplate entry.",
            "    log_template_id = Column(",
            "        Integer,",
            "        ForeignKey(\"log_template.id\", name=\"task_instance_log_template_id_fkey\", ondelete=\"NO ACTION\"),",
            "        default=select(func.max(LogTemplate.__table__.c.id)),",
            "    )",
            "    updated_at = Column(UtcDateTime, default=timezone.utcnow, onupdate=timezone.utcnow)",
            "",
            "    # Remove this `if` after upgrading Sphinx-AutoAPI",
            "    if not TYPE_CHECKING and \"BUILDING_AIRFLOW_DOCS\" in os.environ:",
            "        dag: DAG | None",
            "    else:",
            "        dag: DAG | None = None",
            "",
            "    __table_args__ = (",
            "        Index(\"dag_id_state\", dag_id, _state),",
            "        UniqueConstraint(\"dag_id\", \"execution_date\", name=\"dag_run_dag_id_execution_date_key\"),",
            "        UniqueConstraint(\"dag_id\", \"run_id\", name=\"dag_run_dag_id_run_id_key\"),",
            "        Index(\"idx_last_scheduling_decision\", last_scheduling_decision),",
            "        Index(\"idx_dag_run_dag_id\", dag_id),",
            "        Index(",
            "            \"idx_dag_run_running_dags\",",
            "            \"state\",",
            "            \"dag_id\",",
            "            postgresql_where=text(\"state='running'\"),",
            "            mssql_where=text(\"state='running'\"),",
            "            sqlite_where=text(\"state='running'\"),",
            "        ),",
            "        # since mysql lacks filtered/partial indices, this creates a",
            "        # duplicate index on mysql. Not the end of the world",
            "        Index(",
            "            \"idx_dag_run_queued_dags\",",
            "            \"state\",",
            "            \"dag_id\",",
            "            postgresql_where=text(\"state='queued'\"),",
            "            mssql_where=text(\"state='queued'\"),",
            "            sqlite_where=text(\"state='queued'\"),",
            "        ),",
            "    )",
            "",
            "    task_instances = relationship(",
            "        TI, back_populates=\"dag_run\", cascade=\"save-update, merge, delete, delete-orphan\"",
            "    )",
            "    dag_model = relationship(",
            "        \"DagModel\",",
            "        primaryjoin=\"foreign(DagRun.dag_id) == DagModel.dag_id\",",
            "        uselist=False,",
            "        viewonly=True,",
            "    )",
            "    dag_run_note = relationship(",
            "        \"DagRunNote\",",
            "        back_populates=\"dag_run\",",
            "        uselist=False,",
            "        cascade=\"all, delete, delete-orphan\",",
            "    )",
            "    note = association_proxy(\"dag_run_note\", \"content\", creator=_creator_note)",
            "",
            "    DEFAULT_DAGRUNS_TO_EXAMINE = airflow_conf.getint(",
            "        \"scheduler\",",
            "        \"max_dagruns_per_loop_to_schedule\",",
            "        fallback=20,",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        dag_id: str | None = None,",
            "        run_id: str | None = None,",
            "        queued_at: datetime | None | ArgNotSet = NOTSET,",
            "        execution_date: datetime | None = None,",
            "        start_date: datetime | None = None,",
            "        external_trigger: bool | None = None,",
            "        conf: Any | None = None,",
            "        state: DagRunState | None = None,",
            "        run_type: str | None = None,",
            "        dag_hash: str | None = None,",
            "        creating_job_id: int | None = None,",
            "        data_interval: tuple[datetime, datetime] | None = None,",
            "    ):",
            "        if data_interval is None:",
            "            # Legacy: Only happen for runs created prior to Airflow 2.2.",
            "            self.data_interval_start = self.data_interval_end = None",
            "        else:",
            "            self.data_interval_start, self.data_interval_end = data_interval",
            "",
            "        self.dag_id = dag_id",
            "        self.run_id = run_id",
            "        self.execution_date = execution_date",
            "        self.start_date = start_date",
            "        self.external_trigger = external_trigger",
            "        self.conf = conf or {}",
            "        if state is not None:",
            "            self.state = state",
            "        if queued_at is NOTSET:",
            "            self.queued_at = timezone.utcnow() if state == State.QUEUED else None",
            "        else:",
            "            self.queued_at = queued_at",
            "        self.run_type = run_type",
            "        self.dag_hash = dag_hash",
            "        self.creating_job_id = creating_job_id",
            "        super().__init__()",
            "",
            "    def __repr__(self):",
            "        return (",
            "            \"<DagRun {dag_id} @ {execution_date}: {run_id}, state:{state}, \"",
            "            \"queued_at: {queued_at}. externally triggered: {external_trigger}>\"",
            "        ).format(",
            "            dag_id=self.dag_id,",
            "            execution_date=self.execution_date,",
            "            run_id=self.run_id,",
            "            state=self.state,",
            "            queued_at=self.queued_at,",
            "            external_trigger=self.external_trigger,",
            "        )",
            "",
            "    @validates(\"run_id\")",
            "    def validate_run_id(self, key: str, run_id: str) -> str | None:",
            "        if not run_id:",
            "            return None",
            "        regex = airflow_conf.get(\"scheduler\", \"allowed_run_id_pattern\")",
            "        if not re.match(regex, run_id) and not re.match(RUN_ID_REGEX, run_id):",
            "            raise ValueError(",
            "                f\"The run_id provided '{run_id}' does not match the pattern '{regex}' or '{RUN_ID_REGEX}'\"",
            "            )",
            "        return run_id",
            "",
            "    @property",
            "    def stats_tags(self) -> dict[str, str]:",
            "        return prune_dict({\"dag_id\": self.dag_id, \"run_type\": self.run_type})",
            "",
            "    @property",
            "    def logical_date(self) -> datetime:",
            "        return self.execution_date",
            "",
            "    def get_state(self):",
            "        return self._state",
            "",
            "    def set_state(self, state: DagRunState):",
            "        if state not in State.dag_states:",
            "            raise ValueError(f\"invalid DagRun state: {state}\")",
            "        if self._state != state:",
            "            self._state = state",
            "            self.end_date = timezone.utcnow() if self._state in State.finished else None",
            "            if state == State.QUEUED:",
            "                self.queued_at = timezone.utcnow()",
            "",
            "    @declared_attr",
            "    def state(self):",
            "        return synonym(\"_state\", descriptor=property(self.get_state, self.set_state))",
            "",
            "    @provide_session",
            "    def refresh_from_db(self, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Reloads the current dagrun from the database.",
            "",
            "        :param session: database session",
            "        \"\"\"",
            "        dr = session.scalars(",
            "            select(DagRun).where(DagRun.dag_id == self.dag_id, DagRun.run_id == self.run_id)",
            "        ).one()",
            "        self.id = dr.id",
            "        self.state = dr.state",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def active_runs_of_dags(",
            "        cls,",
            "        dag_ids: Iterable[str] | None = None,",
            "        only_running: bool = False,",
            "        session: Session = NEW_SESSION,",
            "    ) -> dict[str, int]:",
            "        \"\"\"Get the number of active dag runs for each dag.\"\"\"",
            "        query = select(cls.dag_id, func.count(\"*\"))",
            "        if dag_ids is not None:",
            "            # 'set' called to avoid duplicate dag_ids, but converted back to 'list'",
            "            # because SQLAlchemy doesn't accept a set here.",
            "            query = query.where(cls.dag_id.in_(set(dag_ids)))",
            "        if only_running:",
            "            query = query.where(cls.state == State.RUNNING)",
            "        else:",
            "            query = query.where(cls.state.in_([State.RUNNING, State.QUEUED]))",
            "        query = query.group_by(cls.dag_id)",
            "        return {dag_id: count for dag_id, count in session.execute(query)}",
            "",
            "    @classmethod",
            "    def next_dagruns_to_examine(",
            "        cls,",
            "        state: DagRunState,",
            "        session: Session,",
            "        max_number: int | None = None,",
            "    ) -> Query:",
            "        \"\"\"",
            "        Return the next DagRuns that the scheduler should attempt to schedule.",
            "",
            "        This will return zero or more DagRun rows that are row-level-locked with a \"SELECT ... FOR UPDATE\"",
            "        query, you should ensure that any scheduling decisions are made in a single transaction -- as soon as",
            "        the transaction is committed it will be unlocked.",
            "",
            "        \"\"\"",
            "        from airflow.models.dag import DagModel",
            "",
            "        if max_number is None:",
            "            max_number = cls.DEFAULT_DAGRUNS_TO_EXAMINE",
            "",
            "        # TODO: Bake this query, it is run _A lot_",
            "        query = (",
            "            select(cls)",
            "            .with_hint(cls, \"USE INDEX (idx_dag_run_running_dags)\", dialect_name=\"mysql\")",
            "            .where(cls.state == state, cls.run_type != DagRunType.BACKFILL_JOB)",
            "            .join(DagModel, DagModel.dag_id == cls.dag_id)",
            "            .where(DagModel.is_paused == false(), DagModel.is_active == true())",
            "        )",
            "        if state == State.QUEUED:",
            "            # For dag runs in the queued state, we check if they have reached the max_active_runs limit",
            "            # and if so we drop them",
            "            running_drs = (",
            "                select(DagRun.dag_id, func.count(DagRun.state).label(\"num_running\"))",
            "                .where(DagRun.state == DagRunState.RUNNING)",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            query = query.outerjoin(running_drs, running_drs.c.dag_id == DagRun.dag_id).where(",
            "                func.coalesce(running_drs.c.num_running, 0) < DagModel.max_active_runs",
            "            )",
            "        query = query.order_by(",
            "            nulls_first(cls.last_scheduling_decision, session=session),",
            "            cls.execution_date,",
            "        )",
            "",
            "        if not settings.ALLOW_FUTURE_EXEC_DATES:",
            "            query = query.where(DagRun.execution_date <= func.now())",
            "",
            "        return session.scalars(",
            "            with_row_locks(query.limit(max_number), of=cls, session=session, **skip_locked(session=session))",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def find(",
            "        cls,",
            "        dag_id: str | list[str] | None = None,",
            "        run_id: Iterable[str] | None = None,",
            "        execution_date: datetime | Iterable[datetime] | None = None,",
            "        state: DagRunState | None = None,",
            "        external_trigger: bool | None = None,",
            "        no_backfills: bool = False,",
            "        run_type: DagRunType | None = None,",
            "        session: Session = NEW_SESSION,",
            "        execution_start_date: datetime | None = None,",
            "        execution_end_date: datetime | None = None,",
            "    ) -> list[DagRun]:",
            "        \"\"\"",
            "        Returns a set of dag runs for the given search criteria.",
            "",
            "        :param dag_id: the dag_id or list of dag_id to find dag runs for",
            "        :param run_id: defines the run id for this dag run",
            "        :param run_type: type of DagRun",
            "        :param execution_date: the execution date",
            "        :param state: the state of the dag run",
            "        :param external_trigger: whether this dag run is externally triggered",
            "        :param no_backfills: return no backfills (True), return all (False).",
            "            Defaults to False",
            "        :param session: database session",
            "        :param execution_start_date: dag run that was executed from this date",
            "        :param execution_end_date: dag run that was executed until this date",
            "        \"\"\"",
            "        qry = select(cls)",
            "        dag_ids = [dag_id] if isinstance(dag_id, str) else dag_id",
            "        if dag_ids:",
            "            qry = qry.where(cls.dag_id.in_(dag_ids))",
            "",
            "        if is_container(run_id):",
            "            qry = qry.where(cls.run_id.in_(run_id))",
            "        elif run_id is not None:",
            "            qry = qry.where(cls.run_id == run_id)",
            "        if is_container(execution_date):",
            "            qry = qry.where(cls.execution_date.in_(execution_date))",
            "        elif execution_date is not None:",
            "            qry = qry.where(cls.execution_date == execution_date)",
            "        if execution_start_date and execution_end_date:",
            "            qry = qry.where(cls.execution_date.between(execution_start_date, execution_end_date))",
            "        elif execution_start_date:",
            "            qry = qry.where(cls.execution_date >= execution_start_date)",
            "        elif execution_end_date:",
            "            qry = qry.where(cls.execution_date <= execution_end_date)",
            "        if state:",
            "            qry = qry.where(cls.state == state)",
            "        if external_trigger is not None:",
            "            qry = qry.where(cls.external_trigger == external_trigger)",
            "        if run_type:",
            "            qry = qry.where(cls.run_type == run_type)",
            "        if no_backfills:",
            "            qry = qry.where(cls.run_type != DagRunType.BACKFILL_JOB)",
            "",
            "        return session.scalars(qry.order_by(cls.execution_date)).all()",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def find_duplicate(",
            "        cls,",
            "        dag_id: str,",
            "        run_id: str,",
            "        execution_date: datetime,",
            "        session: Session = NEW_SESSION,",
            "    ) -> DagRun | None:",
            "        \"\"\"",
            "        Return an existing run for the DAG with a specific run_id or execution_date.",
            "",
            "        *None* is returned if no such DAG run is found.",
            "",
            "        :param dag_id: the dag_id to find duplicates for",
            "        :param run_id: defines the run id for this dag run",
            "        :param execution_date: the execution date",
            "        :param session: database session",
            "        \"\"\"",
            "        return session.scalars(",
            "            select(cls).where(",
            "                cls.dag_id == dag_id,",
            "                or_(cls.run_id == run_id, cls.execution_date == execution_date),",
            "            )",
            "        ).one_or_none()",
            "",
            "    @staticmethod",
            "    def generate_run_id(run_type: DagRunType, execution_date: datetime) -> str:",
            "        \"\"\"Generate Run ID based on Run Type and Execution Date.\"\"\"",
            "        # _Ensure_ run_type is a DagRunType, not just a string from user code",
            "        return DagRunType(run_type).generate_run_id(execution_date)",
            "",
            "    @provide_session",
            "    def get_task_instances(",
            "        self,",
            "        state: Iterable[TaskInstanceState | None] | None = None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> list[TI]:",
            "        \"\"\"Returns the task instances for this dag run.\"\"\"",
            "        tis = (",
            "            select(TI)",
            "            .options(joinedload(TI.dag_run))",
            "            .where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.run_id == self.run_id,",
            "            )",
            "        )",
            "",
            "        if state:",
            "            if isinstance(state, str):",
            "                tis = tis.where(TI.state == state)",
            "            else:",
            "                # this is required to deal with NULL values",
            "                if State.NONE in state:",
            "                    if all(x is None for x in state):",
            "                        tis = tis.where(TI.state.is_(None))",
            "                    else:",
            "                        not_none_state = [s for s in state if s]",
            "                        tis = tis.where(or_(TI.state.in_(not_none_state), TI.state.is_(None)))",
            "                else:",
            "                    tis = tis.where(TI.state.in_(state))",
            "",
            "        if self.dag and self.dag.partial:",
            "            tis = tis.where(TI.task_id.in_(self.dag.task_ids))",
            "        return session.scalars(tis).all()",
            "",
            "    @provide_session",
            "    def get_task_instance(",
            "        self,",
            "        task_id: str,",
            "        session: Session = NEW_SESSION,",
            "        *,",
            "        map_index: int = -1,",
            "    ) -> TI | None:",
            "        \"\"\"",
            "        Returns the task instance specified by task_id for this dag run.",
            "",
            "        :param task_id: the task id",
            "        :param session: Sqlalchemy ORM Session",
            "        \"\"\"",
            "        return session.scalars(",
            "            select(TI).filter_by(dag_id=self.dag_id, run_id=self.run_id, task_id=task_id, map_index=map_index)",
            "        ).one_or_none()",
            "",
            "    def get_dag(self) -> DAG:",
            "        \"\"\"",
            "        Returns the Dag associated with this DagRun.",
            "",
            "        :return: DAG",
            "        \"\"\"",
            "        if not self.dag:",
            "            raise AirflowException(f\"The DAG (.dag) for {self} needs to be set\")",
            "",
            "        return self.dag",
            "",
            "    @provide_session",
            "    def get_previous_dagrun(",
            "        self, state: DagRunState | None = None, session: Session = NEW_SESSION",
            "    ) -> DagRun | None:",
            "        \"\"\"The previous DagRun, if there is one.\"\"\"",
            "        filters = [",
            "            DagRun.dag_id == self.dag_id,",
            "            DagRun.execution_date < self.execution_date,",
            "        ]",
            "        if state is not None:",
            "            filters.append(DagRun.state == state)",
            "        return session.scalar(select(DagRun).where(*filters).order_by(DagRun.execution_date.desc()))",
            "",
            "    @provide_session",
            "    def get_previous_scheduled_dagrun(self, session: Session = NEW_SESSION) -> DagRun | None:",
            "        \"\"\"The previous, SCHEDULED DagRun, if there is one.\"\"\"",
            "        return session.scalar(",
            "            select(DagRun)",
            "            .where(",
            "                DagRun.dag_id == self.dag_id,",
            "                DagRun.execution_date < self.execution_date,",
            "                DagRun.run_type != DagRunType.MANUAL,",
            "            )",
            "            .order_by(DagRun.execution_date.desc())",
            "        )",
            "",
            "    def _tis_for_dagrun_state(self, *, dag, tis):",
            "        \"\"\"",
            "        Return the collection of tasks that should be considered for evaluation of terminal dag run state.",
            "",
            "        Teardown tasks by default are not considered for the purpose of dag run state.  But",
            "        users may enable such consideration with on_failure_fail_dagrun.",
            "        \"\"\"",
            "",
            "        def is_effective_leaf(task):",
            "            for down_task_id in task.downstream_task_ids:",
            "                down_task = dag.get_task(down_task_id)",
            "                if not down_task.is_teardown or down_task.on_failure_fail_dagrun:",
            "                    # we found a down task that is not ignorable; not a leaf",
            "                    return False",
            "            # we found no ignorable downstreams",
            "            # evaluate whether task is itself ignorable",
            "            return not task.is_teardown or task.on_failure_fail_dagrun",
            "",
            "        leaf_task_ids = {x.task_id for x in dag.tasks if is_effective_leaf(x)}",
            "        if not leaf_task_ids:",
            "            # can happen if dag is exclusively teardown tasks",
            "            leaf_task_ids = {x.task_id for x in dag.tasks if not x.downstream_list}",
            "        leaf_tis = {ti for ti in tis if ti.task_id in leaf_task_ids if ti.state != TaskInstanceState.REMOVED}",
            "        return leaf_tis",
            "",
            "    @provide_session",
            "    def update_state(",
            "        self, session: Session = NEW_SESSION, execute_callbacks: bool = True",
            "    ) -> tuple[list[TI], DagCallbackRequest | None]:",
            "        \"\"\"",
            "        Determines the overall state of the DagRun based on the state",
            "        of its TaskInstances.",
            "",
            "        :param session: Sqlalchemy ORM Session",
            "        :param execute_callbacks: Should dag callbacks (success/failure, SLA etc.) be invoked",
            "            directly (default: true) or recorded as a pending request in the ``returned_callback`` property",
            "        :return: Tuple containing tis that can be scheduled in the current loop & `returned_callback` that",
            "            needs to be executed",
            "        \"\"\"",
            "        # Callback to execute in case of Task Failures",
            "        callback: DagCallbackRequest | None = None",
            "",
            "        class _UnfinishedStates(NamedTuple):",
            "            tis: Sequence[TI]",
            "",
            "            @classmethod",
            "            def calculate(cls, unfinished_tis: Sequence[TI]) -> _UnfinishedStates:",
            "                return cls(tis=unfinished_tis)",
            "",
            "            @property",
            "            def should_schedule(self) -> bool:",
            "                return (",
            "                    bool(self.tis)",
            "                    and all(not t.task.depends_on_past for t in self.tis)",
            "                    and all(t.task.max_active_tis_per_dag is None for t in self.tis)",
            "                    and all(t.task.max_active_tis_per_dagrun is None for t in self.tis)",
            "                    and all(t.state != TaskInstanceState.DEFERRED for t in self.tis)",
            "                )",
            "",
            "            def recalculate(self) -> _UnfinishedStates:",
            "                return self._replace(tis=[t for t in self.tis if t.state in State.unfinished])",
            "",
            "        start_dttm = timezone.utcnow()",
            "        self.last_scheduling_decision = start_dttm",
            "        with Stats.timer(",
            "            f\"dagrun.dependency-check.{self.dag_id}\",",
            "            tags=self.stats_tags,",
            "        ):",
            "            dag = self.get_dag()",
            "            info = self.task_instance_scheduling_decisions(session)",
            "",
            "            tis = info.tis",
            "            schedulable_tis = info.schedulable_tis",
            "            changed_tis = info.changed_tis",
            "            finished_tis = info.finished_tis",
            "            unfinished = _UnfinishedStates.calculate(info.unfinished_tis)",
            "",
            "            if unfinished.should_schedule:",
            "                are_runnable_tasks = schedulable_tis or changed_tis",
            "                # small speed up",
            "                if not are_runnable_tasks:",
            "                    are_runnable_tasks, changed_by_upstream = self._are_premature_tis(",
            "                        unfinished.tis, finished_tis, session",
            "                    )",
            "                    if changed_by_upstream:  # Something changed, we need to recalculate!",
            "                        unfinished = unfinished.recalculate()",
            "",
            "        tis_for_dagrun_state = self._tis_for_dagrun_state(dag=dag, tis=tis)",
            "",
            "        # if all tasks finished and at least one failed, the run failed",
            "        if not unfinished.tis and any(x.state in State.failed_states for x in tis_for_dagrun_state):",
            "            self.log.error(\"Marking run %s failed\", self)",
            "            self.set_state(DagRunState.FAILED)",
            "            self.notify_dagrun_state_changed(msg=\"task_failure\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=False, reason=\"task_failure\", session=session)",
            "            elif dag.has_on_failure_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=True,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"task_failure\",",
            "                )",
            "",
            "        # if all leaves succeeded and no unfinished tasks, the run succeeded",
            "        elif not unfinished.tis and all(x.state in State.success_states for x in tis_for_dagrun_state):",
            "            self.log.info(\"Marking run %s successful\", self)",
            "            self.set_state(DagRunState.SUCCESS)",
            "            self.notify_dagrun_state_changed(msg=\"success\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=True, reason=\"success\", session=session)",
            "            elif dag.has_on_success_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=False,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"success\",",
            "                )",
            "",
            "        # if *all tasks* are deadlocked, the run failed",
            "        elif unfinished.should_schedule and not are_runnable_tasks:",
            "            self.log.error(\"Task deadlock (no runnable tasks); marking run %s failed\", self)",
            "            self.set_state(DagRunState.FAILED)",
            "            self.notify_dagrun_state_changed(msg=\"all_tasks_deadlocked\")",
            "",
            "            if execute_callbacks:",
            "                dag.handle_callback(self, success=False, reason=\"all_tasks_deadlocked\", session=session)",
            "            elif dag.has_on_failure_callback:",
            "                from airflow.models.dag import DagModel",
            "",
            "                dag_model = DagModel.get_dagmodel(dag.dag_id, session)",
            "                callback = DagCallbackRequest(",
            "                    full_filepath=dag.fileloc,",
            "                    dag_id=self.dag_id,",
            "                    run_id=self.run_id,",
            "                    is_failure_callback=True,",
            "                    processor_subdir=None if dag_model is None else dag_model.processor_subdir,",
            "                    msg=\"all_tasks_deadlocked\",",
            "                )",
            "",
            "        # finally, if the roots aren't done, the dag is still running",
            "        else:",
            "            self.set_state(DagRunState.RUNNING)",
            "",
            "        if self._state == DagRunState.FAILED or self._state == DagRunState.SUCCESS:",
            "            msg = (",
            "                \"DagRun Finished: dag_id=%s, execution_date=%s, run_id=%s, \"",
            "                \"run_start_date=%s, run_end_date=%s, run_duration=%s, \"",
            "                \"state=%s, external_trigger=%s, run_type=%s, \"",
            "                \"data_interval_start=%s, data_interval_end=%s, dag_hash=%s\"",
            "            )",
            "            self.log.info(",
            "                msg,",
            "                self.dag_id,",
            "                self.execution_date,",
            "                self.run_id,",
            "                self.start_date,",
            "                self.end_date,",
            "                (self.end_date - self.start_date).total_seconds()",
            "                if self.start_date and self.end_date",
            "                else None,",
            "                self._state,",
            "                self.external_trigger,",
            "                self.run_type,",
            "                self.data_interval_start,",
            "                self.data_interval_end,",
            "                self.dag_hash,",
            "            )",
            "            session.flush()",
            "",
            "        self._emit_true_scheduling_delay_stats_for_finished_state(finished_tis)",
            "        self._emit_duration_stats_for_finished_state()",
            "",
            "        session.merge(self)",
            "        # We do not flush here for performance reasons(It increases queries count by +20)",
            "",
            "        return schedulable_tis, callback",
            "",
            "    @provide_session",
            "    def task_instance_scheduling_decisions(self, session: Session = NEW_SESSION) -> TISchedulingDecision:",
            "        tis = self.get_task_instances(session=session, state=State.task_states)",
            "        self.log.debug(\"number of tis tasks for %s: %s task(s)\", self, len(tis))",
            "",
            "        def _filter_tis_and_exclude_removed(dag: DAG, tis: list[TI]) -> Iterable[TI]:",
            "            \"\"\"Populate ``ti.task`` while excluding those missing one, marking them as REMOVED.\"\"\"",
            "            for ti in tis:",
            "                try:",
            "                    ti.task = dag.get_task(ti.task_id)",
            "                except TaskNotFound:",
            "                    if ti.state != State.REMOVED:",
            "                        self.log.error(\"Failed to get task for ti %s. Marking it as removed.\", ti)",
            "                        ti.state = State.REMOVED",
            "                        session.flush()",
            "                else:",
            "                    yield ti",
            "",
            "        tis = list(_filter_tis_and_exclude_removed(self.get_dag(), tis))",
            "",
            "        unfinished_tis = [t for t in tis if t.state in State.unfinished]",
            "        finished_tis = [t for t in tis if t.state in State.finished]",
            "        if unfinished_tis:",
            "            schedulable_tis = [ut for ut in unfinished_tis if ut.state in SCHEDULEABLE_STATES]",
            "            self.log.debug(\"number of scheduleable tasks for %s: %s task(s)\", self, len(schedulable_tis))",
            "            schedulable_tis, changed_tis, expansion_happened = self._get_ready_tis(",
            "                schedulable_tis,",
            "                finished_tis,",
            "                session=session,",
            "            )",
            "",
            "            # During expansion, we may change some tis into non-schedulable",
            "            # states, so we need to re-compute.",
            "            if expansion_happened:",
            "                changed_tis = True",
            "                new_unfinished_tis = [t for t in unfinished_tis if t.state in State.unfinished]",
            "                finished_tis.extend(t for t in unfinished_tis if t.state in State.finished)",
            "                unfinished_tis = new_unfinished_tis",
            "        else:",
            "            schedulable_tis = []",
            "            changed_tis = False",
            "",
            "        return TISchedulingDecision(",
            "            tis=tis,",
            "            schedulable_tis=schedulable_tis,",
            "            changed_tis=changed_tis,",
            "            unfinished_tis=unfinished_tis,",
            "            finished_tis=finished_tis,",
            "        )",
            "",
            "    def notify_dagrun_state_changed(self, msg: str = \"\"):",
            "        if self.state == DagRunState.RUNNING:",
            "            get_listener_manager().hook.on_dag_run_running(dag_run=self, msg=msg)",
            "        elif self.state == DagRunState.SUCCESS:",
            "            get_listener_manager().hook.on_dag_run_success(dag_run=self, msg=msg)",
            "        elif self.state == DagRunState.FAILED:",
            "            get_listener_manager().hook.on_dag_run_failed(dag_run=self, msg=msg)",
            "        # deliberately not notifying on QUEUED",
            "        # we can't get all the state changes on SchedulerJob, BackfillJob",
            "        # or LocalTaskJob, so we don't want to \"falsely advertise\" we notify about that",
            "",
            "    def _get_ready_tis(",
            "        self,",
            "        schedulable_tis: list[TI],",
            "        finished_tis: list[TI],",
            "        session: Session,",
            "    ) -> tuple[list[TI], bool, bool]:",
            "        old_states = {}",
            "        ready_tis: list[TI] = []",
            "        changed_tis = False",
            "",
            "        if not schedulable_tis:",
            "            return ready_tis, changed_tis, False",
            "",
            "        # If we expand TIs, we need a new list so that we iterate over them too. (We can't alter",
            "        # `schedulable_tis` in place and have the `for` loop pick them up",
            "        additional_tis: list[TI] = []",
            "        dep_context = DepContext(",
            "            flag_upstream_failed=True,",
            "            ignore_unmapped_tasks=True,  # Ignore this Dep, as we will expand it if we can.",
            "            finished_tis=finished_tis,",
            "        )",
            "",
            "        def _expand_mapped_task_if_needed(ti: TI) -> Iterable[TI] | None:",
            "            \"\"\"Try to expand the ti, if needed.",
            "",
            "            If the ti needs expansion, newly created task instances are",
            "            returned as well as the original ti.",
            "            The original ti is also modified in-place and assigned the",
            "            ``map_index`` of 0.",
            "",
            "            If the ti does not need expansion, either because the task is not",
            "            mapped, or has already been expanded, *None* is returned.",
            "            \"\"\"",
            "            if ti.map_index >= 0:  # Already expanded, we're good.",
            "                return None",
            "",
            "            from airflow.models.mappedoperator import MappedOperator",
            "",
            "            if isinstance(ti.task, MappedOperator):",
            "                # If we get here, it could be that we are moving from non-mapped to mapped",
            "                # after task instance clearing or this ti is not yet expanded. Safe to clear",
            "                # the db references.",
            "                ti.clear_db_references(session=session)",
            "            try:",
            "                expanded_tis, _ = ti.task.expand_mapped_task(self.run_id, session=session)",
            "            except NotMapped:  # Not a mapped task, nothing needed.",
            "                return None",
            "            if expanded_tis:",
            "                return expanded_tis",
            "            return ()",
            "",
            "        # Check dependencies.",
            "        expansion_happened = False",
            "        # Set of task ids for which was already done _revise_map_indexes_if_mapped",
            "        revised_map_index_task_ids = set()",
            "        for schedulable in itertools.chain(schedulable_tis, additional_tis):",
            "            old_state = schedulable.state",
            "            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):",
            "                old_states[schedulable.key] = old_state",
            "                continue",
            "            # If schedulable is not yet expanded, try doing it now. This is",
            "            # called in two places: First and ideally in the mini scheduler at",
            "            # the end of LocalTaskJob, and then as an \"expansion of last resort\"",
            "            # in the scheduler to ensure that the mapped task is correctly",
            "            # expanded before executed. Also see _revise_map_indexes_if_mapped",
            "            # docstring for additional information.",
            "            new_tis = None",
            "            if schedulable.map_index < 0:",
            "                new_tis = _expand_mapped_task_if_needed(schedulable)",
            "                if new_tis is not None:",
            "                    additional_tis.extend(new_tis)",
            "                    expansion_happened = True",
            "            if new_tis is None and schedulable.state in SCHEDULEABLE_STATES:",
            "                # It's enough to revise map index once per task id,",
            "                # checking the map index for each mapped task significantly slows down scheduling",
            "                if schedulable.task.task_id not in revised_map_index_task_ids:",
            "                    ready_tis.extend(self._revise_map_indexes_if_mapped(schedulable.task, session=session))",
            "                    revised_map_index_task_ids.add(schedulable.task.task_id)",
            "                ready_tis.append(schedulable)",
            "",
            "        # Check if any ti changed state",
            "        tis_filter = TI.filter_for_tis(old_states)",
            "        if tis_filter is not None:",
            "            fresh_tis = session.scalars(select(TI).where(tis_filter)).all()",
            "            changed_tis = any(ti.state != old_states[ti.key] for ti in fresh_tis)",
            "",
            "        return ready_tis, changed_tis, expansion_happened",
            "",
            "    def _are_premature_tis(",
            "        self,",
            "        unfinished_tis: Sequence[TI],",
            "        finished_tis: list[TI],",
            "        session: Session,",
            "    ) -> tuple[bool, bool]:",
            "        dep_context = DepContext(",
            "            flag_upstream_failed=True,",
            "            ignore_in_retry_period=True,",
            "            ignore_in_reschedule_period=True,",
            "            finished_tis=finished_tis,",
            "        )",
            "        # there might be runnable tasks that are up for retry and for some reason(retry delay, etc.) are",
            "        # not ready yet, so we set the flags to count them in",
            "        return (",
            "            any(ut.are_dependencies_met(dep_context=dep_context, session=session) for ut in unfinished_tis),",
            "            dep_context.have_changed_ti_states,",
            "        )",
            "",
            "    def _emit_true_scheduling_delay_stats_for_finished_state(self, finished_tis: list[TI]) -> None:",
            "        \"\"\"Emit the true scheduling delay stats.",
            "",
            "        The true scheduling delay stats is defined as the time when the first",
            "        task in DAG starts minus the expected DAG run datetime.",
            "",
            "        This helper method is used in ``update_state`` when the state of the",
            "        DAG run is updated to a completed status (either success or failure).",
            "        It finds the first started task within the DAG, calculates the run's",
            "        expected start time based on the logical date and timetable, and gets",
            "        the delay from the difference of these two values.",
            "",
            "        The emitted data may contain outliers (e.g. when the first task was",
            "        cleared, so the second task's start date will be used), but we can get",
            "        rid of the outliers on the stats side through dashboards tooling.",
            "",
            "        Note that the stat will only be emitted for scheduler-triggered DAG runs",
            "        (i.e. when ``external_trigger`` is *False*).",
            "        \"\"\"",
            "        if self.state == TaskInstanceState.RUNNING:",
            "            return",
            "        if self.external_trigger:",
            "            return",
            "        if not finished_tis:",
            "            return",
            "",
            "        try:",
            "            dag = self.get_dag()",
            "",
            "            if not dag.timetable.periodic:",
            "                # We can't emit this metric if there is no following schedule to calculate from!",
            "                return",
            "",
            "            try:",
            "                first_start_date = min(ti.start_date for ti in finished_tis if ti.start_date)",
            "            except ValueError:  # No start dates at all.",
            "                pass",
            "            else:",
            "                # TODO: Logically, this should be DagRunInfo.run_after, but the",
            "                # information is not stored on a DagRun, only before the actual",
            "                # execution on DagModel.next_dagrun_create_after. We should add",
            "                # a field on DagRun for this instead of relying on the run",
            "                # always happening immediately after the data interval.",
            "                data_interval_end = dag.get_run_data_interval(self).end",
            "                true_delay = first_start_date - data_interval_end",
            "                if true_delay.total_seconds() > 0:",
            "                    Stats.timing(",
            "                        f\"dagrun.{dag.dag_id}.first_task_scheduling_delay\", true_delay, tags=self.stats_tags",
            "                    )",
            "                    Stats.timing(\"dagrun.first_task_scheduling_delay\", true_delay, tags=self.stats_tags)",
            "        except Exception:",
            "            self.log.warning(\"Failed to record first_task_scheduling_delay metric:\", exc_info=True)",
            "",
            "    def _emit_duration_stats_for_finished_state(self):",
            "        if self.state == State.RUNNING:",
            "            return",
            "        if self.start_date is None:",
            "            self.log.warning(\"Failed to record duration of %s: start_date is not set.\", self)",
            "            return",
            "        if self.end_date is None:",
            "            self.log.warning(\"Failed to record duration of %s: end_date is not set.\", self)",
            "            return",
            "",
            "        duration = self.end_date - self.start_date",
            "        timer_params = {\"dt\": duration, \"tags\": self.stats_tags}",
            "        Stats.timing(f\"dagrun.duration.{self.state.value}.{self.dag_id}\", **timer_params)",
            "        Stats.timing(f\"dagrun.duration.{self.state.value}\", **timer_params)",
            "",
            "    @provide_session",
            "    def verify_integrity(self, *, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"",
            "        Verifies the DagRun by checking for removed tasks or tasks that are not in the",
            "        database yet. It will set state to removed or add the task if required.",
            "",
            "        :missing_indexes: A dictionary of task vs indexes that are missing.",
            "        :param session: Sqlalchemy ORM Session",
            "        \"\"\"",
            "        from airflow.settings import task_instance_mutation_hook",
            "",
            "        # Set for the empty default in airflow.settings -- if it's not set this means it has been changed",
            "        # Note: Literal[True, False] instead of bool because otherwise it doesn't correctly find the overload.",
            "        hook_is_noop: Literal[True, False] = getattr(task_instance_mutation_hook, \"is_noop\", False)",
            "",
            "        dag = self.get_dag()",
            "        task_ids = self._check_for_removed_or_restored_tasks(",
            "            dag, task_instance_mutation_hook, session=session",
            "        )",
            "",
            "        def task_filter(task: Operator) -> bool:",
            "            return task.task_id not in task_ids and (",
            "                self.is_backfill",
            "                or task.start_date <= self.execution_date",
            "                and (task.end_date is None or self.execution_date <= task.end_date)",
            "            )",
            "",
            "        created_counts: dict[str, int] = defaultdict(int)",
            "        task_creator = self._get_task_creator(created_counts, task_instance_mutation_hook, hook_is_noop)",
            "",
            "        # Create the missing tasks, including mapped tasks",
            "        tasks_to_create = (task for task in dag.task_dict.values() if task_filter(task))",
            "        tis_to_create = self._create_tasks(tasks_to_create, task_creator, session=session)",
            "        self._create_task_instances(self.dag_id, tis_to_create, created_counts, hook_is_noop, session=session)",
            "",
            "    def _check_for_removed_or_restored_tasks(",
            "        self, dag: DAG, ti_mutation_hook, *, session: Session",
            "    ) -> set[str]:",
            "        \"\"\"",
            "        Check for removed tasks/restored/missing tasks.",
            "",
            "        :param dag: DAG object corresponding to the dagrun",
            "        :param ti_mutation_hook: task_instance_mutation_hook function",
            "        :param session: Sqlalchemy ORM Session",
            "",
            "        :return: Task IDs in the DAG run",
            "",
            "        \"\"\"",
            "        tis = self.get_task_instances(session=session)",
            "",
            "        # check for removed or restored tasks",
            "        task_ids = set()",
            "        for ti in tis:",
            "            ti_mutation_hook(ti)",
            "            task_ids.add(ti.task_id)",
            "            try:",
            "                task = dag.get_task(ti.task_id)",
            "",
            "                should_restore_task = (task is not None) and ti.state == State.REMOVED",
            "                if should_restore_task:",
            "                    self.log.info(\"Restoring task '%s' which was previously removed from DAG '%s'\", ti, dag)",
            "                    Stats.incr(f\"task_restored_to_dag.{dag.dag_id}\", tags=self.stats_tags)",
            "                    # Same metric with tagging",
            "                    Stats.incr(\"task_restored_to_dag\", tags={**self.stats_tags, \"dag_id\": dag.dag_id})",
            "                    ti.state = State.NONE",
            "            except AirflowException:",
            "                if ti.state == State.REMOVED:",
            "                    pass  # ti has already been removed, just ignore it",
            "                elif self.state != State.RUNNING and not dag.partial:",
            "                    self.log.warning(\"Failed to get task '%s' for dag '%s'. Marking it as removed.\", ti, dag)",
            "                    Stats.incr(f\"task_removed_from_dag.{dag.dag_id}\", tags=self.stats_tags)",
            "                    # Same metric with tagging",
            "                    Stats.incr(\"task_removed_from_dag\", tags={**self.stats_tags, \"dag_id\": dag.dag_id})",
            "                    ti.state = State.REMOVED",
            "                continue",
            "",
            "            try:",
            "                num_mapped_tis = task.get_parse_time_mapped_ti_count()",
            "            except NotMapped:",
            "                continue",
            "            except NotFullyPopulated:",
            "                # What if it is _now_ dynamically mapped, but wasn't before?",
            "                try:",
            "                    total_length = task.get_mapped_ti_count(self.run_id, session=session)",
            "                except NotFullyPopulated:",
            "                    # Not all upstreams finished, so we can't tell what should be here. Remove everything.",
            "                    if ti.map_index >= 0:",
            "                        self.log.debug(",
            "                            \"Removing the unmapped TI '%s' as the mapping can't be resolved yet\", ti",
            "                        )",
            "                        ti.state = State.REMOVED",
            "                    continue",
            "                # Upstreams finished, check there aren't any extras",
            "                if ti.map_index >= total_length:",
            "                    self.log.debug(",
            "                        \"Removing task '%s' as the map_index is longer than the resolved mapping list (%d)\",",
            "                        ti,",
            "                        total_length,",
            "                    )",
            "                    ti.state = State.REMOVED",
            "            else:",
            "                # Check if the number of mapped literals has changed, and we need to mark this TI as removed.",
            "                if ti.map_index >= num_mapped_tis:",
            "                    self.log.debug(",
            "                        \"Removing task '%s' as the map_index is longer than the literal mapping list (%s)\",",
            "                        ti,",
            "                        num_mapped_tis,",
            "                    )",
            "                    ti.state = State.REMOVED",
            "                elif ti.map_index < 0:",
            "                    self.log.debug(\"Removing the unmapped TI '%s' as the mapping can now be performed\", ti)",
            "                    ti.state = State.REMOVED",
            "",
            "        return task_ids",
            "",
            "    @overload",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[True],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[dict[str, Any]]]:",
            "        ...",
            "",
            "    @overload",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[False],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[TI]]:",
            "        ...",
            "",
            "    def _get_task_creator(",
            "        self,",
            "        created_counts: dict[str, int],",
            "        ti_mutation_hook: Callable,",
            "        hook_is_noop: Literal[True, False],",
            "    ) -> Callable[[Operator, Iterable[int]], Iterator[dict[str, Any]] | Iterator[TI]]:",
            "        \"\"\"",
            "        Get the task creator function.",
            "",
            "        This function also updates the created_counts dictionary with the number of tasks created.",
            "",
            "        :param created_counts: Dictionary of task_type -> count of created TIs",
            "        :param ti_mutation_hook: task_instance_mutation_hook function",
            "        :param hook_is_noop: Whether the task_instance_mutation_hook is a noop",
            "",
            "        \"\"\"",
            "        if hook_is_noop:",
            "",
            "            def create_ti_mapping(task: Operator, indexes: Iterable[int]) -> Iterator[dict[str, Any]]:",
            "                created_counts[task.task_type] += 1",
            "                for map_index in indexes:",
            "                    yield TI.insert_mapping(self.run_id, task, map_index=map_index)",
            "",
            "            creator = create_ti_mapping",
            "",
            "        else:",
            "",
            "            def create_ti(task: Operator, indexes: Iterable[int]) -> Iterator[TI]:",
            "                for map_index in indexes:",
            "                    ti = TI(task, run_id=self.run_id, map_index=map_index)",
            "                    ti_mutation_hook(ti)",
            "                    created_counts[ti.operator] += 1",
            "                    yield ti",
            "",
            "            creator = create_ti",
            "        return creator",
            "",
            "    def _create_tasks(",
            "        self,",
            "        tasks: Iterable[Operator],",
            "        task_creator: TaskCreator,",
            "        *,",
            "        session: Session,",
            "    ) -> CreatedTasks:",
            "        \"\"\"",
            "        Create missing tasks -- and expand any MappedOperator that _only_ have literals as input.",
            "",
            "        :param tasks: Tasks to create jobs for in the DAG run",
            "        :param task_creator: Function to create task instances",
            "        \"\"\"",
            "        map_indexes: Iterable[int]",
            "        for task in tasks:",
            "            try:",
            "                count = task.get_mapped_ti_count(self.run_id, session=session)",
            "            except (NotMapped, NotFullyPopulated):",
            "                map_indexes = (-1,)",
            "            else:",
            "                if count:",
            "                    map_indexes = range(count)",
            "                else:",
            "                    # Make sure to always create at least one ti; this will be",
            "                    # marked as REMOVED later at runtime.",
            "                    map_indexes = (-1,)",
            "            yield from task_creator(task, map_indexes)",
            "",
            "    def _create_task_instances(",
            "        self,",
            "        dag_id: str,",
            "        tasks: Iterator[dict[str, Any]] | Iterator[TI],",
            "        created_counts: dict[str, int],",
            "        hook_is_noop: bool,",
            "        *,",
            "        session: Session,",
            "    ) -> None:",
            "        \"\"\"",
            "        Create the necessary task instances from the given tasks.",
            "",
            "        :param dag_id: DAG ID associated with the dagrun",
            "        :param tasks: the tasks to create the task instances from",
            "        :param created_counts: a dictionary of number of tasks -> total ti created by the task creator",
            "        :param hook_is_noop: whether the task_instance_mutation_hook is noop",
            "        :param session: the session to use",
            "",
            "        \"\"\"",
            "        # Fetch the information we need before handling the exception to avoid",
            "        # PendingRollbackError due to the session being invalidated on exception",
            "        # see https://github.com/apache/superset/pull/530",
            "        run_id = self.run_id",
            "        try:",
            "            if hook_is_noop:",
            "                session.bulk_insert_mappings(TI, tasks)",
            "            else:",
            "                session.bulk_save_objects(tasks)",
            "",
            "            for task_type, count in created_counts.items():",
            "                Stats.incr(f\"task_instance_created_{task_type}\", count, tags=self.stats_tags)",
            "                # Same metric with tagging",
            "                Stats.incr(\"task_instance_created\", count, tags={**self.stats_tags, \"task_type\": task_type})",
            "            session.flush()",
            "        except IntegrityError:",
            "            self.log.info(",
            "                \"Hit IntegrityError while creating the TIs for %s- %s\",",
            "                dag_id,",
            "                run_id,",
            "                exc_info=True,",
            "            )",
            "            self.log.info(\"Doing session rollback.\")",
            "            # TODO[HA]: We probably need to savepoint this so we can keep the transaction alive.",
            "            session.rollback()",
            "",
            "    def _revise_map_indexes_if_mapped(self, task: Operator, *, session: Session) -> Iterator[TI]:",
            "        \"\"\"Check if task increased or reduced in length and handle appropriately.",
            "",
            "        Task instances that do not already exist are created and returned if",
            "        possible. Expansion only happens if all upstreams are ready; otherwise",
            "        we delay expansion to the \"last resort\". See comments at the call site",
            "        for more details.",
            "        \"\"\"",
            "        from airflow.settings import task_instance_mutation_hook",
            "",
            "        try:",
            "            total_length = task.get_mapped_ti_count(self.run_id, session=session)",
            "        except NotMapped:",
            "            return  # Not a mapped task, don't need to do anything.",
            "        except NotFullyPopulated:",
            "            return  # Upstreams not ready, don't need to revise this yet.",
            "",
            "        query = session.scalars(",
            "            select(TI.map_index).where(",
            "                TI.dag_id == self.dag_id,",
            "                TI.task_id == task.task_id,",
            "                TI.run_id == self.run_id,",
            "            )",
            "        )",
            "        existing_indexes = {i for i in query}",
            "",
            "        removed_indexes = existing_indexes.difference(range(total_length))",
            "        if removed_indexes:",
            "            session.execute(",
            "                update(TI)",
            "                .where(",
            "                    TI.dag_id == self.dag_id,",
            "                    TI.task_id == task.task_id,",
            "                    TI.run_id == self.run_id,",
            "                    TI.map_index.in_(removed_indexes),",
            "                )",
            "                .values(state=TaskInstanceState.REMOVED)",
            "            )",
            "            session.flush()",
            "",
            "        for index in range(total_length):",
            "            if index in existing_indexes:",
            "                continue",
            "            ti = TI(task, run_id=self.run_id, map_index=index, state=None)",
            "            self.log.debug(\"Expanding TIs upserted %s\", ti)",
            "            task_instance_mutation_hook(ti)",
            "            ti = session.merge(ti)",
            "            ti.refresh_from_task(task)",
            "            session.flush()",
            "            yield ti",
            "",
            "    @staticmethod",
            "    def get_run(session: Session, dag_id: str, execution_date: datetime) -> DagRun | None:",
            "        \"\"\"",
            "        Get a single DAG Run.",
            "",
            "        :meta private:",
            "        :param session: Sqlalchemy ORM Session",
            "        :param dag_id: DAG ID",
            "        :param execution_date: execution date",
            "        :return: DagRun corresponding to the given dag_id and execution date",
            "            if one exists. None otherwise.",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"This method is deprecated. Please use SQLAlchemy directly\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return session.scalar(",
            "            select(DagRun).where(",
            "                DagRun.dag_id == dag_id,",
            "                DagRun.external_trigger == False,  # noqa",
            "                DagRun.execution_date == execution_date,",
            "            )",
            "        )",
            "",
            "    @property",
            "    def is_backfill(self) -> bool:",
            "        return self.run_type == DagRunType.BACKFILL_JOB",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def get_latest_runs(cls, session: Session = NEW_SESSION) -> list[DagRun]:",
            "        \"\"\"Returns the latest DagRun for each DAG.\"\"\"",
            "        subquery = (",
            "            select(cls.dag_id, func.max(cls.execution_date).label(\"execution_date\"))",
            "            .group_by(cls.dag_id)",
            "            .subquery()",
            "        )",
            "        return session.scalars(",
            "            select(cls).join(",
            "                subquery,",
            "                and_(cls.dag_id == subquery.c.dag_id, cls.execution_date == subquery.c.execution_date),",
            "            )",
            "        ).all()",
            "",
            "    @provide_session",
            "    def schedule_tis(",
            "        self,",
            "        schedulable_tis: Iterable[TI],",
            "        session: Session = NEW_SESSION,",
            "        max_tis_per_query: int | None = None,",
            "    ) -> int:",
            "        \"\"\"",
            "        Set the given task instances in to the scheduled state.",
            "",
            "        Each element of ``schedulable_tis`` should have it's ``task`` attribute already set.",
            "",
            "        Any EmptyOperator without callbacks or outlets is instead set straight to the success state.",
            "",
            "        All the TIs should belong to this DagRun, but this code is in the hot-path, this is not checked -- it",
            "        is the caller's responsibility to call this function only with TIs from a single dag run.",
            "        \"\"\"",
            "        # Get list of TI IDs that do not need to executed, these are",
            "        # tasks using EmptyOperator and without on_execute_callback / on_success_callback",
            "        dummy_ti_ids = []",
            "        schedulable_ti_ids = []",
            "        for ti in schedulable_tis:",
            "            if (",
            "                ti.task.inherits_from_empty_operator",
            "                and not ti.task.on_execute_callback",
            "                and not ti.task.on_success_callback",
            "                and not ti.task.outlets",
            "            ):",
            "                dummy_ti_ids.append(ti.task_id)",
            "            else:",
            "                schedulable_ti_ids.append((ti.task_id, ti.map_index))",
            "",
            "        count = 0",
            "",
            "        if schedulable_ti_ids:",
            "            schedulable_ti_ids_chunks = chunks(",
            "                schedulable_ti_ids, max_tis_per_query or len(schedulable_ti_ids)",
            "            )",
            "            for schedulable_ti_ids_chunk in schedulable_ti_ids_chunks:",
            "                count += session.execute(",
            "                    update(TI)",
            "                    .where(",
            "                        TI.dag_id == self.dag_id,",
            "                        TI.run_id == self.run_id,",
            "                        tuple_in_condition((TI.task_id, TI.map_index), schedulable_ti_ids_chunk),",
            "                    )",
            "                    .values(state=TaskInstanceState.SCHEDULED)",
            "                    .execution_options(synchronize_session=False)",
            "                ).rowcount",
            "",
            "        # Tasks using EmptyOperator should not be executed, mark them as success",
            "        if dummy_ti_ids:",
            "            dummy_ti_ids_chunks = chunks(dummy_ti_ids, max_tis_per_query or len(dummy_ti_ids))",
            "            for dummy_ti_ids_chunk in dummy_ti_ids_chunks:",
            "                count += session.execute(",
            "                    update(TI)",
            "                    .where(",
            "                        TI.dag_id == self.dag_id,",
            "                        TI.run_id == self.run_id,",
            "                        TI.task_id.in_(dummy_ti_ids_chunk),",
            "                    )",
            "                    .values(",
            "                        state=TaskInstanceState.SUCCESS,",
            "                        start_date=timezone.utcnow(),",
            "                        end_date=timezone.utcnow(),",
            "                        duration=0,",
            "                    )",
            "                    .execution_options(",
            "                        synchronize_session=False,",
            "                    )",
            "                ).rowcount",
            "",
            "        return count",
            "",
            "    @provide_session",
            "    def get_log_template(self, *, session: Session = NEW_SESSION) -> LogTemplate:",
            "        if self.log_template_id is None:  # DagRun created before LogTemplate introduction.",
            "            template = session.scalar(select(LogTemplate).order_by(LogTemplate.id))",
            "        else:",
            "            template = session.get(LogTemplate, self.log_template_id)",
            "        if template is None:",
            "            raise AirflowException(",
            "                f\"No log_template entry found for ID {self.log_template_id!r}. \"",
            "                f\"Please make sure you set up the metadatabase correctly.\"",
            "            )",
            "        return template",
            "",
            "    @provide_session",
            "    def get_log_filename_template(self, *, session: Session = NEW_SESSION) -> str:",
            "        warnings.warn(",
            "            \"This method is deprecated. Please use get_log_template instead.\",",
            "            RemovedInAirflow3Warning,",
            "            stacklevel=2,",
            "        )",
            "        return self.get_log_template(session=session).filename",
            "",
            "",
            "class DagRunNote(Base):",
            "    \"\"\"For storage of arbitrary notes concerning the dagrun instance.\"\"\"",
            "",
            "    __tablename__ = \"dag_run_note\"",
            "",
            "    user_id = Column(Integer, nullable=True)",
            "    dag_run_id = Column(Integer, primary_key=True, nullable=False)",
            "    content = Column(String(1000).with_variant(Text(1000), \"mysql\"))",
            "    created_at = Column(UtcDateTime, default=timezone.utcnow, nullable=False)",
            "    updated_at = Column(UtcDateTime, default=timezone.utcnow, onupdate=timezone.utcnow, nullable=False)",
            "",
            "    dag_run = relationship(\"DagRun\", back_populates=\"dag_run_note\")",
            "",
            "    __table_args__ = (",
            "        PrimaryKeyConstraint(\"dag_run_id\", name=\"dag_run_note_pkey\"),",
            "        ForeignKeyConstraint(",
            "            (dag_run_id,),",
            "            [\"dag_run.id\"],",
            "            name=\"dag_run_note_dr_fkey\",",
            "            ondelete=\"CASCADE\",",
            "        ),",
            "        ForeignKeyConstraint(",
            "            (user_id,),",
            "            [\"ab_user.id\"],",
            "            name=\"dag_run_note_user_fkey\",",
            "        ),",
            "    )",
            "",
            "    def __init__(self, content, user_id=None):",
            "        self.content = content",
            "        self.user_id = user_id",
            "",
            "    def __repr__(self):",
            "        prefix = f\"<{self.__class__.__name__}: {self.dag_id}.{self.dagrun_id} {self.run_id}\"",
            "        if self.map_index != -1:",
            "            prefix += f\" map_index={self.map_index}\"",
            "        return prefix + \">\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "47": []
        },
        "addLocation": []
    },
    "airflow/www/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " from airflow.models.abstractoperator import AbstractOperator"
            },
            "1": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " from airflow.models.dag import DAG, get_dataset_triggered_next_run_info"
            },
            "2": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " from airflow.models.dagcode import DagCode"
            },
            "3": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from airflow.models.dagrun import DagRun, DagRunType"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+from airflow.models.dagrun import RUN_ID_REGEX, DagRun, DagRunType"
            },
            "5": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue, DatasetEvent, DatasetModel"
            },
            "6": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " from airflow.models.mappedoperator import MappedOperator"
            },
            "7": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " from airflow.models.operator import Operator"
            },
            "8": {
                "beforePatchRowNumber": 1975,
                "afterPatchRowNumber": 1975,
                "PatchRowcode": "     @provide_session"
            },
            "9": {
                "beforePatchRowNumber": 1976,
                "afterPatchRowNumber": 1976,
                "PatchRowcode": "     def trigger(self, dag_id: str, session: Session = NEW_SESSION):"
            },
            "10": {
                "beforePatchRowNumber": 1977,
                "afterPatchRowNumber": 1977,
                "PatchRowcode": "         \"\"\"Triggers DAG Run.\"\"\""
            },
            "11": {
                "beforePatchRowNumber": 1978,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        run_id = request.values.get(\"run_id\", \"\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1978,
                "PatchRowcode": "+        run_id = request.values.get(\"run_id\", \"\").replace(\" \", \"+\")"
            },
            "13": {
                "beforePatchRowNumber": 1979,
                "afterPatchRowNumber": 1979,
                "PatchRowcode": "         origin = get_safe_url(request.values.get(\"origin\"))"
            },
            "14": {
                "beforePatchRowNumber": 1980,
                "afterPatchRowNumber": 1980,
                "PatchRowcode": "         unpause = request.values.get(\"unpause\")"
            },
            "15": {
                "beforePatchRowNumber": 1981,
                "afterPatchRowNumber": 1981,
                "PatchRowcode": "         request_conf = request.values.get(\"conf\")"
            },
            "16": {
                "beforePatchRowNumber": 2096,
                "afterPatchRowNumber": 2096,
                "PatchRowcode": "             flash(message, \"error\")"
            },
            "17": {
                "beforePatchRowNumber": 2097,
                "afterPatchRowNumber": 2097,
                "PatchRowcode": "             return redirect(origin)"
            },
            "18": {
                "beforePatchRowNumber": 2098,
                "afterPatchRowNumber": 2098,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 2099,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Flash a warning when slash is used, but still allow it to continue on."
            },
            "20": {
                "beforePatchRowNumber": 2100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if run_id and \"/\" in run_id:"
            },
            "21": {
                "beforePatchRowNumber": 2101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            flash("
            },
            "22": {
                "beforePatchRowNumber": 2102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Using forward slash ('/') in a DAG run ID is deprecated. Note that this character \""
            },
            "23": {
                "beforePatchRowNumber": 2103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"also makes the run impossible to retrieve via Airflow's REST API.\","
            },
            "24": {
                "beforePatchRowNumber": 2104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"warning\","
            },
            "25": {
                "beforePatchRowNumber": 2105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2099,
                "PatchRowcode": "+        regex = conf.get(\"scheduler\", \"allowed_run_id_pattern\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2100,
                "PatchRowcode": "+        if run_id and not re.match(RUN_ID_REGEX, run_id):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2101,
                "PatchRowcode": "+            if not regex.strip() or not re.match(regex.strip(), run_id):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2102,
                "PatchRowcode": "+                flash("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2103,
                "PatchRowcode": "+                    f\"The provided run ID '{run_id}' is invalid. It does not match either \""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2104,
                "PatchRowcode": "+                    f\"the configured pattern: '{regex}' or the built-in pattern: '{RUN_ID_REGEX}'\","
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2105,
                "PatchRowcode": "+                    \"error\","
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2106,
                "PatchRowcode": "+                )"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2107,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2108,
                "PatchRowcode": "+                form = DateTimeForm(data={\"execution_date\": execution_date})"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2109,
                "PatchRowcode": "+                return self.render_template("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2110,
                "PatchRowcode": "+                    \"airflow/trigger.html\","
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2111,
                "PatchRowcode": "+                    form_fields=form_fields,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2112,
                "PatchRowcode": "+                    dag=dag,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2113,
                "PatchRowcode": "+                    dag_id=dag_id,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2114,
                "PatchRowcode": "+                    origin=origin,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2115,
                "PatchRowcode": "+                    conf=request_conf,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2116,
                "PatchRowcode": "+                    form=form,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2117,
                "PatchRowcode": "+                    is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2118,
                "PatchRowcode": "+                    recent_confs=recent_confs,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2119,
                "PatchRowcode": "+                )"
            },
            "47": {
                "beforePatchRowNumber": 2106,
                "afterPatchRowNumber": 2120,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 2107,
                "afterPatchRowNumber": 2121,
                "PatchRowcode": "         run_conf = {}"
            },
            "49": {
                "beforePatchRowNumber": 2108,
                "afterPatchRowNumber": 2122,
                "PatchRowcode": "         if request_conf:"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import collections",
            "import copy",
            "import datetime",
            "import itertools",
            "import json",
            "import logging",
            "import math",
            "import re",
            "import sys",
            "import traceback",
            "import warnings",
            "from bisect import insort_left",
            "from collections import defaultdict",
            "from functools import cached_property, wraps",
            "from json import JSONDecodeError",
            "from typing import Any, Callable, Collection, Iterator, Mapping, MutableMapping, Sequence",
            "from urllib.parse import unquote, urljoin, urlsplit",
            "",
            "import configupdater",
            "import flask.json",
            "import lazy_object_proxy",
            "import nvd3",
            "import sqlalchemy as sqla",
            "from croniter import croniter",
            "from flask import (",
            "    Response,",
            "    abort,",
            "    before_render_template,",
            "    flash,",
            "    g,",
            "    has_request_context,",
            "    make_response,",
            "    redirect,",
            "    render_template,",
            "    request,",
            "    send_from_directory,",
            "    session as flask_session,",
            "    url_for,",
            ")",
            "from flask_appbuilder import BaseView, ModelView, expose",
            "from flask_appbuilder.actions import action",
            "from flask_appbuilder.models.sqla.filters import BaseFilter",
            "from flask_appbuilder.security.decorators import has_access",
            "from flask_appbuilder.urltools import get_order_args, get_page_args, get_page_size_args",
            "from flask_appbuilder.widgets import FormWidget",
            "from flask_babel import lazy_gettext",
            "from jinja2.utils import htmlsafe_json_dumps, pformat  # type: ignore",
            "from markupsafe import Markup, escape",
            "from pendulum.datetime import DateTime",
            "from pendulum.parsing.exceptions import ParserError",
            "from pygments import highlight, lexers",
            "from pygments.formatters import HtmlFormatter",
            "from sqlalchemy import Date, and_, case, desc, func, inspect, or_, union_all",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.orm import Session, joinedload",
            "from wtforms import SelectField, validators",
            "",
            "import airflow",
            "from airflow import models, plugins_manager, settings",
            "from airflow.api.common.airflow_health import get_airflow_health",
            "from airflow.api.common.mark_tasks import (",
            "    set_dag_run_state_to_failed,",
            "    set_dag_run_state_to_queued,",
            "    set_dag_run_state_to_success,",
            "    set_state,",
            ")",
            "from airflow.configuration import AIRFLOW_CONFIG, conf",
            "from airflow.datasets import Dataset",
            "from airflow.exceptions import (",
            "    AirflowConfigException,",
            "    AirflowException,",
            "    ParamValidationError,",
            "    RemovedInAirflow3Warning,",
            ")",
            "from airflow.executors.executor_loader import ExecutorLoader",
            "from airflow.jobs.job import Job",
            "from airflow.jobs.scheduler_job_runner import SchedulerJobRunner",
            "from airflow.jobs.triggerer_job_runner import TriggererJobRunner",
            "from airflow.models import Connection, DagModel, DagTag, Log, SlaMiss, TaskFail, XCom, errors",
            "from airflow.models.abstractoperator import AbstractOperator",
            "from airflow.models.dag import DAG, get_dataset_triggered_next_run_info",
            "from airflow.models.dagcode import DagCode",
            "from airflow.models.dagrun import DagRun, DagRunType",
            "from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue, DatasetEvent, DatasetModel",
            "from airflow.models.mappedoperator import MappedOperator",
            "from airflow.models.operator import Operator",
            "from airflow.models.serialized_dag import SerializedDagModel",
            "from airflow.models.taskinstance import TaskInstance, TaskInstanceNote",
            "from airflow.providers_manager import ProvidersManager",
            "from airflow.security import permissions",
            "from airflow.ti_deps.dep_context import DepContext",
            "from airflow.ti_deps.dependencies_deps import SCHEDULER_QUEUED_DEPS",
            "from airflow.timetables._cron import CronMixin",
            "from airflow.timetables.base import DataInterval, TimeRestriction",
            "from airflow.utils import json as utils_json, timezone, yaml",
            "from airflow.utils.airflow_flask_app import get_airflow_app",
            "from airflow.utils.dag_edges import dag_edges",
            "from airflow.utils.dates import infer_time_unit, scale_time_units",
            "from airflow.utils.docs import get_doc_url_for_provider, get_docs_url",
            "from airflow.utils.helpers import alchemy_to_dict, exactly_one",
            "from airflow.utils.log import secrets_masker",
            "from airflow.utils.log.log_reader import TaskLogReader",
            "from airflow.utils.net import get_hostname",
            "from airflow.utils.session import NEW_SESSION, create_session, provide_session",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.strings import to_boolean",
            "from airflow.utils.task_group import MappedTaskGroup, TaskGroup, task_group_to_dict",
            "from airflow.utils.timezone import td_format, utcnow",
            "from airflow.version import version",
            "from airflow.www import auth, utils as wwwutils",
            "from airflow.www.decorators import action_logging, gzipped",
            "from airflow.www.forms import (",
            "    DagRunEditForm,",
            "    DateTimeForm,",
            "    DateTimeWithNumRunsForm,",
            "    DateTimeWithNumRunsWithDagRunsForm,",
            "    TaskInstanceEditForm,",
            "    create_connection_form_class,",
            ")",
            "from airflow.www.widgets import AirflowModelListWidget, AirflowVariableShowWidget",
            "",
            "PAGE_SIZE = conf.getint(\"webserver\", \"page_size\")",
            "FILTER_TAGS_COOKIE = \"tags_filter\"",
            "FILTER_STATUS_COOKIE = \"dag_status_filter\"",
            "LINECHART_X_AXIS_TICKFORMAT = (",
            "    \"function (d, i) { let xLabel;\"",
            "    \"if (i === undefined) {xLabel = d3.time.format('%H:%M, %d %b %Y')(new Date(parseInt(d)));\"",
            "    \"} else {xLabel = d3.time.format('%H:%M, %d %b')(new Date(parseInt(d)));} return xLabel;}\"",
            ")",
            "",
            "",
            "def sanitize_args(args: dict[str, str]) -> dict[str, str]:",
            "    \"\"\"",
            "    Remove all parameters starting with `_`.",
            "",
            "    :param args: arguments of request",
            "    :return: copy of the dictionary passed as input with args starting with `_` removed.",
            "    \"\"\"",
            "    return {key: value for key, value in args.items() if not key.startswith(\"_\")}",
            "",
            "",
            "# Following the release of https://github.com/python/cpython/issues/102153 in Python 3.8.17 and 3.9.17 on",
            "# June 6, 2023, we are adding extra sanitization of the urls passed to get_safe_url method to make it works",
            "# the same way regardless if the user uses latest Python patchlevel versions or not. This also follows",
            "# a recommended solution by the Python core team.",
            "#",
            "# From: https://github.com/python/cpython/commit/d28bafa2d3e424b6fdcfd7ae7cde8e71d7177369",
            "#",
            "#   We recommend that users of these APIs where the values may be used anywhere",
            "#   with security implications code defensively. Do some verification within your",
            "#   code before trusting a returned component part.  Does that ``scheme`` make",
            "#   sense?  Is that a sensible ``path``?  Is there anything strange about that",
            "#   ``hostname``?  etc.",
            "#",
            "# C0 control and space to be stripped per WHATWG spec.",
            "# == \"\".join([chr(i) for i in range(0, 0x20 + 1)])",
            "_WHATWG_C0_CONTROL_OR_SPACE = (",
            "    \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\"",
            "    \"\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \"",
            ")",
            "",
            "",
            "def get_safe_url(url):",
            "    \"\"\"Given a user-supplied URL, ensure it points to our web server.\"\"\"",
            "    if not url:",
            "        return url_for(\"Airflow.index\")",
            "",
            "    # If the url contains semicolon, redirect it to homepage to avoid",
            "    # potential XSS. (Similar to https://github.com/python/cpython/pull/24297/files (bpo-42967))",
            "    if \";\" in unquote(url):",
            "        return url_for(\"Airflow.index\")",
            "",
            "    url = url.lstrip(_WHATWG_C0_CONTROL_OR_SPACE)",
            "",
            "    host_url = urlsplit(request.host_url)",
            "    redirect_url = urlsplit(urljoin(request.host_url, url))",
            "    if not (redirect_url.scheme in (\"http\", \"https\") and host_url.netloc == redirect_url.netloc):",
            "        return url_for(\"Airflow.index\")",
            "",
            "    # This will ensure we only redirect to the right scheme/netloc",
            "    return redirect_url.geturl()",
            "",
            "",
            "def get_date_time_num_runs_dag_runs_form_data(www_request, session, dag):",
            "    \"\"\"Get Execution Data, Base Date & Number of runs from a Request.\"\"\"",
            "    date_time = www_request.args.get(\"execution_date\")",
            "    run_id = www_request.args.get(\"run_id\")",
            "    # First check run id, then check execution date, if not fall back on the latest dagrun",
            "    if run_id:",
            "        dagrun = dag.get_dagrun(run_id=run_id, session=session)",
            "        date_time = dagrun.execution_date",
            "    elif date_time:",
            "        date_time = _safe_parse_datetime(date_time)",
            "    else:",
            "        date_time = dag.get_latest_execution_date(session=session) or timezone.utcnow()",
            "",
            "    base_date = www_request.args.get(\"base_date\")",
            "    if base_date:",
            "        base_date = _safe_parse_datetime(base_date)",
            "    else:",
            "        # The DateTimeField widget truncates milliseconds and would loose",
            "        # the first dag run. Round to next second.",
            "        base_date = (date_time + datetime.timedelta(seconds=1)).replace(microsecond=0)",
            "",
            "    default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "    num_runs = www_request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "    # When base_date has been rounded up because of the DateTimeField widget, we want",
            "    # to use the execution_date as the starting point for our query just to ensure a",
            "    # link targeting a specific dag run actually loads that dag run.  If there are",
            "    # more than num_runs dag runs in the \"rounded period\" then those dagruns would get",
            "    # loaded and the actual requested run would be excluded by the limit().  Once",
            "    # the user has changed base date to be anything else we want to use that instead.",
            "    query_date = base_date",
            "    if date_time < base_date and date_time + datetime.timedelta(seconds=1) >= base_date:",
            "        query_date = date_time",
            "",
            "    drs = (",
            "        session.query(DagRun)",
            "        .filter(DagRun.dag_id == dag.dag_id, DagRun.execution_date <= query_date)",
            "        .order_by(desc(DagRun.execution_date))",
            "        .limit(num_runs)",
            "        .all()",
            "    )",
            "    dr_choices = []",
            "    dr_state = None",
            "    for dr in drs:",
            "        dr_choices.append((dr.execution_date.isoformat(), dr.run_id))",
            "        if date_time == dr.execution_date:",
            "            dr_state = dr.state",
            "",
            "    # Happens if base_date was changed and the selected dag run is not in result",
            "    if not dr_state and drs:",
            "        dr = drs[0]",
            "        date_time = dr.execution_date",
            "        dr_state = dr.state",
            "",
            "    return {",
            "        \"dttm\": date_time,",
            "        \"base_date\": base_date,",
            "        \"num_runs\": num_runs,",
            "        \"execution_date\": date_time.isoformat(),",
            "        \"dr_choices\": dr_choices,",
            "        \"dr_state\": dr_state,",
            "    }",
            "",
            "",
            "def _safe_parse_datetime(v, allow_empty=False) -> datetime.datetime | None:",
            "    \"\"\"",
            "    Parse datetime and return error message for invalid dates.",
            "",
            "    :param v: the string value to be parsed",
            "    :param allow_empty: Set True to return none if empty str or None",
            "    \"\"\"",
            "    if allow_empty is True and not v:",
            "        return None",
            "    try:",
            "        return timezone.parse(v)",
            "    except (TypeError, ParserError):",
            "        abort(400, f\"Invalid datetime: {v!r}\")",
            "",
            "",
            "def node_dict(node_id, label, node_class):",
            "    return {",
            "        \"id\": node_id,",
            "        \"value\": {\"label\": label, \"rx\": 5, \"ry\": 5, \"class\": node_class},",
            "    }",
            "",
            "",
            "def dag_to_grid(dag: DagModel, dag_runs: Sequence[DagRun], session: Session):",
            "    \"\"\"",
            "    Create a nested dict representation of the DAG's TaskGroup and its children",
            "    used to construct the Graph and Grid views.",
            "    \"\"\"",
            "    query = (",
            "        session.query(",
            "            TaskInstance.task_id,",
            "            TaskInstance.run_id,",
            "            TaskInstance.state,",
            "            TaskInstance._try_number,",
            "            func.min(TaskInstanceNote.content).label(\"note\"),",
            "            func.count(func.coalesce(TaskInstance.state, sqla.literal(\"no_status\"))).label(\"state_count\"),",
            "            func.min(TaskInstance.start_date).label(\"start_date\"),",
            "            func.max(TaskInstance.end_date).label(\"end_date\"),",
            "        )",
            "        .join(TaskInstance.task_instance_note, isouter=True)",
            "        .filter(",
            "            TaskInstance.dag_id == dag.dag_id,",
            "            TaskInstance.run_id.in_([dag_run.run_id for dag_run in dag_runs]),",
            "        )",
            "        .group_by(TaskInstance.task_id, TaskInstance.run_id, TaskInstance.state, TaskInstance._try_number)",
            "        .order_by(TaskInstance.task_id, TaskInstance.run_id)",
            "    )",
            "",
            "    grouped_tis = {task_id: list(tis) for task_id, tis in itertools.groupby(query, key=lambda ti: ti.task_id)}",
            "",
            "    sort_order = conf.get(\"webserver\", \"grid_view_sorting_order\", fallback=\"topological\")",
            "    if sort_order == \"topological\":",
            "        sort_children_fn = lambda task_group: task_group.topological_sort()",
            "    elif sort_order == \"hierarchical_alphabetical\":",
            "        sort_children_fn = lambda task_group: task_group.hierarchical_alphabetical_sort()",
            "    else:",
            "        raise AirflowConfigException(f\"Unsupported grid_view_sorting_order: {sort_order}\")",
            "",
            "    def task_group_to_grid(item, grouped_tis, *, is_parent_mapped: bool):",
            "        if not isinstance(item, TaskGroup):",
            "",
            "            def _get_summary(task_instance):",
            "                return {",
            "                    \"task_id\": task_instance.task_id,",
            "                    \"run_id\": task_instance.run_id,",
            "                    \"state\": task_instance.state,",
            "                    \"start_date\": task_instance.start_date,",
            "                    \"end_date\": task_instance.end_date,",
            "                    \"try_number\": wwwutils.get_try_count(task_instance._try_number, task_instance.state),",
            "                    \"note\": task_instance.note,",
            "                }",
            "",
            "            def _mapped_summary(ti_summaries):",
            "                run_id = None",
            "                record = None",
            "",
            "                def set_overall_state(record):",
            "                    for state in wwwutils.priority:",
            "                        if state in record[\"mapped_states\"]:",
            "                            record[\"state\"] = state",
            "                            break",
            "                    if None in record[\"mapped_states\"]:",
            "                        # When turning the dict into JSON we can't have None as a key,",
            "                        # so use the string that the UI does.",
            "                        record[\"mapped_states\"][\"no_status\"] = record[\"mapped_states\"].pop(None)",
            "",
            "                for ti_summary in ti_summaries:",
            "                    if run_id != ti_summary.run_id:",
            "                        run_id = ti_summary.run_id",
            "                        if record:",
            "                            set_overall_state(record)",
            "                            yield record",
            "                        record = {",
            "                            \"task_id\": ti_summary.task_id,",
            "                            \"run_id\": run_id,",
            "                            \"start_date\": ti_summary.start_date,",
            "                            \"end_date\": ti_summary.end_date,",
            "                            \"mapped_states\": {ti_summary.state: ti_summary.state_count},",
            "                            \"state\": None,  # We change this before yielding",
            "                        }",
            "                        continue",
            "                    record[\"start_date\"] = min(",
            "                        filter(None, [record[\"start_date\"], ti_summary.start_date]), default=None",
            "                    )",
            "                    record[\"end_date\"] = max(",
            "                        filter(None, [record[\"end_date\"], ti_summary.end_date]), default=None",
            "                    )",
            "                    record[\"mapped_states\"][ti_summary.state] = ti_summary.state_count",
            "                if record:",
            "                    set_overall_state(record)",
            "                    yield record",
            "",
            "            if isinstance(item, MappedOperator) or is_parent_mapped:",
            "                instances = list(_mapped_summary(grouped_tis.get(item.task_id, [])))",
            "            else:",
            "                instances = list(map(_get_summary, grouped_tis.get(item.task_id, [])))",
            "",
            "            return {",
            "                \"id\": item.task_id,",
            "                \"instances\": instances,",
            "                \"label\": item.label,",
            "                \"extra_links\": item.extra_links,",
            "                \"is_mapped\": isinstance(item, MappedOperator) or is_parent_mapped,",
            "                \"has_outlet_datasets\": any(isinstance(i, Dataset) for i in (item.outlets or [])),",
            "                \"operator\": item.operator_name,",
            "                \"trigger_rule\": item.trigger_rule,",
            "            }",
            "",
            "        # Task Group",
            "        task_group = item",
            "        group_is_mapped = isinstance(task_group, MappedTaskGroup)",
            "",
            "        children = [",
            "            task_group_to_grid(child, grouped_tis, is_parent_mapped=group_is_mapped)",
            "            for child in sort_children_fn(task_group)",
            "        ]",
            "",
            "        def get_summary(dag_run: DagRun):",
            "            child_instances = [",
            "                item",
            "                for sublist in (child[\"instances\"] for child in children if \"instances\" in child)",
            "                for item in sublist",
            "                if item[\"run_id\"] == dag_run.run_id",
            "                if item",
            "            ]",
            "",
            "            children_start_dates = (item[\"start_date\"] for item in child_instances)",
            "            children_end_dates = (item[\"end_date\"] for item in child_instances)",
            "            children_states = {item[\"state\"] for item in child_instances}",
            "",
            "            group_state = next((state for state in wwwutils.priority if state in children_states), None)",
            "            group_start_date = min(filter(None, children_start_dates), default=None)",
            "            group_end_date = max(filter(None, children_end_dates), default=None)",
            "",
            "            return {",
            "                \"task_id\": task_group.group_id,",
            "                \"run_id\": dag_run.run_id,",
            "                \"state\": group_state,",
            "                \"start_date\": group_start_date,",
            "                \"end_date\": group_end_date,",
            "            }",
            "",
            "        def get_mapped_group_summaries():",
            "            mapped_ti_query = (",
            "                session.query(",
            "                    TaskInstance.task_id, TaskInstance.state, TaskInstance.run_id, TaskInstance.map_index",
            "                )",
            "                .filter(",
            "                    TaskInstance.dag_id == dag.dag_id,",
            "                    TaskInstance.task_id.in_(child[\"id\"] for child in children),",
            "                    TaskInstance.run_id.in_(r.run_id for r in dag_runs),",
            "                )",
            "                .order_by(TaskInstance.task_id, TaskInstance.run_id)",
            "            )",
            "            # Group tis by run_id, and then map_index.",
            "            mapped_tis: Mapping[str, Mapping[int, list[TaskInstance]]] = collections.defaultdict(",
            "                lambda: collections.defaultdict(list),",
            "            )",
            "            for ti in mapped_ti_query:",
            "                mapped_tis[ti.run_id][ti.map_index].append(ti)",
            "",
            "            def get_mapped_group_summary(run_id: str, mapped_instances: Mapping[int, list[TaskInstance]]):",
            "                child_instances = [",
            "                    item",
            "                    for sublist in (child[\"instances\"] for child in children if \"instances\" in child)",
            "                    for item in sublist",
            "                    if item and item[\"run_id\"] == run_id",
            "                ]",
            "",
            "                children_start_dates = (item[\"start_date\"] for item in child_instances)",
            "                children_end_dates = (item[\"end_date\"] for item in child_instances)",
            "                children_states = {item[\"state\"] for item in child_instances}",
            "",
            "                # TODO: This assumes TI map index has a one-to-one mapping to",
            "                # its parent mapped task group, which will not be true when we",
            "                # allow nested mapping in the future.",
            "                mapped_states: MutableMapping[str, int] = collections.defaultdict(int)",
            "                for mis in mapped_instances.values():",
            "                    child_states = {mi.state for mi in mis}",
            "                    state = next(s for s in wwwutils.priority if s in child_states)",
            "                    value = state.value if state is not None else \"no_status\"",
            "                    mapped_states[value] += 1",
            "",
            "                group_state = next((state for state in wwwutils.priority if state in children_states), None)",
            "                group_start_date = min(filter(None, children_start_dates), default=None)",
            "                group_end_date = max(filter(None, children_end_dates), default=None)",
            "",
            "                return {",
            "                    \"task_id\": task_group.group_id,",
            "                    \"run_id\": run_id,",
            "                    \"state\": group_state,",
            "                    \"start_date\": group_start_date,",
            "                    \"end_date\": group_end_date,",
            "                    \"mapped_states\": mapped_states,",
            "                }",
            "",
            "            return [get_mapped_group_summary(run_id, tis) for run_id, tis in mapped_tis.items()]",
            "",
            "        # We don't need to calculate summaries for the root",
            "        if task_group.group_id is None:",
            "            return {",
            "                \"id\": task_group.group_id,",
            "                \"label\": task_group.label,",
            "                \"children\": children,",
            "                \"instances\": [],",
            "            }",
            "",
            "        if group_is_mapped:",
            "            mapped_group_summaries = get_mapped_group_summaries()",
            "",
            "            return {",
            "                \"id\": task_group.group_id,",
            "                \"label\": task_group.label,",
            "                \"children\": children,",
            "                \"tooltip\": task_group.tooltip,",
            "                \"instances\": mapped_group_summaries,",
            "                \"is_mapped\": group_is_mapped,",
            "            }",
            "",
            "        group_summaries = [get_summary(dr) for dr in dag_runs]",
            "",
            "        return {",
            "            \"id\": task_group.group_id,",
            "            \"label\": task_group.label,",
            "            \"children\": children,",
            "            \"tooltip\": task_group.tooltip,",
            "            \"instances\": group_summaries,",
            "        }",
            "",
            "    return task_group_to_grid(dag.task_group, grouped_tis, is_parent_mapped=False)",
            "",
            "",
            "def get_key_paths(input_dict):",
            "    \"\"\"Return a list of dot-separated dictionary paths.\"\"\"",
            "    for key, value in input_dict.items():",
            "        if isinstance(value, dict):",
            "            for sub_key in get_key_paths(value):",
            "                yield \".\".join((key, sub_key))",
            "        else:",
            "            yield key",
            "",
            "",
            "def get_value_from_path(key_path, content):",
            "    \"\"\"Return the value from a dictionary based on dot-separated path of keys.\"\"\"",
            "    elem = content",
            "    for x in key_path.strip(\".\").split(\".\"):",
            "        try:",
            "            x = int(x)",
            "            elem = elem[x]",
            "        except ValueError:",
            "            elem = elem.get(x)",
            "",
            "    return elem",
            "",
            "",
            "def get_task_stats_from_query(qry):",
            "    \"\"\"",
            "    Return a dict of the task quantity, grouped by dag id and task status.",
            "",
            "    :param qry: The data in the format (<dag id>, <task state>, <is dag running>, <task count>),",
            "        ordered by <dag id> and <is dag running>",
            "    \"\"\"",
            "    data = {}",
            "    last_dag_id = None",
            "    has_running_dags = False",
            "    for dag_id, state, is_dag_running, count in qry:",
            "        if last_dag_id != dag_id:",
            "            last_dag_id = dag_id",
            "            has_running_dags = False",
            "        elif not is_dag_running and has_running_dags:",
            "            continue",
            "",
            "        if is_dag_running:",
            "            has_running_dags = True",
            "        if dag_id not in data:",
            "            data[dag_id] = {}",
            "        data[dag_id][state] = count",
            "    return data",
            "",
            "",
            "def redirect_or_json(origin, msg, status=\"\", status_code=200):",
            "    \"\"\"",
            "    Some endpoints are called by javascript,",
            "    returning json will allow us to more elegantly handle side-effects in-page.",
            "    \"\"\"",
            "    if request.headers.get(\"Accept\") == \"application/json\":",
            "        if status == \"error\" and status_code == 200:",
            "            status_code = 500",
            "        return Response(response=msg, status=status_code, mimetype=\"application/json\")",
            "    else:",
            "        if status:",
            "            flash(msg, status)",
            "        else:",
            "            flash(msg)",
            "        return redirect(origin)",
            "",
            "",
            "######################################################################################",
            "#                                    Error handlers",
            "######################################################################################",
            "",
            "",
            "def not_found(error):",
            "    \"\"\"Show Not Found on screen for any error in the Webserver.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/error.html\",",
            "            hostname=get_hostname() if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") else \"redact\",",
            "            status_code=404,",
            "            error_message=\"Page cannot be found.\",",
            "        ),",
            "        404,",
            "    )",
            "",
            "",
            "def method_not_allowed(error):",
            "    \"\"\"Show Method Not Allowed on screen for any error in the Webserver.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/error.html\",",
            "            hostname=get_hostname() if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") else \"redact\",",
            "            status_code=405,",
            "            error_message=\"Received an invalid request.\",",
            "        ),",
            "        405,",
            "    )",
            "",
            "",
            "def show_traceback(error):",
            "    \"\"\"Show Traceback for a given error.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/traceback.html\",",
            "            python_version=sys.version.split(\" \")[0] if g.user.is_authenticated else \"redact\",",
            "            airflow_version=version if g.user.is_authenticated else \"redact\",",
            "            hostname=get_hostname()",
            "            if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") and g.user.is_authenticated",
            "            else \"redact\",",
            "            info=traceback.format_exc()",
            "            if conf.getboolean(\"webserver\", \"EXPOSE_STACKTRACE\") and g.user.is_authenticated",
            "            else \"Error! Please contact server admin.\",",
            "        ),",
            "        500,",
            "    )",
            "",
            "",
            "######################################################################################",
            "#                                    BaseViews",
            "######################################################################################",
            "",
            "",
            "class AirflowBaseView(BaseView):",
            "    \"\"\"Base View to set Airflow related properties.\"\"\"",
            "",
            "    from airflow import macros",
            "",
            "    route_base = \"\"",
            "",
            "    extra_args = {",
            "        # Make our macros available to our UI templates too.",
            "        \"macros\": macros,",
            "        \"get_docs_url\": get_docs_url,",
            "    }",
            "",
            "    if not conf.getboolean(\"core\", \"unit_test_mode\"):",
            "        executor, _ = ExecutorLoader.import_default_executor_cls()",
            "        extra_args[\"sqlite_warning\"] = settings.engine.dialect.name == \"sqlite\"",
            "        if not executor.is_production:",
            "            extra_args[\"production_executor_warning\"] = executor.__name__",
            "        extra_args[\"otel_on\"] = conf.getboolean(\"metrics\", \"otel_on\")",
            "",
            "    line_chart_attr = {",
            "        \"legend.maxKeyLength\": 200,",
            "    }",
            "",
            "    def render_template(self, *args, **kwargs):",
            "        # Add triggerer_job only if we need it",
            "        if TriggererJobRunner.is_needed():",
            "            kwargs[\"triggerer_job\"] = lazy_object_proxy.Proxy(TriggererJobRunner.most_recent_job)",
            "        return super().render_template(",
            "            *args,",
            "            # Cache this at most once per request, not for the lifetime of the view instance",
            "            scheduler_job=lazy_object_proxy.Proxy(SchedulerJobRunner.most_recent_job),",
            "            **kwargs,",
            "        )",
            "",
            "",
            "class Airflow(AirflowBaseView):",
            "    \"\"\"Main Airflow application.\"\"\"",
            "",
            "    @expose(\"/health\")",
            "    def health(self):",
            "        \"\"\"",
            "        An endpoint helping check the health status of the Airflow instance,",
            "        including metadatabase, scheduler and triggerer.",
            "        \"\"\"",
            "        airflow_health_status = get_airflow_health()",
            "",
            "        return flask.json.jsonify(airflow_health_status)",
            "",
            "    @expose(\"/home\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_WEBSITE),",
            "        ]",
            "    )",
            "    def index(self):",
            "        \"\"\"Home view.\"\"\"",
            "        from airflow.models.dag import DagOwnerAttributes",
            "",
            "        hide_paused_dags_by_default = conf.getboolean(\"webserver\", \"hide_paused_dags_by_default\")",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "        current_page = request.args.get(\"page\", default=0, type=int)",
            "        arg_search_query = request.args.get(\"search\")",
            "        arg_tags_filter = request.args.getlist(\"tags\")",
            "        arg_status_filter = request.args.get(\"status\")",
            "        arg_sorting_key = request.args.get(\"sorting_key\", \"dag_id\")",
            "        arg_sorting_direction = request.args.get(\"sorting_direction\", default=\"asc\")",
            "",
            "        if request.args.get(\"reset_tags\") is not None:",
            "            flask_session[FILTER_TAGS_COOKIE] = None",
            "            # Remove the reset_tags=reset from the URL",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        cookie_val = flask_session.get(FILTER_TAGS_COOKIE)",
            "        if arg_tags_filter:",
            "            flask_session[FILTER_TAGS_COOKIE] = \",\".join(arg_tags_filter)",
            "        elif cookie_val:",
            "            # If tags exist in cookie, but not URL, add them to the URL",
            "            return redirect(url_for(\"Airflow.index\", tags=cookie_val.split(\",\")))",
            "",
            "        if arg_status_filter is None:",
            "            cookie_val = flask_session.get(FILTER_STATUS_COOKIE)",
            "            if cookie_val:",
            "                arg_status_filter = cookie_val",
            "            else:",
            "                arg_status_filter = \"active\" if hide_paused_dags_by_default else \"all\"",
            "                flask_session[FILTER_STATUS_COOKIE] = arg_status_filter",
            "        else:",
            "            status = arg_status_filter.strip().lower()",
            "            flask_session[FILTER_STATUS_COOKIE] = status",
            "            arg_status_filter = status",
            "",
            "        dags_per_page = PAGE_SIZE",
            "",
            "        start = current_page * dags_per_page",
            "        end = start + dags_per_page",
            "",
            "        # Get all the dag id the user could access",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        with create_session() as session:",
            "            # read orm_dags from the db",
            "            dags_query = session.query(DagModel).filter(~DagModel.is_subdag, DagModel.is_active)",
            "",
            "            if arg_search_query:",
            "                escaped_arg_search_query = arg_search_query.replace(\"_\", r\"\\_\")",
            "                dags_query = dags_query.filter(",
            "                    DagModel.dag_id.ilike(\"%\" + escaped_arg_search_query + \"%\", escape=\"\\\\\")",
            "                    | DagModel.owners.ilike(\"%\" + escaped_arg_search_query + \"%\", escape=\"\\\\\")",
            "                )",
            "",
            "            if arg_tags_filter:",
            "                dags_query = dags_query.filter(DagModel.tags.any(DagTag.name.in_(arg_tags_filter)))",
            "",
            "            dags_query = dags_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "            filtered_dag_count = dags_query.count()",
            "            if filtered_dag_count == 0 and len(arg_tags_filter):",
            "                flash(",
            "                    \"No matching DAG tags found.\",",
            "                    \"warning\",",
            "                )",
            "                flask_session[FILTER_TAGS_COOKIE] = None",
            "                return redirect(url_for(\"Airflow.index\"))",
            "",
            "            all_dags = dags_query",
            "            active_dags = dags_query.filter(~DagModel.is_paused)",
            "            paused_dags = dags_query.filter(DagModel.is_paused)",
            "",
            "            # find DAGs which have a RUNNING DagRun",
            "            running_dags = dags_query.join(DagRun, DagModel.dag_id == DagRun.dag_id).filter(",
            "                DagRun.state == State.RUNNING",
            "            )",
            "",
            "            # find DAGs for which the latest DagRun is FAILED",
            "            subq_all = (",
            "                session.query(DagRun.dag_id, func.max(DagRun.start_date).label(\"start_date\"))",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            subq_failed = (",
            "                session.query(DagRun.dag_id, func.max(DagRun.start_date).label(\"start_date\"))",
            "                .filter(DagRun.state == State.FAILED)",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            subq_join = (",
            "                session.query(subq_all.c.dag_id, subq_all.c.start_date)",
            "                .join(",
            "                    subq_failed,",
            "                    and_(",
            "                        subq_all.c.dag_id == subq_failed.c.dag_id,",
            "                        subq_all.c.start_date == subq_failed.c.start_date,",
            "                    ),",
            "                )",
            "                .subquery()",
            "            )",
            "            failed_dags = dags_query.join(subq_join, DagModel.dag_id == subq_join.c.dag_id)",
            "",
            "            is_paused_count = dict(",
            "                all_dags.with_entities(DagModel.is_paused, func.count(DagModel.dag_id)).group_by(",
            "                    DagModel.is_paused",
            "                )",
            "            )",
            "",
            "            status_count_active = is_paused_count.get(False, 0)",
            "            status_count_paused = is_paused_count.get(True, 0)",
            "",
            "            status_count_running = running_dags.count()",
            "            status_count_failed = failed_dags.count()",
            "",
            "            all_dags_count = status_count_active + status_count_paused",
            "            if arg_status_filter == \"active\":",
            "                current_dags = active_dags",
            "                num_of_all_dags = status_count_active",
            "            elif arg_status_filter == \"paused\":",
            "                current_dags = paused_dags",
            "                num_of_all_dags = status_count_paused",
            "            elif arg_status_filter == \"running\":",
            "                current_dags = running_dags",
            "                num_of_all_dags = status_count_running",
            "            elif arg_status_filter == \"failed\":",
            "                current_dags = failed_dags",
            "                num_of_all_dags = status_count_failed",
            "            else:",
            "                current_dags = all_dags",
            "                num_of_all_dags = all_dags_count",
            "",
            "            if arg_sorting_key == \"last_dagrun\":",
            "                dag_run_subquery = (",
            "                    session.query(",
            "                        DagRun.dag_id,",
            "                        sqla.func.max(DagRun.execution_date).label(\"max_execution_date\"),",
            "                    )",
            "                    .group_by(DagRun.dag_id)",
            "                    .subquery()",
            "                )",
            "                current_dags = current_dags.outerjoin(",
            "                    dag_run_subquery, and_(dag_run_subquery.c.dag_id == DagModel.dag_id)",
            "                )",
            "                null_case = case((dag_run_subquery.c.max_execution_date.is_(None), 1), else_=0)",
            "                if arg_sorting_direction == \"desc\":",
            "                    current_dags = current_dags.order_by(",
            "                        null_case, dag_run_subquery.c.max_execution_date.desc()",
            "                    )",
            "",
            "                else:",
            "                    current_dags = current_dags.order_by(null_case, dag_run_subquery.c.max_execution_date)",
            "",
            "            else:",
            "                sort_column = DagModel.__table__.c.get(arg_sorting_key)",
            "                if sort_column is not None:",
            "                    null_case = case((sort_column.is_(None), 1), else_=0)",
            "                    if arg_sorting_direction == \"desc\":",
            "                        current_dags = current_dags.order_by(null_case, sort_column.desc())",
            "                    else:",
            "                        current_dags = current_dags.order_by(null_case, sort_column)",
            "",
            "            dags = current_dags.options(joinedload(DagModel.tags)).offset(start).limit(dags_per_page).all()",
            "            user_permissions = g.user.perms",
            "            can_create_dag_run = (",
            "                permissions.ACTION_CAN_CREATE,",
            "                permissions.RESOURCE_DAG_RUN,",
            "            ) in user_permissions",
            "",
            "            dataset_triggered_dag_ids = {dag.dag_id for dag in dags if dag.schedule_interval == \"Dataset\"}",
            "            if dataset_triggered_dag_ids:",
            "                dataset_triggered_next_run_info = get_dataset_triggered_next_run_info(",
            "                    dataset_triggered_dag_ids, session=session",
            "                )",
            "            else:",
            "                dataset_triggered_next_run_info = {}",
            "",
            "            for dag in dags:",
            "                dag.can_edit = get_airflow_app().appbuilder.sm.can_edit_dag(dag.dag_id, g.user)",
            "                dag.can_trigger = dag.can_edit and can_create_dag_run",
            "                dag.can_delete = get_airflow_app().appbuilder.sm.can_delete_dag(dag.dag_id, g.user)",
            "",
            "            dagtags = session.query(func.distinct(DagTag.name)).order_by(DagTag.name).all()",
            "            tags = [",
            "                {\"name\": name, \"selected\": bool(arg_tags_filter and name in arg_tags_filter)}",
            "                for name, in dagtags",
            "            ]",
            "",
            "            owner_links_dict = DagOwnerAttributes.get_all(session)",
            "",
            "            import_errors = session.query(errors.ImportError).order_by(errors.ImportError.id)",
            "",
            "            if (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG) not in user_permissions:",
            "                # if the user doesn't have access to all DAGs, only display errors from visible DAGs",
            "                import_errors = import_errors.join(",
            "                    DagModel, DagModel.fileloc == errors.ImportError.filename",
            "                ).filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "            for import_error in import_errors:",
            "                flash(",
            "                    f\"Broken DAG: [{import_error.filename}] {import_error.stacktrace}\",",
            "                    \"dag_import_error\",",
            "                )",
            "",
            "        from airflow.plugins_manager import import_errors as plugin_import_errors",
            "",
            "        for filename, stacktrace in plugin_import_errors.items():",
            "            flash(",
            "                f\"Broken plugin: [{filename}] {stacktrace}\",",
            "                \"error\",",
            "            )",
            "",
            "        num_of_pages = int(math.ceil(num_of_all_dags / float(dags_per_page)))",
            "",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"null\"] = state_color_mapping.pop(None)",
            "",
            "        page_title = conf.get(section=\"webserver\", key=\"instance_name\", fallback=\"DAGs\")",
            "        page_title_has_markup = conf.getboolean(",
            "            section=\"webserver\", key=\"instance_name_has_markup\", fallback=False",
            "        )",
            "",
            "        dashboard_alerts = [",
            "            fm for fm in settings.DASHBOARD_UIALERTS if fm.should_show(get_airflow_app().appbuilder.sm)",
            "        ]",
            "",
            "        def _iter_parsed_moved_data_table_names():",
            "            for table_name in inspect(session.get_bind()).get_table_names():",
            "                segments = table_name.split(\"__\", 3)",
            "                if len(segments) < 3:",
            "                    continue",
            "                if segments[0] != settings.AIRFLOW_MOVED_TABLE_PREFIX:",
            "                    continue",
            "                # Second segment is a version marker that we don't need to show.",
            "                yield segments[-1], table_name",
            "",
            "        if (",
            "            permissions.ACTION_CAN_ACCESS_MENU,",
            "            permissions.RESOURCE_ADMIN_MENU,",
            "        ) in user_permissions and conf.getboolean(\"webserver\", \"warn_deployment_exposure\"):",
            "            robots_file_access_count = (",
            "                session.query(Log)",
            "                .filter(Log.event == \"robots\")",
            "                .filter(Log.dttm > (utcnow() - datetime.timedelta(days=7)))",
            "                .count()",
            "            )",
            "            if robots_file_access_count > 0:",
            "                flash(",
            "                    Markup(",
            "                        \"Recent requests have been made to /robots.txt. \"",
            "                        \"This indicates that this deployment may be accessible to the public internet. \"",
            "                        \"This warning can be disabled by setting webserver.warn_deployment_exposure=False in \"",
            "                        \"airflow.cfg. Read more about web deployment security <a href=\"",
            "                        f'\"{get_docs_url(\"security/webserver.html\")}\">'",
            "                        \"here</a>\"",
            "                    ),",
            "                    \"warning\",",
            "                )",
            "",
            "        return self.render_template(",
            "            \"airflow/dags.html\",",
            "            dags=dags,",
            "            dashboard_alerts=dashboard_alerts,",
            "            migration_moved_data_alerts=sorted(set(_iter_parsed_moved_data_table_names())),",
            "            current_page=current_page,",
            "            search_query=arg_search_query if arg_search_query else \"\",",
            "            page_title=Markup(page_title) if page_title_has_markup else page_title,",
            "            page_size=dags_per_page,",
            "            num_of_pages=num_of_pages,",
            "            num_dag_from=min(start + 1, num_of_all_dags),",
            "            num_dag_to=min(end, num_of_all_dags),",
            "            num_of_all_dags=num_of_all_dags,",
            "            paging=wwwutils.generate_pages(",
            "                current_page,",
            "                num_of_pages,",
            "                search=escape(arg_search_query) if arg_search_query else None,",
            "                status=arg_status_filter if arg_status_filter else None,",
            "                tags=arg_tags_filter if arg_tags_filter else None,",
            "                sorting_key=arg_sorting_key if arg_sorting_key else None,",
            "                sorting_direction=arg_sorting_direction if arg_sorting_direction else None,",
            "            ),",
            "            num_runs=num_runs,",
            "            tags=tags,",
            "            owner_links=owner_links_dict,",
            "            state_color=state_color_mapping,",
            "            status_filter=arg_status_filter,",
            "            status_count_all=all_dags_count,",
            "            status_count_active=status_count_active,",
            "            status_count_paused=status_count_paused,",
            "            status_count_running=status_count_running,",
            "            status_count_failed=status_count_failed,",
            "            tags_filter=arg_tags_filter,",
            "            sorting_key=arg_sorting_key,",
            "            sorting_direction=arg_sorting_direction,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            dataset_triggered_next_run_info=dataset_triggered_next_run_info,",
            "        )",
            "",
            "    @expose(\"/datasets\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DATASET)])",
            "    def datasets(self):",
            "        \"\"\"Datasets view.\"\"\"",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"null\"] = state_color_mapping.pop(None)",
            "        return self.render_template(",
            "            \"airflow/datasets.html\",",
            "            state_color_mapping=state_color_mapping,",
            "        )",
            "",
            "    @expose(\"/cluster_activity\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CLUSTER_ACTIVITY),",
            "        ]",
            "    )",
            "    def cluster_activity(self):",
            "        \"\"\"Cluster Activity view.\"\"\"",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"no_status\"] = state_color_mapping.pop(None)",
            "        return self.render_template(",
            "            \"airflow/cluster_activity.html\",",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            state_color_mapping=state_color_mapping,",
            "        )",
            "",
            "    @expose(\"/next_run_datasets_summary\", methods=[\"POST\"])",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    @provide_session",
            "    def next_run_datasets_summary(self, session: Session = NEW_SESSION):",
            "        \"\"\"Next run info for dataset triggered DAGs.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        if not allowed_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        dataset_triggered_dag_ids = [",
            "            dag.dag_id",
            "            for dag in (",
            "                session.query(DagModel.dag_id)",
            "                .filter(DagModel.dag_id.in_(filter_dag_ids))",
            "                .filter(DagModel.schedule_interval == \"Dataset\")",
            "            )",
            "        ]",
            "",
            "        dataset_triggered_next_run_info = get_dataset_triggered_next_run_info(",
            "            dataset_triggered_dag_ids, session=session",
            "        )",
            "",
            "        return flask.json.jsonify(dataset_triggered_next_run_info)",
            "",
            "    @expose(\"/dag_stats\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def dag_stats(self, session: Session = NEW_SESSION):",
            "        \"\"\"Dag statistics.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        dag_state_stats = (",
            "            session.query(DagRun.dag_id, DagRun.state, sqla.func.count(DagRun.state))",
            "            .group_by(DagRun.dag_id, DagRun.state)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))",
            "        )",
            "        dag_state_data = {(dag_id, state): count for dag_id, state, count in dag_state_stats}",
            "",
            "        payload = {",
            "            dag_id: [",
            "                {\"state\": state, \"count\": dag_state_data.get((dag_id, state), 0)}",
            "                for state in State.dag_states",
            "            ]",
            "            for dag_id in filter_dag_ids",
            "        }",
            "        return flask.json.jsonify(payload)",
            "",
            "    @expose(\"/task_stats\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def task_stats(self, session: Session = NEW_SESSION):",
            "        \"\"\"Task Statistics.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        if not allowed_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        running_dag_run_query_result = (",
            "            session.query(DagRun.dag_id, DagRun.run_id)",
            "            .join(DagModel, DagModel.dag_id == DagRun.dag_id)",
            "            .filter(DagRun.state == State.RUNNING, DagModel.is_active)",
            "        )",
            "",
            "        running_dag_run_query_result = running_dag_run_query_result.filter(DagRun.dag_id.in_(filter_dag_ids))",
            "",
            "        running_dag_run_query_result = running_dag_run_query_result.subquery(\"running_dag_run\")",
            "",
            "        # Select all task_instances from active dag_runs.",
            "        running_task_instance_query_result = session.query(",
            "            TaskInstance.dag_id.label(\"dag_id\"),",
            "            TaskInstance.state.label(\"state\"),",
            "            sqla.literal(True).label(\"is_dag_running\"),",
            "        ).join(",
            "            running_dag_run_query_result,",
            "            and_(",
            "                running_dag_run_query_result.c.dag_id == TaskInstance.dag_id,",
            "                running_dag_run_query_result.c.run_id == TaskInstance.run_id,",
            "            ),",
            "        )",
            "",
            "        if conf.getboolean(\"webserver\", \"SHOW_RECENT_STATS_FOR_COMPLETED_RUNS\", fallback=True):",
            "            last_dag_run = (",
            "                session.query(DagRun.dag_id, sqla.func.max(DagRun.execution_date).label(\"execution_date\"))",
            "                .join(DagModel, DagModel.dag_id == DagRun.dag_id)",
            "                .filter(DagRun.state != State.RUNNING, DagModel.is_active)",
            "                .group_by(DagRun.dag_id)",
            "            )",
            "",
            "            last_dag_run = last_dag_run.filter(DagRun.dag_id.in_(filter_dag_ids))",
            "            last_dag_run = last_dag_run.subquery(\"last_dag_run\")",
            "",
            "            # Select all task_instances from active dag_runs.",
            "            # If no dag_run is active, return task instances from most recent dag_run.",
            "            last_task_instance_query_result = (",
            "                session.query(",
            "                    TaskInstance.dag_id.label(\"dag_id\"),",
            "                    TaskInstance.state.label(\"state\"),",
            "                    sqla.literal(False).label(\"is_dag_running\"),",
            "                )",
            "                .join(TaskInstance.dag_run)",
            "                .join(",
            "                    last_dag_run,",
            "                    and_(",
            "                        last_dag_run.c.dag_id == TaskInstance.dag_id,",
            "                        last_dag_run.c.execution_date == DagRun.execution_date,",
            "                    ),",
            "                )",
            "            )",
            "",
            "            final_task_instance_query_result = union_all(",
            "                last_task_instance_query_result, running_task_instance_query_result",
            "            ).alias(\"final_ti\")",
            "        else:",
            "            final_task_instance_query_result = running_task_instance_query_result.subquery(\"final_ti\")",
            "",
            "        qry = (",
            "            session.query(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.state,",
            "                final_task_instance_query_result.c.is_dag_running,",
            "                sqla.func.count(),",
            "            )",
            "            .group_by(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.state,",
            "                final_task_instance_query_result.c.is_dag_running,",
            "            )",
            "            .order_by(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.is_dag_running.desc(),",
            "            )",
            "        )",
            "",
            "        data = get_task_stats_from_query(qry)",
            "        payload: dict[str, list[dict[str, Any]]] = collections.defaultdict(list)",
            "        for dag_id in filter_dag_ids:",
            "            for state in State.task_states:",
            "                count = data.get(dag_id, {}).get(state, 0)",
            "                payload[dag_id].append({\"state\": state, \"count\": count})",
            "        return flask.json.jsonify(payload)",
            "",
            "    @expose(\"/last_dagruns\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def last_dagruns(self, session: Session = NEW_SESSION):",
            "        \"\"\"Last DAG runs.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        last_runs_subquery = (",
            "            session.query(",
            "                DagRun.dag_id,",
            "                sqla.func.max(DagRun.execution_date).label(\"max_execution_date\"),",
            "            )",
            "            .group_by(DagRun.dag_id)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))  # Only include accessible/selected DAGs.",
            "            .subquery(\"last_runs\")",
            "        )",
            "",
            "        query = session.query(",
            "            DagRun.dag_id,",
            "            DagRun.start_date,",
            "            DagRun.end_date,",
            "            DagRun.state,",
            "            DagRun.execution_date,",
            "            DagRun.data_interval_start,",
            "            DagRun.data_interval_end,",
            "        ).join(",
            "            last_runs_subquery,",
            "            and_(",
            "                last_runs_subquery.c.dag_id == DagRun.dag_id,",
            "                last_runs_subquery.c.max_execution_date == DagRun.execution_date,",
            "            ),",
            "        )",
            "",
            "        resp = {",
            "            r.dag_id.replace(\".\", \"__dot__\"): {",
            "                \"dag_id\": r.dag_id,",
            "                \"state\": r.state,",
            "                \"execution_date\": wwwutils.datetime_to_string(r.execution_date),",
            "                \"start_date\": wwwutils.datetime_to_string(r.start_date),",
            "                \"end_date\": wwwutils.datetime_to_string(r.end_date),",
            "                \"data_interval_start\": wwwutils.datetime_to_string(r.data_interval_start),",
            "                \"data_interval_end\": wwwutils.datetime_to_string(r.data_interval_end),",
            "            }",
            "            for r in query",
            "        }",
            "        return flask.json.jsonify(resp)",
            "",
            "    @expose(\"/code\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_CODE),",
            "        ]",
            "    )",
            "    def legacy_code(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.code\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/code\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_CODE),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def code(self, dag_id, session: Session = NEW_SESSION):",
            "        \"\"\"Dag Code.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag or not dag_model:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag_model.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag_model.dag_id, session)",
            "",
            "        try:",
            "            code = DagCode.get_code_by_fileloc(dag_model.fileloc)",
            "            html_code = Markup(highlight(code, lexers.PythonLexer(), HtmlFormatter(linenos=True)))",
            "        except Exception as e:",
            "            error = f\"Exception encountered during dag code retrieval/code highlighting:\\n\\n{e}\\n\"",
            "            html_code = Markup(\"<p>Failed to load DAG file Code.</p><p>Details: {}</p>\").format(escape(error))",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_code.html\",",
            "            html_code=html_code,",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            title=dag_id,",
            "            root=request.args.get(\"root\"),",
            "            wrapped=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "        )",
            "",
            "    @expose(\"/dag_details\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    def legacy_dag_details(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.dag_details\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/details\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def dag_details(self, dag_id, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag details.\"\"\"",
            "        from airflow.models.dag import DagOwnerAttributes",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        title = \"DAG Details\"",
            "        root = request.args.get(\"root\", \"\")",
            "",
            "        states = (",
            "            session.query(TaskInstance.state, sqla.func.count(TaskInstance.dag_id))",
            "            .filter(TaskInstance.dag_id == dag_id)",
            "            .group_by(TaskInstance.state)",
            "            .all()",
            "        )",
            "",
            "        active_runs = models.DagRun.find(dag_id=dag_id, state=DagRunState.RUNNING, external_trigger=False)",
            "",
            "        tags = session.query(models.DagTag).filter(models.DagTag.dag_id == dag_id).all()",
            "",
            "        # TODO: convert this to a relationship",
            "        owner_links = session.query(DagOwnerAttributes).filter_by(dag_id=dag_id).all()",
            "",
            "        attrs_to_avoid = [",
            "            \"schedule_datasets\",",
            "            \"schedule_dataset_references\",",
            "            \"task_outlet_dataset_references\",",
            "            \"NUM_DAGS_PER_DAGRUN_QUERY\",",
            "            \"serialized_dag\",",
            "            \"tags\",",
            "            \"default_view\",",
            "            \"relative_fileloc\",",
            "            \"dag_id\",",
            "            \"description\",",
            "            \"max_active_runs\",",
            "            \"max_active_tasks\",",
            "            \"schedule_interval\",",
            "            \"owners\",",
            "            \"dag_owner_links\",",
            "            \"is_paused\",",
            "        ]",
            "        attrs_to_avoid.extend(wwwutils.get_attr_renderer().keys())",
            "        dag_model_attrs: list[tuple[str, Any]] = [",
            "            (attr_name, attr)",
            "            for attr_name, attr in (",
            "                (attr_name, getattr(dag_model, attr_name))",
            "                for attr_name in dir(dag_model)",
            "                if not attr_name.startswith(\"_\") and attr_name not in attrs_to_avoid",
            "            )",
            "            if not callable(attr)",
            "        ]",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_details.html\",",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            title=title,",
            "            root=root,",
            "            states=states,",
            "            State=State,",
            "            active_runs=active_runs,",
            "            tags=tags,",
            "            owner_links=owner_links,",
            "            dag_model_attrs=dag_model_attrs,",
            "        )",
            "",
            "    @expose(\"/rendered-templates\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def rendered_templates(self, session):",
            "        \"\"\"Get rendered Dag.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "",
            "        logging.info(\"Retrieving rendered templates.\")",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dag_run = dag.get_dagrun(execution_date=dttm, session=session)",
            "        raw_task = dag.get_task(task_id).prepare_for_execution()",
            "",
            "        title = \"Rendered Template\"",
            "        html_dict = {}",
            "",
            "        ti: TaskInstance",
            "        if dag_run is None:",
            "            # No DAG run matching given logical date. This usually means this",
            "            # DAG has never been run. Task instance rendering does not really",
            "            # make sense in this situation, but \"works\" prior to AIP-39. This",
            "            # \"fakes\" a temporary DagRun-TaskInstance association (not saved to",
            "            # database) for presentation only.",
            "            ti = TaskInstance(raw_task, map_index=map_index)",
            "            ti.dag_run = DagRun(dag_id=dag_id, execution_date=dttm)",
            "        else:",
            "            ti = dag_run.get_task_instance(task_id=task_id, map_index=map_index, session=session)",
            "            if ti:",
            "                ti.refresh_from_task(raw_task)",
            "            else:",
            "                flash(f\"there is no task instance with the provided map_index {map_index}\", \"error\")",
            "                return self.render_template(",
            "                    \"airflow/ti_code.html\",",
            "                    html_dict=html_dict,",
            "                    dag=dag,",
            "                    task_id=task_id,",
            "                    execution_date=execution_date,",
            "                    map_index=map_index,",
            "                    form=form,",
            "                    root=root,",
            "                    title=title,",
            "                )",
            "",
            "        try:",
            "            ti.get_rendered_template_fields(session=session)",
            "        except AirflowException as e:",
            "            if not e.__cause__:",
            "                flash(f\"Error rendering template: {e}\", \"error\")",
            "            else:",
            "                msg = Markup(\"Error rendering template: {0}<br><br>OriginalError: {0.__cause__}\").format(e)",
            "                flash(msg, \"error\")",
            "        except Exception as e:",
            "            flash(f\"Error rendering template: {e}\", \"error\")",
            "",
            "        # Ensure we are rendering the unmapped operator. Unmapping should be",
            "        # done automatically if template fields are rendered successfully; this",
            "        # only matters if get_rendered_template_fields() raised an exception.",
            "        # The following rendering won't show useful values in this case anyway,",
            "        # but we'll display some quasi-meaingful field names.",
            "        task = ti.task.unmap(None)",
            "",
            "        renderers = wwwutils.get_attr_renderer()",
            "",
            "        for template_field in task.template_fields:",
            "            content = getattr(task, template_field)",
            "            renderer = task.template_fields_renderers.get(template_field, template_field)",
            "            if renderer in renderers:",
            "                if isinstance(content, (dict, list)):",
            "                    json_content = json.dumps(content, sort_keys=True, indent=4)",
            "                    html_dict[template_field] = renderers[renderer](json_content)",
            "                else:",
            "                    html_dict[template_field] = renderers[renderer](content)",
            "            else:",
            "                html_dict[template_field] = Markup(\"<pre><code>{}</pre></code>\").format(pformat(content))",
            "",
            "            if isinstance(content, dict):",
            "                if template_field == \"op_kwargs\":",
            "                    for key, value in content.items():",
            "                        renderer = task.template_fields_renderers.get(key, key)",
            "                        if renderer in renderers:",
            "                            html_dict[\".\".join([template_field, key])] = renderers[renderer](value)",
            "                        else:",
            "                            html_dict[\".\".join([template_field, key])] = Markup(",
            "                                \"<pre><code>{}</pre></code>\"",
            "                            ).format(pformat(value))",
            "                else:",
            "                    for dict_keys in get_key_paths(content):",
            "                        template_path = \".\".join((template_field, dict_keys))",
            "                        renderer = task.template_fields_renderers.get(template_path, template_path)",
            "                        if renderer in renderers:",
            "                            content_value = get_value_from_path(dict_keys, content)",
            "                            html_dict[template_path] = renderers[renderer](content_value)",
            "",
            "        return self.render_template(",
            "            \"airflow/ti_code.html\",",
            "            html_dict=html_dict,",
            "            dag=dag,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/rendered-k8s\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def rendered_k8s(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Get rendered k8s yaml.\"\"\"",
            "        if not settings.IS_K8S_OR_K8SCELERY_EXECUTOR:",
            "            abort(404)",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        if task_id is None:",
            "            logging.warning(\"Task id not passed in the request\")",
            "            abort(400)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        logging.info(\"Retrieving rendered templates.\")",
            "",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        task = dag.get_task(task_id)",
            "        dag_run = dag.get_dagrun(execution_date=dttm, session=session)",
            "        ti = dag_run.get_task_instance(task_id=task.task_id, map_index=map_index, session=session)",
            "",
            "        pod_spec = None",
            "        try:",
            "            pod_spec = ti.get_rendered_k8s_spec(session=session)",
            "        except AirflowException as e:",
            "            if not e.__cause__:",
            "                flash(f\"Error rendering Kubernetes POD Spec: {e}\", \"error\")",
            "            else:",
            "                tmp = Markup(\"Error rendering Kubernetes POD Spec: {0}<br><br>Original error: {0.__cause__}\")",
            "                flash(tmp.format(e), \"error\")",
            "        except Exception as e:",
            "            flash(f\"Error rendering Kubernetes Pod Spec: {e}\", \"error\")",
            "        title = \"Rendered K8s Pod Spec\"",
            "",
            "        if pod_spec:",
            "            content = wwwutils.get_attr_renderer()[\"yaml\"](yaml.dump(pod_spec))",
            "        else:",
            "            content = Markup(\"<pre><code>Error rendering Kubernetes POD Spec</pre></code>\")",
            "",
            "        return self.render_template(",
            "            \"airflow/ti_code.html\",",
            "            html_dict={\"k8s\": content},",
            "            dag=dag,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/get_logs_with_metadata\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def get_logs_with_metadata(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve logs including metadata.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date_str = request.args[\"execution_date\"]",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        try_number = request.args.get(\"try_number\", type=int)",
            "        metadata_str = request.args.get(\"metadata\", \"{}\")",
            "        response_format = request.args.get(\"format\", \"json\")",
            "",
            "        # Validate JSON metadata",
            "        try:",
            "            metadata: dict = json.loads(metadata_str) or {}",
            "        except json.decoder.JSONDecodeError:",
            "            return {\"error\": \"Invalid JSON metadata\"}, 400",
            "",
            "        # Convert string datetime into actual datetime",
            "        try:",
            "            execution_date = timezone.parse(execution_date_str)",
            "        except ValueError:",
            "            error_message = (",
            "                f\"Given execution date, {execution_date}, could not be identified as a date. \"",
            "                \"Example date format: 2015-11-16T14:34:15+00:00\"",
            "            )",
            "            return {\"error\": error_message}, 400",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if not task_log_reader.supports_read:",
            "            return {",
            "                \"message\": \"Task log handler does not support read logs.\",",
            "                \"error\": True,",
            "                \"metadata\": {\"end_of_log\": True},",
            "            }",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter(",
            "                TaskInstance.task_id == task_id,",
            "                TaskInstance.dag_id == dag_id,",
            "                TaskInstance.execution_date == execution_date,",
            "                TaskInstance.map_index == map_index,",
            "            )",
            "            .join(TaskInstance.dag_run)",
            "            .options(joinedload(\"trigger\"))",
            "            .options(joinedload(\"trigger.triggerer_job\"))",
            "            .first()",
            "        )",
            "",
            "        if ti is None:",
            "            return {",
            "                \"message\": \"*** Task instance did not exist in the DB\\n\",",
            "                \"error\": True,",
            "                \"metadata\": {\"end_of_log\": True},",
            "            }",
            "",
            "        try:",
            "            dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "            if dag:",
            "                ti.task = dag.get_task(ti.task_id)",
            "",
            "            if response_format == \"json\":",
            "                logs, metadata = task_log_reader.read_log_chunks(ti, try_number, metadata)",
            "                message = logs[0] if try_number is not None else logs",
            "                return {\"message\": message, \"metadata\": metadata}",
            "",
            "            metadata[\"download_logs\"] = True",
            "            attachment_filename = task_log_reader.render_log_filename(ti, try_number, session=session)",
            "            log_stream = task_log_reader.read_log_stream(ti, try_number, metadata)",
            "            return Response(",
            "                response=log_stream,",
            "                mimetype=\"text/plain\",",
            "                headers={\"Content-Disposition\": f\"attachment; filename={attachment_filename}\"},",
            "            )",
            "        except AttributeError as e:",
            "            error_messages = [f\"Task log handler does not support read logs.\\n{str(e)}\\n\"]",
            "            metadata[\"end_of_log\"] = True",
            "            return {\"message\": error_messages, \"error\": True, \"metadata\": metadata}",
            "",
            "    @expose(\"/log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def log(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve log.\"\"\"",
            "        dag_id = request.args[\"dag_id\"]",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "",
            "        if execution_date:",
            "            dttm = _safe_parse_datetime(execution_date)",
            "        else:",
            "            dttm = None",
            "",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        dag_model = DagModel.get_dagmodel(dag_id)",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .first()",
            "        )",
            "",
            "        num_logs = 0",
            "        if ti is not None:",
            "            num_logs = wwwutils.get_try_count(ti._try_number, ti.state)",
            "        logs = [\"\"] * num_logs",
            "        root = request.args.get(\"root\", \"\")",
            "        return self.render_template(",
            "            \"airflow/ti_log.html\",",
            "            logs=logs,",
            "            dag=dag_model,",
            "            title=\"Log by attempts\",",
            "            dag_id=dag_id,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            wrapped=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "        )",
            "",
            "    @expose(\"/redirect_to_external_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def redirect_to_external_log(self, session: Session = NEW_SESSION):",
            "        \"\"\"Redirects to external log.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        try_number = request.args.get(\"try_number\", 1)",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .first()",
            "        )",
            "",
            "        if not ti:",
            "            flash(f\"Task [{dag_id}.{task_id}] does not exist\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if not task_log_reader.supports_external_link:",
            "            flash(\"Task log handler does not support external links\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        handler = task_log_reader.log_handler",
            "        url = handler.get_external_log_url(ti, try_number)",
            "        return redirect(url)",
            "",
            "    @expose(\"/task\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def task(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve task.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag or task_id not in dag.task_ids:",
            "            flash(f\"Task [{dag_id}.{task_id}] doesn't seem to exist at the moment\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "        task = copy.copy(dag.get_task(task_id))",
            "        task.resolve_template_files()",
            "",
            "        ti: TaskInstance | None = (",
            "            session.query(TaskInstance)",
            "            .options(",
            "                # HACK: Eager-load relationships. This is needed because",
            "                # multiple properties mis-use provide_session() that destroys",
            "                # the session object ti is bounded to.",
            "                joinedload(TaskInstance.queued_by_job, innerjoin=False),",
            "                joinedload(TaskInstance.trigger, innerjoin=False),",
            "            )",
            "            .filter_by(execution_date=dttm, dag_id=dag_id, task_id=task_id, map_index=map_index)",
            "            .one_or_none()",
            "        )",
            "        if ti is None:",
            "            ti_attrs: list[tuple[str, Any]] | None = None",
            "        else:",
            "            ti.refresh_from_task(task)",
            "            ti_attrs_to_skip = [",
            "                \"dag_id\",",
            "                \"key\",",
            "                \"mark_success_url\",",
            "                \"log\",",
            "                \"log_url\",",
            "                \"task\",",
            "                \"trigger\",",
            "                \"triggerer_job\",",
            "            ]",
            "            # Some fields on TI are deprecated, but we don't want those warnings here.",
            "            with warnings.catch_warnings():",
            "                warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "                all_ti_attrs = (",
            "                    (name, getattr(ti, name))",
            "                    for name in dir(ti)",
            "                    if not name.startswith(\"_\") and name not in ti_attrs_to_skip",
            "                )",
            "            ti_attrs = sorted((name, attr) for name, attr in all_ti_attrs if not callable(attr))",
            "",
            "        attr_renderers = wwwutils.get_attr_renderer()",
            "",
            "        attrs_to_skip: frozenset[str] = getattr(task, \"HIDE_ATTRS_FROM_UI\", frozenset())",
            "",
            "        def include_task_attrs(attr_name):",
            "            return not (",
            "                attr_name == \"HIDE_ATTRS_FROM_UI\"",
            "                or attr_name.startswith(\"_\")",
            "                or attr_name in attr_renderers",
            "                or attr_name in attrs_to_skip",
            "            )",
            "",
            "        task_attrs = [",
            "            (attr_name, secrets_masker.redact(attr, attr_name))",
            "            for attr_name, attr in (",
            "                (attr_name, getattr(task, attr_name)) for attr_name in filter(include_task_attrs, dir(task))",
            "            )",
            "            if not callable(attr)",
            "        ]",
            "",
            "        # Color coding the special attributes that are code",
            "        special_attrs_rendered = {",
            "            attr_name: renderer(getattr(task, attr_name))",
            "            for attr_name, renderer in attr_renderers.items()",
            "            if hasattr(task, attr_name)",
            "        }",
            "",
            "        no_failed_deps_result = [",
            "            (",
            "                \"Unknown\",",
            "                \"All dependencies are met but the task instance is not running. In most \"",
            "                \"cases this just means that the task will probably be scheduled soon \"",
            "                \"unless:<br>\\n- The scheduler is down or under heavy load<br>\\n{}\\n\"",
            "                \"<br>\\nIf this task instance does not start soon please contact your \"",
            "                \"Airflow administrator for assistance.\".format(",
            "                    \"- This task instance already ran and had it's state changed manually \"",
            "                    \"(e.g. cleared in the UI)<br>\"",
            "                    if ti and ti.state == State.NONE",
            "                    else \"\"",
            "                ),",
            "            )",
            "        ]",
            "",
            "        # Use the scheduler's context to figure out which dependencies are not met",
            "        if ti is None:",
            "            failed_dep_reasons: list[tuple[str, str]] = []",
            "        else:",
            "            dep_context = DepContext(SCHEDULER_QUEUED_DEPS)",
            "            failed_dep_reasons = [",
            "                (dep.dep_name, dep.reason) for dep in ti.get_failed_dep_statuses(dep_context=dep_context)",
            "            ]",
            "",
            "        title = \"Task Instance Details\"",
            "        return self.render_template(",
            "            \"airflow/task.html\",",
            "            task_attrs=task_attrs,",
            "            ti_attrs=ti_attrs,",
            "            failed_dep_reasons=failed_dep_reasons or no_failed_deps_result,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            special_attrs_rendered=special_attrs_rendered,",
            "            form=form,",
            "            root=root,",
            "            dag=dag,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/xcom\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_XCOM),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def xcom(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve XCOM.\"\"\"",
            "        dag_id = request.args[\"dag_id\"]",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        # Carrying execution_date through, even though it's irrelevant for",
            "        # this context",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        dag = DagModel.get_dagmodel(dag_id)",
            "        ti = session.query(TaskInstance).filter_by(dag_id=dag_id, task_id=task_id).first()",
            "",
            "        if not ti:",
            "            flash(f\"Task [{dag_id}.{task_id}] doesn't seem to exist at the moment\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        xcom_query = session.query(XCom.key, XCom.value).filter(",
            "            XCom.dag_id == dag_id,",
            "            XCom.task_id == task_id,",
            "            XCom.execution_date == dttm,",
            "            XCom.map_index == map_index,",
            "        )",
            "        attributes = [(k, v) for k, v in xcom_query if not k.startswith(\"_\")]",
            "",
            "        title = \"XCom\"",
            "        return self.render_template(",
            "            \"airflow/xcom.html\",",
            "            attributes=attributes,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            dag=dag,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/delete\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def delete(self):",
            "        \"\"\"Deletes DAG.\"\"\"",
            "        from airflow.api.common import delete_dag",
            "        from airflow.exceptions import DagNotFound",
            "",
            "        dag_id = request.values.get(\"dag_id\")",
            "        origin = get_safe_url(request.values.get(\"origin\"))",
            "        redirect_url = get_safe_url(request.values.get(\"redirect_url\"))",
            "",
            "        try:",
            "            delete_dag.delete_dag(dag_id)",
            "        except DagNotFound:",
            "            flash(f\"DAG with id {dag_id} not found. Cannot delete\", \"error\")",
            "            return redirect(redirect_url)",
            "        except AirflowException:",
            "            flash(",
            "                f\"Cannot delete DAG with id {dag_id} because some task instances of the DAG \"",
            "                \"are still running. Please mark the  task instances as \"",
            "                \"failed/succeeded before deleting the DAG\",",
            "                \"error\",",
            "            )",
            "            return redirect(redirect_url)",
            "",
            "        flash(f\"Deleting DAG with id {dag_id}. May take a couple minutes to fully disappear.\")",
            "",
            "        # Upon success return to origin.",
            "        return redirect(origin)",
            "",
            "    @expose(\"/dags/<string:dag_id>/trigger\", methods=[\"POST\", \"GET\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_CREATE, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def trigger(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Triggers DAG Run.\"\"\"",
            "        run_id = request.values.get(\"run_id\", \"\")",
            "        origin = get_safe_url(request.values.get(\"origin\"))",
            "        unpause = request.values.get(\"unpause\")",
            "        request_conf = request.values.get(\"conf\")",
            "        request_execution_date = request.values.get(\"execution_date\", default=timezone.utcnow().isoformat())",
            "        is_dag_run_conf_overrides_params = conf.getboolean(\"core\", \"dag_run_conf_overrides_params\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dag_orm: DagModel = session.query(DagModel).filter(DagModel.dag_id == dag_id).first()",
            "",
            "        # Prepare form fields with param struct details to render a proper form with schema information",
            "        form_fields = {}",
            "        for k, v in dag.params.items():",
            "            form_fields[k] = v.dump()",
            "            # If no schema is provided, auto-detect on default values",
            "            if \"schema\" not in form_fields[k]:",
            "                form_fields[k][\"schema\"] = {}",
            "            if \"type\" not in form_fields[k][\"schema\"]:",
            "                if isinstance(form_fields[k][\"value\"], bool):",
            "                    form_fields[k][\"schema\"][\"type\"] = \"boolean\"",
            "                elif isinstance(form_fields[k][\"value\"], int):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"integer\", \"null\"]",
            "                elif isinstance(form_fields[k][\"value\"], list):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"array\", \"null\"]",
            "                elif isinstance(form_fields[k][\"value\"], dict):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"object\", \"null\"]",
            "            # Mark markup fields as safe",
            "            if (",
            "                \"description_html\" in form_fields[k][\"schema\"]",
            "                and form_fields[k][\"schema\"][\"description_html\"]",
            "            ):",
            "                form_fields[k][\"description\"] = Markup(form_fields[k][\"schema\"][\"description_html\"])",
            "            if \"custom_html_form\" in form_fields[k][\"schema\"]:",
            "                form_fields[k][\"schema\"][\"custom_html_form\"] = Markup(",
            "                    form_fields[k][\"schema\"][\"custom_html_form\"]",
            "                )",
            "        ui_fields_defined = any(\"const\" not in f[\"schema\"] for f in form_fields.values())",
            "",
            "        if not dag_orm:",
            "            flash(f\"Cannot find dag {dag_id}\")",
            "            return redirect(origin)",
            "",
            "        if dag_orm.has_import_errors:",
            "            flash(f\"Cannot create dagruns because the dag {dag_id} has import errors\", \"error\")",
            "            return redirect(origin)",
            "",
            "        recent_runs = (",
            "            session.query(",
            "                DagRun.conf, func.max(DagRun.run_id).label(\"run_id\"), func.max(DagRun.execution_date)",
            "            )",
            "            .filter(",
            "                DagRun.dag_id == dag_id,",
            "                DagRun.run_type == DagRunType.MANUAL,",
            "                DagRun.conf.isnot(None),",
            "            )",
            "            .group_by(DagRun.conf)",
            "            .order_by(func.max(DagRun.execution_date).desc())",
            "            .limit(5)",
            "        )",
            "        recent_confs = {",
            "            run_id: json.dumps(run_conf)",
            "            for run_id, run_conf in ((run.run_id, run.conf) for run in recent_runs)",
            "            if isinstance(run_conf, dict) and any(run_conf)",
            "        }",
            "",
            "        if request.method == \"GET\" and ui_fields_defined:",
            "            # Populate conf textarea with conf requests parameter, or dag.params",
            "            default_conf = \"\"",
            "",
            "            doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "            form = DateTimeForm(data={\"execution_date\": request_execution_date})",
            "",
            "            if request_conf:",
            "                default_conf = request_conf",
            "            else:",
            "                try:",
            "                    default_conf = json.dumps(",
            "                        {str(k): v.resolve(suppress_exception=True) for k, v in dag.params.items()},",
            "                        indent=4,",
            "                        ensure_ascii=False,",
            "                    )",
            "                except TypeError:",
            "                    flash(\"Could not pre-populate conf field due to non-JSON-serializable data-types\")",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=default_conf,",
            "                doc_md=doc_md,",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                recent_confs=recent_confs,",
            "            )",
            "",
            "        try:",
            "            execution_date = timezone.parse(request_execution_date)",
            "        except ParserError:",
            "            flash(\"Invalid execution date\", \"error\")",
            "            form = DateTimeForm(data={\"execution_date\": timezone.utcnow().isoformat()})",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=request_conf if request_conf else {},",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                recent_confs=recent_confs,",
            "            )",
            "",
            "        dr = DagRun.find_duplicate(dag_id=dag_id, run_id=run_id, execution_date=execution_date)",
            "        if dr:",
            "            if dr.run_id == run_id:",
            "                message = f\"The run ID {run_id} already exists\"",
            "            else:",
            "                message = f\"The logical date {execution_date} already exists\"",
            "            flash(message, \"error\")",
            "            return redirect(origin)",
            "",
            "        # Flash a warning when slash is used, but still allow it to continue on.",
            "        if run_id and \"/\" in run_id:",
            "            flash(",
            "                \"Using forward slash ('/') in a DAG run ID is deprecated. Note that this character \"",
            "                \"also makes the run impossible to retrieve via Airflow's REST API.\",",
            "                \"warning\",",
            "            )",
            "",
            "        run_conf = {}",
            "        if request_conf:",
            "            try:",
            "                run_conf = json.loads(request_conf)",
            "                if not isinstance(run_conf, dict):",
            "                    flash(\"Invalid JSON configuration, must be a dict\", \"error\")",
            "                    form = DateTimeForm(data={\"execution_date\": execution_date})",
            "                    return self.render_template(",
            "                        \"airflow/trigger.html\",",
            "                        form_fields=form_fields,",
            "                        dag=dag,",
            "                        dag_id=dag_id,",
            "                        origin=origin,",
            "                        conf=request_conf,",
            "                        form=form,",
            "                        is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                        recent_confs=recent_confs,",
            "                    )",
            "            except json.decoder.JSONDecodeError:",
            "                flash(\"Invalid JSON configuration, not parseable\", \"error\")",
            "                form = DateTimeForm(data={\"execution_date\": execution_date})",
            "                return self.render_template(",
            "                    \"airflow/trigger.html\",",
            "                    form_fields=form_fields,",
            "                    dag=dag,",
            "                    dag_id=dag_id,",
            "                    origin=origin,",
            "                    conf=request_conf,",
            "                    form=form,",
            "                    is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                    recent_confs=recent_confs,",
            "                )",
            "",
            "        if unpause and dag.get_is_paused():",
            "            dag_model = models.DagModel.get_dagmodel(dag_id)",
            "            if dag_model is not None:",
            "                dag_model.set_is_paused(is_paused=False)",
            "",
            "        try:",
            "            dag.create_dagrun(",
            "                run_type=DagRunType.MANUAL,",
            "                execution_date=execution_date,",
            "                data_interval=dag.timetable.infer_manual_data_interval(run_after=execution_date),",
            "                state=State.QUEUED,",
            "                conf=run_conf,",
            "                external_trigger=True,",
            "                dag_hash=get_airflow_app().dag_bag.dags_hash.get(dag_id),",
            "                run_id=run_id,",
            "            )",
            "        except (ValueError, ParamValidationError) as ve:",
            "            flash(f\"{ve}\", \"error\")",
            "            form = DateTimeForm(data={\"execution_date\": execution_date})",
            "            # Take over \"bad\" submitted fields for new form display",
            "            for k, v in form_fields.items():",
            "                form_fields[k][\"value\"] = run_conf[k]",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=request_conf,",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "            )",
            "",
            "        flash(f\"Triggered {dag_id}, it should start any moment now.\")",
            "        return redirect(origin)",
            "",
            "    def _clear_dag_tis(",
            "        self,",
            "        dag: DAG,",
            "        start_date: datetime.datetime | None,",
            "        end_date: datetime.datetime | None,",
            "        *,",
            "        origin: str | None,",
            "        task_ids: Collection[str | tuple[str, int]] | None = None,",
            "        recursive: bool = False,",
            "        confirmed: bool = False,",
            "        only_failed: bool = False,",
            "        session: Session,",
            "    ):",
            "        if confirmed:",
            "            count = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                task_ids=task_ids,",
            "                include_subdags=recursive,",
            "                include_parentdag=recursive,",
            "                only_failed=only_failed,",
            "                session=session,",
            "            )",
            "",
            "            msg = f\"{count} task instances have been cleared\"",
            "            return redirect_or_json(origin, msg)",
            "",
            "        try:",
            "            tis = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                task_ids=task_ids,",
            "                include_subdags=recursive,",
            "                include_parentdag=recursive,",
            "                only_failed=only_failed,",
            "                dry_run=True,",
            "                session=session,",
            "            )",
            "        except AirflowException as ex:",
            "            return redirect_or_json(origin, msg=str(ex), status=\"error\", status_code=500)",
            "",
            "        assert isinstance(tis, collections.abc.Iterable)",
            "        details = [str(t) for t in tis]",
            "",
            "        if not details:",
            "            return redirect_or_json(origin, \"No task instances to clear\", status=\"error\", status_code=404)",
            "        elif request.headers.get(\"Accept\") == \"application/json\":",
            "            if confirmed:",
            "                return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "            return htmlsafe_json_dumps(",
            "                [{\"task_id\": ti.task_id, \"map_index\": ti.map_index, \"run_id\": ti.run_id} for ti in tis],",
            "                separators=(\",\", \":\"),",
            "            )",
            "        return self.render_template(",
            "            \"airflow/confirm.html\",",
            "            endpoint=None,",
            "            message=\"Task instances you are about to clear:\",",
            "            details=\"\\n\".join(details),",
            "        )",
            "",
            "    @expose(\"/clear\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def clear(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Clears DAG tasks.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        task_id = request.form.get(\"task_id\")",
            "        origin = get_safe_url(request.form.get(\"origin\"))",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        group_id = request.form.get(\"group_id\")",
            "",
            "        if \"map_index\" not in request.form:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = request.form.getlist(\"map_index\", type=int)",
            "",
            "        execution_date_str = request.form.get(\"execution_date\")",
            "        execution_date = _safe_parse_datetime(execution_date_str)",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        upstream = request.form.get(\"upstream\") == \"true\"",
            "        downstream = request.form.get(\"downstream\") == \"true\"",
            "        future = request.form.get(\"future\") == \"true\"",
            "        past = request.form.get(\"past\") == \"true\"",
            "        recursive = request.form.get(\"recursive\") == \"true\"",
            "        only_failed = request.form.get(\"only_failed\") == \"true\"",
            "",
            "        task_ids: list[str | tuple[str, int]] = []",
            "",
            "        end_date = execution_date if not future else None",
            "        start_date = execution_date if not past else None",
            "",
            "        locked_dag_run_ids: list[int] = []",
            "",
            "        if group_id is not None:",
            "            task_group_dict = dag.task_group.get_task_group_dict()",
            "            task_group = task_group_dict.get(group_id)",
            "            if task_group is None:",
            "                return redirect_or_json(",
            "                    origin, msg=f\"TaskGroup {group_id} could not be found\", status=\"error\", status_code=404",
            "                )",
            "            task_ids = task_ids_or_regex = [t.task_id for t in task_group.iter_tasks()]",
            "",
            "            # Lock the related dag runs to prevent from possible dead lock.",
            "            # https://github.com/apache/airflow/pull/26658",
            "            dag_runs_query = session.query(DagRun.id).filter(DagRun.dag_id == dag_id).with_for_update()",
            "            if start_date is None and end_date is None:",
            "                dag_runs_query = dag_runs_query.filter(DagRun.execution_date == start_date)",
            "            else:",
            "                if start_date is not None:",
            "                    dag_runs_query = dag_runs_query.filter(DagRun.execution_date >= start_date)",
            "",
            "                if end_date is not None:",
            "                    dag_runs_query = dag_runs_query.filter(DagRun.execution_date <= end_date)",
            "",
            "            locked_dag_run_ids = dag_runs_query.all()",
            "        elif task_id:",
            "            if map_indexes is None:",
            "                task_ids = [task_id]",
            "            else:",
            "                task_ids = [(task_id, map_index) for map_index in map_indexes]",
            "            task_ids_or_regex = [task_id]",
            "",
            "        dag = dag.partial_subset(",
            "            task_ids_or_regex=task_ids_or_regex,",
            "            include_downstream=downstream,",
            "            include_upstream=upstream,",
            "        )",
            "",
            "        if len(dag.task_dict) > 1:",
            "            # If we had upstream/downstream etc then also include those!",
            "            task_ids.extend(tid for tid in dag.task_dict if tid != task_id)",
            "",
            "        response = self._clear_dag_tis(",
            "            dag,",
            "            start_date,",
            "            end_date,",
            "            origin=origin,",
            "            task_ids=task_ids,",
            "            recursive=recursive,",
            "            confirmed=confirmed,",
            "            only_failed=only_failed,",
            "            session=session,",
            "        )",
            "",
            "        del locked_dag_run_ids",
            "",
            "        return response",
            "",
            "    @expose(\"/dagrun_clear\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def dagrun_clear(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Clears the DagRun.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dr = dag.get_dagrun(run_id=dag_run_id)",
            "        start_date = dr.logical_date",
            "        end_date = dr.logical_date",
            "",
            "        return self._clear_dag_tis(",
            "            dag,",
            "            start_date,",
            "            end_date,",
            "            origin=None,",
            "            recursive=True,",
            "            confirmed=confirmed,",
            "            session=session,",
            "        )",
            "",
            "    @expose(\"/blocked\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def blocked(self, session: Session = NEW_SESSION):",
            "        \"\"\"Mark Dag Blocked.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify([])",
            "",
            "        dags = (",
            "            session.query(DagRun.dag_id, sqla.func.count(DagRun.id))",
            "            .filter(DagRun.state == DagRunState.RUNNING)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))",
            "            .group_by(DagRun.dag_id)",
            "        )",
            "",
            "        payload = []",
            "        for dag_id, active_dag_runs in dags:",
            "            max_active_runs = 0",
            "            dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "            if dag:",
            "                # TODO: Make max_active_runs a column so we can query for it directly",
            "                max_active_runs = dag.max_active_runs",
            "            payload.append(",
            "                {",
            "                    \"dag_id\": dag_id,",
            "                    \"active_dag_run\": active_dag_runs,",
            "                    \"max_active_runs\": max_active_runs,",
            "                }",
            "            )",
            "        return flask.json.jsonify(payload)",
            "",
            "    def _mark_dagrun_state_as_failed(self, dag_id, dag_run_id, confirmed):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        new_dag_state = set_dag_run_state_to_failed(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": f\"Marked failed on {len(new_dag_state)} task instances\"}",
            "        else:",
            "            details = [str(t) for t in new_dag_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    def _mark_dagrun_state_as_success(self, dag_id, dag_run_id, confirmed):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        new_dag_state = set_dag_run_state_to_success(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": f\"Marked success on {len(new_dag_state)} task instances\"}",
            "        else:",
            "            details = [str(t) for t in new_dag_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    @provide_session",
            "    def _mark_dagrun_state_as_queued(",
            "        self,",
            "        dag_id: str,",
            "        dag_run_id: str,",
            "        confirmed: bool,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        set_dag_run_state_to_queued(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": \"Marked the DagRun as queued.\"}",
            "",
            "        else:",
            "            # Identify tasks that will be queued up to run when confirmed",
            "            all_task_ids = [task.task_id for task in dag.tasks]",
            "",
            "            existing_tis = session.query(TaskInstance.task_id).filter(",
            "                TaskInstance.dag_id == dag.dag_id,",
            "                TaskInstance.run_id == dag_run_id,",
            "            )",
            "",
            "            completed_tis_ids = [task_id for task_id, in existing_tis]",
            "            tasks_with_no_state = list(set(all_task_ids) - set(completed_tis_ids))",
            "            details = [str(t) for t in tasks_with_no_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    @expose(\"/dagrun_failed\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_failed(self):",
            "        \"\"\"Mark DagRun failed.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_failed(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_success\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_success(self):",
            "        \"\"\"Mark DagRun success.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_success(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_queued\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_queued(self):",
            "        \"\"\"Queue DagRun so tasks that haven't run yet can be started.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_queued(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_details\")",
            "    def dagrun_details(self):",
            "        \"\"\"Redirect to the GRID DAGRun page. This is avoids breaking links.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        run_id = request.args.get(\"run_id\")",
            "        return redirect(url_for(\"Airflow.grid\", dag_id=dag_id, dag_run_id=run_id))",
            "",
            "    def _mark_task_instance_state(",
            "        self,",
            "        *,",
            "        dag_id: str,",
            "        run_id: str,",
            "        task_id: str,",
            "        map_indexes: list[int] | None,",
            "        origin: str,",
            "        upstream: bool,",
            "        downstream: bool,",
            "        future: bool,",
            "        past: bool,",
            "        state: TaskInstanceState,",
            "    ):",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not run_id:",
            "            flash(f\"Cannot mark tasks as {state}, seem that DAG {dag_id} has never run\", \"error\")",
            "            return redirect(origin)",
            "",
            "        altered = dag.set_task_instance_state(",
            "            task_id=task_id,",
            "            map_indexes=map_indexes,",
            "            run_id=run_id,",
            "            state=state,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "        )",
            "",
            "        flash(f\"Marked {state} on {len(altered)} task instances\")",
            "        return redirect(origin)",
            "",
            "    def _mark_task_group_state(",
            "        self,",
            "        *,",
            "        dag_id: str,",
            "        run_id: str,",
            "        group_id: str,",
            "        origin: str,",
            "        upstream: bool,",
            "        downstream: bool,",
            "        future: bool,",
            "        past: bool,",
            "        state: TaskInstanceState,",
            "    ):",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not run_id:",
            "            flash(f\"Cannot mark tasks as {state}, as DAG {dag_id} has never run\", \"error\")",
            "            return redirect(origin)",
            "",
            "        altered = dag.set_task_group_state(",
            "            group_id=group_id,",
            "            run_id=run_id,",
            "            state=state,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "        )",
            "",
            "        flash(f\"Marked {state} on {len(altered)} task instances\")",
            "        return redirect(origin)",
            "",
            "    @expose(\"/confirm\", methods=[\"GET\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def confirm(self):",
            "        \"\"\"Show confirmation page for marking tasks as success or failed.\"\"\"",
            "        args = request.args",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        dag_run_id = args.get(\"dag_run_id\")",
            "        state = args.get(\"state\")",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "        origin = origin or url_for(\"Airflow.index\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        if not dag:",
            "            msg = f\"DAG {dag_id} not found\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=404)",
            "",
            "        if state not in (",
            "            \"success\",",
            "            \"failed\",",
            "        ):",
            "            msg = f\"Invalid state {state}, must be either 'success' or 'failed'\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=400)",
            "",
            "        latest_execution_date = dag.get_latest_execution_date()",
            "        if not latest_execution_date:",
            "            msg = f\"Cannot mark tasks as {state}, seem that dag {dag_id} has never run\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=400)",
            "",
            "        tasks: list[Operator | tuple[Operator, int]] = []",
            "",
            "        if group_id:",
            "            task_group_dict = dag.task_group.get_task_group_dict()",
            "            task_group = task_group_dict.get(group_id)",
            "            if task_group is None:",
            "                return redirect_or_json(",
            "                    origin, msg=f\"TaskGroup {group_id} could not be found\", status=\"error\", status_code=404",
            "                )",
            "            tasks = [task for task in task_group.iter_tasks()]",
            "        elif task_id:",
            "            try:",
            "                task = dag.get_task(task_id)",
            "            except airflow.exceptions.TaskNotFound:",
            "                msg = f\"Task {task_id} not found\"",
            "                return redirect_or_json(origin, msg, status=\"error\", status_code=404)",
            "            task.dag = dag",
            "            if map_indexes is None:",
            "                tasks = [task]",
            "            else:",
            "                tasks = [(task, map_index) for map_index in map_indexes]",
            "",
            "        to_be_altered = set_state(",
            "            tasks=tasks,",
            "            run_id=dag_run_id,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "            state=state,",
            "            commit=False,",
            "        )",
            "",
            "        if request.headers.get(\"Accept\") == \"application/json\":",
            "            return htmlsafe_json_dumps(",
            "                [",
            "                    {\"task_id\": ti.task_id, \"map_index\": ti.map_index, \"run_id\": ti.run_id}",
            "                    for ti in to_be_altered",
            "                ],",
            "                separators=(\",\", \":\"),",
            "            )",
            "",
            "        details = \"\\n\".join(str(t) for t in to_be_altered)",
            "",
            "        response = self.render_template(",
            "            \"airflow/confirm.html\",",
            "            endpoint=url_for(f\"Airflow.{state}\"),",
            "            message=f\"Task instances you are about to mark as {state}:\",",
            "            details=details,",
            "        )",
            "",
            "        return response",
            "",
            "    @expose(\"/failed\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def failed(self):",
            "        \"\"\"Mark task or task_group as failed.\"\"\"",
            "        args = request.form",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        run_id = args.get(\"dag_run_id\")",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "",
            "        if task_id:",
            "            return self._mark_task_instance_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                task_id=task_id,",
            "                map_indexes=map_indexes,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.FAILED,",
            "            )",
            "        elif group_id:",
            "            return self._mark_task_group_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                group_id=group_id,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.FAILED,",
            "            )",
            "",
            "    @expose(\"/success\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def success(self):",
            "        \"\"\"Mark task or task_group as success.\"\"\"",
            "        args = request.form",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        run_id = args.get(\"dag_run_id\")",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "",
            "        if task_id:",
            "            return self._mark_task_instance_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                task_id=task_id,",
            "                map_indexes=map_indexes,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.SUCCESS,",
            "            )",
            "        elif group_id:",
            "            return self._mark_task_group_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                group_id=group_id,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.SUCCESS,",
            "            )",
            "",
            "    @expose(\"/dags/<string:dag_id>\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def dag(self, dag_id):",
            "        \"\"\"Redirect to default DAG view.\"\"\"",
            "        kwargs = {**sanitize_args(request.args), \"dag_id\": dag_id}",
            "        return redirect(url_for(\"Airflow.grid\", **kwargs))",
            "",
            "    @expose(\"/tree\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_tree(self):",
            "        \"\"\"Redirect to the replacement - grid view. Kept for backwards compatibility.\"\"\"",
            "        return redirect(url_for(\"Airflow.grid\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/grid\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def grid(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag's grid view.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_downstream=False, include_upstream=True)",
            "",
            "        num_runs = request.args.get(\"num_runs\", type=int)",
            "        if num_runs is None:",
            "            num_runs = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if task_log_reader.supports_external_link:",
            "            external_log_name = task_log_reader.log_handler.log_name",
            "        else:",
            "            external_log_name = None",
            "",
            "        default_dag_run_display_number = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        num_runs_options = [5, 25, 50, 100, 365]",
            "",
            "        if default_dag_run_display_number not in num_runs_options:",
            "            insort_left(num_runs_options, default_dag_run_display_number)",
            "",
            "        return self.render_template(",
            "            \"airflow/grid.html\",",
            "            root=root,",
            "            dag=dag,",
            "            doc_md=doc_md,",
            "            num_runs=num_runs,",
            "            show_external_log_redirect=task_log_reader.supports_external_link,",
            "            external_log_name=external_log_name,",
            "            dag_model=dag_model,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            default_dag_run_display_number=default_dag_run_display_number,",
            "            default_wrap=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "            filters_drop_down_values=htmlsafe_json_dumps(",
            "                {",
            "                    \"taskStates\": [state.value for state in TaskInstanceState],",
            "                    \"dagStates\": [state.value for state in State.dag_states],",
            "                    \"runTypes\": [run_type.value for run_type in DagRunType],",
            "                    \"numRuns\": num_runs_options,",
            "                }",
            "            ),",
            "        )",
            "",
            "    @expose(\"/calendar\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_calendar(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.calendar\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/calendar\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def calendar(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get DAG runs as calendar.\"\"\"",
            "",
            "        def _convert_to_date(session, column):",
            "            \"\"\"Convert column to date.\"\"\"",
            "            if session.bind.dialect.name == \"mssql\":",
            "                return column.cast(Date)",
            "            else:",
            "                return func.date(column)",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_downstream=False, include_upstream=True)",
            "",
            "        dag_states = (",
            "            session.query(",
            "                (_convert_to_date(session, DagRun.execution_date)).label(\"date\"),",
            "                DagRun.state,",
            "                func.max(DagRun.data_interval_start).label(\"data_interval_start\"),",
            "                func.max(DagRun.data_interval_end).label(\"data_interval_end\"),",
            "                func.count(\"*\").label(\"count\"),",
            "            )",
            "            .filter(DagRun.dag_id == dag.dag_id)",
            "            .group_by(_convert_to_date(session, DagRun.execution_date), DagRun.state)",
            "            .order_by(_convert_to_date(session, DagRun.execution_date).asc())",
            "            .all()",
            "        )",
            "",
            "        data_dag_states = [",
            "            {",
            "                # DATE() in SQLite and MySQL behave differently:",
            "                # SQLite returns a string, MySQL returns a date.",
            "                \"date\": dr.date if isinstance(dr.date, str) else dr.date.isoformat(),",
            "                \"state\": dr.state,",
            "                \"count\": dr.count,",
            "            }",
            "            for dr in dag_states",
            "        ]",
            "",
            "        if dag_states and dag_states[-1].data_interval_start and dag_states[-1].data_interval_end:",
            "            last_automated_data_interval = DataInterval(",
            "                timezone.coerce_datetime(dag_states[-1].data_interval_start),",
            "                timezone.coerce_datetime(dag_states[-1].data_interval_end),",
            "            )",
            "",
            "            year = last_automated_data_interval.end.year",
            "            restriction = TimeRestriction(dag.start_date, dag.end_date, False)",
            "            dates: dict[datetime.date, int] = collections.Counter()",
            "",
            "            if isinstance(dag.timetable, CronMixin):",
            "                # Optimized calendar generation for timetables based on a cron expression.",
            "                dates_iter: Iterator[datetime.datetime | None] = croniter(",
            "                    dag.timetable._expression,",
            "                    start_time=last_automated_data_interval.end,",
            "                    ret_type=datetime.datetime,",
            "                )",
            "                for dt in dates_iter:",
            "                    if dt is None:",
            "                        break",
            "                    if dt.year != year:",
            "                        break",
            "                    if dag.end_date and dt > dag.end_date:",
            "                        break",
            "                    dates[dt.date()] += 1",
            "            else:",
            "                prev_logical_date = DateTime.min",
            "                while True:",
            "                    curr_info = dag.timetable.next_dagrun_info(",
            "                        last_automated_data_interval=last_automated_data_interval,",
            "                        restriction=restriction,",
            "                    )",
            "                    if curr_info is None:",
            "                        break  # Reached the end.",
            "                    if curr_info.logical_date <= prev_logical_date:",
            "                        break  # We're not progressing. Maybe a malformed timetable? Give up.",
            "                    if curr_info.logical_date.year != year:",
            "                        break  # Crossed the year boundary.",
            "                    last_automated_data_interval = curr_info.data_interval",
            "                    dates[curr_info.logical_date] += 1",
            "                    prev_logical_date = curr_info.logical_date",
            "",
            "            data_dag_states.extend(",
            "                {\"date\": date.isoformat(), \"state\": \"planned\", \"count\": count}",
            "                for (date, count) in dates.items()",
            "            )",
            "",
            "        now = DateTime.utcnow()",
            "        data = {",
            "            \"dag_states\": data_dag_states,",
            "            \"start_date\": (dag.start_date or now).date().isoformat(),",
            "            \"end_date\": (dag.end_date or now).date().isoformat(),",
            "        }",
            "",
            "        return self.render_template(",
            "            \"airflow/calendar.html\",",
            "            dag=dag,",
            "            doc_md=wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None)),",
            "            data=htmlsafe_json_dumps(data, separators=(\",\", \":\")),  # Avoid spaces to reduce payload size.",
            "            root=root,",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/graph\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_graph(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.graph\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/graph\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def graph(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get DAG as Graph.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "        arrange = request.args.get(\"arrange\", dag.orientation)",
            "",
            "        nodes = task_group_to_dict(dag.task_group)",
            "        edges = dag_edges(dag)",
            "",
            "        dt_nr_dr_data = get_date_time_num_runs_dag_runs_form_data(request, session, dag)",
            "",
            "        dt_nr_dr_data[\"arrange\"] = arrange",
            "        dttm = dt_nr_dr_data[\"dttm\"]",
            "        dag_run = dag.get_dagrun(execution_date=dttm)",
            "        dag_run_id = dag_run.run_id if dag_run else None",
            "",
            "        class GraphForm(DateTimeWithNumRunsWithDagRunsForm):",
            "            \"\"\"Graph Form class.\"\"\"",
            "",
            "            arrange = SelectField(",
            "                \"Layout\",",
            "                choices=(",
            "                    (\"LR\", \"Left > Right\"),",
            "                    (\"RL\", \"Right > Left\"),",
            "                    (\"TB\", \"Top > Bottom\"),",
            "                    (\"BT\", \"Bottom > Top\"),",
            "                ),",
            "            )",
            "",
            "        form = GraphForm(data=dt_nr_dr_data)",
            "        form.execution_date.choices = dt_nr_dr_data[\"dr_choices\"]",
            "",
            "        task_instances = {}",
            "        for ti in dag.get_task_instances(dttm, dttm):",
            "            if ti.task_id not in task_instances:",
            "                task_instances[ti.task_id] = wwwutils.get_instance_with_map(ti, session)",
            "        tasks = {",
            "            t.task_id: {",
            "                \"dag_id\": t.dag_id,",
            "                \"task_type\": t.task_type,",
            "                \"operator_name\": t.operator_name,",
            "                \"extra_links\": t.extra_links,",
            "                \"is_mapped\": isinstance(t, MappedOperator),",
            "                \"trigger_rule\": t.trigger_rule,",
            "            }",
            "            for t in dag.tasks",
            "        }",
            "        if not tasks:",
            "            flash(\"No tasks found\", \"error\")",
            "        session.commit()",
            "        doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if task_log_reader.supports_external_link:",
            "            external_log_name = task_log_reader.log_handler.log_name",
            "        else:",
            "            external_log_name = None",
            "",
            "        state_priority = [\"no_status\" if p is None else p for p in wwwutils.priority]",
            "",
            "        return self.render_template(",
            "            \"airflow/graph.html\",",
            "            dag=dag,",
            "            form=form,",
            "            dag_run_id=dag_run_id,",
            "            execution_date=dttm.isoformat(),",
            "            state_token=wwwutils.state_token(dt_nr_dr_data[\"dr_state\"]),",
            "            doc_md=doc_md,",
            "            arrange=arrange,",
            "            operators=sorted(",
            "                {op.operator_name: op for op in dag.tasks}.values(), key=lambda x: x.operator_name",
            "            ),",
            "            root=root or \"\",",
            "            task_instances=task_instances,",
            "            tasks=tasks,",
            "            nodes=nodes,",
            "            edges=edges,",
            "            show_external_log_redirect=task_log_reader.supports_external_link,",
            "            external_log_name=external_log_name,",
            "            dag_run_state=dt_nr_dr_data[\"dr_state\"],",
            "            dag_model=dag_model,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            state_priority=state_priority,",
            "        )",
            "",
            "    @expose(\"/duration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_duration(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.duration\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/duration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def duration(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag as duration graph.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "        cum_chart = nvd3.lineChart(",
            "            name=\"cumLineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        y_points = defaultdict(list)",
            "        x_points = defaultdict(list)",
            "",
            "        task_instances = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "        if task_instances:",
            "            min_date = task_instances[0].execution_date",
            "        else:",
            "            min_date = timezone.utc_epoch()",
            "        ti_fails = (",
            "            session.query(TaskFail)",
            "            .join(TaskFail.dag_run)",
            "            .filter(",
            "                TaskFail.dag_id == dag.dag_id,",
            "                DagRun.execution_date >= min_date,",
            "                DagRun.execution_date <= base_date,",
            "            )",
            "        )",
            "        if dag.partial:",
            "            ti_fails = ti_fails.filter(TaskFail.task_id.in_([t.task_id for t in dag.tasks]))",
            "        fails_totals: dict[tuple[str, str, str], int] = defaultdict(int)",
            "        for failed_task_instance in ti_fails:",
            "            dict_key = (",
            "                failed_task_instance.dag_id,",
            "                failed_task_instance.task_id,",
            "                failed_task_instance.run_id,",
            "            )",
            "            if failed_task_instance.duration:",
            "                fails_totals[dict_key] += failed_task_instance.duration",
            "",
            "        # we must group any mapped TIs by dag_id, task_id, run_id",
            "        mapped_tis = set()",
            "        tis_grouped = itertools.groupby(task_instances, lambda x: (x.dag_id, x.task_id, x.run_id))",
            "        for _, group in tis_grouped:",
            "            tis = list(group)",
            "            duration = sum(x.duration for x in tis if x.duration)",
            "            if duration:",
            "                first_ti = tis[0]",
            "                if first_ti.map_index >= 0:",
            "                    mapped_tis.add(first_ti.task_id)",
            "                date_time = wwwutils.epoch(first_ti.execution_date)",
            "                x_points[first_ti.task_id].append(date_time)",
            "                fails_dict_key = (first_ti.dag_id, first_ti.task_id, first_ti.run_id)",
            "                fails_total = fails_totals[fails_dict_key]",
            "                y_points[first_ti.task_id].append(float(duration + fails_total))",
            "",
            "        cumulative_y = {k: list(itertools.accumulate(v)) for k, v in y_points.items()}",
            "",
            "        # determine the most relevant time unit for the set of task instance",
            "        # durations for the DAG",
            "        y_unit = infer_time_unit([d for t in y_points.values() for d in t])",
            "        cum_y_unit = infer_time_unit([d for t in cumulative_y.values() for d in t])",
            "        # update the y Axis on both charts to have the correct time units",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Duration ({y_unit})\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "        cum_chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Duration ({cum_y_unit})\")",
            "        cum_chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        for task_id in x_points:",
            "            chart.add_serie(",
            "                name=task_id + \"[]\" if task_id in mapped_tis else task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(y_points[task_id], y_unit),",
            "            )",
            "            cum_chart.add_serie(",
            "                name=task_id + \"[]\" if task_id in mapped_tis else task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(cumulative_y[task_id], cum_y_unit),",
            "            )",
            "",
            "        dates = sorted({ti.execution_date for ti in task_instances})",
            "        max_date = max(ti.execution_date for ti in task_instances) if dates else None",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "        chart.buildcontent()",
            "        cum_chart.buildcontent()",
            "        s_index = cum_chart.htmlcontent.rfind(\"});\")",
            "        cum_chart.htmlcontent = (",
            "            f\"{cum_chart.htmlcontent[:s_index]}\"",
            "            \"$( document ).trigger('chartload')\"",
            "            f\"{cum_chart.htmlcontent[s_index:]}\"",
            "        )",
            "",
            "        return self.render_template(",
            "            \"airflow/duration_chart.html\",",
            "            dag=dag,",
            "            root=root,",
            "            form=form,",
            "            chart=Markup(chart.htmlcontent),",
            "            cum_chart=Markup(cum_chart.htmlcontent),",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/tries\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_tries(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.tries\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/tries\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def tries(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Shows all tries.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        tis = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "        for task in dag.tasks:",
            "            y_points = []",
            "            x_points = []",
            "            for ti in tis:",
            "                if ti.task_id != task.task_id:",
            "                    continue",
            "                dttm = wwwutils.epoch(ti.execution_date)",
            "                x_points.append(dttm)",
            "                # y value should reflect completed tries to have a 0 baseline.",
            "                y_points.append(ti.prev_attempted_tries)",
            "            if x_points:",
            "                chart.add_serie(name=task.task_id, x=x_points, y=y_points)",
            "",
            "        tries = sorted({ti.try_number for ti in tis})",
            "        max_date = max(ti.execution_date for ti in tis) if tries else None",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=\"Tries\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "",
            "        chart.buildcontent()",
            "",
            "        return self.render_template(",
            "            \"airflow/chart.html\",",
            "            dag=dag,",
            "            root=root,",
            "            form=form,",
            "            chart=Markup(chart.htmlcontent),",
            "            tab_title=\"Tries\",",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/landing_times\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_landing_times(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.landing_times\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/landing-times\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def landing_times(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Shows landing times.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        tis = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        y_points: dict[str, list[float]] = collections.defaultdict(list)",
            "        x_points: dict[str, list[tuple[int]]] = collections.defaultdict(list)",
            "        for task in dag.tasks:",
            "            task_id = task.task_id",
            "            for ti in tis:",
            "                if ti.task_id != task.task_id:",
            "                    continue",
            "                ts = dag.get_run_data_interval(ti.dag_run).end",
            "                if ti.end_date:",
            "                    dttm = wwwutils.epoch(ti.execution_date)",
            "                    secs = (ti.end_date - ts).total_seconds()",
            "                    x_points[task_id].append(dttm)",
            "                    y_points[task_id].append(secs)",
            "",
            "        # determine the most relevant time unit for the set of landing times",
            "        # for the DAG",
            "        y_unit = infer_time_unit([d for t in y_points.values() for d in t])",
            "        # update the y Axis to have the correct time units",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Landing Time ({y_unit})\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        for task_id in x_points:",
            "            chart.add_serie(",
            "                name=task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(y_points[task_id], y_unit),",
            "            )",
            "        max_date = max(ti.execution_date for ti in tis) if tis else None",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "        chart.buildcontent()",
            "",
            "        return self.render_template(",
            "            \"airflow/chart.html\",",
            "            dag=dag,",
            "            chart=Markup(chart.htmlcontent),",
            "            height=f\"{chart_height + 100}px\",",
            "            root=root,",
            "            form=form,",
            "            tab_title=\"Landing times\",",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/paused\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def paused(self):",
            "        \"\"\"Toggle paused.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        is_paused = request.args.get(\"is_paused\") == \"false\"",
            "        models.DagModel.get_dagmodel(dag_id).set_is_paused(is_paused=is_paused)",
            "        return \"OK\"",
            "",
            "    @expose(\"/gantt\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_gantt(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.gantt\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/gantt\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def gantt(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Show GANTT chart.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        dt_nr_dr_data = get_date_time_num_runs_dag_runs_form_data(request, session, dag)",
            "        dttm = dt_nr_dr_data[\"dttm\"]",
            "        dag_run = dag.get_dagrun(execution_date=dttm)",
            "        dag_run_id = dag_run.run_id if dag_run else None",
            "",
            "        form = DateTimeWithNumRunsWithDagRunsForm(data=dt_nr_dr_data)",
            "        form.execution_date.choices = dt_nr_dr_data[\"dr_choices\"]",
            "",
            "        tis = (",
            "            session.query(TaskInstance)",
            "            .filter(",
            "                TaskInstance.dag_id == dag_id,",
            "                TaskInstance.run_id == dag_run_id,",
            "                TaskInstance.start_date.is_not(None),",
            "                TaskInstance.state.is_not(None),",
            "            )",
            "            .order_by(TaskInstance.start_date)",
            "        )",
            "",
            "        ti_fails = session.query(TaskFail).filter_by(run_id=dag_run_id, dag_id=dag_id)",
            "        if dag.partial:",
            "            ti_fails = ti_fails.filter(TaskFail.task_id.in_([t.task_id for t in dag.tasks]))",
            "",
            "        tasks = []",
            "        for ti in tis:",
            "            if not dag.has_task(ti.task_id):",
            "                continue",
            "            # prev_attempted_tries will reflect the currently running try_number",
            "            # or the try_number of the last complete run",
            "            # https://issues.apache.org/jira/browse/AIRFLOW-2143",
            "            try_count = ti.prev_attempted_tries if ti.prev_attempted_tries != 0 else ti.try_number",
            "            task_dict = alchemy_to_dict(ti) or {}",
            "            task_dict[\"end_date\"] = task_dict[\"end_date\"] or timezone.utcnow()",
            "            task_dict[\"extraLinks\"] = dag.get_task(ti.task_id).extra_links",
            "            task_dict[\"try_number\"] = try_count",
            "            task_dict[\"execution_date\"] = dttm.isoformat()",
            "            task_dict[\"run_id\"] = dag_run_id",
            "            tasks.append(task_dict)",
            "",
            "        tf_count = 0",
            "        try_count = 1",
            "        prev_task_id = \"\"",
            "        for failed_task_instance in ti_fails:",
            "            if not dag.has_task(failed_task_instance.task_id):",
            "                continue",
            "            if tf_count != 0 and failed_task_instance.task_id == prev_task_id:",
            "                try_count += 1",
            "            else:",
            "                try_count = 1",
            "            prev_task_id = failed_task_instance.task_id",
            "            tf_count += 1",
            "            task = dag.get_task(failed_task_instance.task_id)",
            "            task_dict = alchemy_to_dict(failed_task_instance) or {}",
            "            end_date = task_dict[\"end_date\"] or timezone.utcnow()",
            "            task_dict[\"end_date\"] = end_date",
            "            task_dict[\"start_date\"] = task_dict[\"start_date\"] or end_date",
            "            task_dict[\"state\"] = TaskInstanceState.FAILED",
            "            task_dict[\"operator\"] = task.operator_name",
            "            task_dict[\"try_number\"] = try_count",
            "            task_dict[\"extraLinks\"] = task.extra_links",
            "            task_dict[\"execution_date\"] = dttm.isoformat()",
            "            task_dict[\"run_id\"] = dag_run_id",
            "            tasks.append(task_dict)",
            "",
            "        task_names = [ti.task_id for ti in tis]",
            "        data = {",
            "            \"taskNames\": task_names,",
            "            \"tasks\": tasks,",
            "            \"height\": len(task_names) * 25 + 25,",
            "        }",
            "",
            "        session.commit()",
            "",
            "        return self.render_template(",
            "            \"airflow/gantt.html\",",
            "            dag=dag,",
            "            dag_run_id=dag_run_id,",
            "            execution_date=dttm.isoformat(),",
            "            form=form,",
            "            data=data,",
            "            base_date=\"\",",
            "            root=root,",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/extra_links\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def extra_links(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"",
            "        A restful endpoint that returns external links for a given Operator.",
            "",
            "        It queries the operator that sent the request for the links it wishes",
            "        to provide for a given external link name.",
            "",
            "        API: GET",
            "        Args: dag_id: The id of the dag containing the task in question",
            "              task_id: The id of the task in question",
            "              execution_date: The date of execution of the task",
            "              link_name: The name of the link reference to find the actual URL for",
            "",
            "        Returns:",
            "            200: {url: <url of link>, error: None} - returned when there was no problem",
            "                finding the URL",
            "            404: {url: None, error: <error message>} - returned when the operator does",
            "                not return a URL",
            "        \"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag or task_id not in dag.task_ids:",
            "            return {\"url\": None, \"error\": f\"can't find dag {dag} or task_id {task_id}\"}, 404",
            "",
            "        task: AbstractOperator = dag.get_task(task_id)",
            "        link_name = request.args.get(\"link_name\")",
            "        if link_name is None:",
            "            return {\"url\": None, \"error\": \"Link name not passed\"}, 400",
            "",
            "        ti = (",
            "            session.query(TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .options(joinedload(TaskInstance.dag_run))",
            "            .first()",
            "        )",
            "        if not ti:",
            "            return {\"url\": None, \"error\": \"Task Instances not found\"}, 404",
            "        try:",
            "            url = task.get_extra_links(ti, link_name)",
            "        except ValueError as err:",
            "            return {\"url\": None, \"error\": str(err)}, 404",
            "        if url:",
            "            return {\"error\": None, \"url\": url}",
            "        else:",
            "            return {\"url\": None, \"error\": f\"No URL found for {link_name}\"}, 404",
            "",
            "    @expose(\"/object/graph_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def graph_data(self, session: Session = NEW_SESSION):",
            "        \"\"\"Get Graph Data.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "",
            "        nodes = task_group_to_dict(dag.task_group)",
            "        edges = dag_edges(dag)",
            "",
            "        data = {",
            "            \"arrange\": dag.orientation,",
            "            \"nodes\": nodes,",
            "            \"edges\": edges,",
            "        }",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/task_instances\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def task_instances(self):",
            "        \"\"\"Shows task instances.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        dttm = request.args.get(\"execution_date\")",
            "        if dttm:",
            "            dttm = _safe_parse_datetime(dttm)",
            "        else:",
            "            return {\"error\": f\"Invalid execution_date {dttm}\"}, 400",
            "",
            "        with create_session() as session:",
            "            task_instances = {",
            "                ti.task_id: wwwutils.get_instance_with_map(ti, session)",
            "                for ti in dag.get_task_instances(dttm, dttm)",
            "            }",
            "",
            "        return flask.json.jsonify(task_instances)",
            "",
            "    @expose(\"/object/grid_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    def grid_data(self):",
            "        \"\"\"Returns grid data.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"error\": f\"can't find dag {dag_id}\"}, 404",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "",
            "        num_runs = request.args.get(\"num_runs\", type=int)",
            "        if num_runs is None:",
            "            num_runs = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        try:",
            "            base_date = timezone.parse(request.args[\"base_date\"])",
            "        except (KeyError, ValueError):",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        with create_session() as session:",
            "            query = session.query(DagRun).filter(",
            "                DagRun.dag_id == dag.dag_id, DagRun.execution_date <= base_date",
            "            )",
            "",
            "            run_type = request.args.get(\"run_type\")",
            "            if run_type:",
            "                query = query.filter(DagRun.run_type == run_type)",
            "",
            "            run_state = request.args.get(\"run_state\")",
            "            if run_state:",
            "                query = query.filter(DagRun.state == run_state)",
            "",
            "            dag_runs = wwwutils.sorted_dag_runs(query, ordering=dag.timetable.run_ordering, limit=num_runs)",
            "            encoded_runs = [",
            "                wwwutils.encode_dag_run(dr, json_encoder=utils_json.WebEncoder) for dr in dag_runs",
            "            ]",
            "            data = {",
            "                \"groups\": dag_to_grid(dag, dag_runs, session),",
            "                \"dag_runs\": encoded_runs,",
            "                \"ordering\": dag.timetable.run_ordering,",
            "            }",
            "        # avoid spaces to reduce payload size",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/historical_metrics_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CLUSTER_ACTIVITY),",
            "        ]",
            "    )",
            "    def historical_metrics_data(self):",
            "        \"\"\"Returns cluster activity historical metrics.\"\"\"",
            "        start_date = _safe_parse_datetime(request.args.get(\"start_date\"))",
            "        end_date = _safe_parse_datetime(request.args.get(\"end_date\"))",
            "        with create_session() as session:",
            "            # DagRuns",
            "            dag_runs_type = (",
            "                session.query(DagRun.run_type, func.count(DagRun.run_id))",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(DagRun.run_type)",
            "                .all()",
            "            )",
            "",
            "            dag_run_states = (",
            "                session.query(DagRun.state, func.count(DagRun.run_id))",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(DagRun.state)",
            "                .all()",
            "            )",
            "",
            "            # TaskInstances",
            "            task_instance_states = (",
            "                session.query(TaskInstance.state, func.count(TaskInstance.run_id))",
            "                .join(TaskInstance.dag_run)",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(TaskInstance.state)",
            "                .all()",
            "            )",
            "",
            "            data = {",
            "                \"dag_run_types\": {",
            "                    **{dag_run_type.value: 0 for dag_run_type in DagRunType},",
            "                    **{run_type: sum_value for run_type, sum_value in dag_runs_type},",
            "                },",
            "                \"dag_run_states\": {",
            "                    **{dag_run_state.value: 0 for dag_run_state in DagRunState},",
            "                    **{run_state: sum_value for run_state, sum_value in dag_run_states},",
            "                },",
            "                \"task_instance_states\": {",
            "                    \"no_status\": 0,",
            "                    **{ti_state.value: 0 for ti_state in TaskInstanceState},",
            "                    **{ti_state or \"no_status\": sum_value for ti_state, sum_value in task_instance_states},",
            "                },",
            "            }",
            "",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/next_run_datasets/<string:dag_id>\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    def next_run_datasets(self, dag_id):",
            "        \"\"\"Returns datasets necessary, and their status, for the next dag run.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        if not dag:",
            "            return {\"error\": f\"can't find dag {dag_id}\"}, 404",
            "",
            "        with create_session() as session:",
            "            data = [",
            "                dict(info)",
            "                for info in session.query(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                    func.max(DatasetEvent.timestamp).label(\"lastUpdate\"),",
            "                )",
            "                .join(DagScheduleDatasetReference, DagScheduleDatasetReference.dataset_id == DatasetModel.id)",
            "                .join(",
            "                    DatasetDagRunQueue,",
            "                    and_(",
            "                        DatasetDagRunQueue.dataset_id == DatasetModel.id,",
            "                        DatasetDagRunQueue.target_dag_id == DagScheduleDatasetReference.dag_id,",
            "                    ),",
            "                    isouter=True,",
            "                )",
            "                .join(",
            "                    DatasetEvent,",
            "                    DatasetEvent.dataset_id == DatasetModel.id,",
            "                    isouter=True,",
            "                )",
            "                .filter(DagScheduleDatasetReference.dag_id == dag_id, ~DatasetModel.is_orphaned)",
            "                .group_by(DatasetModel.id, DatasetModel.uri)",
            "                .order_by(DatasetModel.uri)",
            "            ]",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/dataset_dependencies\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_DEPENDENCIES),",
            "        ]",
            "    )",
            "    def dataset_dependencies(self):",
            "        \"\"\"Returns dataset dependencies graph.\"\"\"",
            "        nodes_dict: dict[str, Any] = {}",
            "        edge_tuples: set[dict[str, str]] = set()",
            "",
            "        for dag, dependencies in SerializedDagModel.get_dag_dependencies().items():",
            "            dag_node_id = f\"dag:{dag}\"",
            "            if dag_node_id not in nodes_dict and len(dependencies) > 0:",
            "                for dep in dependencies:",
            "                    if dep.dependency_type == \"dag\" or dep.dependency_type == \"dataset\":",
            "                        nodes_dict[dag_node_id] = node_dict(dag_node_id, dag, \"dag\")",
            "                        if dep.node_id not in nodes_dict:",
            "                            nodes_dict[dep.node_id] = node_dict(",
            "                                dep.node_id, dep.dependency_id, dep.dependency_type",
            "                            )",
            "                        if dep.source != \"dataset\":",
            "                            edge_tuples.add((f\"dag:{dep.source}\", dep.node_id))",
            "                        if dep.target != \"dataset\":",
            "                            edge_tuples.add((dep.node_id, f\"dag:{dep.target}\"))",
            "",
            "        nodes = list(nodes_dict.values())",
            "        edges = [{\"source\": source, \"target\": target} for source, target in edge_tuples]",
            "",
            "        data = {",
            "            \"nodes\": nodes,",
            "            \"edges\": edges,",
            "        }",
            "",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/datasets_summary\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DATASET)])",
            "    def datasets_summary(self):",
            "        \"\"\"Get a summary of datasets, including the datetime they were last updated and how many updates",
            "        they've ever had.",
            "        \"\"\"",
            "        allowed_attrs = [\"uri\", \"last_dataset_update\"]",
            "",
            "        # Grab query parameters",
            "        limit = int(request.args.get(\"limit\", 25))",
            "        offset = int(request.args.get(\"offset\", 0))",
            "        order_by = request.args.get(\"order_by\", \"uri\")",
            "        uri_pattern = request.args.get(\"uri_pattern\", \"\")",
            "        lstripped_orderby = order_by.lstrip(\"-\")",
            "        updated_after = _safe_parse_datetime(request.args.get(\"updated_after\"), allow_empty=True)",
            "        updated_before = _safe_parse_datetime(request.args.get(\"updated_before\"), allow_empty=True)",
            "",
            "        # Check and clean up query parameters",
            "        limit = 50 if limit > 50 else limit",
            "",
            "        uri_pattern = uri_pattern[:4000]",
            "",
            "        if lstripped_orderby not in allowed_attrs:",
            "            return {",
            "                \"detail\": (",
            "                    f\"Ordering with '{lstripped_orderby}' is disallowed or the attribute does not \"",
            "                    \"exist on the model\"",
            "                )",
            "            }, 400",
            "",
            "        with create_session() as session:",
            "            if lstripped_orderby == \"uri\":",
            "                if order_by.startswith(\"-\"):",
            "                    order_by = (DatasetModel.uri.desc(),)",
            "                else:",
            "                    order_by = (DatasetModel.uri.asc(),)",
            "            elif lstripped_orderby == \"last_dataset_update\":",
            "                if order_by.startswith(\"-\"):",
            "                    order_by = (",
            "                        func.max(DatasetEvent.timestamp).desc(),",
            "                        DatasetModel.uri.asc(),",
            "                    )",
            "                    if session.bind.dialect.name == \"postgresql\":",
            "                        order_by = (order_by[0].nulls_last(), *order_by[1:])",
            "                else:",
            "                    order_by = (",
            "                        func.max(DatasetEvent.timestamp).asc(),",
            "                        DatasetModel.uri.desc(),",
            "                    )",
            "                    if session.bind.dialect.name == \"postgresql\":",
            "                        order_by = (order_by[0].nulls_first(), *order_by[1:])",
            "",
            "            count_query = session.query(func.count(DatasetModel.id))",
            "",
            "            has_event_filters = bool(updated_before or updated_after)",
            "",
            "            query = (",
            "                session.query(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                    func.max(DatasetEvent.timestamp).label(\"last_dataset_update\"),",
            "                    func.sum(case((DatasetEvent.id.is_not(None), 1), else_=0)).label(\"total_updates\"),",
            "                )",
            "                .join(DatasetEvent, DatasetEvent.dataset_id == DatasetModel.id, isouter=not has_event_filters)",
            "                .group_by(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                )",
            "                .order_by(*order_by)",
            "            )",
            "",
            "            if has_event_filters:",
            "                count_query = count_query.join(DatasetEvent, DatasetEvent.dataset_id == DatasetModel.id)",
            "",
            "            filters = [~DatasetModel.is_orphaned]",
            "            if uri_pattern:",
            "                filters.append(DatasetModel.uri.ilike(f\"%{uri_pattern}%\"))",
            "            if updated_after:",
            "                filters.append(DatasetEvent.timestamp >= updated_after)",
            "            if updated_before:",
            "                filters.append(DatasetEvent.timestamp <= updated_before)",
            "",
            "            query = query.filter(*filters).offset(offset).limit(limit)",
            "            count_query = count_query.filter(*filters)",
            "",
            "            datasets = [dict(dataset) for dataset in query]",
            "            data = {\"datasets\": datasets, \"total_entries\": count_query.scalar()}",
            "",
            "            return (",
            "                htmlsafe_json_dumps(data, separators=(\",\", \":\"), cls=utils_json.WebEncoder),",
            "                {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "            )",
            "",
            "    @expose(\"/robots.txt\")",
            "    @action_logging",
            "    def robots(self):",
            "        \"\"\"",
            "        Returns a robots.txt file for blocking certain search engine crawlers. This mitigates some",
            "        of the risk associated with exposing Airflow to the public internet, however it does not",
            "        address the real security risks associated with such a deployment.",
            "        \"\"\"",
            "        return send_from_directory(get_airflow_app().static_folder, \"robots.txt\")",
            "",
            "    @expose(\"/audit_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_AUDIT_LOG),",
            "        ]",
            "    )",
            "    def legacy_audit_log(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.audit_log\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/audit_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_AUDIT_LOG),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def audit_log(self, dag_id: str, session: Session = NEW_SESSION):",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        included_events_raw = conf.get(\"webserver\", \"audit_view_included_events\", fallback=None)",
            "        excluded_events_raw = conf.get(\"webserver\", \"audit_view_excluded_events\", fallback=None)",
            "",
            "        query = session.query(Log).filter(Log.dag_id == dag_id)",
            "        if included_events_raw:",
            "            included_events = {event.strip() for event in included_events_raw.split(\",\")}",
            "            query = query.filter(Log.event.in_(included_events))",
            "        elif excluded_events_raw:",
            "            excluded_events = {event.strip() for event in excluded_events_raw.split(\",\")}",
            "            query = query.filter(Log.event.notin_(excluded_events))",
            "",
            "        current_page = request.args.get(\"page\", default=0, type=int)",
            "        arg_sorting_key = request.args.get(\"sorting_key\", \"dttm\")",
            "        arg_sorting_direction = request.args.get(\"sorting_direction\", default=\"desc\")",
            "",
            "        logs_per_page = PAGE_SIZE",
            "        audit_logs_count = query.count()",
            "        num_of_pages = int(math.ceil(audit_logs_count / float(logs_per_page)))",
            "",
            "        start = current_page * logs_per_page",
            "        end = start + logs_per_page",
            "",
            "        sort_column = Log.__table__.c.get(arg_sorting_key)",
            "        if sort_column is not None:",
            "            if arg_sorting_direction == \"desc\":",
            "                sort_column = sort_column.desc()",
            "            query = query.order_by(sort_column)",
            "",
            "        dag_audit_logs = query.offset(start).limit(logs_per_page).all()",
            "        return self.render_template(",
            "            \"airflow/dag_audit_log.html\",",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            root=request.args.get(\"root\"),",
            "            dag_id=dag_id,",
            "            dag_logs=dag_audit_logs,",
            "            num_log_from=min(start + 1, audit_logs_count),",
            "            num_log_to=min(end, audit_logs_count),",
            "            audit_logs_count=audit_logs_count,",
            "            page_size=PAGE_SIZE,",
            "            paging=wwwutils.generate_pages(",
            "                current_page,",
            "                num_of_pages,",
            "                sorting_key=arg_sorting_key if arg_sorting_key else None,",
            "                sorting_direction=arg_sorting_direction if arg_sorting_direction else None,",
            "            ),",
            "            sorting_key=arg_sorting_key,",
            "            sorting_direction=arg_sorting_direction,",
            "        )",
            "",
            "",
            "class ConfigurationView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Configurations.\"\"\"",
            "",
            "    default_view = \"conf\"",
            "",
            "    class_permission_name = permissions.RESOURCE_CONFIG",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    @expose(\"/configuration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CONFIG),",
            "        ]",
            "    )",
            "    def conf(self):",
            "        \"\"\"Shows configuration.\"\"\"",
            "        raw = request.args.get(\"raw\") == \"true\"",
            "        title = \"Airflow Configuration\"",
            "        expose_config = conf.get(\"webserver\", \"expose_config\").lower()",
            "",
            "        # TODO remove \"if raw\" usage in Airflow 3.0. Configuration can be fetched via the REST API.",
            "        if raw:",
            "            if expose_config == \"non-sensitive-only\":",
            "                updater = configupdater.ConfigUpdater()",
            "                updater.read(AIRFLOW_CONFIG)",
            "                for sect, key in conf.sensitive_config_values:",
            "                    if updater.has_option(sect, key):",
            "                        updater[sect][key].value = \"< hidden >\"",
            "                config = str(updater)",
            "            elif expose_config in {\"true\", \"t\", \"1\"}:",
            "                with open(AIRFLOW_CONFIG) as file:",
            "                    config = file.read()",
            "            else:",
            "                config = (",
            "                    \"# Your Airflow administrator chose not to expose the configuration, \"",
            "                    \"most likely for security reasons.\"",
            "                )",
            "",
            "            return Response(",
            "                response=config,",
            "                status=200,",
            "                mimetype=\"application/text\",",
            "                headers={\"Deprecation\": \"Endpoint will be removed in Airflow 3.0, use the REST API instead.\"},",
            "            )",
            "",
            "        if expose_config in {\"non-sensitive-only\", \"true\", \"t\", \"1\"}:",
            "            display_sensitive = expose_config != \"non-sensitive-only\"",
            "",
            "            table = [",
            "                (section, key, str(value), source)",
            "                for section, parameters in conf.as_dict(True, display_sensitive).items()",
            "                for key, (value, source) in parameters.items()",
            "            ]",
            "",
            "            return self.render_template(",
            "                template=\"airflow/config.html\",",
            "                title=title,",
            "                table=table,",
            "            )",
            "",
            "        else:",
            "            return self.render_template(",
            "                \"airflow/config.html\",",
            "                title=title,",
            "                hide_config_msg=(",
            "                    \"Your Airflow administrator chose not to expose the configuration, \"",
            "                    \"most likely for security reasons.\"",
            "                ),",
            "            )",
            "",
            "",
            "class RedocView(AirflowBaseView):",
            "    \"\"\"Redoc Open API documentation.\"\"\"",
            "",
            "    default_view = \"redoc\"",
            "",
            "    @expose(\"/redoc\")",
            "    def redoc(self):",
            "        \"\"\"Redoc API documentation.\"\"\"",
            "        openapi_spec_url = url_for(\"/api/v1./api/v1_openapi_yaml\")",
            "        return self.render_template(\"airflow/redoc.html\", openapi_spec_url=openapi_spec_url)",
            "",
            "",
            "######################################################################################",
            "#                                    ModelViews",
            "######################################################################################",
            "",
            "",
            "class DagFilter(BaseFilter):",
            "    \"\"\"Filter using DagIDs.\"\"\"",
            "",
            "    def apply(self, query, func):",
            "        if get_airflow_app().appbuilder.sm.has_all_dags_access(g.user):",
            "            return query",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "        return query.filter(self.model.dag_id.in_(filter_dag_ids))",
            "",
            "",
            "class AirflowModelView(ModelView):",
            "    \"\"\"Airflow Mode View.",
            "",
            "    Overridden `__getattribute__` to wraps REST methods with action_logger",
            "    \"\"\"",
            "",
            "    list_widget = AirflowModelListWidget",
            "    page_size = PAGE_SIZE",
            "",
            "    CustomSQLAInterface = wwwutils.CustomSQLAInterface",
            "",
            "    def __getattribute__(self, attr):",
            "        \"\"\"Wraps action REST methods with `action_logging` wrapper",
            "        Overriding enables differentiating resource and generation of event name at the decorator level.",
            "",
            "        if attr in [\"show\", \"list\", \"read\", \"get\", \"get_list\"]:",
            "            return action_logging(event=\"RESOURCE_NAME\".\"action_name\")(attr)",
            "        else:",
            "            return attr",
            "        \"\"\"",
            "        attribute = object.__getattribute__(self, attr)",
            "        if (",
            "            callable(attribute)",
            "            and hasattr(attribute, \"_permission_name\")",
            "            and attribute._permission_name in self.method_permission_name",
            "        ):",
            "            permission_str = self.method_permission_name[attribute._permission_name]",
            "            if permission_str not in [\"show\", \"list\", \"read\", \"get\", \"get_list\"]:",
            "                return action_logging(event=f\"{self.route_base.strip('/')}.{permission_str}\")(attribute)",
            "        return attribute",
            "",
            "",
            "class AirflowPrivilegeVerifierModelView(AirflowModelView):",
            "    \"\"\"",
            "    This ModelView prevents ability to pass primary keys of objects relating to DAGs you shouldn't be able to",
            "    edit. This only holds for the add, update and delete operations.",
            "    You will still need to use the `action_has_dag_edit_access()` for actions.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def validate_dag_edit_access(item: DagRun | TaskInstance):",
            "        \"\"\"Validates whether the user has 'can_edit' access for this specific DAG.\"\"\"",
            "        if not get_airflow_app().appbuilder.sm.can_edit_dag(item.dag_id):",
            "            raise AirflowException(f\"Access denied for dag_id {item.dag_id}\")",
            "",
            "    def pre_add(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def pre_update(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def pre_delete(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def post_add_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "    def post_edit_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "    def post_delete_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "def action_has_dag_edit_access(action_func: Callable) -> Callable:",
            "    \"\"\"Decorator for actions which verifies you have DAG edit access on the given tis/drs.\"\"\"",
            "",
            "    @wraps(action_func)",
            "    def check_dag_edit_acl_for_actions(",
            "        self,",
            "        items: list[TaskInstance] | list[DagRun] | TaskInstance | DagRun | None,",
            "        *args,",
            "        **kwargs,",
            "    ) -> Callable:",
            "        if items is None:",
            "            dag_ids: set[str] = set()",
            "        elif isinstance(items, list):",
            "            dag_ids = {item.dag_id for item in items if item is not None}",
            "        elif isinstance(items, TaskInstance) or isinstance(items, DagRun):",
            "            dag_ids = {items.dag_id}",
            "        else:",
            "            raise ValueError(",
            "                \"Was expecting the first argument of the action to be of type \"",
            "                \"list[TaskInstance] | list[DagRun] | TaskInstance | DagRun | None.\"",
            "                f\"Was of type: {type(items)}\"",
            "            )",
            "",
            "        for dag_id in dag_ids:",
            "            if not get_airflow_app().appbuilder.sm.can_edit_dag(dag_id):",
            "                flash(f\"Access denied for dag_id {dag_id}\", \"danger\")",
            "                logging.warning(\"User %s tried to modify %s without having access.\", g.user.username, dag_id)",
            "                return redirect(self.get_default_url())",
            "        return action_func(self, items, *args, **kwargs)",
            "",
            "    return check_dag_edit_acl_for_actions",
            "",
            "",
            "class SlaMissModelView(AirflowModelView):",
            "    \"\"\"View to show SlaMiss table.\"\"\"",
            "",
            "    route_base = \"/slamiss\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(SlaMiss)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_SLA_MISS",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    add_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "    edit_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "    search_columns = [\"dag_id\", \"task_id\", \"email_sent\", \"notification_sent\", \"timestamp\", \"execution_date\"]",
            "    base_order = (\"execution_date\", \"desc\")",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"timestamp\": wwwutils.datetime_f(\"timestamp\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete action.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(",
            "        \"mulnotificationsent\",",
            "        \"Set notification sent to true\",",
            "        \"Are you sure you want to set all these notifications to sent?\",",
            "        single=False,",
            "    )",
            "    def action_mulnotificationsent(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"notification_sent\", True)",
            "",
            "    @action(",
            "        \"mulnotificationsentfalse\",",
            "        \"Set notification sent to false\",",
            "        \"Are you sure you want to mark these SLA alerts as notification not sent yet?\",",
            "        single=False,",
            "    )",
            "    def action_mulnotificationsentfalse(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"notification_sent\", False)",
            "",
            "    @action(",
            "        \"mulemailsent\",",
            "        \"Set email sent to true\",",
            "        \"Are you sure you want to mark these SLA alerts as emails were sent?\",",
            "        single=False,",
            "    )",
            "    def action_mulemailsent(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"email_sent\", True)",
            "",
            "    @action(",
            "        \"mulemailsentfalse\",",
            "        \"Set email sent to false\",",
            "        \"Are you sure you want to mark these SLA alerts as emails not sent yet?\",",
            "        single=False,",
            "    )",
            "    def action_mulemailsentfalse(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"email_sent\", False)",
            "",
            "    @provide_session",
            "    def _set_notification_property(",
            "        self,",
            "        items: list[SlaMiss],",
            "        attr: str,",
            "        new_value: bool,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        try:",
            "            count = 0",
            "            for sla in items:",
            "                count += 1",
            "                setattr(sla, attr, new_value)",
            "                session.merge(sla)",
            "            session.commit()",
            "            flash(f\"{count} SLAMisses had {attr} set to {new_value}.\")",
            "        except Exception as ex:",
            "            flash(str(ex), \"error\")",
            "            flash(\"Failed to set state\", \"error\")",
            "        self.update_redirect()",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "class XComModelView(AirflowModelView):",
            "    \"\"\"View to show records from XCom table.\"\"\"",
            "",
            "    route_base = \"/xcom\"",
            "",
            "    list_title = \"List XComs\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(XCom)",
            "",
            "    class_permission_name = permissions.RESOURCE_XCOM",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    search_columns = [\"key\", \"value\", \"timestamp\", \"dag_id\", \"task_id\", \"run_id\", \"execution_date\"]",
            "    list_columns = [\"key\", \"value\", \"timestamp\", \"dag_id\", \"task_id\", \"run_id\", \"map_index\", \"execution_date\"]",
            "    base_order = (\"dag_run_id\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"timestamp\": wwwutils.datetime_f(\"timestamp\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete action.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    def pre_add(self, item):",
            "        \"\"\"Pre add hook.\"\"\"",
            "        item.execution_date = timezone.make_aware(item.execution_date)",
            "        item.value = XCom.serialize_value(",
            "            value=item.value,",
            "            key=item.key,",
            "            task_id=item.task_id,",
            "            dag_id=item.dag_id,",
            "            run_id=item.run_id,",
            "            map_index=item.map_index,",
            "        )",
            "",
            "    def pre_update(self, item):",
            "        \"\"\"Pre update hook.\"\"\"",
            "        item.execution_date = timezone.make_aware(item.execution_date)",
            "        item.value = XCom.serialize_value(",
            "            value=item.value,",
            "            key=item.key,",
            "            task_id=item.task_id,",
            "            dag_id=item.dag_id,",
            "            run_id=item.run_id,",
            "            map_index=item.map_index,",
            "        )",
            "",
            "",
            "# Used to store a dictionary of field behaviours used to dynamically change available",
            "# fields in ConnectionForm based on type of connection chosen",
            "# See airflow.hooks.base_hook.DiscoverableHook for details on how to customize your Hooks.",
            "#",
            "# Additionally, a list of connection types that support testing via Airflow REST API is stored to dynamically",
            "# enable/disable the Test Connection button.",
            "#",
            "# These field behaviours and testable connection types are rendered as scripts in the conn_create.html and",
            "# conn_edit.html templates.",
            "class ConnectionFormWidget(FormWidget):",
            "    \"\"\"Form widget used to display connection.\"\"\"",
            "",
            "    @cached_property",
            "    def field_behaviours(self) -> str:",
            "        return json.dumps(ProvidersManager().field_behaviours)",
            "",
            "    @cached_property",
            "    def testable_connection_types(self) -> list[str]:",
            "        return [",
            "            connection_type",
            "            for connection_type, hook_info in ProvidersManager().hooks.items()",
            "            if hook_info and hook_info.connection_testable",
            "        ]",
            "",
            "",
            "class ConnectionFormProxy:",
            "    \"\"\"A stand-in for the connection form class.",
            "",
            "    Flask-Appbuilder model views only ever call the ``refresh()`` function on",
            "    the form class, so this is the perfect place to make the form generation",
            "    dynamic. See docstring of ``create_connection_form_class`` for rationales.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def refresh(obj=None):",
            "        return create_connection_form_class().refresh(obj)",
            "",
            "",
            "class ConnectionModelView(AirflowModelView):",
            "    \"\"\"View to show records from Connections table.\"\"\"",
            "",
            "    route_base = \"/connection\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Connection)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_CONNECTION",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_mulduplicate\": \"create\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"conn_id\",",
            "        \"conn_type\",",
            "        \"description\",",
            "        \"host\",",
            "        \"port\",",
            "        \"is_encrypted\",",
            "        \"is_extra_encrypted\",",
            "    ]",
            "",
            "    # The real add_columns and edit_columns are dynamically generated at runtime",
            "    # so we can delay calculating entries relying on providers to make webserver",
            "    # start up faster.",
            "    _add_columns = _edit_columns = [",
            "        \"conn_id\",",
            "        \"conn_type\",",
            "        \"description\",",
            "        \"host\",",
            "        \"schema\",",
            "        \"login\",",
            "        \"password\",",
            "        \"port\",",
            "        \"extra\",",
            "    ]",
            "",
            "    # We will generate the actual ConnectionForm when it is actually needed,",
            "    # i.e. when the web form views are displayed and submitted.",
            "    add_form = edit_form = ConnectionFormProxy",
            "",
            "    add_template = \"airflow/conn_create.html\"",
            "    edit_template = \"airflow/conn_edit.html\"",
            "",
            "    add_widget = ConnectionFormWidget",
            "    edit_widget = ConnectionFormWidget",
            "",
            "    base_order = (\"conn_id\", \"asc\")",
            "",
            "    def _iter_extra_field_names(self) -> Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate through provider-backed connection fields.",
            "",
            "        Note that this cannot be a property (including a cached property)",
            "        because Flask-Appbuilder attempts to access all members on startup, and",
            "        using a property would initialize the providers manager too eagerly.",
            "        \"\"\"",
            "        return ((k, v.field_name) for k, v in ProvidersManager().connection_form_widgets.items())",
            "",
            "    @property",
            "    def add_columns(self) -> list[str]:",
            "        \"\"\"A list of columns to show in the Add form.",
            "",
            "        This dynamically calculates additional fields from providers and add",
            "        them to the backing list. This calculation is done exactly once (by",
            "        checking we're referencing the class-level variable instead of the",
            "        instance-level), and only after we enter the request context (to skip",
            "        superfuluous checks done by Flask-Appbuilder on startup).",
            "        \"\"\"",
            "        if self._add_columns is type(self)._add_columns and has_request_context():",
            "            self._add_columns = [*self._add_columns, *(k for k, _ in self._iter_extra_field_names())]",
            "        return self._add_columns",
            "",
            "    @property",
            "    def edit_columns(self) -> list[str]:",
            "        \"\"\"A list of columns to show in the Edit form.",
            "",
            "        This dynamically calculates additional fields from providers and add",
            "        them to the backing list. This calculation is done exactly once (by",
            "        checking we're referencing the class-level variable instead of the",
            "        instance-level), and only after we enter the request context (to skip",
            "        superfuluous checks done by Flask-Appbuilder on startup).",
            "        \"\"\"",
            "        if self._edit_columns is type(self)._edit_columns and has_request_context():",
            "            self._edit_columns = [*self._edit_columns, *(k for k, _ in self._iter_extra_field_names())]",
            "        return self._edit_columns",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(",
            "        \"mulduplicate\",",
            "        \"Duplicate\",",
            "        \"Are you sure you want to duplicate the selected connections?\",",
            "        single=False,",
            "    )",
            "    @provide_session",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_CREATE, permissions.RESOURCE_CONNECTION),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CONNECTION),",
            "        ]",
            "    )",
            "    def action_mulduplicate(self, connections, session: Session = NEW_SESSION):",
            "        \"\"\"Duplicate Multiple connections.\"\"\"",
            "        for selected_conn in connections:",
            "            new_conn_id = selected_conn.conn_id",
            "            match = re.search(r\"_copy(\\d+)$\", selected_conn.conn_id)",
            "",
            "            base_conn_id = selected_conn.conn_id",
            "            if match:",
            "                base_conn_id = base_conn_id.split(\"_copy\")[0]",
            "",
            "            potential_connection_ids = [f\"{base_conn_id}_copy{i}\" for i in range(1, 11)]",
            "",
            "            query = session.query(Connection.conn_id).filter(Connection.conn_id.in_(potential_connection_ids))",
            "",
            "            found_conn_id_set = {conn_id for conn_id, in query}",
            "",
            "            possible_conn_id_iter = (",
            "                connection_id",
            "                for connection_id in potential_connection_ids",
            "                if connection_id not in found_conn_id_set",
            "            )",
            "            try:",
            "                new_conn_id = next(possible_conn_id_iter)",
            "            except StopIteration:",
            "                flash(",
            "                    f\"Connection {new_conn_id} can't be added because it already exists, \"",
            "                    f\"Please rename the existing connections\",",
            "                    \"warning\",",
            "                )",
            "            else:",
            "                dup_conn = Connection(",
            "                    new_conn_id,",
            "                    selected_conn.conn_type,",
            "                    selected_conn.description,",
            "                    selected_conn.host,",
            "                    selected_conn.login,",
            "                    selected_conn.password,",
            "                    selected_conn.schema,",
            "                    selected_conn.port,",
            "                    selected_conn.extra,",
            "                )",
            "",
            "                try:",
            "                    session.add(dup_conn)",
            "                    session.commit()",
            "                    flash(f\"Connection {new_conn_id} added successfully.\", \"success\")",
            "                except IntegrityError:",
            "                    flash(",
            "                        f\"Connection {new_conn_id} can't be added. Integrity error, \"",
            "                        f\"probably unique constraint.\",",
            "                        \"warning\",",
            "                    )",
            "                    session.rollback()",
            "",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    def process_form(self, form, is_created):",
            "        \"\"\"Process form data.\"\"\"",
            "        conn_id = form.data[\"conn_id\"]",
            "        conn_type = form.data[\"conn_type\"]",
            "",
            "        # The extra value is the combination of custom fields for this conn_type and the Extra field.",
            "        # The extra form field with all extra values (including custom fields) is in the form being processed",
            "        # so we start with those values, and override them with anything in the custom fields.",
            "        extra = {}",
            "",
            "        extra_json = form.data.get(\"extra\")",
            "",
            "        if extra_json:",
            "            try:",
            "                extra.update(json.loads(extra_json))",
            "            except (JSONDecodeError, TypeError):",
            "                flash(",
            "                    Markup(",
            "                        \"<p>The <em>Extra</em> connection field contained an invalid value for Conn ID: \"",
            "                        \"<q>{conn_id}</q>.</p>\"",
            "                        \"<p>If connection parameters need to be added to <em>Extra</em>, \"",
            "                        \"please make sure they are in the form of a single, valid JSON object.</p><br>\"",
            "                        \"The following <em>Extra</em> parameters were <b>not</b> added to the connection:<br>\"",
            "                        \"{extra_json}\"",
            "                    ).format(conn_id=conn_id, extra_json=extra_json),",
            "                    category=\"error\",",
            "                )",
            "                del form.extra",
            "        del extra_json",
            "",
            "        for key, field_name in self._iter_extra_field_names():",
            "            if key in form.data and key.startswith(\"extra__\"):",
            "                conn_type_from_extra_field = key.split(\"__\")[1]",
            "                if conn_type_from_extra_field == conn_type:",
            "                    value = form.data[key]",
            "                    # Some extra fields have a default value of False so we need to explicitly check the",
            "                    # value isn't an empty string.",
            "                    if value != \"\":",
            "                        extra[field_name] = value",
            "",
            "        if extra.keys():",
            "            form.extra.data = json.dumps(extra)",
            "",
            "    def prefill_form(self, form, pk):",
            "        \"\"\"Prefill the form.\"\"\"",
            "        try:",
            "            extra = form.data.get(\"extra\")",
            "            if extra is None:",
            "                extra_dictionary = {}",
            "            else:",
            "                extra_dictionary = json.loads(extra)",
            "        except JSONDecodeError:",
            "            extra_dictionary = {}",
            "",
            "        if not isinstance(extra_dictionary, dict):",
            "            logging.warning(\"extra field for %s is not a dictionary\", form.data.get(\"conn_id\", \"<unknown>\"))",
            "            return",
            "",
            "        for field_key, field_name in self._iter_extra_field_names():",
            "            value = extra_dictionary.get(field_name, \"\")",
            "",
            "            if not value:",
            "                # check if connection `extra` json is using old prefixed field name style",
            "                value = extra_dictionary.get(field_key, \"\")",
            "",
            "            if value:",
            "                field = getattr(form, field_key)",
            "                field.data = value",
            "",
            "",
            "class PluginView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Plugins.\"\"\"",
            "",
            "    default_view = \"list\"",
            "",
            "    class_permission_name = permissions.RESOURCE_PLUGIN",
            "",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    plugins_attributes_to_dump = [",
            "        \"hooks\",",
            "        \"executors\",",
            "        \"macros\",",
            "        \"admin_views\",",
            "        \"flask_blueprints\",",
            "        \"menu_links\",",
            "        \"appbuilder_views\",",
            "        \"appbuilder_menu_items\",",
            "        \"global_operator_extra_links\",",
            "        \"operator_extra_links\",",
            "        \"source\",",
            "    ]",
            "",
            "    @expose(\"/plugin\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_PLUGIN),",
            "        ]",
            "    )",
            "    def list(self):",
            "        \"\"\"List loaded plugins.\"\"\"",
            "        plugins_manager.ensure_plugins_loaded()",
            "        plugins_manager.integrate_executor_plugins()",
            "        plugins_manager.initialize_extra_operators_links_plugins()",
            "        plugins_manager.initialize_web_ui_plugins()",
            "",
            "        plugins = []",
            "        for plugin_no, plugin in enumerate(plugins_manager.plugins, 1):",
            "            plugin_data = {",
            "                \"plugin_no\": plugin_no,",
            "                \"plugin_name\": plugin.name,",
            "                \"attrs\": {},",
            "            }",
            "            for attr_name in self.plugins_attributes_to_dump:",
            "                attr_value = getattr(plugin, attr_name)",
            "                plugin_data[\"attrs\"][attr_name] = attr_value",
            "",
            "            plugins.append(plugin_data)",
            "",
            "        title = \"Airflow Plugins\"",
            "        doc_url = get_docs_url(\"plugins.html\")",
            "        return self.render_template(",
            "            \"airflow/plugin.html\",",
            "            plugins=plugins,",
            "            title=title,",
            "            doc_url=doc_url,",
            "        )",
            "",
            "",
            "class ProviderView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Providers.\"\"\"",
            "",
            "    default_view = \"list\"",
            "",
            "    class_permission_name = permissions.RESOURCE_PROVIDER",
            "",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    @expose(\"/provider\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_PROVIDER),",
            "        ]",
            "    )",
            "    def list(self):",
            "        \"\"\"List providers.\"\"\"",
            "        providers_manager = ProvidersManager()",
            "",
            "        providers = []",
            "        for pi in providers_manager.providers.values():",
            "            provider_info = pi.data",
            "            provider_data = {",
            "                \"package_name\": provider_info[\"package-name\"],",
            "                \"description\": self._clean_description(provider_info[\"description\"]),",
            "                \"version\": pi.version,",
            "                \"documentation_url\": get_doc_url_for_provider(provider_info[\"package-name\"], pi.version),",
            "            }",
            "            providers.append(provider_data)",
            "",
            "        title = \"Providers\"",
            "        doc_url = get_docs_url(\"apache-airflow-providers/index.html\")",
            "        return self.render_template(",
            "            \"airflow/providers.html\",",
            "            providers=providers,",
            "            title=title,",
            "            doc_url=doc_url,",
            "        )",
            "",
            "    def _clean_description(self, description):",
            "        def _build_link(match_obj):",
            "            text = match_obj.group(1)",
            "            url = match_obj.group(2)",
            "            return Markup(f'<a href=\"{url}\">{text}</a>')",
            "",
            "        cd = escape(description)",
            "        cd = re.sub(r\"`(.*)[\\s+]+&lt;(.*)&gt;`__\", _build_link, cd)",
            "        cd = re.sub(r\"\\n\", r\"<br>\", cd)",
            "        return Markup(cd)",
            "",
            "",
            "class PoolModelView(AirflowModelView):",
            "    \"\"\"View to show records from Pool table.\"\"\"",
            "",
            "    route_base = \"/pool\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Pool)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_POOL",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"pool\", \"slots\", \"running_slots\", \"queued_slots\", \"scheduled_slots\"]",
            "    add_columns = [\"pool\", \"slots\", \"description\"]",
            "    edit_columns = [\"pool\", \"slots\", \"description\"]",
            "",
            "    base_order = (\"pool\", \"asc\")",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        if any(item.pool == models.Pool.DEFAULT_POOL_NAME for item in items):",
            "            flash(f\"{models.Pool.DEFAULT_POOL_NAME} cannot be deleted\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @expose(\"/delete/<pk>\", methods=[\"GET\", \"POST\"])",
            "    @has_access",
            "    def delete(self, pk):",
            "        \"\"\"Single delete.\"\"\"",
            "        if models.Pool.is_default_pool(pk):",
            "            flash(f\"{models.Pool.DEFAULT_POOL_NAME} cannot be deleted\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "",
            "        return super().delete(pk)",
            "",
            "    def pool_link(self):",
            "        \"\"\"Pool link rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        if pool_id is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id)",
            "            return Markup(\"<a href='{url}'>{pool_id}</a>\").format(url=url, pool_id=pool_id)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def frunning_slots(self):",
            "        \"\"\"Running slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        running_slots = self.get(\"running_slots\")",
            "        if pool_id is not None and running_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"running\")",
            "            return Markup(\"<a href='{url}'>{running_slots}</a>\").format(url=url, running_slots=running_slots)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def fqueued_slots(self):",
            "        \"\"\"Queued slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        queued_slots = self.get(\"queued_slots\")",
            "        if pool_id is not None and queued_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"queued\")",
            "            return Markup(\"<a href='{url}'>{queued_slots}</a>\").format(url=url, queued_slots=queued_slots)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def fscheduled_slots(self):",
            "        \"\"\"Scheduled slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        scheduled_slots = self.get(\"scheduled_slots\")",
            "        if pool_id is not None and scheduled_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"scheduled\")",
            "            return Markup(\"<a href='{url}'>{scheduled_slots}</a>\").format(",
            "                url=url, scheduled_slots=scheduled_slots",
            "            )",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    formatters_columns = {",
            "        \"pool\": pool_link,",
            "        \"running_slots\": frunning_slots,",
            "        \"queued_slots\": fqueued_slots,",
            "        \"scheduled_slots\": fscheduled_slots,",
            "    }",
            "",
            "    validators_columns = {\"pool\": [validators.DataRequired()], \"slots\": [validators.NumberRange(min=-1)]}",
            "",
            "",
            "def _can_create_variable() -> bool:",
            "    return get_airflow_app().appbuilder.sm.has_access(",
            "        permissions.ACTION_CAN_CREATE, permissions.RESOURCE_VARIABLE",
            "    )",
            "",
            "",
            "class VariableModelView(AirflowModelView):",
            "    \"\"\"View to show records from Variable table.\"\"\"",
            "",
            "    route_base = \"/variable\"",
            "",
            "    list_template = \"airflow/variable_list.html\"",
            "    edit_template = \"airflow/variable_edit.html\"",
            "    show_template = \"airflow/variable_show.html\"",
            "",
            "    show_widget = AirflowVariableShowWidget",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Variable)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_VARIABLE",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"show\": \"read\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_varexport\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"key\", \"val\", \"description\", \"is_encrypted\"]",
            "    add_columns = [\"key\", \"val\", \"description\"]",
            "    edit_columns = [\"key\", \"val\", \"description\"]",
            "    show_columns = [\"key\", \"val\", \"description\"]",
            "    search_columns = [\"key\", \"val\"]",
            "",
            "    base_order = (\"key\", \"asc\")",
            "",
            "    def hidden_field_formatter(self):",
            "        \"\"\"Formats hidden fields.\"\"\"",
            "        key = self.get(\"key\")",
            "        val = self.get(\"val\")",
            "        if secrets_masker.should_hide_value_for_key(key):",
            "            return Markup(\"*\" * 8)",
            "        if val:",
            "            return val",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    formatters_columns = {",
            "        \"val\": hidden_field_formatter,",
            "    }",
            "",
            "    validators_columns = {\"key\": [validators.DataRequired()]}",
            "",
            "    def prefill_form(self, form, request_id):",
            "        if secrets_masker.should_hide_value_for_key(form.key.data):",
            "            form.val.data = \"*\" * 8",
            "",
            "    def prefill_show(self, item):",
            "        if secrets_masker.should_hide_value_for_key(item.key):",
            "            item.val = \"*\" * 8",
            "",
            "    def _show(self, pk):",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        self.prefill_show(item)",
            "        widgets = self._get_show_widget(pk, item)",
            "        self.update_redirect()",
            "",
            "        return self._get_related_views_widgets(",
            "            item, orders=orders, pages=pages, page_sizes=page_sizes, widgets=widgets",
            "        )",
            "",
            "    extra_args = {\"can_create_variable\": _can_create_variable}",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"varexport\", \"Export\", \"\", single=False)",
            "    def action_varexport(self, items):",
            "        \"\"\"Export variables.\"\"\"",
            "        var_dict = {}",
            "        decoder = json.JSONDecoder()",
            "        for var in items:",
            "            try:",
            "                val = decoder.decode(var.val)",
            "            except Exception:",
            "                val = var.val",
            "            var_dict[var.key] = val",
            "",
            "        response = make_response(json.dumps(var_dict, sort_keys=True, indent=4))",
            "        response.headers[\"Content-Disposition\"] = \"attachment; filename=variables.json\"",
            "        response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "        return response",
            "",
            "    @expose(\"/varimport\", methods=[\"POST\"])",
            "    @auth.has_access([(permissions.ACTION_CAN_CREATE, permissions.RESOURCE_VARIABLE)])",
            "    @action_logging(event=f\"{permissions.RESOURCE_VARIABLE.lower()}.varimport\")",
            "    def varimport(self):",
            "        \"\"\"Import variables.\"\"\"",
            "        try:",
            "            variable_dict = json.loads(request.files[\"file\"].read())",
            "        except Exception:",
            "            self.update_redirect()",
            "            flash(\"Missing file or syntax error.\", \"error\")",
            "            return redirect(self.get_redirect())",
            "        else:",
            "            suc_count = fail_count = 0",
            "            for k, v in variable_dict.items():",
            "                try:",
            "                    models.Variable.set(k, v, serialize_json=not isinstance(v, str))",
            "                except Exception as e:",
            "                    logging.info(\"Variable import failed: %s\", repr(e))",
            "                    fail_count += 1",
            "                else:",
            "                    suc_count += 1",
            "            flash(f\"{suc_count} variable(s) successfully updated.\")",
            "            if fail_count:",
            "                flash(f\"{fail_count} variable(s) failed to be updated.\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "",
            "",
            "class JobModelView(AirflowModelView):",
            "    \"\"\"View to show records from Job table.\"\"\"",
            "",
            "    route_base = \"/job\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Job)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_JOB",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"state\",",
            "        \"job_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"latest_heartbeat\",",
            "        \"executor_class\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "    ]",
            "    search_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"state\",",
            "        \"job_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"latest_heartbeat\",",
            "        \"executor_class\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "    ]",
            "",
            "    base_order = (\"start_date\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"hostname\": wwwutils.nobr_f(\"hostname\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"latest_heartbeat\": wwwutils.datetime_f(\"latest_heartbeat\"),",
            "    }",
            "",
            "",
            "class DagRunModelView(AirflowPrivilegeVerifierModelView):",
            "    \"\"\"View to show records from DagRun table.\"\"\"",
            "",
            "    route_base = \"/dagrun\"",
            "",
            "    datamodel = wwwutils.DagRunCustomSQLAInterface(models.DagRun)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_DAG_RUN",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"action_clear\": \"edit\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_set_queued\": \"edit\",",
            "        \"action_set_running\": \"edit\",",
            "        \"action_set_failed\": \"edit\",",
            "        \"action_set_success\": \"edit\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"queued_at\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"external_trigger\",",
            "        \"conf\",",
            "        \"duration\",",
            "    ]",
            "    search_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"external_trigger\",",
            "    ]",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "    edit_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"run_id\",",
            "        \"conf\",",
            "        \"note\",",
            "    ]",
            "",
            "    # duration is not a DB column, its derived",
            "    order_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"queued_at\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        # \"note\", # todo: maybe figure out how to re-enable this",
            "        \"external_trigger\",",
            "        \"conf\",",
            "    ]",
            "",
            "    base_order = (\"execution_date\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    edit_form = DagRunEditForm",
            "",
            "    def duration_f(self):",
            "        \"\"\"Duration calculation.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        start_date = self.get(\"start_date\")",
            "",
            "        difference = \"0s\"",
            "        if start_date and end_date:",
            "            difference = td_format(end_date - start_date)",
            "",
            "        return difference",
            "",
            "    formatters_columns = {",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"queued_at\": wwwutils.datetime_f(\"queued_at\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"run_id\": wwwutils.dag_run_link,",
            "        \"conf\": wwwutils.json_f(\"conf\"),",
            "        \"duration\": duration_f,",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_muldelete(self, items: list[DagRun]):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_queued\", \"Set state to 'queued'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_queued(self, drs: list[DagRun]):",
            "        \"\"\"Set state to queued.\"\"\"",
            "        return self._set_dag_runs_to_active_state(drs, State.QUEUED)",
            "",
            "    @action(\"set_running\", \"Set state to 'running'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_running(self, drs: list[DagRun]):",
            "        \"\"\"Set state to running.\"\"\"",
            "        return self._set_dag_runs_to_active_state(drs, State.RUNNING)",
            "",
            "    @provide_session",
            "    def _set_dag_runs_to_active_state(self, drs: list[DagRun], state: str, session: Session = NEW_SESSION):",
            "        \"\"\"This routine only supports Running and Queued state.\"\"\"",
            "        try:",
            "            count = 0",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                if state == State.RUNNING:",
            "                    dr.start_date = timezone.utcnow()",
            "                dr.state = state",
            "            session.commit()",
            "            flash(f\"{count} dag runs were set to {state}.\")",
            "        except Exception as ex:",
            "            flash(str(ex), \"error\")",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(",
            "        \"set_failed\",",
            "        \"Set state to 'failed'\",",
            "        \"All running task instances would also be marked as failed, are you sure?\",",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_set_failed(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Set state to failed.\"\"\"",
            "        try:",
            "            count = 0",
            "            altered_tis = []",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                altered_tis += set_dag_run_state_to_failed(",
            "                    dag=get_airflow_app().dag_bag.get_dag(dr.dag_id),",
            "                    run_id=dr.run_id,",
            "                    commit=True,",
            "                    session=session,",
            "                )",
            "            altered_ti_count = len(altered_tis)",
            "            flash(f\"{count} dag runs and {altered_ti_count} task instances were set to failed\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(",
            "        \"set_success\",",
            "        \"Set state to 'success'\",",
            "        \"All task instances would also be marked as success, are you sure?\",",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_set_success(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Set state to success.\"\"\"",
            "        try:",
            "            count = 0",
            "            altered_tis = []",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                altered_tis += set_dag_run_state_to_success(",
            "                    dag=get_airflow_app().dag_bag.get_dag(dr.dag_id),",
            "                    run_id=dr.run_id,",
            "                    commit=True,",
            "                    session=session,",
            "                )",
            "            altered_ti_count = len(altered_tis)",
            "            flash(f\"{count} dag runs and {altered_ti_count} task instances were set to success\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(\"clear\", \"Clear the state\", \"All task instances would be cleared, are you sure?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_clear(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Clears the state.\"\"\"",
            "        try:",
            "            count = 0",
            "            cleared_ti_count = 0",
            "            dag_to_tis: dict[DAG, list[TaskInstance]] = {}",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                dag = get_airflow_app().dag_bag.get_dag(dr.dag_id)",
            "                tis_to_clear = dag_to_tis.setdefault(dag, [])",
            "                tis_to_clear += dr.get_task_instances()",
            "",
            "            for dag, tis in dag_to_tis.items():",
            "                cleared_ti_count += len(tis)",
            "                models.clear_task_instances(tis, session, dag=dag)",
            "",
            "            flash(f\"{count} dag runs and {cleared_ti_count} task instances were cleared\")",
            "        except Exception:",
            "            flash(\"Failed to clear state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "class LogModelView(AirflowModelView):",
            "    \"\"\"View to show records from Log table.\"\"\"",
            "",
            "    route_base = \"/log\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Log)  # type:ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_AUDIT_LOG",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"id\", \"dttm\", \"dag_id\", \"task_id\", \"event\", \"execution_date\", \"owner\", \"extra\"]",
            "    search_columns = [\"dttm\", \"dag_id\", \"task_id\", \"event\", \"execution_date\", \"owner\", \"extra\"]",
            "",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    base_order = (\"dttm\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"dttm\": wwwutils.datetime_f(\"dttm\"),",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "    }",
            "",
            "",
            "class TaskRescheduleModelView(AirflowModelView):",
            "    \"\"\"View to show records from Task Reschedule table.\"\"\"",
            "",
            "    route_base = \"/taskreschedule\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskReschedule)  # type: ignore",
            "    related_views = [DagRunModelView]",
            "",
            "    class_permission_name = permissions.RESOURCE_TASK_RESCHEDULE",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"run_id\",",
            "        \"dag_run.execution_date\",",
            "        \"task_id\",",
            "        \"map_index\",",
            "        \"try_number\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        \"reschedule_date\",",
            "    ]",
            "",
            "    label_columns = {",
            "        \"dag_run.execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    search_columns = [",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"reschedule_date\",",
            "    ]",
            "",
            "    base_order = (\"id\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    def duration_f(self):",
            "        \"\"\"Duration calculation.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        duration = self.get(\"duration\")",
            "        if end_date and duration:",
            "            return td_format(datetime.timedelta(seconds=duration))",
            "        return None",
            "",
            "    formatters_columns = {",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"dag_run.execution_date\": wwwutils.datetime_f(\"dag_run.execution_date\"),",
            "        \"reschedule_date\": wwwutils.datetime_f(\"reschedule_date\"),",
            "        \"duration\": duration_f,",
            "        \"map_index\": wwwutils.format_map_index,",
            "    }",
            "",
            "",
            "class TriggerModelView(AirflowModelView):",
            "    \"\"\"View to show records from Task Reschedule table.\"\"\"",
            "",
            "    route_base = \"/triggerview\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Trigger)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_TRIGGER",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"classpath\",",
            "        \"created_date\",",
            "        \"triggerer_id\",",
            "    ]",
            "",
            "    search_columns = [",
            "        \"id\",",
            "        \"classpath\",",
            "        \"created_date\",",
            "        \"triggerer_id\",",
            "    ]",
            "",
            "    base_order = (\"id\", \"created_date\")",
            "",
            "    formatters_columns = {",
            "        \"created_date\": wwwutils.datetime_f(\"created_date\"),",
            "    }",
            "",
            "",
            "class TaskInstanceModelView(AirflowPrivilegeVerifierModelView):",
            "    \"\"\"View to show records from TaskInstance table.\"\"\"",
            "",
            "    route_base = \"/taskinstance\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskInstance)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_TASK_INSTANCE",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"action_clear\": \"edit\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_set_running\": \"edit\",",
            "        \"action_set_failed\": \"edit\",",
            "        \"action_set_success\": \"edit\",",
            "        \"action_set_retry\": \"edit\",",
            "        \"action_set_skipped\": \"edit\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    page_size = PAGE_SIZE",
            "",
            "    list_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"dag_run.execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        \"note\",",
            "        \"job_id\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"try_number\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "        \"external_executor_id\",",
            "        \"log_url\",",
            "    ]",
            "",
            "    order_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"dag_run.execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        # \"note\",  # TODO: Maybe figure out how to re-enable this.",
            "        \"job_id\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "    ]",
            "",
            "    label_columns = {",
            "        \"dag_run.execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    search_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"hostname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"try_number\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "    ]",
            "",
            "    edit_columns = [",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"state\",",
            "        \"note\",",
            "    ]",
            "",
            "    add_exclude_columns = [\"next_method\", \"next_kwargs\", \"trigger_id\"]",
            "",
            "    edit_form = TaskInstanceEditForm",
            "",
            "    base_order = (\"job_id\", \"asc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    def log_url_formatter(self):",
            "        \"\"\"Formats log URL.\"\"\"",
            "        log_url = self.get(\"log_url\")",
            "        return Markup(",
            "            '<a href=\"{log_url}\"><span class=\"material-icons\" aria-hidden=\"true\">reorder</span></a>'",
            "        ).format(log_url=log_url)",
            "",
            "    def duration_f(self):",
            "        \"\"\"Formats duration.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        duration = self.get(\"duration\")",
            "        if end_date and duration:",
            "            return td_format(datetime.timedelta(seconds=duration))",
            "        return None",
            "",
            "    formatters_columns = {",
            "        \"log_url\": log_url_formatter,",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"run_id\": wwwutils.dag_run_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "        \"hostname\": wwwutils.nobr_f(\"hostname\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"dag_run.execution_date\": wwwutils.datetime_f(\"dag_run.execution_date\"),",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"queued_dttm\": wwwutils.datetime_f(\"queued_dttm\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"duration\": duration_f,",
            "    }",
            "",
            "    @action(",
            "        \"clear\",",
            "        lazy_gettext(\"Clear\"),",
            "        lazy_gettext(",
            "            \"Are you sure you want to clear the state of the selected task\"",
            "            \" instance(s) and set their dagruns to the QUEUED state?\"",
            "        ),",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_clear(self, task_instances, session: Session = NEW_SESSION):",
            "        \"\"\"Clears the action.\"\"\"",
            "        try:",
            "            dag_to_tis = collections.defaultdict(list)",
            "",
            "            for ti in task_instances:",
            "                dag = get_airflow_app().dag_bag.get_dag(ti.dag_id)",
            "                dag_to_tis[dag].append(ti)",
            "",
            "            for dag, task_instances_list in dag_to_tis.items():",
            "                models.clear_task_instances(task_instances_list, session, dag=dag)",
            "",
            "            session.commit()",
            "            flash(f\"{len(task_instances)} task instances have been cleared\")",
            "        except Exception as e:",
            "            flash(f'Failed to clear task instances: \"{e}\"', \"error\")",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_muldelete(self, items):",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @provide_session",
            "    def set_task_instance_state(self, tis, target_state, session: Session = NEW_SESSION):",
            "        \"\"\"Set task instance state.\"\"\"",
            "        try:",
            "            count = len(tis)",
            "            for ti in tis:",
            "                ti.set_state(target_state, session)",
            "            session.commit()",
            "            flash(f\"{count} task instances were set to '{target_state}'\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "",
            "    @action(\"set_running\", \"Set state to 'running'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_running(self, tis):",
            "        \"\"\"Set state to 'running'.\"\"\"",
            "        self.set_task_instance_state(tis, State.RUNNING)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_failed\", \"Set state to 'failed'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_failed(self, tis):",
            "        \"\"\"Set state to 'failed'.\"\"\"",
            "        self.set_task_instance_state(tis, State.FAILED)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_success\", \"Set state to 'success'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_success(self, tis):",
            "        \"\"\"Set state to 'success'.\"\"\"",
            "        self.set_task_instance_state(tis, State.SUCCESS)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_retry\", \"Set state to 'up_for_retry'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_retry(self, tis):",
            "        \"\"\"Set state to 'up_for_retry'.\"\"\"",
            "        self.set_task_instance_state(tis, State.UP_FOR_RETRY)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_skipped\", \"Set state to 'skipped'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_skipped(self, tis):",
            "        \"\"\"Set state to skipped.\"\"\"",
            "        self.set_task_instance_state(tis, TaskInstanceState.SKIPPED)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "",
            "class AutocompleteView(AirflowBaseView):",
            "    \"\"\"View to provide autocomplete results.\"\"\"",
            "",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    @provide_session",
            "    @expose(\"/dagmodel/autocomplete\")",
            "    def autocomplete(self, session: Session = NEW_SESSION):",
            "        \"\"\"Autocomplete.\"\"\"",
            "        query = unquote(request.args.get(\"query\", \"\"))",
            "",
            "        if not query:",
            "            return flask.json.jsonify([])",
            "",
            "        # Provide suggestions of dag_ids and owners",
            "        dag_ids_query = session.query(",
            "            sqla.literal(\"dag\").label(\"type\"),",
            "            DagModel.dag_id.label(\"name\"),",
            "        ).filter(~DagModel.is_subdag, DagModel.is_active, DagModel.dag_id.ilike(f\"%{query}%\"))",
            "",
            "        owners_query = (",
            "            session.query(",
            "                sqla.literal(\"owner\").label(\"type\"),",
            "                DagModel.owners.label(\"name\"),",
            "            )",
            "            .distinct()",
            "            .filter(~DagModel.is_subdag, DagModel.is_active, DagModel.owners.ilike(f\"%{query}%\"))",
            "        )",
            "",
            "        # Hide DAGs if not showing status: \"all\"",
            "        status = flask_session.get(FILTER_STATUS_COOKIE)",
            "        if status == \"active\":",
            "            dag_ids_query = dag_ids_query.filter(~DagModel.is_paused)",
            "            owners_query = owners_query.filter(~DagModel.is_paused)",
            "        elif status == \"paused\":",
            "            dag_ids_query = dag_ids_query.filter(DagModel.is_paused)",
            "            owners_query = owners_query.filter(DagModel.is_paused)",
            "",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        dag_ids_query = dag_ids_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "        owners_query = owners_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "        payload = [row._asdict() for row in dag_ids_query.union(owners_query).order_by(\"name\").limit(10)]",
            "        return flask.json.jsonify(payload)",
            "",
            "",
            "class DagDependenciesView(AirflowBaseView):",
            "    \"\"\"View to show dependencies between DAGs.\"\"\"",
            "",
            "    refresh_interval = datetime.timedelta(",
            "        seconds=conf.getint(",
            "            \"webserver\",",
            "            \"dag_dependencies_refresh_interval\",",
            "            fallback=conf.getint(\"scheduler\", \"dag_dir_list_interval\"),",
            "        )",
            "    )",
            "    last_refresh = timezone.utcnow() - refresh_interval",
            "    nodes: list[dict[str, Any]] = []",
            "    edges: list[dict[str, str]] = []",
            "",
            "    @expose(\"/dag-dependencies\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_DEPENDENCIES),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def list(self):",
            "        \"\"\"Display DAG dependencies.\"\"\"",
            "        title = \"DAG Dependencies\"",
            "",
            "        if not self.nodes or not self.edges:",
            "            self._calculate_graph()",
            "            self.last_refresh = timezone.utcnow()",
            "        elif timezone.utcnow() > self.last_refresh + self.refresh_interval:",
            "            max_last_updated = SerializedDagModel.get_max_last_updated_datetime()",
            "            if max_last_updated is None or max_last_updated > self.last_refresh:",
            "                self._calculate_graph()",
            "            self.last_refresh = timezone.utcnow()",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_dependencies.html\",",
            "            title=title,",
            "            nodes=self.nodes,",
            "            edges=self.edges,",
            "            last_refresh=self.last_refresh,",
            "            arrange=conf.get(\"webserver\", \"dag_orientation\"),",
            "            width=request.args.get(\"width\", \"100%\"),",
            "            height=request.args.get(\"height\", \"800\"),",
            "        )",
            "",
            "    def _calculate_graph(self):",
            "        nodes_dict: dict[str, Any] = {}",
            "        edge_tuples: set[dict[str, str]] = set()",
            "",
            "        for dag, dependencies in SerializedDagModel.get_dag_dependencies().items():",
            "            dag_node_id = f\"dag:{dag}\"",
            "            if dag_node_id not in nodes_dict:",
            "                nodes_dict[dag_node_id] = node_dict(dag_node_id, dag, \"dag\")",
            "",
            "            for dep in dependencies:",
            "                if dep.node_id not in nodes_dict:",
            "                    nodes_dict[dep.node_id] = node_dict(dep.node_id, dep.dependency_id, dep.dependency_type)",
            "                edge_tuples.add((f\"dag:{dep.source}\", dep.node_id))",
            "                edge_tuples.add((dep.node_id, f\"dag:{dep.target}\"))",
            "",
            "        self.nodes = list(nodes_dict.values())",
            "        self.edges = [{\"u\": u, \"v\": v} for u, v in edge_tuples]",
            "",
            "",
            "def add_user_permissions_to_dag(sender, template, context, **extra):",
            "    \"\"\"",
            "    Adds `.can_edit`, `.can_trigger`, and `.can_delete` properties",
            "    to DAG based on current user's permissions.",
            "    Located in `views.py` rather than the DAG model to keep",
            "    permissions logic out of the Airflow core.",
            "    \"\"\"",
            "    if \"dag\" not in context:",
            "        return",
            "    dag = context[\"dag\"]",
            "    can_create_dag_run = get_airflow_app().appbuilder.sm.has_access(",
            "        permissions.ACTION_CAN_CREATE, permissions.RESOURCE_DAG_RUN",
            "    )",
            "",
            "    dag.can_edit = get_airflow_app().appbuilder.sm.can_edit_dag(dag.dag_id)",
            "    dag.can_trigger = dag.can_edit and can_create_dag_run",
            "    dag.can_delete = get_airflow_app().appbuilder.sm.can_delete_dag(dag.dag_id)",
            "    context[\"dag\"] = dag",
            "",
            "",
            "# NOTE: Put this at the end of the file. Pylance is too clever and detects that",
            "# before_render_template.connect() is declared as NoReturn, and marks everything",
            "# after this line as unreachable code. It's technically correct based on the",
            "# lint-time information, but that's not what actually happens at runtime.",
            "before_render_template.connect(add_user_permissions_to_dag)"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import collections",
            "import copy",
            "import datetime",
            "import itertools",
            "import json",
            "import logging",
            "import math",
            "import re",
            "import sys",
            "import traceback",
            "import warnings",
            "from bisect import insort_left",
            "from collections import defaultdict",
            "from functools import cached_property, wraps",
            "from json import JSONDecodeError",
            "from typing import Any, Callable, Collection, Iterator, Mapping, MutableMapping, Sequence",
            "from urllib.parse import unquote, urljoin, urlsplit",
            "",
            "import configupdater",
            "import flask.json",
            "import lazy_object_proxy",
            "import nvd3",
            "import sqlalchemy as sqla",
            "from croniter import croniter",
            "from flask import (",
            "    Response,",
            "    abort,",
            "    before_render_template,",
            "    flash,",
            "    g,",
            "    has_request_context,",
            "    make_response,",
            "    redirect,",
            "    render_template,",
            "    request,",
            "    send_from_directory,",
            "    session as flask_session,",
            "    url_for,",
            ")",
            "from flask_appbuilder import BaseView, ModelView, expose",
            "from flask_appbuilder.actions import action",
            "from flask_appbuilder.models.sqla.filters import BaseFilter",
            "from flask_appbuilder.security.decorators import has_access",
            "from flask_appbuilder.urltools import get_order_args, get_page_args, get_page_size_args",
            "from flask_appbuilder.widgets import FormWidget",
            "from flask_babel import lazy_gettext",
            "from jinja2.utils import htmlsafe_json_dumps, pformat  # type: ignore",
            "from markupsafe import Markup, escape",
            "from pendulum.datetime import DateTime",
            "from pendulum.parsing.exceptions import ParserError",
            "from pygments import highlight, lexers",
            "from pygments.formatters import HtmlFormatter",
            "from sqlalchemy import Date, and_, case, desc, func, inspect, or_, union_all",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.orm import Session, joinedload",
            "from wtforms import SelectField, validators",
            "",
            "import airflow",
            "from airflow import models, plugins_manager, settings",
            "from airflow.api.common.airflow_health import get_airflow_health",
            "from airflow.api.common.mark_tasks import (",
            "    set_dag_run_state_to_failed,",
            "    set_dag_run_state_to_queued,",
            "    set_dag_run_state_to_success,",
            "    set_state,",
            ")",
            "from airflow.configuration import AIRFLOW_CONFIG, conf",
            "from airflow.datasets import Dataset",
            "from airflow.exceptions import (",
            "    AirflowConfigException,",
            "    AirflowException,",
            "    ParamValidationError,",
            "    RemovedInAirflow3Warning,",
            ")",
            "from airflow.executors.executor_loader import ExecutorLoader",
            "from airflow.jobs.job import Job",
            "from airflow.jobs.scheduler_job_runner import SchedulerJobRunner",
            "from airflow.jobs.triggerer_job_runner import TriggererJobRunner",
            "from airflow.models import Connection, DagModel, DagTag, Log, SlaMiss, TaskFail, XCom, errors",
            "from airflow.models.abstractoperator import AbstractOperator",
            "from airflow.models.dag import DAG, get_dataset_triggered_next_run_info",
            "from airflow.models.dagcode import DagCode",
            "from airflow.models.dagrun import RUN_ID_REGEX, DagRun, DagRunType",
            "from airflow.models.dataset import DagScheduleDatasetReference, DatasetDagRunQueue, DatasetEvent, DatasetModel",
            "from airflow.models.mappedoperator import MappedOperator",
            "from airflow.models.operator import Operator",
            "from airflow.models.serialized_dag import SerializedDagModel",
            "from airflow.models.taskinstance import TaskInstance, TaskInstanceNote",
            "from airflow.providers_manager import ProvidersManager",
            "from airflow.security import permissions",
            "from airflow.ti_deps.dep_context import DepContext",
            "from airflow.ti_deps.dependencies_deps import SCHEDULER_QUEUED_DEPS",
            "from airflow.timetables._cron import CronMixin",
            "from airflow.timetables.base import DataInterval, TimeRestriction",
            "from airflow.utils import json as utils_json, timezone, yaml",
            "from airflow.utils.airflow_flask_app import get_airflow_app",
            "from airflow.utils.dag_edges import dag_edges",
            "from airflow.utils.dates import infer_time_unit, scale_time_units",
            "from airflow.utils.docs import get_doc_url_for_provider, get_docs_url",
            "from airflow.utils.helpers import alchemy_to_dict, exactly_one",
            "from airflow.utils.log import secrets_masker",
            "from airflow.utils.log.log_reader import TaskLogReader",
            "from airflow.utils.net import get_hostname",
            "from airflow.utils.session import NEW_SESSION, create_session, provide_session",
            "from airflow.utils.state import DagRunState, State, TaskInstanceState",
            "from airflow.utils.strings import to_boolean",
            "from airflow.utils.task_group import MappedTaskGroup, TaskGroup, task_group_to_dict",
            "from airflow.utils.timezone import td_format, utcnow",
            "from airflow.version import version",
            "from airflow.www import auth, utils as wwwutils",
            "from airflow.www.decorators import action_logging, gzipped",
            "from airflow.www.forms import (",
            "    DagRunEditForm,",
            "    DateTimeForm,",
            "    DateTimeWithNumRunsForm,",
            "    DateTimeWithNumRunsWithDagRunsForm,",
            "    TaskInstanceEditForm,",
            "    create_connection_form_class,",
            ")",
            "from airflow.www.widgets import AirflowModelListWidget, AirflowVariableShowWidget",
            "",
            "PAGE_SIZE = conf.getint(\"webserver\", \"page_size\")",
            "FILTER_TAGS_COOKIE = \"tags_filter\"",
            "FILTER_STATUS_COOKIE = \"dag_status_filter\"",
            "LINECHART_X_AXIS_TICKFORMAT = (",
            "    \"function (d, i) { let xLabel;\"",
            "    \"if (i === undefined) {xLabel = d3.time.format('%H:%M, %d %b %Y')(new Date(parseInt(d)));\"",
            "    \"} else {xLabel = d3.time.format('%H:%M, %d %b')(new Date(parseInt(d)));} return xLabel;}\"",
            ")",
            "",
            "",
            "def sanitize_args(args: dict[str, str]) -> dict[str, str]:",
            "    \"\"\"",
            "    Remove all parameters starting with `_`.",
            "",
            "    :param args: arguments of request",
            "    :return: copy of the dictionary passed as input with args starting with `_` removed.",
            "    \"\"\"",
            "    return {key: value for key, value in args.items() if not key.startswith(\"_\")}",
            "",
            "",
            "# Following the release of https://github.com/python/cpython/issues/102153 in Python 3.8.17 and 3.9.17 on",
            "# June 6, 2023, we are adding extra sanitization of the urls passed to get_safe_url method to make it works",
            "# the same way regardless if the user uses latest Python patchlevel versions or not. This also follows",
            "# a recommended solution by the Python core team.",
            "#",
            "# From: https://github.com/python/cpython/commit/d28bafa2d3e424b6fdcfd7ae7cde8e71d7177369",
            "#",
            "#   We recommend that users of these APIs where the values may be used anywhere",
            "#   with security implications code defensively. Do some verification within your",
            "#   code before trusting a returned component part.  Does that ``scheme`` make",
            "#   sense?  Is that a sensible ``path``?  Is there anything strange about that",
            "#   ``hostname``?  etc.",
            "#",
            "# C0 control and space to be stripped per WHATWG spec.",
            "# == \"\".join([chr(i) for i in range(0, 0x20 + 1)])",
            "_WHATWG_C0_CONTROL_OR_SPACE = (",
            "    \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\"",
            "    \"\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \"",
            ")",
            "",
            "",
            "def get_safe_url(url):",
            "    \"\"\"Given a user-supplied URL, ensure it points to our web server.\"\"\"",
            "    if not url:",
            "        return url_for(\"Airflow.index\")",
            "",
            "    # If the url contains semicolon, redirect it to homepage to avoid",
            "    # potential XSS. (Similar to https://github.com/python/cpython/pull/24297/files (bpo-42967))",
            "    if \";\" in unquote(url):",
            "        return url_for(\"Airflow.index\")",
            "",
            "    url = url.lstrip(_WHATWG_C0_CONTROL_OR_SPACE)",
            "",
            "    host_url = urlsplit(request.host_url)",
            "    redirect_url = urlsplit(urljoin(request.host_url, url))",
            "    if not (redirect_url.scheme in (\"http\", \"https\") and host_url.netloc == redirect_url.netloc):",
            "        return url_for(\"Airflow.index\")",
            "",
            "    # This will ensure we only redirect to the right scheme/netloc",
            "    return redirect_url.geturl()",
            "",
            "",
            "def get_date_time_num_runs_dag_runs_form_data(www_request, session, dag):",
            "    \"\"\"Get Execution Data, Base Date & Number of runs from a Request.\"\"\"",
            "    date_time = www_request.args.get(\"execution_date\")",
            "    run_id = www_request.args.get(\"run_id\")",
            "    # First check run id, then check execution date, if not fall back on the latest dagrun",
            "    if run_id:",
            "        dagrun = dag.get_dagrun(run_id=run_id, session=session)",
            "        date_time = dagrun.execution_date",
            "    elif date_time:",
            "        date_time = _safe_parse_datetime(date_time)",
            "    else:",
            "        date_time = dag.get_latest_execution_date(session=session) or timezone.utcnow()",
            "",
            "    base_date = www_request.args.get(\"base_date\")",
            "    if base_date:",
            "        base_date = _safe_parse_datetime(base_date)",
            "    else:",
            "        # The DateTimeField widget truncates milliseconds and would loose",
            "        # the first dag run. Round to next second.",
            "        base_date = (date_time + datetime.timedelta(seconds=1)).replace(microsecond=0)",
            "",
            "    default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "    num_runs = www_request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "    # When base_date has been rounded up because of the DateTimeField widget, we want",
            "    # to use the execution_date as the starting point for our query just to ensure a",
            "    # link targeting a specific dag run actually loads that dag run.  If there are",
            "    # more than num_runs dag runs in the \"rounded period\" then those dagruns would get",
            "    # loaded and the actual requested run would be excluded by the limit().  Once",
            "    # the user has changed base date to be anything else we want to use that instead.",
            "    query_date = base_date",
            "    if date_time < base_date and date_time + datetime.timedelta(seconds=1) >= base_date:",
            "        query_date = date_time",
            "",
            "    drs = (",
            "        session.query(DagRun)",
            "        .filter(DagRun.dag_id == dag.dag_id, DagRun.execution_date <= query_date)",
            "        .order_by(desc(DagRun.execution_date))",
            "        .limit(num_runs)",
            "        .all()",
            "    )",
            "    dr_choices = []",
            "    dr_state = None",
            "    for dr in drs:",
            "        dr_choices.append((dr.execution_date.isoformat(), dr.run_id))",
            "        if date_time == dr.execution_date:",
            "            dr_state = dr.state",
            "",
            "    # Happens if base_date was changed and the selected dag run is not in result",
            "    if not dr_state and drs:",
            "        dr = drs[0]",
            "        date_time = dr.execution_date",
            "        dr_state = dr.state",
            "",
            "    return {",
            "        \"dttm\": date_time,",
            "        \"base_date\": base_date,",
            "        \"num_runs\": num_runs,",
            "        \"execution_date\": date_time.isoformat(),",
            "        \"dr_choices\": dr_choices,",
            "        \"dr_state\": dr_state,",
            "    }",
            "",
            "",
            "def _safe_parse_datetime(v, allow_empty=False) -> datetime.datetime | None:",
            "    \"\"\"",
            "    Parse datetime and return error message for invalid dates.",
            "",
            "    :param v: the string value to be parsed",
            "    :param allow_empty: Set True to return none if empty str or None",
            "    \"\"\"",
            "    if allow_empty is True and not v:",
            "        return None",
            "    try:",
            "        return timezone.parse(v)",
            "    except (TypeError, ParserError):",
            "        abort(400, f\"Invalid datetime: {v!r}\")",
            "",
            "",
            "def node_dict(node_id, label, node_class):",
            "    return {",
            "        \"id\": node_id,",
            "        \"value\": {\"label\": label, \"rx\": 5, \"ry\": 5, \"class\": node_class},",
            "    }",
            "",
            "",
            "def dag_to_grid(dag: DagModel, dag_runs: Sequence[DagRun], session: Session):",
            "    \"\"\"",
            "    Create a nested dict representation of the DAG's TaskGroup and its children",
            "    used to construct the Graph and Grid views.",
            "    \"\"\"",
            "    query = (",
            "        session.query(",
            "            TaskInstance.task_id,",
            "            TaskInstance.run_id,",
            "            TaskInstance.state,",
            "            TaskInstance._try_number,",
            "            func.min(TaskInstanceNote.content).label(\"note\"),",
            "            func.count(func.coalesce(TaskInstance.state, sqla.literal(\"no_status\"))).label(\"state_count\"),",
            "            func.min(TaskInstance.start_date).label(\"start_date\"),",
            "            func.max(TaskInstance.end_date).label(\"end_date\"),",
            "        )",
            "        .join(TaskInstance.task_instance_note, isouter=True)",
            "        .filter(",
            "            TaskInstance.dag_id == dag.dag_id,",
            "            TaskInstance.run_id.in_([dag_run.run_id for dag_run in dag_runs]),",
            "        )",
            "        .group_by(TaskInstance.task_id, TaskInstance.run_id, TaskInstance.state, TaskInstance._try_number)",
            "        .order_by(TaskInstance.task_id, TaskInstance.run_id)",
            "    )",
            "",
            "    grouped_tis = {task_id: list(tis) for task_id, tis in itertools.groupby(query, key=lambda ti: ti.task_id)}",
            "",
            "    sort_order = conf.get(\"webserver\", \"grid_view_sorting_order\", fallback=\"topological\")",
            "    if sort_order == \"topological\":",
            "        sort_children_fn = lambda task_group: task_group.topological_sort()",
            "    elif sort_order == \"hierarchical_alphabetical\":",
            "        sort_children_fn = lambda task_group: task_group.hierarchical_alphabetical_sort()",
            "    else:",
            "        raise AirflowConfigException(f\"Unsupported grid_view_sorting_order: {sort_order}\")",
            "",
            "    def task_group_to_grid(item, grouped_tis, *, is_parent_mapped: bool):",
            "        if not isinstance(item, TaskGroup):",
            "",
            "            def _get_summary(task_instance):",
            "                return {",
            "                    \"task_id\": task_instance.task_id,",
            "                    \"run_id\": task_instance.run_id,",
            "                    \"state\": task_instance.state,",
            "                    \"start_date\": task_instance.start_date,",
            "                    \"end_date\": task_instance.end_date,",
            "                    \"try_number\": wwwutils.get_try_count(task_instance._try_number, task_instance.state),",
            "                    \"note\": task_instance.note,",
            "                }",
            "",
            "            def _mapped_summary(ti_summaries):",
            "                run_id = None",
            "                record = None",
            "",
            "                def set_overall_state(record):",
            "                    for state in wwwutils.priority:",
            "                        if state in record[\"mapped_states\"]:",
            "                            record[\"state\"] = state",
            "                            break",
            "                    if None in record[\"mapped_states\"]:",
            "                        # When turning the dict into JSON we can't have None as a key,",
            "                        # so use the string that the UI does.",
            "                        record[\"mapped_states\"][\"no_status\"] = record[\"mapped_states\"].pop(None)",
            "",
            "                for ti_summary in ti_summaries:",
            "                    if run_id != ti_summary.run_id:",
            "                        run_id = ti_summary.run_id",
            "                        if record:",
            "                            set_overall_state(record)",
            "                            yield record",
            "                        record = {",
            "                            \"task_id\": ti_summary.task_id,",
            "                            \"run_id\": run_id,",
            "                            \"start_date\": ti_summary.start_date,",
            "                            \"end_date\": ti_summary.end_date,",
            "                            \"mapped_states\": {ti_summary.state: ti_summary.state_count},",
            "                            \"state\": None,  # We change this before yielding",
            "                        }",
            "                        continue",
            "                    record[\"start_date\"] = min(",
            "                        filter(None, [record[\"start_date\"], ti_summary.start_date]), default=None",
            "                    )",
            "                    record[\"end_date\"] = max(",
            "                        filter(None, [record[\"end_date\"], ti_summary.end_date]), default=None",
            "                    )",
            "                    record[\"mapped_states\"][ti_summary.state] = ti_summary.state_count",
            "                if record:",
            "                    set_overall_state(record)",
            "                    yield record",
            "",
            "            if isinstance(item, MappedOperator) or is_parent_mapped:",
            "                instances = list(_mapped_summary(grouped_tis.get(item.task_id, [])))",
            "            else:",
            "                instances = list(map(_get_summary, grouped_tis.get(item.task_id, [])))",
            "",
            "            return {",
            "                \"id\": item.task_id,",
            "                \"instances\": instances,",
            "                \"label\": item.label,",
            "                \"extra_links\": item.extra_links,",
            "                \"is_mapped\": isinstance(item, MappedOperator) or is_parent_mapped,",
            "                \"has_outlet_datasets\": any(isinstance(i, Dataset) for i in (item.outlets or [])),",
            "                \"operator\": item.operator_name,",
            "                \"trigger_rule\": item.trigger_rule,",
            "            }",
            "",
            "        # Task Group",
            "        task_group = item",
            "        group_is_mapped = isinstance(task_group, MappedTaskGroup)",
            "",
            "        children = [",
            "            task_group_to_grid(child, grouped_tis, is_parent_mapped=group_is_mapped)",
            "            for child in sort_children_fn(task_group)",
            "        ]",
            "",
            "        def get_summary(dag_run: DagRun):",
            "            child_instances = [",
            "                item",
            "                for sublist in (child[\"instances\"] for child in children if \"instances\" in child)",
            "                for item in sublist",
            "                if item[\"run_id\"] == dag_run.run_id",
            "                if item",
            "            ]",
            "",
            "            children_start_dates = (item[\"start_date\"] for item in child_instances)",
            "            children_end_dates = (item[\"end_date\"] for item in child_instances)",
            "            children_states = {item[\"state\"] for item in child_instances}",
            "",
            "            group_state = next((state for state in wwwutils.priority if state in children_states), None)",
            "            group_start_date = min(filter(None, children_start_dates), default=None)",
            "            group_end_date = max(filter(None, children_end_dates), default=None)",
            "",
            "            return {",
            "                \"task_id\": task_group.group_id,",
            "                \"run_id\": dag_run.run_id,",
            "                \"state\": group_state,",
            "                \"start_date\": group_start_date,",
            "                \"end_date\": group_end_date,",
            "            }",
            "",
            "        def get_mapped_group_summaries():",
            "            mapped_ti_query = (",
            "                session.query(",
            "                    TaskInstance.task_id, TaskInstance.state, TaskInstance.run_id, TaskInstance.map_index",
            "                )",
            "                .filter(",
            "                    TaskInstance.dag_id == dag.dag_id,",
            "                    TaskInstance.task_id.in_(child[\"id\"] for child in children),",
            "                    TaskInstance.run_id.in_(r.run_id for r in dag_runs),",
            "                )",
            "                .order_by(TaskInstance.task_id, TaskInstance.run_id)",
            "            )",
            "            # Group tis by run_id, and then map_index.",
            "            mapped_tis: Mapping[str, Mapping[int, list[TaskInstance]]] = collections.defaultdict(",
            "                lambda: collections.defaultdict(list),",
            "            )",
            "            for ti in mapped_ti_query:",
            "                mapped_tis[ti.run_id][ti.map_index].append(ti)",
            "",
            "            def get_mapped_group_summary(run_id: str, mapped_instances: Mapping[int, list[TaskInstance]]):",
            "                child_instances = [",
            "                    item",
            "                    for sublist in (child[\"instances\"] for child in children if \"instances\" in child)",
            "                    for item in sublist",
            "                    if item and item[\"run_id\"] == run_id",
            "                ]",
            "",
            "                children_start_dates = (item[\"start_date\"] for item in child_instances)",
            "                children_end_dates = (item[\"end_date\"] for item in child_instances)",
            "                children_states = {item[\"state\"] for item in child_instances}",
            "",
            "                # TODO: This assumes TI map index has a one-to-one mapping to",
            "                # its parent mapped task group, which will not be true when we",
            "                # allow nested mapping in the future.",
            "                mapped_states: MutableMapping[str, int] = collections.defaultdict(int)",
            "                for mis in mapped_instances.values():",
            "                    child_states = {mi.state for mi in mis}",
            "                    state = next(s for s in wwwutils.priority if s in child_states)",
            "                    value = state.value if state is not None else \"no_status\"",
            "                    mapped_states[value] += 1",
            "",
            "                group_state = next((state for state in wwwutils.priority if state in children_states), None)",
            "                group_start_date = min(filter(None, children_start_dates), default=None)",
            "                group_end_date = max(filter(None, children_end_dates), default=None)",
            "",
            "                return {",
            "                    \"task_id\": task_group.group_id,",
            "                    \"run_id\": run_id,",
            "                    \"state\": group_state,",
            "                    \"start_date\": group_start_date,",
            "                    \"end_date\": group_end_date,",
            "                    \"mapped_states\": mapped_states,",
            "                }",
            "",
            "            return [get_mapped_group_summary(run_id, tis) for run_id, tis in mapped_tis.items()]",
            "",
            "        # We don't need to calculate summaries for the root",
            "        if task_group.group_id is None:",
            "            return {",
            "                \"id\": task_group.group_id,",
            "                \"label\": task_group.label,",
            "                \"children\": children,",
            "                \"instances\": [],",
            "            }",
            "",
            "        if group_is_mapped:",
            "            mapped_group_summaries = get_mapped_group_summaries()",
            "",
            "            return {",
            "                \"id\": task_group.group_id,",
            "                \"label\": task_group.label,",
            "                \"children\": children,",
            "                \"tooltip\": task_group.tooltip,",
            "                \"instances\": mapped_group_summaries,",
            "                \"is_mapped\": group_is_mapped,",
            "            }",
            "",
            "        group_summaries = [get_summary(dr) for dr in dag_runs]",
            "",
            "        return {",
            "            \"id\": task_group.group_id,",
            "            \"label\": task_group.label,",
            "            \"children\": children,",
            "            \"tooltip\": task_group.tooltip,",
            "            \"instances\": group_summaries,",
            "        }",
            "",
            "    return task_group_to_grid(dag.task_group, grouped_tis, is_parent_mapped=False)",
            "",
            "",
            "def get_key_paths(input_dict):",
            "    \"\"\"Return a list of dot-separated dictionary paths.\"\"\"",
            "    for key, value in input_dict.items():",
            "        if isinstance(value, dict):",
            "            for sub_key in get_key_paths(value):",
            "                yield \".\".join((key, sub_key))",
            "        else:",
            "            yield key",
            "",
            "",
            "def get_value_from_path(key_path, content):",
            "    \"\"\"Return the value from a dictionary based on dot-separated path of keys.\"\"\"",
            "    elem = content",
            "    for x in key_path.strip(\".\").split(\".\"):",
            "        try:",
            "            x = int(x)",
            "            elem = elem[x]",
            "        except ValueError:",
            "            elem = elem.get(x)",
            "",
            "    return elem",
            "",
            "",
            "def get_task_stats_from_query(qry):",
            "    \"\"\"",
            "    Return a dict of the task quantity, grouped by dag id and task status.",
            "",
            "    :param qry: The data in the format (<dag id>, <task state>, <is dag running>, <task count>),",
            "        ordered by <dag id> and <is dag running>",
            "    \"\"\"",
            "    data = {}",
            "    last_dag_id = None",
            "    has_running_dags = False",
            "    for dag_id, state, is_dag_running, count in qry:",
            "        if last_dag_id != dag_id:",
            "            last_dag_id = dag_id",
            "            has_running_dags = False",
            "        elif not is_dag_running and has_running_dags:",
            "            continue",
            "",
            "        if is_dag_running:",
            "            has_running_dags = True",
            "        if dag_id not in data:",
            "            data[dag_id] = {}",
            "        data[dag_id][state] = count",
            "    return data",
            "",
            "",
            "def redirect_or_json(origin, msg, status=\"\", status_code=200):",
            "    \"\"\"",
            "    Some endpoints are called by javascript,",
            "    returning json will allow us to more elegantly handle side-effects in-page.",
            "    \"\"\"",
            "    if request.headers.get(\"Accept\") == \"application/json\":",
            "        if status == \"error\" and status_code == 200:",
            "            status_code = 500",
            "        return Response(response=msg, status=status_code, mimetype=\"application/json\")",
            "    else:",
            "        if status:",
            "            flash(msg, status)",
            "        else:",
            "            flash(msg)",
            "        return redirect(origin)",
            "",
            "",
            "######################################################################################",
            "#                                    Error handlers",
            "######################################################################################",
            "",
            "",
            "def not_found(error):",
            "    \"\"\"Show Not Found on screen for any error in the Webserver.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/error.html\",",
            "            hostname=get_hostname() if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") else \"redact\",",
            "            status_code=404,",
            "            error_message=\"Page cannot be found.\",",
            "        ),",
            "        404,",
            "    )",
            "",
            "",
            "def method_not_allowed(error):",
            "    \"\"\"Show Method Not Allowed on screen for any error in the Webserver.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/error.html\",",
            "            hostname=get_hostname() if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") else \"redact\",",
            "            status_code=405,",
            "            error_message=\"Received an invalid request.\",",
            "        ),",
            "        405,",
            "    )",
            "",
            "",
            "def show_traceback(error):",
            "    \"\"\"Show Traceback for a given error.\"\"\"",
            "    return (",
            "        render_template(",
            "            \"airflow/traceback.html\",",
            "            python_version=sys.version.split(\" \")[0] if g.user.is_authenticated else \"redact\",",
            "            airflow_version=version if g.user.is_authenticated else \"redact\",",
            "            hostname=get_hostname()",
            "            if conf.getboolean(\"webserver\", \"EXPOSE_HOSTNAME\") and g.user.is_authenticated",
            "            else \"redact\",",
            "            info=traceback.format_exc()",
            "            if conf.getboolean(\"webserver\", \"EXPOSE_STACKTRACE\") and g.user.is_authenticated",
            "            else \"Error! Please contact server admin.\",",
            "        ),",
            "        500,",
            "    )",
            "",
            "",
            "######################################################################################",
            "#                                    BaseViews",
            "######################################################################################",
            "",
            "",
            "class AirflowBaseView(BaseView):",
            "    \"\"\"Base View to set Airflow related properties.\"\"\"",
            "",
            "    from airflow import macros",
            "",
            "    route_base = \"\"",
            "",
            "    extra_args = {",
            "        # Make our macros available to our UI templates too.",
            "        \"macros\": macros,",
            "        \"get_docs_url\": get_docs_url,",
            "    }",
            "",
            "    if not conf.getboolean(\"core\", \"unit_test_mode\"):",
            "        executor, _ = ExecutorLoader.import_default_executor_cls()",
            "        extra_args[\"sqlite_warning\"] = settings.engine.dialect.name == \"sqlite\"",
            "        if not executor.is_production:",
            "            extra_args[\"production_executor_warning\"] = executor.__name__",
            "        extra_args[\"otel_on\"] = conf.getboolean(\"metrics\", \"otel_on\")",
            "",
            "    line_chart_attr = {",
            "        \"legend.maxKeyLength\": 200,",
            "    }",
            "",
            "    def render_template(self, *args, **kwargs):",
            "        # Add triggerer_job only if we need it",
            "        if TriggererJobRunner.is_needed():",
            "            kwargs[\"triggerer_job\"] = lazy_object_proxy.Proxy(TriggererJobRunner.most_recent_job)",
            "        return super().render_template(",
            "            *args,",
            "            # Cache this at most once per request, not for the lifetime of the view instance",
            "            scheduler_job=lazy_object_proxy.Proxy(SchedulerJobRunner.most_recent_job),",
            "            **kwargs,",
            "        )",
            "",
            "",
            "class Airflow(AirflowBaseView):",
            "    \"\"\"Main Airflow application.\"\"\"",
            "",
            "    @expose(\"/health\")",
            "    def health(self):",
            "        \"\"\"",
            "        An endpoint helping check the health status of the Airflow instance,",
            "        including metadatabase, scheduler and triggerer.",
            "        \"\"\"",
            "        airflow_health_status = get_airflow_health()",
            "",
            "        return flask.json.jsonify(airflow_health_status)",
            "",
            "    @expose(\"/home\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_WEBSITE),",
            "        ]",
            "    )",
            "    def index(self):",
            "        \"\"\"Home view.\"\"\"",
            "        from airflow.models.dag import DagOwnerAttributes",
            "",
            "        hide_paused_dags_by_default = conf.getboolean(\"webserver\", \"hide_paused_dags_by_default\")",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "        current_page = request.args.get(\"page\", default=0, type=int)",
            "        arg_search_query = request.args.get(\"search\")",
            "        arg_tags_filter = request.args.getlist(\"tags\")",
            "        arg_status_filter = request.args.get(\"status\")",
            "        arg_sorting_key = request.args.get(\"sorting_key\", \"dag_id\")",
            "        arg_sorting_direction = request.args.get(\"sorting_direction\", default=\"asc\")",
            "",
            "        if request.args.get(\"reset_tags\") is not None:",
            "            flask_session[FILTER_TAGS_COOKIE] = None",
            "            # Remove the reset_tags=reset from the URL",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        cookie_val = flask_session.get(FILTER_TAGS_COOKIE)",
            "        if arg_tags_filter:",
            "            flask_session[FILTER_TAGS_COOKIE] = \",\".join(arg_tags_filter)",
            "        elif cookie_val:",
            "            # If tags exist in cookie, but not URL, add them to the URL",
            "            return redirect(url_for(\"Airflow.index\", tags=cookie_val.split(\",\")))",
            "",
            "        if arg_status_filter is None:",
            "            cookie_val = flask_session.get(FILTER_STATUS_COOKIE)",
            "            if cookie_val:",
            "                arg_status_filter = cookie_val",
            "            else:",
            "                arg_status_filter = \"active\" if hide_paused_dags_by_default else \"all\"",
            "                flask_session[FILTER_STATUS_COOKIE] = arg_status_filter",
            "        else:",
            "            status = arg_status_filter.strip().lower()",
            "            flask_session[FILTER_STATUS_COOKIE] = status",
            "            arg_status_filter = status",
            "",
            "        dags_per_page = PAGE_SIZE",
            "",
            "        start = current_page * dags_per_page",
            "        end = start + dags_per_page",
            "",
            "        # Get all the dag id the user could access",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        with create_session() as session:",
            "            # read orm_dags from the db",
            "            dags_query = session.query(DagModel).filter(~DagModel.is_subdag, DagModel.is_active)",
            "",
            "            if arg_search_query:",
            "                escaped_arg_search_query = arg_search_query.replace(\"_\", r\"\\_\")",
            "                dags_query = dags_query.filter(",
            "                    DagModel.dag_id.ilike(\"%\" + escaped_arg_search_query + \"%\", escape=\"\\\\\")",
            "                    | DagModel.owners.ilike(\"%\" + escaped_arg_search_query + \"%\", escape=\"\\\\\")",
            "                )",
            "",
            "            if arg_tags_filter:",
            "                dags_query = dags_query.filter(DagModel.tags.any(DagTag.name.in_(arg_tags_filter)))",
            "",
            "            dags_query = dags_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "            filtered_dag_count = dags_query.count()",
            "            if filtered_dag_count == 0 and len(arg_tags_filter):",
            "                flash(",
            "                    \"No matching DAG tags found.\",",
            "                    \"warning\",",
            "                )",
            "                flask_session[FILTER_TAGS_COOKIE] = None",
            "                return redirect(url_for(\"Airflow.index\"))",
            "",
            "            all_dags = dags_query",
            "            active_dags = dags_query.filter(~DagModel.is_paused)",
            "            paused_dags = dags_query.filter(DagModel.is_paused)",
            "",
            "            # find DAGs which have a RUNNING DagRun",
            "            running_dags = dags_query.join(DagRun, DagModel.dag_id == DagRun.dag_id).filter(",
            "                DagRun.state == State.RUNNING",
            "            )",
            "",
            "            # find DAGs for which the latest DagRun is FAILED",
            "            subq_all = (",
            "                session.query(DagRun.dag_id, func.max(DagRun.start_date).label(\"start_date\"))",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            subq_failed = (",
            "                session.query(DagRun.dag_id, func.max(DagRun.start_date).label(\"start_date\"))",
            "                .filter(DagRun.state == State.FAILED)",
            "                .group_by(DagRun.dag_id)",
            "                .subquery()",
            "            )",
            "            subq_join = (",
            "                session.query(subq_all.c.dag_id, subq_all.c.start_date)",
            "                .join(",
            "                    subq_failed,",
            "                    and_(",
            "                        subq_all.c.dag_id == subq_failed.c.dag_id,",
            "                        subq_all.c.start_date == subq_failed.c.start_date,",
            "                    ),",
            "                )",
            "                .subquery()",
            "            )",
            "            failed_dags = dags_query.join(subq_join, DagModel.dag_id == subq_join.c.dag_id)",
            "",
            "            is_paused_count = dict(",
            "                all_dags.with_entities(DagModel.is_paused, func.count(DagModel.dag_id)).group_by(",
            "                    DagModel.is_paused",
            "                )",
            "            )",
            "",
            "            status_count_active = is_paused_count.get(False, 0)",
            "            status_count_paused = is_paused_count.get(True, 0)",
            "",
            "            status_count_running = running_dags.count()",
            "            status_count_failed = failed_dags.count()",
            "",
            "            all_dags_count = status_count_active + status_count_paused",
            "            if arg_status_filter == \"active\":",
            "                current_dags = active_dags",
            "                num_of_all_dags = status_count_active",
            "            elif arg_status_filter == \"paused\":",
            "                current_dags = paused_dags",
            "                num_of_all_dags = status_count_paused",
            "            elif arg_status_filter == \"running\":",
            "                current_dags = running_dags",
            "                num_of_all_dags = status_count_running",
            "            elif arg_status_filter == \"failed\":",
            "                current_dags = failed_dags",
            "                num_of_all_dags = status_count_failed",
            "            else:",
            "                current_dags = all_dags",
            "                num_of_all_dags = all_dags_count",
            "",
            "            if arg_sorting_key == \"last_dagrun\":",
            "                dag_run_subquery = (",
            "                    session.query(",
            "                        DagRun.dag_id,",
            "                        sqla.func.max(DagRun.execution_date).label(\"max_execution_date\"),",
            "                    )",
            "                    .group_by(DagRun.dag_id)",
            "                    .subquery()",
            "                )",
            "                current_dags = current_dags.outerjoin(",
            "                    dag_run_subquery, and_(dag_run_subquery.c.dag_id == DagModel.dag_id)",
            "                )",
            "                null_case = case((dag_run_subquery.c.max_execution_date.is_(None), 1), else_=0)",
            "                if arg_sorting_direction == \"desc\":",
            "                    current_dags = current_dags.order_by(",
            "                        null_case, dag_run_subquery.c.max_execution_date.desc()",
            "                    )",
            "",
            "                else:",
            "                    current_dags = current_dags.order_by(null_case, dag_run_subquery.c.max_execution_date)",
            "",
            "            else:",
            "                sort_column = DagModel.__table__.c.get(arg_sorting_key)",
            "                if sort_column is not None:",
            "                    null_case = case((sort_column.is_(None), 1), else_=0)",
            "                    if arg_sorting_direction == \"desc\":",
            "                        current_dags = current_dags.order_by(null_case, sort_column.desc())",
            "                    else:",
            "                        current_dags = current_dags.order_by(null_case, sort_column)",
            "",
            "            dags = current_dags.options(joinedload(DagModel.tags)).offset(start).limit(dags_per_page).all()",
            "            user_permissions = g.user.perms",
            "            can_create_dag_run = (",
            "                permissions.ACTION_CAN_CREATE,",
            "                permissions.RESOURCE_DAG_RUN,",
            "            ) in user_permissions",
            "",
            "            dataset_triggered_dag_ids = {dag.dag_id for dag in dags if dag.schedule_interval == \"Dataset\"}",
            "            if dataset_triggered_dag_ids:",
            "                dataset_triggered_next_run_info = get_dataset_triggered_next_run_info(",
            "                    dataset_triggered_dag_ids, session=session",
            "                )",
            "            else:",
            "                dataset_triggered_next_run_info = {}",
            "",
            "            for dag in dags:",
            "                dag.can_edit = get_airflow_app().appbuilder.sm.can_edit_dag(dag.dag_id, g.user)",
            "                dag.can_trigger = dag.can_edit and can_create_dag_run",
            "                dag.can_delete = get_airflow_app().appbuilder.sm.can_delete_dag(dag.dag_id, g.user)",
            "",
            "            dagtags = session.query(func.distinct(DagTag.name)).order_by(DagTag.name).all()",
            "            tags = [",
            "                {\"name\": name, \"selected\": bool(arg_tags_filter and name in arg_tags_filter)}",
            "                for name, in dagtags",
            "            ]",
            "",
            "            owner_links_dict = DagOwnerAttributes.get_all(session)",
            "",
            "            import_errors = session.query(errors.ImportError).order_by(errors.ImportError.id)",
            "",
            "            if (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG) not in user_permissions:",
            "                # if the user doesn't have access to all DAGs, only display errors from visible DAGs",
            "                import_errors = import_errors.join(",
            "                    DagModel, DagModel.fileloc == errors.ImportError.filename",
            "                ).filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "            for import_error in import_errors:",
            "                flash(",
            "                    f\"Broken DAG: [{import_error.filename}] {import_error.stacktrace}\",",
            "                    \"dag_import_error\",",
            "                )",
            "",
            "        from airflow.plugins_manager import import_errors as plugin_import_errors",
            "",
            "        for filename, stacktrace in plugin_import_errors.items():",
            "            flash(",
            "                f\"Broken plugin: [{filename}] {stacktrace}\",",
            "                \"error\",",
            "            )",
            "",
            "        num_of_pages = int(math.ceil(num_of_all_dags / float(dags_per_page)))",
            "",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"null\"] = state_color_mapping.pop(None)",
            "",
            "        page_title = conf.get(section=\"webserver\", key=\"instance_name\", fallback=\"DAGs\")",
            "        page_title_has_markup = conf.getboolean(",
            "            section=\"webserver\", key=\"instance_name_has_markup\", fallback=False",
            "        )",
            "",
            "        dashboard_alerts = [",
            "            fm for fm in settings.DASHBOARD_UIALERTS if fm.should_show(get_airflow_app().appbuilder.sm)",
            "        ]",
            "",
            "        def _iter_parsed_moved_data_table_names():",
            "            for table_name in inspect(session.get_bind()).get_table_names():",
            "                segments = table_name.split(\"__\", 3)",
            "                if len(segments) < 3:",
            "                    continue",
            "                if segments[0] != settings.AIRFLOW_MOVED_TABLE_PREFIX:",
            "                    continue",
            "                # Second segment is a version marker that we don't need to show.",
            "                yield segments[-1], table_name",
            "",
            "        if (",
            "            permissions.ACTION_CAN_ACCESS_MENU,",
            "            permissions.RESOURCE_ADMIN_MENU,",
            "        ) in user_permissions and conf.getboolean(\"webserver\", \"warn_deployment_exposure\"):",
            "            robots_file_access_count = (",
            "                session.query(Log)",
            "                .filter(Log.event == \"robots\")",
            "                .filter(Log.dttm > (utcnow() - datetime.timedelta(days=7)))",
            "                .count()",
            "            )",
            "            if robots_file_access_count > 0:",
            "                flash(",
            "                    Markup(",
            "                        \"Recent requests have been made to /robots.txt. \"",
            "                        \"This indicates that this deployment may be accessible to the public internet. \"",
            "                        \"This warning can be disabled by setting webserver.warn_deployment_exposure=False in \"",
            "                        \"airflow.cfg. Read more about web deployment security <a href=\"",
            "                        f'\"{get_docs_url(\"security/webserver.html\")}\">'",
            "                        \"here</a>\"",
            "                    ),",
            "                    \"warning\",",
            "                )",
            "",
            "        return self.render_template(",
            "            \"airflow/dags.html\",",
            "            dags=dags,",
            "            dashboard_alerts=dashboard_alerts,",
            "            migration_moved_data_alerts=sorted(set(_iter_parsed_moved_data_table_names())),",
            "            current_page=current_page,",
            "            search_query=arg_search_query if arg_search_query else \"\",",
            "            page_title=Markup(page_title) if page_title_has_markup else page_title,",
            "            page_size=dags_per_page,",
            "            num_of_pages=num_of_pages,",
            "            num_dag_from=min(start + 1, num_of_all_dags),",
            "            num_dag_to=min(end, num_of_all_dags),",
            "            num_of_all_dags=num_of_all_dags,",
            "            paging=wwwutils.generate_pages(",
            "                current_page,",
            "                num_of_pages,",
            "                search=escape(arg_search_query) if arg_search_query else None,",
            "                status=arg_status_filter if arg_status_filter else None,",
            "                tags=arg_tags_filter if arg_tags_filter else None,",
            "                sorting_key=arg_sorting_key if arg_sorting_key else None,",
            "                sorting_direction=arg_sorting_direction if arg_sorting_direction else None,",
            "            ),",
            "            num_runs=num_runs,",
            "            tags=tags,",
            "            owner_links=owner_links_dict,",
            "            state_color=state_color_mapping,",
            "            status_filter=arg_status_filter,",
            "            status_count_all=all_dags_count,",
            "            status_count_active=status_count_active,",
            "            status_count_paused=status_count_paused,",
            "            status_count_running=status_count_running,",
            "            status_count_failed=status_count_failed,",
            "            tags_filter=arg_tags_filter,",
            "            sorting_key=arg_sorting_key,",
            "            sorting_direction=arg_sorting_direction,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            dataset_triggered_next_run_info=dataset_triggered_next_run_info,",
            "        )",
            "",
            "    @expose(\"/datasets\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DATASET)])",
            "    def datasets(self):",
            "        \"\"\"Datasets view.\"\"\"",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"null\"] = state_color_mapping.pop(None)",
            "        return self.render_template(",
            "            \"airflow/datasets.html\",",
            "            state_color_mapping=state_color_mapping,",
            "        )",
            "",
            "    @expose(\"/cluster_activity\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CLUSTER_ACTIVITY),",
            "        ]",
            "    )",
            "    def cluster_activity(self):",
            "        \"\"\"Cluster Activity view.\"\"\"",
            "        state_color_mapping = State.state_color.copy()",
            "        state_color_mapping[\"no_status\"] = state_color_mapping.pop(None)",
            "        return self.render_template(",
            "            \"airflow/cluster_activity.html\",",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            state_color_mapping=state_color_mapping,",
            "        )",
            "",
            "    @expose(\"/next_run_datasets_summary\", methods=[\"POST\"])",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    @provide_session",
            "    def next_run_datasets_summary(self, session: Session = NEW_SESSION):",
            "        \"\"\"Next run info for dataset triggered DAGs.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        if not allowed_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        dataset_triggered_dag_ids = [",
            "            dag.dag_id",
            "            for dag in (",
            "                session.query(DagModel.dag_id)",
            "                .filter(DagModel.dag_id.in_(filter_dag_ids))",
            "                .filter(DagModel.schedule_interval == \"Dataset\")",
            "            )",
            "        ]",
            "",
            "        dataset_triggered_next_run_info = get_dataset_triggered_next_run_info(",
            "            dataset_triggered_dag_ids, session=session",
            "        )",
            "",
            "        return flask.json.jsonify(dataset_triggered_next_run_info)",
            "",
            "    @expose(\"/dag_stats\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def dag_stats(self, session: Session = NEW_SESSION):",
            "        \"\"\"Dag statistics.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        dag_state_stats = (",
            "            session.query(DagRun.dag_id, DagRun.state, sqla.func.count(DagRun.state))",
            "            .group_by(DagRun.dag_id, DagRun.state)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))",
            "        )",
            "        dag_state_data = {(dag_id, state): count for dag_id, state, count in dag_state_stats}",
            "",
            "        payload = {",
            "            dag_id: [",
            "                {\"state\": state, \"count\": dag_state_data.get((dag_id, state), 0)}",
            "                for state in State.dag_states",
            "            ]",
            "            for dag_id in filter_dag_ids",
            "        }",
            "        return flask.json.jsonify(payload)",
            "",
            "    @expose(\"/task_stats\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def task_stats(self, session: Session = NEW_SESSION):",
            "        \"\"\"Task Statistics.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        if not allowed_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        running_dag_run_query_result = (",
            "            session.query(DagRun.dag_id, DagRun.run_id)",
            "            .join(DagModel, DagModel.dag_id == DagRun.dag_id)",
            "            .filter(DagRun.state == State.RUNNING, DagModel.is_active)",
            "        )",
            "",
            "        running_dag_run_query_result = running_dag_run_query_result.filter(DagRun.dag_id.in_(filter_dag_ids))",
            "",
            "        running_dag_run_query_result = running_dag_run_query_result.subquery(\"running_dag_run\")",
            "",
            "        # Select all task_instances from active dag_runs.",
            "        running_task_instance_query_result = session.query(",
            "            TaskInstance.dag_id.label(\"dag_id\"),",
            "            TaskInstance.state.label(\"state\"),",
            "            sqla.literal(True).label(\"is_dag_running\"),",
            "        ).join(",
            "            running_dag_run_query_result,",
            "            and_(",
            "                running_dag_run_query_result.c.dag_id == TaskInstance.dag_id,",
            "                running_dag_run_query_result.c.run_id == TaskInstance.run_id,",
            "            ),",
            "        )",
            "",
            "        if conf.getboolean(\"webserver\", \"SHOW_RECENT_STATS_FOR_COMPLETED_RUNS\", fallback=True):",
            "            last_dag_run = (",
            "                session.query(DagRun.dag_id, sqla.func.max(DagRun.execution_date).label(\"execution_date\"))",
            "                .join(DagModel, DagModel.dag_id == DagRun.dag_id)",
            "                .filter(DagRun.state != State.RUNNING, DagModel.is_active)",
            "                .group_by(DagRun.dag_id)",
            "            )",
            "",
            "            last_dag_run = last_dag_run.filter(DagRun.dag_id.in_(filter_dag_ids))",
            "            last_dag_run = last_dag_run.subquery(\"last_dag_run\")",
            "",
            "            # Select all task_instances from active dag_runs.",
            "            # If no dag_run is active, return task instances from most recent dag_run.",
            "            last_task_instance_query_result = (",
            "                session.query(",
            "                    TaskInstance.dag_id.label(\"dag_id\"),",
            "                    TaskInstance.state.label(\"state\"),",
            "                    sqla.literal(False).label(\"is_dag_running\"),",
            "                )",
            "                .join(TaskInstance.dag_run)",
            "                .join(",
            "                    last_dag_run,",
            "                    and_(",
            "                        last_dag_run.c.dag_id == TaskInstance.dag_id,",
            "                        last_dag_run.c.execution_date == DagRun.execution_date,",
            "                    ),",
            "                )",
            "            )",
            "",
            "            final_task_instance_query_result = union_all(",
            "                last_task_instance_query_result, running_task_instance_query_result",
            "            ).alias(\"final_ti\")",
            "        else:",
            "            final_task_instance_query_result = running_task_instance_query_result.subquery(\"final_ti\")",
            "",
            "        qry = (",
            "            session.query(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.state,",
            "                final_task_instance_query_result.c.is_dag_running,",
            "                sqla.func.count(),",
            "            )",
            "            .group_by(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.state,",
            "                final_task_instance_query_result.c.is_dag_running,",
            "            )",
            "            .order_by(",
            "                final_task_instance_query_result.c.dag_id,",
            "                final_task_instance_query_result.c.is_dag_running.desc(),",
            "            )",
            "        )",
            "",
            "        data = get_task_stats_from_query(qry)",
            "        payload: dict[str, list[dict[str, Any]]] = collections.defaultdict(list)",
            "        for dag_id in filter_dag_ids:",
            "            for state in State.task_states:",
            "                count = data.get(dag_id, {}).get(state, 0)",
            "                payload[dag_id].append({\"state\": state, \"count\": count})",
            "        return flask.json.jsonify(payload)",
            "",
            "    @expose(\"/last_dagruns\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def last_dagruns(self, session: Session = NEW_SESSION):",
            "        \"\"\"Last DAG runs.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify({})",
            "",
            "        last_runs_subquery = (",
            "            session.query(",
            "                DagRun.dag_id,",
            "                sqla.func.max(DagRun.execution_date).label(\"max_execution_date\"),",
            "            )",
            "            .group_by(DagRun.dag_id)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))  # Only include accessible/selected DAGs.",
            "            .subquery(\"last_runs\")",
            "        )",
            "",
            "        query = session.query(",
            "            DagRun.dag_id,",
            "            DagRun.start_date,",
            "            DagRun.end_date,",
            "            DagRun.state,",
            "            DagRun.execution_date,",
            "            DagRun.data_interval_start,",
            "            DagRun.data_interval_end,",
            "        ).join(",
            "            last_runs_subquery,",
            "            and_(",
            "                last_runs_subquery.c.dag_id == DagRun.dag_id,",
            "                last_runs_subquery.c.max_execution_date == DagRun.execution_date,",
            "            ),",
            "        )",
            "",
            "        resp = {",
            "            r.dag_id.replace(\".\", \"__dot__\"): {",
            "                \"dag_id\": r.dag_id,",
            "                \"state\": r.state,",
            "                \"execution_date\": wwwutils.datetime_to_string(r.execution_date),",
            "                \"start_date\": wwwutils.datetime_to_string(r.start_date),",
            "                \"end_date\": wwwutils.datetime_to_string(r.end_date),",
            "                \"data_interval_start\": wwwutils.datetime_to_string(r.data_interval_start),",
            "                \"data_interval_end\": wwwutils.datetime_to_string(r.data_interval_end),",
            "            }",
            "            for r in query",
            "        }",
            "        return flask.json.jsonify(resp)",
            "",
            "    @expose(\"/code\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_CODE),",
            "        ]",
            "    )",
            "    def legacy_code(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.code\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/code\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_CODE),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def code(self, dag_id, session: Session = NEW_SESSION):",
            "        \"\"\"Dag Code.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag or not dag_model:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag_model.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag_model.dag_id, session)",
            "",
            "        try:",
            "            code = DagCode.get_code_by_fileloc(dag_model.fileloc)",
            "            html_code = Markup(highlight(code, lexers.PythonLexer(), HtmlFormatter(linenos=True)))",
            "        except Exception as e:",
            "            error = f\"Exception encountered during dag code retrieval/code highlighting:\\n\\n{e}\\n\"",
            "            html_code = Markup(\"<p>Failed to load DAG file Code.</p><p>Details: {}</p>\").format(escape(error))",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_code.html\",",
            "            html_code=html_code,",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            title=dag_id,",
            "            root=request.args.get(\"root\"),",
            "            wrapped=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "        )",
            "",
            "    @expose(\"/dag_details\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    def legacy_dag_details(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.dag_details\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/details\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def dag_details(self, dag_id, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag details.\"\"\"",
            "        from airflow.models.dag import DagOwnerAttributes",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        title = \"DAG Details\"",
            "        root = request.args.get(\"root\", \"\")",
            "",
            "        states = (",
            "            session.query(TaskInstance.state, sqla.func.count(TaskInstance.dag_id))",
            "            .filter(TaskInstance.dag_id == dag_id)",
            "            .group_by(TaskInstance.state)",
            "            .all()",
            "        )",
            "",
            "        active_runs = models.DagRun.find(dag_id=dag_id, state=DagRunState.RUNNING, external_trigger=False)",
            "",
            "        tags = session.query(models.DagTag).filter(models.DagTag.dag_id == dag_id).all()",
            "",
            "        # TODO: convert this to a relationship",
            "        owner_links = session.query(DagOwnerAttributes).filter_by(dag_id=dag_id).all()",
            "",
            "        attrs_to_avoid = [",
            "            \"schedule_datasets\",",
            "            \"schedule_dataset_references\",",
            "            \"task_outlet_dataset_references\",",
            "            \"NUM_DAGS_PER_DAGRUN_QUERY\",",
            "            \"serialized_dag\",",
            "            \"tags\",",
            "            \"default_view\",",
            "            \"relative_fileloc\",",
            "            \"dag_id\",",
            "            \"description\",",
            "            \"max_active_runs\",",
            "            \"max_active_tasks\",",
            "            \"schedule_interval\",",
            "            \"owners\",",
            "            \"dag_owner_links\",",
            "            \"is_paused\",",
            "        ]",
            "        attrs_to_avoid.extend(wwwutils.get_attr_renderer().keys())",
            "        dag_model_attrs: list[tuple[str, Any]] = [",
            "            (attr_name, attr)",
            "            for attr_name, attr in (",
            "                (attr_name, getattr(dag_model, attr_name))",
            "                for attr_name in dir(dag_model)",
            "                if not attr_name.startswith(\"_\") and attr_name not in attrs_to_avoid",
            "            )",
            "            if not callable(attr)",
            "        ]",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_details.html\",",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            title=title,",
            "            root=root,",
            "            states=states,",
            "            State=State,",
            "            active_runs=active_runs,",
            "            tags=tags,",
            "            owner_links=owner_links,",
            "            dag_model_attrs=dag_model_attrs,",
            "        )",
            "",
            "    @expose(\"/rendered-templates\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def rendered_templates(self, session):",
            "        \"\"\"Get rendered Dag.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "",
            "        logging.info(\"Retrieving rendered templates.\")",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dag_run = dag.get_dagrun(execution_date=dttm, session=session)",
            "        raw_task = dag.get_task(task_id).prepare_for_execution()",
            "",
            "        title = \"Rendered Template\"",
            "        html_dict = {}",
            "",
            "        ti: TaskInstance",
            "        if dag_run is None:",
            "            # No DAG run matching given logical date. This usually means this",
            "            # DAG has never been run. Task instance rendering does not really",
            "            # make sense in this situation, but \"works\" prior to AIP-39. This",
            "            # \"fakes\" a temporary DagRun-TaskInstance association (not saved to",
            "            # database) for presentation only.",
            "            ti = TaskInstance(raw_task, map_index=map_index)",
            "            ti.dag_run = DagRun(dag_id=dag_id, execution_date=dttm)",
            "        else:",
            "            ti = dag_run.get_task_instance(task_id=task_id, map_index=map_index, session=session)",
            "            if ti:",
            "                ti.refresh_from_task(raw_task)",
            "            else:",
            "                flash(f\"there is no task instance with the provided map_index {map_index}\", \"error\")",
            "                return self.render_template(",
            "                    \"airflow/ti_code.html\",",
            "                    html_dict=html_dict,",
            "                    dag=dag,",
            "                    task_id=task_id,",
            "                    execution_date=execution_date,",
            "                    map_index=map_index,",
            "                    form=form,",
            "                    root=root,",
            "                    title=title,",
            "                )",
            "",
            "        try:",
            "            ti.get_rendered_template_fields(session=session)",
            "        except AirflowException as e:",
            "            if not e.__cause__:",
            "                flash(f\"Error rendering template: {e}\", \"error\")",
            "            else:",
            "                msg = Markup(\"Error rendering template: {0}<br><br>OriginalError: {0.__cause__}\").format(e)",
            "                flash(msg, \"error\")",
            "        except Exception as e:",
            "            flash(f\"Error rendering template: {e}\", \"error\")",
            "",
            "        # Ensure we are rendering the unmapped operator. Unmapping should be",
            "        # done automatically if template fields are rendered successfully; this",
            "        # only matters if get_rendered_template_fields() raised an exception.",
            "        # The following rendering won't show useful values in this case anyway,",
            "        # but we'll display some quasi-meaingful field names.",
            "        task = ti.task.unmap(None)",
            "",
            "        renderers = wwwutils.get_attr_renderer()",
            "",
            "        for template_field in task.template_fields:",
            "            content = getattr(task, template_field)",
            "            renderer = task.template_fields_renderers.get(template_field, template_field)",
            "            if renderer in renderers:",
            "                if isinstance(content, (dict, list)):",
            "                    json_content = json.dumps(content, sort_keys=True, indent=4)",
            "                    html_dict[template_field] = renderers[renderer](json_content)",
            "                else:",
            "                    html_dict[template_field] = renderers[renderer](content)",
            "            else:",
            "                html_dict[template_field] = Markup(\"<pre><code>{}</pre></code>\").format(pformat(content))",
            "",
            "            if isinstance(content, dict):",
            "                if template_field == \"op_kwargs\":",
            "                    for key, value in content.items():",
            "                        renderer = task.template_fields_renderers.get(key, key)",
            "                        if renderer in renderers:",
            "                            html_dict[\".\".join([template_field, key])] = renderers[renderer](value)",
            "                        else:",
            "                            html_dict[\".\".join([template_field, key])] = Markup(",
            "                                \"<pre><code>{}</pre></code>\"",
            "                            ).format(pformat(value))",
            "                else:",
            "                    for dict_keys in get_key_paths(content):",
            "                        template_path = \".\".join((template_field, dict_keys))",
            "                        renderer = task.template_fields_renderers.get(template_path, template_path)",
            "                        if renderer in renderers:",
            "                            content_value = get_value_from_path(dict_keys, content)",
            "                            html_dict[template_path] = renderers[renderer](content_value)",
            "",
            "        return self.render_template(",
            "            \"airflow/ti_code.html\",",
            "            html_dict=html_dict,",
            "            dag=dag,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/rendered-k8s\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def rendered_k8s(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Get rendered k8s yaml.\"\"\"",
            "        if not settings.IS_K8S_OR_K8SCELERY_EXECUTOR:",
            "            abort(404)",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        if task_id is None:",
            "            logging.warning(\"Task id not passed in the request\")",
            "            abort(400)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        logging.info(\"Retrieving rendered templates.\")",
            "",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        task = dag.get_task(task_id)",
            "        dag_run = dag.get_dagrun(execution_date=dttm, session=session)",
            "        ti = dag_run.get_task_instance(task_id=task.task_id, map_index=map_index, session=session)",
            "",
            "        pod_spec = None",
            "        try:",
            "            pod_spec = ti.get_rendered_k8s_spec(session=session)",
            "        except AirflowException as e:",
            "            if not e.__cause__:",
            "                flash(f\"Error rendering Kubernetes POD Spec: {e}\", \"error\")",
            "            else:",
            "                tmp = Markup(\"Error rendering Kubernetes POD Spec: {0}<br><br>Original error: {0.__cause__}\")",
            "                flash(tmp.format(e), \"error\")",
            "        except Exception as e:",
            "            flash(f\"Error rendering Kubernetes Pod Spec: {e}\", \"error\")",
            "        title = \"Rendered K8s Pod Spec\"",
            "",
            "        if pod_spec:",
            "            content = wwwutils.get_attr_renderer()[\"yaml\"](yaml.dump(pod_spec))",
            "        else:",
            "            content = Markup(\"<pre><code>Error rendering Kubernetes POD Spec</pre></code>\")",
            "",
            "        return self.render_template(",
            "            \"airflow/ti_code.html\",",
            "            html_dict={\"k8s\": content},",
            "            dag=dag,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/get_logs_with_metadata\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def get_logs_with_metadata(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve logs including metadata.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date_str = request.args[\"execution_date\"]",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        try_number = request.args.get(\"try_number\", type=int)",
            "        metadata_str = request.args.get(\"metadata\", \"{}\")",
            "        response_format = request.args.get(\"format\", \"json\")",
            "",
            "        # Validate JSON metadata",
            "        try:",
            "            metadata: dict = json.loads(metadata_str) or {}",
            "        except json.decoder.JSONDecodeError:",
            "            return {\"error\": \"Invalid JSON metadata\"}, 400",
            "",
            "        # Convert string datetime into actual datetime",
            "        try:",
            "            execution_date = timezone.parse(execution_date_str)",
            "        except ValueError:",
            "            error_message = (",
            "                f\"Given execution date, {execution_date}, could not be identified as a date. \"",
            "                \"Example date format: 2015-11-16T14:34:15+00:00\"",
            "            )",
            "            return {\"error\": error_message}, 400",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if not task_log_reader.supports_read:",
            "            return {",
            "                \"message\": \"Task log handler does not support read logs.\",",
            "                \"error\": True,",
            "                \"metadata\": {\"end_of_log\": True},",
            "            }",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter(",
            "                TaskInstance.task_id == task_id,",
            "                TaskInstance.dag_id == dag_id,",
            "                TaskInstance.execution_date == execution_date,",
            "                TaskInstance.map_index == map_index,",
            "            )",
            "            .join(TaskInstance.dag_run)",
            "            .options(joinedload(\"trigger\"))",
            "            .options(joinedload(\"trigger.triggerer_job\"))",
            "            .first()",
            "        )",
            "",
            "        if ti is None:",
            "            return {",
            "                \"message\": \"*** Task instance did not exist in the DB\\n\",",
            "                \"error\": True,",
            "                \"metadata\": {\"end_of_log\": True},",
            "            }",
            "",
            "        try:",
            "            dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "            if dag:",
            "                ti.task = dag.get_task(ti.task_id)",
            "",
            "            if response_format == \"json\":",
            "                logs, metadata = task_log_reader.read_log_chunks(ti, try_number, metadata)",
            "                message = logs[0] if try_number is not None else logs",
            "                return {\"message\": message, \"metadata\": metadata}",
            "",
            "            metadata[\"download_logs\"] = True",
            "            attachment_filename = task_log_reader.render_log_filename(ti, try_number, session=session)",
            "            log_stream = task_log_reader.read_log_stream(ti, try_number, metadata)",
            "            return Response(",
            "                response=log_stream,",
            "                mimetype=\"text/plain\",",
            "                headers={\"Content-Disposition\": f\"attachment; filename={attachment_filename}\"},",
            "            )",
            "        except AttributeError as e:",
            "            error_messages = [f\"Task log handler does not support read logs.\\n{str(e)}\\n\"]",
            "            metadata[\"end_of_log\"] = True",
            "            return {\"message\": error_messages, \"error\": True, \"metadata\": metadata}",
            "",
            "    @expose(\"/log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def log(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve log.\"\"\"",
            "        dag_id = request.args[\"dag_id\"]",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "",
            "        if execution_date:",
            "            dttm = _safe_parse_datetime(execution_date)",
            "        else:",
            "            dttm = None",
            "",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        dag_model = DagModel.get_dagmodel(dag_id)",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .first()",
            "        )",
            "",
            "        num_logs = 0",
            "        if ti is not None:",
            "            num_logs = wwwutils.get_try_count(ti._try_number, ti.state)",
            "        logs = [\"\"] * num_logs",
            "        root = request.args.get(\"root\", \"\")",
            "        return self.render_template(",
            "            \"airflow/ti_log.html\",",
            "            logs=logs,",
            "            dag=dag_model,",
            "            title=\"Log by attempts\",",
            "            dag_id=dag_id,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            wrapped=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "        )",
            "",
            "    @expose(\"/redirect_to_external_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def redirect_to_external_log(self, session: Session = NEW_SESSION):",
            "        \"\"\"Redirects to external log.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        try_number = request.args.get(\"try_number\", 1)",
            "",
            "        ti = (",
            "            session.query(models.TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .first()",
            "        )",
            "",
            "        if not ti:",
            "            flash(f\"Task [{dag_id}.{task_id}] does not exist\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if not task_log_reader.supports_external_link:",
            "            flash(\"Task log handler does not support external links\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        handler = task_log_reader.log_handler",
            "        url = handler.get_external_log_url(ti, try_number)",
            "        return redirect(url)",
            "",
            "    @expose(\"/task\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def task(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve task.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag or task_id not in dag.task_ids:",
            "            flash(f\"Task [{dag_id}.{task_id}] doesn't seem to exist at the moment\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "        task = copy.copy(dag.get_task(task_id))",
            "        task.resolve_template_files()",
            "",
            "        ti: TaskInstance | None = (",
            "            session.query(TaskInstance)",
            "            .options(",
            "                # HACK: Eager-load relationships. This is needed because",
            "                # multiple properties mis-use provide_session() that destroys",
            "                # the session object ti is bounded to.",
            "                joinedload(TaskInstance.queued_by_job, innerjoin=False),",
            "                joinedload(TaskInstance.trigger, innerjoin=False),",
            "            )",
            "            .filter_by(execution_date=dttm, dag_id=dag_id, task_id=task_id, map_index=map_index)",
            "            .one_or_none()",
            "        )",
            "        if ti is None:",
            "            ti_attrs: list[tuple[str, Any]] | None = None",
            "        else:",
            "            ti.refresh_from_task(task)",
            "            ti_attrs_to_skip = [",
            "                \"dag_id\",",
            "                \"key\",",
            "                \"mark_success_url\",",
            "                \"log\",",
            "                \"log_url\",",
            "                \"task\",",
            "                \"trigger\",",
            "                \"triggerer_job\",",
            "            ]",
            "            # Some fields on TI are deprecated, but we don't want those warnings here.",
            "            with warnings.catch_warnings():",
            "                warnings.simplefilter(\"ignore\", RemovedInAirflow3Warning)",
            "                all_ti_attrs = (",
            "                    (name, getattr(ti, name))",
            "                    for name in dir(ti)",
            "                    if not name.startswith(\"_\") and name not in ti_attrs_to_skip",
            "                )",
            "            ti_attrs = sorted((name, attr) for name, attr in all_ti_attrs if not callable(attr))",
            "",
            "        attr_renderers = wwwutils.get_attr_renderer()",
            "",
            "        attrs_to_skip: frozenset[str] = getattr(task, \"HIDE_ATTRS_FROM_UI\", frozenset())",
            "",
            "        def include_task_attrs(attr_name):",
            "            return not (",
            "                attr_name == \"HIDE_ATTRS_FROM_UI\"",
            "                or attr_name.startswith(\"_\")",
            "                or attr_name in attr_renderers",
            "                or attr_name in attrs_to_skip",
            "            )",
            "",
            "        task_attrs = [",
            "            (attr_name, secrets_masker.redact(attr, attr_name))",
            "            for attr_name, attr in (",
            "                (attr_name, getattr(task, attr_name)) for attr_name in filter(include_task_attrs, dir(task))",
            "            )",
            "            if not callable(attr)",
            "        ]",
            "",
            "        # Color coding the special attributes that are code",
            "        special_attrs_rendered = {",
            "            attr_name: renderer(getattr(task, attr_name))",
            "            for attr_name, renderer in attr_renderers.items()",
            "            if hasattr(task, attr_name)",
            "        }",
            "",
            "        no_failed_deps_result = [",
            "            (",
            "                \"Unknown\",",
            "                \"All dependencies are met but the task instance is not running. In most \"",
            "                \"cases this just means that the task will probably be scheduled soon \"",
            "                \"unless:<br>\\n- The scheduler is down or under heavy load<br>\\n{}\\n\"",
            "                \"<br>\\nIf this task instance does not start soon please contact your \"",
            "                \"Airflow administrator for assistance.\".format(",
            "                    \"- This task instance already ran and had it's state changed manually \"",
            "                    \"(e.g. cleared in the UI)<br>\"",
            "                    if ti and ti.state == State.NONE",
            "                    else \"\"",
            "                ),",
            "            )",
            "        ]",
            "",
            "        # Use the scheduler's context to figure out which dependencies are not met",
            "        if ti is None:",
            "            failed_dep_reasons: list[tuple[str, str]] = []",
            "        else:",
            "            dep_context = DepContext(SCHEDULER_QUEUED_DEPS)",
            "            failed_dep_reasons = [",
            "                (dep.dep_name, dep.reason) for dep in ti.get_failed_dep_statuses(dep_context=dep_context)",
            "            ]",
            "",
            "        title = \"Task Instance Details\"",
            "        return self.render_template(",
            "            \"airflow/task.html\",",
            "            task_attrs=task_attrs,",
            "            ti_attrs=ti_attrs,",
            "            failed_dep_reasons=failed_dep_reasons or no_failed_deps_result,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            special_attrs_rendered=special_attrs_rendered,",
            "            form=form,",
            "            root=root,",
            "            dag=dag,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/xcom\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_XCOM),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def xcom(self, session: Session = NEW_SESSION):",
            "        \"\"\"Retrieve XCOM.\"\"\"",
            "        dag_id = request.args[\"dag_id\"]",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        # Carrying execution_date through, even though it's irrelevant for",
            "        # this context",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "",
            "        form = DateTimeForm(data={\"execution_date\": dttm})",
            "        root = request.args.get(\"root\", \"\")",
            "        dag = DagModel.get_dagmodel(dag_id)",
            "        ti = session.query(TaskInstance).filter_by(dag_id=dag_id, task_id=task_id).first()",
            "",
            "        if not ti:",
            "            flash(f\"Task [{dag_id}.{task_id}] doesn't seem to exist at the moment\", \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        xcom_query = session.query(XCom.key, XCom.value).filter(",
            "            XCom.dag_id == dag_id,",
            "            XCom.task_id == task_id,",
            "            XCom.execution_date == dttm,",
            "            XCom.map_index == map_index,",
            "        )",
            "        attributes = [(k, v) for k, v in xcom_query if not k.startswith(\"_\")]",
            "",
            "        title = \"XCom\"",
            "        return self.render_template(",
            "            \"airflow/xcom.html\",",
            "            attributes=attributes,",
            "            task_id=task_id,",
            "            execution_date=execution_date,",
            "            map_index=map_index,",
            "            form=form,",
            "            root=root,",
            "            dag=dag,",
            "            title=title,",
            "        )",
            "",
            "    @expose(\"/delete\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def delete(self):",
            "        \"\"\"Deletes DAG.\"\"\"",
            "        from airflow.api.common import delete_dag",
            "        from airflow.exceptions import DagNotFound",
            "",
            "        dag_id = request.values.get(\"dag_id\")",
            "        origin = get_safe_url(request.values.get(\"origin\"))",
            "        redirect_url = get_safe_url(request.values.get(\"redirect_url\"))",
            "",
            "        try:",
            "            delete_dag.delete_dag(dag_id)",
            "        except DagNotFound:",
            "            flash(f\"DAG with id {dag_id} not found. Cannot delete\", \"error\")",
            "            return redirect(redirect_url)",
            "        except AirflowException:",
            "            flash(",
            "                f\"Cannot delete DAG with id {dag_id} because some task instances of the DAG \"",
            "                \"are still running. Please mark the  task instances as \"",
            "                \"failed/succeeded before deleting the DAG\",",
            "                \"error\",",
            "            )",
            "            return redirect(redirect_url)",
            "",
            "        flash(f\"Deleting DAG with id {dag_id}. May take a couple minutes to fully disappear.\")",
            "",
            "        # Upon success return to origin.",
            "        return redirect(origin)",
            "",
            "    @expose(\"/dags/<string:dag_id>/trigger\", methods=[\"POST\", \"GET\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_CREATE, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def trigger(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Triggers DAG Run.\"\"\"",
            "        run_id = request.values.get(\"run_id\", \"\").replace(\" \", \"+\")",
            "        origin = get_safe_url(request.values.get(\"origin\"))",
            "        unpause = request.values.get(\"unpause\")",
            "        request_conf = request.values.get(\"conf\")",
            "        request_execution_date = request.values.get(\"execution_date\", default=timezone.utcnow().isoformat())",
            "        is_dag_run_conf_overrides_params = conf.getboolean(\"core\", \"dag_run_conf_overrides_params\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dag_orm: DagModel = session.query(DagModel).filter(DagModel.dag_id == dag_id).first()",
            "",
            "        # Prepare form fields with param struct details to render a proper form with schema information",
            "        form_fields = {}",
            "        for k, v in dag.params.items():",
            "            form_fields[k] = v.dump()",
            "            # If no schema is provided, auto-detect on default values",
            "            if \"schema\" not in form_fields[k]:",
            "                form_fields[k][\"schema\"] = {}",
            "            if \"type\" not in form_fields[k][\"schema\"]:",
            "                if isinstance(form_fields[k][\"value\"], bool):",
            "                    form_fields[k][\"schema\"][\"type\"] = \"boolean\"",
            "                elif isinstance(form_fields[k][\"value\"], int):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"integer\", \"null\"]",
            "                elif isinstance(form_fields[k][\"value\"], list):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"array\", \"null\"]",
            "                elif isinstance(form_fields[k][\"value\"], dict):",
            "                    form_fields[k][\"schema\"][\"type\"] = [\"object\", \"null\"]",
            "            # Mark markup fields as safe",
            "            if (",
            "                \"description_html\" in form_fields[k][\"schema\"]",
            "                and form_fields[k][\"schema\"][\"description_html\"]",
            "            ):",
            "                form_fields[k][\"description\"] = Markup(form_fields[k][\"schema\"][\"description_html\"])",
            "            if \"custom_html_form\" in form_fields[k][\"schema\"]:",
            "                form_fields[k][\"schema\"][\"custom_html_form\"] = Markup(",
            "                    form_fields[k][\"schema\"][\"custom_html_form\"]",
            "                )",
            "        ui_fields_defined = any(\"const\" not in f[\"schema\"] for f in form_fields.values())",
            "",
            "        if not dag_orm:",
            "            flash(f\"Cannot find dag {dag_id}\")",
            "            return redirect(origin)",
            "",
            "        if dag_orm.has_import_errors:",
            "            flash(f\"Cannot create dagruns because the dag {dag_id} has import errors\", \"error\")",
            "            return redirect(origin)",
            "",
            "        recent_runs = (",
            "            session.query(",
            "                DagRun.conf, func.max(DagRun.run_id).label(\"run_id\"), func.max(DagRun.execution_date)",
            "            )",
            "            .filter(",
            "                DagRun.dag_id == dag_id,",
            "                DagRun.run_type == DagRunType.MANUAL,",
            "                DagRun.conf.isnot(None),",
            "            )",
            "            .group_by(DagRun.conf)",
            "            .order_by(func.max(DagRun.execution_date).desc())",
            "            .limit(5)",
            "        )",
            "        recent_confs = {",
            "            run_id: json.dumps(run_conf)",
            "            for run_id, run_conf in ((run.run_id, run.conf) for run in recent_runs)",
            "            if isinstance(run_conf, dict) and any(run_conf)",
            "        }",
            "",
            "        if request.method == \"GET\" and ui_fields_defined:",
            "            # Populate conf textarea with conf requests parameter, or dag.params",
            "            default_conf = \"\"",
            "",
            "            doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "            form = DateTimeForm(data={\"execution_date\": request_execution_date})",
            "",
            "            if request_conf:",
            "                default_conf = request_conf",
            "            else:",
            "                try:",
            "                    default_conf = json.dumps(",
            "                        {str(k): v.resolve(suppress_exception=True) for k, v in dag.params.items()},",
            "                        indent=4,",
            "                        ensure_ascii=False,",
            "                    )",
            "                except TypeError:",
            "                    flash(\"Could not pre-populate conf field due to non-JSON-serializable data-types\")",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=default_conf,",
            "                doc_md=doc_md,",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                recent_confs=recent_confs,",
            "            )",
            "",
            "        try:",
            "            execution_date = timezone.parse(request_execution_date)",
            "        except ParserError:",
            "            flash(\"Invalid execution date\", \"error\")",
            "            form = DateTimeForm(data={\"execution_date\": timezone.utcnow().isoformat()})",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=request_conf if request_conf else {},",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                recent_confs=recent_confs,",
            "            )",
            "",
            "        dr = DagRun.find_duplicate(dag_id=dag_id, run_id=run_id, execution_date=execution_date)",
            "        if dr:",
            "            if dr.run_id == run_id:",
            "                message = f\"The run ID {run_id} already exists\"",
            "            else:",
            "                message = f\"The logical date {execution_date} already exists\"",
            "            flash(message, \"error\")",
            "            return redirect(origin)",
            "",
            "        regex = conf.get(\"scheduler\", \"allowed_run_id_pattern\")",
            "        if run_id and not re.match(RUN_ID_REGEX, run_id):",
            "            if not regex.strip() or not re.match(regex.strip(), run_id):",
            "                flash(",
            "                    f\"The provided run ID '{run_id}' is invalid. It does not match either \"",
            "                    f\"the configured pattern: '{regex}' or the built-in pattern: '{RUN_ID_REGEX}'\",",
            "                    \"error\",",
            "                )",
            "",
            "                form = DateTimeForm(data={\"execution_date\": execution_date})",
            "                return self.render_template(",
            "                    \"airflow/trigger.html\",",
            "                    form_fields=form_fields,",
            "                    dag=dag,",
            "                    dag_id=dag_id,",
            "                    origin=origin,",
            "                    conf=request_conf,",
            "                    form=form,",
            "                    is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                    recent_confs=recent_confs,",
            "                )",
            "",
            "        run_conf = {}",
            "        if request_conf:",
            "            try:",
            "                run_conf = json.loads(request_conf)",
            "                if not isinstance(run_conf, dict):",
            "                    flash(\"Invalid JSON configuration, must be a dict\", \"error\")",
            "                    form = DateTimeForm(data={\"execution_date\": execution_date})",
            "                    return self.render_template(",
            "                        \"airflow/trigger.html\",",
            "                        form_fields=form_fields,",
            "                        dag=dag,",
            "                        dag_id=dag_id,",
            "                        origin=origin,",
            "                        conf=request_conf,",
            "                        form=form,",
            "                        is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                        recent_confs=recent_confs,",
            "                    )",
            "            except json.decoder.JSONDecodeError:",
            "                flash(\"Invalid JSON configuration, not parseable\", \"error\")",
            "                form = DateTimeForm(data={\"execution_date\": execution_date})",
            "                return self.render_template(",
            "                    \"airflow/trigger.html\",",
            "                    form_fields=form_fields,",
            "                    dag=dag,",
            "                    dag_id=dag_id,",
            "                    origin=origin,",
            "                    conf=request_conf,",
            "                    form=form,",
            "                    is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "                    recent_confs=recent_confs,",
            "                )",
            "",
            "        if unpause and dag.get_is_paused():",
            "            dag_model = models.DagModel.get_dagmodel(dag_id)",
            "            if dag_model is not None:",
            "                dag_model.set_is_paused(is_paused=False)",
            "",
            "        try:",
            "            dag.create_dagrun(",
            "                run_type=DagRunType.MANUAL,",
            "                execution_date=execution_date,",
            "                data_interval=dag.timetable.infer_manual_data_interval(run_after=execution_date),",
            "                state=State.QUEUED,",
            "                conf=run_conf,",
            "                external_trigger=True,",
            "                dag_hash=get_airflow_app().dag_bag.dags_hash.get(dag_id),",
            "                run_id=run_id,",
            "            )",
            "        except (ValueError, ParamValidationError) as ve:",
            "            flash(f\"{ve}\", \"error\")",
            "            form = DateTimeForm(data={\"execution_date\": execution_date})",
            "            # Take over \"bad\" submitted fields for new form display",
            "            for k, v in form_fields.items():",
            "                form_fields[k][\"value\"] = run_conf[k]",
            "            return self.render_template(",
            "                \"airflow/trigger.html\",",
            "                form_fields=form_fields,",
            "                dag=dag,",
            "                dag_id=dag_id,",
            "                origin=origin,",
            "                conf=request_conf,",
            "                form=form,",
            "                is_dag_run_conf_overrides_params=is_dag_run_conf_overrides_params,",
            "            )",
            "",
            "        flash(f\"Triggered {dag_id}, it should start any moment now.\")",
            "        return redirect(origin)",
            "",
            "    def _clear_dag_tis(",
            "        self,",
            "        dag: DAG,",
            "        start_date: datetime.datetime | None,",
            "        end_date: datetime.datetime | None,",
            "        *,",
            "        origin: str | None,",
            "        task_ids: Collection[str | tuple[str, int]] | None = None,",
            "        recursive: bool = False,",
            "        confirmed: bool = False,",
            "        only_failed: bool = False,",
            "        session: Session,",
            "    ):",
            "        if confirmed:",
            "            count = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                task_ids=task_ids,",
            "                include_subdags=recursive,",
            "                include_parentdag=recursive,",
            "                only_failed=only_failed,",
            "                session=session,",
            "            )",
            "",
            "            msg = f\"{count} task instances have been cleared\"",
            "            return redirect_or_json(origin, msg)",
            "",
            "        try:",
            "            tis = dag.clear(",
            "                start_date=start_date,",
            "                end_date=end_date,",
            "                task_ids=task_ids,",
            "                include_subdags=recursive,",
            "                include_parentdag=recursive,",
            "                only_failed=only_failed,",
            "                dry_run=True,",
            "                session=session,",
            "            )",
            "        except AirflowException as ex:",
            "            return redirect_or_json(origin, msg=str(ex), status=\"error\", status_code=500)",
            "",
            "        assert isinstance(tis, collections.abc.Iterable)",
            "        details = [str(t) for t in tis]",
            "",
            "        if not details:",
            "            return redirect_or_json(origin, \"No task instances to clear\", status=\"error\", status_code=404)",
            "        elif request.headers.get(\"Accept\") == \"application/json\":",
            "            if confirmed:",
            "                return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "            return htmlsafe_json_dumps(",
            "                [{\"task_id\": ti.task_id, \"map_index\": ti.map_index, \"run_id\": ti.run_id} for ti in tis],",
            "                separators=(\",\", \":\"),",
            "            )",
            "        return self.render_template(",
            "            \"airflow/confirm.html\",",
            "            endpoint=None,",
            "            message=\"Task instances you are about to clear:\",",
            "            details=\"\\n\".join(details),",
            "        )",
            "",
            "    @expose(\"/clear\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def clear(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Clears DAG tasks.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        task_id = request.form.get(\"task_id\")",
            "        origin = get_safe_url(request.form.get(\"origin\"))",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        group_id = request.form.get(\"group_id\")",
            "",
            "        if \"map_index\" not in request.form:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = request.form.getlist(\"map_index\", type=int)",
            "",
            "        execution_date_str = request.form.get(\"execution_date\")",
            "        execution_date = _safe_parse_datetime(execution_date_str)",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        upstream = request.form.get(\"upstream\") == \"true\"",
            "        downstream = request.form.get(\"downstream\") == \"true\"",
            "        future = request.form.get(\"future\") == \"true\"",
            "        past = request.form.get(\"past\") == \"true\"",
            "        recursive = request.form.get(\"recursive\") == \"true\"",
            "        only_failed = request.form.get(\"only_failed\") == \"true\"",
            "",
            "        task_ids: list[str | tuple[str, int]] = []",
            "",
            "        end_date = execution_date if not future else None",
            "        start_date = execution_date if not past else None",
            "",
            "        locked_dag_run_ids: list[int] = []",
            "",
            "        if group_id is not None:",
            "            task_group_dict = dag.task_group.get_task_group_dict()",
            "            task_group = task_group_dict.get(group_id)",
            "            if task_group is None:",
            "                return redirect_or_json(",
            "                    origin, msg=f\"TaskGroup {group_id} could not be found\", status=\"error\", status_code=404",
            "                )",
            "            task_ids = task_ids_or_regex = [t.task_id for t in task_group.iter_tasks()]",
            "",
            "            # Lock the related dag runs to prevent from possible dead lock.",
            "            # https://github.com/apache/airflow/pull/26658",
            "            dag_runs_query = session.query(DagRun.id).filter(DagRun.dag_id == dag_id).with_for_update()",
            "            if start_date is None and end_date is None:",
            "                dag_runs_query = dag_runs_query.filter(DagRun.execution_date == start_date)",
            "            else:",
            "                if start_date is not None:",
            "                    dag_runs_query = dag_runs_query.filter(DagRun.execution_date >= start_date)",
            "",
            "                if end_date is not None:",
            "                    dag_runs_query = dag_runs_query.filter(DagRun.execution_date <= end_date)",
            "",
            "            locked_dag_run_ids = dag_runs_query.all()",
            "        elif task_id:",
            "            if map_indexes is None:",
            "                task_ids = [task_id]",
            "            else:",
            "                task_ids = [(task_id, map_index) for map_index in map_indexes]",
            "            task_ids_or_regex = [task_id]",
            "",
            "        dag = dag.partial_subset(",
            "            task_ids_or_regex=task_ids_or_regex,",
            "            include_downstream=downstream,",
            "            include_upstream=upstream,",
            "        )",
            "",
            "        if len(dag.task_dict) > 1:",
            "            # If we had upstream/downstream etc then also include those!",
            "            task_ids.extend(tid for tid in dag.task_dict if tid != task_id)",
            "",
            "        response = self._clear_dag_tis(",
            "            dag,",
            "            start_date,",
            "            end_date,",
            "            origin=origin,",
            "            task_ids=task_ids,",
            "            recursive=recursive,",
            "            confirmed=confirmed,",
            "            only_failed=only_failed,",
            "            session=session,",
            "        )",
            "",
            "        del locked_dag_run_ids",
            "",
            "        return response",
            "",
            "    @expose(\"/dagrun_clear\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_DELETE, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def dagrun_clear(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"Clears the DagRun.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        dr = dag.get_dagrun(run_id=dag_run_id)",
            "        start_date = dr.logical_date",
            "        end_date = dr.logical_date",
            "",
            "        return self._clear_dag_tis(",
            "            dag,",
            "            start_date,",
            "            end_date,",
            "            origin=None,",
            "            recursive=True,",
            "            confirmed=confirmed,",
            "            session=session,",
            "        )",
            "",
            "    @expose(\"/blocked\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def blocked(self, session: Session = NEW_SESSION):",
            "        \"\"\"Mark Dag Blocked.\"\"\"",
            "        allowed_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        # Filter by post parameters",
            "        selected_dag_ids = {unquote(dag_id) for dag_id in request.form.getlist(\"dag_ids\") if dag_id}",
            "",
            "        if selected_dag_ids:",
            "            filter_dag_ids = selected_dag_ids.intersection(allowed_dag_ids)",
            "        else:",
            "            filter_dag_ids = allowed_dag_ids",
            "",
            "        if not filter_dag_ids:",
            "            return flask.json.jsonify([])",
            "",
            "        dags = (",
            "            session.query(DagRun.dag_id, sqla.func.count(DagRun.id))",
            "            .filter(DagRun.state == DagRunState.RUNNING)",
            "            .filter(DagRun.dag_id.in_(filter_dag_ids))",
            "            .group_by(DagRun.dag_id)",
            "        )",
            "",
            "        payload = []",
            "        for dag_id, active_dag_runs in dags:",
            "            max_active_runs = 0",
            "            dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "            if dag:",
            "                # TODO: Make max_active_runs a column so we can query for it directly",
            "                max_active_runs = dag.max_active_runs",
            "            payload.append(",
            "                {",
            "                    \"dag_id\": dag_id,",
            "                    \"active_dag_run\": active_dag_runs,",
            "                    \"max_active_runs\": max_active_runs,",
            "                }",
            "            )",
            "        return flask.json.jsonify(payload)",
            "",
            "    def _mark_dagrun_state_as_failed(self, dag_id, dag_run_id, confirmed):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        new_dag_state = set_dag_run_state_to_failed(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": f\"Marked failed on {len(new_dag_state)} task instances\"}",
            "        else:",
            "            details = [str(t) for t in new_dag_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    def _mark_dagrun_state_as_success(self, dag_id, dag_run_id, confirmed):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        new_dag_state = set_dag_run_state_to_success(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": f\"Marked success on {len(new_dag_state)} task instances\"}",
            "        else:",
            "            details = [str(t) for t in new_dag_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    @provide_session",
            "    def _mark_dagrun_state_as_queued(",
            "        self,",
            "        dag_id: str,",
            "        dag_run_id: str,",
            "        confirmed: bool,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        if not dag_run_id:",
            "            return {\"status\": \"error\", \"message\": \"Invalid dag_run_id\"}",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"status\": \"error\", \"message\": f\"Cannot find DAG: {dag_id}\"}",
            "",
            "        set_dag_run_state_to_queued(dag=dag, run_id=dag_run_id, commit=confirmed)",
            "",
            "        if confirmed:",
            "            return {\"status\": \"success\", \"message\": \"Marked the DagRun as queued.\"}",
            "",
            "        else:",
            "            # Identify tasks that will be queued up to run when confirmed",
            "            all_task_ids = [task.task_id for task in dag.tasks]",
            "",
            "            existing_tis = session.query(TaskInstance.task_id).filter(",
            "                TaskInstance.dag_id == dag.dag_id,",
            "                TaskInstance.run_id == dag_run_id,",
            "            )",
            "",
            "            completed_tis_ids = [task_id for task_id, in existing_tis]",
            "            tasks_with_no_state = list(set(all_task_ids) - set(completed_tis_ids))",
            "            details = [str(t) for t in tasks_with_no_state]",
            "",
            "            return htmlsafe_json_dumps(details, separators=(\",\", \":\"))",
            "",
            "    @expose(\"/dagrun_failed\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_failed(self):",
            "        \"\"\"Mark DagRun failed.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_failed(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_success\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_success(self):",
            "        \"\"\"Mark DagRun success.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_success(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_queued\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG_RUN),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def dagrun_queued(self):",
            "        \"\"\"Queue DagRun so tasks that haven't run yet can be started.\"\"\"",
            "        dag_id = request.form.get(\"dag_id\")",
            "        dag_run_id = request.form.get(\"dag_run_id\")",
            "        confirmed = request.form.get(\"confirmed\") == \"true\"",
            "        return self._mark_dagrun_state_as_queued(dag_id, dag_run_id, confirmed)",
            "",
            "    @expose(\"/dagrun_details\")",
            "    def dagrun_details(self):",
            "        \"\"\"Redirect to the GRID DAGRun page. This is avoids breaking links.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        run_id = request.args.get(\"run_id\")",
            "        return redirect(url_for(\"Airflow.grid\", dag_id=dag_id, dag_run_id=run_id))",
            "",
            "    def _mark_task_instance_state(",
            "        self,",
            "        *,",
            "        dag_id: str,",
            "        run_id: str,",
            "        task_id: str,",
            "        map_indexes: list[int] | None,",
            "        origin: str,",
            "        upstream: bool,",
            "        downstream: bool,",
            "        future: bool,",
            "        past: bool,",
            "        state: TaskInstanceState,",
            "    ):",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not run_id:",
            "            flash(f\"Cannot mark tasks as {state}, seem that DAG {dag_id} has never run\", \"error\")",
            "            return redirect(origin)",
            "",
            "        altered = dag.set_task_instance_state(",
            "            task_id=task_id,",
            "            map_indexes=map_indexes,",
            "            run_id=run_id,",
            "            state=state,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "        )",
            "",
            "        flash(f\"Marked {state} on {len(altered)} task instances\")",
            "        return redirect(origin)",
            "",
            "    def _mark_task_group_state(",
            "        self,",
            "        *,",
            "        dag_id: str,",
            "        run_id: str,",
            "        group_id: str,",
            "        origin: str,",
            "        upstream: bool,",
            "        downstream: bool,",
            "        future: bool,",
            "        past: bool,",
            "        state: TaskInstanceState,",
            "    ):",
            "        dag: DAG = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not run_id:",
            "            flash(f\"Cannot mark tasks as {state}, as DAG {dag_id} has never run\", \"error\")",
            "            return redirect(origin)",
            "",
            "        altered = dag.set_task_group_state(",
            "            group_id=group_id,",
            "            run_id=run_id,",
            "            state=state,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "        )",
            "",
            "        flash(f\"Marked {state} on {len(altered)} task instances\")",
            "        return redirect(origin)",
            "",
            "    @expose(\"/confirm\", methods=[\"GET\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def confirm(self):",
            "        \"\"\"Show confirmation page for marking tasks as success or failed.\"\"\"",
            "        args = request.args",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        dag_run_id = args.get(\"dag_run_id\")",
            "        state = args.get(\"state\")",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "        origin = origin or url_for(\"Airflow.index\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        if not dag:",
            "            msg = f\"DAG {dag_id} not found\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=404)",
            "",
            "        if state not in (",
            "            \"success\",",
            "            \"failed\",",
            "        ):",
            "            msg = f\"Invalid state {state}, must be either 'success' or 'failed'\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=400)",
            "",
            "        latest_execution_date = dag.get_latest_execution_date()",
            "        if not latest_execution_date:",
            "            msg = f\"Cannot mark tasks as {state}, seem that dag {dag_id} has never run\"",
            "            return redirect_or_json(origin, msg, status=\"error\", status_code=400)",
            "",
            "        tasks: list[Operator | tuple[Operator, int]] = []",
            "",
            "        if group_id:",
            "            task_group_dict = dag.task_group.get_task_group_dict()",
            "            task_group = task_group_dict.get(group_id)",
            "            if task_group is None:",
            "                return redirect_or_json(",
            "                    origin, msg=f\"TaskGroup {group_id} could not be found\", status=\"error\", status_code=404",
            "                )",
            "            tasks = [task for task in task_group.iter_tasks()]",
            "        elif task_id:",
            "            try:",
            "                task = dag.get_task(task_id)",
            "            except airflow.exceptions.TaskNotFound:",
            "                msg = f\"Task {task_id} not found\"",
            "                return redirect_or_json(origin, msg, status=\"error\", status_code=404)",
            "            task.dag = dag",
            "            if map_indexes is None:",
            "                tasks = [task]",
            "            else:",
            "                tasks = [(task, map_index) for map_index in map_indexes]",
            "",
            "        to_be_altered = set_state(",
            "            tasks=tasks,",
            "            run_id=dag_run_id,",
            "            upstream=upstream,",
            "            downstream=downstream,",
            "            future=future,",
            "            past=past,",
            "            state=state,",
            "            commit=False,",
            "        )",
            "",
            "        if request.headers.get(\"Accept\") == \"application/json\":",
            "            return htmlsafe_json_dumps(",
            "                [",
            "                    {\"task_id\": ti.task_id, \"map_index\": ti.map_index, \"run_id\": ti.run_id}",
            "                    for ti in to_be_altered",
            "                ],",
            "                separators=(\",\", \":\"),",
            "            )",
            "",
            "        details = \"\\n\".join(str(t) for t in to_be_altered)",
            "",
            "        response = self.render_template(",
            "            \"airflow/confirm.html\",",
            "            endpoint=url_for(f\"Airflow.{state}\"),",
            "            message=f\"Task instances you are about to mark as {state}:\",",
            "            details=details,",
            "        )",
            "",
            "        return response",
            "",
            "    @expose(\"/failed\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def failed(self):",
            "        \"\"\"Mark task or task_group as failed.\"\"\"",
            "        args = request.form",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        run_id = args.get(\"dag_run_id\")",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "",
            "        if task_id:",
            "            return self._mark_task_instance_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                task_id=task_id,",
            "                map_indexes=map_indexes,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.FAILED,",
            "            )",
            "        elif group_id:",
            "            return self._mark_task_group_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                group_id=group_id,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.FAILED,",
            "            )",
            "",
            "    @expose(\"/success\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def success(self):",
            "        \"\"\"Mark task or task_group as success.\"\"\"",
            "        args = request.form",
            "        dag_id = args.get(\"dag_id\")",
            "        task_id = args.get(\"task_id\")",
            "        run_id = args.get(\"dag_run_id\")",
            "        group_id = args.get(\"group_id\")",
            "",
            "        if not exactly_one(task_id, group_id):",
            "            raise ValueError(\"Exactly one of task_id or group_id must be provided\")",
            "",
            "        if \"map_index\" not in args:",
            "            map_indexes: list[int] | None = None",
            "        else:",
            "            map_indexes = args.getlist(\"map_index\", type=int)",
            "",
            "        origin = get_safe_url(args.get(\"origin\"))",
            "        upstream = to_boolean(args.get(\"upstream\"))",
            "        downstream = to_boolean(args.get(\"downstream\"))",
            "        future = to_boolean(args.get(\"future\"))",
            "        past = to_boolean(args.get(\"past\"))",
            "",
            "        if task_id:",
            "            return self._mark_task_instance_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                task_id=task_id,",
            "                map_indexes=map_indexes,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.SUCCESS,",
            "            )",
            "        elif group_id:",
            "            return self._mark_task_group_state(",
            "                dag_id=dag_id,",
            "                run_id=run_id,",
            "                group_id=group_id,",
            "                origin=origin,",
            "                upstream=upstream,",
            "                downstream=downstream,",
            "                future=future,",
            "                past=past,",
            "                state=TaskInstanceState.SUCCESS,",
            "            )",
            "",
            "    @expose(\"/dags/<string:dag_id>\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def dag(self, dag_id):",
            "        \"\"\"Redirect to default DAG view.\"\"\"",
            "        kwargs = {**sanitize_args(request.args), \"dag_id\": dag_id}",
            "        return redirect(url_for(\"Airflow.grid\", **kwargs))",
            "",
            "    @expose(\"/tree\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_tree(self):",
            "        \"\"\"Redirect to the replacement - grid view. Kept for backwards compatibility.\"\"\"",
            "        return redirect(url_for(\"Airflow.grid\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/grid\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def grid(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag's grid view.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_downstream=False, include_upstream=True)",
            "",
            "        num_runs = request.args.get(\"num_runs\", type=int)",
            "        if num_runs is None:",
            "            num_runs = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if task_log_reader.supports_external_link:",
            "            external_log_name = task_log_reader.log_handler.log_name",
            "        else:",
            "            external_log_name = None",
            "",
            "        default_dag_run_display_number = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        num_runs_options = [5, 25, 50, 100, 365]",
            "",
            "        if default_dag_run_display_number not in num_runs_options:",
            "            insort_left(num_runs_options, default_dag_run_display_number)",
            "",
            "        return self.render_template(",
            "            \"airflow/grid.html\",",
            "            root=root,",
            "            dag=dag,",
            "            doc_md=doc_md,",
            "            num_runs=num_runs,",
            "            show_external_log_redirect=task_log_reader.supports_external_link,",
            "            external_log_name=external_log_name,",
            "            dag_model=dag_model,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            default_dag_run_display_number=default_dag_run_display_number,",
            "            default_wrap=conf.getboolean(\"webserver\", \"default_wrap\"),",
            "            filters_drop_down_values=htmlsafe_json_dumps(",
            "                {",
            "                    \"taskStates\": [state.value for state in TaskInstanceState],",
            "                    \"dagStates\": [state.value for state in State.dag_states],",
            "                    \"runTypes\": [run_type.value for run_type in DagRunType],",
            "                    \"numRuns\": num_runs_options,",
            "                }",
            "            ),",
            "        )",
            "",
            "    @expose(\"/calendar\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_calendar(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.calendar\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/calendar\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def calendar(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get DAG runs as calendar.\"\"\"",
            "",
            "        def _convert_to_date(session, column):",
            "            \"\"\"Convert column to date.\"\"\"",
            "            if session.bind.dialect.name == \"mssql\":",
            "                return column.cast(Date)",
            "            else:",
            "                return func.date(column)",
            "",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_downstream=False, include_upstream=True)",
            "",
            "        dag_states = (",
            "            session.query(",
            "                (_convert_to_date(session, DagRun.execution_date)).label(\"date\"),",
            "                DagRun.state,",
            "                func.max(DagRun.data_interval_start).label(\"data_interval_start\"),",
            "                func.max(DagRun.data_interval_end).label(\"data_interval_end\"),",
            "                func.count(\"*\").label(\"count\"),",
            "            )",
            "            .filter(DagRun.dag_id == dag.dag_id)",
            "            .group_by(_convert_to_date(session, DagRun.execution_date), DagRun.state)",
            "            .order_by(_convert_to_date(session, DagRun.execution_date).asc())",
            "            .all()",
            "        )",
            "",
            "        data_dag_states = [",
            "            {",
            "                # DATE() in SQLite and MySQL behave differently:",
            "                # SQLite returns a string, MySQL returns a date.",
            "                \"date\": dr.date if isinstance(dr.date, str) else dr.date.isoformat(),",
            "                \"state\": dr.state,",
            "                \"count\": dr.count,",
            "            }",
            "            for dr in dag_states",
            "        ]",
            "",
            "        if dag_states and dag_states[-1].data_interval_start and dag_states[-1].data_interval_end:",
            "            last_automated_data_interval = DataInterval(",
            "                timezone.coerce_datetime(dag_states[-1].data_interval_start),",
            "                timezone.coerce_datetime(dag_states[-1].data_interval_end),",
            "            )",
            "",
            "            year = last_automated_data_interval.end.year",
            "            restriction = TimeRestriction(dag.start_date, dag.end_date, False)",
            "            dates: dict[datetime.date, int] = collections.Counter()",
            "",
            "            if isinstance(dag.timetable, CronMixin):",
            "                # Optimized calendar generation for timetables based on a cron expression.",
            "                dates_iter: Iterator[datetime.datetime | None] = croniter(",
            "                    dag.timetable._expression,",
            "                    start_time=last_automated_data_interval.end,",
            "                    ret_type=datetime.datetime,",
            "                )",
            "                for dt in dates_iter:",
            "                    if dt is None:",
            "                        break",
            "                    if dt.year != year:",
            "                        break",
            "                    if dag.end_date and dt > dag.end_date:",
            "                        break",
            "                    dates[dt.date()] += 1",
            "            else:",
            "                prev_logical_date = DateTime.min",
            "                while True:",
            "                    curr_info = dag.timetable.next_dagrun_info(",
            "                        last_automated_data_interval=last_automated_data_interval,",
            "                        restriction=restriction,",
            "                    )",
            "                    if curr_info is None:",
            "                        break  # Reached the end.",
            "                    if curr_info.logical_date <= prev_logical_date:",
            "                        break  # We're not progressing. Maybe a malformed timetable? Give up.",
            "                    if curr_info.logical_date.year != year:",
            "                        break  # Crossed the year boundary.",
            "                    last_automated_data_interval = curr_info.data_interval",
            "                    dates[curr_info.logical_date] += 1",
            "                    prev_logical_date = curr_info.logical_date",
            "",
            "            data_dag_states.extend(",
            "                {\"date\": date.isoformat(), \"state\": \"planned\", \"count\": count}",
            "                for (date, count) in dates.items()",
            "            )",
            "",
            "        now = DateTime.utcnow()",
            "        data = {",
            "            \"dag_states\": data_dag_states,",
            "            \"start_date\": (dag.start_date or now).date().isoformat(),",
            "            \"end_date\": (dag.end_date or now).date().isoformat(),",
            "        }",
            "",
            "        return self.render_template(",
            "            \"airflow/calendar.html\",",
            "            dag=dag,",
            "            doc_md=wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None)),",
            "            data=htmlsafe_json_dumps(data, separators=(\",\", \":\")),  # Avoid spaces to reduce payload size.",
            "            root=root,",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/graph\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def legacy_graph(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.graph\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/graph\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def graph(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get DAG as Graph.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "        arrange = request.args.get(\"arrange\", dag.orientation)",
            "",
            "        nodes = task_group_to_dict(dag.task_group)",
            "        edges = dag_edges(dag)",
            "",
            "        dt_nr_dr_data = get_date_time_num_runs_dag_runs_form_data(request, session, dag)",
            "",
            "        dt_nr_dr_data[\"arrange\"] = arrange",
            "        dttm = dt_nr_dr_data[\"dttm\"]",
            "        dag_run = dag.get_dagrun(execution_date=dttm)",
            "        dag_run_id = dag_run.run_id if dag_run else None",
            "",
            "        class GraphForm(DateTimeWithNumRunsWithDagRunsForm):",
            "            \"\"\"Graph Form class.\"\"\"",
            "",
            "            arrange = SelectField(",
            "                \"Layout\",",
            "                choices=(",
            "                    (\"LR\", \"Left > Right\"),",
            "                    (\"RL\", \"Right > Left\"),",
            "                    (\"TB\", \"Top > Bottom\"),",
            "                    (\"BT\", \"Bottom > Top\"),",
            "                ),",
            "            )",
            "",
            "        form = GraphForm(data=dt_nr_dr_data)",
            "        form.execution_date.choices = dt_nr_dr_data[\"dr_choices\"]",
            "",
            "        task_instances = {}",
            "        for ti in dag.get_task_instances(dttm, dttm):",
            "            if ti.task_id not in task_instances:",
            "                task_instances[ti.task_id] = wwwutils.get_instance_with_map(ti, session)",
            "        tasks = {",
            "            t.task_id: {",
            "                \"dag_id\": t.dag_id,",
            "                \"task_type\": t.task_type,",
            "                \"operator_name\": t.operator_name,",
            "                \"extra_links\": t.extra_links,",
            "                \"is_mapped\": isinstance(t, MappedOperator),",
            "                \"trigger_rule\": t.trigger_rule,",
            "            }",
            "            for t in dag.tasks",
            "        }",
            "        if not tasks:",
            "            flash(\"No tasks found\", \"error\")",
            "        session.commit()",
            "        doc_md = wwwutils.wrapped_markdown(getattr(dag, \"doc_md\", None))",
            "",
            "        task_log_reader = TaskLogReader()",
            "        if task_log_reader.supports_external_link:",
            "            external_log_name = task_log_reader.log_handler.log_name",
            "        else:",
            "            external_log_name = None",
            "",
            "        state_priority = [\"no_status\" if p is None else p for p in wwwutils.priority]",
            "",
            "        return self.render_template(",
            "            \"airflow/graph.html\",",
            "            dag=dag,",
            "            form=form,",
            "            dag_run_id=dag_run_id,",
            "            execution_date=dttm.isoformat(),",
            "            state_token=wwwutils.state_token(dt_nr_dr_data[\"dr_state\"]),",
            "            doc_md=doc_md,",
            "            arrange=arrange,",
            "            operators=sorted(",
            "                {op.operator_name: op for op in dag.tasks}.values(), key=lambda x: x.operator_name",
            "            ),",
            "            root=root or \"\",",
            "            task_instances=task_instances,",
            "            tasks=tasks,",
            "            nodes=nodes,",
            "            edges=edges,",
            "            show_external_log_redirect=task_log_reader.supports_external_link,",
            "            external_log_name=external_log_name,",
            "            dag_run_state=dt_nr_dr_data[\"dr_state\"],",
            "            dag_model=dag_model,",
            "            auto_refresh_interval=conf.getint(\"webserver\", \"auto_refresh_interval\"),",
            "            state_priority=state_priority,",
            "        )",
            "",
            "    @expose(\"/duration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_duration(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.duration\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/duration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def duration(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Get Dag as duration graph.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "        cum_chart = nvd3.lineChart(",
            "            name=\"cumLineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        y_points = defaultdict(list)",
            "        x_points = defaultdict(list)",
            "",
            "        task_instances = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "        if task_instances:",
            "            min_date = task_instances[0].execution_date",
            "        else:",
            "            min_date = timezone.utc_epoch()",
            "        ti_fails = (",
            "            session.query(TaskFail)",
            "            .join(TaskFail.dag_run)",
            "            .filter(",
            "                TaskFail.dag_id == dag.dag_id,",
            "                DagRun.execution_date >= min_date,",
            "                DagRun.execution_date <= base_date,",
            "            )",
            "        )",
            "        if dag.partial:",
            "            ti_fails = ti_fails.filter(TaskFail.task_id.in_([t.task_id for t in dag.tasks]))",
            "        fails_totals: dict[tuple[str, str, str], int] = defaultdict(int)",
            "        for failed_task_instance in ti_fails:",
            "            dict_key = (",
            "                failed_task_instance.dag_id,",
            "                failed_task_instance.task_id,",
            "                failed_task_instance.run_id,",
            "            )",
            "            if failed_task_instance.duration:",
            "                fails_totals[dict_key] += failed_task_instance.duration",
            "",
            "        # we must group any mapped TIs by dag_id, task_id, run_id",
            "        mapped_tis = set()",
            "        tis_grouped = itertools.groupby(task_instances, lambda x: (x.dag_id, x.task_id, x.run_id))",
            "        for _, group in tis_grouped:",
            "            tis = list(group)",
            "            duration = sum(x.duration for x in tis if x.duration)",
            "            if duration:",
            "                first_ti = tis[0]",
            "                if first_ti.map_index >= 0:",
            "                    mapped_tis.add(first_ti.task_id)",
            "                date_time = wwwutils.epoch(first_ti.execution_date)",
            "                x_points[first_ti.task_id].append(date_time)",
            "                fails_dict_key = (first_ti.dag_id, first_ti.task_id, first_ti.run_id)",
            "                fails_total = fails_totals[fails_dict_key]",
            "                y_points[first_ti.task_id].append(float(duration + fails_total))",
            "",
            "        cumulative_y = {k: list(itertools.accumulate(v)) for k, v in y_points.items()}",
            "",
            "        # determine the most relevant time unit for the set of task instance",
            "        # durations for the DAG",
            "        y_unit = infer_time_unit([d for t in y_points.values() for d in t])",
            "        cum_y_unit = infer_time_unit([d for t in cumulative_y.values() for d in t])",
            "        # update the y Axis on both charts to have the correct time units",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Duration ({y_unit})\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "        cum_chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Duration ({cum_y_unit})\")",
            "        cum_chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        for task_id in x_points:",
            "            chart.add_serie(",
            "                name=task_id + \"[]\" if task_id in mapped_tis else task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(y_points[task_id], y_unit),",
            "            )",
            "            cum_chart.add_serie(",
            "                name=task_id + \"[]\" if task_id in mapped_tis else task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(cumulative_y[task_id], cum_y_unit),",
            "            )",
            "",
            "        dates = sorted({ti.execution_date for ti in task_instances})",
            "        max_date = max(ti.execution_date for ti in task_instances) if dates else None",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "        chart.buildcontent()",
            "        cum_chart.buildcontent()",
            "        s_index = cum_chart.htmlcontent.rfind(\"});\")",
            "        cum_chart.htmlcontent = (",
            "            f\"{cum_chart.htmlcontent[:s_index]}\"",
            "            \"$( document ).trigger('chartload')\"",
            "            f\"{cum_chart.htmlcontent[s_index:]}\"",
            "        )",
            "",
            "        return self.render_template(",
            "            \"airflow/duration_chart.html\",",
            "            dag=dag,",
            "            root=root,",
            "            form=form,",
            "            chart=Markup(chart.htmlcontent),",
            "            cum_chart=Markup(cum_chart.htmlcontent),",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/tries\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_tries(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.tries\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/tries\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def tries(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Shows all tries.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        tis = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "        for task in dag.tasks:",
            "            y_points = []",
            "            x_points = []",
            "            for ti in tis:",
            "                if ti.task_id != task.task_id:",
            "                    continue",
            "                dttm = wwwutils.epoch(ti.execution_date)",
            "                x_points.append(dttm)",
            "                # y value should reflect completed tries to have a 0 baseline.",
            "                y_points.append(ti.prev_attempted_tries)",
            "            if x_points:",
            "                chart.add_serie(name=task.task_id, x=x_points, y=y_points)",
            "",
            "        tries = sorted({ti.try_number for ti in tis})",
            "        max_date = max(ti.execution_date for ti in tis) if tries else None",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=\"Tries\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "",
            "        chart.buildcontent()",
            "",
            "        return self.render_template(",
            "            \"airflow/chart.html\",",
            "            dag=dag,",
            "            root=root,",
            "            form=form,",
            "            chart=Markup(chart.htmlcontent),",
            "            tab_title=\"Tries\",",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/landing_times\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_landing_times(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.landing_times\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/landing-times\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def landing_times(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Shows landing times.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        default_dag_run = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "        base_date_str = request.args.get(\"base_date\")",
            "        num_runs = request.args.get(\"num_runs\", default=default_dag_run, type=int)",
            "",
            "        if base_date_str:",
            "            base_date = _safe_parse_datetime(base_date_str)",
            "        else:",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        tis = dag.get_task_instances_before(base_date, num_runs, session=session)",
            "",
            "        chart_height = wwwutils.get_chart_height(dag)",
            "        chart = nvd3.lineChart(",
            "            name=\"lineChart\",",
            "            x_custom_format=True,",
            "            x_axis_date=True,",
            "            x_axis_format=LINECHART_X_AXIS_TICKFORMAT,",
            "            height=chart_height,",
            "            chart_attr=self.line_chart_attr,",
            "        )",
            "",
            "        y_points: dict[str, list[float]] = collections.defaultdict(list)",
            "        x_points: dict[str, list[tuple[int]]] = collections.defaultdict(list)",
            "        for task in dag.tasks:",
            "            task_id = task.task_id",
            "            for ti in tis:",
            "                if ti.task_id != task.task_id:",
            "                    continue",
            "                ts = dag.get_run_data_interval(ti.dag_run).end",
            "                if ti.end_date:",
            "                    dttm = wwwutils.epoch(ti.execution_date)",
            "                    secs = (ti.end_date - ts).total_seconds()",
            "                    x_points[task_id].append(dttm)",
            "                    y_points[task_id].append(secs)",
            "",
            "        # determine the most relevant time unit for the set of landing times",
            "        # for the DAG",
            "        y_unit = infer_time_unit([d for t in y_points.values() for d in t])",
            "        # update the y Axis to have the correct time units",
            "        chart.create_y_axis(\"yAxis\", format=\".02f\", custom_format=False, label=f\"Landing Time ({y_unit})\")",
            "        chart.axislist[\"yAxis\"][\"axisLabelDistance\"] = \"-15\"",
            "",
            "        for task_id in x_points:",
            "            chart.add_serie(",
            "                name=task_id,",
            "                x=x_points[task_id],",
            "                y=scale_time_units(y_points[task_id], y_unit),",
            "            )",
            "        max_date = max(ti.execution_date for ti in tis) if tis else None",
            "",
            "        session.commit()",
            "",
            "        form = DateTimeWithNumRunsForm(",
            "            data={",
            "                \"base_date\": max_date or timezone.utcnow(),",
            "                \"num_runs\": num_runs,",
            "            }",
            "        )",
            "        chart.buildcontent()",
            "",
            "        return self.render_template(",
            "            \"airflow/chart.html\",",
            "            dag=dag,",
            "            chart=Markup(chart.htmlcontent),",
            "            height=f\"{chart_height + 100}px\",",
            "            root=root,",
            "            form=form,",
            "            tab_title=\"Landing times\",",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/paused\", methods=[\"POST\"])",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def paused(self):",
            "        \"\"\"Toggle paused.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        is_paused = request.args.get(\"is_paused\") == \"false\"",
            "        models.DagModel.get_dagmodel(dag_id).set_is_paused(is_paused=is_paused)",
            "        return \"OK\"",
            "",
            "    @expose(\"/gantt\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def legacy_gantt(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.gantt\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/gantt\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def gantt(self, dag_id: str, session: Session = NEW_SESSION):",
            "        \"\"\"Show GANTT chart.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        wwwutils.check_import_errors(dag.fileloc, session)",
            "        wwwutils.check_dag_warnings(dag.dag_id, session)",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            dag = dag.partial_subset(task_ids_or_regex=root, include_upstream=True, include_downstream=False)",
            "",
            "        dt_nr_dr_data = get_date_time_num_runs_dag_runs_form_data(request, session, dag)",
            "        dttm = dt_nr_dr_data[\"dttm\"]",
            "        dag_run = dag.get_dagrun(execution_date=dttm)",
            "        dag_run_id = dag_run.run_id if dag_run else None",
            "",
            "        form = DateTimeWithNumRunsWithDagRunsForm(data=dt_nr_dr_data)",
            "        form.execution_date.choices = dt_nr_dr_data[\"dr_choices\"]",
            "",
            "        tis = (",
            "            session.query(TaskInstance)",
            "            .filter(",
            "                TaskInstance.dag_id == dag_id,",
            "                TaskInstance.run_id == dag_run_id,",
            "                TaskInstance.start_date.is_not(None),",
            "                TaskInstance.state.is_not(None),",
            "            )",
            "            .order_by(TaskInstance.start_date)",
            "        )",
            "",
            "        ti_fails = session.query(TaskFail).filter_by(run_id=dag_run_id, dag_id=dag_id)",
            "        if dag.partial:",
            "            ti_fails = ti_fails.filter(TaskFail.task_id.in_([t.task_id for t in dag.tasks]))",
            "",
            "        tasks = []",
            "        for ti in tis:",
            "            if not dag.has_task(ti.task_id):",
            "                continue",
            "            # prev_attempted_tries will reflect the currently running try_number",
            "            # or the try_number of the last complete run",
            "            # https://issues.apache.org/jira/browse/AIRFLOW-2143",
            "            try_count = ti.prev_attempted_tries if ti.prev_attempted_tries != 0 else ti.try_number",
            "            task_dict = alchemy_to_dict(ti) or {}",
            "            task_dict[\"end_date\"] = task_dict[\"end_date\"] or timezone.utcnow()",
            "            task_dict[\"extraLinks\"] = dag.get_task(ti.task_id).extra_links",
            "            task_dict[\"try_number\"] = try_count",
            "            task_dict[\"execution_date\"] = dttm.isoformat()",
            "            task_dict[\"run_id\"] = dag_run_id",
            "            tasks.append(task_dict)",
            "",
            "        tf_count = 0",
            "        try_count = 1",
            "        prev_task_id = \"\"",
            "        for failed_task_instance in ti_fails:",
            "            if not dag.has_task(failed_task_instance.task_id):",
            "                continue",
            "            if tf_count != 0 and failed_task_instance.task_id == prev_task_id:",
            "                try_count += 1",
            "            else:",
            "                try_count = 1",
            "            prev_task_id = failed_task_instance.task_id",
            "            tf_count += 1",
            "            task = dag.get_task(failed_task_instance.task_id)",
            "            task_dict = alchemy_to_dict(failed_task_instance) or {}",
            "            end_date = task_dict[\"end_date\"] or timezone.utcnow()",
            "            task_dict[\"end_date\"] = end_date",
            "            task_dict[\"start_date\"] = task_dict[\"start_date\"] or end_date",
            "            task_dict[\"state\"] = TaskInstanceState.FAILED",
            "            task_dict[\"operator\"] = task.operator_name",
            "            task_dict[\"try_number\"] = try_count",
            "            task_dict[\"extraLinks\"] = task.extra_links",
            "            task_dict[\"execution_date\"] = dttm.isoformat()",
            "            task_dict[\"run_id\"] = dag_run_id",
            "            tasks.append(task_dict)",
            "",
            "        task_names = [ti.task_id for ti in tis]",
            "        data = {",
            "            \"taskNames\": task_names,",
            "            \"tasks\": tasks,",
            "            \"height\": len(task_names) * 25 + 25,",
            "        }",
            "",
            "        session.commit()",
            "",
            "        return self.render_template(",
            "            \"airflow/gantt.html\",",
            "            dag=dag,",
            "            dag_run_id=dag_run_id,",
            "            execution_date=dttm.isoformat(),",
            "            form=form,",
            "            data=data,",
            "            base_date=\"\",",
            "            root=root,",
            "            dag_model=dag_model,",
            "        )",
            "",
            "    @expose(\"/extra_links\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    @provide_session",
            "    def extra_links(self, *, session: Session = NEW_SESSION):",
            "        \"\"\"",
            "        A restful endpoint that returns external links for a given Operator.",
            "",
            "        It queries the operator that sent the request for the links it wishes",
            "        to provide for a given external link name.",
            "",
            "        API: GET",
            "        Args: dag_id: The id of the dag containing the task in question",
            "              task_id: The id of the task in question",
            "              execution_date: The date of execution of the task",
            "              link_name: The name of the link reference to find the actual URL for",
            "",
            "        Returns:",
            "            200: {url: <url of link>, error: None} - returned when there was no problem",
            "                finding the URL",
            "            404: {url: None, error: <error message>} - returned when the operator does",
            "                not return a URL",
            "        \"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        task_id = request.args.get(\"task_id\")",
            "        map_index = request.args.get(\"map_index\", -1, type=int)",
            "        execution_date = request.args.get(\"execution_date\")",
            "        dttm = _safe_parse_datetime(execution_date)",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag or task_id not in dag.task_ids:",
            "            return {\"url\": None, \"error\": f\"can't find dag {dag} or task_id {task_id}\"}, 404",
            "",
            "        task: AbstractOperator = dag.get_task(task_id)",
            "        link_name = request.args.get(\"link_name\")",
            "        if link_name is None:",
            "            return {\"url\": None, \"error\": \"Link name not passed\"}, 400",
            "",
            "        ti = (",
            "            session.query(TaskInstance)",
            "            .filter_by(dag_id=dag_id, task_id=task_id, execution_date=dttm, map_index=map_index)",
            "            .options(joinedload(TaskInstance.dag_run))",
            "            .first()",
            "        )",
            "        if not ti:",
            "            return {\"url\": None, \"error\": \"Task Instances not found\"}, 404",
            "        try:",
            "            url = task.get_extra_links(ti, link_name)",
            "        except ValueError as err:",
            "            return {\"url\": None, \"error\": str(err)}, 404",
            "        if url:",
            "            return {\"error\": None, \"url\": url}",
            "        else:",
            "            return {\"url\": None, \"error\": f\"No URL found for {link_name}\"}, 404",
            "",
            "    @expose(\"/object/graph_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    @provide_session",
            "    def graph_data(self, session: Session = NEW_SESSION):",
            "        \"\"\"Get Graph Data.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "",
            "        nodes = task_group_to_dict(dag.task_group)",
            "        edges = dag_edges(dag)",
            "",
            "        data = {",
            "            \"arrange\": dag.orientation,",
            "            \"nodes\": nodes,",
            "            \"edges\": edges,",
            "        }",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/task_instances\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    @action_logging",
            "    def task_instances(self):",
            "        \"\"\"Shows task instances.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        dttm = request.args.get(\"execution_date\")",
            "        if dttm:",
            "            dttm = _safe_parse_datetime(dttm)",
            "        else:",
            "            return {\"error\": f\"Invalid execution_date {dttm}\"}, 400",
            "",
            "        with create_session() as session:",
            "            task_instances = {",
            "                ti.task_id: wwwutils.get_instance_with_map(ti, session)",
            "                for ti in dag.get_task_instances(dttm, dttm)",
            "            }",
            "",
            "        return flask.json.jsonify(task_instances)",
            "",
            "    @expose(\"/object/grid_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),",
            "        ]",
            "    )",
            "    def grid_data(self):",
            "        \"\"\"Returns grid data.\"\"\"",
            "        dag_id = request.args.get(\"dag_id\")",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "",
            "        if not dag:",
            "            return {\"error\": f\"can't find dag {dag_id}\"}, 404",
            "",
            "        root = request.args.get(\"root\")",
            "        if root:",
            "            filter_upstream = request.args.get(\"filter_upstream\") == \"true\"",
            "            filter_downstream = request.args.get(\"filter_downstream\") == \"true\"",
            "            dag = dag.partial_subset(",
            "                task_ids_or_regex=root, include_upstream=filter_upstream, include_downstream=filter_downstream",
            "            )",
            "",
            "        num_runs = request.args.get(\"num_runs\", type=int)",
            "        if num_runs is None:",
            "            num_runs = conf.getint(\"webserver\", \"default_dag_run_display_number\")",
            "",
            "        try:",
            "            base_date = timezone.parse(request.args[\"base_date\"])",
            "        except (KeyError, ValueError):",
            "            base_date = dag.get_latest_execution_date() or timezone.utcnow()",
            "",
            "        with create_session() as session:",
            "            query = session.query(DagRun).filter(",
            "                DagRun.dag_id == dag.dag_id, DagRun.execution_date <= base_date",
            "            )",
            "",
            "            run_type = request.args.get(\"run_type\")",
            "            if run_type:",
            "                query = query.filter(DagRun.run_type == run_type)",
            "",
            "            run_state = request.args.get(\"run_state\")",
            "            if run_state:",
            "                query = query.filter(DagRun.state == run_state)",
            "",
            "            dag_runs = wwwutils.sorted_dag_runs(query, ordering=dag.timetable.run_ordering, limit=num_runs)",
            "            encoded_runs = [",
            "                wwwutils.encode_dag_run(dr, json_encoder=utils_json.WebEncoder) for dr in dag_runs",
            "            ]",
            "            data = {",
            "                \"groups\": dag_to_grid(dag, dag_runs, session),",
            "                \"dag_runs\": encoded_runs,",
            "                \"ordering\": dag.timetable.run_ordering,",
            "            }",
            "        # avoid spaces to reduce payload size",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/historical_metrics_data\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CLUSTER_ACTIVITY),",
            "        ]",
            "    )",
            "    def historical_metrics_data(self):",
            "        \"\"\"Returns cluster activity historical metrics.\"\"\"",
            "        start_date = _safe_parse_datetime(request.args.get(\"start_date\"))",
            "        end_date = _safe_parse_datetime(request.args.get(\"end_date\"))",
            "        with create_session() as session:",
            "            # DagRuns",
            "            dag_runs_type = (",
            "                session.query(DagRun.run_type, func.count(DagRun.run_id))",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(DagRun.run_type)",
            "                .all()",
            "            )",
            "",
            "            dag_run_states = (",
            "                session.query(DagRun.state, func.count(DagRun.run_id))",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(DagRun.state)",
            "                .all()",
            "            )",
            "",
            "            # TaskInstances",
            "            task_instance_states = (",
            "                session.query(TaskInstance.state, func.count(TaskInstance.run_id))",
            "                .join(TaskInstance.dag_run)",
            "                .filter(",
            "                    DagRun.start_date >= start_date,",
            "                    or_(DagRun.end_date.is_(None), DagRun.end_date <= end_date),",
            "                )",
            "                .group_by(TaskInstance.state)",
            "                .all()",
            "            )",
            "",
            "            data = {",
            "                \"dag_run_types\": {",
            "                    **{dag_run_type.value: 0 for dag_run_type in DagRunType},",
            "                    **{run_type: sum_value for run_type, sum_value in dag_runs_type},",
            "                },",
            "                \"dag_run_states\": {",
            "                    **{dag_run_state.value: 0 for dag_run_state in DagRunState},",
            "                    **{run_state: sum_value for run_state, sum_value in dag_run_states},",
            "                },",
            "                \"task_instance_states\": {",
            "                    \"no_status\": 0,",
            "                    **{ti_state.value: 0 for ti_state in TaskInstanceState},",
            "                    **{ti_state or \"no_status\": sum_value for ti_state, sum_value in task_instance_states},",
            "                },",
            "            }",
            "",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/next_run_datasets/<string:dag_id>\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    def next_run_datasets(self, dag_id):",
            "        \"\"\"Returns datasets necessary, and their status, for the next dag run.\"\"\"",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id)",
            "        if not dag:",
            "            return {\"error\": f\"can't find dag {dag_id}\"}, 404",
            "",
            "        with create_session() as session:",
            "            data = [",
            "                dict(info)",
            "                for info in session.query(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                    func.max(DatasetEvent.timestamp).label(\"lastUpdate\"),",
            "                )",
            "                .join(DagScheduleDatasetReference, DagScheduleDatasetReference.dataset_id == DatasetModel.id)",
            "                .join(",
            "                    DatasetDagRunQueue,",
            "                    and_(",
            "                        DatasetDagRunQueue.dataset_id == DatasetModel.id,",
            "                        DatasetDagRunQueue.target_dag_id == DagScheduleDatasetReference.dag_id,",
            "                    ),",
            "                    isouter=True,",
            "                )",
            "                .join(",
            "                    DatasetEvent,",
            "                    DatasetEvent.dataset_id == DatasetModel.id,",
            "                    isouter=True,",
            "                )",
            "                .filter(DagScheduleDatasetReference.dag_id == dag_id, ~DatasetModel.is_orphaned)",
            "                .group_by(DatasetModel.id, DatasetModel.uri)",
            "                .order_by(DatasetModel.uri)",
            "            ]",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/dataset_dependencies\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_DEPENDENCIES),",
            "        ]",
            "    )",
            "    def dataset_dependencies(self):",
            "        \"\"\"Returns dataset dependencies graph.\"\"\"",
            "        nodes_dict: dict[str, Any] = {}",
            "        edge_tuples: set[dict[str, str]] = set()",
            "",
            "        for dag, dependencies in SerializedDagModel.get_dag_dependencies().items():",
            "            dag_node_id = f\"dag:{dag}\"",
            "            if dag_node_id not in nodes_dict and len(dependencies) > 0:",
            "                for dep in dependencies:",
            "                    if dep.dependency_type == \"dag\" or dep.dependency_type == \"dataset\":",
            "                        nodes_dict[dag_node_id] = node_dict(dag_node_id, dag, \"dag\")",
            "                        if dep.node_id not in nodes_dict:",
            "                            nodes_dict[dep.node_id] = node_dict(",
            "                                dep.node_id, dep.dependency_id, dep.dependency_type",
            "                            )",
            "                        if dep.source != \"dataset\":",
            "                            edge_tuples.add((f\"dag:{dep.source}\", dep.node_id))",
            "                        if dep.target != \"dataset\":",
            "                            edge_tuples.add((dep.node_id, f\"dag:{dep.target}\"))",
            "",
            "        nodes = list(nodes_dict.values())",
            "        edges = [{\"source\": source, \"target\": target} for source, target in edge_tuples]",
            "",
            "        data = {",
            "            \"nodes\": nodes,",
            "            \"edges\": edges,",
            "        }",
            "",
            "        return (",
            "            htmlsafe_json_dumps(data, separators=(\",\", \":\"), dumps=flask.json.dumps),",
            "            {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "        )",
            "",
            "    @expose(\"/object/datasets_summary\")",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DATASET)])",
            "    def datasets_summary(self):",
            "        \"\"\"Get a summary of datasets, including the datetime they were last updated and how many updates",
            "        they've ever had.",
            "        \"\"\"",
            "        allowed_attrs = [\"uri\", \"last_dataset_update\"]",
            "",
            "        # Grab query parameters",
            "        limit = int(request.args.get(\"limit\", 25))",
            "        offset = int(request.args.get(\"offset\", 0))",
            "        order_by = request.args.get(\"order_by\", \"uri\")",
            "        uri_pattern = request.args.get(\"uri_pattern\", \"\")",
            "        lstripped_orderby = order_by.lstrip(\"-\")",
            "        updated_after = _safe_parse_datetime(request.args.get(\"updated_after\"), allow_empty=True)",
            "        updated_before = _safe_parse_datetime(request.args.get(\"updated_before\"), allow_empty=True)",
            "",
            "        # Check and clean up query parameters",
            "        limit = 50 if limit > 50 else limit",
            "",
            "        uri_pattern = uri_pattern[:4000]",
            "",
            "        if lstripped_orderby not in allowed_attrs:",
            "            return {",
            "                \"detail\": (",
            "                    f\"Ordering with '{lstripped_orderby}' is disallowed or the attribute does not \"",
            "                    \"exist on the model\"",
            "                )",
            "            }, 400",
            "",
            "        with create_session() as session:",
            "            if lstripped_orderby == \"uri\":",
            "                if order_by.startswith(\"-\"):",
            "                    order_by = (DatasetModel.uri.desc(),)",
            "                else:",
            "                    order_by = (DatasetModel.uri.asc(),)",
            "            elif lstripped_orderby == \"last_dataset_update\":",
            "                if order_by.startswith(\"-\"):",
            "                    order_by = (",
            "                        func.max(DatasetEvent.timestamp).desc(),",
            "                        DatasetModel.uri.asc(),",
            "                    )",
            "                    if session.bind.dialect.name == \"postgresql\":",
            "                        order_by = (order_by[0].nulls_last(), *order_by[1:])",
            "                else:",
            "                    order_by = (",
            "                        func.max(DatasetEvent.timestamp).asc(),",
            "                        DatasetModel.uri.desc(),",
            "                    )",
            "                    if session.bind.dialect.name == \"postgresql\":",
            "                        order_by = (order_by[0].nulls_first(), *order_by[1:])",
            "",
            "            count_query = session.query(func.count(DatasetModel.id))",
            "",
            "            has_event_filters = bool(updated_before or updated_after)",
            "",
            "            query = (",
            "                session.query(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                    func.max(DatasetEvent.timestamp).label(\"last_dataset_update\"),",
            "                    func.sum(case((DatasetEvent.id.is_not(None), 1), else_=0)).label(\"total_updates\"),",
            "                )",
            "                .join(DatasetEvent, DatasetEvent.dataset_id == DatasetModel.id, isouter=not has_event_filters)",
            "                .group_by(",
            "                    DatasetModel.id,",
            "                    DatasetModel.uri,",
            "                )",
            "                .order_by(*order_by)",
            "            )",
            "",
            "            if has_event_filters:",
            "                count_query = count_query.join(DatasetEvent, DatasetEvent.dataset_id == DatasetModel.id)",
            "",
            "            filters = [~DatasetModel.is_orphaned]",
            "            if uri_pattern:",
            "                filters.append(DatasetModel.uri.ilike(f\"%{uri_pattern}%\"))",
            "            if updated_after:",
            "                filters.append(DatasetEvent.timestamp >= updated_after)",
            "            if updated_before:",
            "                filters.append(DatasetEvent.timestamp <= updated_before)",
            "",
            "            query = query.filter(*filters).offset(offset).limit(limit)",
            "            count_query = count_query.filter(*filters)",
            "",
            "            datasets = [dict(dataset) for dataset in query]",
            "            data = {\"datasets\": datasets, \"total_entries\": count_query.scalar()}",
            "",
            "            return (",
            "                htmlsafe_json_dumps(data, separators=(\",\", \":\"), cls=utils_json.WebEncoder),",
            "                {\"Content-Type\": \"application/json; charset=utf-8\"},",
            "            )",
            "",
            "    @expose(\"/robots.txt\")",
            "    @action_logging",
            "    def robots(self):",
            "        \"\"\"",
            "        Returns a robots.txt file for blocking certain search engine crawlers. This mitigates some",
            "        of the risk associated with exposing Airflow to the public internet, however it does not",
            "        address the real security risks associated with such a deployment.",
            "        \"\"\"",
            "        return send_from_directory(get_airflow_app().static_folder, \"robots.txt\")",
            "",
            "    @expose(\"/audit_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_AUDIT_LOG),",
            "        ]",
            "    )",
            "    def legacy_audit_log(self):",
            "        \"\"\"Redirect from url param.\"\"\"",
            "        return redirect(url_for(\"Airflow.audit_log\", **sanitize_args(request.args)))",
            "",
            "    @expose(\"/dags/<string:dag_id>/audit_log\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_AUDIT_LOG),",
            "        ]",
            "    )",
            "    @provide_session",
            "    def audit_log(self, dag_id: str, session: Session = NEW_SESSION):",
            "        dag = get_airflow_app().dag_bag.get_dag(dag_id, session=session)",
            "        dag_model = DagModel.get_dagmodel(dag_id, session=session)",
            "        if not dag:",
            "            flash(f'DAG \"{dag_id}\" seems to be missing from DagBag.', \"error\")",
            "            return redirect(url_for(\"Airflow.index\"))",
            "",
            "        included_events_raw = conf.get(\"webserver\", \"audit_view_included_events\", fallback=None)",
            "        excluded_events_raw = conf.get(\"webserver\", \"audit_view_excluded_events\", fallback=None)",
            "",
            "        query = session.query(Log).filter(Log.dag_id == dag_id)",
            "        if included_events_raw:",
            "            included_events = {event.strip() for event in included_events_raw.split(\",\")}",
            "            query = query.filter(Log.event.in_(included_events))",
            "        elif excluded_events_raw:",
            "            excluded_events = {event.strip() for event in excluded_events_raw.split(\",\")}",
            "            query = query.filter(Log.event.notin_(excluded_events))",
            "",
            "        current_page = request.args.get(\"page\", default=0, type=int)",
            "        arg_sorting_key = request.args.get(\"sorting_key\", \"dttm\")",
            "        arg_sorting_direction = request.args.get(\"sorting_direction\", default=\"desc\")",
            "",
            "        logs_per_page = PAGE_SIZE",
            "        audit_logs_count = query.count()",
            "        num_of_pages = int(math.ceil(audit_logs_count / float(logs_per_page)))",
            "",
            "        start = current_page * logs_per_page",
            "        end = start + logs_per_page",
            "",
            "        sort_column = Log.__table__.c.get(arg_sorting_key)",
            "        if sort_column is not None:",
            "            if arg_sorting_direction == \"desc\":",
            "                sort_column = sort_column.desc()",
            "            query = query.order_by(sort_column)",
            "",
            "        dag_audit_logs = query.offset(start).limit(logs_per_page).all()",
            "        return self.render_template(",
            "            \"airflow/dag_audit_log.html\",",
            "            dag=dag,",
            "            dag_model=dag_model,",
            "            root=request.args.get(\"root\"),",
            "            dag_id=dag_id,",
            "            dag_logs=dag_audit_logs,",
            "            num_log_from=min(start + 1, audit_logs_count),",
            "            num_log_to=min(end, audit_logs_count),",
            "            audit_logs_count=audit_logs_count,",
            "            page_size=PAGE_SIZE,",
            "            paging=wwwutils.generate_pages(",
            "                current_page,",
            "                num_of_pages,",
            "                sorting_key=arg_sorting_key if arg_sorting_key else None,",
            "                sorting_direction=arg_sorting_direction if arg_sorting_direction else None,",
            "            ),",
            "            sorting_key=arg_sorting_key,",
            "            sorting_direction=arg_sorting_direction,",
            "        )",
            "",
            "",
            "class ConfigurationView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Configurations.\"\"\"",
            "",
            "    default_view = \"conf\"",
            "",
            "    class_permission_name = permissions.RESOURCE_CONFIG",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    @expose(\"/configuration\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CONFIG),",
            "        ]",
            "    )",
            "    def conf(self):",
            "        \"\"\"Shows configuration.\"\"\"",
            "        raw = request.args.get(\"raw\") == \"true\"",
            "        title = \"Airflow Configuration\"",
            "        expose_config = conf.get(\"webserver\", \"expose_config\").lower()",
            "",
            "        # TODO remove \"if raw\" usage in Airflow 3.0. Configuration can be fetched via the REST API.",
            "        if raw:",
            "            if expose_config == \"non-sensitive-only\":",
            "                updater = configupdater.ConfigUpdater()",
            "                updater.read(AIRFLOW_CONFIG)",
            "                for sect, key in conf.sensitive_config_values:",
            "                    if updater.has_option(sect, key):",
            "                        updater[sect][key].value = \"< hidden >\"",
            "                config = str(updater)",
            "            elif expose_config in {\"true\", \"t\", \"1\"}:",
            "                with open(AIRFLOW_CONFIG) as file:",
            "                    config = file.read()",
            "            else:",
            "                config = (",
            "                    \"# Your Airflow administrator chose not to expose the configuration, \"",
            "                    \"most likely for security reasons.\"",
            "                )",
            "",
            "            return Response(",
            "                response=config,",
            "                status=200,",
            "                mimetype=\"application/text\",",
            "                headers={\"Deprecation\": \"Endpoint will be removed in Airflow 3.0, use the REST API instead.\"},",
            "            )",
            "",
            "        if expose_config in {\"non-sensitive-only\", \"true\", \"t\", \"1\"}:",
            "            display_sensitive = expose_config != \"non-sensitive-only\"",
            "",
            "            table = [",
            "                (section, key, str(value), source)",
            "                for section, parameters in conf.as_dict(True, display_sensitive).items()",
            "                for key, (value, source) in parameters.items()",
            "            ]",
            "",
            "            return self.render_template(",
            "                template=\"airflow/config.html\",",
            "                title=title,",
            "                table=table,",
            "            )",
            "",
            "        else:",
            "            return self.render_template(",
            "                \"airflow/config.html\",",
            "                title=title,",
            "                hide_config_msg=(",
            "                    \"Your Airflow administrator chose not to expose the configuration, \"",
            "                    \"most likely for security reasons.\"",
            "                ),",
            "            )",
            "",
            "",
            "class RedocView(AirflowBaseView):",
            "    \"\"\"Redoc Open API documentation.\"\"\"",
            "",
            "    default_view = \"redoc\"",
            "",
            "    @expose(\"/redoc\")",
            "    def redoc(self):",
            "        \"\"\"Redoc API documentation.\"\"\"",
            "        openapi_spec_url = url_for(\"/api/v1./api/v1_openapi_yaml\")",
            "        return self.render_template(\"airflow/redoc.html\", openapi_spec_url=openapi_spec_url)",
            "",
            "",
            "######################################################################################",
            "#                                    ModelViews",
            "######################################################################################",
            "",
            "",
            "class DagFilter(BaseFilter):",
            "    \"\"\"Filter using DagIDs.\"\"\"",
            "",
            "    def apply(self, query, func):",
            "        if get_airflow_app().appbuilder.sm.has_all_dags_access(g.user):",
            "            return query",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "        return query.filter(self.model.dag_id.in_(filter_dag_ids))",
            "",
            "",
            "class AirflowModelView(ModelView):",
            "    \"\"\"Airflow Mode View.",
            "",
            "    Overridden `__getattribute__` to wraps REST methods with action_logger",
            "    \"\"\"",
            "",
            "    list_widget = AirflowModelListWidget",
            "    page_size = PAGE_SIZE",
            "",
            "    CustomSQLAInterface = wwwutils.CustomSQLAInterface",
            "",
            "    def __getattribute__(self, attr):",
            "        \"\"\"Wraps action REST methods with `action_logging` wrapper",
            "        Overriding enables differentiating resource and generation of event name at the decorator level.",
            "",
            "        if attr in [\"show\", \"list\", \"read\", \"get\", \"get_list\"]:",
            "            return action_logging(event=\"RESOURCE_NAME\".\"action_name\")(attr)",
            "        else:",
            "            return attr",
            "        \"\"\"",
            "        attribute = object.__getattribute__(self, attr)",
            "        if (",
            "            callable(attribute)",
            "            and hasattr(attribute, \"_permission_name\")",
            "            and attribute._permission_name in self.method_permission_name",
            "        ):",
            "            permission_str = self.method_permission_name[attribute._permission_name]",
            "            if permission_str not in [\"show\", \"list\", \"read\", \"get\", \"get_list\"]:",
            "                return action_logging(event=f\"{self.route_base.strip('/')}.{permission_str}\")(attribute)",
            "        return attribute",
            "",
            "",
            "class AirflowPrivilegeVerifierModelView(AirflowModelView):",
            "    \"\"\"",
            "    This ModelView prevents ability to pass primary keys of objects relating to DAGs you shouldn't be able to",
            "    edit. This only holds for the add, update and delete operations.",
            "    You will still need to use the `action_has_dag_edit_access()` for actions.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def validate_dag_edit_access(item: DagRun | TaskInstance):",
            "        \"\"\"Validates whether the user has 'can_edit' access for this specific DAG.\"\"\"",
            "        if not get_airflow_app().appbuilder.sm.can_edit_dag(item.dag_id):",
            "            raise AirflowException(f\"Access denied for dag_id {item.dag_id}\")",
            "",
            "    def pre_add(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def pre_update(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def pre_delete(self, item: DagRun | TaskInstance):",
            "        self.validate_dag_edit_access(item)",
            "",
            "    def post_add_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "    def post_edit_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "    def post_delete_redirect(self):  # Required to prevent redirect loop",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "def action_has_dag_edit_access(action_func: Callable) -> Callable:",
            "    \"\"\"Decorator for actions which verifies you have DAG edit access on the given tis/drs.\"\"\"",
            "",
            "    @wraps(action_func)",
            "    def check_dag_edit_acl_for_actions(",
            "        self,",
            "        items: list[TaskInstance] | list[DagRun] | TaskInstance | DagRun | None,",
            "        *args,",
            "        **kwargs,",
            "    ) -> Callable:",
            "        if items is None:",
            "            dag_ids: set[str] = set()",
            "        elif isinstance(items, list):",
            "            dag_ids = {item.dag_id for item in items if item is not None}",
            "        elif isinstance(items, TaskInstance) or isinstance(items, DagRun):",
            "            dag_ids = {items.dag_id}",
            "        else:",
            "            raise ValueError(",
            "                \"Was expecting the first argument of the action to be of type \"",
            "                \"list[TaskInstance] | list[DagRun] | TaskInstance | DagRun | None.\"",
            "                f\"Was of type: {type(items)}\"",
            "            )",
            "",
            "        for dag_id in dag_ids:",
            "            if not get_airflow_app().appbuilder.sm.can_edit_dag(dag_id):",
            "                flash(f\"Access denied for dag_id {dag_id}\", \"danger\")",
            "                logging.warning(\"User %s tried to modify %s without having access.\", g.user.username, dag_id)",
            "                return redirect(self.get_default_url())",
            "        return action_func(self, items, *args, **kwargs)",
            "",
            "    return check_dag_edit_acl_for_actions",
            "",
            "",
            "class SlaMissModelView(AirflowModelView):",
            "    \"\"\"View to show SlaMiss table.\"\"\"",
            "",
            "    route_base = \"/slamiss\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(SlaMiss)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_SLA_MISS",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    add_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "    edit_columns = [\"dag_id\", \"task_id\", \"execution_date\", \"email_sent\", \"notification_sent\", \"timestamp\"]",
            "    search_columns = [\"dag_id\", \"task_id\", \"email_sent\", \"notification_sent\", \"timestamp\", \"execution_date\"]",
            "    base_order = (\"execution_date\", \"desc\")",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"timestamp\": wwwutils.datetime_f(\"timestamp\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete action.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(",
            "        \"mulnotificationsent\",",
            "        \"Set notification sent to true\",",
            "        \"Are you sure you want to set all these notifications to sent?\",",
            "        single=False,",
            "    )",
            "    def action_mulnotificationsent(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"notification_sent\", True)",
            "",
            "    @action(",
            "        \"mulnotificationsentfalse\",",
            "        \"Set notification sent to false\",",
            "        \"Are you sure you want to mark these SLA alerts as notification not sent yet?\",",
            "        single=False,",
            "    )",
            "    def action_mulnotificationsentfalse(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"notification_sent\", False)",
            "",
            "    @action(",
            "        \"mulemailsent\",",
            "        \"Set email sent to true\",",
            "        \"Are you sure you want to mark these SLA alerts as emails were sent?\",",
            "        single=False,",
            "    )",
            "    def action_mulemailsent(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"email_sent\", True)",
            "",
            "    @action(",
            "        \"mulemailsentfalse\",",
            "        \"Set email sent to false\",",
            "        \"Are you sure you want to mark these SLA alerts as emails not sent yet?\",",
            "        single=False,",
            "    )",
            "    def action_mulemailsentfalse(self, items: list[SlaMiss]):",
            "        return self._set_notification_property(items, \"email_sent\", False)",
            "",
            "    @provide_session",
            "    def _set_notification_property(",
            "        self,",
            "        items: list[SlaMiss],",
            "        attr: str,",
            "        new_value: bool,",
            "        session: Session = NEW_SESSION,",
            "    ):",
            "        try:",
            "            count = 0",
            "            for sla in items:",
            "                count += 1",
            "                setattr(sla, attr, new_value)",
            "                session.merge(sla)",
            "            session.commit()",
            "            flash(f\"{count} SLAMisses had {attr} set to {new_value}.\")",
            "        except Exception as ex:",
            "            flash(str(ex), \"error\")",
            "            flash(\"Failed to set state\", \"error\")",
            "        self.update_redirect()",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "class XComModelView(AirflowModelView):",
            "    \"\"\"View to show records from XCom table.\"\"\"",
            "",
            "    route_base = \"/xcom\"",
            "",
            "    list_title = \"List XComs\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(XCom)",
            "",
            "    class_permission_name = permissions.RESOURCE_XCOM",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    search_columns = [\"key\", \"value\", \"timestamp\", \"dag_id\", \"task_id\", \"run_id\", \"execution_date\"]",
            "    list_columns = [\"key\", \"value\", \"timestamp\", \"dag_id\", \"task_id\", \"run_id\", \"map_index\", \"execution_date\"]",
            "    base_order = (\"dag_run_id\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"timestamp\": wwwutils.datetime_f(\"timestamp\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete action.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    def pre_add(self, item):",
            "        \"\"\"Pre add hook.\"\"\"",
            "        item.execution_date = timezone.make_aware(item.execution_date)",
            "        item.value = XCom.serialize_value(",
            "            value=item.value,",
            "            key=item.key,",
            "            task_id=item.task_id,",
            "            dag_id=item.dag_id,",
            "            run_id=item.run_id,",
            "            map_index=item.map_index,",
            "        )",
            "",
            "    def pre_update(self, item):",
            "        \"\"\"Pre update hook.\"\"\"",
            "        item.execution_date = timezone.make_aware(item.execution_date)",
            "        item.value = XCom.serialize_value(",
            "            value=item.value,",
            "            key=item.key,",
            "            task_id=item.task_id,",
            "            dag_id=item.dag_id,",
            "            run_id=item.run_id,",
            "            map_index=item.map_index,",
            "        )",
            "",
            "",
            "# Used to store a dictionary of field behaviours used to dynamically change available",
            "# fields in ConnectionForm based on type of connection chosen",
            "# See airflow.hooks.base_hook.DiscoverableHook for details on how to customize your Hooks.",
            "#",
            "# Additionally, a list of connection types that support testing via Airflow REST API is stored to dynamically",
            "# enable/disable the Test Connection button.",
            "#",
            "# These field behaviours and testable connection types are rendered as scripts in the conn_create.html and",
            "# conn_edit.html templates.",
            "class ConnectionFormWidget(FormWidget):",
            "    \"\"\"Form widget used to display connection.\"\"\"",
            "",
            "    @cached_property",
            "    def field_behaviours(self) -> str:",
            "        return json.dumps(ProvidersManager().field_behaviours)",
            "",
            "    @cached_property",
            "    def testable_connection_types(self) -> list[str]:",
            "        return [",
            "            connection_type",
            "            for connection_type, hook_info in ProvidersManager().hooks.items()",
            "            if hook_info and hook_info.connection_testable",
            "        ]",
            "",
            "",
            "class ConnectionFormProxy:",
            "    \"\"\"A stand-in for the connection form class.",
            "",
            "    Flask-Appbuilder model views only ever call the ``refresh()`` function on",
            "    the form class, so this is the perfect place to make the form generation",
            "    dynamic. See docstring of ``create_connection_form_class`` for rationales.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def refresh(obj=None):",
            "        return create_connection_form_class().refresh(obj)",
            "",
            "",
            "class ConnectionModelView(AirflowModelView):",
            "    \"\"\"View to show records from Connections table.\"\"\"",
            "",
            "    route_base = \"/connection\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Connection)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_CONNECTION",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_mulduplicate\": \"create\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"conn_id\",",
            "        \"conn_type\",",
            "        \"description\",",
            "        \"host\",",
            "        \"port\",",
            "        \"is_encrypted\",",
            "        \"is_extra_encrypted\",",
            "    ]",
            "",
            "    # The real add_columns and edit_columns are dynamically generated at runtime",
            "    # so we can delay calculating entries relying on providers to make webserver",
            "    # start up faster.",
            "    _add_columns = _edit_columns = [",
            "        \"conn_id\",",
            "        \"conn_type\",",
            "        \"description\",",
            "        \"host\",",
            "        \"schema\",",
            "        \"login\",",
            "        \"password\",",
            "        \"port\",",
            "        \"extra\",",
            "    ]",
            "",
            "    # We will generate the actual ConnectionForm when it is actually needed,",
            "    # i.e. when the web form views are displayed and submitted.",
            "    add_form = edit_form = ConnectionFormProxy",
            "",
            "    add_template = \"airflow/conn_create.html\"",
            "    edit_template = \"airflow/conn_edit.html\"",
            "",
            "    add_widget = ConnectionFormWidget",
            "    edit_widget = ConnectionFormWidget",
            "",
            "    base_order = (\"conn_id\", \"asc\")",
            "",
            "    def _iter_extra_field_names(self) -> Iterator[tuple[str, str]]:",
            "        \"\"\"Iterate through provider-backed connection fields.",
            "",
            "        Note that this cannot be a property (including a cached property)",
            "        because Flask-Appbuilder attempts to access all members on startup, and",
            "        using a property would initialize the providers manager too eagerly.",
            "        \"\"\"",
            "        return ((k, v.field_name) for k, v in ProvidersManager().connection_form_widgets.items())",
            "",
            "    @property",
            "    def add_columns(self) -> list[str]:",
            "        \"\"\"A list of columns to show in the Add form.",
            "",
            "        This dynamically calculates additional fields from providers and add",
            "        them to the backing list. This calculation is done exactly once (by",
            "        checking we're referencing the class-level variable instead of the",
            "        instance-level), and only after we enter the request context (to skip",
            "        superfuluous checks done by Flask-Appbuilder on startup).",
            "        \"\"\"",
            "        if self._add_columns is type(self)._add_columns and has_request_context():",
            "            self._add_columns = [*self._add_columns, *(k for k, _ in self._iter_extra_field_names())]",
            "        return self._add_columns",
            "",
            "    @property",
            "    def edit_columns(self) -> list[str]:",
            "        \"\"\"A list of columns to show in the Edit form.",
            "",
            "        This dynamically calculates additional fields from providers and add",
            "        them to the backing list. This calculation is done exactly once (by",
            "        checking we're referencing the class-level variable instead of the",
            "        instance-level), and only after we enter the request context (to skip",
            "        superfuluous checks done by Flask-Appbuilder on startup).",
            "        \"\"\"",
            "        if self._edit_columns is type(self)._edit_columns and has_request_context():",
            "            self._edit_columns = [*self._edit_columns, *(k for k, _ in self._iter_extra_field_names())]",
            "        return self._edit_columns",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_EDIT, permissions.RESOURCE_DAG),",
            "        ]",
            "    )",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(",
            "        \"mulduplicate\",",
            "        \"Duplicate\",",
            "        \"Are you sure you want to duplicate the selected connections?\",",
            "        single=False,",
            "    )",
            "    @provide_session",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_CREATE, permissions.RESOURCE_CONNECTION),",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_CONNECTION),",
            "        ]",
            "    )",
            "    def action_mulduplicate(self, connections, session: Session = NEW_SESSION):",
            "        \"\"\"Duplicate Multiple connections.\"\"\"",
            "        for selected_conn in connections:",
            "            new_conn_id = selected_conn.conn_id",
            "            match = re.search(r\"_copy(\\d+)$\", selected_conn.conn_id)",
            "",
            "            base_conn_id = selected_conn.conn_id",
            "            if match:",
            "                base_conn_id = base_conn_id.split(\"_copy\")[0]",
            "",
            "            potential_connection_ids = [f\"{base_conn_id}_copy{i}\" for i in range(1, 11)]",
            "",
            "            query = session.query(Connection.conn_id).filter(Connection.conn_id.in_(potential_connection_ids))",
            "",
            "            found_conn_id_set = {conn_id for conn_id, in query}",
            "",
            "            possible_conn_id_iter = (",
            "                connection_id",
            "                for connection_id in potential_connection_ids",
            "                if connection_id not in found_conn_id_set",
            "            )",
            "            try:",
            "                new_conn_id = next(possible_conn_id_iter)",
            "            except StopIteration:",
            "                flash(",
            "                    f\"Connection {new_conn_id} can't be added because it already exists, \"",
            "                    f\"Please rename the existing connections\",",
            "                    \"warning\",",
            "                )",
            "            else:",
            "                dup_conn = Connection(",
            "                    new_conn_id,",
            "                    selected_conn.conn_type,",
            "                    selected_conn.description,",
            "                    selected_conn.host,",
            "                    selected_conn.login,",
            "                    selected_conn.password,",
            "                    selected_conn.schema,",
            "                    selected_conn.port,",
            "                    selected_conn.extra,",
            "                )",
            "",
            "                try:",
            "                    session.add(dup_conn)",
            "                    session.commit()",
            "                    flash(f\"Connection {new_conn_id} added successfully.\", \"success\")",
            "                except IntegrityError:",
            "                    flash(",
            "                        f\"Connection {new_conn_id} can't be added. Integrity error, \"",
            "                        f\"probably unique constraint.\",",
            "                        \"warning\",",
            "                    )",
            "                    session.rollback()",
            "",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    def process_form(self, form, is_created):",
            "        \"\"\"Process form data.\"\"\"",
            "        conn_id = form.data[\"conn_id\"]",
            "        conn_type = form.data[\"conn_type\"]",
            "",
            "        # The extra value is the combination of custom fields for this conn_type and the Extra field.",
            "        # The extra form field with all extra values (including custom fields) is in the form being processed",
            "        # so we start with those values, and override them with anything in the custom fields.",
            "        extra = {}",
            "",
            "        extra_json = form.data.get(\"extra\")",
            "",
            "        if extra_json:",
            "            try:",
            "                extra.update(json.loads(extra_json))",
            "            except (JSONDecodeError, TypeError):",
            "                flash(",
            "                    Markup(",
            "                        \"<p>The <em>Extra</em> connection field contained an invalid value for Conn ID: \"",
            "                        \"<q>{conn_id}</q>.</p>\"",
            "                        \"<p>If connection parameters need to be added to <em>Extra</em>, \"",
            "                        \"please make sure they are in the form of a single, valid JSON object.</p><br>\"",
            "                        \"The following <em>Extra</em> parameters were <b>not</b> added to the connection:<br>\"",
            "                        \"{extra_json}\"",
            "                    ).format(conn_id=conn_id, extra_json=extra_json),",
            "                    category=\"error\",",
            "                )",
            "                del form.extra",
            "        del extra_json",
            "",
            "        for key, field_name in self._iter_extra_field_names():",
            "            if key in form.data and key.startswith(\"extra__\"):",
            "                conn_type_from_extra_field = key.split(\"__\")[1]",
            "                if conn_type_from_extra_field == conn_type:",
            "                    value = form.data[key]",
            "                    # Some extra fields have a default value of False so we need to explicitly check the",
            "                    # value isn't an empty string.",
            "                    if value != \"\":",
            "                        extra[field_name] = value",
            "",
            "        if extra.keys():",
            "            form.extra.data = json.dumps(extra)",
            "",
            "    def prefill_form(self, form, pk):",
            "        \"\"\"Prefill the form.\"\"\"",
            "        try:",
            "            extra = form.data.get(\"extra\")",
            "            if extra is None:",
            "                extra_dictionary = {}",
            "            else:",
            "                extra_dictionary = json.loads(extra)",
            "        except JSONDecodeError:",
            "            extra_dictionary = {}",
            "",
            "        if not isinstance(extra_dictionary, dict):",
            "            logging.warning(\"extra field for %s is not a dictionary\", form.data.get(\"conn_id\", \"<unknown>\"))",
            "            return",
            "",
            "        for field_key, field_name in self._iter_extra_field_names():",
            "            value = extra_dictionary.get(field_name, \"\")",
            "",
            "            if not value:",
            "                # check if connection `extra` json is using old prefixed field name style",
            "                value = extra_dictionary.get(field_key, \"\")",
            "",
            "            if value:",
            "                field = getattr(form, field_key)",
            "                field.data = value",
            "",
            "",
            "class PluginView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Plugins.\"\"\"",
            "",
            "    default_view = \"list\"",
            "",
            "    class_permission_name = permissions.RESOURCE_PLUGIN",
            "",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    plugins_attributes_to_dump = [",
            "        \"hooks\",",
            "        \"executors\",",
            "        \"macros\",",
            "        \"admin_views\",",
            "        \"flask_blueprints\",",
            "        \"menu_links\",",
            "        \"appbuilder_views\",",
            "        \"appbuilder_menu_items\",",
            "        \"global_operator_extra_links\",",
            "        \"operator_extra_links\",",
            "        \"source\",",
            "    ]",
            "",
            "    @expose(\"/plugin\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_PLUGIN),",
            "        ]",
            "    )",
            "    def list(self):",
            "        \"\"\"List loaded plugins.\"\"\"",
            "        plugins_manager.ensure_plugins_loaded()",
            "        plugins_manager.integrate_executor_plugins()",
            "        plugins_manager.initialize_extra_operators_links_plugins()",
            "        plugins_manager.initialize_web_ui_plugins()",
            "",
            "        plugins = []",
            "        for plugin_no, plugin in enumerate(plugins_manager.plugins, 1):",
            "            plugin_data = {",
            "                \"plugin_no\": plugin_no,",
            "                \"plugin_name\": plugin.name,",
            "                \"attrs\": {},",
            "            }",
            "            for attr_name in self.plugins_attributes_to_dump:",
            "                attr_value = getattr(plugin, attr_name)",
            "                plugin_data[\"attrs\"][attr_name] = attr_value",
            "",
            "            plugins.append(plugin_data)",
            "",
            "        title = \"Airflow Plugins\"",
            "        doc_url = get_docs_url(\"plugins.html\")",
            "        return self.render_template(",
            "            \"airflow/plugin.html\",",
            "            plugins=plugins,",
            "            title=title,",
            "            doc_url=doc_url,",
            "        )",
            "",
            "",
            "class ProviderView(AirflowBaseView):",
            "    \"\"\"View to show Airflow Providers.\"\"\"",
            "",
            "    default_view = \"list\"",
            "",
            "    class_permission_name = permissions.RESOURCE_PROVIDER",
            "",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    @expose(\"/provider\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_PROVIDER),",
            "        ]",
            "    )",
            "    def list(self):",
            "        \"\"\"List providers.\"\"\"",
            "        providers_manager = ProvidersManager()",
            "",
            "        providers = []",
            "        for pi in providers_manager.providers.values():",
            "            provider_info = pi.data",
            "            provider_data = {",
            "                \"package_name\": provider_info[\"package-name\"],",
            "                \"description\": self._clean_description(provider_info[\"description\"]),",
            "                \"version\": pi.version,",
            "                \"documentation_url\": get_doc_url_for_provider(provider_info[\"package-name\"], pi.version),",
            "            }",
            "            providers.append(provider_data)",
            "",
            "        title = \"Providers\"",
            "        doc_url = get_docs_url(\"apache-airflow-providers/index.html\")",
            "        return self.render_template(",
            "            \"airflow/providers.html\",",
            "            providers=providers,",
            "            title=title,",
            "            doc_url=doc_url,",
            "        )",
            "",
            "    def _clean_description(self, description):",
            "        def _build_link(match_obj):",
            "            text = match_obj.group(1)",
            "            url = match_obj.group(2)",
            "            return Markup(f'<a href=\"{url}\">{text}</a>')",
            "",
            "        cd = escape(description)",
            "        cd = re.sub(r\"`(.*)[\\s+]+&lt;(.*)&gt;`__\", _build_link, cd)",
            "        cd = re.sub(r\"\\n\", r\"<br>\", cd)",
            "        return Markup(cd)",
            "",
            "",
            "class PoolModelView(AirflowModelView):",
            "    \"\"\"View to show records from Pool table.\"\"\"",
            "",
            "    route_base = \"/pool\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Pool)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_POOL",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"pool\", \"slots\", \"running_slots\", \"queued_slots\", \"scheduled_slots\"]",
            "    add_columns = [\"pool\", \"slots\", \"description\"]",
            "    edit_columns = [\"pool\", \"slots\", \"description\"]",
            "",
            "    base_order = (\"pool\", \"asc\")",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        if any(item.pool == models.Pool.DEFAULT_POOL_NAME for item in items):",
            "            flash(f\"{models.Pool.DEFAULT_POOL_NAME} cannot be deleted\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @expose(\"/delete/<pk>\", methods=[\"GET\", \"POST\"])",
            "    @has_access",
            "    def delete(self, pk):",
            "        \"\"\"Single delete.\"\"\"",
            "        if models.Pool.is_default_pool(pk):",
            "            flash(f\"{models.Pool.DEFAULT_POOL_NAME} cannot be deleted\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "",
            "        return super().delete(pk)",
            "",
            "    def pool_link(self):",
            "        \"\"\"Pool link rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        if pool_id is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id)",
            "            return Markup(\"<a href='{url}'>{pool_id}</a>\").format(url=url, pool_id=pool_id)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def frunning_slots(self):",
            "        \"\"\"Running slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        running_slots = self.get(\"running_slots\")",
            "        if pool_id is not None and running_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"running\")",
            "            return Markup(\"<a href='{url}'>{running_slots}</a>\").format(url=url, running_slots=running_slots)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def fqueued_slots(self):",
            "        \"\"\"Queued slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        queued_slots = self.get(\"queued_slots\")",
            "        if pool_id is not None and queued_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"queued\")",
            "            return Markup(\"<a href='{url}'>{queued_slots}</a>\").format(url=url, queued_slots=queued_slots)",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    def fscheduled_slots(self):",
            "        \"\"\"Scheduled slots rendering.\"\"\"",
            "        pool_id = self.get(\"pool\")",
            "        scheduled_slots = self.get(\"scheduled_slots\")",
            "        if pool_id is not None and scheduled_slots is not None:",
            "            url = url_for(\"TaskInstanceModelView.list\", _flt_3_pool=pool_id, _flt_3_state=\"scheduled\")",
            "            return Markup(\"<a href='{url}'>{scheduled_slots}</a>\").format(",
            "                url=url, scheduled_slots=scheduled_slots",
            "            )",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    formatters_columns = {",
            "        \"pool\": pool_link,",
            "        \"running_slots\": frunning_slots,",
            "        \"queued_slots\": fqueued_slots,",
            "        \"scheduled_slots\": fscheduled_slots,",
            "    }",
            "",
            "    validators_columns = {\"pool\": [validators.DataRequired()], \"slots\": [validators.NumberRange(min=-1)]}",
            "",
            "",
            "def _can_create_variable() -> bool:",
            "    return get_airflow_app().appbuilder.sm.has_access(",
            "        permissions.ACTION_CAN_CREATE, permissions.RESOURCE_VARIABLE",
            "    )",
            "",
            "",
            "class VariableModelView(AirflowModelView):",
            "    \"\"\"View to show records from Variable table.\"\"\"",
            "",
            "    route_base = \"/variable\"",
            "",
            "    list_template = \"airflow/variable_list.html\"",
            "    edit_template = \"airflow/variable_edit.html\"",
            "    show_template = \"airflow/variable_show.html\"",
            "",
            "    show_widget = AirflowVariableShowWidget",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Variable)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_VARIABLE",
            "    method_permission_name = {",
            "        \"add\": \"create\",",
            "        \"list\": \"read\",",
            "        \"edit\": \"edit\",",
            "        \"show\": \"read\",",
            "        \"delete\": \"delete\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_varexport\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"key\", \"val\", \"description\", \"is_encrypted\"]",
            "    add_columns = [\"key\", \"val\", \"description\"]",
            "    edit_columns = [\"key\", \"val\", \"description\"]",
            "    show_columns = [\"key\", \"val\", \"description\"]",
            "    search_columns = [\"key\", \"val\"]",
            "",
            "    base_order = (\"key\", \"asc\")",
            "",
            "    def hidden_field_formatter(self):",
            "        \"\"\"Formats hidden fields.\"\"\"",
            "        key = self.get(\"key\")",
            "        val = self.get(\"val\")",
            "        if secrets_masker.should_hide_value_for_key(key):",
            "            return Markup(\"*\" * 8)",
            "        if val:",
            "            return val",
            "        else:",
            "            return Markup('<span class=\"label label-danger\">Invalid</span>')",
            "",
            "    formatters_columns = {",
            "        \"val\": hidden_field_formatter,",
            "    }",
            "",
            "    validators_columns = {\"key\": [validators.DataRequired()]}",
            "",
            "    def prefill_form(self, form, request_id):",
            "        if secrets_masker.should_hide_value_for_key(form.key.data):",
            "            form.val.data = \"*\" * 8",
            "",
            "    def prefill_show(self, item):",
            "        if secrets_masker.should_hide_value_for_key(item.key):",
            "            item.val = \"*\" * 8",
            "",
            "    def _show(self, pk):",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        self.prefill_show(item)",
            "        widgets = self._get_show_widget(pk, item)",
            "        self.update_redirect()",
            "",
            "        return self._get_related_views_widgets(",
            "            item, orders=orders, pages=pages, page_sizes=page_sizes, widgets=widgets",
            "        )",
            "",
            "    extra_args = {\"can_create_variable\": _can_create_variable}",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    def action_muldelete(self, items):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"varexport\", \"Export\", \"\", single=False)",
            "    def action_varexport(self, items):",
            "        \"\"\"Export variables.\"\"\"",
            "        var_dict = {}",
            "        decoder = json.JSONDecoder()",
            "        for var in items:",
            "            try:",
            "                val = decoder.decode(var.val)",
            "            except Exception:",
            "                val = var.val",
            "            var_dict[var.key] = val",
            "",
            "        response = make_response(json.dumps(var_dict, sort_keys=True, indent=4))",
            "        response.headers[\"Content-Disposition\"] = \"attachment; filename=variables.json\"",
            "        response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "        return response",
            "",
            "    @expose(\"/varimport\", methods=[\"POST\"])",
            "    @auth.has_access([(permissions.ACTION_CAN_CREATE, permissions.RESOURCE_VARIABLE)])",
            "    @action_logging(event=f\"{permissions.RESOURCE_VARIABLE.lower()}.varimport\")",
            "    def varimport(self):",
            "        \"\"\"Import variables.\"\"\"",
            "        try:",
            "            variable_dict = json.loads(request.files[\"file\"].read())",
            "        except Exception:",
            "            self.update_redirect()",
            "            flash(\"Missing file or syntax error.\", \"error\")",
            "            return redirect(self.get_redirect())",
            "        else:",
            "            suc_count = fail_count = 0",
            "            for k, v in variable_dict.items():",
            "                try:",
            "                    models.Variable.set(k, v, serialize_json=not isinstance(v, str))",
            "                except Exception as e:",
            "                    logging.info(\"Variable import failed: %s\", repr(e))",
            "                    fail_count += 1",
            "                else:",
            "                    suc_count += 1",
            "            flash(f\"{suc_count} variable(s) successfully updated.\")",
            "            if fail_count:",
            "                flash(f\"{fail_count} variable(s) failed to be updated.\", \"error\")",
            "            self.update_redirect()",
            "            return redirect(self.get_redirect())",
            "",
            "",
            "class JobModelView(AirflowModelView):",
            "    \"\"\"View to show records from Job table.\"\"\"",
            "",
            "    route_base = \"/job\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Job)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_JOB",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"state\",",
            "        \"job_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"latest_heartbeat\",",
            "        \"executor_class\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "    ]",
            "    search_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"state\",",
            "        \"job_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"latest_heartbeat\",",
            "        \"executor_class\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "    ]",
            "",
            "    base_order = (\"start_date\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"hostname\": wwwutils.nobr_f(\"hostname\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"latest_heartbeat\": wwwutils.datetime_f(\"latest_heartbeat\"),",
            "    }",
            "",
            "",
            "class DagRunModelView(AirflowPrivilegeVerifierModelView):",
            "    \"\"\"View to show records from DagRun table.\"\"\"",
            "",
            "    route_base = \"/dagrun\"",
            "",
            "    datamodel = wwwutils.DagRunCustomSQLAInterface(models.DagRun)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_DAG_RUN",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"action_clear\": \"edit\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_set_queued\": \"edit\",",
            "        \"action_set_running\": \"edit\",",
            "        \"action_set_failed\": \"edit\",",
            "        \"action_set_success\": \"edit\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"queued_at\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"external_trigger\",",
            "        \"conf\",",
            "        \"duration\",",
            "    ]",
            "    search_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"external_trigger\",",
            "    ]",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "    edit_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"run_id\",",
            "        \"conf\",",
            "        \"note\",",
            "    ]",
            "",
            "    # duration is not a DB column, its derived",
            "    order_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"execution_date\",",
            "        \"run_id\",",
            "        \"run_type\",",
            "        \"queued_at\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        # \"note\", # todo: maybe figure out how to re-enable this",
            "        \"external_trigger\",",
            "        \"conf\",",
            "    ]",
            "",
            "    base_order = (\"execution_date\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    edit_form = DagRunEditForm",
            "",
            "    def duration_f(self):",
            "        \"\"\"Duration calculation.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        start_date = self.get(\"start_date\")",
            "",
            "        difference = \"0s\"",
            "        if start_date and end_date:",
            "            difference = td_format(end_date - start_date)",
            "",
            "        return difference",
            "",
            "    formatters_columns = {",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"queued_at\": wwwutils.datetime_f(\"queued_at\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"run_id\": wwwutils.dag_run_link,",
            "        \"conf\": wwwutils.json_f(\"conf\"),",
            "        \"duration\": duration_f,",
            "    }",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_muldelete(self, items: list[DagRun]):",
            "        \"\"\"Multiple delete.\"\"\"",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_queued\", \"Set state to 'queued'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_queued(self, drs: list[DagRun]):",
            "        \"\"\"Set state to queued.\"\"\"",
            "        return self._set_dag_runs_to_active_state(drs, State.QUEUED)",
            "",
            "    @action(\"set_running\", \"Set state to 'running'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_running(self, drs: list[DagRun]):",
            "        \"\"\"Set state to running.\"\"\"",
            "        return self._set_dag_runs_to_active_state(drs, State.RUNNING)",
            "",
            "    @provide_session",
            "    def _set_dag_runs_to_active_state(self, drs: list[DagRun], state: str, session: Session = NEW_SESSION):",
            "        \"\"\"This routine only supports Running and Queued state.\"\"\"",
            "        try:",
            "            count = 0",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                if state == State.RUNNING:",
            "                    dr.start_date = timezone.utcnow()",
            "                dr.state = state",
            "            session.commit()",
            "            flash(f\"{count} dag runs were set to {state}.\")",
            "        except Exception as ex:",
            "            flash(str(ex), \"error\")",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(",
            "        \"set_failed\",",
            "        \"Set state to 'failed'\",",
            "        \"All running task instances would also be marked as failed, are you sure?\",",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_set_failed(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Set state to failed.\"\"\"",
            "        try:",
            "            count = 0",
            "            altered_tis = []",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                altered_tis += set_dag_run_state_to_failed(",
            "                    dag=get_airflow_app().dag_bag.get_dag(dr.dag_id),",
            "                    run_id=dr.run_id,",
            "                    commit=True,",
            "                    session=session,",
            "                )",
            "            altered_ti_count = len(altered_tis)",
            "            flash(f\"{count} dag runs and {altered_ti_count} task instances were set to failed\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(",
            "        \"set_success\",",
            "        \"Set state to 'success'\",",
            "        \"All task instances would also be marked as success, are you sure?\",",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_set_success(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Set state to success.\"\"\"",
            "        try:",
            "            count = 0",
            "            altered_tis = []",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                altered_tis += set_dag_run_state_to_success(",
            "                    dag=get_airflow_app().dag_bag.get_dag(dr.dag_id),",
            "                    run_id=dr.run_id,",
            "                    commit=True,",
            "                    session=session,",
            "                )",
            "            altered_ti_count = len(altered_tis)",
            "            flash(f\"{count} dag runs and {altered_ti_count} task instances were set to success\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "    @action(\"clear\", \"Clear the state\", \"All task instances would be cleared, are you sure?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_clear(self, drs: list[DagRun], session: Session = NEW_SESSION):",
            "        \"\"\"Clears the state.\"\"\"",
            "        try:",
            "            count = 0",
            "            cleared_ti_count = 0",
            "            dag_to_tis: dict[DAG, list[TaskInstance]] = {}",
            "            for dr in session.query(DagRun).filter(DagRun.id.in_(dagrun.id for dagrun in drs)):",
            "                count += 1",
            "                dag = get_airflow_app().dag_bag.get_dag(dr.dag_id)",
            "                tis_to_clear = dag_to_tis.setdefault(dag, [])",
            "                tis_to_clear += dr.get_task_instances()",
            "",
            "            for dag, tis in dag_to_tis.items():",
            "                cleared_ti_count += len(tis)",
            "                models.clear_task_instances(tis, session, dag=dag)",
            "",
            "            flash(f\"{count} dag runs and {cleared_ti_count} task instances were cleared\")",
            "        except Exception:",
            "            flash(\"Failed to clear state\", \"error\")",
            "        return redirect(self.get_default_url())",
            "",
            "",
            "class LogModelView(AirflowModelView):",
            "    \"\"\"View to show records from Log table.\"\"\"",
            "",
            "    route_base = \"/log\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(Log)  # type:ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_AUDIT_LOG",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [\"id\", \"dttm\", \"dag_id\", \"task_id\", \"event\", \"execution_date\", \"owner\", \"extra\"]",
            "    search_columns = [\"dttm\", \"dag_id\", \"task_id\", \"event\", \"execution_date\", \"owner\", \"extra\"]",
            "",
            "    label_columns = {",
            "        \"execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    base_order = (\"dttm\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    formatters_columns = {",
            "        \"dttm\": wwwutils.datetime_f(\"dttm\"),",
            "        \"execution_date\": wwwutils.datetime_f(\"execution_date\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "    }",
            "",
            "",
            "class TaskRescheduleModelView(AirflowModelView):",
            "    \"\"\"View to show records from Task Reschedule table.\"\"\"",
            "",
            "    route_base = \"/taskreschedule\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskReschedule)  # type: ignore",
            "    related_views = [DagRunModelView]",
            "",
            "    class_permission_name = permissions.RESOURCE_TASK_RESCHEDULE",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"dag_id\",",
            "        \"run_id\",",
            "        \"dag_run.execution_date\",",
            "        \"task_id\",",
            "        \"map_index\",",
            "        \"try_number\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        \"reschedule_date\",",
            "    ]",
            "",
            "    label_columns = {",
            "        \"dag_run.execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    search_columns = [",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"reschedule_date\",",
            "    ]",
            "",
            "    base_order = (\"id\", \"desc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    def duration_f(self):",
            "        \"\"\"Duration calculation.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        duration = self.get(\"duration\")",
            "        if end_date and duration:",
            "            return td_format(datetime.timedelta(seconds=duration))",
            "        return None",
            "",
            "    formatters_columns = {",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"dag_run.execution_date\": wwwutils.datetime_f(\"dag_run.execution_date\"),",
            "        \"reschedule_date\": wwwutils.datetime_f(\"reschedule_date\"),",
            "        \"duration\": duration_f,",
            "        \"map_index\": wwwutils.format_map_index,",
            "    }",
            "",
            "",
            "class TriggerModelView(AirflowModelView):",
            "    \"\"\"View to show records from Task Reschedule table.\"\"\"",
            "",
            "    route_base = \"/triggerview\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.Trigger)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_TRIGGER",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "    }",
            "",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    list_columns = [",
            "        \"id\",",
            "        \"classpath\",",
            "        \"created_date\",",
            "        \"triggerer_id\",",
            "    ]",
            "",
            "    search_columns = [",
            "        \"id\",",
            "        \"classpath\",",
            "        \"created_date\",",
            "        \"triggerer_id\",",
            "    ]",
            "",
            "    base_order = (\"id\", \"created_date\")",
            "",
            "    formatters_columns = {",
            "        \"created_date\": wwwutils.datetime_f(\"created_date\"),",
            "    }",
            "",
            "",
            "class TaskInstanceModelView(AirflowPrivilegeVerifierModelView):",
            "    \"\"\"View to show records from TaskInstance table.\"\"\"",
            "",
            "    route_base = \"/taskinstance\"",
            "",
            "    datamodel = AirflowModelView.CustomSQLAInterface(models.TaskInstance)  # type: ignore",
            "",
            "    class_permission_name = permissions.RESOURCE_TASK_INSTANCE",
            "    method_permission_name = {",
            "        \"list\": \"read\",",
            "        \"action_clear\": \"edit\",",
            "        \"action_muldelete\": \"delete\",",
            "        \"action_set_running\": \"edit\",",
            "        \"action_set_failed\": \"edit\",",
            "        \"action_set_success\": \"edit\",",
            "        \"action_set_retry\": \"edit\",",
            "        \"action_set_skipped\": \"edit\",",
            "    }",
            "    base_permissions = [",
            "        permissions.ACTION_CAN_CREATE,",
            "        permissions.ACTION_CAN_READ,",
            "        permissions.ACTION_CAN_EDIT,",
            "        permissions.ACTION_CAN_DELETE,",
            "        permissions.ACTION_CAN_ACCESS_MENU,",
            "    ]",
            "",
            "    page_size = PAGE_SIZE",
            "",
            "    list_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"dag_run.execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        \"note\",",
            "        \"job_id\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"try_number\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "        \"external_executor_id\",",
            "        \"log_url\",",
            "    ]",
            "",
            "    order_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"dag_run.execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"duration\",",
            "        # \"note\",  # TODO: Maybe figure out how to re-enable this.",
            "        \"job_id\",",
            "        \"hostname\",",
            "        \"unixname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "    ]",
            "",
            "    label_columns = {",
            "        \"dag_run.execution_date\": \"Logical Date\",",
            "    }",
            "",
            "    search_columns = [",
            "        \"state\",",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"run_id\",",
            "        \"map_index\",",
            "        \"execution_date\",",
            "        \"operator\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"note\",",
            "        \"hostname\",",
            "        \"priority_weight\",",
            "        \"queue\",",
            "        \"queued_dttm\",",
            "        \"try_number\",",
            "        \"pool\",",
            "        \"queued_by_job_id\",",
            "    ]",
            "",
            "    edit_columns = [",
            "        \"dag_id\",",
            "        \"task_id\",",
            "        \"execution_date\",",
            "        \"start_date\",",
            "        \"end_date\",",
            "        \"state\",",
            "        \"note\",",
            "    ]",
            "",
            "    add_exclude_columns = [\"next_method\", \"next_kwargs\", \"trigger_id\"]",
            "",
            "    edit_form = TaskInstanceEditForm",
            "",
            "    base_order = (\"job_id\", \"asc\")",
            "",
            "    base_filters = [[\"dag_id\", DagFilter, list]]",
            "",
            "    def log_url_formatter(self):",
            "        \"\"\"Formats log URL.\"\"\"",
            "        log_url = self.get(\"log_url\")",
            "        return Markup(",
            "            '<a href=\"{log_url}\"><span class=\"material-icons\" aria-hidden=\"true\">reorder</span></a>'",
            "        ).format(log_url=log_url)",
            "",
            "    def duration_f(self):",
            "        \"\"\"Formats duration.\"\"\"",
            "        end_date = self.get(\"end_date\")",
            "        duration = self.get(\"duration\")",
            "        if end_date and duration:",
            "            return td_format(datetime.timedelta(seconds=duration))",
            "        return None",
            "",
            "    formatters_columns = {",
            "        \"log_url\": log_url_formatter,",
            "        \"task_id\": wwwutils.task_instance_link,",
            "        \"run_id\": wwwutils.dag_run_link,",
            "        \"map_index\": wwwutils.format_map_index,",
            "        \"hostname\": wwwutils.nobr_f(\"hostname\"),",
            "        \"state\": wwwutils.state_f,",
            "        \"dag_run.execution_date\": wwwutils.datetime_f(\"dag_run.execution_date\"),",
            "        \"start_date\": wwwutils.datetime_f(\"start_date\"),",
            "        \"end_date\": wwwutils.datetime_f(\"end_date\"),",
            "        \"queued_dttm\": wwwutils.datetime_f(\"queued_dttm\"),",
            "        \"dag_id\": wwwutils.dag_link,",
            "        \"duration\": duration_f,",
            "    }",
            "",
            "    @action(",
            "        \"clear\",",
            "        lazy_gettext(\"Clear\"),",
            "        lazy_gettext(",
            "            \"Are you sure you want to clear the state of the selected task\"",
            "            \" instance(s) and set their dagruns to the QUEUED state?\"",
            "        ),",
            "        single=False,",
            "    )",
            "    @action_has_dag_edit_access",
            "    @provide_session",
            "    @action_logging",
            "    def action_clear(self, task_instances, session: Session = NEW_SESSION):",
            "        \"\"\"Clears the action.\"\"\"",
            "        try:",
            "            dag_to_tis = collections.defaultdict(list)",
            "",
            "            for ti in task_instances:",
            "                dag = get_airflow_app().dag_bag.get_dag(ti.dag_id)",
            "                dag_to_tis[dag].append(ti)",
            "",
            "            for dag, task_instances_list in dag_to_tis.items():",
            "                models.clear_task_instances(task_instances_list, session, dag=dag)",
            "",
            "            session.commit()",
            "            flash(f\"{len(task_instances)} task instances have been cleared\")",
            "        except Exception as e:",
            "            flash(f'Failed to clear task instances: \"{e}\"', \"error\")",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"muldelete\", \"Delete\", \"Are you sure you want to delete selected records?\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_muldelete(self, items):",
            "        self.datamodel.delete_all(items)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @provide_session",
            "    def set_task_instance_state(self, tis, target_state, session: Session = NEW_SESSION):",
            "        \"\"\"Set task instance state.\"\"\"",
            "        try:",
            "            count = len(tis)",
            "            for ti in tis:",
            "                ti.set_state(target_state, session)",
            "            session.commit()",
            "            flash(f\"{count} task instances were set to '{target_state}'\")",
            "        except Exception:",
            "            flash(\"Failed to set state\", \"error\")",
            "",
            "    @action(\"set_running\", \"Set state to 'running'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_running(self, tis):",
            "        \"\"\"Set state to 'running'.\"\"\"",
            "        self.set_task_instance_state(tis, State.RUNNING)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_failed\", \"Set state to 'failed'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_failed(self, tis):",
            "        \"\"\"Set state to 'failed'.\"\"\"",
            "        self.set_task_instance_state(tis, State.FAILED)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_success\", \"Set state to 'success'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_success(self, tis):",
            "        \"\"\"Set state to 'success'.\"\"\"",
            "        self.set_task_instance_state(tis, State.SUCCESS)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_retry\", \"Set state to 'up_for_retry'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_retry(self, tis):",
            "        \"\"\"Set state to 'up_for_retry'.\"\"\"",
            "        self.set_task_instance_state(tis, State.UP_FOR_RETRY)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "    @action(\"set_skipped\", \"Set state to 'skipped'\", \"\", single=False)",
            "    @action_has_dag_edit_access",
            "    @action_logging",
            "    def action_set_skipped(self, tis):",
            "        \"\"\"Set state to skipped.\"\"\"",
            "        self.set_task_instance_state(tis, TaskInstanceState.SKIPPED)",
            "        self.update_redirect()",
            "        return redirect(self.get_redirect())",
            "",
            "",
            "class AutocompleteView(AirflowBaseView):",
            "    \"\"\"View to provide autocomplete results.\"\"\"",
            "",
            "    @auth.has_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG)])",
            "    @provide_session",
            "    @expose(\"/dagmodel/autocomplete\")",
            "    def autocomplete(self, session: Session = NEW_SESSION):",
            "        \"\"\"Autocomplete.\"\"\"",
            "        query = unquote(request.args.get(\"query\", \"\"))",
            "",
            "        if not query:",
            "            return flask.json.jsonify([])",
            "",
            "        # Provide suggestions of dag_ids and owners",
            "        dag_ids_query = session.query(",
            "            sqla.literal(\"dag\").label(\"type\"),",
            "            DagModel.dag_id.label(\"name\"),",
            "        ).filter(~DagModel.is_subdag, DagModel.is_active, DagModel.dag_id.ilike(f\"%{query}%\"))",
            "",
            "        owners_query = (",
            "            session.query(",
            "                sqla.literal(\"owner\").label(\"type\"),",
            "                DagModel.owners.label(\"name\"),",
            "            )",
            "            .distinct()",
            "            .filter(~DagModel.is_subdag, DagModel.is_active, DagModel.owners.ilike(f\"%{query}%\"))",
            "        )",
            "",
            "        # Hide DAGs if not showing status: \"all\"",
            "        status = flask_session.get(FILTER_STATUS_COOKIE)",
            "        if status == \"active\":",
            "            dag_ids_query = dag_ids_query.filter(~DagModel.is_paused)",
            "            owners_query = owners_query.filter(~DagModel.is_paused)",
            "        elif status == \"paused\":",
            "            dag_ids_query = dag_ids_query.filter(DagModel.is_paused)",
            "            owners_query = owners_query.filter(DagModel.is_paused)",
            "",
            "        filter_dag_ids = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "",
            "        dag_ids_query = dag_ids_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "        owners_query = owners_query.filter(DagModel.dag_id.in_(filter_dag_ids))",
            "",
            "        payload = [row._asdict() for row in dag_ids_query.union(owners_query).order_by(\"name\").limit(10)]",
            "        return flask.json.jsonify(payload)",
            "",
            "",
            "class DagDependenciesView(AirflowBaseView):",
            "    \"\"\"View to show dependencies between DAGs.\"\"\"",
            "",
            "    refresh_interval = datetime.timedelta(",
            "        seconds=conf.getint(",
            "            \"webserver\",",
            "            \"dag_dependencies_refresh_interval\",",
            "            fallback=conf.getint(\"scheduler\", \"dag_dir_list_interval\"),",
            "        )",
            "    )",
            "    last_refresh = timezone.utcnow() - refresh_interval",
            "    nodes: list[dict[str, Any]] = []",
            "    edges: list[dict[str, str]] = []",
            "",
            "    @expose(\"/dag-dependencies\")",
            "    @auth.has_access(",
            "        [",
            "            (permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_DEPENDENCIES),",
            "        ]",
            "    )",
            "    @gzipped",
            "    @action_logging",
            "    def list(self):",
            "        \"\"\"Display DAG dependencies.\"\"\"",
            "        title = \"DAG Dependencies\"",
            "",
            "        if not self.nodes or not self.edges:",
            "            self._calculate_graph()",
            "            self.last_refresh = timezone.utcnow()",
            "        elif timezone.utcnow() > self.last_refresh + self.refresh_interval:",
            "            max_last_updated = SerializedDagModel.get_max_last_updated_datetime()",
            "            if max_last_updated is None or max_last_updated > self.last_refresh:",
            "                self._calculate_graph()",
            "            self.last_refresh = timezone.utcnow()",
            "",
            "        return self.render_template(",
            "            \"airflow/dag_dependencies.html\",",
            "            title=title,",
            "            nodes=self.nodes,",
            "            edges=self.edges,",
            "            last_refresh=self.last_refresh,",
            "            arrange=conf.get(\"webserver\", \"dag_orientation\"),",
            "            width=request.args.get(\"width\", \"100%\"),",
            "            height=request.args.get(\"height\", \"800\"),",
            "        )",
            "",
            "    def _calculate_graph(self):",
            "        nodes_dict: dict[str, Any] = {}",
            "        edge_tuples: set[dict[str, str]] = set()",
            "",
            "        for dag, dependencies in SerializedDagModel.get_dag_dependencies().items():",
            "            dag_node_id = f\"dag:{dag}\"",
            "            if dag_node_id not in nodes_dict:",
            "                nodes_dict[dag_node_id] = node_dict(dag_node_id, dag, \"dag\")",
            "",
            "            for dep in dependencies:",
            "                if dep.node_id not in nodes_dict:",
            "                    nodes_dict[dep.node_id] = node_dict(dep.node_id, dep.dependency_id, dep.dependency_type)",
            "                edge_tuples.add((f\"dag:{dep.source}\", dep.node_id))",
            "                edge_tuples.add((dep.node_id, f\"dag:{dep.target}\"))",
            "",
            "        self.nodes = list(nodes_dict.values())",
            "        self.edges = [{\"u\": u, \"v\": v} for u, v in edge_tuples]",
            "",
            "",
            "def add_user_permissions_to_dag(sender, template, context, **extra):",
            "    \"\"\"",
            "    Adds `.can_edit`, `.can_trigger`, and `.can_delete` properties",
            "    to DAG based on current user's permissions.",
            "    Located in `views.py` rather than the DAG model to keep",
            "    permissions logic out of the Airflow core.",
            "    \"\"\"",
            "    if \"dag\" not in context:",
            "        return",
            "    dag = context[\"dag\"]",
            "    can_create_dag_run = get_airflow_app().appbuilder.sm.has_access(",
            "        permissions.ACTION_CAN_CREATE, permissions.RESOURCE_DAG_RUN",
            "    )",
            "",
            "    dag.can_edit = get_airflow_app().appbuilder.sm.can_edit_dag(dag.dag_id)",
            "    dag.can_trigger = dag.can_edit and can_create_dag_run",
            "    dag.can_delete = get_airflow_app().appbuilder.sm.can_delete_dag(dag.dag_id)",
            "    context[\"dag\"] = dag",
            "",
            "",
            "# NOTE: Put this at the end of the file. Pylance is too clever and detects that",
            "# before_render_template.connect() is declared as NoReturn, and marks everything",
            "# after this line as unreachable code. It's technically correct based on the",
            "# lint-time information, but that's not what actually happens at runtime.",
            "before_render_template.connect(add_user_permissions_to_dag)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "102": [],
            "1978": [
                "Airflow",
                "trigger"
            ],
            "2099": [
                "Airflow",
                "trigger"
            ],
            "2100": [
                "Airflow",
                "trigger"
            ],
            "2101": [
                "Airflow",
                "trigger"
            ],
            "2102": [
                "Airflow",
                "trigger"
            ],
            "2103": [
                "Airflow",
                "trigger"
            ],
            "2104": [
                "Airflow",
                "trigger"
            ],
            "2105": [
                "Airflow",
                "trigger"
            ]
        },
        "addLocation": []
    }
}