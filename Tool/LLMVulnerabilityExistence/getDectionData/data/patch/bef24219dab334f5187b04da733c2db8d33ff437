{
    "flask_appbuilder/api/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " from ..hooks import get_before_request_hooks, wrap_route_handler_with_hooks"
            },
            "1": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " from ..models.filters import Filters"
            },
            "2": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " from ..security.decorators import permission_name, protect"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+from ..utils.limit import Limit"
            },
            "4": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "6": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     from flask_appbuilder import AppBuilder"
            },
            "7": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "         Use this attribute to override the tag name"
            },
            "8": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 456,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+    limits: Optional[List[Limit]] = None"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        List of limits for this api."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+        Use it like this if you want to restrict the rate of requests to a view:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+            class MyView(ModelView):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+                limits = [Limit(\"2 per 5 second\")]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+        or use the decorator @limit."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+    \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "     def __init__(self) -> None:"
            },
            "23": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "         \"\"\""
            },
            "24": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "         Initialization of base permissions"
            },
            "25": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "         if self.base_permissions is None:"
            },
            "26": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "             self.base_permissions = set()"
            },
            "27": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "             is_add_base_permissions = True"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+        if self.limits is None:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+            self.limits = []"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "         for attr_name in dir(self):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+            if hasattr(getattr(self, attr_name), \"_limit\"):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+                self.limits.append(getattr(getattr(self, attr_name), \"_limit\"))"
            },
            "35": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "             # If include_route_methods is not None white list"
            },
            "36": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "             if ("
            },
            "37": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "                 self.include_route_methods is not None"
            }
        },
        "frontPatchFile": [
            "import functools",
            "import json",
            "import logging",
            "import re",
            "import traceback",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    Union,",
            ")",
            "import urllib.parse",
            "",
            "from apispec import APISpec, yaml_utils",
            "from apispec.exceptions import DuplicateComponentNameError",
            "from flask import Blueprint, current_app, jsonify, make_response, request, Response",
            "from flask_appbuilder.models.sqla import Model",
            "from flask_appbuilder.models.sqla.interface import SQLAInterface",
            "from flask_babel import lazy_gettext as _",
            "import jsonschema",
            "from marshmallow import Schema, ValidationError",
            "from marshmallow.fields import Field",
            "from marshmallow_sqlalchemy.fields import Related, RelatedList",
            "import prison",
            "from sqlalchemy.exc import IntegrityError",
            "from werkzeug.exceptions import BadRequest",
            "import yaml",
            "",
            "from .convert import Model2SchemaConverter",
            "from .schemas import get_info_schema, get_item_schema, get_list_schema",
            "from .._compat import as_unicode",
            "from ..baseviews import AbstractViewApi",
            "from ..const import (",
            "    API_ADD_COLUMNS_RES_KEY,",
            "    API_ADD_COLUMNS_RIS_KEY,",
            "    API_ADD_TITLE_RES_KEY,",
            "    API_ADD_TITLE_RIS_KEY,",
            "    API_DESCRIPTION_COLUMNS_RES_KEY,",
            "    API_DESCRIPTION_COLUMNS_RIS_KEY,",
            "    API_EDIT_COLUMNS_RES_KEY,",
            "    API_EDIT_COLUMNS_RIS_KEY,",
            "    API_EDIT_TITLE_RES_KEY,",
            "    API_EDIT_TITLE_RIS_KEY,",
            "    API_FILTERS_RES_KEY,",
            "    API_FILTERS_RIS_KEY,",
            "    API_LABEL_COLUMNS_RES_KEY,",
            "    API_LABEL_COLUMNS_RIS_KEY,",
            "    API_LIST_COLUMNS_RES_KEY,",
            "    API_LIST_COLUMNS_RIS_KEY,",
            "    API_LIST_TITLE_RES_KEY,",
            "    API_LIST_TITLE_RIS_KEY,",
            "    API_ORDER_COLUMN_RIS_KEY,",
            "    API_ORDER_COLUMNS_RES_KEY,",
            "    API_ORDER_COLUMNS_RIS_KEY,",
            "    API_ORDER_DIRECTION_RIS_KEY,",
            "    API_PAGE_INDEX_RIS_KEY,",
            "    API_PAGE_SIZE_RIS_KEY,",
            "    API_PERMISSIONS_RES_KEY,",
            "    API_PERMISSIONS_RIS_KEY,",
            "    API_RESULT_RES_KEY,",
            "    API_SELECT_COLUMNS_RIS_KEY,",
            "    API_SHOW_COLUMNS_RES_KEY,",
            "    API_SHOW_COLUMNS_RIS_KEY,",
            "    API_SHOW_TITLE_RES_KEY,",
            "    API_SHOW_TITLE_RIS_KEY,",
            "    API_URI_RIS_KEY,",
            "    PERMISSION_PREFIX,",
            ")",
            "from ..exceptions import FABException, InvalidOrderByColumnFABException",
            "from ..hooks import get_before_request_hooks, wrap_route_handler_with_hooks",
            "from ..models.filters import Filters",
            "from ..security.decorators import permission_name, protect",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder import AppBuilder",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "ModelKeyType = Union[str, int]",
            "QueryRelatedFieldsFilters = Dict[str, List[List[Any]]]",
            "",
            "",
            "def get_error_msg() -> str:",
            "    \"\"\"",
            "    (inspired on Superset code)",
            "    :return: (str)",
            "    \"\"\"",
            "    if current_app.config.get(\"FAB_API_SHOW_STACKTRACE\"):",
            "        return traceback.format_exc()",
            "    return \"Fatal error\"",
            "",
            "",
            "def safe(f: Callable[..., Any]) -> Callable[..., Any]:",
            "    \"\"\"",
            "    A decorator that catches uncaught exceptions and",
            "    return the response in JSON format (inspired on Superset code)",
            "    \"\"\"",
            "",
            "    def wraps(self: \"BaseApi\", *args: Any, **kwargs: Any) -> Response:",
            "        try:",
            "            return f(self, *args, **kwargs)",
            "        except BadRequest as e:",
            "            return self.response_400(message=str(e))",
            "        except Exception as e:",
            "            log.exception(e)",
            "            return self.response_500(message=get_error_msg())",
            "",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def rison(",
            "    schema: Optional[Dict[str, Any]] = None",
            ") -> Callable[[Callable[..., Any]], Callable[..., Any]]:",
            "    \"\"\"",
            "    Use this decorator to parse URI *Rison* arguments to",
            "    a python data structure, your method gets the data",
            "    structure on kwargs['rison']. Response is HTTP 400",
            "    if *Rison* is not correct::",
            "",
            "        class ExampleApi(BaseApi):",
            "                @expose('/risonjson')",
            "                @rison()",
            "                def rison_json(self, **kwargs):",
            "                    return self.response(200, result=kwargs['rison'])",
            "",
            "    You can additionally pass a JSON schema to",
            "    validate Rison arguments::",
            "",
            "        schema = {",
            "            \"type\": \"object\",",
            "            \"properties\": {",
            "                \"arg1\": {",
            "                    \"type\": \"integer\"",
            "                }",
            "            }",
            "        }",
            "",
            "        class ExampleApi(BaseApi):",
            "                @expose('/risonjson')",
            "                @rison(schema)",
            "                def rison_json(self, **kwargs):",
            "                    return self.response(200, result=kwargs['rison'])",
            "",
            "    \"\"\"",
            "",
            "    def _rison(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        def wraps(self: \"BaseApi\", *args: Any, **kwargs: Any) -> Response:",
            "            value = request.args.get(API_URI_RIS_KEY, None)",
            "            kwargs[\"rison\"] = dict()",
            "            if value:",
            "                try:",
            "                    kwargs[\"rison\"] = prison.loads(value)",
            "                except prison.decoder.ParserException:",
            "                    if current_app.config.get(\"FAB_API_ALLOW_JSON_QS\", True):",
            "                        # Rison failed try json encoded content",
            "                        try:",
            "                            kwargs[\"rison\"] = json.loads(",
            "                                urllib.parse.parse_qs(f\"{API_URI_RIS_KEY}={value}\").get(",
            "                                    API_URI_RIS_KEY",
            "                                )[0]",
            "                            )",
            "                        except Exception:",
            "                            return self.response_400(",
            "                                message=\"Not a valid rison/json argument\"",
            "                            )",
            "                    else:",
            "                        return self.response_400(message=\"Not a valid rison argument\")",
            "            if schema:",
            "                try:",
            "                    jsonschema.validate(instance=kwargs[\"rison\"], schema=schema)",
            "                except jsonschema.ValidationError as e:",
            "                    return self.response_400(message=f\"Not a valid rison schema {e}\")",
            "            return f(self, *args, **kwargs)",
            "",
            "        return functools.update_wrapper(wraps, f)",
            "",
            "    return _rison",
            "",
            "",
            "def expose(url: str = \"/\", methods: Tuple[str] = (\"GET\",)) -> Callable[..., Any]:",
            "    \"\"\"",
            "    Use this decorator to expose API endpoints on your API classes.",
            "",
            "    :param url:",
            "        Relative URL for the endpoint",
            "    :param methods:",
            "        Allowed HTTP methods. By default only GET is allowed.",
            "    \"\"\"",
            "",
            "    def wrap(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []  # type: ignore",
            "        f._urls.append((url, methods))  # type: ignore",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "def merge_response_func(func: Callable[..., Any], key: str) -> Callable[..., Any]:",
            "    \"\"\"",
            "        Use this decorator to set a new merging",
            "        response function to HTTP endpoints",
            "",
            "        candidate function must have the following signature",
            "        and be childs of BaseApi:",
            "        ```",
            "            def merge_some_function(self, response, rison_args):",
            "        ```",
            "",
            "    :param func: Name of the merge function where the key is allowed",
            "    :param key: The key name for rison selection",
            "    :return: None",
            "    \"\"\"",
            "",
            "    def wrap(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        if not hasattr(f, \"_response_key_func_mappings\"):",
            "            f._response_key_func_mappings = {}  # type: ignore",
            "        f._response_key_func_mappings[key] = func  # type: ignore",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "class BaseApi(AbstractViewApi):",
            "    \"\"\"",
            "    All apis inherit from this class.",
            "    it's constructor will register your exposed urls on flask",
            "    as a Blueprint.",
            "",
            "    This class does not expose any urls,",
            "    but provides a common base for all APIS.",
            "    \"\"\"",
            "",
            "    endpoint: Optional[str] = None",
            "",
            "    version: Optional[str] = \"v1\"",
            "    \"\"\"",
            "        Define the Api version for this resource/class",
            "    \"\"\"",
            "    route_base: Optional[str] = None",
            "    \"\"\"",
            "        Define the route base where all methods will suffix from",
            "    \"\"\"",
            "    resource_name: Optional[str] = None",
            "    \"\"\"",
            "        Defines a custom resource name, overrides the inferred from Class name",
            "        makes no sense to use it with route base",
            "    \"\"\"",
            "    base_permissions: Optional[List[str]] = None",
            "    \"\"\"",
            "        A list of allowed base permissions::",
            "",
            "            class ExampleApi(BaseApi):",
            "                base_permissions = ['can_get']",
            "",
            "    \"\"\"",
            "    class_permission_name: Optional[str] = None",
            "    \"\"\"",
            "        Override class permission name default fallback to self.__class__.__name__",
            "    \"\"\"",
            "    previous_class_permission_name: Optional[str] = None",
            "    \"\"\"",
            "        If set security converge will replace all permissions tuples",
            "        with this name by the class_permission_name or self.__class__.__name__",
            "    \"\"\"",
            "    method_permission_name: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "        Override method permission names, example::",
            "",
            "            method_permissions_name = {",
            "                'get_list': 'read',",
            "                'get': 'read',",
            "                'put': 'write',",
            "                'post': 'write',",
            "                'delete': 'write'",
            "            }",
            "    \"\"\"",
            "    previous_method_permission_name: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "        Use same structure as method_permission_name. If set security converge",
            "        will replace all method permissions by the new ones",
            "    \"\"\"",
            "    allow_browser_login = False",
            "    \"\"\"",
            "        Will allow flask-login cookie authorization on the API",
            "        default is False.",
            "    \"\"\"",
            "    csrf_exempt = True",
            "    \"\"\"",
            "        If using flask-wtf CSRFProtect exempt the API from check",
            "    \"\"\"",
            "    apispec_parameter_schemas: Optional[Dict[str, Dict[str, Any]]] = None",
            "    \"\"\"",
            "        Set your custom Rison parameter schemas here so that",
            "        they get registered on the OpenApi spec::",
            "",
            "            custom_parameter = {",
            "                \"type\": \"object\"",
            "                \"properties\": {",
            "                    \"name\": {",
            "                        \"type\": \"string\"",
            "                    }",
            "                }",
            "            }",
            "",
            "            class CustomApi(BaseApi):",
            "                apispec_parameter_schemas = {",
            "                    \"custom_parameter\": custom_parameter",
            "                }",
            "    \"\"\"",
            "    _apispec_parameter_schemas: Optional[Dict[str, Dict[str, Any]]] = None",
            "",
            "    openapi_spec_component_schemas: Tuple[Type[Schema], ...] = tuple()",
            "    \"\"\"",
            "    A Tuple containing marshmallow schemas to be registered on the OpenAPI spec",
            "    has component schemas, these can be referenced by the endpoint's spec like:",
            "    `$ref: '#/components/schemas/MyCustomSchema'` Where MyCustomSchema is the",
            "    marshmallow schema class name.",
            "",
            "    To set your own OpenAPI schema component name, declare your schemas with:",
            "    __component_name__",
            "",
            "    class Schema1(Schema):",
            "        __component_name__ = \"MyCustomSchema\"",
            "        id = fields.Integer()",
            "        ...",
            "",
            "    \"\"\"",
            "    responses = {",
            "        \"400\": {",
            "            \"description\": \"Bad request\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"401\": {",
            "            \"description\": \"Unauthorized\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"403\": {",
            "            \"description\": \"Forbidden\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"404\": {",
            "            \"description\": \"Not found\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"422\": {",
            "            \"description\": \"Could not process entity\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"500\": {",
            "            \"description\": \"Fatal error\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "    }",
            "    \"\"\"",
            "        Override custom OpenApi responses",
            "    \"\"\"",
            "",
            "    exclude_route_methods: Set[str] = set()",
            "    \"\"\"",
            "        Does not register routes for a set of builtin ModelRestApi functions.",
            "        example::",
            "",
            "            class ContactModelView(ModelRestApi):",
            "                datamodel = SQLAInterface(Contact)",
            "                exclude_route_methods = {\"info\", \"get_list\", \"get\"}",
            "",
            "",
            "        The previous examples will only register the `put`, `post` and `delete` routes",
            "    \"\"\"",
            "    include_route_methods: Optional[Set[str]] = None",
            "    \"\"\"",
            "        If defined will assume a white list setup, where all endpoints are excluded",
            "        except those define on this attribute",
            "        example::",
            "",
            "            class ContactModelView(ModelRestApi):",
            "                datamodel = SQLAInterface(Contact)",
            "                include_route_methods = {\"list\"}",
            "",
            "",
            "        The previous example will exclude all endpoints except the `list` endpoint",
            "    \"\"\"",
            "    openapi_spec_methods: Dict[str, Any] = {}",
            "    \"\"\"",
            "        Merge OpenAPI spec defined on the method's doc.",
            "        For example to merge/override `get_list`::",
            "",
            "",
            "            class GreetingApi(BaseApi):",
            "                resource_name = \"greeting\"",
            "                openapi_spec_methods = {",
            "                    \"greeting\": {",
            "                        \"get\": {",
            "                           \"description\": \"Override description\",",
            "                        }",
            "                    }",
            "                }",
            "    \"\"\"",
            "    openapi_spec_tag: Optional[str] = None",
            "    \"\"\"",
            "        By default all endpoints will be tagged (grouped) to their class name.",
            "        Use this attribute to override the tag name",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"",
            "        Initialization of base permissions",
            "        based on exposed methods and actions",
            "",
            "        Initialization of extra args",
            "        \"\"\"",
            "        self.appbuilder = None",
            "        self.blueprint = None",
            "",
            "        # Init OpenAPI",
            "        self._response_key_func_mappings: Dict[str, Any] = {}",
            "        self.apispec_parameter_schemas = self.apispec_parameter_schemas or {}",
            "        self._apispec_parameter_schemas = self._apispec_parameter_schemas or {}",
            "        self._apispec_parameter_schemas.update(self.apispec_parameter_schemas)",
            "        if self.openapi_spec_component_schemas is None:",
            "            self.openapi_spec_component_schemas = ()",
            "",
            "        # Init class permission override attrs",
            "        if not self.previous_class_permission_name and self.class_permission_name:",
            "            self.previous_class_permission_name = self.__class__.__name__",
            "        self.class_permission_name = (",
            "            self.class_permission_name or self.__class__.__name__",
            "        )",
            "",
            "        # Init previous permission override attrs",
            "        is_collect_previous = False",
            "        if not self.previous_method_permission_name and self.method_permission_name:",
            "            self.previous_method_permission_name = dict()",
            "            is_collect_previous = True",
            "        self.method_permission_name = self.method_permission_name or dict()",
            "",
            "        # Collect base_permissions and infer previous permissions",
            "        is_add_base_permissions = False",
            "        if self.base_permissions is None:",
            "            self.base_permissions = set()",
            "            is_add_base_permissions = True",
            "        for attr_name in dir(self):",
            "            # If include_route_methods is not None white list",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            # Don't create permission for excluded routes",
            "            if attr_name in self.exclude_route_methods:",
            "                continue",
            "            if hasattr(getattr(self, attr_name), \"_permission_name\"):",
            "                if is_collect_previous:",
            "                    self.previous_method_permission_name[attr_name] = getattr(",
            "                        getattr(self, attr_name), \"_permission_name\"",
            "                    )",
            "                _permission_name = self.get_method_permission(attr_name)",
            "                if is_add_base_permissions:",
            "                    self.base_permissions.add(PERMISSION_PREFIX + _permission_name)",
            "        self.base_permissions = list(self.base_permissions)",
            "",
            "    def create_blueprint(",
            "        self,",
            "        appbuilder: \"AppBuilder\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> Blueprint:",
            "        # Store appbuilder instance",
            "        self.appbuilder = appbuilder",
            "        # If endpoint name is not provided, get it from the class name",
            "        self.endpoint = endpoint or self.__class__.__name__",
            "        self.resource_name = self.resource_name or self.__class__.__name__.lower()",
            "",
            "        if self.route_base is None:",
            "            self.route_base = f\"/api/{self.version}/{self.resource_name.lower()}\"",
            "        self.blueprint = Blueprint(self.endpoint, __name__, url_prefix=self.route_base)",
            "        # Exempt API from CSRF protect",
            "        if self.csrf_exempt:",
            "            csrf = self.appbuilder.app.extensions.get(\"csrf\")",
            "            if csrf:",
            "                csrf.exempt(self.blueprint)",
            "",
            "        self._register_urls()",
            "        return self.blueprint",
            "",
            "    def add_api_spec(self, api_spec: APISpec) -> None:",
            "        self.add_apispec_components(api_spec)",
            "        for attr_name in dir(self):",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    # If include_route_methods is not None white list",
            "                    if (",
            "                        self.include_route_methods is not None",
            "                        and attr_name not in self.include_route_methods",
            "                    ):",
            "                        continue",
            "                    if attr_name in self.exclude_route_methods:",
            "                        log.info(f\"Not registering api spec for method {attr_name}\")",
            "                        continue",
            "                    operations = {}",
            "                    path = self.path_helper(path=url, operations=operations)",
            "                    self.operation_helper(",
            "                        path=path, operations=operations, methods=methods, func=attr",
            "                    )",
            "                    api_spec.path(path=path, operations=operations)",
            "                    for operation in operations:",
            "                        openapi_spec_tag = (",
            "                            self.openapi_spec_tag or self.__class__.__name__",
            "                        )",
            "                        api_spec._paths[path][operation][\"tags\"] = [openapi_spec_tag]",
            "",
            "    def add_apispec_components(self, api_spec: APISpec) -> None:",
            "        for k, v in self.responses.items():",
            "            try:",
            "                api_spec.components.response(k, v)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "        for k, v in self._apispec_parameter_schemas.items():",
            "            try:",
            "                api_spec.components.schema(k, v)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "        for schema in self.openapi_spec_component_schemas:",
            "            try:",
            "                if hasattr(schema, \"__component_name__\"):",
            "                    component_name = schema.__component_name__",
            "                elif isinstance(schema, type):",
            "                    component_name = schema.__name__",
            "                else:",
            "                    component_name = schema.__class__.__name__",
            "                api_spec.components.schema(component_name, schema=schema)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "",
            "    def _register_urls(self) -> None:",
            "        before_request_hooks = get_before_request_hooks(self)",
            "        for attr_name in dir(self):",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            if attr_name in self.exclude_route_methods:",
            "                log.info(f\"Not registering route for method {attr_name}\")",
            "                continue",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    log.info(",
            "                        f\"Registering route {self.blueprint.url_prefix}{url} {methods}\"",
            "                    )",
            "                    route_handler = wrap_route_handler_with_hooks(",
            "                        attr_name, attr, before_request_hooks",
            "                    )",
            "                    self.blueprint.add_url_rule(",
            "                        url, attr_name, route_handler, methods=methods",
            "                    )",
            "",
            "    def path_helper(",
            "        self,",
            "        path: str = None,",
            "        operations: Optional[Dict[str, Dict]] = None,",
            "        **kwargs: Any,",
            "    ) -> str:",
            "        \"\"\"",
            "            Works like an apispec plugin",
            "            May return a path as string and mutate operations dict.",
            "",
            "        :param str path: Path to the resource",
            "        :param dict operations: A `dict` mapping HTTP methods to operation object. See",
            "            https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject",
            "        :param kwargs:",
            "        :return: Return value should be a string or None. If a string is returned, it",
            "        is set as the path.",
            "        \"\"\"",
            "        RE_URL = re.compile(r\"<(?:[^:<>]+:)?([^<>]+)>\")",
            "        path = RE_URL.sub(r\"{\\1}\", path)",
            "        return f\"{self.route_base}{path}\"",
            "",
            "    def operation_helper(",
            "        self,",
            "        path: Optional[str] = None,",
            "        operations: Dict[str, Any] = None,",
            "        methods: List[str] = None,",
            "        func: Callable[..., Response] = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"May mutate operations.",
            "        :param str path: Path to the resource",
            "        :param dict operations: A `dict` mapping HTTP methods to operation object.",
            "        :param list methods: A list of HTTP methods registered for this path",
            "        \"\"\"",
            "        for method in methods:",
            "            try:",
            "                # Check if method openapi spec is overridden",
            "                override_method_spec = self.openapi_spec_methods[func.__name__]",
            "            except KeyError:",
            "                override_method_spec = {}",
            "            yaml_doc_string = yaml_utils.load_operations_from_docstring(func.__doc__)",
            "            yaml_doc_string = yaml.safe_load(",
            "                str(yaml_doc_string).replace(",
            "                    \"{{self.__class__.__name__}}\", self.__class__.__name__",
            "                )",
            "            )",
            "            if yaml_doc_string:",
            "                operation_spec = yaml_doc_string.get(method.lower(), {})",
            "                # Merge docs spec and override spec",
            "                operation_spec.update(override_method_spec.get(method.lower(), {}))",
            "                if self.get_method_permission(func.__name__):",
            "                    operation_spec[\"security\"] = [{\"jwt\": []}]",
            "                operations[method.lower()] = operation_spec",
            "            else:",
            "                operations[method.lower()] = {}",
            "",
            "    @staticmethod",
            "    def _prettify_name(name: str) -> str:",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'HelloWorld' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(r\"(?<=.)([A-Z])\", r\" \\1\", name)",
            "",
            "    @staticmethod",
            "    def _prettify_column(name: str) -> str:",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'hello_world' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(\"[._]\", \" \", name).title()",
            "",
            "    def get_uninit_inner_views(self) -> List[Type[AbstractViewApi]]:",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_init_inner_views(self) -> List[AbstractViewApi]:",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "        pass  # pragma: no cover",
            "",
            "    def get_method_permission(self, method_name: str) -> str:",
            "        \"\"\"",
            "        Returns the permission name for a method",
            "        \"\"\"",
            "        if self.method_permission_name:",
            "            return self.method_permission_name.get(method_name, method_name)",
            "        else:",
            "            if hasattr(getattr(self, method_name), \"_permission_name\"):",
            "                return getattr(getattr(self, method_name), \"_permission_name\")",
            "",
            "    def set_response_key_mappings(",
            "        self,",
            "        response: Dict[str, Any],",
            "        func: Callable[..., Response],",
            "        rison_args: Dict[str, Any],",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        if not hasattr(func, \"_response_key_func_mappings\"):",
            "            return  # pragma: no cover",
            "        _keys = rison_args.get(\"keys\", None)",
            "        if not _keys:",
            "            for k, v in func._response_key_func_mappings.items():",
            "                v(self, response, **kwargs)",
            "        else:",
            "            for k, v in func._response_key_func_mappings.items():",
            "                if k in _keys:",
            "                    v(self, response, **kwargs)",
            "",
            "    def merge_current_user_permissions(",
            "        self, response: Dict[str, Any], **kwargs: Any",
            "    ) -> None:",
            "        response[API_PERMISSIONS_RES_KEY] = [",
            "            permission",
            "            for permission in self.base_permissions",
            "            if self.appbuilder.sm.has_access(permission, self.class_permission_name)",
            "        ]",
            "",
            "    @staticmethod",
            "    def response(code: int, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        Generic HTTP JSON response method",
            "",
            "        :param code: HTTP code (int)",
            "        :param kwargs: Data structure for response (dict)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        _ret_json = jsonify(kwargs)",
            "        resp = make_response(_ret_json, code)",
            "        resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "        return resp",
            "",
            "    def response_400(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 400 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Arguments are not correct\"",
            "        return self.response(400, **{\"message\": message})",
            "",
            "    def response_422(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 422 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Could not process entity\"",
            "        return self.response(422, **{\"message\": message})",
            "",
            "    def response_401(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 401 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(401, **{\"message\": \"Not authorized\"})",
            "",
            "    def response_403(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 403 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(403, **{\"message\": \"Forbidden\"})",
            "",
            "    def response_404(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 404 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(404, **{\"message\": \"Not found\"})",
            "",
            "    def response_500(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 500 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Internal error\"",
            "        return self.response(500, **{\"message\": message})",
            "",
            "",
            "class BaseModelApi(BaseApi):",
            "    datamodel: Optional[SQLAInterface] = None",
            "    \"\"\"",
            "    Your sqla model you must initialize it like::",
            "",
            "        class MyModelApi(BaseModelApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "    \"\"\"",
            "    search_columns = None",
            "    \"\"\"",
            "    List with allowed search columns, if not provided all possible search",
            "    columns will be used. If you want to limit the search (*filter*) columns",
            "     possibilities, define it with a list of column names from your model::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            search_columns = ['name', 'address']",
            "",
            "    \"\"\"",
            "    search_filters = None",
            "    \"\"\"",
            "    Override default search filters for columns",
            "    \"\"\"",
            "    search_exclude_columns = None",
            "    \"\"\"",
            "    List with columns to exclude from search. Search includes all possible",
            "    columns by default",
            "    \"\"\"",
            "    label_columns = None",
            "    \"\"\"",
            "    Dictionary of labels for your columns, override this if you want",
            "     different pretify labels",
            "",
            "    example (will just override the label for name column)::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            label_columns = {'name':'My Name Label Override'}",
            "",
            "    \"\"\"",
            "    base_filters = None",
            "    \"\"\"",
            "    Filter the view use: [['column_name',BaseFilter,'value'],]",
            "",
            "    example::",
            "",
            "        def get_user():",
            "            return g.user",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            base_filters = [['created_by', FilterEqualFunction, get_user],",
            "                            ['name', FilterStartsWith, 'a']]",
            "",
            "    \"\"\"",
            "",
            "    base_order = None",
            "    \"\"\"",
            "    Use this property to set default ordering for lists",
            "     ('col_name','asc|desc')::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            base_order = ('my_column_name','asc')",
            "",
            "    \"\"\"",
            "    _base_filters = None",
            "    \"\"\" Internal base Filter from class Filters will always filter view \"\"\"",
            "    _filters = None",
            "    \"\"\"",
            "    Filters object will calculate all possible filter types",
            "    based on search_columns",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs: Any) -> None:",
            "        datamodel = kwargs.get(\"datamodel\", None)",
            "        if datamodel:",
            "            self.datamodel = datamodel",
            "        self._init_properties()",
            "        self._init_titles()",
            "        super(BaseModelApi, self).__init__()",
            "",
            "    def _gen_labels_columns(self, list_columns: List[str]) -> None:",
            "        \"\"\"",
            "        Auto generates pretty label_columns from list of columns",
            "        \"\"\"",
            "        for col in list_columns:",
            "            if not self.label_columns.get(col):",
            "                self.label_columns[col] = self._prettify_column(col)",
            "",
            "    def _label_columns_json(self, cols: Optional[List[str]] = None) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Prepares dict with labels to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        cols = cols or []",
            "        d = {k: v for (k, v) in self.label_columns.items() if k in cols}",
            "        for key, value in d.items():",
            "            ret[key] = as_unicode(_(value).encode(\"UTF-8\"))",
            "        return ret",
            "",
            "    def _init_properties(self) -> None:",
            "        self.label_columns = self.label_columns or {}",
            "        self.base_filters = self.base_filters or []",
            "        self.search_exclude_columns = self.search_exclude_columns or []",
            "        self.search_columns = self.search_columns or []",
            "",
            "        self._base_filters = self.datamodel.get_filters().add_filter_list(",
            "            self.base_filters",
            "        )",
            "        search_columns = self.datamodel.get_search_columns_list()",
            "        if not self.search_columns:",
            "            self.search_columns = [",
            "                x for x in search_columns if x not in self.search_exclude_columns",
            "            ]",
            "        self._gen_labels_columns(self.datamodel.get_columns_list())",
            "",
            "    def _init_titles(self) -> None:",
            "        pass",
            "",
            "",
            "class ModelRestApi(BaseModelApi):",
            "    list_title = \"\"",
            "    \"\"\"",
            "    List Title, if not configured the default is",
            "    'List ' with pretty model name",
            "    \"\"\"",
            "    show_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Show Title , if not configured the default is",
            "    'Show ' with pretty model name",
            "    \"\"\"",
            "    add_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Add Title , if not configured the default is",
            "    'Add ' with pretty model name",
            "    \"\"\"",
            "    edit_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Edit Title , if not configured the default is",
            "    'Edit ' with pretty model name",
            "    \"\"\"",
            "    list_select_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A List of column names that will be included on the SQL select.",
            "    This is useful for including all necessary columns that are referenced",
            "    by properties listed on `list_columns` without generating N+1 queries.",
            "    \"\"\"",
            "    list_outer_default_load = False",
            "    \"\"\"",
            "    If True, the default load for outer joins will be applied on the get item endpoint.",
            "    This is useful for when you want to control the load of the many-to-many and",
            "    many-to-one relationships at the model level. Will apply:",
            "     https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload",
            "    \"\"\"",
            "    list_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be displayed on the list view.",
            "    Use it to control the order of the display",
            "    \"\"\"",
            "    show_select_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A List of column names that will be included on the SQL select.",
            "    This is useful for including all necessary columns that are referenced",
            "    by properties listed on `show_columns` without generating N+1 queries.",
            "    \"\"\"",
            "    show_outer_default_load = False",
            "    \"\"\"",
            "    If True, the default load for outer joins will be applied on the get item endpoint.",
            "    This is useful for when you want to control the load of the many-to-many and",
            "    many-to-one relationships at the model level. Will apply:",
            "     https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload",
            "    \"\"\"",
            "    show_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) for the get item endpoint.",
            "    Use it to control the order of the results",
            "    \"\"\"",
            "    add_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be allowed to post",
            "    \"\"\"",
            "    edit_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be allowed to update",
            "    \"\"\"",
            "    list_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the get list endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    show_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the get item endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    add_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the add endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    edit_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the edit endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    order_columns: Optional[List[str]] = None",
            "    \"\"\" Allowed order columns \"\"\"",
            "    page_size = 20",
            "    \"\"\"",
            "    Use this property to change default page size",
            "    \"\"\"",
            "    max_page_size: Optional[int] = None",
            "    \"\"\"",
            "    class override for the FAB_API_MAX_SIZE, use special -1 to allow for any page",
            "    size",
            "    \"\"\"",
            "    description_columns: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "    Dictionary with column descriptions that will be shown on the forms::",
            "",
            "        class MyView(ModelView):",
            "            datamodel = SQLAModel(MyTable, db.session)",
            "",
            "            description_columns = {'name':'your models name column',",
            "                                    'address':'the address column'}",
            "    \"\"\"",
            "    validators_columns: Optional[Dict[str, Callable]] = None",
            "    \"\"\" Dictionary to add your own marshmallow validators \"\"\"",
            "",
            "    add_query_rel_fields = None",
            "    \"\"\"",
            "    Add Customized query for related add fields.",
            "    Assign a dictionary where the keys are the column names of",
            "    the related models to filter, the value for each key, is a list of lists with the",
            "    same format as base_filter",
            "    {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "    Add a custom filter to form related fields::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact)",
            "            add_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "    edit_query_rel_fields = None",
            "    \"\"\"",
            "    Add Customized query for related edit fields.",
            "    Assign a dictionary where the keys are the column names of",
            "    the related models to filter, the value for each key, is a list of lists with the",
            "    same format as base_filter",
            "    {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "    Add a custom filter to form related fields::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact, db.session)",
            "            edit_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "    order_rel_fields = None",
            "    \"\"\"",
            "    Impose order on related fields.",
            "    assign a dictionary where the keys are the related column names::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact)",
            "            order_rel_fields = {",
            "                'group': ('name', 'asc')",
            "                'gender': ('name', 'asc')",
            "            }",
            "    \"\"\"",
            "    list_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    add_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    edit_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    show_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    model2schemaconverter = Model2SchemaConverter",
            "    \"\"\"",
            "    Override to use your own Model2SchemaConverter",
            "    (inherit from BaseModel2SchemaConverter)",
            "    \"\"\"",
            "    _apispec_parameter_schemas = {",
            "        \"get_info_schema\": get_info_schema,",
            "        \"get_item_schema\": get_item_schema,",
            "        \"get_list_schema\": get_list_schema,",
            "    }",
            "",
            "    def __init__(self) -> None:",
            "        super(ModelRestApi, self).__init__()",
            "        self.validators_columns = self.validators_columns or {}",
            "        self.model2schemaconverter = self.model2schemaconverter(",
            "            self.datamodel, self.validators_columns",
            "        )",
            "",
            "    def create_blueprint(",
            "        self, appbuilder: \"AppBuilder\", *args: Any, **kwargs: Any",
            "    ) -> Blueprint:",
            "        self._init_model_schemas()",
            "        return super(ModelRestApi, self).create_blueprint(appbuilder, *args, **kwargs)",
            "",
            "    @property",
            "    def list_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.get_list\"",
            "",
            "    @property",
            "    def show_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.get\"",
            "",
            "    @property",
            "    def add_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.post\"",
            "",
            "    @property",
            "    def edit_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.put\"",
            "",
            "    def add_apispec_components(self, api_spec: APISpec) -> None:",
            "        super(ModelRestApi, self).add_apispec_components(api_spec)",
            "        api_spec.components.schema(",
            "            self.list_model_schema_name, schema=self.list_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.add_model_schema_name, schema=self.add_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.edit_model_schema_name, schema=self.edit_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.show_model_schema_name, schema=self.show_model_schema",
            "        )",
            "",
            "    def _init_model_schemas(self) -> None:",
            "        # Create Marshmalow schemas if one is not specified",
            "        if self.list_model_schema is None:",
            "            self.list_model_schema = self.model2schemaconverter.convert(",
            "                self.list_columns, parent_schema_name=self.list_model_schema_name",
            "            )",
            "        if self.add_model_schema is None:",
            "            self.add_model_schema = self.model2schemaconverter.convert(",
            "                self.add_columns,",
            "                nested=False,",
            "                enum_dump_by_name=True,",
            "                parent_schema_name=self.add_model_schema_name,",
            "            )",
            "        if self.edit_model_schema is None:",
            "            self.edit_model_schema = self.model2schemaconverter.convert(",
            "                self.edit_columns,",
            "                nested=False,",
            "                enum_dump_by_name=True,",
            "                parent_schema_name=self.edit_model_schema_name,",
            "            )",
            "        if self.show_model_schema is None:",
            "            self.show_model_schema = self.model2schemaconverter.convert(",
            "                self.show_columns, parent_schema_name=self.show_model_schema_name",
            "            )",
            "",
            "    def _init_titles(self) -> None:",
            "        \"\"\"",
            "        Init Titles if not defined",
            "        \"\"\"",
            "        super(ModelRestApi, self)._init_titles()",
            "        class_name = self.datamodel.model_name",
            "        if not self.list_title:",
            "            self.list_title = \"List \" + self._prettify_name(class_name)",
            "        if not self.add_title:",
            "            self.add_title = \"Add \" + self._prettify_name(class_name)",
            "        if not self.edit_title:",
            "            self.edit_title = \"Edit \" + self._prettify_name(class_name)",
            "        if not self.show_title:",
            "            self.show_title = \"Show \" + self._prettify_name(class_name)",
            "        self.title = self.list_title",
            "",
            "    def _init_properties(self) -> None:",
            "        \"\"\"",
            "        Initializes all properties",
            "        \"\"\"",
            "        super(ModelRestApi, self)._init_properties()",
            "        # Reset init props",
            "        self.description_columns = self.description_columns or {}",
            "        self.list_exclude_columns = self.list_exclude_columns or []",
            "        self.show_exclude_columns = self.show_exclude_columns or []",
            "        self.add_exclude_columns = self.add_exclude_columns or []",
            "        self.edit_exclude_columns = self.edit_exclude_columns or []",
            "        self.order_rel_fields = self.order_rel_fields or {}",
            "        # Generate base props",
            "        list_cols = self.datamodel.get_user_columns_list()",
            "        if not self.list_columns and self.list_model_schema:",
            "            list(self.list_model_schema._declared_fields.keys())",
            "        else:",
            "            self.list_columns = self.list_columns or [",
            "                x",
            "                for x in self.datamodel.get_user_columns_list()",
            "                if x not in self.list_exclude_columns",
            "            ]",
            "        self.list_select_columns = self.list_select_columns or self.list_columns",
            "",
            "        self.order_columns = (",
            "            self.order_columns",
            "            or self.datamodel.get_order_columns_list(list_columns=self.list_columns)",
            "        )",
            "        # Process excluded columns",
            "        if not self.show_columns:",
            "            self.show_columns = [",
            "                x for x in list_cols if x not in self.show_exclude_columns",
            "            ]",
            "        self.show_select_columns = self.show_select_columns or self.show_columns",
            "",
            "        if not self.add_columns:",
            "            self.add_columns = [",
            "                x for x in list_cols if x not in self.add_exclude_columns",
            "            ]",
            "        if not self.edit_columns:",
            "            self.edit_columns = [",
            "                x for x in list_cols if x not in self.edit_exclude_columns",
            "            ]",
            "        self._gen_labels_columns(self.list_columns)",
            "        self._gen_labels_columns(self.show_columns)",
            "        self._filters = self.datamodel.get_filters(",
            "            search_columns=self.search_columns, search_filters=self.search_filters",
            "        )",
            "        self.edit_query_rel_fields = self.edit_query_rel_fields or dict()",
            "        self.add_query_rel_fields = self.add_query_rel_fields or dict()",
            "",
            "    def merge_add_field_info(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        add_columns_info = kwargs.get(\"add_columns\", {})",
            "        response[API_ADD_COLUMNS_RES_KEY] = self._get_fields_info(",
            "            self.add_columns,",
            "            self.add_model_schema,",
            "            self.add_query_rel_fields,",
            "            **add_columns_info,",
            "        )",
            "",
            "    def merge_edit_field_info(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        edit_columns_info = kwargs.get(\"edit_columns\", {})",
            "        response[API_EDIT_COLUMNS_RES_KEY] = self._get_fields_info(",
            "            self.edit_columns,",
            "            self.edit_model_schema,",
            "            self.edit_query_rel_fields,",
            "            **edit_columns_info,",
            "        )",
            "",
            "    def merge_search_filters(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        # Get possible search fields and all possible operations",
            "        search_filters = {}",
            "        dict_filters = self._filters.get_search_filters()",
            "        for col in self.search_columns:",
            "            if col not in dict_filters:",
            "                # column not in search filters but defined has one",
            "                continue",
            "            search_filters[col] = [",
            "                {\"name\": as_unicode(flt.name), \"operator\": flt.arg_name}",
            "                for flt in dict_filters[col]",
            "            ]",
            "        response[API_FILTERS_RES_KEY] = search_filters",
            "",
            "    def merge_add_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_ADD_TITLE_RES_KEY] = self.add_title",
            "",
            "    def merge_edit_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_EDIT_TITLE_RES_KEY] = self.edit_title",
            "",
            "    def merge_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            columns = pruned_select_cols",
            "        else:",
            "            # Send the exact labels for the caller operation",
            "            if kwargs.get(\"caller\") == \"list\":",
            "                columns = self.list_columns",
            "            elif kwargs.get(\"caller\") == \"show\":",
            "                columns = self.show_columns",
            "            else:",
            "                columns = self.label_columns  # pragma: no cover",
            "        response[API_LABEL_COLUMNS_RES_KEY] = self._label_columns_json(columns)",
            "",
            "    def merge_list_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        self.merge_label_columns(response, caller=\"list\", **kwargs)",
            "",
            "    def merge_show_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        self.merge_label_columns(response, caller=\"show\", **kwargs)",
            "",
            "    def merge_show_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_SHOW_COLUMNS_RES_KEY] = pruned_select_cols",
            "        else:",
            "            response[API_SHOW_COLUMNS_RES_KEY] = self.show_columns",
            "",
            "    def merge_description_columns(",
            "        self, response: Dict[str, Any], **kwargs: Any",
            "    ) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_DESCRIPTION_COLUMNS_RES_KEY] = self._description_columns_json(",
            "                pruned_select_cols",
            "            )",
            "        else:",
            "            # Send all descriptions if cols are or request pruned",
            "            response[API_DESCRIPTION_COLUMNS_RES_KEY] = self._description_columns_json(",
            "                self.description_columns",
            "            )",
            "",
            "    def merge_list_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_LIST_COLUMNS_RES_KEY] = pruned_select_cols",
            "        else:",
            "            response[API_LIST_COLUMNS_RES_KEY] = self.list_columns",
            "",
            "    def merge_order_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_ORDER_COLUMNS_RES_KEY] = [",
            "                order_col",
            "                for order_col in self.order_columns",
            "                if order_col in pruned_select_cols",
            "            ]",
            "        else:",
            "            response[API_ORDER_COLUMNS_RES_KEY] = self.order_columns",
            "",
            "    def merge_list_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_LIST_TITLE_RES_KEY] = self.list_title",
            "",
            "    def merge_show_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_SHOW_TITLE_RES_KEY] = self.show_title",
            "",
            "    def info_headless(self, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        response for CRUD REST meta data",
            "        \"\"\"",
            "        payload = {}",
            "        rison_args = kwargs.get(\"rison\", {})",
            "        self.set_response_key_mappings(payload, self.info, rison_args, **rison_args)",
            "        return self.response(200, **payload)",
            "",
            "    @expose(\"/_info\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @rison(get_info_schema)",
            "    @permission_name(\"info\")",
            "    @merge_response_func(",
            "        BaseApi.merge_current_user_permissions, API_PERMISSIONS_RIS_KEY",
            "    )",
            "    @merge_response_func(merge_add_field_info, API_ADD_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_edit_field_info, API_EDIT_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_search_filters, API_FILTERS_RIS_KEY)",
            "    @merge_response_func(merge_add_title, API_ADD_TITLE_RIS_KEY)",
            "    @merge_response_func(merge_edit_title, API_EDIT_TITLE_RIS_KEY)",
            "    def info(self, **kwargs: Any) -> Response:",
            "        \"\"\"Endpoint that renders a response for CRUD REST meta data",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get metadata information about this API resource",
            "          parameters:",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_info_schema'",
            "          responses:",
            "            200:",
            "              description: Item from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      add_columns:",
            "                        type: object",
            "                      edit_columns:",
            "                        type: object",
            "                      filters:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            type: array",
            "                            items:",
            "                              type: object",
            "                              properties:",
            "                                name:",
            "                                  description: >-",
            "                                    The filter name. Will be translated by babel",
            "                                  type: string",
            "                                operator:",
            "                                  description: >-",
            "                                    The filter operation key to use on list filters",
            "                                  type: string",
            "                      permissions:",
            "                        description: The user permissions for this API resource",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.info_headless(**kwargs)",
            "",
            "    def get_headless(self, pk: ModelKeyType, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "            Get an item from Model",
            "",
            "        :param pk: Item primary key",
            "        :param kwargs: Query string parameter arguments",
            "        :return: HTTP Response",
            "        \"\"\"",
            "        item = self.datamodel.get(",
            "            pk,",
            "            self._base_filters,",
            "            self.show_select_columns,",
            "            self.show_outer_default_load,",
            "        )",
            "        if not item:",
            "            return self.response_404()",
            "",
            "        response = {}",
            "        args = kwargs.get(\"rison\", {})",
            "        select_cols = args.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        pruned_select_cols = [col for col in select_cols if col in self.show_columns]",
            "        self.set_response_key_mappings(",
            "            response, self.get, args, **{API_SELECT_COLUMNS_RIS_KEY: pruned_select_cols}",
            "        )",
            "        if pruned_select_cols:",
            "            show_model_schema = self.model2schemaconverter.convert(pruned_select_cols)",
            "        else:",
            "            show_model_schema = self.show_model_schema",
            "",
            "        response[\"id\"] = pk",
            "        response[API_RESULT_RES_KEY] = show_model_schema.dump(item, many=False)",
            "        self.pre_get(response)",
            "        return self.response(200, **response)",
            "",
            "    @expose(\"/<int:pk>\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"get\")",
            "    @rison(get_item_schema)",
            "    @merge_response_func(merge_show_label_columns, API_LABEL_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_show_columns, API_SHOW_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_description_columns, API_DESCRIPTION_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_show_title, API_SHOW_TITLE_RIS_KEY)",
            "    def get(self, pk: ModelKeyType, **kwargs: Any) -> Response:",
            "        \"\"\"Get item from Model",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get an item model",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_item_schema'",
            "          responses:",
            "            200:",
            "              description: Item from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      label_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The label for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice label for the column",
            "                            type: string",
            "                      show_columns:",
            "                        description: >-",
            "                          A list of columns",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      description_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The description for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice description for the column",
            "                            type: string",
            "                      show_title:",
            "                        description: >-",
            "                          A title to render.",
            "                          Will be translated by babel",
            "                        example: Show Item Details",
            "                        type: string",
            "                      id:",
            "                        description: The item id",
            "                        type: string",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.get'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.get_headless(pk, **kwargs)",
            "",
            "    def get_list_headless(self, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        Get list of items from Model",
            "        \"\"\"",
            "        response = dict()",
            "        args = kwargs.get(\"rison\", {})",
            "        # handle select columns",
            "        select_cols = args.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        pruned_select_cols = [col for col in select_cols if col in self.list_columns]",
            "        # map decorated metadata",
            "        self.set_response_key_mappings(",
            "            response,",
            "            self.get_list,",
            "            args,",
            "            **{API_SELECT_COLUMNS_RIS_KEY: pruned_select_cols},",
            "        )",
            "        # Create a response schema with the computed response columns,",
            "        # defined or requested",
            "        if pruned_select_cols:",
            "            list_model_schema = self.model2schemaconverter.convert(pruned_select_cols)",
            "        else:",
            "            list_model_schema = self.list_model_schema",
            "        # handle filters",
            "        try:",
            "            joined_filters = self._handle_filters_args(args)",
            "        except FABException as e:",
            "            return self.response_400(message=str(e))",
            "        # handle base order",
            "        try:",
            "            order_column, order_direction = self._handle_order_args(args)",
            "        except InvalidOrderByColumnFABException as e:",
            "            return self.response_400(message=str(e))",
            "        # handle pagination",
            "        page_index, page_size = self._handle_page_args(args)",
            "        # Make the query",
            "        count, lst = self.datamodel.query(",
            "            joined_filters,",
            "            order_column,",
            "            order_direction,",
            "            page=page_index,",
            "            page_size=page_size,",
            "            select_columns=self.list_select_columns,",
            "            outer_default_load=self.list_outer_default_load,",
            "        )",
            "        pks = self.datamodel.get_keys(lst)",
            "        response[API_RESULT_RES_KEY] = list_model_schema.dump(lst, many=True)",
            "        response[\"ids\"] = pks",
            "        response[\"count\"] = count",
            "        self.pre_get_list(response)",
            "        return self.response(200, **response)",
            "",
            "    @expose(\"/\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"get\")",
            "    @rison(get_list_schema)",
            "    @merge_response_func(merge_order_columns, API_ORDER_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_label_columns, API_LABEL_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_description_columns, API_DESCRIPTION_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_columns, API_LIST_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_title, API_LIST_TITLE_RIS_KEY)",
            "    def get_list(self, **kwargs: Any) -> Response:",
            "        \"\"\"Get list of items from Model",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get a list of models",
            "          parameters:",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_list_schema'",
            "          responses:",
            "            200:",
            "              description: Items from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      label_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The label for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice label for the column",
            "                            type: string",
            "                      list_columns:",
            "                        description: >-",
            "                          A list of columns",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      description_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The description for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice description for the column",
            "                            type: string",
            "                      list_title:",
            "                        description: >-",
            "                          A title to render.",
            "                          Will be translated by babel",
            "                        example: List Items",
            "                        type: string",
            "                      ids:",
            "                        description: >-",
            "                          A list of item ids, useful when you don't know the column id",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      count:",
            "                        description: >-",
            "                          The total record count on the backend",
            "                        type: number",
            "                      order_columns:",
            "                        description: >-",
            "                          A list of allowed columns to sort",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      result:",
            "                        description: >-",
            "                          The result from the get list query",
            "                        type: array",
            "                        items:",
            "                          $ref: '#/components/schemas/{{self.__class__.__name__}}.get_list'  # noqa",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.get_list_headless(**kwargs)",
            "",
            "    def post_headless(self) -> Response:",
            "        \"\"\"",
            "        POST/Add item to Model",
            "        \"\"\"",
            "        if not request.is_json:",
            "            return self.response_400(message=\"Request is not JSON\")",
            "        try:",
            "            item = self.add_model_schema.load(request.json)",
            "        except ValidationError as err:",
            "            return self.response_422(message=err.messages)",
            "        # This validates custom Schema with custom validations",
            "        self.pre_add(item)",
            "        try:",
            "            self.datamodel.add(item, raise_exception=True)",
            "            self.post_add(item)",
            "            return self.response(",
            "                201,",
            "                **{",
            "                    API_RESULT_RES_KEY: self.add_model_schema.dump(item, many=False),",
            "                    \"id\": self.datamodel.get_pk_value(item),",
            "                },",
            "            )",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/\", methods=[\"POST\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"post\")",
            "    def post(self) -> Response:",
            "        \"\"\"POST item to Model",
            "        ---",
            "        post:",
            "          requestBody:",
            "            description: Model schema",
            "            required: true",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/{{self.__class__.__name__}}.post'",
            "          responses:",
            "            201:",
            "              description: Item inserted",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      id:",
            "                        type: string",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.post'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.post_headless()",
            "",
            "    def put_headless(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"",
            "        PUT/Edit item to Model",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not request.is_json:",
            "            return self.response(400, **{\"message\": \"Request is not JSON\"})",
            "        if not item:",
            "            return self.response_404()",
            "        try:",
            "            data = self._merge_update_item(item, request.json)",
            "            item = self.edit_model_schema.load(data, instance=item)",
            "        except ValidationError as err:",
            "            return self.response_422(message=err.messages)",
            "        self.pre_update(item)",
            "        try:",
            "            self.datamodel.edit(item, raise_exception=True)",
            "            self.post_update(item)",
            "            return self.response(",
            "                200,",
            "                **{API_RESULT_RES_KEY: self.edit_model_schema.dump(item, many=False)},",
            "            )",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/<pk>\", methods=[\"PUT\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"put\")",
            "    def put(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"PUT item to Model",
            "        ---",
            "        put:",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          requestBody:",
            "            description: Model schema",
            "            required: true",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/{{self.__class__.__name__}}.put'",
            "          responses:",
            "            200:",
            "              description: Item changed",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.put'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.put_headless(pk)",
            "",
            "    def delete_headless(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"",
            "        Delete item from Model",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            return self.response_404()",
            "        self.pre_delete(item)",
            "        try:",
            "            self.datamodel.delete(item, raise_exception=True)",
            "            self.post_delete(item)",
            "            return self.response(200, message=\"OK\")",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/<pk>\", methods=[\"DELETE\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"delete\")",
            "    def delete(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"Delete item from Model",
            "        ---",
            "        delete:",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          responses:",
            "            200:",
            "              description: Item deleted",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      message:",
            "                        type: string",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.delete_headless(pk)",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                HELPER FUNCTIONS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _handle_page_args(",
            "        self, rison_args: Dict[str, Any]",
            "    ) -> Tuple[Optional[int], Optional[int]]:",
            "        \"\"\"",
            "        Helper function to handle rison page",
            "        arguments, sets defaults and impose",
            "        FAB_API_MAX_PAGE_SIZE",
            "",
            "        :param rison_args:",
            "        :return: (tuple) page, page_size",
            "        \"\"\"",
            "        page = rison_args.get(API_PAGE_INDEX_RIS_KEY, 0)",
            "        page_size = rison_args.get(API_PAGE_SIZE_RIS_KEY, self.page_size)",
            "        return self._sanitize_page_args(page, page_size)",
            "",
            "    def _sanitize_page_args(",
            "        self, page: Optional[int], page_size: Optional[int]",
            "    ) -> Tuple[Optional[int], Optional[int]]:",
            "        page_ = page or 0",
            "        page_size_ = page_size or self.page_size",
            "        max_page_size = self.max_page_size or current_app.config.get(",
            "            \"FAB_API_MAX_PAGE_SIZE\"",
            "        )",
            "        # Accept special -1 to uncap the page size",
            "        if max_page_size == -1:",
            "            if page_size_ == -1:",
            "                return None, None",
            "            else:",
            "                return page_, page_size_",
            "        if page_size_ > max_page_size or page_size_ < 1:",
            "            page_size_ = max_page_size",
            "        return page_, page_size_",
            "",
            "    def _handle_order_args(self, rison_args: Dict[str, Any]) -> Tuple[str, str]:",
            "        \"\"\"",
            "        Help function to handle rison order",
            "        arguments",
            "",
            "        :param rison_args:",
            "        :return:",
            "        \"\"\"",
            "        order_column = rison_args.get(API_ORDER_COLUMN_RIS_KEY, \"\")",
            "        order_direction = rison_args.get(API_ORDER_DIRECTION_RIS_KEY, \"\")",
            "        if not order_column and self.base_order:",
            "            return self.base_order",
            "        if not order_column:",
            "            return \"\", \"\"",
            "        elif self.order_columns and order_column not in self.order_columns:",
            "            raise InvalidOrderByColumnFABException(",
            "                f\"Invalid order by column: {order_column}\"",
            "            )",
            "        return order_column, order_direction",
            "",
            "    def _handle_filters_args(self, rison_args: Dict[str, Any]) -> Filters:",
            "        self._filters.clear_filters()",
            "        self._filters.rest_add_filters(rison_args.get(API_FILTERS_RIS_KEY, []))",
            "        return self._filters.get_joined_filters(self._base_filters)",
            "",
            "    def _description_columns_json(",
            "        self, cols: Optional[List[str]] = None",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Prepares dict with col descriptions to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        cols = cols or []",
            "        d = {k: v for (k, v) in self.description_columns.items() if k in cols}",
            "        for key, value in d.items():",
            "            ret[key] = as_unicode(_(value).encode(\"UTF-8\"))",
            "        return ret",
            "",
            "    def _get_field_info(",
            "        self,",
            "        field: Field,",
            "        filter_rel_field: Dict[str, Any],",
            "        page: Optional[int] = None,",
            "        page_size: Optional[int] = None,",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Return a dict with field details",
            "        ready to serve as a response",
            "",
            "        :param field: marshmallow field",
            "        :return: dict with field details",
            "        \"\"\"",
            "        ret = {",
            "            \"name\": field.name,",
            "            \"label\": _(self.label_columns.get(field.name, \"\")),",
            "            \"description\": _(self.description_columns.get(field.name, \"\")),",
            "            \"type\": field.__class__.__name__,",
            "            \"required\": field.required,",
            "            # When using custom marshmallow schemas fields don't have unique property",
            "            \"unique\": getattr(field, \"unique\", False),",
            "        }",
            "        # Handles related fields",
            "        if isinstance(field, Related) or isinstance(field, RelatedList):",
            "            ret[\"count\"], ret[\"values\"] = self._get_list_related_field(",
            "                field, filter_rel_field, page=page, page_size=page_size",
            "            )",
            "        if field.validate and isinstance(field.validate, list):",
            "            ret[\"validate\"] = [str(v) for v in field.validate]",
            "        elif field.validate:",
            "            ret[\"validate\"] = [str(field.validate)]",
            "        return ret",
            "",
            "    def _get_fields_info(",
            "        self,",
            "        cols: List[str],",
            "        model_schema: Schema,",
            "        filter_rel_fields: QueryRelatedFieldsFilters,",
            "        **kwargs: Any,",
            "    ) -> List[Dict[str, Any]]:",
            "        \"\"\"",
            "        Returns a dict with fields detail",
            "        from a marshmallow schema",
            "",
            "        :param cols: list of columns to show info for",
            "        :param model_schema: Marshmallow model schema",
            "        :param filter_rel_fields: expects add_query_rel_fields or",
            "                                    edit_query_rel_fields",
            "        :param kwargs: Receives all rison arguments for pagination",
            "        :return: dict with all fields details",
            "        \"\"\"",
            "        ret = []",
            "        for col in cols:",
            "            page = page_size = None",
            "            col_args = kwargs.get(col, {})",
            "            if col_args:",
            "                page = col_args.get(API_PAGE_INDEX_RIS_KEY, None)",
            "                page_size = col_args.get(API_PAGE_SIZE_RIS_KEY, None)",
            "            ret.append(",
            "                self._get_field_info(",
            "                    model_schema.fields[col],",
            "                    filter_rel_fields.get(col, []),",
            "                    page=page,",
            "                    page_size=page_size,",
            "                )",
            "            )",
            "        return ret",
            "",
            "    def _get_list_related_field(",
            "        self,",
            "        field: Field,",
            "        filter_rel_field: List[Any],",
            "        page: Optional[int] = None,",
            "        page_size: Optional[int] = None,",
            "    ) -> Tuple[int, List[Dict[str, Any]]]:",
            "        \"\"\"",
            "        Return a list of values for a related field",
            "",
            "        :param field: Marshmallow field",
            "        :param filter_rel_field: Filters for the related field,",
            "                expects [field_name, Type[BaseFilter], value]",
            "        :param page: The page index",
            "        :param page_size: The page size",
            "        :return: Total record count and list of dict with id and value",
            "        \"\"\"",
            "        ret = []",
            "        count = 0",
            "        if isinstance(field, Related) or isinstance(field, RelatedList):",
            "            datamodel = self.datamodel.get_related_interface(field.name)",
            "            filters = datamodel.get_filters(datamodel.get_search_columns_list())",
            "            page, page_size = self._sanitize_page_args(page, page_size)",
            "            order_field = self.order_rel_fields.get(field.name)",
            "            if order_field:",
            "                order_column, order_direction = order_field",
            "            else:",
            "                order_column, order_direction = \"\", \"\"",
            "            if filter_rel_field:",
            "                filters = filters.add_filter_list(filter_rel_field)",
            "            count, values = datamodel.query(",
            "                filters, order_column, order_direction, page=page, page_size=page_size",
            "            )",
            "            for value in values:",
            "                ret.append({\"id\": datamodel.get_pk_value(value), \"value\": str(value)})",
            "        return count, ret",
            "",
            "    def _merge_update_item(",
            "        self, model_item: Model, data: Dict[str, Any]",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Merge a model with a python data structure",
            "        This is useful to turn PUT method into a PATCH also",
            "        \"\"\"",
            "        data_item = self.edit_model_schema.dump(model_item, many=False)",
            "        for _col in self.edit_columns:",
            "            if _col not in data.keys():",
            "                data[_col] = data_item[_col]",
            "        return data",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                PRE AND POST METHODS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def pre_update(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, this method is called before the update takes place.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_update(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_add(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called before add.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_add(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_delete(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called before delete",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_delete(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after delete",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_get(self, data: Dict[str, Any]) -> None:",
            "        \"\"\"",
            "        Override this, will be called before data is sent",
            "        to the requester on get item endpoint.",
            "        You can use it to mutate the response sent.",
            "        Note that any new field added will not be reflected on the OpenApi spec.",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_get_list(self, data: Dict[str, Any]) -> None:",
            "        \"\"\"",
            "        Override this, will be called before data is sent",
            "        to the requester on get list endpoint.",
            "        You can use it to mutate the response sent",
            "        Note that any new field added will not be reflected on the OpenApi spec.",
            "        \"\"\"",
            "        pass"
        ],
        "afterPatchFile": [
            "import functools",
            "import json",
            "import logging",
            "import re",
            "import traceback",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    Union,",
            ")",
            "import urllib.parse",
            "",
            "from apispec import APISpec, yaml_utils",
            "from apispec.exceptions import DuplicateComponentNameError",
            "from flask import Blueprint, current_app, jsonify, make_response, request, Response",
            "from flask_appbuilder.models.sqla import Model",
            "from flask_appbuilder.models.sqla.interface import SQLAInterface",
            "from flask_babel import lazy_gettext as _",
            "import jsonschema",
            "from marshmallow import Schema, ValidationError",
            "from marshmallow.fields import Field",
            "from marshmallow_sqlalchemy.fields import Related, RelatedList",
            "import prison",
            "from sqlalchemy.exc import IntegrityError",
            "from werkzeug.exceptions import BadRequest",
            "import yaml",
            "",
            "from .convert import Model2SchemaConverter",
            "from .schemas import get_info_schema, get_item_schema, get_list_schema",
            "from .._compat import as_unicode",
            "from ..baseviews import AbstractViewApi",
            "from ..const import (",
            "    API_ADD_COLUMNS_RES_KEY,",
            "    API_ADD_COLUMNS_RIS_KEY,",
            "    API_ADD_TITLE_RES_KEY,",
            "    API_ADD_TITLE_RIS_KEY,",
            "    API_DESCRIPTION_COLUMNS_RES_KEY,",
            "    API_DESCRIPTION_COLUMNS_RIS_KEY,",
            "    API_EDIT_COLUMNS_RES_KEY,",
            "    API_EDIT_COLUMNS_RIS_KEY,",
            "    API_EDIT_TITLE_RES_KEY,",
            "    API_EDIT_TITLE_RIS_KEY,",
            "    API_FILTERS_RES_KEY,",
            "    API_FILTERS_RIS_KEY,",
            "    API_LABEL_COLUMNS_RES_KEY,",
            "    API_LABEL_COLUMNS_RIS_KEY,",
            "    API_LIST_COLUMNS_RES_KEY,",
            "    API_LIST_COLUMNS_RIS_KEY,",
            "    API_LIST_TITLE_RES_KEY,",
            "    API_LIST_TITLE_RIS_KEY,",
            "    API_ORDER_COLUMN_RIS_KEY,",
            "    API_ORDER_COLUMNS_RES_KEY,",
            "    API_ORDER_COLUMNS_RIS_KEY,",
            "    API_ORDER_DIRECTION_RIS_KEY,",
            "    API_PAGE_INDEX_RIS_KEY,",
            "    API_PAGE_SIZE_RIS_KEY,",
            "    API_PERMISSIONS_RES_KEY,",
            "    API_PERMISSIONS_RIS_KEY,",
            "    API_RESULT_RES_KEY,",
            "    API_SELECT_COLUMNS_RIS_KEY,",
            "    API_SHOW_COLUMNS_RES_KEY,",
            "    API_SHOW_COLUMNS_RIS_KEY,",
            "    API_SHOW_TITLE_RES_KEY,",
            "    API_SHOW_TITLE_RIS_KEY,",
            "    API_URI_RIS_KEY,",
            "    PERMISSION_PREFIX,",
            ")",
            "from ..exceptions import FABException, InvalidOrderByColumnFABException",
            "from ..hooks import get_before_request_hooks, wrap_route_handler_with_hooks",
            "from ..models.filters import Filters",
            "from ..security.decorators import permission_name, protect",
            "from ..utils.limit import Limit",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder import AppBuilder",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "ModelKeyType = Union[str, int]",
            "QueryRelatedFieldsFilters = Dict[str, List[List[Any]]]",
            "",
            "",
            "def get_error_msg() -> str:",
            "    \"\"\"",
            "    (inspired on Superset code)",
            "    :return: (str)",
            "    \"\"\"",
            "    if current_app.config.get(\"FAB_API_SHOW_STACKTRACE\"):",
            "        return traceback.format_exc()",
            "    return \"Fatal error\"",
            "",
            "",
            "def safe(f: Callable[..., Any]) -> Callable[..., Any]:",
            "    \"\"\"",
            "    A decorator that catches uncaught exceptions and",
            "    return the response in JSON format (inspired on Superset code)",
            "    \"\"\"",
            "",
            "    def wraps(self: \"BaseApi\", *args: Any, **kwargs: Any) -> Response:",
            "        try:",
            "            return f(self, *args, **kwargs)",
            "        except BadRequest as e:",
            "            return self.response_400(message=str(e))",
            "        except Exception as e:",
            "            log.exception(e)",
            "            return self.response_500(message=get_error_msg())",
            "",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def rison(",
            "    schema: Optional[Dict[str, Any]] = None",
            ") -> Callable[[Callable[..., Any]], Callable[..., Any]]:",
            "    \"\"\"",
            "    Use this decorator to parse URI *Rison* arguments to",
            "    a python data structure, your method gets the data",
            "    structure on kwargs['rison']. Response is HTTP 400",
            "    if *Rison* is not correct::",
            "",
            "        class ExampleApi(BaseApi):",
            "                @expose('/risonjson')",
            "                @rison()",
            "                def rison_json(self, **kwargs):",
            "                    return self.response(200, result=kwargs['rison'])",
            "",
            "    You can additionally pass a JSON schema to",
            "    validate Rison arguments::",
            "",
            "        schema = {",
            "            \"type\": \"object\",",
            "            \"properties\": {",
            "                \"arg1\": {",
            "                    \"type\": \"integer\"",
            "                }",
            "            }",
            "        }",
            "",
            "        class ExampleApi(BaseApi):",
            "                @expose('/risonjson')",
            "                @rison(schema)",
            "                def rison_json(self, **kwargs):",
            "                    return self.response(200, result=kwargs['rison'])",
            "",
            "    \"\"\"",
            "",
            "    def _rison(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        def wraps(self: \"BaseApi\", *args: Any, **kwargs: Any) -> Response:",
            "            value = request.args.get(API_URI_RIS_KEY, None)",
            "            kwargs[\"rison\"] = dict()",
            "            if value:",
            "                try:",
            "                    kwargs[\"rison\"] = prison.loads(value)",
            "                except prison.decoder.ParserException:",
            "                    if current_app.config.get(\"FAB_API_ALLOW_JSON_QS\", True):",
            "                        # Rison failed try json encoded content",
            "                        try:",
            "                            kwargs[\"rison\"] = json.loads(",
            "                                urllib.parse.parse_qs(f\"{API_URI_RIS_KEY}={value}\").get(",
            "                                    API_URI_RIS_KEY",
            "                                )[0]",
            "                            )",
            "                        except Exception:",
            "                            return self.response_400(",
            "                                message=\"Not a valid rison/json argument\"",
            "                            )",
            "                    else:",
            "                        return self.response_400(message=\"Not a valid rison argument\")",
            "            if schema:",
            "                try:",
            "                    jsonschema.validate(instance=kwargs[\"rison\"], schema=schema)",
            "                except jsonschema.ValidationError as e:",
            "                    return self.response_400(message=f\"Not a valid rison schema {e}\")",
            "            return f(self, *args, **kwargs)",
            "",
            "        return functools.update_wrapper(wraps, f)",
            "",
            "    return _rison",
            "",
            "",
            "def expose(url: str = \"/\", methods: Tuple[str] = (\"GET\",)) -> Callable[..., Any]:",
            "    \"\"\"",
            "    Use this decorator to expose API endpoints on your API classes.",
            "",
            "    :param url:",
            "        Relative URL for the endpoint",
            "    :param methods:",
            "        Allowed HTTP methods. By default only GET is allowed.",
            "    \"\"\"",
            "",
            "    def wrap(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []  # type: ignore",
            "        f._urls.append((url, methods))  # type: ignore",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "def merge_response_func(func: Callable[..., Any], key: str) -> Callable[..., Any]:",
            "    \"\"\"",
            "        Use this decorator to set a new merging",
            "        response function to HTTP endpoints",
            "",
            "        candidate function must have the following signature",
            "        and be childs of BaseApi:",
            "        ```",
            "            def merge_some_function(self, response, rison_args):",
            "        ```",
            "",
            "    :param func: Name of the merge function where the key is allowed",
            "    :param key: The key name for rison selection",
            "    :return: None",
            "    \"\"\"",
            "",
            "    def wrap(f: Callable[..., Any]) -> Callable[..., Any]:",
            "        if not hasattr(f, \"_response_key_func_mappings\"):",
            "            f._response_key_func_mappings = {}  # type: ignore",
            "        f._response_key_func_mappings[key] = func  # type: ignore",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "class BaseApi(AbstractViewApi):",
            "    \"\"\"",
            "    All apis inherit from this class.",
            "    it's constructor will register your exposed urls on flask",
            "    as a Blueprint.",
            "",
            "    This class does not expose any urls,",
            "    but provides a common base for all APIS.",
            "    \"\"\"",
            "",
            "    endpoint: Optional[str] = None",
            "",
            "    version: Optional[str] = \"v1\"",
            "    \"\"\"",
            "        Define the Api version for this resource/class",
            "    \"\"\"",
            "    route_base: Optional[str] = None",
            "    \"\"\"",
            "        Define the route base where all methods will suffix from",
            "    \"\"\"",
            "    resource_name: Optional[str] = None",
            "    \"\"\"",
            "        Defines a custom resource name, overrides the inferred from Class name",
            "        makes no sense to use it with route base",
            "    \"\"\"",
            "    base_permissions: Optional[List[str]] = None",
            "    \"\"\"",
            "        A list of allowed base permissions::",
            "",
            "            class ExampleApi(BaseApi):",
            "                base_permissions = ['can_get']",
            "",
            "    \"\"\"",
            "    class_permission_name: Optional[str] = None",
            "    \"\"\"",
            "        Override class permission name default fallback to self.__class__.__name__",
            "    \"\"\"",
            "    previous_class_permission_name: Optional[str] = None",
            "    \"\"\"",
            "        If set security converge will replace all permissions tuples",
            "        with this name by the class_permission_name or self.__class__.__name__",
            "    \"\"\"",
            "    method_permission_name: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "        Override method permission names, example::",
            "",
            "            method_permissions_name = {",
            "                'get_list': 'read',",
            "                'get': 'read',",
            "                'put': 'write',",
            "                'post': 'write',",
            "                'delete': 'write'",
            "            }",
            "    \"\"\"",
            "    previous_method_permission_name: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "        Use same structure as method_permission_name. If set security converge",
            "        will replace all method permissions by the new ones",
            "    \"\"\"",
            "    allow_browser_login = False",
            "    \"\"\"",
            "        Will allow flask-login cookie authorization on the API",
            "        default is False.",
            "    \"\"\"",
            "    csrf_exempt = True",
            "    \"\"\"",
            "        If using flask-wtf CSRFProtect exempt the API from check",
            "    \"\"\"",
            "    apispec_parameter_schemas: Optional[Dict[str, Dict[str, Any]]] = None",
            "    \"\"\"",
            "        Set your custom Rison parameter schemas here so that",
            "        they get registered on the OpenApi spec::",
            "",
            "            custom_parameter = {",
            "                \"type\": \"object\"",
            "                \"properties\": {",
            "                    \"name\": {",
            "                        \"type\": \"string\"",
            "                    }",
            "                }",
            "            }",
            "",
            "            class CustomApi(BaseApi):",
            "                apispec_parameter_schemas = {",
            "                    \"custom_parameter\": custom_parameter",
            "                }",
            "    \"\"\"",
            "    _apispec_parameter_schemas: Optional[Dict[str, Dict[str, Any]]] = None",
            "",
            "    openapi_spec_component_schemas: Tuple[Type[Schema], ...] = tuple()",
            "    \"\"\"",
            "    A Tuple containing marshmallow schemas to be registered on the OpenAPI spec",
            "    has component schemas, these can be referenced by the endpoint's spec like:",
            "    `$ref: '#/components/schemas/MyCustomSchema'` Where MyCustomSchema is the",
            "    marshmallow schema class name.",
            "",
            "    To set your own OpenAPI schema component name, declare your schemas with:",
            "    __component_name__",
            "",
            "    class Schema1(Schema):",
            "        __component_name__ = \"MyCustomSchema\"",
            "        id = fields.Integer()",
            "        ...",
            "",
            "    \"\"\"",
            "    responses = {",
            "        \"400\": {",
            "            \"description\": \"Bad request\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"401\": {",
            "            \"description\": \"Unauthorized\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"403\": {",
            "            \"description\": \"Forbidden\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"404\": {",
            "            \"description\": \"Not found\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"422\": {",
            "            \"description\": \"Could not process entity\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "        \"500\": {",
            "            \"description\": \"Fatal error\",",
            "            \"content\": {",
            "                \"application/json\": {",
            "                    \"schema\": {",
            "                        \"type\": \"object\",",
            "                        \"properties\": {\"message\": {\"type\": \"string\"}},",
            "                    }",
            "                }",
            "            },",
            "        },",
            "    }",
            "    \"\"\"",
            "        Override custom OpenApi responses",
            "    \"\"\"",
            "",
            "    exclude_route_methods: Set[str] = set()",
            "    \"\"\"",
            "        Does not register routes for a set of builtin ModelRestApi functions.",
            "        example::",
            "",
            "            class ContactModelView(ModelRestApi):",
            "                datamodel = SQLAInterface(Contact)",
            "                exclude_route_methods = {\"info\", \"get_list\", \"get\"}",
            "",
            "",
            "        The previous examples will only register the `put`, `post` and `delete` routes",
            "    \"\"\"",
            "    include_route_methods: Optional[Set[str]] = None",
            "    \"\"\"",
            "        If defined will assume a white list setup, where all endpoints are excluded",
            "        except those define on this attribute",
            "        example::",
            "",
            "            class ContactModelView(ModelRestApi):",
            "                datamodel = SQLAInterface(Contact)",
            "                include_route_methods = {\"list\"}",
            "",
            "",
            "        The previous example will exclude all endpoints except the `list` endpoint",
            "    \"\"\"",
            "    openapi_spec_methods: Dict[str, Any] = {}",
            "    \"\"\"",
            "        Merge OpenAPI spec defined on the method's doc.",
            "        For example to merge/override `get_list`::",
            "",
            "",
            "            class GreetingApi(BaseApi):",
            "                resource_name = \"greeting\"",
            "                openapi_spec_methods = {",
            "                    \"greeting\": {",
            "                        \"get\": {",
            "                           \"description\": \"Override description\",",
            "                        }",
            "                    }",
            "                }",
            "    \"\"\"",
            "    openapi_spec_tag: Optional[str] = None",
            "    \"\"\"",
            "        By default all endpoints will be tagged (grouped) to their class name.",
            "        Use this attribute to override the tag name",
            "    \"\"\"",
            "",
            "    limits: Optional[List[Limit]] = None",
            "    \"\"\"",
            "        List of limits for this api.",
            "",
            "        Use it like this if you want to restrict the rate of requests to a view:",
            "",
            "            class MyView(ModelView):",
            "                limits = [Limit(\"2 per 5 second\")]",
            "",
            "        or use the decorator @limit.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"",
            "        Initialization of base permissions",
            "        based on exposed methods and actions",
            "",
            "        Initialization of extra args",
            "        \"\"\"",
            "        self.appbuilder = None",
            "        self.blueprint = None",
            "",
            "        # Init OpenAPI",
            "        self._response_key_func_mappings: Dict[str, Any] = {}",
            "        self.apispec_parameter_schemas = self.apispec_parameter_schemas or {}",
            "        self._apispec_parameter_schemas = self._apispec_parameter_schemas or {}",
            "        self._apispec_parameter_schemas.update(self.apispec_parameter_schemas)",
            "        if self.openapi_spec_component_schemas is None:",
            "            self.openapi_spec_component_schemas = ()",
            "",
            "        # Init class permission override attrs",
            "        if not self.previous_class_permission_name and self.class_permission_name:",
            "            self.previous_class_permission_name = self.__class__.__name__",
            "        self.class_permission_name = (",
            "            self.class_permission_name or self.__class__.__name__",
            "        )",
            "",
            "        # Init previous permission override attrs",
            "        is_collect_previous = False",
            "        if not self.previous_method_permission_name and self.method_permission_name:",
            "            self.previous_method_permission_name = dict()",
            "            is_collect_previous = True",
            "        self.method_permission_name = self.method_permission_name or dict()",
            "",
            "        # Collect base_permissions and infer previous permissions",
            "        is_add_base_permissions = False",
            "        if self.base_permissions is None:",
            "            self.base_permissions = set()",
            "            is_add_base_permissions = True",
            "",
            "        if self.limits is None:",
            "            self.limits = []",
            "",
            "        for attr_name in dir(self):",
            "            if hasattr(getattr(self, attr_name), \"_limit\"):",
            "                self.limits.append(getattr(getattr(self, attr_name), \"_limit\"))",
            "            # If include_route_methods is not None white list",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            # Don't create permission for excluded routes",
            "            if attr_name in self.exclude_route_methods:",
            "                continue",
            "            if hasattr(getattr(self, attr_name), \"_permission_name\"):",
            "                if is_collect_previous:",
            "                    self.previous_method_permission_name[attr_name] = getattr(",
            "                        getattr(self, attr_name), \"_permission_name\"",
            "                    )",
            "                _permission_name = self.get_method_permission(attr_name)",
            "                if is_add_base_permissions:",
            "                    self.base_permissions.add(PERMISSION_PREFIX + _permission_name)",
            "        self.base_permissions = list(self.base_permissions)",
            "",
            "    def create_blueprint(",
            "        self,",
            "        appbuilder: \"AppBuilder\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> Blueprint:",
            "        # Store appbuilder instance",
            "        self.appbuilder = appbuilder",
            "        # If endpoint name is not provided, get it from the class name",
            "        self.endpoint = endpoint or self.__class__.__name__",
            "        self.resource_name = self.resource_name or self.__class__.__name__.lower()",
            "",
            "        if self.route_base is None:",
            "            self.route_base = f\"/api/{self.version}/{self.resource_name.lower()}\"",
            "        self.blueprint = Blueprint(self.endpoint, __name__, url_prefix=self.route_base)",
            "        # Exempt API from CSRF protect",
            "        if self.csrf_exempt:",
            "            csrf = self.appbuilder.app.extensions.get(\"csrf\")",
            "            if csrf:",
            "                csrf.exempt(self.blueprint)",
            "",
            "        self._register_urls()",
            "        return self.blueprint",
            "",
            "    def add_api_spec(self, api_spec: APISpec) -> None:",
            "        self.add_apispec_components(api_spec)",
            "        for attr_name in dir(self):",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    # If include_route_methods is not None white list",
            "                    if (",
            "                        self.include_route_methods is not None",
            "                        and attr_name not in self.include_route_methods",
            "                    ):",
            "                        continue",
            "                    if attr_name in self.exclude_route_methods:",
            "                        log.info(f\"Not registering api spec for method {attr_name}\")",
            "                        continue",
            "                    operations = {}",
            "                    path = self.path_helper(path=url, operations=operations)",
            "                    self.operation_helper(",
            "                        path=path, operations=operations, methods=methods, func=attr",
            "                    )",
            "                    api_spec.path(path=path, operations=operations)",
            "                    for operation in operations:",
            "                        openapi_spec_tag = (",
            "                            self.openapi_spec_tag or self.__class__.__name__",
            "                        )",
            "                        api_spec._paths[path][operation][\"tags\"] = [openapi_spec_tag]",
            "",
            "    def add_apispec_components(self, api_spec: APISpec) -> None:",
            "        for k, v in self.responses.items():",
            "            try:",
            "                api_spec.components.response(k, v)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "        for k, v in self._apispec_parameter_schemas.items():",
            "            try:",
            "                api_spec.components.schema(k, v)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "        for schema in self.openapi_spec_component_schemas:",
            "            try:",
            "                if hasattr(schema, \"__component_name__\"):",
            "                    component_name = schema.__component_name__",
            "                elif isinstance(schema, type):",
            "                    component_name = schema.__name__",
            "                else:",
            "                    component_name = schema.__class__.__name__",
            "                api_spec.components.schema(component_name, schema=schema)",
            "            except DuplicateComponentNameError:",
            "                pass",
            "",
            "    def _register_urls(self) -> None:",
            "        before_request_hooks = get_before_request_hooks(self)",
            "        for attr_name in dir(self):",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            if attr_name in self.exclude_route_methods:",
            "                log.info(f\"Not registering route for method {attr_name}\")",
            "                continue",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    log.info(",
            "                        f\"Registering route {self.blueprint.url_prefix}{url} {methods}\"",
            "                    )",
            "                    route_handler = wrap_route_handler_with_hooks(",
            "                        attr_name, attr, before_request_hooks",
            "                    )",
            "                    self.blueprint.add_url_rule(",
            "                        url, attr_name, route_handler, methods=methods",
            "                    )",
            "",
            "    def path_helper(",
            "        self,",
            "        path: str = None,",
            "        operations: Optional[Dict[str, Dict]] = None,",
            "        **kwargs: Any,",
            "    ) -> str:",
            "        \"\"\"",
            "            Works like an apispec plugin",
            "            May return a path as string and mutate operations dict.",
            "",
            "        :param str path: Path to the resource",
            "        :param dict operations: A `dict` mapping HTTP methods to operation object. See",
            "            https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject",
            "        :param kwargs:",
            "        :return: Return value should be a string or None. If a string is returned, it",
            "        is set as the path.",
            "        \"\"\"",
            "        RE_URL = re.compile(r\"<(?:[^:<>]+:)?([^<>]+)>\")",
            "        path = RE_URL.sub(r\"{\\1}\", path)",
            "        return f\"{self.route_base}{path}\"",
            "",
            "    def operation_helper(",
            "        self,",
            "        path: Optional[str] = None,",
            "        operations: Dict[str, Any] = None,",
            "        methods: List[str] = None,",
            "        func: Callable[..., Response] = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"May mutate operations.",
            "        :param str path: Path to the resource",
            "        :param dict operations: A `dict` mapping HTTP methods to operation object.",
            "        :param list methods: A list of HTTP methods registered for this path",
            "        \"\"\"",
            "        for method in methods:",
            "            try:",
            "                # Check if method openapi spec is overridden",
            "                override_method_spec = self.openapi_spec_methods[func.__name__]",
            "            except KeyError:",
            "                override_method_spec = {}",
            "            yaml_doc_string = yaml_utils.load_operations_from_docstring(func.__doc__)",
            "            yaml_doc_string = yaml.safe_load(",
            "                str(yaml_doc_string).replace(",
            "                    \"{{self.__class__.__name__}}\", self.__class__.__name__",
            "                )",
            "            )",
            "            if yaml_doc_string:",
            "                operation_spec = yaml_doc_string.get(method.lower(), {})",
            "                # Merge docs spec and override spec",
            "                operation_spec.update(override_method_spec.get(method.lower(), {}))",
            "                if self.get_method_permission(func.__name__):",
            "                    operation_spec[\"security\"] = [{\"jwt\": []}]",
            "                operations[method.lower()] = operation_spec",
            "            else:",
            "                operations[method.lower()] = {}",
            "",
            "    @staticmethod",
            "    def _prettify_name(name: str) -> str:",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'HelloWorld' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(r\"(?<=.)([A-Z])\", r\" \\1\", name)",
            "",
            "    @staticmethod",
            "    def _prettify_column(name: str) -> str:",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'hello_world' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(\"[._]\", \" \", name).title()",
            "",
            "    def get_uninit_inner_views(self) -> List[Type[AbstractViewApi]]:",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_init_inner_views(self) -> List[AbstractViewApi]:",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "        pass  # pragma: no cover",
            "",
            "    def get_method_permission(self, method_name: str) -> str:",
            "        \"\"\"",
            "        Returns the permission name for a method",
            "        \"\"\"",
            "        if self.method_permission_name:",
            "            return self.method_permission_name.get(method_name, method_name)",
            "        else:",
            "            if hasattr(getattr(self, method_name), \"_permission_name\"):",
            "                return getattr(getattr(self, method_name), \"_permission_name\")",
            "",
            "    def set_response_key_mappings(",
            "        self,",
            "        response: Dict[str, Any],",
            "        func: Callable[..., Response],",
            "        rison_args: Dict[str, Any],",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        if not hasattr(func, \"_response_key_func_mappings\"):",
            "            return  # pragma: no cover",
            "        _keys = rison_args.get(\"keys\", None)",
            "        if not _keys:",
            "            for k, v in func._response_key_func_mappings.items():",
            "                v(self, response, **kwargs)",
            "        else:",
            "            for k, v in func._response_key_func_mappings.items():",
            "                if k in _keys:",
            "                    v(self, response, **kwargs)",
            "",
            "    def merge_current_user_permissions(",
            "        self, response: Dict[str, Any], **kwargs: Any",
            "    ) -> None:",
            "        response[API_PERMISSIONS_RES_KEY] = [",
            "            permission",
            "            for permission in self.base_permissions",
            "            if self.appbuilder.sm.has_access(permission, self.class_permission_name)",
            "        ]",
            "",
            "    @staticmethod",
            "    def response(code: int, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        Generic HTTP JSON response method",
            "",
            "        :param code: HTTP code (int)",
            "        :param kwargs: Data structure for response (dict)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        _ret_json = jsonify(kwargs)",
            "        resp = make_response(_ret_json, code)",
            "        resp.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "        return resp",
            "",
            "    def response_400(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 400 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Arguments are not correct\"",
            "        return self.response(400, **{\"message\": message})",
            "",
            "    def response_422(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 422 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Could not process entity\"",
            "        return self.response(422, **{\"message\": message})",
            "",
            "    def response_401(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 401 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(401, **{\"message\": \"Not authorized\"})",
            "",
            "    def response_403(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 403 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(403, **{\"message\": \"Forbidden\"})",
            "",
            "    def response_404(self) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 404 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        return self.response(404, **{\"message\": \"Not found\"})",
            "",
            "    def response_500(self, message: str = None) -> Response:",
            "        \"\"\"",
            "        Helper method for HTTP 500 response",
            "",
            "        :param message: Error message (str)",
            "        :return: HTTP Json response",
            "        \"\"\"",
            "        message = message or \"Internal error\"",
            "        return self.response(500, **{\"message\": message})",
            "",
            "",
            "class BaseModelApi(BaseApi):",
            "    datamodel: Optional[SQLAInterface] = None",
            "    \"\"\"",
            "    Your sqla model you must initialize it like::",
            "",
            "        class MyModelApi(BaseModelApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "    \"\"\"",
            "    search_columns = None",
            "    \"\"\"",
            "    List with allowed search columns, if not provided all possible search",
            "    columns will be used. If you want to limit the search (*filter*) columns",
            "     possibilities, define it with a list of column names from your model::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            search_columns = ['name', 'address']",
            "",
            "    \"\"\"",
            "    search_filters = None",
            "    \"\"\"",
            "    Override default search filters for columns",
            "    \"\"\"",
            "    search_exclude_columns = None",
            "    \"\"\"",
            "    List with columns to exclude from search. Search includes all possible",
            "    columns by default",
            "    \"\"\"",
            "    label_columns = None",
            "    \"\"\"",
            "    Dictionary of labels for your columns, override this if you want",
            "     different pretify labels",
            "",
            "    example (will just override the label for name column)::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            label_columns = {'name':'My Name Label Override'}",
            "",
            "    \"\"\"",
            "    base_filters = None",
            "    \"\"\"",
            "    Filter the view use: [['column_name',BaseFilter,'value'],]",
            "",
            "    example::",
            "",
            "        def get_user():",
            "            return g.user",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            base_filters = [['created_by', FilterEqualFunction, get_user],",
            "                            ['name', FilterStartsWith, 'a']]",
            "",
            "    \"\"\"",
            "",
            "    base_order = None",
            "    \"\"\"",
            "    Use this property to set default ordering for lists",
            "     ('col_name','asc|desc')::",
            "",
            "        class MyView(ModelRestApi):",
            "            datamodel = SQLAInterface(MyTable)",
            "            base_order = ('my_column_name','asc')",
            "",
            "    \"\"\"",
            "    _base_filters = None",
            "    \"\"\" Internal base Filter from class Filters will always filter view \"\"\"",
            "    _filters = None",
            "    \"\"\"",
            "    Filters object will calculate all possible filter types",
            "    based on search_columns",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs: Any) -> None:",
            "        datamodel = kwargs.get(\"datamodel\", None)",
            "        if datamodel:",
            "            self.datamodel = datamodel",
            "        self._init_properties()",
            "        self._init_titles()",
            "        super(BaseModelApi, self).__init__()",
            "",
            "    def _gen_labels_columns(self, list_columns: List[str]) -> None:",
            "        \"\"\"",
            "        Auto generates pretty label_columns from list of columns",
            "        \"\"\"",
            "        for col in list_columns:",
            "            if not self.label_columns.get(col):",
            "                self.label_columns[col] = self._prettify_column(col)",
            "",
            "    def _label_columns_json(self, cols: Optional[List[str]] = None) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Prepares dict with labels to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        cols = cols or []",
            "        d = {k: v for (k, v) in self.label_columns.items() if k in cols}",
            "        for key, value in d.items():",
            "            ret[key] = as_unicode(_(value).encode(\"UTF-8\"))",
            "        return ret",
            "",
            "    def _init_properties(self) -> None:",
            "        self.label_columns = self.label_columns or {}",
            "        self.base_filters = self.base_filters or []",
            "        self.search_exclude_columns = self.search_exclude_columns or []",
            "        self.search_columns = self.search_columns or []",
            "",
            "        self._base_filters = self.datamodel.get_filters().add_filter_list(",
            "            self.base_filters",
            "        )",
            "        search_columns = self.datamodel.get_search_columns_list()",
            "        if not self.search_columns:",
            "            self.search_columns = [",
            "                x for x in search_columns if x not in self.search_exclude_columns",
            "            ]",
            "        self._gen_labels_columns(self.datamodel.get_columns_list())",
            "",
            "    def _init_titles(self) -> None:",
            "        pass",
            "",
            "",
            "class ModelRestApi(BaseModelApi):",
            "    list_title = \"\"",
            "    \"\"\"",
            "    List Title, if not configured the default is",
            "    'List ' with pretty model name",
            "    \"\"\"",
            "    show_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Show Title , if not configured the default is",
            "    'Show ' with pretty model name",
            "    \"\"\"",
            "    add_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Add Title , if not configured the default is",
            "    'Add ' with pretty model name",
            "    \"\"\"",
            "    edit_title: Optional[str] = \"\"",
            "    \"\"\"",
            "    Edit Title , if not configured the default is",
            "    'Edit ' with pretty model name",
            "    \"\"\"",
            "    list_select_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A List of column names that will be included on the SQL select.",
            "    This is useful for including all necessary columns that are referenced",
            "    by properties listed on `list_columns` without generating N+1 queries.",
            "    \"\"\"",
            "    list_outer_default_load = False",
            "    \"\"\"",
            "    If True, the default load for outer joins will be applied on the get item endpoint.",
            "    This is useful for when you want to control the load of the many-to-many and",
            "    many-to-one relationships at the model level. Will apply:",
            "     https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload",
            "    \"\"\"",
            "    list_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be displayed on the list view.",
            "    Use it to control the order of the display",
            "    \"\"\"",
            "    show_select_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A List of column names that will be included on the SQL select.",
            "    This is useful for including all necessary columns that are referenced",
            "    by properties listed on `show_columns` without generating N+1 queries.",
            "    \"\"\"",
            "    show_outer_default_load = False",
            "    \"\"\"",
            "    If True, the default load for outer joins will be applied on the get item endpoint.",
            "    This is useful for when you want to control the load of the many-to-many and",
            "    many-to-one relationships at the model level. Will apply:",
            "     https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload",
            "    \"\"\"",
            "    show_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) for the get item endpoint.",
            "    Use it to control the order of the results",
            "    \"\"\"",
            "    add_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be allowed to post",
            "    \"\"\"",
            "    edit_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns (or model's methods) to be allowed to update",
            "    \"\"\"",
            "    list_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the get list endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    show_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the get item endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    add_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the add endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    edit_exclude_columns: Optional[List[str]] = None",
            "    \"\"\"",
            "    A list of columns to exclude from the edit endpoint.",
            "    By default all columns are included.",
            "    \"\"\"",
            "    order_columns: Optional[List[str]] = None",
            "    \"\"\" Allowed order columns \"\"\"",
            "    page_size = 20",
            "    \"\"\"",
            "    Use this property to change default page size",
            "    \"\"\"",
            "    max_page_size: Optional[int] = None",
            "    \"\"\"",
            "    class override for the FAB_API_MAX_SIZE, use special -1 to allow for any page",
            "    size",
            "    \"\"\"",
            "    description_columns: Optional[Dict[str, str]] = None",
            "    \"\"\"",
            "    Dictionary with column descriptions that will be shown on the forms::",
            "",
            "        class MyView(ModelView):",
            "            datamodel = SQLAModel(MyTable, db.session)",
            "",
            "            description_columns = {'name':'your models name column',",
            "                                    'address':'the address column'}",
            "    \"\"\"",
            "    validators_columns: Optional[Dict[str, Callable]] = None",
            "    \"\"\" Dictionary to add your own marshmallow validators \"\"\"",
            "",
            "    add_query_rel_fields = None",
            "    \"\"\"",
            "    Add Customized query for related add fields.",
            "    Assign a dictionary where the keys are the column names of",
            "    the related models to filter, the value for each key, is a list of lists with the",
            "    same format as base_filter",
            "    {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "    Add a custom filter to form related fields::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact)",
            "            add_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "    edit_query_rel_fields = None",
            "    \"\"\"",
            "    Add Customized query for related edit fields.",
            "    Assign a dictionary where the keys are the column names of",
            "    the related models to filter, the value for each key, is a list of lists with the",
            "    same format as base_filter",
            "    {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "    Add a custom filter to form related fields::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact, db.session)",
            "            edit_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "    order_rel_fields = None",
            "    \"\"\"",
            "    Impose order on related fields.",
            "    assign a dictionary where the keys are the related column names::",
            "",
            "        class ContactModelView(ModelRestApi):",
            "            datamodel = SQLAModel(Contact)",
            "            order_rel_fields = {",
            "                'group': ('name', 'asc')",
            "                'gender': ('name', 'asc')",
            "            }",
            "    \"\"\"",
            "    list_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    add_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    edit_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    show_model_schema: Optional[Schema] = None",
            "    \"\"\"",
            "    Override to provide your own marshmallow Schema",
            "    for JSON to SQLA dumps",
            "    \"\"\"",
            "    model2schemaconverter = Model2SchemaConverter",
            "    \"\"\"",
            "    Override to use your own Model2SchemaConverter",
            "    (inherit from BaseModel2SchemaConverter)",
            "    \"\"\"",
            "    _apispec_parameter_schemas = {",
            "        \"get_info_schema\": get_info_schema,",
            "        \"get_item_schema\": get_item_schema,",
            "        \"get_list_schema\": get_list_schema,",
            "    }",
            "",
            "    def __init__(self) -> None:",
            "        super(ModelRestApi, self).__init__()",
            "        self.validators_columns = self.validators_columns or {}",
            "        self.model2schemaconverter = self.model2schemaconverter(",
            "            self.datamodel, self.validators_columns",
            "        )",
            "",
            "    def create_blueprint(",
            "        self, appbuilder: \"AppBuilder\", *args: Any, **kwargs: Any",
            "    ) -> Blueprint:",
            "        self._init_model_schemas()",
            "        return super(ModelRestApi, self).create_blueprint(appbuilder, *args, **kwargs)",
            "",
            "    @property",
            "    def list_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.get_list\"",
            "",
            "    @property",
            "    def show_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.get\"",
            "",
            "    @property",
            "    def add_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.post\"",
            "",
            "    @property",
            "    def edit_model_schema_name(self) -> str:",
            "        return f\"{self.__class__.__name__}.put\"",
            "",
            "    def add_apispec_components(self, api_spec: APISpec) -> None:",
            "        super(ModelRestApi, self).add_apispec_components(api_spec)",
            "        api_spec.components.schema(",
            "            self.list_model_schema_name, schema=self.list_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.add_model_schema_name, schema=self.add_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.edit_model_schema_name, schema=self.edit_model_schema",
            "        )",
            "        api_spec.components.schema(",
            "            self.show_model_schema_name, schema=self.show_model_schema",
            "        )",
            "",
            "    def _init_model_schemas(self) -> None:",
            "        # Create Marshmalow schemas if one is not specified",
            "        if self.list_model_schema is None:",
            "            self.list_model_schema = self.model2schemaconverter.convert(",
            "                self.list_columns, parent_schema_name=self.list_model_schema_name",
            "            )",
            "        if self.add_model_schema is None:",
            "            self.add_model_schema = self.model2schemaconverter.convert(",
            "                self.add_columns,",
            "                nested=False,",
            "                enum_dump_by_name=True,",
            "                parent_schema_name=self.add_model_schema_name,",
            "            )",
            "        if self.edit_model_schema is None:",
            "            self.edit_model_schema = self.model2schemaconverter.convert(",
            "                self.edit_columns,",
            "                nested=False,",
            "                enum_dump_by_name=True,",
            "                parent_schema_name=self.edit_model_schema_name,",
            "            )",
            "        if self.show_model_schema is None:",
            "            self.show_model_schema = self.model2schemaconverter.convert(",
            "                self.show_columns, parent_schema_name=self.show_model_schema_name",
            "            )",
            "",
            "    def _init_titles(self) -> None:",
            "        \"\"\"",
            "        Init Titles if not defined",
            "        \"\"\"",
            "        super(ModelRestApi, self)._init_titles()",
            "        class_name = self.datamodel.model_name",
            "        if not self.list_title:",
            "            self.list_title = \"List \" + self._prettify_name(class_name)",
            "        if not self.add_title:",
            "            self.add_title = \"Add \" + self._prettify_name(class_name)",
            "        if not self.edit_title:",
            "            self.edit_title = \"Edit \" + self._prettify_name(class_name)",
            "        if not self.show_title:",
            "            self.show_title = \"Show \" + self._prettify_name(class_name)",
            "        self.title = self.list_title",
            "",
            "    def _init_properties(self) -> None:",
            "        \"\"\"",
            "        Initializes all properties",
            "        \"\"\"",
            "        super(ModelRestApi, self)._init_properties()",
            "        # Reset init props",
            "        self.description_columns = self.description_columns or {}",
            "        self.list_exclude_columns = self.list_exclude_columns or []",
            "        self.show_exclude_columns = self.show_exclude_columns or []",
            "        self.add_exclude_columns = self.add_exclude_columns or []",
            "        self.edit_exclude_columns = self.edit_exclude_columns or []",
            "        self.order_rel_fields = self.order_rel_fields or {}",
            "        # Generate base props",
            "        list_cols = self.datamodel.get_user_columns_list()",
            "        if not self.list_columns and self.list_model_schema:",
            "            list(self.list_model_schema._declared_fields.keys())",
            "        else:",
            "            self.list_columns = self.list_columns or [",
            "                x",
            "                for x in self.datamodel.get_user_columns_list()",
            "                if x not in self.list_exclude_columns",
            "            ]",
            "        self.list_select_columns = self.list_select_columns or self.list_columns",
            "",
            "        self.order_columns = (",
            "            self.order_columns",
            "            or self.datamodel.get_order_columns_list(list_columns=self.list_columns)",
            "        )",
            "        # Process excluded columns",
            "        if not self.show_columns:",
            "            self.show_columns = [",
            "                x for x in list_cols if x not in self.show_exclude_columns",
            "            ]",
            "        self.show_select_columns = self.show_select_columns or self.show_columns",
            "",
            "        if not self.add_columns:",
            "            self.add_columns = [",
            "                x for x in list_cols if x not in self.add_exclude_columns",
            "            ]",
            "        if not self.edit_columns:",
            "            self.edit_columns = [",
            "                x for x in list_cols if x not in self.edit_exclude_columns",
            "            ]",
            "        self._gen_labels_columns(self.list_columns)",
            "        self._gen_labels_columns(self.show_columns)",
            "        self._filters = self.datamodel.get_filters(",
            "            search_columns=self.search_columns, search_filters=self.search_filters",
            "        )",
            "        self.edit_query_rel_fields = self.edit_query_rel_fields or dict()",
            "        self.add_query_rel_fields = self.add_query_rel_fields or dict()",
            "",
            "    def merge_add_field_info(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        add_columns_info = kwargs.get(\"add_columns\", {})",
            "        response[API_ADD_COLUMNS_RES_KEY] = self._get_fields_info(",
            "            self.add_columns,",
            "            self.add_model_schema,",
            "            self.add_query_rel_fields,",
            "            **add_columns_info,",
            "        )",
            "",
            "    def merge_edit_field_info(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        edit_columns_info = kwargs.get(\"edit_columns\", {})",
            "        response[API_EDIT_COLUMNS_RES_KEY] = self._get_fields_info(",
            "            self.edit_columns,",
            "            self.edit_model_schema,",
            "            self.edit_query_rel_fields,",
            "            **edit_columns_info,",
            "        )",
            "",
            "    def merge_search_filters(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        # Get possible search fields and all possible operations",
            "        search_filters = {}",
            "        dict_filters = self._filters.get_search_filters()",
            "        for col in self.search_columns:",
            "            if col not in dict_filters:",
            "                # column not in search filters but defined has one",
            "                continue",
            "            search_filters[col] = [",
            "                {\"name\": as_unicode(flt.name), \"operator\": flt.arg_name}",
            "                for flt in dict_filters[col]",
            "            ]",
            "        response[API_FILTERS_RES_KEY] = search_filters",
            "",
            "    def merge_add_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_ADD_TITLE_RES_KEY] = self.add_title",
            "",
            "    def merge_edit_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_EDIT_TITLE_RES_KEY] = self.edit_title",
            "",
            "    def merge_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            columns = pruned_select_cols",
            "        else:",
            "            # Send the exact labels for the caller operation",
            "            if kwargs.get(\"caller\") == \"list\":",
            "                columns = self.list_columns",
            "            elif kwargs.get(\"caller\") == \"show\":",
            "                columns = self.show_columns",
            "            else:",
            "                columns = self.label_columns  # pragma: no cover",
            "        response[API_LABEL_COLUMNS_RES_KEY] = self._label_columns_json(columns)",
            "",
            "    def merge_list_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        self.merge_label_columns(response, caller=\"list\", **kwargs)",
            "",
            "    def merge_show_label_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        self.merge_label_columns(response, caller=\"show\", **kwargs)",
            "",
            "    def merge_show_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_SHOW_COLUMNS_RES_KEY] = pruned_select_cols",
            "        else:",
            "            response[API_SHOW_COLUMNS_RES_KEY] = self.show_columns",
            "",
            "    def merge_description_columns(",
            "        self, response: Dict[str, Any], **kwargs: Any",
            "    ) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_DESCRIPTION_COLUMNS_RES_KEY] = self._description_columns_json(",
            "                pruned_select_cols",
            "            )",
            "        else:",
            "            # Send all descriptions if cols are or request pruned",
            "            response[API_DESCRIPTION_COLUMNS_RES_KEY] = self._description_columns_json(",
            "                self.description_columns",
            "            )",
            "",
            "    def merge_list_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_LIST_COLUMNS_RES_KEY] = pruned_select_cols",
            "        else:",
            "            response[API_LIST_COLUMNS_RES_KEY] = self.list_columns",
            "",
            "    def merge_order_columns(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        pruned_select_cols = kwargs.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        if pruned_select_cols:",
            "            response[API_ORDER_COLUMNS_RES_KEY] = [",
            "                order_col",
            "                for order_col in self.order_columns",
            "                if order_col in pruned_select_cols",
            "            ]",
            "        else:",
            "            response[API_ORDER_COLUMNS_RES_KEY] = self.order_columns",
            "",
            "    def merge_list_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_LIST_TITLE_RES_KEY] = self.list_title",
            "",
            "    def merge_show_title(self, response: Dict[str, Any], **kwargs: Any) -> None:",
            "        response[API_SHOW_TITLE_RES_KEY] = self.show_title",
            "",
            "    def info_headless(self, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        response for CRUD REST meta data",
            "        \"\"\"",
            "        payload = {}",
            "        rison_args = kwargs.get(\"rison\", {})",
            "        self.set_response_key_mappings(payload, self.info, rison_args, **rison_args)",
            "        return self.response(200, **payload)",
            "",
            "    @expose(\"/_info\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @rison(get_info_schema)",
            "    @permission_name(\"info\")",
            "    @merge_response_func(",
            "        BaseApi.merge_current_user_permissions, API_PERMISSIONS_RIS_KEY",
            "    )",
            "    @merge_response_func(merge_add_field_info, API_ADD_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_edit_field_info, API_EDIT_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_search_filters, API_FILTERS_RIS_KEY)",
            "    @merge_response_func(merge_add_title, API_ADD_TITLE_RIS_KEY)",
            "    @merge_response_func(merge_edit_title, API_EDIT_TITLE_RIS_KEY)",
            "    def info(self, **kwargs: Any) -> Response:",
            "        \"\"\"Endpoint that renders a response for CRUD REST meta data",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get metadata information about this API resource",
            "          parameters:",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_info_schema'",
            "          responses:",
            "            200:",
            "              description: Item from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      add_columns:",
            "                        type: object",
            "                      edit_columns:",
            "                        type: object",
            "                      filters:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            type: array",
            "                            items:",
            "                              type: object",
            "                              properties:",
            "                                name:",
            "                                  description: >-",
            "                                    The filter name. Will be translated by babel",
            "                                  type: string",
            "                                operator:",
            "                                  description: >-",
            "                                    The filter operation key to use on list filters",
            "                                  type: string",
            "                      permissions:",
            "                        description: The user permissions for this API resource",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.info_headless(**kwargs)",
            "",
            "    def get_headless(self, pk: ModelKeyType, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "            Get an item from Model",
            "",
            "        :param pk: Item primary key",
            "        :param kwargs: Query string parameter arguments",
            "        :return: HTTP Response",
            "        \"\"\"",
            "        item = self.datamodel.get(",
            "            pk,",
            "            self._base_filters,",
            "            self.show_select_columns,",
            "            self.show_outer_default_load,",
            "        )",
            "        if not item:",
            "            return self.response_404()",
            "",
            "        response = {}",
            "        args = kwargs.get(\"rison\", {})",
            "        select_cols = args.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        pruned_select_cols = [col for col in select_cols if col in self.show_columns]",
            "        self.set_response_key_mappings(",
            "            response, self.get, args, **{API_SELECT_COLUMNS_RIS_KEY: pruned_select_cols}",
            "        )",
            "        if pruned_select_cols:",
            "            show_model_schema = self.model2schemaconverter.convert(pruned_select_cols)",
            "        else:",
            "            show_model_schema = self.show_model_schema",
            "",
            "        response[\"id\"] = pk",
            "        response[API_RESULT_RES_KEY] = show_model_schema.dump(item, many=False)",
            "        self.pre_get(response)",
            "        return self.response(200, **response)",
            "",
            "    @expose(\"/<int:pk>\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"get\")",
            "    @rison(get_item_schema)",
            "    @merge_response_func(merge_show_label_columns, API_LABEL_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_show_columns, API_SHOW_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_description_columns, API_DESCRIPTION_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_show_title, API_SHOW_TITLE_RIS_KEY)",
            "    def get(self, pk: ModelKeyType, **kwargs: Any) -> Response:",
            "        \"\"\"Get item from Model",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get an item model",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_item_schema'",
            "          responses:",
            "            200:",
            "              description: Item from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      label_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The label for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice label for the column",
            "                            type: string",
            "                      show_columns:",
            "                        description: >-",
            "                          A list of columns",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      description_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The description for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice description for the column",
            "                            type: string",
            "                      show_title:",
            "                        description: >-",
            "                          A title to render.",
            "                          Will be translated by babel",
            "                        example: Show Item Details",
            "                        type: string",
            "                      id:",
            "                        description: The item id",
            "                        type: string",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.get'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.get_headless(pk, **kwargs)",
            "",
            "    def get_list_headless(self, **kwargs: Any) -> Response:",
            "        \"\"\"",
            "        Get list of items from Model",
            "        \"\"\"",
            "        response = dict()",
            "        args = kwargs.get(\"rison\", {})",
            "        # handle select columns",
            "        select_cols = args.get(API_SELECT_COLUMNS_RIS_KEY, [])",
            "        pruned_select_cols = [col for col in select_cols if col in self.list_columns]",
            "        # map decorated metadata",
            "        self.set_response_key_mappings(",
            "            response,",
            "            self.get_list,",
            "            args,",
            "            **{API_SELECT_COLUMNS_RIS_KEY: pruned_select_cols},",
            "        )",
            "        # Create a response schema with the computed response columns,",
            "        # defined or requested",
            "        if pruned_select_cols:",
            "            list_model_schema = self.model2schemaconverter.convert(pruned_select_cols)",
            "        else:",
            "            list_model_schema = self.list_model_schema",
            "        # handle filters",
            "        try:",
            "            joined_filters = self._handle_filters_args(args)",
            "        except FABException as e:",
            "            return self.response_400(message=str(e))",
            "        # handle base order",
            "        try:",
            "            order_column, order_direction = self._handle_order_args(args)",
            "        except InvalidOrderByColumnFABException as e:",
            "            return self.response_400(message=str(e))",
            "        # handle pagination",
            "        page_index, page_size = self._handle_page_args(args)",
            "        # Make the query",
            "        count, lst = self.datamodel.query(",
            "            joined_filters,",
            "            order_column,",
            "            order_direction,",
            "            page=page_index,",
            "            page_size=page_size,",
            "            select_columns=self.list_select_columns,",
            "            outer_default_load=self.list_outer_default_load,",
            "        )",
            "        pks = self.datamodel.get_keys(lst)",
            "        response[API_RESULT_RES_KEY] = list_model_schema.dump(lst, many=True)",
            "        response[\"ids\"] = pks",
            "        response[\"count\"] = count",
            "        self.pre_get_list(response)",
            "        return self.response(200, **response)",
            "",
            "    @expose(\"/\", methods=[\"GET\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"get\")",
            "    @rison(get_list_schema)",
            "    @merge_response_func(merge_order_columns, API_ORDER_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_label_columns, API_LABEL_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_description_columns, API_DESCRIPTION_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_columns, API_LIST_COLUMNS_RIS_KEY)",
            "    @merge_response_func(merge_list_title, API_LIST_TITLE_RIS_KEY)",
            "    def get_list(self, **kwargs: Any) -> Response:",
            "        \"\"\"Get list of items from Model",
            "        ---",
            "        get:",
            "          description: >-",
            "            Get a list of models",
            "          parameters:",
            "          - in: query",
            "            name: q",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/get_list_schema'",
            "          responses:",
            "            200:",
            "              description: Items from Model",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      label_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The label for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice label for the column",
            "                            type: string",
            "                      list_columns:",
            "                        description: >-",
            "                          A list of columns",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      description_columns:",
            "                        type: object",
            "                        properties:",
            "                          column_name:",
            "                            description: >-",
            "                              The description for the column name.",
            "                              Will be translated by babel",
            "                            example: A Nice description for the column",
            "                            type: string",
            "                      list_title:",
            "                        description: >-",
            "                          A title to render.",
            "                          Will be translated by babel",
            "                        example: List Items",
            "                        type: string",
            "                      ids:",
            "                        description: >-",
            "                          A list of item ids, useful when you don't know the column id",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      count:",
            "                        description: >-",
            "                          The total record count on the backend",
            "                        type: number",
            "                      order_columns:",
            "                        description: >-",
            "                          A list of allowed columns to sort",
            "                        type: array",
            "                        items:",
            "                          type: string",
            "                      result:",
            "                        description: >-",
            "                          The result from the get list query",
            "                        type: array",
            "                        items:",
            "                          $ref: '#/components/schemas/{{self.__class__.__name__}}.get_list'  # noqa",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.get_list_headless(**kwargs)",
            "",
            "    def post_headless(self) -> Response:",
            "        \"\"\"",
            "        POST/Add item to Model",
            "        \"\"\"",
            "        if not request.is_json:",
            "            return self.response_400(message=\"Request is not JSON\")",
            "        try:",
            "            item = self.add_model_schema.load(request.json)",
            "        except ValidationError as err:",
            "            return self.response_422(message=err.messages)",
            "        # This validates custom Schema with custom validations",
            "        self.pre_add(item)",
            "        try:",
            "            self.datamodel.add(item, raise_exception=True)",
            "            self.post_add(item)",
            "            return self.response(",
            "                201,",
            "                **{",
            "                    API_RESULT_RES_KEY: self.add_model_schema.dump(item, many=False),",
            "                    \"id\": self.datamodel.get_pk_value(item),",
            "                },",
            "            )",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/\", methods=[\"POST\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"post\")",
            "    def post(self) -> Response:",
            "        \"\"\"POST item to Model",
            "        ---",
            "        post:",
            "          requestBody:",
            "            description: Model schema",
            "            required: true",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/{{self.__class__.__name__}}.post'",
            "          responses:",
            "            201:",
            "              description: Item inserted",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      id:",
            "                        type: string",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.post'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.post_headless()",
            "",
            "    def put_headless(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"",
            "        PUT/Edit item to Model",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not request.is_json:",
            "            return self.response(400, **{\"message\": \"Request is not JSON\"})",
            "        if not item:",
            "            return self.response_404()",
            "        try:",
            "            data = self._merge_update_item(item, request.json)",
            "            item = self.edit_model_schema.load(data, instance=item)",
            "        except ValidationError as err:",
            "            return self.response_422(message=err.messages)",
            "        self.pre_update(item)",
            "        try:",
            "            self.datamodel.edit(item, raise_exception=True)",
            "            self.post_update(item)",
            "            return self.response(",
            "                200,",
            "                **{API_RESULT_RES_KEY: self.edit_model_schema.dump(item, many=False)},",
            "            )",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/<pk>\", methods=[\"PUT\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"put\")",
            "    def put(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"PUT item to Model",
            "        ---",
            "        put:",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          requestBody:",
            "            description: Model schema",
            "            required: true",
            "            content:",
            "              application/json:",
            "                schema:",
            "                  $ref: '#/components/schemas/{{self.__class__.__name__}}.put'",
            "          responses:",
            "            200:",
            "              description: Item changed",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      result:",
            "                        $ref: '#/components/schemas/{{self.__class__.__name__}}.put'",
            "            400:",
            "              $ref: '#/components/responses/400'",
            "            401:",
            "              $ref: '#/components/responses/401'",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.put_headless(pk)",
            "",
            "    def delete_headless(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"",
            "        Delete item from Model",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            return self.response_404()",
            "        self.pre_delete(item)",
            "        try:",
            "            self.datamodel.delete(item, raise_exception=True)",
            "            self.post_delete(item)",
            "            return self.response(200, message=\"OK\")",
            "        except IntegrityError as e:",
            "            return self.response_422(message=str(e.orig))",
            "",
            "    @expose(\"/<pk>\", methods=[\"DELETE\"])",
            "    @protect()",
            "    @safe",
            "    @permission_name(\"delete\")",
            "    def delete(self, pk: ModelKeyType) -> Response:",
            "        \"\"\"Delete item from Model",
            "        ---",
            "        delete:",
            "          parameters:",
            "          - in: path",
            "            schema:",
            "              type: integer",
            "            name: pk",
            "          responses:",
            "            200:",
            "              description: Item deleted",
            "              content:",
            "                application/json:",
            "                  schema:",
            "                    type: object",
            "                    properties:",
            "                      message:",
            "                        type: string",
            "            404:",
            "              $ref: '#/components/responses/404'",
            "            422:",
            "              $ref: '#/components/responses/422'",
            "            500:",
            "              $ref: '#/components/responses/500'",
            "        \"\"\"",
            "        return self.delete_headless(pk)",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                HELPER FUNCTIONS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _handle_page_args(",
            "        self, rison_args: Dict[str, Any]",
            "    ) -> Tuple[Optional[int], Optional[int]]:",
            "        \"\"\"",
            "        Helper function to handle rison page",
            "        arguments, sets defaults and impose",
            "        FAB_API_MAX_PAGE_SIZE",
            "",
            "        :param rison_args:",
            "        :return: (tuple) page, page_size",
            "        \"\"\"",
            "        page = rison_args.get(API_PAGE_INDEX_RIS_KEY, 0)",
            "        page_size = rison_args.get(API_PAGE_SIZE_RIS_KEY, self.page_size)",
            "        return self._sanitize_page_args(page, page_size)",
            "",
            "    def _sanitize_page_args(",
            "        self, page: Optional[int], page_size: Optional[int]",
            "    ) -> Tuple[Optional[int], Optional[int]]:",
            "        page_ = page or 0",
            "        page_size_ = page_size or self.page_size",
            "        max_page_size = self.max_page_size or current_app.config.get(",
            "            \"FAB_API_MAX_PAGE_SIZE\"",
            "        )",
            "        # Accept special -1 to uncap the page size",
            "        if max_page_size == -1:",
            "            if page_size_ == -1:",
            "                return None, None",
            "            else:",
            "                return page_, page_size_",
            "        if page_size_ > max_page_size or page_size_ < 1:",
            "            page_size_ = max_page_size",
            "        return page_, page_size_",
            "",
            "    def _handle_order_args(self, rison_args: Dict[str, Any]) -> Tuple[str, str]:",
            "        \"\"\"",
            "        Help function to handle rison order",
            "        arguments",
            "",
            "        :param rison_args:",
            "        :return:",
            "        \"\"\"",
            "        order_column = rison_args.get(API_ORDER_COLUMN_RIS_KEY, \"\")",
            "        order_direction = rison_args.get(API_ORDER_DIRECTION_RIS_KEY, \"\")",
            "        if not order_column and self.base_order:",
            "            return self.base_order",
            "        if not order_column:",
            "            return \"\", \"\"",
            "        elif self.order_columns and order_column not in self.order_columns:",
            "            raise InvalidOrderByColumnFABException(",
            "                f\"Invalid order by column: {order_column}\"",
            "            )",
            "        return order_column, order_direction",
            "",
            "    def _handle_filters_args(self, rison_args: Dict[str, Any]) -> Filters:",
            "        self._filters.clear_filters()",
            "        self._filters.rest_add_filters(rison_args.get(API_FILTERS_RIS_KEY, []))",
            "        return self._filters.get_joined_filters(self._base_filters)",
            "",
            "    def _description_columns_json(",
            "        self, cols: Optional[List[str]] = None",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Prepares dict with col descriptions to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        cols = cols or []",
            "        d = {k: v for (k, v) in self.description_columns.items() if k in cols}",
            "        for key, value in d.items():",
            "            ret[key] = as_unicode(_(value).encode(\"UTF-8\"))",
            "        return ret",
            "",
            "    def _get_field_info(",
            "        self,",
            "        field: Field,",
            "        filter_rel_field: Dict[str, Any],",
            "        page: Optional[int] = None,",
            "        page_size: Optional[int] = None,",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Return a dict with field details",
            "        ready to serve as a response",
            "",
            "        :param field: marshmallow field",
            "        :return: dict with field details",
            "        \"\"\"",
            "        ret = {",
            "            \"name\": field.name,",
            "            \"label\": _(self.label_columns.get(field.name, \"\")),",
            "            \"description\": _(self.description_columns.get(field.name, \"\")),",
            "            \"type\": field.__class__.__name__,",
            "            \"required\": field.required,",
            "            # When using custom marshmallow schemas fields don't have unique property",
            "            \"unique\": getattr(field, \"unique\", False),",
            "        }",
            "        # Handles related fields",
            "        if isinstance(field, Related) or isinstance(field, RelatedList):",
            "            ret[\"count\"], ret[\"values\"] = self._get_list_related_field(",
            "                field, filter_rel_field, page=page, page_size=page_size",
            "            )",
            "        if field.validate and isinstance(field.validate, list):",
            "            ret[\"validate\"] = [str(v) for v in field.validate]",
            "        elif field.validate:",
            "            ret[\"validate\"] = [str(field.validate)]",
            "        return ret",
            "",
            "    def _get_fields_info(",
            "        self,",
            "        cols: List[str],",
            "        model_schema: Schema,",
            "        filter_rel_fields: QueryRelatedFieldsFilters,",
            "        **kwargs: Any,",
            "    ) -> List[Dict[str, Any]]:",
            "        \"\"\"",
            "        Returns a dict with fields detail",
            "        from a marshmallow schema",
            "",
            "        :param cols: list of columns to show info for",
            "        :param model_schema: Marshmallow model schema",
            "        :param filter_rel_fields: expects add_query_rel_fields or",
            "                                    edit_query_rel_fields",
            "        :param kwargs: Receives all rison arguments for pagination",
            "        :return: dict with all fields details",
            "        \"\"\"",
            "        ret = []",
            "        for col in cols:",
            "            page = page_size = None",
            "            col_args = kwargs.get(col, {})",
            "            if col_args:",
            "                page = col_args.get(API_PAGE_INDEX_RIS_KEY, None)",
            "                page_size = col_args.get(API_PAGE_SIZE_RIS_KEY, None)",
            "            ret.append(",
            "                self._get_field_info(",
            "                    model_schema.fields[col],",
            "                    filter_rel_fields.get(col, []),",
            "                    page=page,",
            "                    page_size=page_size,",
            "                )",
            "            )",
            "        return ret",
            "",
            "    def _get_list_related_field(",
            "        self,",
            "        field: Field,",
            "        filter_rel_field: List[Any],",
            "        page: Optional[int] = None,",
            "        page_size: Optional[int] = None,",
            "    ) -> Tuple[int, List[Dict[str, Any]]]:",
            "        \"\"\"",
            "        Return a list of values for a related field",
            "",
            "        :param field: Marshmallow field",
            "        :param filter_rel_field: Filters for the related field,",
            "                expects [field_name, Type[BaseFilter], value]",
            "        :param page: The page index",
            "        :param page_size: The page size",
            "        :return: Total record count and list of dict with id and value",
            "        \"\"\"",
            "        ret = []",
            "        count = 0",
            "        if isinstance(field, Related) or isinstance(field, RelatedList):",
            "            datamodel = self.datamodel.get_related_interface(field.name)",
            "            filters = datamodel.get_filters(datamodel.get_search_columns_list())",
            "            page, page_size = self._sanitize_page_args(page, page_size)",
            "            order_field = self.order_rel_fields.get(field.name)",
            "            if order_field:",
            "                order_column, order_direction = order_field",
            "            else:",
            "                order_column, order_direction = \"\", \"\"",
            "            if filter_rel_field:",
            "                filters = filters.add_filter_list(filter_rel_field)",
            "            count, values = datamodel.query(",
            "                filters, order_column, order_direction, page=page, page_size=page_size",
            "            )",
            "            for value in values:",
            "                ret.append({\"id\": datamodel.get_pk_value(value), \"value\": str(value)})",
            "        return count, ret",
            "",
            "    def _merge_update_item(",
            "        self, model_item: Model, data: Dict[str, Any]",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Merge a model with a python data structure",
            "        This is useful to turn PUT method into a PATCH also",
            "        \"\"\"",
            "        data_item = self.edit_model_schema.dump(model_item, many=False)",
            "        for _col in self.edit_columns:",
            "            if _col not in data.keys():",
            "                data[_col] = data_item[_col]",
            "        return data",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                PRE AND POST METHODS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def pre_update(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, this method is called before the update takes place.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_update(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_add(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called before add.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_add(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_delete(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called before delete",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_delete(self, item: Model) -> None:",
            "        \"\"\"",
            "        Override this, will be called after delete",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_get(self, data: Dict[str, Any]) -> None:",
            "        \"\"\"",
            "        Override this, will be called before data is sent",
            "        to the requester on get item endpoint.",
            "        You can use it to mutate the response sent.",
            "        Note that any new field added will not be reflected on the OpenApi spec.",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_get_list(self, data: Dict[str, Any]) -> None:",
            "        \"\"\"",
            "        Override this, will be called before data is sent",
            "        to the requester on get list endpoint.",
            "        You can use it to mutate the response sent",
            "        Note that any new field added will not be reflected on the OpenApi spec.",
            "        \"\"\"",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job",
            "flask_appbuilder.api.BaseApi.self",
            "flask_appbuilder.api.BaseApi",
            "flask_appbuilder.api.BaseApi.responses"
        ]
    },
    "flask_appbuilder/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "             if self.app:"
            },
            "1": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "                 self.register_blueprint(baseview)"
            },
            "2": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "                 self._add_permission(baseview)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+                self.add_limits(baseview)"
            },
            "4": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "         self.add_link("
            },
            "5": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "             name=name,"
            },
            "6": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "             href=href,"
            },
            "7": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "                     baseview, endpoint=endpoint, static_folder=static_folder"
            },
            "8": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "                 )"
            },
            "9": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "                 self._add_permission(baseview)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+                self.add_limits(baseview)"
            },
            "11": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "         else:"
            },
            "12": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 570,
                "PatchRowcode": "             log.warning(LOGMSG_WAR_FAB_VIEW_EXISTS.format(baseview.__class__.__name__))"
            },
            "13": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 571,
                "PatchRowcode": "         return baseview"
            },
            "14": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 651,
                "PatchRowcode": "             locale=lang,"
            },
            "15": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 652,
                "PatchRowcode": "         )"
            },
            "16": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 653,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+    def add_limits(self, baseview: \"AbstractViewApi\") -> None:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+        if hasattr(baseview, \"limits\"):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+            self.sm.add_limit_view(baseview)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 658,
                "PatchRowcode": "     def add_permissions(self, update_perms: bool = False) -> None:"
            },
            "22": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": 659,
                "PatchRowcode": "         from flask_appbuilder.baseviews import AbstractViewApi"
            },
            "23": {
                "beforePatchRowNumber": 654,
                "afterPatchRowNumber": 660,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from functools import reduce",
            "import logging",
            "from typing import Any, Callable, cast, Dict, List, Optional, Type, TYPE_CHECKING, Union",
            "",
            "from flask import Blueprint, current_app, Flask, url_for",
            "from sqlalchemy.orm.session import Session as SessionBase",
            "",
            "from . import __version__",
            "from .api.manager import OpenApiManager",
            "from .babel.manager import BabelManager",
            "from .const import (",
            "    LOGMSG_ERR_FAB_ADD_PERMISSION_MENU,",
            "    LOGMSG_ERR_FAB_ADD_PERMISSION_VIEW,",
            "    LOGMSG_ERR_FAB_ADDON_IMPORT,",
            "    LOGMSG_ERR_FAB_ADDON_PROCESS,",
            "    LOGMSG_INF_FAB_ADD_VIEW,",
            "    LOGMSG_INF_FAB_ADDON_ADDED,",
            "    LOGMSG_WAR_FAB_VIEW_EXISTS,",
            ")",
            "from .filters import TemplateFilters",
            "from .menu import Menu, MenuApiManager",
            "from .views import IndexView, UtilView",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder.basemanager import BaseManager",
            "    from flask_appbuilder.baseviews import BaseView, AbstractViewApi",
            "    from flask_appbuilder.security.manager import BaseSecurityManager",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "DynamicImportType = Union[",
            "    Type[\"BaseManager\"],",
            "    Type[\"BaseView\"],",
            "    Type[\"BaseSecurityManager\"],",
            "    Type[Menu],",
            "    Type[\"AbstractViewApi\"],",
            "]",
            "",
            "",
            "def dynamic_class_import(class_path: str) -> Optional[DynamicImportType]:",
            "    \"\"\"",
            "    Will dynamically import a class from a string path",
            "    :param class_path: string with class path",
            "    :return: class",
            "    \"\"\"",
            "    # Split first occurrence of path",
            "    try:",
            "        tmp = class_path.split(\".\")",
            "        module_path = \".\".join(tmp[0:-1])",
            "        package = __import__(module_path)",
            "        return reduce(getattr, tmp[1:], package)",
            "    except Exception as e:",
            "        log.exception(e)",
            "        log.error(LOGMSG_ERR_FAB_ADDON_IMPORT.format(class_path, e))",
            "        return None",
            "",
            "",
            "class AppBuilder:",
            "    \"\"\"",
            "    This is the base class for all the framework.",
            "    This is where you will register all your views and create the menu structure.",
            "    Will hold your flask app object, all your views, and security classes.",
            "",
            "    initialize your application like this for SQLAlchemy::",
            "",
            "        from flask import Flask",
            "        from flask_appbuilder import SQLA, AppBuilder",
            "",
            "        app = Flask(__name__)",
            "        app.config.from_object('config')",
            "        db = SQLA(app)",
            "        appbuilder = AppBuilder(app, db.session)",
            "",
            "    When using MongoEngine::",
            "",
            "        from flask import Flask",
            "        from flask_appbuilder import AppBuilder",
            "        from flask_appbuilder.security.mongoengine.manager import SecurityManager",
            "        from flask_mongoengine import MongoEngine",
            "",
            "        app = Flask(__name__)",
            "        app.config.from_object('config')",
            "        dbmongo = MongoEngine(app)",
            "        appbuilder = AppBuilder(app, security_manager_class=SecurityManager)",
            "",
            "    You can also create everything as an application factory.",
            "    \"\"\"",
            "",
            "    security_manager_class = None",
            "",
            "    template_filters = None",
            "",
            "    def __init__(",
            "        self,",
            "        app: Optional[Flask] = None,",
            "        session: Optional[SessionBase] = None,",
            "        menu: Optional[Menu] = None,",
            "        indexview: Optional[Type[\"AbstractViewApi\"]] = None,",
            "        base_template: str = \"appbuilder/baselayout.html\",",
            "        static_folder: str = \"static/appbuilder\",",
            "        static_url_path: str = \"/appbuilder\",",
            "        security_manager_class: Optional[Type[\"BaseSecurityManager\"]] = None,",
            "        update_perms: bool = True,",
            "    ) -> None:",
            "        \"\"\"",
            "        AppBuilder init",
            "",
            "        :param app:",
            "            The flask app object",
            "        :param session:",
            "            The SQLAlchemy session object",
            "        :param menu:",
            "            optional, a previous contructed menu",
            "        :param indexview:",
            "            optional, your customized indexview",
            "        :param static_folder:",
            "            optional, your override for the global static folder",
            "        :param static_url_path:",
            "            optional, your override for the global static url path",
            "        :param security_manager_class:",
            "            optional, pass your own security manager class",
            "        :param update_perms:",
            "            optional, update permissions flag (Boolean) you can use",
            "            FAB_UPDATE_PERMS config key also",
            "        \"\"\"",
            "        self.baseviews: List[Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"]] = []",
            "",
            "        # temporary list that hold addon_managers config key",
            "        self._addon_managers: List[str] = []",
            "        # dict with addon name has key and instantiated class has value",
            "        self.addon_managers: Dict[str, Any] = {}",
            "        self.menu = menu",
            "        self.base_template = base_template",
            "        self.security_manager_class = security_manager_class",
            "        self.indexview = indexview",
            "        self.static_folder = static_folder",
            "        self.static_url_path = static_url_path",
            "        self.app = app",
            "        self.update_perms = update_perms",
            "",
            "        # Security Manager Class",
            "        self.sm: BaseSecurityManager = None  # type: ignore",
            "        # Babel Manager Class",
            "        self.bm: BabelManager = None  # type: ignore",
            "        self.openapi_manager: OpenApiManager = None  # type: ignore",
            "        self.menuapi_manager: MenuApiManager = None  # type: ignore",
            "",
            "        if app is not None:",
            "            self.init_app(app, session)",
            "",
            "    def init_app(self, app: Flask, session: SessionBase) -> None:",
            "        \"\"\"",
            "        Will initialize the Flask app, supporting the app factory pattern.",
            "",
            "        :param app:",
            "        :param session: The SQLAlchemy session",
            "",
            "        \"\"\"",
            "        app.config.setdefault(\"APP_NAME\", \"F.A.B.\")",
            "        app.config.setdefault(\"APP_THEME\", \"\")",
            "        app.config.setdefault(\"APP_ICON\", \"\")",
            "        app.config.setdefault(\"LANGUAGES\", {\"en\": {\"flag\": \"gb\", \"name\": \"English\"}})",
            "        app.config.setdefault(\"ADDON_MANAGERS\", [])",
            "        app.config.setdefault(\"FAB_API_MAX_PAGE_SIZE\", 100)",
            "        app.config.setdefault(\"FAB_BASE_TEMPLATE\", self.base_template)",
            "        app.config.setdefault(\"FAB_STATIC_FOLDER\", self.static_folder)",
            "        app.config.setdefault(\"FAB_STATIC_URL_PATH\", self.static_url_path)",
            "",
            "        self.app = app",
            "",
            "        self.base_template = app.config.get(\"FAB_BASE_TEMPLATE\", self.base_template)",
            "        self.static_folder = app.config.get(\"FAB_STATIC_FOLDER\", self.static_folder)",
            "        self.static_url_path = app.config.get(",
            "            \"FAB_STATIC_URL_PATH\", self.static_url_path",
            "        )",
            "        _index_view = app.config.get(\"FAB_INDEX_VIEW\", None)",
            "        if _index_view:",
            "            self.indexview = dynamic_class_import(_index_view)  # type: ignore",
            "        else:",
            "            self.indexview = self.indexview or IndexView",
            "",
            "        _menu = app.config.get(\"FAB_MENU\", None)",
            "",
            "        # Setup Menu",
            "        if _menu is not None:",
            "            menu = dynamic_class_import(_menu)",
            "            if menu is not None and issubclass(menu, Menu):",
            "                self.menu = menu()",
            "        else:",
            "            self.menu = self.menu or Menu()",
            "",
            "        if self.update_perms:  # default is True, if False takes precedence from config",
            "            self.update_perms = app.config.get(\"FAB_UPDATE_PERMS\", True)",
            "        _security_manager_class_name = app.config.get(",
            "            \"FAB_SECURITY_MANAGER_CLASS\", None",
            "        )",
            "        if _security_manager_class_name is not None:",
            "            security_manager_class = dynamic_class_import(_security_manager_class_name)",
            "            self.security_manager_class = cast(",
            "                Type[\"BaseSecurityManager\"], security_manager_class",
            "            )",
            "        if self.security_manager_class is None:",
            "            from flask_appbuilder.security.sqla.manager import SecurityManager",
            "",
            "            self.security_manager_class = SecurityManager",
            "",
            "        self._addon_managers = app.config[\"ADDON_MANAGERS\"]",
            "        self.session = session",
            "        self.sm = self.security_manager_class(self)",
            "        self.bm = BabelManager(self)",
            "        self.openapi_manager = OpenApiManager(self)",
            "        self.menuapi_manager = MenuApiManager(self)",
            "        self._add_global_static()",
            "        self._add_global_filters()",
            "        app.before_request(self.sm.before_request)",
            "        self._add_admin_views()",
            "        self._add_addon_views()",
            "        if self.app:",
            "            self._add_menu_permissions()",
            "        else:",
            "            self.post_init()",
            "        self._init_extension(app)",
            "",
            "    def _init_extension(self, app: Flask) -> None:",
            "        app.appbuilder = self",
            "        if not hasattr(app, \"extensions\"):",
            "            app.extensions = {}",
            "        app.extensions[\"appbuilder\"] = self",
            "",
            "    def post_init(self) -> None:",
            "        for baseview in self.baseviews:",
            "            # instantiate the views and add session",
            "            baseview = self._check_and_init(baseview)",
            "            # Register the views has blueprints",
            "            if baseview.__class__.__name__ not in self.get_app.blueprints.keys():",
            "                self.register_blueprint(baseview)",
            "            # Add missing permissions where needed",
            "        self.add_permissions()",
            "",
            "    @property",
            "    def get_app(self) -> Flask:",
            "        \"\"\"",
            "        Get current or configured flask app",
            "",
            "        :return: Flask App",
            "        \"\"\"",
            "        if self.app:",
            "            return self.app",
            "        else:",
            "            return current_app",
            "",
            "    @property",
            "    def get_session(self) -> SessionBase:",
            "        \"\"\"",
            "        Get the current sqlalchemy session.",
            "",
            "        :return: SQLAlchemy Session",
            "        \"\"\"",
            "        return self.session",
            "",
            "    @property",
            "    def app_name(self) -> str:",
            "        \"\"\"",
            "        Get the App name",
            "",
            "        :return: String with app name",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_NAME\"]",
            "",
            "    @property",
            "    def app_theme(self) -> str:",
            "        \"\"\"",
            "        Get the App theme name",
            "",
            "        :return: String app theme name",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_THEME\"]",
            "",
            "    @property",
            "    def app_icon(self) -> str:",
            "        \"\"\"",
            "        Get the App icon location",
            "",
            "        :return: String with relative app icon location",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_ICON\"]",
            "",
            "    @property",
            "    def languages(self) -> Dict[str, Any]:",
            "        return self.get_app.config[\"LANGUAGES\"]",
            "",
            "    @property",
            "    def version(self) -> str:",
            "        \"\"\"",
            "        Get the current F.A.B. version",
            "",
            "        :return: String with the current F.A.B. version",
            "        \"\"\"",
            "        return __version__",
            "",
            "    def _add_global_filters(self) -> None:",
            "        self.template_filters = TemplateFilters(self.get_app, self.sm)",
            "",
            "    def _add_global_static(self) -> None:",
            "        bp = Blueprint(",
            "            \"appbuilder\",",
            "            __name__,",
            "            url_prefix=\"/static\",",
            "            template_folder=\"templates\",",
            "            static_folder=self.static_folder,",
            "            static_url_path=self.static_url_path,",
            "        )",
            "        self.get_app.register_blueprint(bp)",
            "",
            "    def _add_admin_views(self) -> None:",
            "        \"\"\"",
            "        Registers indexview, utilview (back function), babel views and Security views.",
            "        \"\"\"",
            "        if self.indexview:",
            "            self._indexview = self.add_view_no_menu(self.indexview)",
            "        self.add_view_no_menu(UtilView)",
            "        self.bm.register_views()",
            "        self.sm.register_views()",
            "        self.openapi_manager.register_views()",
            "        self.menuapi_manager.register_views()",
            "",
            "    def _add_addon_views(self) -> None:",
            "        \"\"\"",
            "        Registers declared addon's",
            "        \"\"\"",
            "        for addon in self._addon_managers:",
            "            addon_class_ = dynamic_class_import(addon)",
            "            addon_class = cast(Type[\"BaseManager\"], addon_class_)",
            "            if addon_class:",
            "                # Instantiate manager with appbuilder (self)",
            "                inst_addon_class: \"BaseManager\" = addon_class(self)",
            "                try:",
            "                    inst_addon_class.pre_process()",
            "                    inst_addon_class.register_views()",
            "                    inst_addon_class.post_process()",
            "                    self.addon_managers[addon] = inst_addon_class",
            "                    log.info(LOGMSG_INF_FAB_ADDON_ADDED.format(str(addon)))",
            "                except Exception as e:",
            "                    log.exception(e)",
            "                    log.error(LOGMSG_ERR_FAB_ADDON_PROCESS.format(addon, e))",
            "",
            "    def _check_and_init(",
            "        self, baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"]",
            "    ) -> \"AbstractViewApi\":",
            "        # If class if not instantiated, instantiate it",
            "        # and add db session from security models.",
            "        if hasattr(baseview, \"datamodel\"):",
            "            if getattr(baseview, \"datamodel\").session is None:",
            "                getattr(baseview, \"datamodel\").session = self.session",
            "        if isinstance(baseview, type):",
            "            baseview = baseview()",
            "        return baseview",
            "",
            "    def add_view(",
            "        self,",
            "        baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"],",
            "        name: str,",
            "        href: str = \"\",",
            "        icon: str = \"\",",
            "        label: str = \"\",",
            "        category: str = \"\",",
            "        category_icon: str = \"\",",
            "        category_label: str = \"\",",
            "        menu_cond: Optional[Callable[..., bool]] = None,",
            "    ) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add your views associated with menus using this method.",
            "",
            "        :param baseview:",
            "            A BaseView type class instantiated or not.",
            "            This method will instantiate the class for you if needed.",
            "        :param name:",
            "            The string name that identifies the menu.",
            "        :param href:",
            "            Override the generated href for the menu.",
            "            You can use an url string or an endpoint name",
            "            if non provided default_view from view will be set as href.",
            "        :param icon:",
            "            Font-Awesome icon name, optional.",
            "        :param label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param category:",
            "            The menu category where the menu will be included,",
            "            if non provided the view will be acessible as a top menu.",
            "        :param category_icon:",
            "            Font-Awesome icon name for the category, optional.",
            "        :param category_label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param menu_cond:",
            "            If a callable, :code:`menu_cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this link will be a part of the menu. Otherwise, it",
            "            will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the item will always be present.",
            "",
            "        Examples::",
            "",
            "            appbuilder = AppBuilder(app, db)",
            "            # Register a view, rendering a top menu without icon.",
            "            appbuilder.add_view(MyModelView(), \"My View\")",
            "            # or not instantiated",
            "            appbuilder.add_view(MyModelView, \"My View\")",
            "            # Register a view, a submenu \"Other View\" from \"Other\" with a phone icon.",
            "            appbuilder.add_view(",
            "                MyOtherModelView,",
            "                \"Other View\",",
            "                icon='fa-phone',",
            "                category=\"Others\"",
            "            )",
            "            # Register a view, with category icon and translation.",
            "            appbuilder.add_view(",
            "                YetOtherModelView,",
            "                \"Other View\",",
            "                icon='fa-phone',",
            "                label=_('Other View'),",
            "                category=\"Others\",",
            "                category_icon='fa-envelop',",
            "                category_label=_('Other View')",
            "            )",
            "            # Register a view whose menu item will be conditionally displayed",
            "            appbuilder.add_view(",
            "                YourFeatureView,",
            "                \"Your Feature\",",
            "                icon='fa-feature',",
            "                label=_('Your Feature'),",
            "                menu_cond=lambda: is_feature_enabled(\"your-feature\"),",
            "            )",
            "            # Add a link",
            "            appbuilder.add_link(\"google\", href=\"www.google.com\", icon = \"fa-google-plus\")",
            "        \"\"\"",
            "        baseview = self._check_and_init(baseview)",
            "        log.info(LOGMSG_INF_FAB_ADD_VIEW.format(baseview.__class__.__name__, name))",
            "",
            "        if not self._view_exists(baseview):",
            "            baseview.appbuilder = self",
            "            self.baseviews.append(baseview)",
            "            self._process_inner_views()",
            "            if self.app:",
            "                self.register_blueprint(baseview)",
            "                self._add_permission(baseview)",
            "        self.add_link(",
            "            name=name,",
            "            href=href,",
            "            icon=icon,",
            "            label=label,",
            "            category=category,",
            "            category_icon=category_icon,",
            "            category_label=category_label,",
            "            baseview=baseview,",
            "            cond=menu_cond,",
            "        )",
            "        return baseview",
            "",
            "    def add_link(",
            "        self,",
            "        name: str,",
            "        href: str,",
            "        icon: str = \"\",",
            "        label: str = \"\",",
            "        category: str = \"\",",
            "        category_icon: str = \"\",",
            "        category_label: str = \"\",",
            "        baseview: Optional[\"AbstractViewApi\"] = None,",
            "        cond: Optional[Callable[..., bool]] = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        Add your own links to menu using this method",
            "",
            "        :param baseview:",
            "        :param name:",
            "            The string name that identifies the menu.",
            "        :param href:",
            "            Override the generated href for the menu.",
            "            You can use an url string or an endpoint name",
            "        :param icon:",
            "            Font-Awesome icon name, optional.",
            "        :param label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param category:",
            "            The menu category where the menu will be included,",
            "            if non provided the view will be accessible as a top menu.",
            "        :param category_icon:",
            "            Font-Awesome icon name for the category, optional.",
            "        :param category_label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param cond:",
            "            If a callable, :code:`cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this link will be a part of the menu. Otherwise, it",
            "            will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the item will always be present.",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return",
            "        self.menu.add_link(",
            "            name=name,",
            "            href=href,",
            "            icon=icon,",
            "            label=label,",
            "            category=category,",
            "            category_icon=category_icon,",
            "            category_label=category_label,",
            "            baseview=baseview,",
            "            cond=cond,",
            "        )",
            "        if self.app:",
            "            self._add_permissions_menu(name)",
            "            if category:",
            "                self._add_permissions_menu(category)",
            "",
            "    def add_separator(",
            "        self, category: str, cond: Optional[Callable[..., bool]] = None",
            "    ) -> None:",
            "        \"\"\"",
            "        Add a separator to the menu, you will sequentially create the menu",
            "",
            "        :param category:",
            "            The menu category where the separator will be included.",
            "        :param cond:",
            "            If a callable, :code:`cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this separator will be a part of the menu. Otherwise,",
            "            it will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the separator will always be present.",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return",
            "        self.menu.add_separator(category, cond=cond)",
            "",
            "    def add_view_no_menu(",
            "        self,",
            "        baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"],",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add your views without creating a menu.",
            "",
            "        :param baseview:",
            "            A BaseView type class instantiated.",
            "        :param endpoint: The endpoint path for the Flask blueprint",
            "        :param static_folder: The static folder for the Flask blueprint",
            "",
            "        \"\"\"",
            "        baseview = self._check_and_init(baseview)",
            "        log.info(LOGMSG_INF_FAB_ADD_VIEW.format(baseview.__class__.__name__, \"\"))",
            "",
            "        if not self._view_exists(baseview):",
            "            baseview.appbuilder = self",
            "            self.baseviews.append(baseview)",
            "            self._process_inner_views()",
            "            if self.app:",
            "                self.register_blueprint(",
            "                    baseview, endpoint=endpoint, static_folder=static_folder",
            "                )",
            "                self._add_permission(baseview)",
            "        else:",
            "            log.warning(LOGMSG_WAR_FAB_VIEW_EXISTS.format(baseview.__class__.__name__))",
            "        return baseview",
            "",
            "    def add_api(self, baseview: Type[\"AbstractViewApi\"]) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add a BaseApi class or child to AppBuilder",
            "",
            "        :param baseview: A BaseApi type class",
            "        :return: The instantiated base view",
            "        \"\"\"",
            "        return self.add_view_no_menu(baseview)",
            "",
            "    def security_cleanup(self) -> None:",
            "        \"\"\"",
            "        This method is useful if you have changed",
            "        the name of your menus or classes,",
            "        changing them will leave behind permissions",
            "        that are not associated with anything.",
            "",
            "        You can use it always or just sometimes to",
            "        perform a security cleanup. Warning this will delete any permission",
            "        that is no longer part of any registered view or menu.",
            "",
            "        Remember invoke ONLY AFTER YOU HAVE REGISTERED ALL VIEWS",
            "        \"\"\"",
            "        self.sm.security_cleanup(self.baseviews, self.menu)",
            "",
            "    def security_converge(self, dry: bool = False) -> Dict[str, Any]:",
            "        \"\"\"",
            "        This method is useful when you use:",
            "",
            "        - `class_permission_name`",
            "        - `previous_class_permission_name`",
            "        - `method_permission_name`",
            "        - `previous_method_permission_name`",
            "",
            "        migrates all permissions to the new names on all the Roles",
            "",
            "        :param dry: If True will not change DB",
            "        :return: Dict with all computed necessary operations",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return {}",
            "        return self.sm.security_converge(self.baseviews, self.menu.menu, dry)",
            "",
            "    def get_url_for_login_with(self, next_url: str = None) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"login\"), next=next_url)",
            "",
            "    @property",
            "    def get_url_for_login(self) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"login\"))",
            "",
            "    @property",
            "    def get_url_for_logout(self) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"logout\"))",
            "",
            "    @property",
            "    def get_url_for_index(self) -> str:",
            "        if self._indexview is None:",
            "            return \"\"",
            "        return url_for(",
            "            \"%s.%s\" % (self._indexview.endpoint, self._indexview.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_url_for_userinfo(self) -> str:",
            "        if self.sm.user_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.user_view.endpoint, \"userinfo\"))",
            "",
            "    def get_url_for_locale(self, lang: str) -> str:",
            "        if self.bm.locale_view is None:",
            "            return \"\"",
            "        return url_for(",
            "            \"%s.%s\" % (self.bm.locale_view.endpoint, self.bm.locale_view.default_view),",
            "            locale=lang,",
            "        )",
            "",
            "    def add_permissions(self, update_perms: bool = False) -> None:",
            "        from flask_appbuilder.baseviews import AbstractViewApi",
            "",
            "        if self.update_perms or update_perms:",
            "            for baseview in self.baseviews:",
            "                baseview = cast(AbstractViewApi, baseview)",
            "                self._add_permission(baseview, update_perms=update_perms)",
            "            self._add_menu_permissions(update_perms=update_perms)",
            "",
            "    def _add_permission(",
            "        self, baseview: \"AbstractViewApi\", update_perms: bool = False",
            "    ) -> None:",
            "        if self.update_perms or update_perms:",
            "            try:",
            "                self.sm.add_permissions_view(",
            "                    baseview.base_permissions, baseview.class_permission_name",
            "                )",
            "            except Exception as e:",
            "                log.exception(e)",
            "                log.error(LOGMSG_ERR_FAB_ADD_PERMISSION_VIEW.format(str(e)))",
            "",
            "    def _add_permissions_menu(self, name: str, update_perms: bool = False) -> None:",
            "        if self.update_perms or update_perms:",
            "            try:",
            "                self.sm.add_permissions_menu(name)",
            "            except Exception as e:",
            "                log.exception(e)",
            "                log.error(LOGMSG_ERR_FAB_ADD_PERMISSION_MENU.format(str(e)))",
            "",
            "    def _add_menu_permissions(self, update_perms: bool = False) -> None:",
            "        if self.menu is None:",
            "            return",
            "        if self.update_perms or update_perms:",
            "            for category in self.menu.get_list():",
            "                self._add_permissions_menu(category.name, update_perms=update_perms)",
            "                for item in category.childs:",
            "                    # don't add permission for menu separator",
            "                    if item.name != \"-\":",
            "                        self._add_permissions_menu(item.name, update_perms=update_perms)",
            "",
            "    def register_blueprint(",
            "        self,",
            "        baseview: \"AbstractViewApi\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> None:",
            "        self.get_app.register_blueprint(",
            "            baseview.create_blueprint(",
            "                self, endpoint=endpoint, static_folder=static_folder",
            "            )",
            "        )",
            "",
            "    def _view_exists(self, view: \"AbstractViewApi\") -> bool:",
            "        for baseview in self.baseviews:",
            "            if baseview.__class__ == view.__class__:",
            "                return True",
            "        return False",
            "",
            "    def _process_inner_views(self) -> None:",
            "        from flask_appbuilder.baseviews import AbstractViewApi",
            "",
            "        for view in self.baseviews:",
            "            view = cast(AbstractViewApi, view)",
            "            for inner_class in view.get_uninit_inner_views():",
            "                for v in self.baseviews:",
            "                    if (",
            "                        isinstance(v, inner_class)",
            "                        and v not in view.get_init_inner_views()",
            "                    ):",
            "                        view.get_init_inner_views().append(v)"
        ],
        "afterPatchFile": [
            "from functools import reduce",
            "import logging",
            "from typing import Any, Callable, cast, Dict, List, Optional, Type, TYPE_CHECKING, Union",
            "",
            "from flask import Blueprint, current_app, Flask, url_for",
            "from sqlalchemy.orm.session import Session as SessionBase",
            "",
            "from . import __version__",
            "from .api.manager import OpenApiManager",
            "from .babel.manager import BabelManager",
            "from .const import (",
            "    LOGMSG_ERR_FAB_ADD_PERMISSION_MENU,",
            "    LOGMSG_ERR_FAB_ADD_PERMISSION_VIEW,",
            "    LOGMSG_ERR_FAB_ADDON_IMPORT,",
            "    LOGMSG_ERR_FAB_ADDON_PROCESS,",
            "    LOGMSG_INF_FAB_ADD_VIEW,",
            "    LOGMSG_INF_FAB_ADDON_ADDED,",
            "    LOGMSG_WAR_FAB_VIEW_EXISTS,",
            ")",
            "from .filters import TemplateFilters",
            "from .menu import Menu, MenuApiManager",
            "from .views import IndexView, UtilView",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder.basemanager import BaseManager",
            "    from flask_appbuilder.baseviews import BaseView, AbstractViewApi",
            "    from flask_appbuilder.security.manager import BaseSecurityManager",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "DynamicImportType = Union[",
            "    Type[\"BaseManager\"],",
            "    Type[\"BaseView\"],",
            "    Type[\"BaseSecurityManager\"],",
            "    Type[Menu],",
            "    Type[\"AbstractViewApi\"],",
            "]",
            "",
            "",
            "def dynamic_class_import(class_path: str) -> Optional[DynamicImportType]:",
            "    \"\"\"",
            "    Will dynamically import a class from a string path",
            "    :param class_path: string with class path",
            "    :return: class",
            "    \"\"\"",
            "    # Split first occurrence of path",
            "    try:",
            "        tmp = class_path.split(\".\")",
            "        module_path = \".\".join(tmp[0:-1])",
            "        package = __import__(module_path)",
            "        return reduce(getattr, tmp[1:], package)",
            "    except Exception as e:",
            "        log.exception(e)",
            "        log.error(LOGMSG_ERR_FAB_ADDON_IMPORT.format(class_path, e))",
            "        return None",
            "",
            "",
            "class AppBuilder:",
            "    \"\"\"",
            "    This is the base class for all the framework.",
            "    This is where you will register all your views and create the menu structure.",
            "    Will hold your flask app object, all your views, and security classes.",
            "",
            "    initialize your application like this for SQLAlchemy::",
            "",
            "        from flask import Flask",
            "        from flask_appbuilder import SQLA, AppBuilder",
            "",
            "        app = Flask(__name__)",
            "        app.config.from_object('config')",
            "        db = SQLA(app)",
            "        appbuilder = AppBuilder(app, db.session)",
            "",
            "    When using MongoEngine::",
            "",
            "        from flask import Flask",
            "        from flask_appbuilder import AppBuilder",
            "        from flask_appbuilder.security.mongoengine.manager import SecurityManager",
            "        from flask_mongoengine import MongoEngine",
            "",
            "        app = Flask(__name__)",
            "        app.config.from_object('config')",
            "        dbmongo = MongoEngine(app)",
            "        appbuilder = AppBuilder(app, security_manager_class=SecurityManager)",
            "",
            "    You can also create everything as an application factory.",
            "    \"\"\"",
            "",
            "    security_manager_class = None",
            "",
            "    template_filters = None",
            "",
            "    def __init__(",
            "        self,",
            "        app: Optional[Flask] = None,",
            "        session: Optional[SessionBase] = None,",
            "        menu: Optional[Menu] = None,",
            "        indexview: Optional[Type[\"AbstractViewApi\"]] = None,",
            "        base_template: str = \"appbuilder/baselayout.html\",",
            "        static_folder: str = \"static/appbuilder\",",
            "        static_url_path: str = \"/appbuilder\",",
            "        security_manager_class: Optional[Type[\"BaseSecurityManager\"]] = None,",
            "        update_perms: bool = True,",
            "    ) -> None:",
            "        \"\"\"",
            "        AppBuilder init",
            "",
            "        :param app:",
            "            The flask app object",
            "        :param session:",
            "            The SQLAlchemy session object",
            "        :param menu:",
            "            optional, a previous contructed menu",
            "        :param indexview:",
            "            optional, your customized indexview",
            "        :param static_folder:",
            "            optional, your override for the global static folder",
            "        :param static_url_path:",
            "            optional, your override for the global static url path",
            "        :param security_manager_class:",
            "            optional, pass your own security manager class",
            "        :param update_perms:",
            "            optional, update permissions flag (Boolean) you can use",
            "            FAB_UPDATE_PERMS config key also",
            "        \"\"\"",
            "        self.baseviews: List[Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"]] = []",
            "",
            "        # temporary list that hold addon_managers config key",
            "        self._addon_managers: List[str] = []",
            "        # dict with addon name has key and instantiated class has value",
            "        self.addon_managers: Dict[str, Any] = {}",
            "        self.menu = menu",
            "        self.base_template = base_template",
            "        self.security_manager_class = security_manager_class",
            "        self.indexview = indexview",
            "        self.static_folder = static_folder",
            "        self.static_url_path = static_url_path",
            "        self.app = app",
            "        self.update_perms = update_perms",
            "",
            "        # Security Manager Class",
            "        self.sm: BaseSecurityManager = None  # type: ignore",
            "        # Babel Manager Class",
            "        self.bm: BabelManager = None  # type: ignore",
            "        self.openapi_manager: OpenApiManager = None  # type: ignore",
            "        self.menuapi_manager: MenuApiManager = None  # type: ignore",
            "",
            "        if app is not None:",
            "            self.init_app(app, session)",
            "",
            "    def init_app(self, app: Flask, session: SessionBase) -> None:",
            "        \"\"\"",
            "        Will initialize the Flask app, supporting the app factory pattern.",
            "",
            "        :param app:",
            "        :param session: The SQLAlchemy session",
            "",
            "        \"\"\"",
            "        app.config.setdefault(\"APP_NAME\", \"F.A.B.\")",
            "        app.config.setdefault(\"APP_THEME\", \"\")",
            "        app.config.setdefault(\"APP_ICON\", \"\")",
            "        app.config.setdefault(\"LANGUAGES\", {\"en\": {\"flag\": \"gb\", \"name\": \"English\"}})",
            "        app.config.setdefault(\"ADDON_MANAGERS\", [])",
            "        app.config.setdefault(\"FAB_API_MAX_PAGE_SIZE\", 100)",
            "        app.config.setdefault(\"FAB_BASE_TEMPLATE\", self.base_template)",
            "        app.config.setdefault(\"FAB_STATIC_FOLDER\", self.static_folder)",
            "        app.config.setdefault(\"FAB_STATIC_URL_PATH\", self.static_url_path)",
            "",
            "        self.app = app",
            "",
            "        self.base_template = app.config.get(\"FAB_BASE_TEMPLATE\", self.base_template)",
            "        self.static_folder = app.config.get(\"FAB_STATIC_FOLDER\", self.static_folder)",
            "        self.static_url_path = app.config.get(",
            "            \"FAB_STATIC_URL_PATH\", self.static_url_path",
            "        )",
            "        _index_view = app.config.get(\"FAB_INDEX_VIEW\", None)",
            "        if _index_view:",
            "            self.indexview = dynamic_class_import(_index_view)  # type: ignore",
            "        else:",
            "            self.indexview = self.indexview or IndexView",
            "",
            "        _menu = app.config.get(\"FAB_MENU\", None)",
            "",
            "        # Setup Menu",
            "        if _menu is not None:",
            "            menu = dynamic_class_import(_menu)",
            "            if menu is not None and issubclass(menu, Menu):",
            "                self.menu = menu()",
            "        else:",
            "            self.menu = self.menu or Menu()",
            "",
            "        if self.update_perms:  # default is True, if False takes precedence from config",
            "            self.update_perms = app.config.get(\"FAB_UPDATE_PERMS\", True)",
            "        _security_manager_class_name = app.config.get(",
            "            \"FAB_SECURITY_MANAGER_CLASS\", None",
            "        )",
            "        if _security_manager_class_name is not None:",
            "            security_manager_class = dynamic_class_import(_security_manager_class_name)",
            "            self.security_manager_class = cast(",
            "                Type[\"BaseSecurityManager\"], security_manager_class",
            "            )",
            "        if self.security_manager_class is None:",
            "            from flask_appbuilder.security.sqla.manager import SecurityManager",
            "",
            "            self.security_manager_class = SecurityManager",
            "",
            "        self._addon_managers = app.config[\"ADDON_MANAGERS\"]",
            "        self.session = session",
            "        self.sm = self.security_manager_class(self)",
            "        self.bm = BabelManager(self)",
            "        self.openapi_manager = OpenApiManager(self)",
            "        self.menuapi_manager = MenuApiManager(self)",
            "        self._add_global_static()",
            "        self._add_global_filters()",
            "        app.before_request(self.sm.before_request)",
            "        self._add_admin_views()",
            "        self._add_addon_views()",
            "        if self.app:",
            "            self._add_menu_permissions()",
            "        else:",
            "            self.post_init()",
            "        self._init_extension(app)",
            "",
            "    def _init_extension(self, app: Flask) -> None:",
            "        app.appbuilder = self",
            "        if not hasattr(app, \"extensions\"):",
            "            app.extensions = {}",
            "        app.extensions[\"appbuilder\"] = self",
            "",
            "    def post_init(self) -> None:",
            "        for baseview in self.baseviews:",
            "            # instantiate the views and add session",
            "            baseview = self._check_and_init(baseview)",
            "            # Register the views has blueprints",
            "            if baseview.__class__.__name__ not in self.get_app.blueprints.keys():",
            "                self.register_blueprint(baseview)",
            "            # Add missing permissions where needed",
            "        self.add_permissions()",
            "",
            "    @property",
            "    def get_app(self) -> Flask:",
            "        \"\"\"",
            "        Get current or configured flask app",
            "",
            "        :return: Flask App",
            "        \"\"\"",
            "        if self.app:",
            "            return self.app",
            "        else:",
            "            return current_app",
            "",
            "    @property",
            "    def get_session(self) -> SessionBase:",
            "        \"\"\"",
            "        Get the current sqlalchemy session.",
            "",
            "        :return: SQLAlchemy Session",
            "        \"\"\"",
            "        return self.session",
            "",
            "    @property",
            "    def app_name(self) -> str:",
            "        \"\"\"",
            "        Get the App name",
            "",
            "        :return: String with app name",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_NAME\"]",
            "",
            "    @property",
            "    def app_theme(self) -> str:",
            "        \"\"\"",
            "        Get the App theme name",
            "",
            "        :return: String app theme name",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_THEME\"]",
            "",
            "    @property",
            "    def app_icon(self) -> str:",
            "        \"\"\"",
            "        Get the App icon location",
            "",
            "        :return: String with relative app icon location",
            "        \"\"\"",
            "        return self.get_app.config[\"APP_ICON\"]",
            "",
            "    @property",
            "    def languages(self) -> Dict[str, Any]:",
            "        return self.get_app.config[\"LANGUAGES\"]",
            "",
            "    @property",
            "    def version(self) -> str:",
            "        \"\"\"",
            "        Get the current F.A.B. version",
            "",
            "        :return: String with the current F.A.B. version",
            "        \"\"\"",
            "        return __version__",
            "",
            "    def _add_global_filters(self) -> None:",
            "        self.template_filters = TemplateFilters(self.get_app, self.sm)",
            "",
            "    def _add_global_static(self) -> None:",
            "        bp = Blueprint(",
            "            \"appbuilder\",",
            "            __name__,",
            "            url_prefix=\"/static\",",
            "            template_folder=\"templates\",",
            "            static_folder=self.static_folder,",
            "            static_url_path=self.static_url_path,",
            "        )",
            "        self.get_app.register_blueprint(bp)",
            "",
            "    def _add_admin_views(self) -> None:",
            "        \"\"\"",
            "        Registers indexview, utilview (back function), babel views and Security views.",
            "        \"\"\"",
            "        if self.indexview:",
            "            self._indexview = self.add_view_no_menu(self.indexview)",
            "        self.add_view_no_menu(UtilView)",
            "        self.bm.register_views()",
            "        self.sm.register_views()",
            "        self.openapi_manager.register_views()",
            "        self.menuapi_manager.register_views()",
            "",
            "    def _add_addon_views(self) -> None:",
            "        \"\"\"",
            "        Registers declared addon's",
            "        \"\"\"",
            "        for addon in self._addon_managers:",
            "            addon_class_ = dynamic_class_import(addon)",
            "            addon_class = cast(Type[\"BaseManager\"], addon_class_)",
            "            if addon_class:",
            "                # Instantiate manager with appbuilder (self)",
            "                inst_addon_class: \"BaseManager\" = addon_class(self)",
            "                try:",
            "                    inst_addon_class.pre_process()",
            "                    inst_addon_class.register_views()",
            "                    inst_addon_class.post_process()",
            "                    self.addon_managers[addon] = inst_addon_class",
            "                    log.info(LOGMSG_INF_FAB_ADDON_ADDED.format(str(addon)))",
            "                except Exception as e:",
            "                    log.exception(e)",
            "                    log.error(LOGMSG_ERR_FAB_ADDON_PROCESS.format(addon, e))",
            "",
            "    def _check_and_init(",
            "        self, baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"]",
            "    ) -> \"AbstractViewApi\":",
            "        # If class if not instantiated, instantiate it",
            "        # and add db session from security models.",
            "        if hasattr(baseview, \"datamodel\"):",
            "            if getattr(baseview, \"datamodel\").session is None:",
            "                getattr(baseview, \"datamodel\").session = self.session",
            "        if isinstance(baseview, type):",
            "            baseview = baseview()",
            "        return baseview",
            "",
            "    def add_view(",
            "        self,",
            "        baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"],",
            "        name: str,",
            "        href: str = \"\",",
            "        icon: str = \"\",",
            "        label: str = \"\",",
            "        category: str = \"\",",
            "        category_icon: str = \"\",",
            "        category_label: str = \"\",",
            "        menu_cond: Optional[Callable[..., bool]] = None,",
            "    ) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add your views associated with menus using this method.",
            "",
            "        :param baseview:",
            "            A BaseView type class instantiated or not.",
            "            This method will instantiate the class for you if needed.",
            "        :param name:",
            "            The string name that identifies the menu.",
            "        :param href:",
            "            Override the generated href for the menu.",
            "            You can use an url string or an endpoint name",
            "            if non provided default_view from view will be set as href.",
            "        :param icon:",
            "            Font-Awesome icon name, optional.",
            "        :param label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param category:",
            "            The menu category where the menu will be included,",
            "            if non provided the view will be acessible as a top menu.",
            "        :param category_icon:",
            "            Font-Awesome icon name for the category, optional.",
            "        :param category_label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param menu_cond:",
            "            If a callable, :code:`menu_cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this link will be a part of the menu. Otherwise, it",
            "            will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the item will always be present.",
            "",
            "        Examples::",
            "",
            "            appbuilder = AppBuilder(app, db)",
            "            # Register a view, rendering a top menu without icon.",
            "            appbuilder.add_view(MyModelView(), \"My View\")",
            "            # or not instantiated",
            "            appbuilder.add_view(MyModelView, \"My View\")",
            "            # Register a view, a submenu \"Other View\" from \"Other\" with a phone icon.",
            "            appbuilder.add_view(",
            "                MyOtherModelView,",
            "                \"Other View\",",
            "                icon='fa-phone',",
            "                category=\"Others\"",
            "            )",
            "            # Register a view, with category icon and translation.",
            "            appbuilder.add_view(",
            "                YetOtherModelView,",
            "                \"Other View\",",
            "                icon='fa-phone',",
            "                label=_('Other View'),",
            "                category=\"Others\",",
            "                category_icon='fa-envelop',",
            "                category_label=_('Other View')",
            "            )",
            "            # Register a view whose menu item will be conditionally displayed",
            "            appbuilder.add_view(",
            "                YourFeatureView,",
            "                \"Your Feature\",",
            "                icon='fa-feature',",
            "                label=_('Your Feature'),",
            "                menu_cond=lambda: is_feature_enabled(\"your-feature\"),",
            "            )",
            "            # Add a link",
            "            appbuilder.add_link(\"google\", href=\"www.google.com\", icon = \"fa-google-plus\")",
            "        \"\"\"",
            "        baseview = self._check_and_init(baseview)",
            "        log.info(LOGMSG_INF_FAB_ADD_VIEW.format(baseview.__class__.__name__, name))",
            "",
            "        if not self._view_exists(baseview):",
            "            baseview.appbuilder = self",
            "            self.baseviews.append(baseview)",
            "            self._process_inner_views()",
            "            if self.app:",
            "                self.register_blueprint(baseview)",
            "                self._add_permission(baseview)",
            "                self.add_limits(baseview)",
            "        self.add_link(",
            "            name=name,",
            "            href=href,",
            "            icon=icon,",
            "            label=label,",
            "            category=category,",
            "            category_icon=category_icon,",
            "            category_label=category_label,",
            "            baseview=baseview,",
            "            cond=menu_cond,",
            "        )",
            "        return baseview",
            "",
            "    def add_link(",
            "        self,",
            "        name: str,",
            "        href: str,",
            "        icon: str = \"\",",
            "        label: str = \"\",",
            "        category: str = \"\",",
            "        category_icon: str = \"\",",
            "        category_label: str = \"\",",
            "        baseview: Optional[\"AbstractViewApi\"] = None,",
            "        cond: Optional[Callable[..., bool]] = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        Add your own links to menu using this method",
            "",
            "        :param baseview:",
            "        :param name:",
            "            The string name that identifies the menu.",
            "        :param href:",
            "            Override the generated href for the menu.",
            "            You can use an url string or an endpoint name",
            "        :param icon:",
            "            Font-Awesome icon name, optional.",
            "        :param label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param category:",
            "            The menu category where the menu will be included,",
            "            if non provided the view will be accessible as a top menu.",
            "        :param category_icon:",
            "            Font-Awesome icon name for the category, optional.",
            "        :param category_label:",
            "            The label that will be displayed on the menu,",
            "            if absent param name will be used",
            "        :param cond:",
            "            If a callable, :code:`cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this link will be a part of the menu. Otherwise, it",
            "            will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the item will always be present.",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return",
            "        self.menu.add_link(",
            "            name=name,",
            "            href=href,",
            "            icon=icon,",
            "            label=label,",
            "            category=category,",
            "            category_icon=category_icon,",
            "            category_label=category_label,",
            "            baseview=baseview,",
            "            cond=cond,",
            "        )",
            "        if self.app:",
            "            self._add_permissions_menu(name)",
            "            if category:",
            "                self._add_permissions_menu(category)",
            "",
            "    def add_separator(",
            "        self, category: str, cond: Optional[Callable[..., bool]] = None",
            "    ) -> None:",
            "        \"\"\"",
            "        Add a separator to the menu, you will sequentially create the menu",
            "",
            "        :param category:",
            "            The menu category where the separator will be included.",
            "        :param cond:",
            "            If a callable, :code:`cond` will be invoked when",
            "            constructing the menu items. If it returns :code:`True`,",
            "            then this separator will be a part of the menu. Otherwise,",
            "            it will not be included in the menu items. Defaults to",
            "            :code:`None`, meaning the separator will always be present.",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return",
            "        self.menu.add_separator(category, cond=cond)",
            "",
            "    def add_view_no_menu(",
            "        self,",
            "        baseview: Union[Type[\"AbstractViewApi\"], \"AbstractViewApi\"],",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add your views without creating a menu.",
            "",
            "        :param baseview:",
            "            A BaseView type class instantiated.",
            "        :param endpoint: The endpoint path for the Flask blueprint",
            "        :param static_folder: The static folder for the Flask blueprint",
            "",
            "        \"\"\"",
            "        baseview = self._check_and_init(baseview)",
            "        log.info(LOGMSG_INF_FAB_ADD_VIEW.format(baseview.__class__.__name__, \"\"))",
            "",
            "        if not self._view_exists(baseview):",
            "            baseview.appbuilder = self",
            "            self.baseviews.append(baseview)",
            "            self._process_inner_views()",
            "            if self.app:",
            "                self.register_blueprint(",
            "                    baseview, endpoint=endpoint, static_folder=static_folder",
            "                )",
            "                self._add_permission(baseview)",
            "                self.add_limits(baseview)",
            "        else:",
            "            log.warning(LOGMSG_WAR_FAB_VIEW_EXISTS.format(baseview.__class__.__name__))",
            "        return baseview",
            "",
            "    def add_api(self, baseview: Type[\"AbstractViewApi\"]) -> \"AbstractViewApi\":",
            "        \"\"\"",
            "        Add a BaseApi class or child to AppBuilder",
            "",
            "        :param baseview: A BaseApi type class",
            "        :return: The instantiated base view",
            "        \"\"\"",
            "        return self.add_view_no_menu(baseview)",
            "",
            "    def security_cleanup(self) -> None:",
            "        \"\"\"",
            "        This method is useful if you have changed",
            "        the name of your menus or classes,",
            "        changing them will leave behind permissions",
            "        that are not associated with anything.",
            "",
            "        You can use it always or just sometimes to",
            "        perform a security cleanup. Warning this will delete any permission",
            "        that is no longer part of any registered view or menu.",
            "",
            "        Remember invoke ONLY AFTER YOU HAVE REGISTERED ALL VIEWS",
            "        \"\"\"",
            "        self.sm.security_cleanup(self.baseviews, self.menu)",
            "",
            "    def security_converge(self, dry: bool = False) -> Dict[str, Any]:",
            "        \"\"\"",
            "        This method is useful when you use:",
            "",
            "        - `class_permission_name`",
            "        - `previous_class_permission_name`",
            "        - `method_permission_name`",
            "        - `previous_method_permission_name`",
            "",
            "        migrates all permissions to the new names on all the Roles",
            "",
            "        :param dry: If True will not change DB",
            "        :return: Dict with all computed necessary operations",
            "        \"\"\"",
            "        if self.menu is None:",
            "            return {}",
            "        return self.sm.security_converge(self.baseviews, self.menu.menu, dry)",
            "",
            "    def get_url_for_login_with(self, next_url: str = None) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"login\"), next=next_url)",
            "",
            "    @property",
            "    def get_url_for_login(self) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"login\"))",
            "",
            "    @property",
            "    def get_url_for_logout(self) -> str:",
            "        if self.sm.auth_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.auth_view.endpoint, \"logout\"))",
            "",
            "    @property",
            "    def get_url_for_index(self) -> str:",
            "        if self._indexview is None:",
            "            return \"\"",
            "        return url_for(",
            "            \"%s.%s\" % (self._indexview.endpoint, self._indexview.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_url_for_userinfo(self) -> str:",
            "        if self.sm.user_view is None:",
            "            return \"\"",
            "        return url_for(\"%s.%s\" % (self.sm.user_view.endpoint, \"userinfo\"))",
            "",
            "    def get_url_for_locale(self, lang: str) -> str:",
            "        if self.bm.locale_view is None:",
            "            return \"\"",
            "        return url_for(",
            "            \"%s.%s\" % (self.bm.locale_view.endpoint, self.bm.locale_view.default_view),",
            "            locale=lang,",
            "        )",
            "",
            "    def add_limits(self, baseview: \"AbstractViewApi\") -> None:",
            "        if hasattr(baseview, \"limits\"):",
            "            self.sm.add_limit_view(baseview)",
            "",
            "    def add_permissions(self, update_perms: bool = False) -> None:",
            "        from flask_appbuilder.baseviews import AbstractViewApi",
            "",
            "        if self.update_perms or update_perms:",
            "            for baseview in self.baseviews:",
            "                baseview = cast(AbstractViewApi, baseview)",
            "                self._add_permission(baseview, update_perms=update_perms)",
            "            self._add_menu_permissions(update_perms=update_perms)",
            "",
            "    def _add_permission(",
            "        self, baseview: \"AbstractViewApi\", update_perms: bool = False",
            "    ) -> None:",
            "        if self.update_perms or update_perms:",
            "            try:",
            "                self.sm.add_permissions_view(",
            "                    baseview.base_permissions, baseview.class_permission_name",
            "                )",
            "            except Exception as e:",
            "                log.exception(e)",
            "                log.error(LOGMSG_ERR_FAB_ADD_PERMISSION_VIEW.format(str(e)))",
            "",
            "    def _add_permissions_menu(self, name: str, update_perms: bool = False) -> None:",
            "        if self.update_perms or update_perms:",
            "            try:",
            "                self.sm.add_permissions_menu(name)",
            "            except Exception as e:",
            "                log.exception(e)",
            "                log.error(LOGMSG_ERR_FAB_ADD_PERMISSION_MENU.format(str(e)))",
            "",
            "    def _add_menu_permissions(self, update_perms: bool = False) -> None:",
            "        if self.menu is None:",
            "            return",
            "        if self.update_perms or update_perms:",
            "            for category in self.menu.get_list():",
            "                self._add_permissions_menu(category.name, update_perms=update_perms)",
            "                for item in category.childs:",
            "                    # don't add permission for menu separator",
            "                    if item.name != \"-\":",
            "                        self._add_permissions_menu(item.name, update_perms=update_perms)",
            "",
            "    def register_blueprint(",
            "        self,",
            "        baseview: \"AbstractViewApi\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ) -> None:",
            "        self.get_app.register_blueprint(",
            "            baseview.create_blueprint(",
            "                self, endpoint=endpoint, static_folder=static_folder",
            "            )",
            "        )",
            "",
            "    def _view_exists(self, view: \"AbstractViewApi\") -> bool:",
            "        for baseview in self.baseviews:",
            "            if baseview.__class__ == view.__class__:",
            "                return True",
            "        return False",
            "",
            "    def _process_inner_views(self) -> None:",
            "        from flask_appbuilder.baseviews import AbstractViewApi",
            "",
            "        for view in self.baseviews:",
            "            view = cast(AbstractViewApi, view)",
            "            for inner_class in view.get_uninit_inner_views():",
            "                for v in self.baseviews:",
            "                    if (",
            "                        isinstance(v, inner_class)",
            "                        and v not in view.get_init_inner_views()",
            "                    ):",
            "                        view.get_init_inner_views().append(v)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "flask_appbuilder.base.AppBuilder.add_view",
            "flask_appbuilder.base.AppBuilder.add_api",
            "flask_appbuilder.base.AppBuilder._add_admin_views",
            "flask_appbuilder.base.AppBuilder.self",
            "web.pgadmin.tools.import_export.create_import_export_job",
            "flask_appbuilder.base.AppBuilder.add_view_no_menu"
        ]
    },
    "flask_appbuilder/baseviews.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     default_view = \"list\""
            },
            "1": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     \"\"\" the default view for this BaseView, to be used with url_for (method name) \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "     extra_args = None"
            },
            "3": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     \"\"\" dictionary for injecting extra arguments into template \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    limits = None"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        List of limits for this view."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        Use it like this if you want to restrict the rate of requests to a view:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            class MyView(ModelView):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                limits = [Limit(\"2 per 5 second\")]"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        or use the decorator @limit."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+    \"\"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     _apis = None"
            },
            "19": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "     def __init__(self):"
            },
            "21": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "             self.base_permissions = set()"
            },
            "22": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             is_add_base_permissions = True"
            },
            "23": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        if self.limits is None:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            self.limits = []"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         for attr_name in dir(self):"
            },
            "28": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "             # If include_route_methods is not None white list"
            },
            "29": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             if ("
            },
            "30": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "                 _extra = getattr(getattr(self, attr_name), \"_extra\")"
            },
            "31": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "                 for key in _extra:"
            },
            "32": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "                     self._apis[key] = _extra[key]"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+            if hasattr(getattr(self, attr_name), \"_limit\"):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+                self.limits.append(getattr(getattr(self, attr_name), \"_limit\"))"
            },
            "35": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     def create_blueprint(self, appbuilder, endpoint=None, static_folder=None):"
            },
            "37": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         \"\"\""
            },
            "39": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         Sets initialized inner views"
            },
            "40": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "         \"\"\""
            },
            "41": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "42": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 405,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "     def get_method_permission(self, method_name: str) -> str:"
            },
            "44": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         \"\"\""
            },
            "45": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "         \"\"\""
            },
            "46": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "         Override this method to implement your form processing"
            },
            "47": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "         \"\"\""
            },
            "48": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "49": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 455,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "     def form_post(self, form):"
            },
            "51": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "         \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "         Return None or a flask response to render"
            },
            "53": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "         a custom template or redirect the user"
            },
            "54": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "         \"\"\""
            },
            "55": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "56": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 465,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "     def _get_edit_widget(self, form=None, exclude_cols=None, widgets=None):"
            },
            "58": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         exclude_cols = exclude_cols or []"
            },
            "59": {
                "beforePatchRowNumber": 1380,
                "afterPatchRowNumber": 1394,
                "PatchRowcode": "                 if form.email.data:"
            },
            "60": {
                "beforePatchRowNumber": 1381,
                "afterPatchRowNumber": 1395,
                "PatchRowcode": "                     form.email_confirmation.data = form.email.data"
            },
            "61": {
                "beforePatchRowNumber": 1382,
                "afterPatchRowNumber": 1396,
                "PatchRowcode": "         \"\"\""
            },
            "62": {
                "beforePatchRowNumber": 1383,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "63": {
                "beforePatchRowNumber": 1384,
                "afterPatchRowNumber": 1397,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 1385,
                "afterPatchRowNumber": 1398,
                "PatchRowcode": "     def process_form(self, form, is_created):"
            },
            "65": {
                "beforePatchRowNumber": 1386,
                "afterPatchRowNumber": 1399,
                "PatchRowcode": "         \"\"\""
            },
            "66": {
                "beforePatchRowNumber": 1396,
                "afterPatchRowNumber": 1409,
                "PatchRowcode": "                 if not form.owner:"
            },
            "67": {
                "beforePatchRowNumber": 1397,
                "afterPatchRowNumber": 1410,
                "PatchRowcode": "                     form.owner.data = 'n/a'"
            },
            "68": {
                "beforePatchRowNumber": 1398,
                "afterPatchRowNumber": 1411,
                "PatchRowcode": "         \"\"\""
            },
            "69": {
                "beforePatchRowNumber": 1399,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "70": {
                "beforePatchRowNumber": 1400,
                "afterPatchRowNumber": 1412,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 1401,
                "afterPatchRowNumber": 1413,
                "PatchRowcode": "     def pre_update(self, item):"
            },
            "72": {
                "beforePatchRowNumber": 1402,
                "afterPatchRowNumber": 1414,
                "PatchRowcode": "         \"\"\""
            },
            "73": {
                "beforePatchRowNumber": 1407,
                "afterPatchRowNumber": 1419,
                "PatchRowcode": "         implement more complex logic around updates. For instance"
            },
            "74": {
                "beforePatchRowNumber": 1408,
                "afterPatchRowNumber": 1420,
                "PatchRowcode": "         allowing only the original creator of the object to update it."
            },
            "75": {
                "beforePatchRowNumber": 1409,
                "afterPatchRowNumber": 1421,
                "PatchRowcode": "         \"\"\""
            },
            "76": {
                "beforePatchRowNumber": 1410,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "77": {
                "beforePatchRowNumber": 1411,
                "afterPatchRowNumber": 1422,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": 1412,
                "afterPatchRowNumber": 1423,
                "PatchRowcode": "     def post_update(self, item):"
            },
            "79": {
                "beforePatchRowNumber": 1413,
                "afterPatchRowNumber": 1424,
                "PatchRowcode": "         \"\"\""
            },
            "80": {
                "beforePatchRowNumber": 1414,
                "afterPatchRowNumber": 1425,
                "PatchRowcode": "         Override this, will be called after update"
            },
            "81": {
                "beforePatchRowNumber": 1415,
                "afterPatchRowNumber": 1426,
                "PatchRowcode": "         \"\"\""
            },
            "82": {
                "beforePatchRowNumber": 1416,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "83": {
                "beforePatchRowNumber": 1417,
                "afterPatchRowNumber": 1427,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 1418,
                "afterPatchRowNumber": 1428,
                "PatchRowcode": "     def pre_add(self, item):"
            },
            "85": {
                "beforePatchRowNumber": 1419,
                "afterPatchRowNumber": 1429,
                "PatchRowcode": "         \"\"\""
            },
            "86": {
                "beforePatchRowNumber": 1420,
                "afterPatchRowNumber": 1430,
                "PatchRowcode": "         Override this, will be called before add."
            },
            "87": {
                "beforePatchRowNumber": 1421,
                "afterPatchRowNumber": 1431,
                "PatchRowcode": "         If an exception is raised by this method,"
            },
            "88": {
                "beforePatchRowNumber": 1422,
                "afterPatchRowNumber": 1432,
                "PatchRowcode": "         the message is shown to the user and the add operation is aborted."
            },
            "89": {
                "beforePatchRowNumber": 1423,
                "afterPatchRowNumber": 1433,
                "PatchRowcode": "         \"\"\""
            },
            "90": {
                "beforePatchRowNumber": 1424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "91": {
                "beforePatchRowNumber": 1425,
                "afterPatchRowNumber": 1434,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 1426,
                "afterPatchRowNumber": 1435,
                "PatchRowcode": "     def post_add(self, item):"
            },
            "93": {
                "beforePatchRowNumber": 1427,
                "afterPatchRowNumber": 1436,
                "PatchRowcode": "         \"\"\""
            },
            "94": {
                "beforePatchRowNumber": 1428,
                "afterPatchRowNumber": 1437,
                "PatchRowcode": "         Override this, will be called after update"
            },
            "95": {
                "beforePatchRowNumber": 1429,
                "afterPatchRowNumber": 1438,
                "PatchRowcode": "         \"\"\""
            },
            "96": {
                "beforePatchRowNumber": 1430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "97": {
                "beforePatchRowNumber": 1431,
                "afterPatchRowNumber": 1439,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 1432,
                "afterPatchRowNumber": 1440,
                "PatchRowcode": "     def pre_delete(self, item):"
            },
            "99": {
                "beforePatchRowNumber": 1433,
                "afterPatchRowNumber": 1441,
                "PatchRowcode": "         \"\"\""
            },
            "100": {
                "beforePatchRowNumber": 1438,
                "afterPatchRowNumber": 1446,
                "PatchRowcode": "         implement more complex logic around deletes. For instance"
            },
            "101": {
                "beforePatchRowNumber": 1439,
                "afterPatchRowNumber": 1447,
                "PatchRowcode": "         allowing only the original creator of the object to delete it."
            },
            "102": {
                "beforePatchRowNumber": 1440,
                "afterPatchRowNumber": 1448,
                "PatchRowcode": "         \"\"\""
            },
            "103": {
                "beforePatchRowNumber": 1441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "104": {
                "beforePatchRowNumber": 1442,
                "afterPatchRowNumber": 1449,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 1443,
                "afterPatchRowNumber": 1450,
                "PatchRowcode": "     def post_delete(self, item):"
            },
            "106": {
                "beforePatchRowNumber": 1444,
                "afterPatchRowNumber": 1451,
                "PatchRowcode": "         \"\"\""
            },
            "107": {
                "beforePatchRowNumber": 1445,
                "afterPatchRowNumber": 1452,
                "PatchRowcode": "         Override this, will be called after delete"
            },
            "108": {
                "beforePatchRowNumber": 1446,
                "afterPatchRowNumber": 1453,
                "PatchRowcode": "         \"\"\""
            },
            "109": {
                "beforePatchRowNumber": 1447,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            }
        },
        "frontPatchFile": [
            "from datetime import date, datetime",
            "from inspect import isclass",
            "import json",
            "import logging",
            "import re",
            "from typing import List, Optional, TYPE_CHECKING",
            "",
            "from flask import (",
            "    abort,",
            "    Blueprint,",
            "    current_app,",
            "    flash,",
            "    render_template,",
            "    request,",
            "    session,",
            "    url_for,",
            ")",
            "",
            "from ._compat import as_unicode",
            "from .actions import ActionItem",
            "from .const import PERMISSION_PREFIX",
            "from .forms import GeneralModelConverter",
            "from .hooks import get_before_request_hooks, wrap_route_handler_with_hooks",
            "from .urltools import (",
            "    get_filter_args,",
            "    get_order_args,",
            "    get_page_args,",
            "    get_page_size_args,",
            "    Stack,",
            ")",
            "from .widgets import FormWidget, ListWidget, SearchWidget, ShowWidget",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder.base import AppBuilder",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def expose(url=\"/\", methods=(\"GET\",)):",
            "    \"\"\"",
            "    Use this decorator to expose views on your view classes.",
            "",
            "    :param url:",
            "        Relative URL for the view",
            "    :param methods:",
            "        Allowed HTTP methods. By default only GET is allowed.",
            "    \"\"\"",
            "",
            "    def wrap(f):",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []",
            "        f._urls.append((url, methods))",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "def expose_api(name=\"\", url=\"\", methods=(\"GET\",), description=\"\"):",
            "    def wrap(f):",
            "        api_name = name or f.__name__",
            "        api_url = url or \"/api/{0}\".format(name)",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []",
            "            f._extra = {}",
            "        f._urls.append((api_url, methods))",
            "        f._extra[api_name] = (api_url, f.__name__, description)",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "class AbstractViewApi:",
            "",
            "    appbuilder: \"AppBuilder\"",
            "    base_permissions: Optional[List[str]]",
            "    class_permission_name: str",
            "    endpoint: str",
            "    default_view: str",
            "",
            "    def create_blueprint(",
            "        self,",
            "        appbuilder: \"AppBuilder\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ):",
            "        ...",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        ...",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "        ...",
            "",
            "",
            "class BaseView(AbstractViewApi):",
            "    \"\"\"",
            "    All views inherit from this class.",
            "    it's constructor will register your exposed urls on flask as a Blueprint.",
            "",
            "    This class does not expose any urls, but provides a common base for all views.",
            "",
            "    Extend this class if you want to expose methods for your own templates",
            "    \"\"\"",
            "",
            "    appbuilder = None",
            "    blueprint = None",
            "    endpoint = None",
            "",
            "    route_base = None",
            "    \"\"\" Override this if you want to define your own relative url \"\"\"",
            "",
            "    template_folder = \"templates\"",
            "    \"\"\" The template folder relative location \"\"\"",
            "    static_folder = \"static\"",
            "    \"\"\"  The static folder relative location \"\"\"",
            "    base_permissions = None",
            "    \"\"\"",
            "        List with allowed base permission.",
            "        Use it like this if you want to restrict your view to readonly::",
            "",
            "            class MyView(ModelView):",
            "                base_permissions = ['can_list','can_show']",
            "    \"\"\"",
            "    class_permission_name = None",
            "    \"\"\"",
            "        Override class permission name default fallback to self.__class__.__name__",
            "    \"\"\"",
            "    previous_class_permission_name = None",
            "    \"\"\"",
            "        If set security cleanup will remove all permissions tuples",
            "        with this name",
            "    \"\"\"",
            "    method_permission_name = None",
            "    \"\"\"",
            "        Override method permission names, example::",
            "",
            "            method_permissions_name = {",
            "                'get_list': 'read',",
            "                'get': 'read',",
            "                'put': 'write',",
            "                'post': 'write',",
            "                'delete': 'write'",
            "            }",
            "    \"\"\"",
            "    previous_method_permission_name = None",
            "    \"\"\"",
            "        Use same structure as method_permission_name. If set security converge",
            "        will replace all method permissions by the new ones",
            "    \"\"\"",
            "    exclude_route_methods = set()",
            "    \"\"\"",
            "        Does not register routes for a set of builtin ModelView functions.",
            "        example::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAInterface(Contact)",
            "                exclude_route_methods = {\"delete\", \"edit\"}",
            "",
            "    \"\"\"",
            "    include_route_methods = None",
            "    \"\"\"",
            "        If defined will assume a white list setup, where all endpoints are excluded",
            "        except those define on this attribute",
            "        example::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAInterface(Contact)",
            "                include_route_methods = {\"list\"}",
            "",
            "",
            "        The previous example will exclude all endpoints except the `list` endpoint",
            "    \"\"\"",
            "    default_view = \"list\"",
            "    \"\"\" the default view for this BaseView, to be used with url_for (method name) \"\"\"",
            "    extra_args = None",
            "",
            "    \"\"\" dictionary for injecting extra arguments into template \"\"\"",
            "    _apis = None",
            "",
            "    def __init__(self):",
            "        \"\"\"",
            "        Initialization of base permissions",
            "        based on exposed methods and actions",
            "",
            "        Initialization of extra args",
            "        \"\"\"",
            "        # Init class permission override attrs",
            "        if not self.previous_class_permission_name and self.class_permission_name:",
            "            self.previous_class_permission_name = self.__class__.__name__",
            "        self.class_permission_name = (",
            "            self.class_permission_name or self.__class__.__name__",
            "        )",
            "",
            "        # Init previous permission override attrs",
            "        is_collect_previous = False",
            "        if not self.previous_method_permission_name and self.method_permission_name:",
            "            self.previous_method_permission_name = dict()",
            "            is_collect_previous = True",
            "        self.method_permission_name = self.method_permission_name or dict()",
            "",
            "        # Collect base_permissions and infer previous permissions",
            "        is_add_base_permissions = False",
            "        if self.base_permissions is None:",
            "            self.base_permissions = set()",
            "            is_add_base_permissions = True",
            "",
            "        for attr_name in dir(self):",
            "            # If include_route_methods is not None white list",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            # Don't create permission for excluded routes",
            "            if attr_name in self.exclude_route_methods:",
            "                continue",
            "            if hasattr(getattr(self, attr_name), \"_permission_name\"):",
            "                if is_collect_previous:",
            "                    self.previous_method_permission_name[attr_name] = getattr(",
            "                        getattr(self, attr_name), \"_permission_name\"",
            "                    )",
            "                _permission_name = self.get_method_permission(attr_name)",
            "                if is_add_base_permissions:",
            "                    self.base_permissions.add(PERMISSION_PREFIX + _permission_name)",
            "        self.base_permissions = list(self.base_permissions)",
            "        if not self.extra_args:",
            "            self.extra_args = dict()",
            "        self._apis = dict()",
            "        for attr_name in dir(self):",
            "            if hasattr(getattr(self, attr_name), \"_extra\"):",
            "                _extra = getattr(getattr(self, attr_name), \"_extra\")",
            "                for key in _extra:",
            "                    self._apis[key] = _extra[key]",
            "",
            "    def create_blueprint(self, appbuilder, endpoint=None, static_folder=None):",
            "        \"\"\"",
            "        Create Flask blueprint. You will generally not use it",
            "",
            "        :param appbuilder:",
            "           the AppBuilder object",
            "        :param endpoint:",
            "           endpoint override for this blueprint,",
            "           will assume class name if not provided",
            "        :param static_folder:",
            "           the relative override for static folder,",
            "           if omitted application will use the appbuilder static",
            "        \"\"\"",
            "        # Store appbuilder instance",
            "        self.appbuilder = appbuilder",
            "",
            "        # If endpoint name is not provided, get it from the class name",
            "        self.endpoint = endpoint or self.__class__.__name__",
            "",
            "        if self.route_base is None:",
            "            self.route_base = \"/\" + self.__class__.__name__.lower()",
            "",
            "        self.static_folder = static_folder",
            "        if not static_folder:",
            "            # Create blueprint and register rules",
            "            self.blueprint = Blueprint(",
            "                self.endpoint,",
            "                __name__,",
            "                url_prefix=self.route_base,",
            "                template_folder=self.template_folder,",
            "            )",
            "        else:",
            "            self.blueprint = Blueprint(",
            "                self.endpoint,",
            "                __name__,",
            "                url_prefix=self.route_base,",
            "                template_folder=self.template_folder,",
            "                static_folder=static_folder,",
            "            )",
            "        self._register_urls()",
            "        return self.blueprint",
            "",
            "    def _register_urls(self):",
            "        before_request_hooks = get_before_request_hooks(self)",
            "        for attr_name in dir(self):",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            if attr_name in self.exclude_route_methods:",
            "                log.info(",
            "                    f\"Not registering route for method \"",
            "                    f\"{self.__class__.__name__}.{attr_name}\"",
            "                )",
            "                continue",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    log.info(",
            "                        f\"Registering route {self.blueprint.url_prefix}{url} {methods}\"",
            "                    )",
            "                    route_handler = wrap_route_handler_with_hooks(",
            "                        attr_name, attr, before_request_hooks",
            "                    )",
            "                    self.blueprint.add_url_rule(",
            "                        url, attr_name, route_handler, methods=methods",
            "                    )",
            "",
            "    def render_template(self, template, **kwargs):",
            "        \"\"\"",
            "        Use this method on your own endpoints, will pass the extra_args",
            "        to the templates.",
            "",
            "        :param template: The template relative path",
            "        :param kwargs: arguments to be passed to the template",
            "        \"\"\"",
            "        kwargs[\"base_template\"] = self.appbuilder.base_template",
            "        kwargs[\"appbuilder\"] = self.appbuilder",
            "        return render_template(",
            "            template, **dict(list(kwargs.items()) + list(self.extra_args.items()))",
            "        )",
            "",
            "    def _prettify_name(self, name):",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'HelloWorld' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(r\"(?<=.)([A-Z])\", r\" \\1\", name)",
            "",
            "    def _prettify_column(self, name):",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'hello_world' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(\"[._]\", \" \", name).title()",
            "",
            "    def update_redirect(self):",
            "        \"\"\"",
            "        Call it on your own endpoint's to update the back history navigation.",
            "        If you bypass it, the next submit or back will go over it.",
            "        \"\"\"",
            "        page_history = Stack(session.get(\"page_history\", []))",
            "        page_history.push(request.url)",
            "        session[\"page_history\"] = page_history.to_json()",
            "",
            "    def get_redirect(self):",
            "        \"\"\"",
            "        Returns the previous url.",
            "        \"\"\"",
            "        index_url = self.appbuilder.get_url_for_index",
            "        page_history = Stack(session.get(\"page_history\", []))",
            "",
            "        if page_history.pop() is None:",
            "            return index_url",
            "        session[\"page_history\"] = page_history.to_json()",
            "        url = page_history.pop() or index_url",
            "        return url",
            "",
            "    @classmethod",
            "    def get_default_url(cls, **kwargs):",
            "        \"\"\"",
            "        Returns the url for this class default endpoint",
            "        \"\"\"",
            "        return url_for(cls.__name__ + \".\" + cls.default_view, **kwargs)",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "        pass",
            "",
            "    def get_method_permission(self, method_name: str) -> str:",
            "        \"\"\"",
            "        Returns the permission name for a method",
            "        \"\"\"",
            "        permission = self.method_permission_name.get(method_name)",
            "        if permission:",
            "            return permission",
            "        else:",
            "            return getattr(getattr(self, method_name), \"_permission_name\")",
            "",
            "",
            "class BaseFormView(BaseView):",
            "    \"\"\"",
            "    Base class FormView's",
            "    \"\"\"",
            "",
            "    form_template = \"appbuilder/general/model/edit.html\"",
            "",
            "    edit_widget = FormWidget",
            "    \"\"\" Form widget to override \"\"\"",
            "    form_title = \"\"",
            "    \"\"\" The form title to be displayed \"\"\"",
            "    form_columns = None",
            "    \"\"\" The form columns to include, if empty will include all\"\"\"",
            "    form = None",
            "    \"\"\" The WTF form to render \"\"\"",
            "    form_fieldsets = None",
            "    \"\"\" Form field sets \"\"\"",
            "    default_view = \"this_form_get\"",
            "    \"\"\" The form view default entry endpoint \"\"\"",
            "",
            "    def _init_vars(self):",
            "        self.form_columns = self.form_columns or []",
            "        self.form_fieldsets = self.form_fieldsets or []",
            "        list_cols = [field.name for field in self.form.refresh()]",
            "        if self.form_fieldsets:",
            "            self.form_columns = []",
            "            for fieldset_item in self.form_fieldsets:",
            "                self.form_columns = self.form_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.form_columns:",
            "                self.form_columns = list_cols",
            "",
            "    def form_get(self, form):",
            "        \"\"\"",
            "        Override this method to implement your form processing",
            "        \"\"\"",
            "        pass",
            "",
            "    def form_post(self, form):",
            "        \"\"\"",
            "        Override this method to implement your form processing",
            "",
            "        :param form: WTForm form",
            "",
            "        Return None or a flask response to render",
            "        a custom template or redirect the user",
            "        \"\"\"",
            "        pass",
            "",
            "    def _get_edit_widget(self, form=None, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"edit\"] = self.edit_widget(",
            "            route_base=self.route_base,",
            "            form=form,",
            "            include_cols=self.form_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.form_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "",
            "class BaseModelView(BaseView):",
            "    \"\"\"",
            "    The base class of ModelView and ChartView, all properties are inherited",
            "    Customize ModelView and ChartView overriding this properties",
            "",
            "    This class supports all the basics for query",
            "    \"\"\"",
            "",
            "    datamodel = None",
            "    \"\"\"",
            "        Your sqla model you must initialize it like::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "    \"\"\"",
            "",
            "    title = \"Title\"",
            "",
            "    search_columns = None",
            "    \"\"\"",
            "        List with allowed search columns, if not provided",
            "        all possible search columns will be used",
            "        If you want to limit the search (*filter*) columns possibilities,",
            "        define it with a list of column names from your model::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                search_columns = ['name','address']",
            "",
            "    \"\"\"",
            "    search_exclude_columns = None",
            "    \"\"\"",
            "        List with columns to exclude from search.",
            "        Search includes all possible columns by default",
            "    \"\"\"",
            "    search_form_extra_fields = None",
            "    \"\"\"",
            "        A dictionary containing column names and a WTForm",
            "        Form fields to be added to the search form, these fields do not",
            "        exist on the model itself ex::",
            "",
            "        search_form_extra_fields = {'some_col':BooleanField('Some Col', default=False)}",
            "",
            "    \"\"\"",
            "    search_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields on search form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                search_form_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "",
            "    label_columns = None",
            "    \"\"\"",
            "        Dictionary of labels for your columns,",
            "        override this if you want different pretify labels",
            "",
            "        example (will just override the label for name column)::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                label_columns = {'name':'My Name Label Override'}",
            "",
            "    \"\"\"",
            "    search_form = None",
            "    \"\"\" To implement your own add WTF form for Search \"\"\"",
            "    base_filters = None",
            "    \"\"\"",
            "        Filter the view use: [['column_name',BaseFilter,'value'],]",
            "",
            "        example::",
            "",
            "            def get_user():",
            "                return g.user",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                base_filters = [['created_by', FilterEqualFunction, get_user],",
            "                                ['name', FilterStartsWith, 'a']]",
            "",
            "    \"\"\"",
            "",
            "    base_order = None",
            "    \"\"\"",
            "        Use this property to set default ordering for lists ('col_name','asc|desc')::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                base_order = ('my_column_name','asc')",
            "",
            "    \"\"\"",
            "",
            "    search_widget = SearchWidget",
            "    \"\"\" Search widget you can override with your own \"\"\"",
            "",
            "    _base_filters = None",
            "    \"\"\" Internal base Filter from class Filters will always filter view \"\"\"",
            "    _filters = None",
            "    \"\"\" Filters object will calculate all possible filter types",
            "    based on search_columns \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"",
            "        Constructor",
            "        \"\"\"",
            "        datamodel = kwargs.get(\"datamodel\", None)",
            "        if datamodel:",
            "            self.datamodel = datamodel",
            "        self._init_properties()",
            "        self._init_forms()",
            "        self._init_titles()",
            "        super(BaseModelView, self).__init__(**kwargs)",
            "",
            "    def _gen_labels_columns(self, list_columns):",
            "        \"\"\"",
            "        Auto generates pretty label_columns from list of columns",
            "        \"\"\"",
            "        for col in list_columns:",
            "            if not self.label_columns.get(col):",
            "                self.label_columns[col] = self._prettify_column(col)",
            "",
            "    def _init_titles(self):",
            "        pass",
            "",
            "    def _init_properties(self):",
            "        self.label_columns = self.label_columns or {}",
            "        self.base_filters = self.base_filters or []",
            "        self.search_exclude_columns = self.search_exclude_columns or []",
            "        self.search_columns = self.search_columns or []",
            "",
            "        self._base_filters = self.datamodel.get_filters().add_filter_list(",
            "            self.base_filters",
            "        )",
            "        list_cols = self.datamodel.get_columns_list()",
            "        search_columns = self.datamodel.get_search_columns_list()",
            "        if not self.search_columns:",
            "            self.search_columns = [",
            "                x for x in search_columns if x not in self.search_exclude_columns",
            "            ]",
            "",
            "        self._gen_labels_columns(list_cols)",
            "        self._filters = self.datamodel.get_filters(self.search_columns)",
            "",
            "    def _init_forms(self):",
            "        conv = GeneralModelConverter(self.datamodel)",
            "        if not self.search_form:",
            "            self.search_form = conv.create_form(",
            "                self.label_columns,",
            "                self.search_columns,",
            "                extra_fields=self.search_form_extra_fields,",
            "                filter_rel_fields=self.search_form_query_rel_fields,",
            "            )",
            "",
            "    def _get_search_widget(self, form=None, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"search\"] = self.search_widget(",
            "            route_base=self.route_base,",
            "            form=form,",
            "            include_cols=self.search_columns,",
            "            exclude_cols=exclude_cols,",
            "            filters=self._filters,",
            "        )",
            "        return widgets",
            "",
            "    def _label_columns_json(self):",
            "        \"\"\"",
            "        Prepares dict with labels to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        for key, value in list(self.label_columns.items()):",
            "            ret[key] = as_unicode(value.encode(\"UTF-8\"))",
            "        return ret",
            "",
            "",
            "class BaseCRUDView(BaseModelView):",
            "    \"\"\"",
            "    The base class for ModelView, all properties are inherited",
            "    Customize ModelView overriding this properties",
            "    \"\"\"",
            "",
            "    related_views = None",
            "    \"\"\"",
            "        List with ModelView classes",
            "        Will be displayed related with this one using relationship sqlalchemy property::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(Group, db.session)",
            "                related_views = [MyOtherRelatedView]",
            "",
            "    \"\"\"",
            "    _related_views = None",
            "    \"\"\" internal list with ref to instantiated view classes \"\"\"",
            "    list_title = \"\"",
            "    \"\"\" List Title, if not configured the default is 'List ' with pretty model name \"\"\"",
            "    show_title = \"\"",
            "    \"\"\" Show Title , if not configured the default is 'Show ' with pretty model name \"\"\"",
            "    add_title = \"\"",
            "    \"\"\" Add Title , if not configured the default is 'Add ' with pretty model name \"\"\"",
            "    edit_title = \"\"",
            "    \"\"\" Edit Title , if not configured the default is 'Edit ' with pretty model name \"\"\"",
            "",
            "    list_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the list view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    show_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the show view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    add_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the add form view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    edit_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the edit form view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    show_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the show view.",
            "       By default all columns are included.",
            "    \"\"\"",
            "    add_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the add form.",
            "       By default all columns are included.",
            "    \"\"\"",
            "    edit_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the edit form.",
            "        By default all columns are included.",
            "    \"\"\"",
            "    order_columns = None",
            "    \"\"\" Allowed order columns \"\"\"",
            "    page_size = 25",
            "    \"\"\"",
            "        Use this property to change default page size",
            "    \"\"\"",
            "    show_fieldsets = None",
            "    \"\"\"",
            "        show fieldsets django style [(<'TITLE'|None>, {'fields':[<F1>,<F2>,...]}),....]",
            "",
            "        ::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(MyTable, db.session)",
            "",
            "                show_fieldsets = [",
            "                    ('Summary', {",
            "                        'fields': [",
            "                            'name',",
            "                            'address',",
            "                            'group'",
            "                            ]",
            "                        }",
            "                    ),",
            "                    ('Personal Info', {",
            "                        'fields': [",
            "                            'birthday',",
            "                            'personal_phone'",
            "                            ],",
            "                        'expanded':False",
            "                        }",
            "                    ),",
            "                ]",
            "",
            "    \"\"\"",
            "    add_fieldsets = None",
            "    \"\"\"",
            "        add fieldsets django style (look at show_fieldsets for an example)",
            "    \"\"\"",
            "    edit_fieldsets = None",
            "    \"\"\"",
            "        edit fieldsets django style (look at show_fieldsets for an example)",
            "    \"\"\"",
            "",
            "    description_columns = None",
            "    \"\"\"",
            "        Dictionary with column descriptions that will be shown on the forms::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(MyTable, db.session)",
            "",
            "                description_columns = {",
            "                    'name': 'your models name column',",
            "                    'address': 'the address column'",
            "                }",
            "    \"\"\"",
            "    validators_columns = None",
            "    \"\"\" Dictionary to add your own validators for forms \"\"\"",
            "    formatters_columns = None",
            "    \"\"\" Dictionary of formatter used to format the display of columns",
            "",
            "        formatters_columns = {'some_date_col': lambda x: x.isoformat() }",
            "    \"\"\"",
            "    add_form_extra_fields = None",
            "    \"\"\"",
            "        A dictionary containing column names and a WTForm",
            "        Form fields to be added to the Add form, these fields do not",
            "        exist on the model itself ex::",
            "",
            "        add_form_extra_fields = {'some_col':BooleanField('Some Col', default=False)}",
            "",
            "    \"\"\"",
            "    edit_form_extra_fields = None",
            "    \"\"\" Dictionary to add extra fields to the Edit form using this property \"\"\"",
            "",
            "    add_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields to add form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {",
            "            'relation col name':",
            "                [['Related model col', FilterClass, 'Filter Value'],...],...",
            "        }",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                add_form_query_rel_fields = {'group': [['name', FilterStartsWith, 'W']]}",
            "",
            "    \"\"\"",
            "    edit_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields to edit form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {",
            "            'relation col name':",
            "                [['Related model col', FilterClass, 'Filter Value'],...],...",
            "        }",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                edit_form_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "",
            "    add_form = None",
            "    \"\"\" To implement your own, assign WTF form for Add \"\"\"",
            "    edit_form = None",
            "    \"\"\" To implement your own, assign WTF form for Edit \"\"\"",
            "",
            "    list_template = \"appbuilder/general/model/list.html\"",
            "    \"\"\" Your own add jinja2 template for list \"\"\"",
            "    edit_template = \"appbuilder/general/model/edit.html\"",
            "    \"\"\" Your own add jinja2 template for edit \"\"\"",
            "    add_template = \"appbuilder/general/model/add.html\"",
            "    \"\"\" Your own add jinja2 template for add \"\"\"",
            "    show_template = \"appbuilder/general/model/show.html\"",
            "    \"\"\" Your own add jinja2 template for show \"\"\"",
            "",
            "    list_widget = ListWidget",
            "    \"\"\" List widget override \"\"\"",
            "    edit_widget = FormWidget",
            "    \"\"\" Edit widget override \"\"\"",
            "    add_widget = FormWidget",
            "    \"\"\" Add widget override \"\"\"",
            "    show_widget = ShowWidget",
            "    \"\"\" Show widget override \"\"\"",
            "",
            "    actions = None",
            "",
            "    def __init__(self, **kwargs):",
            "        super(BaseCRUDView, self).__init__(**kwargs)",
            "        # collect and setup actions",
            "        self.actions = {}",
            "        for attr_name in dir(self):",
            "            func = getattr(self, attr_name)",
            "            if hasattr(func, \"_action\"):",
            "                action = ActionItem(*func._action, func=func)",
            "                permission_name = action.name",
            "                # Infer previous if not declared",
            "                if self.method_permission_name.get(attr_name):",
            "                    if not self.previous_method_permission_name.get(attr_name):",
            "                        self.previous_method_permission_name[attr_name] = action.name",
            "                    permission_name = (",
            "                        PERMISSION_PREFIX + self.method_permission_name.get(attr_name)",
            "                    )",
            "                if permission_name not in self.base_permissions:",
            "                    self.base_permissions.append(permission_name)",
            "                self.actions[action.name] = action",
            "",
            "    def _init_forms(self):",
            "        \"\"\"",
            "        Init forms for Add and Edit",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_forms()",
            "        conv = GeneralModelConverter(self.datamodel)",
            "        if not self.add_form:",
            "            self.add_form = conv.create_form(",
            "                self.label_columns,",
            "                self.add_columns,",
            "                self.description_columns,",
            "                self.validators_columns,",
            "                self.add_form_extra_fields,",
            "                self.add_form_query_rel_fields,",
            "            )",
            "        if not self.edit_form:",
            "            self.edit_form = conv.create_form(",
            "                self.label_columns,",
            "                self.edit_columns,",
            "                self.description_columns,",
            "                self.validators_columns,",
            "                self.edit_form_extra_fields,",
            "                self.edit_form_query_rel_fields,",
            "            )",
            "",
            "    def _init_titles(self):",
            "        \"\"\"",
            "        Init Titles if not defined",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_titles()",
            "        class_name = self.datamodel.model_name",
            "        if not self.list_title:",
            "            self.list_title = \"List \" + self._prettify_name(class_name)",
            "        if not self.add_title:",
            "            self.add_title = \"Add \" + self._prettify_name(class_name)",
            "        if not self.edit_title:",
            "            self.edit_title = \"Edit \" + self._prettify_name(class_name)",
            "        if not self.show_title:",
            "            self.show_title = \"Show \" + self._prettify_name(class_name)",
            "        self.title = self.list_title",
            "",
            "    def _init_properties(self):",
            "        \"\"\"",
            "        Init Properties",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_properties()",
            "        # Reset init props",
            "        self.related_views = self.related_views or []",
            "        self._related_views = self._related_views or []",
            "        self.description_columns = self.description_columns or {}",
            "        self.validators_columns = self.validators_columns or {}",
            "        self.formatters_columns = self.formatters_columns or {}",
            "        self.add_form_extra_fields = self.add_form_extra_fields or {}",
            "        self.edit_form_extra_fields = self.edit_form_extra_fields or {}",
            "        self.show_exclude_columns = self.show_exclude_columns or []",
            "        self.add_exclude_columns = self.add_exclude_columns or []",
            "        self.edit_exclude_columns = self.edit_exclude_columns or []",
            "        # Generate base props",
            "        list_cols = self.datamodel.get_user_columns_list()",
            "        self.list_columns = self.list_columns or [list_cols[0]]",
            "        self._gen_labels_columns(self.list_columns)",
            "        self.order_columns = (",
            "            self.order_columns",
            "            or self.datamodel.get_order_columns_list(list_columns=self.list_columns)",
            "        )",
            "        if self.show_fieldsets:",
            "            self.show_columns = []",
            "            for fieldset_item in self.show_fieldsets:",
            "                self.show_columns = self.show_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.show_columns:",
            "                self.show_columns = [",
            "                    x for x in list_cols if x not in self.show_exclude_columns",
            "                ]",
            "        if self.add_fieldsets:",
            "            self.add_columns = []",
            "            for fieldset_item in self.add_fieldsets:",
            "                self.add_columns = self.add_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.add_columns:",
            "                self.add_columns = [",
            "                    x for x in list_cols if x not in self.add_exclude_columns",
            "                ]",
            "        if self.edit_fieldsets:",
            "            self.edit_columns = []",
            "            for fieldset_item in self.edit_fieldsets:",
            "                self.edit_columns = self.edit_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.edit_columns:",
            "                self.edit_columns = [",
            "                    x for x in list_cols if x not in self.edit_exclude_columns",
            "                ]",
            "",
            "    \"\"\"",
            "    -----------------------------------------------------",
            "            GET WIDGETS SECTION",
            "    -----------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _get_related_view_widget(",
            "        self,",
            "        item,",
            "        related_view,",
            "        order_column=\"\",",
            "        order_direction=\"\",",
            "        page=None,",
            "        page_size=None,",
            "    ):",
            "        fk = related_view.datamodel.get_related_fk(self.datamodel.obj)",
            "        filters = related_view.datamodel.get_filters()",
            "        # Check if it's a many to one model relation",
            "        if related_view.datamodel.is_relation_many_to_one(fk):",
            "            filters.add_filter_related_view(",
            "                fk,",
            "                self.datamodel.FilterRelationOneToManyEqual,",
            "                self.datamodel.get_pk_value(item),",
            "            )",
            "        # Check if it's a many to many model relation",
            "        elif related_view.datamodel.is_relation_many_to_many(fk):",
            "            filters.add_filter_related_view(",
            "                fk,",
            "                self.datamodel.FilterRelationManyToManyEqual,",
            "                self.datamodel.get_pk_value(item),",
            "            )",
            "        else:",
            "            if isclass(related_view) and issubclass(related_view, BaseView):",
            "                name = related_view.__name__",
            "            else:",
            "                name = related_view.__class__.__name__",
            "            log.error(\"Can't find relation on related view {0}\".format(name))",
            "            return None",
            "        return related_view._get_view_widget(",
            "            filters=filters,",
            "            order_column=order_column,",
            "            order_direction=order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "",
            "    def _get_related_views_widgets(",
            "        self, item, orders=None, pages=None, page_sizes=None, widgets=None, **args",
            "    ):",
            "        \"\"\"",
            "        :return:",
            "            Returns a dict with 'related_views' key with a list of",
            "            Model View widgets",
            "        \"\"\"",
            "        widgets = widgets or {}",
            "        widgets[\"related_views\"] = []",
            "        for view in self._related_views:",
            "            if orders.get(view.__class__.__name__):",
            "                order_column, order_direction = orders.get(view.__class__.__name__)",
            "            else:",
            "                order_column, order_direction = \"\", \"\"",
            "            widgets[\"related_views\"].append(",
            "                self._get_related_view_widget(",
            "                    item,",
            "                    view,",
            "                    order_column,",
            "                    order_direction,",
            "                    page=pages.get(view.__class__.__name__),",
            "                    page_size=page_sizes.get(view.__class__.__name__),",
            "                )",
            "            )",
            "        return widgets",
            "",
            "    def _get_view_widget(self, **kwargs):",
            "        \"\"\"",
            "        :return:",
            "            Returns a Model View widget",
            "        \"\"\"",
            "        return self._get_list_widget(**kwargs).get(\"list\")",
            "",
            "    def _get_list_widget(",
            "        self,",
            "        filters,",
            "        actions=None,",
            "        order_column=\"\",",
            "        order_direction=\"\",",
            "        page=None,",
            "        page_size=None,",
            "        widgets=None,",
            "        **args,",
            "    ):",
            "",
            "        \"\"\"get joined base filter and current active filter for query\"\"\"",
            "        widgets = widgets or {}",
            "        actions = actions or self.actions",
            "        page_size = page_size or self.page_size",
            "        if not order_column and self.base_order:",
            "            order_column, order_direction = self.base_order",
            "        joined_filters = filters.get_joined_filters(self._base_filters)",
            "        count, lst = self.datamodel.query(",
            "            joined_filters,",
            "            order_column,",
            "            order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "        pks = self.datamodel.get_keys(lst)",
            "",
            "        # serialize composite pks",
            "        pks = [self._serialize_pk_if_composite(pk) for pk in pks]",
            "",
            "        widgets[\"list\"] = self.list_widget(",
            "            label_columns=self.label_columns,",
            "            include_columns=self.list_columns,",
            "            value_columns=self.datamodel.get_values(lst, self.list_columns),",
            "            order_columns=self.order_columns,",
            "            formatters_columns=self.formatters_columns,",
            "            page=page,",
            "            page_size=page_size,",
            "            count=count,",
            "            pks=pks,",
            "            actions=actions,",
            "            filters=filters,",
            "            modelview_name=self.__class__.__name__,",
            "        )",
            "        return widgets",
            "",
            "    def _get_show_widget(",
            "        self, pk, item, widgets=None, actions=None, show_fieldsets=None",
            "    ):",
            "        widgets = widgets or {}",
            "        actions = actions or self.actions",
            "        show_fieldsets = show_fieldsets or self.show_fieldsets",
            "        widgets[\"show\"] = self.show_widget(",
            "            pk=pk,",
            "            label_columns=self.label_columns,",
            "            include_columns=self.show_columns,",
            "            value_columns=self.datamodel.get_values_item(item, self.show_columns),",
            "            formatters_columns=self.formatters_columns,",
            "            actions=actions,",
            "            fieldsets=show_fieldsets,",
            "            modelview_name=self.__class__.__name__,",
            "        )",
            "        return widgets",
            "",
            "    def _get_add_widget(self, form, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"add\"] = self.add_widget(",
            "            form=form,",
            "            include_cols=self.add_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.add_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "    def _get_edit_widget(self, form, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"edit\"] = self.edit_widget(",
            "            form=form,",
            "            include_cols=self.edit_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.edit_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return self.related_views",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Get the list of related ModelViews after they have been initialized",
            "        \"\"\"",
            "        return self._related_views",
            "",
            "    \"\"\"",
            "    -----------------------------------------------------",
            "            CRUD functions behaviour",
            "    -----------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _list(self):",
            "        \"\"\"",
            "        list function logic, override to implement different logic",
            "        returns list and search widget",
            "        \"\"\"",
            "        if get_order_args().get(self.__class__.__name__):",
            "            order_column, order_direction = get_order_args().get(",
            "                self.__class__.__name__",
            "            )",
            "        else:",
            "            order_column, order_direction = \"\", \"\"",
            "        page = get_page_args().get(self.__class__.__name__)",
            "        page_size = get_page_size_args().get(self.__class__.__name__)",
            "        get_filter_args(self._filters)",
            "        widgets = self._get_list_widget(",
            "            filters=self._filters,",
            "            order_column=order_column,",
            "            order_direction=order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "        form = self.search_form.refresh()",
            "        self.update_redirect()",
            "        return self._get_search_widget(form=form, widgets=widgets)",
            "",
            "    def _show(self, pk):",
            "        \"\"\"",
            "        show function logic, override to implement different logic",
            "        returns show and related list widget",
            "        \"\"\"",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        widgets = self._get_show_widget(pk, item)",
            "        self.update_redirect()",
            "        return self._get_related_views_widgets(",
            "            item, orders=orders, pages=pages, page_sizes=page_sizes, widgets=widgets",
            "        )",
            "",
            "    def _add(self):",
            "        \"\"\"",
            "        Add function logic, override to implement different logic",
            "        returns add widget or None",
            "        \"\"\"",
            "        is_valid_form = True",
            "        get_filter_args(self._filters, disallow_if_not_in_search=False)",
            "        exclude_cols = self._filters.get_relation_cols()",
            "        form = self.add_form.refresh()",
            "",
            "        if request.method == \"POST\":",
            "            self._fill_form_exclude_cols(exclude_cols, form)",
            "            if form.validate():",
            "                self.process_form(form, True)",
            "                item = self.datamodel.obj()",
            "",
            "                try:",
            "                    form.populate_obj(item)",
            "                    self.pre_add(item)",
            "                except Exception as e:",
            "                    flash(str(e), \"danger\")",
            "                else:",
            "                    if self.datamodel.add(item):",
            "                        self.post_add(item)",
            "                    flash(*self.datamodel.message)",
            "                finally:",
            "                    return None",
            "            else:",
            "                is_valid_form = False",
            "        if is_valid_form:",
            "            self.update_redirect()",
            "        return self._get_add_widget(form=form, exclude_cols=exclude_cols)",
            "",
            "    def _edit(self, pk):",
            "        \"\"\"",
            "        Edit function logic, override to implement different logic",
            "        returns Edit widget and related list or None",
            "        \"\"\"",
            "        is_valid_form = True",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "        get_filter_args(self._filters, disallow_if_not_in_search=False)",
            "        exclude_cols = self._filters.get_relation_cols()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        # convert pk to correct type, if pk is non string type.",
            "        pk = self.datamodel.get_pk_value(item)",
            "",
            "        if request.method == \"POST\":",
            "            form = self.edit_form.refresh(request.form)",
            "            # fill the form with the suppressed cols, generated from exclude_cols",
            "            self._fill_form_exclude_cols(exclude_cols, form)",
            "            # trick to pass unique validation",
            "            form._id = pk",
            "            if form.validate():",
            "                self.process_form(form, False)",
            "",
            "                try:",
            "                    form.populate_obj(item)",
            "                    self.pre_update(item)",
            "                except Exception as e:",
            "                    flash(str(e), \"danger\")",
            "                else:",
            "                    if self.datamodel.edit(item):",
            "                        self.post_update(item)",
            "                    flash(*self.datamodel.message)",
            "                finally:",
            "                    return None",
            "            else:",
            "                is_valid_form = False",
            "        else:",
            "            # Only force form refresh for select cascade events",
            "            form = self.edit_form.refresh(obj=item)",
            "            # Perform additional actions to pre-fill the edit form.",
            "            self.prefill_form(form, pk)",
            "",
            "        widgets = self._get_edit_widget(form=form, exclude_cols=exclude_cols)",
            "        widgets = self._get_related_views_widgets(",
            "            item,",
            "            filters={},",
            "            orders=orders,",
            "            pages=pages,",
            "            page_sizes=page_sizes,",
            "            widgets=widgets,",
            "        )",
            "        if is_valid_form:",
            "            self.update_redirect()",
            "        return widgets",
            "",
            "    def _delete(self, pk):",
            "        \"\"\"",
            "        Delete function logic, override to implement different logic",
            "        deletes the record with primary_key = pk",
            "",
            "        :param pk:",
            "            record primary key to delete",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        try:",
            "            self.pre_delete(item)",
            "        except Exception as e:",
            "            flash(str(e), \"danger\")",
            "        else:",
            "            if self.datamodel.delete(item):",
            "                self.post_delete(item)",
            "            flash(*self.datamodel.message)",
            "            self.update_redirect()",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                HELPER FUNCTIONS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _serialize_pk_if_composite(self, pk):",
            "        def date_serializer(obj):",
            "            if isinstance(obj, datetime):",
            "                return {\"_type\": \"datetime\", \"value\": obj.isoformat()}",
            "            elif isinstance(obj, date):",
            "                return {\"_type\": \"date\", \"value\": obj.isoformat()}",
            "",
            "        if self.datamodel.is_pk_composite():",
            "            try:",
            "                pk = json.dumps(pk, default=date_serializer)",
            "            except Exception:",
            "                pass",
            "        return pk",
            "",
            "    def _deserialize_pk_if_composite(self, pk):",
            "        def date_deserializer(obj):",
            "            if \"_type\" not in obj:",
            "                return obj",
            "",
            "            from dateutil import parser",
            "",
            "            if obj[\"_type\"] == \"datetime\":",
            "                return parser.parse(obj[\"value\"])",
            "            elif obj[\"_type\"] == \"date\":",
            "                return parser.parse(obj[\"value\"]).date()",
            "            return obj",
            "",
            "        if self.datamodel.is_pk_composite():",
            "            try:",
            "                pk = json.loads(pk, object_hook=date_deserializer)",
            "            except Exception:",
            "                pass",
            "        return pk",
            "",
            "    def _fill_form_exclude_cols(self, exclude_cols, form):",
            "        \"\"\"",
            "        fill the form with the suppressed cols, generated from exclude_cols",
            "        \"\"\"",
            "        for filter_key in exclude_cols:",
            "            filter_value = self._filters.get_filter_value(filter_key)",
            "            rel_obj = self.datamodel.get_related_obj(filter_key, filter_value)",
            "            if hasattr(form, filter_key):",
            "                field = getattr(form, filter_key)",
            "                field.data = rel_obj",
            "",
            "    def is_get_mutation_allowed(self) -> bool:",
            "        \"\"\"",
            "        Check is mutations on HTTP GET methods are allowed.",
            "        Always called on a request",
            "        \"\"\"",
            "        if current_app.config.get(\"FAB_ALLOW_GET_UNSAFE_MUTATIONS\", False):",
            "            return True",
            "        return not (",
            "            request.method == \"GET\" and self.appbuilder.app.extensions.get(\"csrf\")",
            "        )",
            "",
            "    def prefill_form(self, form, pk):",
            "        \"\"\"",
            "        Override this, will be called only if the current action is rendering",
            "        an edit form (a GET request), and is used to perform additional action to",
            "        prefill the form.",
            "",
            "        This is useful when you have added custom fields that depend on the",
            "        database contents. Fields that were added by name of a normal column",
            "        or relationship should work out of the box.",
            "",
            "        example::",
            "",
            "            def prefill_form(self, form, pk):",
            "                if form.email.data:",
            "                    form.email_confirmation.data = form.email.data",
            "        \"\"\"",
            "        pass",
            "",
            "    def process_form(self, form, is_created):",
            "        \"\"\"",
            "        Override this, will be called only if the current action is submitting",
            "        a create/edit form (a POST request), and is used to perform additional",
            "        action before the form is used to populate the item.",
            "",
            "        By default does nothing.",
            "",
            "        example::",
            "",
            "            def process_form(self, form, is_created):",
            "                if not form.owner:",
            "                    form.owner.data = 'n/a'",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_update(self, item):",
            "        \"\"\"",
            "        Override this, this method is called before the update takes place.",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the update operation is",
            "        aborted. Because of this behavior, it can be used as a way to",
            "        implement more complex logic around updates. For instance",
            "        allowing only the original creator of the object to update it.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_update(self, item):",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_add(self, item):",
            "        \"\"\"",
            "        Override this, will be called before add.",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the add operation is aborted.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_add(self, item):",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "        pass",
            "",
            "    def pre_delete(self, item):",
            "        \"\"\"",
            "        Override this, will be called before delete",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the delete operation is",
            "        aborted. Because of this behavior, it can be used as a way to",
            "        implement more complex logic around deletes. For instance",
            "        allowing only the original creator of the object to delete it.",
            "        \"\"\"",
            "        pass",
            "",
            "    def post_delete(self, item):",
            "        \"\"\"",
            "        Override this, will be called after delete",
            "        \"\"\"",
            "        pass"
        ],
        "afterPatchFile": [
            "from datetime import date, datetime",
            "from inspect import isclass",
            "import json",
            "import logging",
            "import re",
            "from typing import List, Optional, TYPE_CHECKING",
            "",
            "from flask import (",
            "    abort,",
            "    Blueprint,",
            "    current_app,",
            "    flash,",
            "    render_template,",
            "    request,",
            "    session,",
            "    url_for,",
            ")",
            "",
            "from ._compat import as_unicode",
            "from .actions import ActionItem",
            "from .const import PERMISSION_PREFIX",
            "from .forms import GeneralModelConverter",
            "from .hooks import get_before_request_hooks, wrap_route_handler_with_hooks",
            "from .urltools import (",
            "    get_filter_args,",
            "    get_order_args,",
            "    get_page_args,",
            "    get_page_size_args,",
            "    Stack,",
            ")",
            "from .widgets import FormWidget, ListWidget, SearchWidget, ShowWidget",
            "",
            "if TYPE_CHECKING:",
            "    from flask_appbuilder.base import AppBuilder",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def expose(url=\"/\", methods=(\"GET\",)):",
            "    \"\"\"",
            "    Use this decorator to expose views on your view classes.",
            "",
            "    :param url:",
            "        Relative URL for the view",
            "    :param methods:",
            "        Allowed HTTP methods. By default only GET is allowed.",
            "    \"\"\"",
            "",
            "    def wrap(f):",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []",
            "        f._urls.append((url, methods))",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "def expose_api(name=\"\", url=\"\", methods=(\"GET\",), description=\"\"):",
            "    def wrap(f):",
            "        api_name = name or f.__name__",
            "        api_url = url or \"/api/{0}\".format(name)",
            "        if not hasattr(f, \"_urls\"):",
            "            f._urls = []",
            "            f._extra = {}",
            "        f._urls.append((api_url, methods))",
            "        f._extra[api_name] = (api_url, f.__name__, description)",
            "        return f",
            "",
            "    return wrap",
            "",
            "",
            "class AbstractViewApi:",
            "",
            "    appbuilder: \"AppBuilder\"",
            "    base_permissions: Optional[List[str]]",
            "    class_permission_name: str",
            "    endpoint: str",
            "    default_view: str",
            "",
            "    def create_blueprint(",
            "        self,",
            "        appbuilder: \"AppBuilder\",",
            "        endpoint: Optional[str] = None,",
            "        static_folder: Optional[str] = None,",
            "    ):",
            "        ...",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        ...",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "        ...",
            "",
            "",
            "class BaseView(AbstractViewApi):",
            "    \"\"\"",
            "    All views inherit from this class.",
            "    it's constructor will register your exposed urls on flask as a Blueprint.",
            "",
            "    This class does not expose any urls, but provides a common base for all views.",
            "",
            "    Extend this class if you want to expose methods for your own templates",
            "    \"\"\"",
            "",
            "    appbuilder = None",
            "    blueprint = None",
            "    endpoint = None",
            "",
            "    route_base = None",
            "    \"\"\" Override this if you want to define your own relative url \"\"\"",
            "",
            "    template_folder = \"templates\"",
            "    \"\"\" The template folder relative location \"\"\"",
            "    static_folder = \"static\"",
            "    \"\"\"  The static folder relative location \"\"\"",
            "    base_permissions = None",
            "    \"\"\"",
            "        List with allowed base permission.",
            "        Use it like this if you want to restrict your view to readonly::",
            "",
            "            class MyView(ModelView):",
            "                base_permissions = ['can_list','can_show']",
            "    \"\"\"",
            "    class_permission_name = None",
            "    \"\"\"",
            "        Override class permission name default fallback to self.__class__.__name__",
            "    \"\"\"",
            "    previous_class_permission_name = None",
            "    \"\"\"",
            "        If set security cleanup will remove all permissions tuples",
            "        with this name",
            "    \"\"\"",
            "    method_permission_name = None",
            "    \"\"\"",
            "        Override method permission names, example::",
            "",
            "            method_permissions_name = {",
            "                'get_list': 'read',",
            "                'get': 'read',",
            "                'put': 'write',",
            "                'post': 'write',",
            "                'delete': 'write'",
            "            }",
            "    \"\"\"",
            "    previous_method_permission_name = None",
            "    \"\"\"",
            "        Use same structure as method_permission_name. If set security converge",
            "        will replace all method permissions by the new ones",
            "    \"\"\"",
            "    exclude_route_methods = set()",
            "    \"\"\"",
            "        Does not register routes for a set of builtin ModelView functions.",
            "        example::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAInterface(Contact)",
            "                exclude_route_methods = {\"delete\", \"edit\"}",
            "",
            "    \"\"\"",
            "    include_route_methods = None",
            "    \"\"\"",
            "        If defined will assume a white list setup, where all endpoints are excluded",
            "        except those define on this attribute",
            "        example::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAInterface(Contact)",
            "                include_route_methods = {\"list\"}",
            "",
            "",
            "        The previous example will exclude all endpoints except the `list` endpoint",
            "    \"\"\"",
            "    default_view = \"list\"",
            "    \"\"\" the default view for this BaseView, to be used with url_for (method name) \"\"\"",
            "    extra_args = None",
            "    \"\"\" dictionary for injecting extra arguments into template \"\"\"",
            "",
            "    limits = None",
            "    \"\"\"",
            "        List of limits for this view.",
            "",
            "        Use it like this if you want to restrict the rate of requests to a view:",
            "",
            "            class MyView(ModelView):",
            "                limits = [Limit(\"2 per 5 second\")]",
            "",
            "        or use the decorator @limit.",
            "    \"\"\"",
            "",
            "    _apis = None",
            "",
            "    def __init__(self):",
            "        \"\"\"",
            "        Initialization of base permissions",
            "        based on exposed methods and actions",
            "",
            "        Initialization of extra args",
            "        \"\"\"",
            "        # Init class permission override attrs",
            "        if not self.previous_class_permission_name and self.class_permission_name:",
            "            self.previous_class_permission_name = self.__class__.__name__",
            "        self.class_permission_name = (",
            "            self.class_permission_name or self.__class__.__name__",
            "        )",
            "",
            "        # Init previous permission override attrs",
            "        is_collect_previous = False",
            "        if not self.previous_method_permission_name and self.method_permission_name:",
            "            self.previous_method_permission_name = dict()",
            "            is_collect_previous = True",
            "        self.method_permission_name = self.method_permission_name or dict()",
            "",
            "        # Collect base_permissions and infer previous permissions",
            "        is_add_base_permissions = False",
            "        if self.base_permissions is None:",
            "            self.base_permissions = set()",
            "            is_add_base_permissions = True",
            "",
            "        if self.limits is None:",
            "            self.limits = []",
            "",
            "        for attr_name in dir(self):",
            "            # If include_route_methods is not None white list",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            # Don't create permission for excluded routes",
            "            if attr_name in self.exclude_route_methods:",
            "                continue",
            "            if hasattr(getattr(self, attr_name), \"_permission_name\"):",
            "                if is_collect_previous:",
            "                    self.previous_method_permission_name[attr_name] = getattr(",
            "                        getattr(self, attr_name), \"_permission_name\"",
            "                    )",
            "                _permission_name = self.get_method_permission(attr_name)",
            "                if is_add_base_permissions:",
            "                    self.base_permissions.add(PERMISSION_PREFIX + _permission_name)",
            "        self.base_permissions = list(self.base_permissions)",
            "        if not self.extra_args:",
            "            self.extra_args = dict()",
            "        self._apis = dict()",
            "        for attr_name in dir(self):",
            "            if hasattr(getattr(self, attr_name), \"_extra\"):",
            "                _extra = getattr(getattr(self, attr_name), \"_extra\")",
            "                for key in _extra:",
            "                    self._apis[key] = _extra[key]",
            "            if hasattr(getattr(self, attr_name), \"_limit\"):",
            "                self.limits.append(getattr(getattr(self, attr_name), \"_limit\"))",
            "",
            "    def create_blueprint(self, appbuilder, endpoint=None, static_folder=None):",
            "        \"\"\"",
            "        Create Flask blueprint. You will generally not use it",
            "",
            "        :param appbuilder:",
            "           the AppBuilder object",
            "        :param endpoint:",
            "           endpoint override for this blueprint,",
            "           will assume class name if not provided",
            "        :param static_folder:",
            "           the relative override for static folder,",
            "           if omitted application will use the appbuilder static",
            "        \"\"\"",
            "        # Store appbuilder instance",
            "        self.appbuilder = appbuilder",
            "",
            "        # If endpoint name is not provided, get it from the class name",
            "        self.endpoint = endpoint or self.__class__.__name__",
            "",
            "        if self.route_base is None:",
            "            self.route_base = \"/\" + self.__class__.__name__.lower()",
            "",
            "        self.static_folder = static_folder",
            "        if not static_folder:",
            "            # Create blueprint and register rules",
            "            self.blueprint = Blueprint(",
            "                self.endpoint,",
            "                __name__,",
            "                url_prefix=self.route_base,",
            "                template_folder=self.template_folder,",
            "            )",
            "        else:",
            "            self.blueprint = Blueprint(",
            "                self.endpoint,",
            "                __name__,",
            "                url_prefix=self.route_base,",
            "                template_folder=self.template_folder,",
            "                static_folder=static_folder,",
            "            )",
            "        self._register_urls()",
            "        return self.blueprint",
            "",
            "    def _register_urls(self):",
            "        before_request_hooks = get_before_request_hooks(self)",
            "        for attr_name in dir(self):",
            "            if (",
            "                self.include_route_methods is not None",
            "                and attr_name not in self.include_route_methods",
            "            ):",
            "                continue",
            "            if attr_name in self.exclude_route_methods:",
            "                log.info(",
            "                    f\"Not registering route for method \"",
            "                    f\"{self.__class__.__name__}.{attr_name}\"",
            "                )",
            "                continue",
            "            attr = getattr(self, attr_name)",
            "            if hasattr(attr, \"_urls\"):",
            "                for url, methods in attr._urls:",
            "                    log.info(",
            "                        f\"Registering route {self.blueprint.url_prefix}{url} {methods}\"",
            "                    )",
            "                    route_handler = wrap_route_handler_with_hooks(",
            "                        attr_name, attr, before_request_hooks",
            "                    )",
            "                    self.blueprint.add_url_rule(",
            "                        url, attr_name, route_handler, methods=methods",
            "                    )",
            "",
            "    def render_template(self, template, **kwargs):",
            "        \"\"\"",
            "        Use this method on your own endpoints, will pass the extra_args",
            "        to the templates.",
            "",
            "        :param template: The template relative path",
            "        :param kwargs: arguments to be passed to the template",
            "        \"\"\"",
            "        kwargs[\"base_template\"] = self.appbuilder.base_template",
            "        kwargs[\"appbuilder\"] = self.appbuilder",
            "        return render_template(",
            "            template, **dict(list(kwargs.items()) + list(self.extra_args.items()))",
            "        )",
            "",
            "    def _prettify_name(self, name):",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'HelloWorld' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(r\"(?<=.)([A-Z])\", r\" \\1\", name)",
            "",
            "    def _prettify_column(self, name):",
            "        \"\"\"",
            "        Prettify pythonic variable name.",
            "",
            "        For example, 'hello_world' will be converted to 'Hello World'",
            "",
            "        :param name:",
            "            Name to prettify.",
            "        \"\"\"",
            "        return re.sub(\"[._]\", \" \", name).title()",
            "",
            "    def update_redirect(self):",
            "        \"\"\"",
            "        Call it on your own endpoint's to update the back history navigation.",
            "        If you bypass it, the next submit or back will go over it.",
            "        \"\"\"",
            "        page_history = Stack(session.get(\"page_history\", []))",
            "        page_history.push(request.url)",
            "        session[\"page_history\"] = page_history.to_json()",
            "",
            "    def get_redirect(self):",
            "        \"\"\"",
            "        Returns the previous url.",
            "        \"\"\"",
            "        index_url = self.appbuilder.get_url_for_index",
            "        page_history = Stack(session.get(\"page_history\", []))",
            "",
            "        if page_history.pop() is None:",
            "            return index_url",
            "        session[\"page_history\"] = page_history.to_json()",
            "        url = page_history.pop() or index_url",
            "        return url",
            "",
            "    @classmethod",
            "    def get_default_url(cls, **kwargs):",
            "        \"\"\"",
            "        Returns the url for this class default endpoint",
            "        \"\"\"",
            "        return url_for(cls.__name__ + \".\" + cls.default_view, **kwargs)",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Sets initialized inner views",
            "        \"\"\"",
            "",
            "    def get_method_permission(self, method_name: str) -> str:",
            "        \"\"\"",
            "        Returns the permission name for a method",
            "        \"\"\"",
            "        permission = self.method_permission_name.get(method_name)",
            "        if permission:",
            "            return permission",
            "        else:",
            "            return getattr(getattr(self, method_name), \"_permission_name\")",
            "",
            "",
            "class BaseFormView(BaseView):",
            "    \"\"\"",
            "    Base class FormView's",
            "    \"\"\"",
            "",
            "    form_template = \"appbuilder/general/model/edit.html\"",
            "",
            "    edit_widget = FormWidget",
            "    \"\"\" Form widget to override \"\"\"",
            "    form_title = \"\"",
            "    \"\"\" The form title to be displayed \"\"\"",
            "    form_columns = None",
            "    \"\"\" The form columns to include, if empty will include all\"\"\"",
            "    form = None",
            "    \"\"\" The WTF form to render \"\"\"",
            "    form_fieldsets = None",
            "    \"\"\" Form field sets \"\"\"",
            "    default_view = \"this_form_get\"",
            "    \"\"\" The form view default entry endpoint \"\"\"",
            "",
            "    def _init_vars(self):",
            "        self.form_columns = self.form_columns or []",
            "        self.form_fieldsets = self.form_fieldsets or []",
            "        list_cols = [field.name for field in self.form.refresh()]",
            "        if self.form_fieldsets:",
            "            self.form_columns = []",
            "            for fieldset_item in self.form_fieldsets:",
            "                self.form_columns = self.form_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.form_columns:",
            "                self.form_columns = list_cols",
            "",
            "    def form_get(self, form):",
            "        \"\"\"",
            "        Override this method to implement your form processing",
            "        \"\"\"",
            "",
            "    def form_post(self, form):",
            "        \"\"\"",
            "        Override this method to implement your form processing",
            "",
            "        :param form: WTForm form",
            "",
            "        Return None or a flask response to render",
            "        a custom template or redirect the user",
            "        \"\"\"",
            "",
            "    def _get_edit_widget(self, form=None, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"edit\"] = self.edit_widget(",
            "            route_base=self.route_base,",
            "            form=form,",
            "            include_cols=self.form_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.form_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "",
            "class BaseModelView(BaseView):",
            "    \"\"\"",
            "    The base class of ModelView and ChartView, all properties are inherited",
            "    Customize ModelView and ChartView overriding this properties",
            "",
            "    This class supports all the basics for query",
            "    \"\"\"",
            "",
            "    datamodel = None",
            "    \"\"\"",
            "        Your sqla model you must initialize it like::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "    \"\"\"",
            "",
            "    title = \"Title\"",
            "",
            "    search_columns = None",
            "    \"\"\"",
            "        List with allowed search columns, if not provided",
            "        all possible search columns will be used",
            "        If you want to limit the search (*filter*) columns possibilities,",
            "        define it with a list of column names from your model::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                search_columns = ['name','address']",
            "",
            "    \"\"\"",
            "    search_exclude_columns = None",
            "    \"\"\"",
            "        List with columns to exclude from search.",
            "        Search includes all possible columns by default",
            "    \"\"\"",
            "    search_form_extra_fields = None",
            "    \"\"\"",
            "        A dictionary containing column names and a WTForm",
            "        Form fields to be added to the search form, these fields do not",
            "        exist on the model itself ex::",
            "",
            "        search_form_extra_fields = {'some_col':BooleanField('Some Col', default=False)}",
            "",
            "    \"\"\"",
            "    search_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields on search form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {'relation col name':[['Related model col',FilterClass,'Filter Value'],...],...}",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                search_form_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "",
            "    label_columns = None",
            "    \"\"\"",
            "        Dictionary of labels for your columns,",
            "        override this if you want different pretify labels",
            "",
            "        example (will just override the label for name column)::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                label_columns = {'name':'My Name Label Override'}",
            "",
            "    \"\"\"",
            "    search_form = None",
            "    \"\"\" To implement your own add WTF form for Search \"\"\"",
            "    base_filters = None",
            "    \"\"\"",
            "        Filter the view use: [['column_name',BaseFilter,'value'],]",
            "",
            "        example::",
            "",
            "            def get_user():",
            "                return g.user",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                base_filters = [['created_by', FilterEqualFunction, get_user],",
            "                                ['name', FilterStartsWith, 'a']]",
            "",
            "    \"\"\"",
            "",
            "    base_order = None",
            "    \"\"\"",
            "        Use this property to set default ordering for lists ('col_name','asc|desc')::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAInterface(MyTable)",
            "                base_order = ('my_column_name','asc')",
            "",
            "    \"\"\"",
            "",
            "    search_widget = SearchWidget",
            "    \"\"\" Search widget you can override with your own \"\"\"",
            "",
            "    _base_filters = None",
            "    \"\"\" Internal base Filter from class Filters will always filter view \"\"\"",
            "    _filters = None",
            "    \"\"\" Filters object will calculate all possible filter types",
            "    based on search_columns \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"",
            "        Constructor",
            "        \"\"\"",
            "        datamodel = kwargs.get(\"datamodel\", None)",
            "        if datamodel:",
            "            self.datamodel = datamodel",
            "        self._init_properties()",
            "        self._init_forms()",
            "        self._init_titles()",
            "        super(BaseModelView, self).__init__(**kwargs)",
            "",
            "    def _gen_labels_columns(self, list_columns):",
            "        \"\"\"",
            "        Auto generates pretty label_columns from list of columns",
            "        \"\"\"",
            "        for col in list_columns:",
            "            if not self.label_columns.get(col):",
            "                self.label_columns[col] = self._prettify_column(col)",
            "",
            "    def _init_titles(self):",
            "        pass",
            "",
            "    def _init_properties(self):",
            "        self.label_columns = self.label_columns or {}",
            "        self.base_filters = self.base_filters or []",
            "        self.search_exclude_columns = self.search_exclude_columns or []",
            "        self.search_columns = self.search_columns or []",
            "",
            "        self._base_filters = self.datamodel.get_filters().add_filter_list(",
            "            self.base_filters",
            "        )",
            "        list_cols = self.datamodel.get_columns_list()",
            "        search_columns = self.datamodel.get_search_columns_list()",
            "        if not self.search_columns:",
            "            self.search_columns = [",
            "                x for x in search_columns if x not in self.search_exclude_columns",
            "            ]",
            "",
            "        self._gen_labels_columns(list_cols)",
            "        self._filters = self.datamodel.get_filters(self.search_columns)",
            "",
            "    def _init_forms(self):",
            "        conv = GeneralModelConverter(self.datamodel)",
            "        if not self.search_form:",
            "            self.search_form = conv.create_form(",
            "                self.label_columns,",
            "                self.search_columns,",
            "                extra_fields=self.search_form_extra_fields,",
            "                filter_rel_fields=self.search_form_query_rel_fields,",
            "            )",
            "",
            "    def _get_search_widget(self, form=None, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"search\"] = self.search_widget(",
            "            route_base=self.route_base,",
            "            form=form,",
            "            include_cols=self.search_columns,",
            "            exclude_cols=exclude_cols,",
            "            filters=self._filters,",
            "        )",
            "        return widgets",
            "",
            "    def _label_columns_json(self):",
            "        \"\"\"",
            "        Prepares dict with labels to be JSON serializable",
            "        \"\"\"",
            "        ret = {}",
            "        for key, value in list(self.label_columns.items()):",
            "            ret[key] = as_unicode(value.encode(\"UTF-8\"))",
            "        return ret",
            "",
            "",
            "class BaseCRUDView(BaseModelView):",
            "    \"\"\"",
            "    The base class for ModelView, all properties are inherited",
            "    Customize ModelView overriding this properties",
            "    \"\"\"",
            "",
            "    related_views = None",
            "    \"\"\"",
            "        List with ModelView classes",
            "        Will be displayed related with this one using relationship sqlalchemy property::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(Group, db.session)",
            "                related_views = [MyOtherRelatedView]",
            "",
            "    \"\"\"",
            "    _related_views = None",
            "    \"\"\" internal list with ref to instantiated view classes \"\"\"",
            "    list_title = \"\"",
            "    \"\"\" List Title, if not configured the default is 'List ' with pretty model name \"\"\"",
            "    show_title = \"\"",
            "    \"\"\" Show Title , if not configured the default is 'Show ' with pretty model name \"\"\"",
            "    add_title = \"\"",
            "    \"\"\" Add Title , if not configured the default is 'Add ' with pretty model name \"\"\"",
            "    edit_title = \"\"",
            "    \"\"\" Edit Title , if not configured the default is 'Edit ' with pretty model name \"\"\"",
            "",
            "    list_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the list view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    show_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the show view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    add_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the add form view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    edit_columns = None",
            "    \"\"\"",
            "        A list of columns (or model's methods) to be displayed on the edit form view.",
            "        Use it to control the order of the display",
            "    \"\"\"",
            "    show_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the show view.",
            "       By default all columns are included.",
            "    \"\"\"",
            "    add_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the add form.",
            "       By default all columns are included.",
            "    \"\"\"",
            "    edit_exclude_columns = None",
            "    \"\"\"",
            "       A list of columns to exclude from the edit form.",
            "        By default all columns are included.",
            "    \"\"\"",
            "    order_columns = None",
            "    \"\"\" Allowed order columns \"\"\"",
            "    page_size = 25",
            "    \"\"\"",
            "        Use this property to change default page size",
            "    \"\"\"",
            "    show_fieldsets = None",
            "    \"\"\"",
            "        show fieldsets django style [(<'TITLE'|None>, {'fields':[<F1>,<F2>,...]}),....]",
            "",
            "        ::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(MyTable, db.session)",
            "",
            "                show_fieldsets = [",
            "                    ('Summary', {",
            "                        'fields': [",
            "                            'name',",
            "                            'address',",
            "                            'group'",
            "                            ]",
            "                        }",
            "                    ),",
            "                    ('Personal Info', {",
            "                        'fields': [",
            "                            'birthday',",
            "                            'personal_phone'",
            "                            ],",
            "                        'expanded':False",
            "                        }",
            "                    ),",
            "                ]",
            "",
            "    \"\"\"",
            "    add_fieldsets = None",
            "    \"\"\"",
            "        add fieldsets django style (look at show_fieldsets for an example)",
            "    \"\"\"",
            "    edit_fieldsets = None",
            "    \"\"\"",
            "        edit fieldsets django style (look at show_fieldsets for an example)",
            "    \"\"\"",
            "",
            "    description_columns = None",
            "    \"\"\"",
            "        Dictionary with column descriptions that will be shown on the forms::",
            "",
            "            class MyView(ModelView):",
            "                datamodel = SQLAModel(MyTable, db.session)",
            "",
            "                description_columns = {",
            "                    'name': 'your models name column',",
            "                    'address': 'the address column'",
            "                }",
            "    \"\"\"",
            "    validators_columns = None",
            "    \"\"\" Dictionary to add your own validators for forms \"\"\"",
            "    formatters_columns = None",
            "    \"\"\" Dictionary of formatter used to format the display of columns",
            "",
            "        formatters_columns = {'some_date_col': lambda x: x.isoformat() }",
            "    \"\"\"",
            "    add_form_extra_fields = None",
            "    \"\"\"",
            "        A dictionary containing column names and a WTForm",
            "        Form fields to be added to the Add form, these fields do not",
            "        exist on the model itself ex::",
            "",
            "        add_form_extra_fields = {'some_col':BooleanField('Some Col', default=False)}",
            "",
            "    \"\"\"",
            "    edit_form_extra_fields = None",
            "    \"\"\" Dictionary to add extra fields to the Edit form using this property \"\"\"",
            "",
            "    add_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields to add form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {",
            "            'relation col name':",
            "                [['Related model col', FilterClass, 'Filter Value'],...],...",
            "        }",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                add_form_query_rel_fields = {'group': [['name', FilterStartsWith, 'W']]}",
            "",
            "    \"\"\"",
            "    edit_form_query_rel_fields = None",
            "    \"\"\"",
            "        Add Customized query for related fields to edit form.",
            "        Assign a dictionary where the keys are the column names of",
            "        the related models to filter, the value for each key, is a list of lists with the",
            "        same format as base_filter",
            "        {",
            "            'relation col name':",
            "                [['Related model col', FilterClass, 'Filter Value'],...],...",
            "        }",
            "        Add a custom filter to form related fields::",
            "",
            "            class ContactModelView(ModelView):",
            "                datamodel = SQLAModel(Contact, db.session)",
            "                edit_form_query_rel_fields = {'group':[['name',FilterStartsWith,'W']]}",
            "",
            "    \"\"\"",
            "",
            "    add_form = None",
            "    \"\"\" To implement your own, assign WTF form for Add \"\"\"",
            "    edit_form = None",
            "    \"\"\" To implement your own, assign WTF form for Edit \"\"\"",
            "",
            "    list_template = \"appbuilder/general/model/list.html\"",
            "    \"\"\" Your own add jinja2 template for list \"\"\"",
            "    edit_template = \"appbuilder/general/model/edit.html\"",
            "    \"\"\" Your own add jinja2 template for edit \"\"\"",
            "    add_template = \"appbuilder/general/model/add.html\"",
            "    \"\"\" Your own add jinja2 template for add \"\"\"",
            "    show_template = \"appbuilder/general/model/show.html\"",
            "    \"\"\" Your own add jinja2 template for show \"\"\"",
            "",
            "    list_widget = ListWidget",
            "    \"\"\" List widget override \"\"\"",
            "    edit_widget = FormWidget",
            "    \"\"\" Edit widget override \"\"\"",
            "    add_widget = FormWidget",
            "    \"\"\" Add widget override \"\"\"",
            "    show_widget = ShowWidget",
            "    \"\"\" Show widget override \"\"\"",
            "",
            "    actions = None",
            "",
            "    def __init__(self, **kwargs):",
            "        super(BaseCRUDView, self).__init__(**kwargs)",
            "        # collect and setup actions",
            "        self.actions = {}",
            "        for attr_name in dir(self):",
            "            func = getattr(self, attr_name)",
            "            if hasattr(func, \"_action\"):",
            "                action = ActionItem(*func._action, func=func)",
            "                permission_name = action.name",
            "                # Infer previous if not declared",
            "                if self.method_permission_name.get(attr_name):",
            "                    if not self.previous_method_permission_name.get(attr_name):",
            "                        self.previous_method_permission_name[attr_name] = action.name",
            "                    permission_name = (",
            "                        PERMISSION_PREFIX + self.method_permission_name.get(attr_name)",
            "                    )",
            "                if permission_name not in self.base_permissions:",
            "                    self.base_permissions.append(permission_name)",
            "                self.actions[action.name] = action",
            "",
            "    def _init_forms(self):",
            "        \"\"\"",
            "        Init forms for Add and Edit",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_forms()",
            "        conv = GeneralModelConverter(self.datamodel)",
            "        if not self.add_form:",
            "            self.add_form = conv.create_form(",
            "                self.label_columns,",
            "                self.add_columns,",
            "                self.description_columns,",
            "                self.validators_columns,",
            "                self.add_form_extra_fields,",
            "                self.add_form_query_rel_fields,",
            "            )",
            "        if not self.edit_form:",
            "            self.edit_form = conv.create_form(",
            "                self.label_columns,",
            "                self.edit_columns,",
            "                self.description_columns,",
            "                self.validators_columns,",
            "                self.edit_form_extra_fields,",
            "                self.edit_form_query_rel_fields,",
            "            )",
            "",
            "    def _init_titles(self):",
            "        \"\"\"",
            "        Init Titles if not defined",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_titles()",
            "        class_name = self.datamodel.model_name",
            "        if not self.list_title:",
            "            self.list_title = \"List \" + self._prettify_name(class_name)",
            "        if not self.add_title:",
            "            self.add_title = \"Add \" + self._prettify_name(class_name)",
            "        if not self.edit_title:",
            "            self.edit_title = \"Edit \" + self._prettify_name(class_name)",
            "        if not self.show_title:",
            "            self.show_title = \"Show \" + self._prettify_name(class_name)",
            "        self.title = self.list_title",
            "",
            "    def _init_properties(self):",
            "        \"\"\"",
            "        Init Properties",
            "        \"\"\"",
            "        super(BaseCRUDView, self)._init_properties()",
            "        # Reset init props",
            "        self.related_views = self.related_views or []",
            "        self._related_views = self._related_views or []",
            "        self.description_columns = self.description_columns or {}",
            "        self.validators_columns = self.validators_columns or {}",
            "        self.formatters_columns = self.formatters_columns or {}",
            "        self.add_form_extra_fields = self.add_form_extra_fields or {}",
            "        self.edit_form_extra_fields = self.edit_form_extra_fields or {}",
            "        self.show_exclude_columns = self.show_exclude_columns or []",
            "        self.add_exclude_columns = self.add_exclude_columns or []",
            "        self.edit_exclude_columns = self.edit_exclude_columns or []",
            "        # Generate base props",
            "        list_cols = self.datamodel.get_user_columns_list()",
            "        self.list_columns = self.list_columns or [list_cols[0]]",
            "        self._gen_labels_columns(self.list_columns)",
            "        self.order_columns = (",
            "            self.order_columns",
            "            or self.datamodel.get_order_columns_list(list_columns=self.list_columns)",
            "        )",
            "        if self.show_fieldsets:",
            "            self.show_columns = []",
            "            for fieldset_item in self.show_fieldsets:",
            "                self.show_columns = self.show_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.show_columns:",
            "                self.show_columns = [",
            "                    x for x in list_cols if x not in self.show_exclude_columns",
            "                ]",
            "        if self.add_fieldsets:",
            "            self.add_columns = []",
            "            for fieldset_item in self.add_fieldsets:",
            "                self.add_columns = self.add_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.add_columns:",
            "                self.add_columns = [",
            "                    x for x in list_cols if x not in self.add_exclude_columns",
            "                ]",
            "        if self.edit_fieldsets:",
            "            self.edit_columns = []",
            "            for fieldset_item in self.edit_fieldsets:",
            "                self.edit_columns = self.edit_columns + list(",
            "                    fieldset_item[1].get(\"fields\")",
            "                )",
            "        else:",
            "            if not self.edit_columns:",
            "                self.edit_columns = [",
            "                    x for x in list_cols if x not in self.edit_exclude_columns",
            "                ]",
            "",
            "    \"\"\"",
            "    -----------------------------------------------------",
            "            GET WIDGETS SECTION",
            "    -----------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _get_related_view_widget(",
            "        self,",
            "        item,",
            "        related_view,",
            "        order_column=\"\",",
            "        order_direction=\"\",",
            "        page=None,",
            "        page_size=None,",
            "    ):",
            "        fk = related_view.datamodel.get_related_fk(self.datamodel.obj)",
            "        filters = related_view.datamodel.get_filters()",
            "        # Check if it's a many to one model relation",
            "        if related_view.datamodel.is_relation_many_to_one(fk):",
            "            filters.add_filter_related_view(",
            "                fk,",
            "                self.datamodel.FilterRelationOneToManyEqual,",
            "                self.datamodel.get_pk_value(item),",
            "            )",
            "        # Check if it's a many to many model relation",
            "        elif related_view.datamodel.is_relation_many_to_many(fk):",
            "            filters.add_filter_related_view(",
            "                fk,",
            "                self.datamodel.FilterRelationManyToManyEqual,",
            "                self.datamodel.get_pk_value(item),",
            "            )",
            "        else:",
            "            if isclass(related_view) and issubclass(related_view, BaseView):",
            "                name = related_view.__name__",
            "            else:",
            "                name = related_view.__class__.__name__",
            "            log.error(\"Can't find relation on related view {0}\".format(name))",
            "            return None",
            "        return related_view._get_view_widget(",
            "            filters=filters,",
            "            order_column=order_column,",
            "            order_direction=order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "",
            "    def _get_related_views_widgets(",
            "        self, item, orders=None, pages=None, page_sizes=None, widgets=None, **args",
            "    ):",
            "        \"\"\"",
            "        :return:",
            "            Returns a dict with 'related_views' key with a list of",
            "            Model View widgets",
            "        \"\"\"",
            "        widgets = widgets or {}",
            "        widgets[\"related_views\"] = []",
            "        for view in self._related_views:",
            "            if orders.get(view.__class__.__name__):",
            "                order_column, order_direction = orders.get(view.__class__.__name__)",
            "            else:",
            "                order_column, order_direction = \"\", \"\"",
            "            widgets[\"related_views\"].append(",
            "                self._get_related_view_widget(",
            "                    item,",
            "                    view,",
            "                    order_column,",
            "                    order_direction,",
            "                    page=pages.get(view.__class__.__name__),",
            "                    page_size=page_sizes.get(view.__class__.__name__),",
            "                )",
            "            )",
            "        return widgets",
            "",
            "    def _get_view_widget(self, **kwargs):",
            "        \"\"\"",
            "        :return:",
            "            Returns a Model View widget",
            "        \"\"\"",
            "        return self._get_list_widget(**kwargs).get(\"list\")",
            "",
            "    def _get_list_widget(",
            "        self,",
            "        filters,",
            "        actions=None,",
            "        order_column=\"\",",
            "        order_direction=\"\",",
            "        page=None,",
            "        page_size=None,",
            "        widgets=None,",
            "        **args,",
            "    ):",
            "",
            "        \"\"\"get joined base filter and current active filter for query\"\"\"",
            "        widgets = widgets or {}",
            "        actions = actions or self.actions",
            "        page_size = page_size or self.page_size",
            "        if not order_column and self.base_order:",
            "            order_column, order_direction = self.base_order",
            "        joined_filters = filters.get_joined_filters(self._base_filters)",
            "        count, lst = self.datamodel.query(",
            "            joined_filters,",
            "            order_column,",
            "            order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "        pks = self.datamodel.get_keys(lst)",
            "",
            "        # serialize composite pks",
            "        pks = [self._serialize_pk_if_composite(pk) for pk in pks]",
            "",
            "        widgets[\"list\"] = self.list_widget(",
            "            label_columns=self.label_columns,",
            "            include_columns=self.list_columns,",
            "            value_columns=self.datamodel.get_values(lst, self.list_columns),",
            "            order_columns=self.order_columns,",
            "            formatters_columns=self.formatters_columns,",
            "            page=page,",
            "            page_size=page_size,",
            "            count=count,",
            "            pks=pks,",
            "            actions=actions,",
            "            filters=filters,",
            "            modelview_name=self.__class__.__name__,",
            "        )",
            "        return widgets",
            "",
            "    def _get_show_widget(",
            "        self, pk, item, widgets=None, actions=None, show_fieldsets=None",
            "    ):",
            "        widgets = widgets or {}",
            "        actions = actions or self.actions",
            "        show_fieldsets = show_fieldsets or self.show_fieldsets",
            "        widgets[\"show\"] = self.show_widget(",
            "            pk=pk,",
            "            label_columns=self.label_columns,",
            "            include_columns=self.show_columns,",
            "            value_columns=self.datamodel.get_values_item(item, self.show_columns),",
            "            formatters_columns=self.formatters_columns,",
            "            actions=actions,",
            "            fieldsets=show_fieldsets,",
            "            modelview_name=self.__class__.__name__,",
            "        )",
            "        return widgets",
            "",
            "    def _get_add_widget(self, form, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"add\"] = self.add_widget(",
            "            form=form,",
            "            include_cols=self.add_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.add_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "    def _get_edit_widget(self, form, exclude_cols=None, widgets=None):",
            "        exclude_cols = exclude_cols or []",
            "        widgets = widgets or {}",
            "        widgets[\"edit\"] = self.edit_widget(",
            "            form=form,",
            "            include_cols=self.edit_columns,",
            "            exclude_cols=exclude_cols,",
            "            fieldsets=self.edit_fieldsets,",
            "        )",
            "        return widgets",
            "",
            "    def get_uninit_inner_views(self):",
            "        \"\"\"",
            "        Will return a list with views that need to be initialized.",
            "        Normally related_views from ModelView",
            "        \"\"\"",
            "        return self.related_views",
            "",
            "    def get_init_inner_views(self):",
            "        \"\"\"",
            "        Get the list of related ModelViews after they have been initialized",
            "        \"\"\"",
            "        return self._related_views",
            "",
            "    \"\"\"",
            "    -----------------------------------------------------",
            "            CRUD functions behaviour",
            "    -----------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _list(self):",
            "        \"\"\"",
            "        list function logic, override to implement different logic",
            "        returns list and search widget",
            "        \"\"\"",
            "        if get_order_args().get(self.__class__.__name__):",
            "            order_column, order_direction = get_order_args().get(",
            "                self.__class__.__name__",
            "            )",
            "        else:",
            "            order_column, order_direction = \"\", \"\"",
            "        page = get_page_args().get(self.__class__.__name__)",
            "        page_size = get_page_size_args().get(self.__class__.__name__)",
            "        get_filter_args(self._filters)",
            "        widgets = self._get_list_widget(",
            "            filters=self._filters,",
            "            order_column=order_column,",
            "            order_direction=order_direction,",
            "            page=page,",
            "            page_size=page_size,",
            "        )",
            "        form = self.search_form.refresh()",
            "        self.update_redirect()",
            "        return self._get_search_widget(form=form, widgets=widgets)",
            "",
            "    def _show(self, pk):",
            "        \"\"\"",
            "        show function logic, override to implement different logic",
            "        returns show and related list widget",
            "        \"\"\"",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        widgets = self._get_show_widget(pk, item)",
            "        self.update_redirect()",
            "        return self._get_related_views_widgets(",
            "            item, orders=orders, pages=pages, page_sizes=page_sizes, widgets=widgets",
            "        )",
            "",
            "    def _add(self):",
            "        \"\"\"",
            "        Add function logic, override to implement different logic",
            "        returns add widget or None",
            "        \"\"\"",
            "        is_valid_form = True",
            "        get_filter_args(self._filters, disallow_if_not_in_search=False)",
            "        exclude_cols = self._filters.get_relation_cols()",
            "        form = self.add_form.refresh()",
            "",
            "        if request.method == \"POST\":",
            "            self._fill_form_exclude_cols(exclude_cols, form)",
            "            if form.validate():",
            "                self.process_form(form, True)",
            "                item = self.datamodel.obj()",
            "",
            "                try:",
            "                    form.populate_obj(item)",
            "                    self.pre_add(item)",
            "                except Exception as e:",
            "                    flash(str(e), \"danger\")",
            "                else:",
            "                    if self.datamodel.add(item):",
            "                        self.post_add(item)",
            "                    flash(*self.datamodel.message)",
            "                finally:",
            "                    return None",
            "            else:",
            "                is_valid_form = False",
            "        if is_valid_form:",
            "            self.update_redirect()",
            "        return self._get_add_widget(form=form, exclude_cols=exclude_cols)",
            "",
            "    def _edit(self, pk):",
            "        \"\"\"",
            "        Edit function logic, override to implement different logic",
            "        returns Edit widget and related list or None",
            "        \"\"\"",
            "        is_valid_form = True",
            "        pages = get_page_args()",
            "        page_sizes = get_page_size_args()",
            "        orders = get_order_args()",
            "        get_filter_args(self._filters, disallow_if_not_in_search=False)",
            "        exclude_cols = self._filters.get_relation_cols()",
            "",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        # convert pk to correct type, if pk is non string type.",
            "        pk = self.datamodel.get_pk_value(item)",
            "",
            "        if request.method == \"POST\":",
            "            form = self.edit_form.refresh(request.form)",
            "            # fill the form with the suppressed cols, generated from exclude_cols",
            "            self._fill_form_exclude_cols(exclude_cols, form)",
            "            # trick to pass unique validation",
            "            form._id = pk",
            "            if form.validate():",
            "                self.process_form(form, False)",
            "",
            "                try:",
            "                    form.populate_obj(item)",
            "                    self.pre_update(item)",
            "                except Exception as e:",
            "                    flash(str(e), \"danger\")",
            "                else:",
            "                    if self.datamodel.edit(item):",
            "                        self.post_update(item)",
            "                    flash(*self.datamodel.message)",
            "                finally:",
            "                    return None",
            "            else:",
            "                is_valid_form = False",
            "        else:",
            "            # Only force form refresh for select cascade events",
            "            form = self.edit_form.refresh(obj=item)",
            "            # Perform additional actions to pre-fill the edit form.",
            "            self.prefill_form(form, pk)",
            "",
            "        widgets = self._get_edit_widget(form=form, exclude_cols=exclude_cols)",
            "        widgets = self._get_related_views_widgets(",
            "            item,",
            "            filters={},",
            "            orders=orders,",
            "            pages=pages,",
            "            page_sizes=page_sizes,",
            "            widgets=widgets,",
            "        )",
            "        if is_valid_form:",
            "            self.update_redirect()",
            "        return widgets",
            "",
            "    def _delete(self, pk):",
            "        \"\"\"",
            "        Delete function logic, override to implement different logic",
            "        deletes the record with primary_key = pk",
            "",
            "        :param pk:",
            "            record primary key to delete",
            "        \"\"\"",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        try:",
            "            self.pre_delete(item)",
            "        except Exception as e:",
            "            flash(str(e), \"danger\")",
            "        else:",
            "            if self.datamodel.delete(item):",
            "                self.post_delete(item)",
            "            flash(*self.datamodel.message)",
            "            self.update_redirect()",
            "",
            "    \"\"\"",
            "    ------------------------------------------------",
            "                HELPER FUNCTIONS",
            "    ------------------------------------------------",
            "    \"\"\"",
            "",
            "    def _serialize_pk_if_composite(self, pk):",
            "        def date_serializer(obj):",
            "            if isinstance(obj, datetime):",
            "                return {\"_type\": \"datetime\", \"value\": obj.isoformat()}",
            "            elif isinstance(obj, date):",
            "                return {\"_type\": \"date\", \"value\": obj.isoformat()}",
            "",
            "        if self.datamodel.is_pk_composite():",
            "            try:",
            "                pk = json.dumps(pk, default=date_serializer)",
            "            except Exception:",
            "                pass",
            "        return pk",
            "",
            "    def _deserialize_pk_if_composite(self, pk):",
            "        def date_deserializer(obj):",
            "            if \"_type\" not in obj:",
            "                return obj",
            "",
            "            from dateutil import parser",
            "",
            "            if obj[\"_type\"] == \"datetime\":",
            "                return parser.parse(obj[\"value\"])",
            "            elif obj[\"_type\"] == \"date\":",
            "                return parser.parse(obj[\"value\"]).date()",
            "            return obj",
            "",
            "        if self.datamodel.is_pk_composite():",
            "            try:",
            "                pk = json.loads(pk, object_hook=date_deserializer)",
            "            except Exception:",
            "                pass",
            "        return pk",
            "",
            "    def _fill_form_exclude_cols(self, exclude_cols, form):",
            "        \"\"\"",
            "        fill the form with the suppressed cols, generated from exclude_cols",
            "        \"\"\"",
            "        for filter_key in exclude_cols:",
            "            filter_value = self._filters.get_filter_value(filter_key)",
            "            rel_obj = self.datamodel.get_related_obj(filter_key, filter_value)",
            "            if hasattr(form, filter_key):",
            "                field = getattr(form, filter_key)",
            "                field.data = rel_obj",
            "",
            "    def is_get_mutation_allowed(self) -> bool:",
            "        \"\"\"",
            "        Check is mutations on HTTP GET methods are allowed.",
            "        Always called on a request",
            "        \"\"\"",
            "        if current_app.config.get(\"FAB_ALLOW_GET_UNSAFE_MUTATIONS\", False):",
            "            return True",
            "        return not (",
            "            request.method == \"GET\" and self.appbuilder.app.extensions.get(\"csrf\")",
            "        )",
            "",
            "    def prefill_form(self, form, pk):",
            "        \"\"\"",
            "        Override this, will be called only if the current action is rendering",
            "        an edit form (a GET request), and is used to perform additional action to",
            "        prefill the form.",
            "",
            "        This is useful when you have added custom fields that depend on the",
            "        database contents. Fields that were added by name of a normal column",
            "        or relationship should work out of the box.",
            "",
            "        example::",
            "",
            "            def prefill_form(self, form, pk):",
            "                if form.email.data:",
            "                    form.email_confirmation.data = form.email.data",
            "        \"\"\"",
            "",
            "    def process_form(self, form, is_created):",
            "        \"\"\"",
            "        Override this, will be called only if the current action is submitting",
            "        a create/edit form (a POST request), and is used to perform additional",
            "        action before the form is used to populate the item.",
            "",
            "        By default does nothing.",
            "",
            "        example::",
            "",
            "            def process_form(self, form, is_created):",
            "                if not form.owner:",
            "                    form.owner.data = 'n/a'",
            "        \"\"\"",
            "",
            "    def pre_update(self, item):",
            "        \"\"\"",
            "        Override this, this method is called before the update takes place.",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the update operation is",
            "        aborted. Because of this behavior, it can be used as a way to",
            "        implement more complex logic around updates. For instance",
            "        allowing only the original creator of the object to update it.",
            "        \"\"\"",
            "",
            "    def post_update(self, item):",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "",
            "    def pre_add(self, item):",
            "        \"\"\"",
            "        Override this, will be called before add.",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the add operation is aborted.",
            "        \"\"\"",
            "",
            "    def post_add(self, item):",
            "        \"\"\"",
            "        Override this, will be called after update",
            "        \"\"\"",
            "",
            "    def pre_delete(self, item):",
            "        \"\"\"",
            "        Override this, will be called before delete",
            "        If an exception is raised by this method,",
            "        the message is shown to the user and the delete operation is",
            "        aborted. Because of this behavior, it can be used as a way to",
            "        implement more complex logic around deletes. For instance",
            "        allowing only the original creator of the object to delete it.",
            "        \"\"\"",
            "",
            "    def post_delete(self, item):",
            "        \"\"\"",
            "        Override this, will be called after delete",
            "        \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "184": [
                "BaseView"
            ],
            "388": [
                "BaseView",
                "get_init_inner_views"
            ],
            "439": [
                "BaseFormView",
                "form_get"
            ],
            "450": [
                "BaseFormView",
                "form_post"
            ],
            "1383": [
                "BaseCRUDView",
                "prefill_form"
            ],
            "1399": [
                "BaseCRUDView",
                "process_form"
            ],
            "1410": [
                "BaseCRUDView",
                "pre_update"
            ],
            "1416": [
                "BaseCRUDView",
                "post_update"
            ],
            "1424": [
                "BaseCRUDView",
                "pre_add"
            ],
            "1430": [
                "BaseCRUDView",
                "post_add"
            ],
            "1441": [
                "BaseCRUDView",
                "pre_delete"
            ],
            "1447": [
                "BaseCRUDView",
                "post_delete"
            ]
        },
        "addLocation": []
    },
    "flask_appbuilder/security/decorators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import functools"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from typing import Callable, List, Optional, TypeVar, Union"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from flask import ("
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": "     current_app,"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     LOGMSG_ERR_SEC_ACCESS_DENIED,"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     PERMISSION_PREFIX,"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from flask_appbuilder.utils.limit import Limit"
            },
            "10": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from flask_jwt_extended import verify_jwt_in_request"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from flask_limiter.wrappers import RequestLimit"
            },
            "12": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flask_login import current_user"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from typing_extensions import ParamSpec"
            },
            "15": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " log = logging.getLogger(__name__)"
            },
            "17": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+R = TypeVar(\"R\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+P = ParamSpec(\"P\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " def response_unauthorized_mvc(status_code: int) -> Response:"
            },
            "23": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     response = make_response("
            },
            "24": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         return f"
            },
            "25": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     return wraps"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+def limit("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    limit_value: Union[str, Callable[[], str]],"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    key_func: Optional[Callable[[], str]] = None,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    per_method: bool = False,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    methods: Optional[List[str]] = None,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    error_message: Optional[str] = None,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+    exempt_when: Optional[Callable[[], bool]] = None,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+    override_defaults: bool = True,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    deduct_when: Optional[Callable[[Response], bool]] = None,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+    on_breach: Optional[Callable[[RequestLimit], Optional[Response]]] = None,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    cost: Union[int, Callable[[], int]] = 1,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+    \"\"\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    Decorator to be used for rate limiting individual routes or blueprints."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    :param limit_value: rate limit string or a callable that returns a"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+     string. :ref:`ratelimit-string` for more details."
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    :param key_func: function/lambda to extract the unique"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+     identifier for the rate limit. defaults to remote address of the"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+     request."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+    :param per_method: whether the limit is sub categorized into the"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+     http method of the request."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    :param methods: if specified, only the methods in this list will"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+     be rate limited (default: ``None``)."
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    :param error_message: string (or callable that returns one) to override"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+     the error message used in the response."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    :param exempt_when: function/lambda used to decide if the rate"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+     limit should skipped."
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    :param override_defaults:  whether the decorated limit overrides"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+     the default limits (Default: ``True``)."
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+     .. note:: When used with a :class:`~BaseView` the meaning"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        of the parameter extends to any parents the blueprint instance is"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        registered under. For more details see :ref:`recipes:nested blueprints`"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+    :param deduct_when: a function that receives the current"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+     :class:`flask.Response` object and returns True/False to decide if a"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+     deduction should be done from the rate limit"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    :param on_breach: a function that will be called when this limit"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+     is breached. If the function returns an instance of :class:`flask.Response`"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+     that will be the response embedded into the :exc:`RateLimitExceeded` exception"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+     raised."
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    :param cost: The cost of a hit or a function that"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+     takes no parameters and returns the cost as an integer (Default: ``1``)."
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+    \"\"\""
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    def wraps(f: Callable[P, R]) -> Callable[P, R]:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        _limit = Limit("
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            limit_value=limit_value,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+            key_func=key_func,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            per_method=per_method,"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            methods=methods,"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            error_message=error_message,"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+            exempt_when=exempt_when,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+            override_defaults=override_defaults,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+            deduct_when=deduct_when,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+            on_breach=on_breach,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+            cost=cost,"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+        )"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+        f._limit = _limit"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        return f"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+    return wraps"
            }
        },
        "frontPatchFile": [
            "import functools",
            "import logging",
            "",
            "from flask import (",
            "    current_app,",
            "    flash,",
            "    jsonify,",
            "    make_response,",
            "    redirect,",
            "    request,",
            "    Response,",
            "    url_for,",
            ")",
            "from flask_appbuilder._compat import as_unicode",
            "from flask_appbuilder.const import (",
            "    FLAMSG_ERR_SEC_ACCESS_DENIED,",
            "    LOGMSG_ERR_SEC_ACCESS_DENIED,",
            "    PERMISSION_PREFIX,",
            ")",
            "from flask_jwt_extended import verify_jwt_in_request",
            "from flask_login import current_user",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def response_unauthorized_mvc(status_code: int) -> Response:",
            "    response = make_response(",
            "        jsonify({\"message\": str(FLAMSG_ERR_SEC_ACCESS_DENIED), \"severity\": \"danger\"}),",
            "        status_code,",
            "    )",
            "    response.headers[\"Content-Type\"] = \"application/json\"",
            "    return response",
            "",
            "",
            "def protect(allow_browser_login=False):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions",
            "    to your API methods (BaseApi and child classes).",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    allow_browser_login will accept signed cookies obtained from the normal MVC app::",
            "",
            "        class MyApi(BaseApi):",
            "            @expose('/dosonmething', methods=['GET'])",
            "            @protect(allow_browser_login=True)",
            "            @safe",
            "            def do_something(self):",
            "                ....",
            "",
            "            @expose('/dosonmethingelse', methods=['GET'])",
            "            @protect()",
            "            @safe",
            "            def do_something_else(self):",
            "                ....",
            "",
            "    By default the permission's name is the methods name.",
            "    \"\"\"",
            "",
            "    def _protect(f):",
            "        if hasattr(f, \"_permission_name\"):",
            "            permission_str = f._permission_name",
            "        else:",
            "            permission_str = f.__name__",
            "",
            "        def wraps(self, *args, **kwargs):",
            "            # Apply method permission name override if exists",
            "            permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "            if self.method_permission_name:",
            "                _permission_name = self.method_permission_name.get(f.__name__)",
            "                if _permission_name:",
            "                    permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "            class_permission_name = self.class_permission_name",
            "            # Check if permission is allowed on the class",
            "            if permission_str not in self.base_permissions:",
            "                return self.response_403()",
            "            # Check if the resource is public",
            "            if current_app.appbuilder.sm.is_item_public(",
            "                permission_str, class_permission_name",
            "            ):",
            "                return f(self, *args, **kwargs)",
            "            # if no browser login then verify JWT",
            "            if not (self.allow_browser_login or allow_browser_login):",
            "                verify_jwt_in_request()",
            "            # Verify resource access",
            "            if current_app.appbuilder.sm.has_access(",
            "                permission_str, class_permission_name",
            "            ):",
            "                return f(self, *args, **kwargs)",
            "            # If browser login?",
            "            elif self.allow_browser_login or allow_browser_login:",
            "                # no session cookie (but we allow it), then try JWT",
            "                if not current_user.is_authenticated:",
            "                    verify_jwt_in_request()",
            "                if current_app.appbuilder.sm.has_access(",
            "                    permission_str, class_permission_name",
            "                ):",
            "                    return f(self, *args, **kwargs)",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, class_permission_name",
            "                )",
            "            )",
            "            return self.response_403()",
            "",
            "        f._permission_name = permission_str",
            "        return functools.update_wrapper(wraps, f)",
            "",
            "    return _protect",
            "",
            "",
            "def has_access(f):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions to your methods.",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    By default the permission's name is the methods name.",
            "    \"\"\"",
            "    if hasattr(f, \"_permission_name\"):",
            "        permission_str = f._permission_name",
            "    else:",
            "        permission_str = f.__name__",
            "",
            "    def wraps(self, *args, **kwargs):",
            "        permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "        if self.method_permission_name:",
            "            _permission_name = self.method_permission_name.get(f.__name__)",
            "            if _permission_name:",
            "                permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "        if permission_str in self.base_permissions and self.appbuilder.sm.has_access(",
            "            permission_str, self.class_permission_name",
            "        ):",
            "            return f(self, *args, **kwargs)",
            "        else:",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, self.__class__.__name__",
            "                )",
            "            )",
            "            flash(as_unicode(FLAMSG_ERR_SEC_ACCESS_DENIED), \"danger\")",
            "        return redirect(",
            "            url_for(",
            "                self.appbuilder.sm.auth_view.__class__.__name__ + \".login\",",
            "                next=request.url,",
            "            )",
            "        )",
            "",
            "    f._permission_name = permission_str",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def has_access_api(f):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions to your API methods.",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    By default the permission's name is the methods name.",
            "",
            "    this will return a message and HTTP 403 is case of unauthorized access.",
            "    \"\"\"",
            "    if hasattr(f, \"_permission_name\"):",
            "        permission_str = f._permission_name",
            "    else:",
            "        permission_str = f.__name__",
            "",
            "    def wraps(self, *args, **kwargs):",
            "        permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "        if self.method_permission_name:",
            "            _permission_name = self.method_permission_name.get(f.__name__)",
            "            if _permission_name:",
            "                permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "        if permission_str in self.base_permissions and self.appbuilder.sm.has_access(",
            "            permission_str, self.class_permission_name",
            "        ):",
            "            return f(self, *args, **kwargs)",
            "        else:",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, self.__class__.__name__",
            "                )",
            "            )",
            "            if not current_user.is_authenticated:",
            "                return response_unauthorized_mvc(401)",
            "            return response_unauthorized_mvc(403)",
            "",
            "    f._permission_name = permission_str",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def permission_name(name):",
            "    \"\"\"",
            "    Use this decorator to override the name of the permission.",
            "    has_access will use the methods name has the permission name",
            "    if you want to override this add this decorator to your methods.",
            "    This is useful if you want to aggregate methods to permissions",
            "",
            "    It will add '_permission_name' attribute to your method",
            "    that will be inspected by BaseView to collect your view's",
            "    permissions.",
            "",
            "    Note that you should use @has_access to execute after @permission_name",
            "    like on the following example.",
            "",
            "    Use it like this to aggregate permissions for your methods::",
            "",
            "        class MyModelView(ModelView):",
            "            datamodel = SQLAInterface(MyModel)",
            "",
            "            @has_access",
            "            @permission_name('GeneralXPTO_Permission')",
            "            @expose(url='/xpto')",
            "            def xpto(self):",
            "                return \"Your on xpto\"",
            "",
            "            @has_access",
            "            @permission_name('GeneralXPTO_Permission')",
            "            @expose(url='/xpto2')",
            "            def xpto2(self):",
            "                return \"Your on xpto2\"",
            "",
            "",
            "    :param name:",
            "        The name of the permission to override",
            "    \"\"\"",
            "",
            "    def wraps(f):",
            "        f._permission_name = name",
            "        return f",
            "",
            "    return wraps"
        ],
        "afterPatchFile": [
            "import functools",
            "import logging",
            "from typing import Callable, List, Optional, TypeVar, Union",
            "",
            "from flask import (",
            "    current_app,",
            "    flash,",
            "    jsonify,",
            "    make_response,",
            "    redirect,",
            "    request,",
            "    Response,",
            "    url_for,",
            ")",
            "from flask_appbuilder._compat import as_unicode",
            "from flask_appbuilder.const import (",
            "    FLAMSG_ERR_SEC_ACCESS_DENIED,",
            "    LOGMSG_ERR_SEC_ACCESS_DENIED,",
            "    PERMISSION_PREFIX,",
            ")",
            "from flask_appbuilder.utils.limit import Limit",
            "from flask_jwt_extended import verify_jwt_in_request",
            "from flask_limiter.wrappers import RequestLimit",
            "from flask_login import current_user",
            "from typing_extensions import ParamSpec",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "R = TypeVar(\"R\")",
            "P = ParamSpec(\"P\")",
            "",
            "",
            "def response_unauthorized_mvc(status_code: int) -> Response:",
            "    response = make_response(",
            "        jsonify({\"message\": str(FLAMSG_ERR_SEC_ACCESS_DENIED), \"severity\": \"danger\"}),",
            "        status_code,",
            "    )",
            "    response.headers[\"Content-Type\"] = \"application/json\"",
            "    return response",
            "",
            "",
            "def protect(allow_browser_login=False):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions",
            "    to your API methods (BaseApi and child classes).",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    allow_browser_login will accept signed cookies obtained from the normal MVC app::",
            "",
            "        class MyApi(BaseApi):",
            "            @expose('/dosonmething', methods=['GET'])",
            "            @protect(allow_browser_login=True)",
            "            @safe",
            "            def do_something(self):",
            "                ....",
            "",
            "            @expose('/dosonmethingelse', methods=['GET'])",
            "            @protect()",
            "            @safe",
            "            def do_something_else(self):",
            "                ....",
            "",
            "    By default the permission's name is the methods name.",
            "    \"\"\"",
            "",
            "    def _protect(f):",
            "        if hasattr(f, \"_permission_name\"):",
            "            permission_str = f._permission_name",
            "        else:",
            "            permission_str = f.__name__",
            "",
            "        def wraps(self, *args, **kwargs):",
            "            # Apply method permission name override if exists",
            "            permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "            if self.method_permission_name:",
            "                _permission_name = self.method_permission_name.get(f.__name__)",
            "                if _permission_name:",
            "                    permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "            class_permission_name = self.class_permission_name",
            "            # Check if permission is allowed on the class",
            "            if permission_str not in self.base_permissions:",
            "                return self.response_403()",
            "            # Check if the resource is public",
            "            if current_app.appbuilder.sm.is_item_public(",
            "                permission_str, class_permission_name",
            "            ):",
            "                return f(self, *args, **kwargs)",
            "            # if no browser login then verify JWT",
            "            if not (self.allow_browser_login or allow_browser_login):",
            "                verify_jwt_in_request()",
            "            # Verify resource access",
            "            if current_app.appbuilder.sm.has_access(",
            "                permission_str, class_permission_name",
            "            ):",
            "                return f(self, *args, **kwargs)",
            "            # If browser login?",
            "            elif self.allow_browser_login or allow_browser_login:",
            "                # no session cookie (but we allow it), then try JWT",
            "                if not current_user.is_authenticated:",
            "                    verify_jwt_in_request()",
            "                if current_app.appbuilder.sm.has_access(",
            "                    permission_str, class_permission_name",
            "                ):",
            "                    return f(self, *args, **kwargs)",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, class_permission_name",
            "                )",
            "            )",
            "            return self.response_403()",
            "",
            "        f._permission_name = permission_str",
            "        return functools.update_wrapper(wraps, f)",
            "",
            "    return _protect",
            "",
            "",
            "def has_access(f):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions to your methods.",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    By default the permission's name is the methods name.",
            "    \"\"\"",
            "    if hasattr(f, \"_permission_name\"):",
            "        permission_str = f._permission_name",
            "    else:",
            "        permission_str = f.__name__",
            "",
            "    def wraps(self, *args, **kwargs):",
            "        permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "        if self.method_permission_name:",
            "            _permission_name = self.method_permission_name.get(f.__name__)",
            "            if _permission_name:",
            "                permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "        if permission_str in self.base_permissions and self.appbuilder.sm.has_access(",
            "            permission_str, self.class_permission_name",
            "        ):",
            "            return f(self, *args, **kwargs)",
            "        else:",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, self.__class__.__name__",
            "                )",
            "            )",
            "            flash(as_unicode(FLAMSG_ERR_SEC_ACCESS_DENIED), \"danger\")",
            "        return redirect(",
            "            url_for(",
            "                self.appbuilder.sm.auth_view.__class__.__name__ + \".login\",",
            "                next=request.url,",
            "            )",
            "        )",
            "",
            "    f._permission_name = permission_str",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def has_access_api(f):",
            "    \"\"\"",
            "    Use this decorator to enable granular security permissions to your API methods.",
            "    Permissions will be associated to a role, and roles are associated to users.",
            "",
            "    By default the permission's name is the methods name.",
            "",
            "    this will return a message and HTTP 403 is case of unauthorized access.",
            "    \"\"\"",
            "    if hasattr(f, \"_permission_name\"):",
            "        permission_str = f._permission_name",
            "    else:",
            "        permission_str = f.__name__",
            "",
            "    def wraps(self, *args, **kwargs):",
            "        permission_str = f\"{PERMISSION_PREFIX}{f._permission_name}\"",
            "        if self.method_permission_name:",
            "            _permission_name = self.method_permission_name.get(f.__name__)",
            "            if _permission_name:",
            "                permission_str = f\"{PERMISSION_PREFIX}{_permission_name}\"",
            "        if permission_str in self.base_permissions and self.appbuilder.sm.has_access(",
            "            permission_str, self.class_permission_name",
            "        ):",
            "            return f(self, *args, **kwargs)",
            "        else:",
            "            log.warning(",
            "                LOGMSG_ERR_SEC_ACCESS_DENIED.format(",
            "                    permission_str, self.__class__.__name__",
            "                )",
            "            )",
            "            if not current_user.is_authenticated:",
            "                return response_unauthorized_mvc(401)",
            "            return response_unauthorized_mvc(403)",
            "",
            "    f._permission_name = permission_str",
            "    return functools.update_wrapper(wraps, f)",
            "",
            "",
            "def permission_name(name):",
            "    \"\"\"",
            "    Use this decorator to override the name of the permission.",
            "    has_access will use the methods name has the permission name",
            "    if you want to override this add this decorator to your methods.",
            "    This is useful if you want to aggregate methods to permissions",
            "",
            "    It will add '_permission_name' attribute to your method",
            "    that will be inspected by BaseView to collect your view's",
            "    permissions.",
            "",
            "    Note that you should use @has_access to execute after @permission_name",
            "    like on the following example.",
            "",
            "    Use it like this to aggregate permissions for your methods::",
            "",
            "        class MyModelView(ModelView):",
            "            datamodel = SQLAInterface(MyModel)",
            "",
            "            @has_access",
            "            @permission_name('GeneralXPTO_Permission')",
            "            @expose(url='/xpto')",
            "            def xpto(self):",
            "                return \"Your on xpto\"",
            "",
            "            @has_access",
            "            @permission_name('GeneralXPTO_Permission')",
            "            @expose(url='/xpto2')",
            "            def xpto2(self):",
            "                return \"Your on xpto2\"",
            "",
            "",
            "    :param name:",
            "        The name of the permission to override",
            "    \"\"\"",
            "",
            "    def wraps(f):",
            "        f._permission_name = name",
            "        return f",
            "",
            "    return wraps",
            "",
            "",
            "def limit(",
            "    limit_value: Union[str, Callable[[], str]],",
            "    key_func: Optional[Callable[[], str]] = None,",
            "    per_method: bool = False,",
            "    methods: Optional[List[str]] = None,",
            "    error_message: Optional[str] = None,",
            "    exempt_when: Optional[Callable[[], bool]] = None,",
            "    override_defaults: bool = True,",
            "    deduct_when: Optional[Callable[[Response], bool]] = None,",
            "    on_breach: Optional[Callable[[RequestLimit], Optional[Response]]] = None,",
            "    cost: Union[int, Callable[[], int]] = 1,",
            "):",
            "    \"\"\"",
            "    Decorator to be used for rate limiting individual routes or blueprints.",
            "",
            "    :param limit_value: rate limit string or a callable that returns a",
            "     string. :ref:`ratelimit-string` for more details.",
            "    :param key_func: function/lambda to extract the unique",
            "     identifier for the rate limit. defaults to remote address of the",
            "     request.",
            "    :param per_method: whether the limit is sub categorized into the",
            "     http method of the request.",
            "    :param methods: if specified, only the methods in this list will",
            "     be rate limited (default: ``None``).",
            "    :param error_message: string (or callable that returns one) to override",
            "     the error message used in the response.",
            "    :param exempt_when: function/lambda used to decide if the rate",
            "     limit should skipped.",
            "    :param override_defaults:  whether the decorated limit overrides",
            "     the default limits (Default: ``True``).",
            "",
            "     .. note:: When used with a :class:`~BaseView` the meaning",
            "        of the parameter extends to any parents the blueprint instance is",
            "        registered under. For more details see :ref:`recipes:nested blueprints`",
            "",
            "    :param deduct_when: a function that receives the current",
            "     :class:`flask.Response` object and returns True/False to decide if a",
            "     deduction should be done from the rate limit",
            "    :param on_breach: a function that will be called when this limit",
            "     is breached. If the function returns an instance of :class:`flask.Response`",
            "     that will be the response embedded into the :exc:`RateLimitExceeded` exception",
            "     raised.",
            "    :param cost: The cost of a hit or a function that",
            "     takes no parameters and returns the cost as an integer (Default: ``1``).",
            "    \"\"\"",
            "",
            "    def wraps(f: Callable[P, R]) -> Callable[P, R]:",
            "        _limit = Limit(",
            "            limit_value=limit_value,",
            "            key_func=key_func,",
            "            per_method=per_method,",
            "            methods=methods,",
            "            error_message=error_message,",
            "            exempt_when=exempt_when,",
            "            override_defaults=override_defaults,",
            "            deduct_when=deduct_when,",
            "            on_breach=on_breach,",
            "            cost=cost,",
            "        )",
            "        f._limit = _limit",
            "        return f",
            "",
            "    return wraps"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "22": []
        },
        "addLocation": []
    },
    "flask_appbuilder/security/manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Any, Dict, List, Optional, Set, Tuple, Union"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask import g, session, url_for"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from flask import Flask, g, session, url_for"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from flask_babel import lazy_gettext as _"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from flask_jwt_extended import current_user as current_user_jwt"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from flask_jwt_extended import JWTManager"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from flask_limiter import Limiter"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from flask_limiter.util import get_remote_address"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from flask_login import current_user, LoginManager"
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from werkzeug.security import check_password_hash, generate_password_hash"
            },
            "12": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")"
            },
            "14": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "             app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")"
            },
            "15": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        # Rate limiting"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        app.config.setdefault(\"AUTH_RATE_LIMITED\", True)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+        app.config.setdefault(\"AUTH_RATE_LIMIT\", \"2 per 5 second\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         if self.auth_type == AUTH_OID:"
            },
            "21": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "             from flask_openid import OpenID"
            },
            "22": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 266,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         # Setup Flask-Jwt-Extended"
            },
            "24": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         self.jwt_manager = self.create_jwt_manager(app)"
            },
            "25": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 293,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+        # Setup Flask-Limiter"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        self.limiter = self.create_limiter(app)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+    def create_limiter(self, app: Flask) -> Limiter:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+        limiter = Limiter(key_func=get_remote_address)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        limiter.init_app(app)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        return limiter"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "     def create_login_manager(self, app) -> LoginManager:"
            },
            "35": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         \"\"\""
            },
            "36": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         Override to implement your custom login manager instance"
            },
            "37": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "     def oauth_providers(self):"
            },
            "38": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]"
            },
            "39": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 505,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+    @property"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+    def is_auth_limited(self) -> bool:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMITED\"]"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+    @property"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+    def auth_rate_limit(self) -> str:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMIT\"]"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "     @property"
            },
            "49": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "     def current_user(self):"
            },
            "50": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "         if current_user.is_authenticated:"
            },
            "51": {
                "beforePatchRowNumber": 735,
                "afterPatchRowNumber": 757,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 736,
                "afterPatchRowNumber": 758,
                "PatchRowcode": "         self.appbuilder.add_view_no_menu(self.auth_view)"
            },
            "53": {
                "beforePatchRowNumber": 737,
                "afterPatchRowNumber": 759,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 760,
                "PatchRowcode": "+        # this needs to be done after the view is added, otherwise the blueprint"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 761,
                "PatchRowcode": "+        # is not initialized"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 762,
                "PatchRowcode": "+        if self.is_auth_limited:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 763,
                "PatchRowcode": "+            self.limiter.limit(self.auth_rate_limit, methods=[\"POST\"])("
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 764,
                "PatchRowcode": "+                self.auth_view.blueprint"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 765,
                "PatchRowcode": "+            )"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 766,
                "PatchRowcode": "+"
            },
            "61": {
                "beforePatchRowNumber": 738,
                "afterPatchRowNumber": 767,
                "PatchRowcode": "         self.user_view = self.appbuilder.add_view("
            },
            "62": {
                "beforePatchRowNumber": 739,
                "afterPatchRowNumber": 768,
                "PatchRowcode": "             self.user_view,"
            },
            "63": {
                "beforePatchRowNumber": 740,
                "afterPatchRowNumber": 769,
                "PatchRowcode": "             \"List Users\","
            },
            "64": {
                "beforePatchRowNumber": 1548,
                "afterPatchRowNumber": 1577,
                "PatchRowcode": "                 None, \"menu_access\", view_menus_name=menu_names"
            },
            "65": {
                "beforePatchRowNumber": 1549,
                "afterPatchRowNumber": 1578,
                "PatchRowcode": "             )"
            },
            "66": {
                "beforePatchRowNumber": 1550,
                "afterPatchRowNumber": 1579,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1580,
                "PatchRowcode": "+    def add_limit_view(self, baseview):"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1581,
                "PatchRowcode": "+        if not baseview.limits:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1582,
                "PatchRowcode": "+            return"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1583,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1584,
                "PatchRowcode": "+        for limit in baseview.limits:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1585,
                "PatchRowcode": "+            self.limiter.limit("
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1586,
                "PatchRowcode": "+                limit_value=limit.limit_value,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1587,
                "PatchRowcode": "+                key_func=limit.key_func,"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1588,
                "PatchRowcode": "+                per_method=limit.per_method,"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1589,
                "PatchRowcode": "+                methods=limit.methods,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1590,
                "PatchRowcode": "+                error_message=limit.error_message,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1591,
                "PatchRowcode": "+                exempt_when=limit.exempt_when,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1592,
                "PatchRowcode": "+                override_defaults=limit.override_defaults,"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1593,
                "PatchRowcode": "+                deduct_when=limit.deduct_when,"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1594,
                "PatchRowcode": "+                on_breach=limit.on_breach,"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1595,
                "PatchRowcode": "+                cost=limit.cost,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1596,
                "PatchRowcode": "+            )(baseview.blueprint)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1597,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": 1551,
                "afterPatchRowNumber": 1598,
                "PatchRowcode": "     def add_permissions_view(self, base_permissions, view_menu):"
            },
            "86": {
                "beforePatchRowNumber": 1552,
                "afterPatchRowNumber": 1599,
                "PatchRowcode": "         \"\"\""
            },
            "87": {
                "beforePatchRowNumber": 1553,
                "afterPatchRowNumber": 1600,
                "PatchRowcode": "         Adds a permission on a view menu to the backend"
            }
        },
        "frontPatchFile": [
            "import base64",
            "import datetime",
            "import json",
            "import logging",
            "import re",
            "from typing import Any, Dict, List, Optional, Set, Tuple, Union",
            "",
            "from flask import g, session, url_for",
            "from flask_babel import lazy_gettext as _",
            "from flask_jwt_extended import current_user as current_user_jwt",
            "from flask_jwt_extended import JWTManager",
            "from flask_login import current_user, LoginManager",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from .api import SecurityApi",
            "from .registerviews import (",
            "    RegisterUserDBView,",
            "    RegisterUserOAuthView,",
            "    RegisterUserOIDView,",
            ")",
            "from .views import (",
            "    AuthDBView,",
            "    AuthLDAPView,",
            "    AuthOAuthView,",
            "    AuthOIDView,",
            "    AuthRemoteUserView,",
            "    PermissionModelView,",
            "    PermissionViewModelView,",
            "    RegisterUserModelView,",
            "    ResetMyPasswordView,",
            "    ResetPasswordView,",
            "    RoleModelView,",
            "    UserDBModelView,",
            "    UserInfoEditView,",
            "    UserLDAPModelView,",
            "    UserOAuthModelView,",
            "    UserOIDModelView,",
            "    UserRemoteUserModelView,",
            "    UserStatsChartView,",
            "    ViewMenuModelView,",
            ")",
            "from ..basemanager import BaseManager",
            "from ..const import (",
            "    AUTH_DB,",
            "    AUTH_LDAP,",
            "    AUTH_OAUTH,",
            "    AUTH_OID,",
            "    AUTH_REMOTE_USER,",
            "    LOGMSG_ERR_SEC_ADD_REGISTER_USER,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,",
            "    LOGMSG_WAR_SEC_LOGIN_FAILED,",
            "    LOGMSG_WAR_SEC_NO_USER,",
            "    LOGMSG_WAR_SEC_NOLDAP_OBJ,",
            "    PERMISSION_PREFIX,",
            ")",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class AbstractSecurityManager(BaseManager):",
            "    \"\"\"",
            "    Abstract SecurityManager class, declares all methods used by the",
            "    framework. There is no assumptions about security models or auth types.",
            "    \"\"\"",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def register_views(self):",
            "        \"\"\"",
            "        Generic function to create the security views",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def has_access(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        raise NotImplementedError",
            "",
            "    def get_first_user(self):",
            "        raise NotImplementedError",
            "",
            "    def noop_user_update(self, user) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "def _oauth_tokengetter(token=None):",
            "    \"\"\"",
            "    Default function to return the current user oauth token",
            "    from session cookie.",
            "    \"\"\"",
            "    token = session.get(\"oauth\")",
            "    log.debug(\"Token Get: {0}\".format(token))",
            "    return token",
            "",
            "",
            "class BaseSecurityManager(AbstractSecurityManager):",
            "    auth_view = None",
            "    \"\"\" The obj instance for authentication view \"\"\"",
            "    user_view = None",
            "    \"\"\" The obj instance for user view \"\"\"",
            "    registeruser_view = None",
            "    \"\"\" The obj instance for registering user view \"\"\"",
            "    lm = None",
            "    \"\"\" Flask-Login LoginManager \"\"\"",
            "    jwt_manager = None",
            "    \"\"\" Flask-JWT-Extended \"\"\"",
            "    oid = None",
            "    \"\"\" Flask-OpenID OpenID \"\"\"",
            "    oauth = None",
            "    \"\"\" Flask-OAuth \"\"\"",
            "    oauth_remotes = None",
            "    \"\"\" OAuth email whitelists \"\"\"",
            "    oauth_whitelists = {}",
            "    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"",
            "    oauth_tokengetter = _oauth_tokengetter",
            "    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"",
            "    oauth_user_info = None",
            "",
            "    user_model = None",
            "    \"\"\" Override to set your own User Model \"\"\"",
            "    role_model = None",
            "    \"\"\" Override to set your own Role Model \"\"\"",
            "    permission_model = None",
            "    \"\"\" Override to set your own Permission Model \"\"\"",
            "    viewmenu_model = None",
            "    \"\"\" Override to set your own ViewMenu Model \"\"\"",
            "    permissionview_model = None",
            "    \"\"\" Override to set your own PermissionView Model \"\"\"",
            "    registeruser_model = None",
            "    \"\"\" Override to set your own RegisterUser Model \"\"\"",
            "",
            "    userdbmodelview = UserDBModelView",
            "    \"\"\" Override if you want your own user db view \"\"\"",
            "    userldapmodelview = UserLDAPModelView",
            "    \"\"\" Override if you want your own user ldap view \"\"\"",
            "    useroidmodelview = UserOIDModelView",
            "    \"\"\" Override if you want your own user OID view \"\"\"",
            "    useroauthmodelview = UserOAuthModelView",
            "    \"\"\" Override if you want your own user OAuth view \"\"\"",
            "    userremoteusermodelview = UserRemoteUserModelView",
            "    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"",
            "    registerusermodelview = RegisterUserModelView",
            "",
            "    authdbview = AuthDBView",
            "    \"\"\" Override if you want your own Authentication DB view \"\"\"",
            "    authldapview = AuthLDAPView",
            "    \"\"\" Override if you want your own Authentication LDAP view \"\"\"",
            "    authoidview = AuthOIDView",
            "    \"\"\" Override if you want your own Authentication OID view \"\"\"",
            "    authoauthview = AuthOAuthView",
            "    \"\"\" Override if you want your own Authentication OAuth view \"\"\"",
            "    authremoteuserview = AuthRemoteUserView",
            "    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"",
            "",
            "    registeruserdbview = RegisterUserDBView",
            "    \"\"\" Override if you want your own register user db view \"\"\"",
            "    registeruseroidview = RegisterUserOIDView",
            "    \"\"\" Override if you want your own register user OpenID view \"\"\"",
            "    registeruseroauthview = RegisterUserOAuthView",
            "    \"\"\" Override if you want your own register user OAuth view \"\"\"",
            "",
            "    resetmypasswordview = ResetMyPasswordView",
            "    \"\"\" Override if you want your own reset my password view \"\"\"",
            "    resetpasswordview = ResetPasswordView",
            "    \"\"\" Override if you want your own reset password view \"\"\"",
            "    userinfoeditview = UserInfoEditView",
            "    \"\"\" Override if you want your own User information edit view \"\"\"",
            "",
            "    # API",
            "    security_api = SecurityApi",
            "    \"\"\" Override if you want your own Security API login endpoint \"\"\"",
            "",
            "    rolemodelview = RoleModelView",
            "    permissionmodelview = PermissionModelView",
            "    userstatschartview = UserStatsChartView",
            "    viewmenumodelview = ViewMenuModelView",
            "    permissionviewmodelview = PermissionViewModelView",
            "",
            "    def __init__(self, appbuilder):",
            "        super(BaseSecurityManager, self).__init__(appbuilder)",
            "        app = self.appbuilder.get_app",
            "        # Base Security Config",
            "        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")",
            "        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")",
            "        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)",
            "        # Self Registration",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)",
            "        # Role Mapping",
            "        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})",
            "        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)",
            "        app.config.setdefault(\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\", False)",
            "",
            "        # LDAP Config",
            "        if self.auth_type == AUTH_LDAP:",
            "            if \"AUTH_LDAP_SERVER\" not in app.config:",
            "                raise Exception(",
            "                    \"No AUTH_LDAP_SERVER defined on config\"",
            "                    \" with AUTH_LDAP authentication type.\"",
            "                )",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")",
            "            # TLS options",
            "            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")",
            "            # Mapping options",
            "            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")",
            "            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")",
            "            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")",
            "            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")",
            "            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")",
            "",
            "        if self.auth_type == AUTH_OID:",
            "            from flask_openid import OpenID",
            "",
            "            self.oid = OpenID(app)",
            "        if self.auth_type == AUTH_OAUTH:",
            "            from authlib.integrations.flask_client import OAuth",
            "",
            "            self.oauth = OAuth(app)",
            "            self.oauth_remotes = dict()",
            "            for _provider in self.oauth_providers:",
            "                provider_name = _provider[\"name\"]",
            "                log.debug(\"OAuth providers init {0}\".format(provider_name))",
            "                obj_provider = self.oauth.register(",
            "                    provider_name, **_provider[\"remote_app\"]",
            "                )",
            "                obj_provider._tokengetter = self.oauth_tokengetter",
            "                if not self.oauth_user_info:",
            "                    self.oauth_user_info = self.get_oauth_user_info",
            "                # Whitelist only users with matching emails",
            "                if \"whitelist\" in _provider:",
            "                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]",
            "                self.oauth_remotes[provider_name] = obj_provider",
            "",
            "        self._builtin_roles = self.create_builtin_roles()",
            "        # Setup Flask-Login",
            "        self.lm = self.create_login_manager(app)",
            "",
            "        # Setup Flask-Jwt-Extended",
            "        self.jwt_manager = self.create_jwt_manager(app)",
            "",
            "    def create_login_manager(self, app) -> LoginManager:",
            "        \"\"\"",
            "        Override to implement your custom login manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        lm = LoginManager(app)",
            "        lm.login_view = \"login\"",
            "        lm.user_loader(self.load_user)",
            "        return lm",
            "",
            "    def create_jwt_manager(self, app) -> JWTManager:",
            "        \"\"\"",
            "        Override to implement your custom JWT manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        jwt_manager = JWTManager()",
            "        jwt_manager.init_app(app)",
            "        jwt_manager.user_lookup_loader(self.load_user_jwt)",
            "        return jwt_manager",
            "",
            "    def create_builtin_roles(self):",
            "        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})",
            "",
            "    def get_roles_from_keys(self, role_keys: List[str]) -> Set[role_model]:",
            "        \"\"\"",
            "        Construct a list of FAB role objects, from a list of keys.",
            "",
            "        NOTE:",
            "        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"",
            "        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names",
            "",
            "        :param role_keys: the list of FAB role keys",
            "        :return: a list of RoleModelView",
            "        \"\"\"",
            "        _roles = set()",
            "        _role_keys = set(role_keys)",
            "        for role_key, fab_role_names in self.auth_roles_mapping.items():",
            "            if role_key in _role_keys:",
            "                for fab_role_name in fab_role_names:",
            "                    fab_role = self.find_role(fab_role_name)",
            "                    if fab_role:",
            "                        _roles.add(fab_role)",
            "                    else:",
            "                        log.warning(",
            "                            \"Can't find role specified in AUTH_ROLES_MAPPING: {0}\".format(",
            "                                fab_role_name",
            "                            )",
            "                        )",
            "        return _roles",
            "",
            "    @property",
            "    def auth_type_provider_name(self) -> Optional[str]:",
            "        provider_to_auth_type = {AUTH_DB: \"db\", AUTH_LDAP: \"ldap\"}",
            "        return provider_to_auth_type.get(self.auth_type)",
            "",
            "    @property",
            "    def get_url_for_registeruser(self):",
            "        return url_for(",
            "            \"%s.%s\"",
            "            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_user_datamodel(self):",
            "        return self.user_view.datamodel",
            "",
            "    @property",
            "    def get_register_user_datamodel(self):",
            "        return self.registerusermodelview.datamodel",
            "",
            "    @property",
            "    def builtin_roles(self) -> Dict[str, Any]:",
            "        return self._builtin_roles",
            "",
            "    @property",
            "    def api_login_allow_multiple_providers(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\"]",
            "",
            "    @property",
            "    def auth_type(self) -> int:",
            "        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]",
            "",
            "    @property",
            "    def auth_username_ci(self) -> str:",
            "        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)",
            "",
            "    @property",
            "    def auth_role_admin(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]",
            "",
            "    @property",
            "    def auth_role_public(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]",
            "",
            "    @property",
            "    def auth_ldap_server(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]",
            "",
            "    @property",
            "    def auth_ldap_use_tls(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]",
            "",
            "    @property",
            "    def auth_user_registration(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]",
            "",
            "    @property",
            "    def auth_user_registration_role(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]",
            "",
            "    @property",
            "    def auth_user_registration_role_jmespath(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]",
            "",
            "    @property",
            "    def auth_roles_mapping(self) -> Dict[str, List[str]]:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]",
            "",
            "    @property",
            "    def auth_roles_sync_at_login(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]",
            "",
            "    @property",
            "    def auth_ldap_search(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]",
            "",
            "    @property",
            "    def auth_ldap_search_filter(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_user(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_password(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]",
            "",
            "    @property",
            "    def auth_ldap_append_domain(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]",
            "",
            "    @property",
            "    def auth_ldap_username_format(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]",
            "",
            "    @property",
            "    def auth_ldap_uid_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_group_field(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_firstname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_lastname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_email_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_first(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]",
            "",
            "    @property",
            "    def auth_ldap_allow_self_signed(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_demand(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertdir(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_certfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_keyfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]",
            "",
            "    @property",
            "    def openid_providers(self):",
            "        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]",
            "",
            "    @property",
            "    def oauth_providers(self):",
            "        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]",
            "",
            "    @property",
            "    def current_user(self):",
            "        if current_user.is_authenticated:",
            "            return g.user",
            "        elif current_user_jwt:",
            "            return current_user_jwt",
            "",
            "    def oauth_user_info_getter(self, f):",
            "        \"\"\"",
            "        Decorator function to be the OAuth user info getter",
            "        for all the providers, receives provider and response",
            "        return a dict with the information returned from the provider.",
            "        The returned user info dict should have it's keys with the same",
            "        name as the User Model.",
            "",
            "        Use it like this an example for GitHub ::",
            "",
            "            @appbuilder.sm.oauth_user_info_getter",
            "            def my_oauth_user_info(sm, provider, response=None):",
            "                if provider == 'github':",
            "                    me = sm.oauth_remotes[provider].get('user')",
            "                    return {'username': me.data.get('login')}",
            "                else:",
            "                    return {}",
            "        \"\"\"",
            "",
            "        def wraps(provider, response=None):",
            "            ret = f(self, provider, response=response)",
            "            # Checks if decorator is well behaved and returns a dict as supposed.",
            "            if not type(ret) == dict:",
            "                log.error(",
            "                    \"OAuth user info decorated function \"",
            "                    \"did not returned a dict, but: {0}\".format(type(ret))",
            "                )",
            "                return {}",
            "            return ret",
            "",
            "        self.oauth_user_info = wraps",
            "        return wraps",
            "",
            "    def get_oauth_token_key_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_key name for the oauth provider",
            "        if none is configured defaults to oauth_token",
            "        this is configured using OAUTH_PROVIDERS and token_key key.",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_key\", \"oauth_token\")",
            "",
            "    def get_oauth_token_secret_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_secret name for the oauth provider",
            "        if none is configured defaults to oauth_secret",
            "        this is configured using OAUTH_PROVIDERS and token_secret",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_secret\", \"oauth_token_secret\")",
            "",
            "    def set_oauth_session(self, provider, oauth_response):",
            "        \"\"\"",
            "        Set the current session with OAuth user secrets",
            "        \"\"\"",
            "        # Get this provider key names for token_key and token_secret",
            "        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)",
            "        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)",
            "        # Save users token on encrypted session cookie",
            "        session[\"oauth\"] = (",
            "            oauth_response[token_key],",
            "            oauth_response.get(token_secret, \"\"),",
            "        )",
            "        session[\"oauth_provider\"] = provider",
            "",
            "    def get_oauth_user_info(self, provider, resp):",
            "        \"\"\"",
            "        Since there are different OAuth API's with different ways to",
            "        retrieve user info",
            "        \"\"\"",
            "        # for GITHUB",
            "        if provider == \"github\" or provider == \"githublocal\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")",
            "            data = me.json()",
            "            log.debug(\"User info from Github: {0}\".format(data))",
            "            return {\"username\": \"github_\" + data.get(\"login\")}",
            "        # for twitter",
            "        if provider == \"twitter\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")",
            "            data = me.json()",
            "            log.debug(\"User info from Twitter: {0}\".format(data))",
            "            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}",
            "        # for linkedin",
            "        if provider == \"linkedin\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"people/~:(id,email-address,first-name,last-name)?format=json\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from Linkedin: {0}\".format(data))",
            "            return {",
            "                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),",
            "                \"email\": data.get(\"email-address\", \"\"),",
            "                \"first_name\": data.get(\"firstName\", \"\"),",
            "                \"last_name\": data.get(\"lastName\", \"\"),",
            "            }",
            "        # for Google",
            "        if provider == \"google\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Google: {0}\".format(data))",
            "            return {",
            "                \"username\": \"google_\" + data.get(\"id\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        # for Azure AD Tenant. Azure OAuth response contains",
            "        # JWT token which has user info.",
            "        # JWT token needs to be base64 decoded.",
            "        # https://docs.microsoft.com/en-us/azure/active-directory/develop/",
            "        # active-directory-protocols-oauth-code",
            "        if provider == \"azure\":",
            "            log.debug(\"Azure response received : {0}\".format(resp))",
            "            id_token = resp[\"id_token\"]",
            "            log.debug(str(id_token))",
            "            me = self._azure_jwt_token_parse(id_token)",
            "            log.debug(\"Parse JWT token : {0}\".format(me))",
            "            return {",
            "                \"name\": me.get(\"name\", \"\"),",
            "                \"email\": me[\"upn\"],",
            "                \"first_name\": me.get(\"given_name\", \"\"),",
            "                \"last_name\": me.get(\"family_name\", \"\"),",
            "                \"id\": me[\"oid\"],",
            "                \"username\": me[\"oid\"],",
            "                \"role_keys\": me.get(\"roles\", []),",
            "            }",
            "        # for OpenShift",
            "        if provider == \"openshift\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"apis/user.openshift.io/v1/users/~\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from OpenShift: {0}\".format(data))",
            "            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}",
            "        # for Okta",
            "        if provider == \"okta\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Okta: %s\", data)",
            "            return {",
            "                \"username\": \"okta_\" + data.get(\"sub\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Keycloak",
            "        if provider in [\"keycloak\", \"keycloak_before_17\"]:",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"openid-connect/userinfo\"",
            "            )",
            "            me.raise_for_status()",
            "            data = me.json()",
            "            log.debug(\"User info from Keycloak: %s\", data)",
            "            return {",
            "                \"username\": data.get(\"preferred_username\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        else:",
            "            return {}",
            "",
            "    def _azure_parse_jwt(self, id_token):",
            "        jwt_token_parts = r\"^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$\"",
            "        matches = re.search(jwt_token_parts, id_token)",
            "        if not matches or len(matches.groups()) < 3:",
            "            log.error(\"Unable to parse token.\")",
            "            return {}",
            "        return {",
            "            \"header\": matches.group(1),",
            "            \"Payload\": matches.group(2),",
            "            \"Sig\": matches.group(3),",
            "        }",
            "",
            "    def _azure_jwt_token_parse(self, id_token):",
            "        jwt_split_token = self._azure_parse_jwt(id_token)",
            "        if not jwt_split_token:",
            "            return",
            "",
            "        jwt_payload = jwt_split_token[\"Payload\"]",
            "        # Prepare for base64 decoding",
            "        payload_b64_string = jwt_payload",
            "        payload_b64_string += \"=\" * (4 - ((len(jwt_payload) % 4)))",
            "        decoded_payload = base64.urlsafe_b64decode(payload_b64_string.encode(\"ascii\"))",
            "",
            "        if not decoded_payload:",
            "            log.error(\"Payload of id_token could not be base64 url decoded.\")",
            "            return",
            "",
            "        jwt_decoded_payload = json.loads(decoded_payload.decode(\"utf-8\"))",
            "",
            "        return jwt_decoded_payload",
            "",
            "    def register_views(self):",
            "        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):",
            "            return",
            "        # Security APIs",
            "        self.appbuilder.add_api(self.security_api)",
            "",
            "        if self.auth_user_registration:",
            "            if self.auth_type == AUTH_DB:",
            "                self.registeruser_view = self.registeruserdbview()",
            "            elif self.auth_type == AUTH_OID:",
            "                self.registeruser_view = self.registeruseroidview()",
            "            elif self.auth_type == AUTH_OAUTH:",
            "                self.registeruser_view = self.registeruseroauthview()",
            "            if self.registeruser_view:",
            "                self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.resetpasswordview())",
            "        self.appbuilder.add_view_no_menu(self.resetmypasswordview())",
            "        self.appbuilder.add_view_no_menu(self.userinfoeditview())",
            "",
            "        if self.auth_type == AUTH_DB:",
            "            self.user_view = self.userdbmodelview",
            "            self.auth_view = self.authdbview()",
            "",
            "        elif self.auth_type == AUTH_LDAP:",
            "            self.user_view = self.userldapmodelview",
            "            self.auth_view = self.authldapview()",
            "        elif self.auth_type == AUTH_OAUTH:",
            "            self.user_view = self.useroauthmodelview",
            "            self.auth_view = self.authoauthview()",
            "        elif self.auth_type == AUTH_REMOTE_USER:",
            "            self.user_view = self.userremoteusermodelview",
            "            self.auth_view = self.authremoteuserview()",
            "        else:",
            "            self.user_view = self.useroidmodelview",
            "            self.auth_view = self.authoidview()",
            "            if self.auth_user_registration:",
            "                pass",
            "                # self.registeruser_view = self.registeruseroidview()",
            "                # self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.auth_view)",
            "",
            "        self.user_view = self.appbuilder.add_view(",
            "            self.user_view,",
            "            \"List Users\",",
            "            icon=\"fa-user\",",
            "            label=_(\"List Users\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "            category_label=_(\"Security\"),",
            "        )",
            "",
            "        role_view = self.appbuilder.add_view(",
            "            self.rolemodelview,",
            "            \"List Roles\",",
            "            icon=\"fa-group\",",
            "            label=_(\"List Roles\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "        )",
            "        role_view.related_views = [self.user_view.__class__]",
            "",
            "        if self.userstatschartview:",
            "            self.appbuilder.add_view(",
            "                self.userstatschartview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-bar-chart-o\",",
            "                label=_(\"User's Statistics\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.auth_user_registration:",
            "            self.appbuilder.add_view(",
            "                self.registerusermodelview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-user-plus\",",
            "                label=_(\"User Registrations\"),",
            "                category=\"Security\",",
            "            )",
            "        self.appbuilder.menu.add_separator(\"Security\")",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.permissionmodelview,",
            "                \"Base Permissions\",",
            "                icon=\"fa-lock\",",
            "                label=_(\"Base Permissions\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.viewmenumodelview,",
            "                \"Views/Menus\",",
            "                icon=\"fa-list-alt\",",
            "                label=_(\"Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(",
            "            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True",
            "        ):",
            "            self.appbuilder.add_view(",
            "                self.permissionviewmodelview,",
            "                \"Permission on Views/Menus\",",
            "                icon=\"fa-link\",",
            "                label=_(\"Permission on Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "",
            "    def create_db(self):",
            "        \"\"\"",
            "        Setups the DB, creates admin and public roles if they don't exist.",
            "        \"\"\"",
            "        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})",
            "        for pk, name in roles_mapping.items():",
            "            self.update_role(pk, name)",
            "        for role_name, permission_view_menus in self.builtin_roles.items():",
            "            permission_view_menus = [",
            "                self.add_permission_view_menu(permission_name, view_menu_name)",
            "                for view_menu_name, permission_name in permission_view_menus",
            "            ]",
            "            self.add_role(name=role_name, permissions=permission_view_menus)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            self.add_role(self.auth_role_admin)",
            "        self.add_role(self.auth_role_public)",
            "        if self.count_users() == 0:",
            "            log.warning(LOGMSG_WAR_SEC_NO_USER)",
            "",
            "    def reset_password(self, userid, password):",
            "        \"\"\"",
            "        Change/Reset a user's password for authdb.",
            "        Password will be hashed and saved.",
            "",
            "        :param userid:",
            "            the user.id to reset the password",
            "        :param password:",
            "            The clear text password to reset and save hashed on the db",
            "        \"\"\"",
            "        user = self.get_user_by_id(userid)",
            "        user.password = generate_password_hash(password)",
            "        self.update_user(user)",
            "",
            "    def update_user_auth_stat(self, user, success=True):",
            "        \"\"\"",
            "        Update user authentication stats upon successful/unsuccessful",
            "        authentication attempts.",
            "",
            "        :param user:",
            "            The identified (but possibly not successfully authenticated) user",
            "            model",
            "        :param success:",
            "        :type success: bool or None",
            "            Defaults to true, if true increments login_count, updates",
            "            last_login, and resets fail_login_count to 0, if false increments",
            "            fail_login_count on user model.",
            "        \"\"\"",
            "        if not user.login_count:",
            "            user.login_count = 0",
            "        if not user.fail_login_count:",
            "            user.fail_login_count = 0",
            "        if success:",
            "            user.login_count += 1",
            "            user.last_login = datetime.datetime.now()",
            "            user.fail_login_count = 0",
            "        else:",
            "            user.fail_login_count += 1",
            "        self.update_user(user)",
            "",
            "    def auth_user_db(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user, auth db style",
            "",
            "        :param username:",
            "            The username or registered email address",
            "        :param password:",
            "            The password, will be tested against hashed password on db",
            "        \"\"\"",
            "        if username is None or username == \"\":",
            "            return None",
            "        first_user = self.get_first_user()",
            "        user = self.find_user(username=username)",
            "        if user is None:",
            "            user = self.find_user(email=username)",
            "        else:",
            "            # Balance failure and success",
            "            _ = self.find_user(email=username)",
            "        if user is None or (not user.is_active):",
            "            # Balance failure and success",
            "            check_password_hash(",
            "                \"pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118\"",
            "                \"c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c\",",
            "                \"password\",",
            "            )",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            # Balance failure and success",
            "            if first_user:",
            "                self.noop_user_update(first_user)",
            "            return None",
            "        elif check_password_hash(user.password, password):",
            "            self.update_user_auth_stat(user, True)",
            "            return user",
            "        else:",
            "            self.update_user_auth_stat(user, False)",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            return None",
            "",
            "    def _search_ldap(self, ldap, con, username):",
            "        \"\"\"",
            "        Searches LDAP for user.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        :param username: username to match with AUTH_LDAP_UID_FIELD",
            "        :return: ldap object array",
            "        \"\"\"",
            "        # always check AUTH_LDAP_SEARCH is set before calling this method",
            "        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"",
            "",
            "        # build the filter string for the LDAP search",
            "        if self.auth_ldap_search_filter:",
            "            filter_str = \"(&{0}({1}={2}))\".format(",
            "                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username",
            "            )",
            "        else:",
            "            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)",
            "",
            "        # build what fields to request in the LDAP search",
            "        request_fields = [",
            "            self.auth_ldap_firstname_field,",
            "            self.auth_ldap_lastname_field,",
            "            self.auth_ldap_email_field,",
            "        ]",
            "        if len(self.auth_roles_mapping) > 0:",
            "            request_fields.append(self.auth_ldap_group_field)",
            "",
            "        # preform the LDAP search",
            "        log.debug(",
            "            \"LDAP search for '{0}' with fields {1} in scope '{2}'\".format(",
            "                filter_str, request_fields, self.auth_ldap_search",
            "            )",
            "        )",
            "        raw_search_result = con.search_s(",
            "            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields",
            "        )",
            "        log.debug(\"LDAP search returned: {0}\".format(raw_search_result))",
            "",
            "        # Remove any search referrals from results",
            "        search_result = [",
            "            (dn, attrs)",
            "            for dn, attrs in raw_search_result",
            "            if dn is not None and isinstance(attrs, dict)",
            "        ]",
            "",
            "        # only continue if 0 or 1 results were returned",
            "        if len(search_result) > 1:",
            "            log.error(",
            "                \"LDAP search for '{0}' in scope '{1}' returned multiple results\".format(",
            "                    filter_str, self.auth_ldap_search",
            "                )",
            "            )",
            "            return None, None",
            "",
            "        try:",
            "            # extract the DN",
            "            user_dn = search_result[0][0]",
            "            # extract the other attributes",
            "            user_info = search_result[0][1]",
            "            # return",
            "            return user_dn, user_info",
            "        except (IndexError, NameError):",
            "            return None, None",
            "",
            "    def _ldap_calculate_user_roles(",
            "        self, user_attributes: Dict[str, bytes]",
            "    ) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = self.ldap_extract_list(",
            "                user_attributes, self.auth_ldap_group_field",
            "            )",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(",
            "                        registration_role_name",
            "                    )",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def _ldap_bind_indirect(self, ldap, con) -> None:",
            "        \"\"\"",
            "        Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        \"\"\"",
            "        # always check AUTH_LDAP_BIND_USER is set before calling this method",
            "        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"",
            "",
            "        try:",
            "            log.debug(",
            "                \"LDAP bind indirect TRY with username: '{0}'\".format(",
            "                    self.auth_ldap_bind_user",
            "                )",
            "            )",
            "            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)",
            "            log.debug(",
            "                \"LDAP bind indirect SUCCESS with username: '{0}'\".format(",
            "                    self.auth_ldap_bind_user",
            "                )",
            "            )",
            "        except ldap.INVALID_CREDENTIALS as ex:",
            "            log.error(",
            "                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"",
            "                \" not valid LDAP bind credentials\"",
            "            )",
            "            raise ex",
            "",
            "    @staticmethod",
            "    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:",
            "        \"\"\"",
            "        Validates/binds the provided dn/password with the LDAP sever.",
            "        \"\"\"",
            "        try:",
            "            log.debug(\"LDAP bind TRY with username: '{0}'\".format(dn))",
            "            con.simple_bind_s(dn, password)",
            "            log.debug(\"LDAP bind SUCCESS with username: '{0}'\".format(dn))",
            "            return True",
            "        except ldap.INVALID_CREDENTIALS:",
            "            return False",
            "",
            "    @staticmethod",
            "    def ldap_extract(",
            "        ldap_dict: Dict[str, bytes], field_name: str, fallback: str",
            "    ) -> str:",
            "        raw_value = ldap_dict.get(field_name, [bytes()])",
            "        # decode - if empty string, default to fallback, otherwise take first element",
            "        return raw_value[0].decode(\"utf-8\") or fallback",
            "",
            "    @staticmethod",
            "    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:",
            "        raw_list = ldap_dict.get(field_name, [])",
            "        # decode - removing empty strings",
            "        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]",
            "",
            "    def auth_user_ldap(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user with LDAP.",
            "",
            "        NOTE: this depends on python-ldap module",
            "",
            "        :param username: the username",
            "        :param password: the password",
            "        \"\"\"",
            "        # If no username is provided, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Ensure python-ldap is installed",
            "        try:",
            "            import ldap",
            "        except ImportError:",
            "            log.error(\"python-ldap library is not installed\")",
            "            return None",
            "",
            "        try:",
            "            # LDAP certificate settings",
            "            if self.auth_ldap_tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)",
            "            if self.auth_ldap_tls_cacertfile:",
            "                ldap.set_option(",
            "                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile",
            "                )",
            "            if self.auth_ldap_tls_certfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)",
            "            if self.auth_ldap_tls_keyfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)",
            "            if self.auth_ldap_allow_self_signed:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "            elif self.auth_ldap_tls_demand:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "",
            "            # Initialise LDAP connection",
            "            con = ldap.initialize(self.auth_ldap_server)",
            "            con.set_option(ldap.OPT_REFERRALS, 0)",
            "            if self.auth_ldap_use_tls:",
            "                try:",
            "                    con.start_tls_s()",
            "                except Exception:",
            "                    log.error(",
            "                        LOGMSG_ERR_SEC_AUTH_LDAP_TLS.format(self.auth_ldap_server)",
            "                    )",
            "                    return None",
            "",
            "            # Define variables, so we can check if they are set in later steps",
            "            user_dn = None",
            "            user_attributes = {}",
            "",
            "            # Flow 1 - (Indirect Search Bind):",
            "            #  - in this flow, special bind credentials are used to preform the",
            "            #    LDAP search",
            "            #  - in this flow, AUTH_LDAP_SEARCH must be set",
            "            if self.auth_ldap_bind_user:",
            "                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD",
            "                # (authorizes for LDAP search)",
            "                self._ldap_bind_indirect(ldap, con)",
            "",
            "                # Search for `username`",
            "                #  - returns the `user_dn` needed for binding to validate credentials",
            "                #  - returns the `user_attributes` needed for",
            "                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "                else:",
            "                    log.error(",
            "                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"",
            "                    )",
            "                    return None",
            "",
            "                # If search failed, go away",
            "                if user_dn is None:",
            "                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))",
            "                    return None",
            "",
            "                # Bind with user_dn/password (validates credentials)",
            "                if not self._ldap_bind(ldap, con, user_dn, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "                    return None",
            "",
            "            # Flow 2 - (Direct Search Bind):",
            "            #  - in this flow, the credentials provided by the end-user are used",
            "            #    to preform the LDAP search",
            "            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set",
            "            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN",
            "            #       will only work if AUTH_LDAP_SEARCH is set",
            "            else:",
            "                # Copy the provided username (so we can apply formatters)",
            "                bind_username = username",
            "",
            "                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN",
            "                #  - for Microsoft AD, which allows binding with userPrincipalName",
            "                if self.auth_ldap_append_domain:",
            "                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain",
            "",
            "                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT",
            "                #  - for transforming the username into a DN,",
            "                #    for example: \"uid=%s,ou=example,o=test\"",
            "                if self.auth_ldap_username_format:",
            "                    bind_username = self.auth_ldap_username_format % bind_username",
            "",
            "                # Bind with bind_username/password",
            "                # (validates credentials & authorizes for LDAP search)",
            "                if not self._ldap_bind(ldap, con, bind_username, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(bind_username))",
            "                    return None",
            "",
            "                # Search for `username` (if AUTH_LDAP_SEARCH is set)",
            "                #  - returns the `user_attributes`",
            "                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                #  - we search on `username` not `bind_username`,",
            "                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT",
            "                #    would result in an invalid search filter",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "",
            "                    # If search failed, go away",
            "                    if user_dn is None:",
            "                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))",
            "                        return None",
            "",
            "            # Sync the user's roles",
            "            if user and user_attributes and self.auth_roles_sync_at_login:",
            "                user.roles = self._ldap_calculate_user_roles(user_attributes)",
            "                log.debug(",
            "                    \"Calculated new roles for user='{0}' as: {1}\".format(",
            "                        user_dn, user.roles",
            "                    )",
            "                )",
            "",
            "            # If the user is new, register them",
            "            if (not user) and user_attributes and self.auth_user_registration:",
            "                user = self.add_user(",
            "                    username=username,",
            "                    first_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_firstname_field, \"\"",
            "                    ),",
            "                    last_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_lastname_field, \"\"",
            "                    ),",
            "                    email=self.ldap_extract(",
            "                        user_attributes,",
            "                        self.auth_ldap_email_field,",
            "                        f\"{username}@email.notfound\",",
            "                    ),",
            "                    role=self._ldap_calculate_user_roles(user_attributes),",
            "                )",
            "                log.debug(\"New user registered: {0}\".format(user))",
            "",
            "                # If user registration failed, go away",
            "                if not user:",
            "                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER.format(username))",
            "                    return None",
            "",
            "            # LOGIN SUCCESS (only if user is now registered)",
            "            if user:",
            "                self.update_user_auth_stat(user)",
            "                return user",
            "            else:",
            "                return None",
            "",
            "        except ldap.LDAPError as e:",
            "            msg = None",
            "            if isinstance(e, dict):",
            "                msg = getattr(e, \"message\", None)",
            "            if (msg is not None) and (\"desc\" in msg):",
            "                log.error(LOGMSG_ERR_SEC_AUTH_LDAP.format(e.message[\"desc\"]))",
            "                return None",
            "            else:",
            "                log.error(e)",
            "                return None",
            "",
            "    def auth_user_oid(self, email):",
            "        \"\"\"",
            "        OpenID user Authentication",
            "",
            "        :param email: user's email to authenticate",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(email=email)",
            "        if user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(email))",
            "            return None",
            "        else:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "",
            "    def auth_user_remote_user(self, username):",
            "        \"\"\"",
            "        REMOTE_USER user Authentication",
            "",
            "        :param username: user's username for remote auth",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(username=username)",
            "",
            "        # User does not exist, create one if auto user registration.",
            "        if user is None and self.auth_user_registration:",
            "            user = self.add_user(",
            "                # All we have is REMOTE_USER, so we set",
            "                # the other fields to blank.",
            "                username=username,",
            "                first_name=username,",
            "                last_name=\"-\",",
            "                email=username + \"@email.notfound\",",
            "                role=self.find_role(self.auth_user_registration_role),",
            "            )",
            "",
            "        # If user does not exist on the DB and not auto user registration,",
            "        # or user is inactive, go away.",
            "        elif user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            return None",
            "",
            "        self.update_user_auth_stat(user)",
            "        return user",
            "",
            "    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = userinfo.get(\"role_keys\", [])",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION_ROLE",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,",
            "            # use it for the registration role",
            "            if self.auth_user_registration_role_jmespath:",
            "                import jmespath",
            "",
            "                registration_role_name = jmespath.search(",
            "                    self.auth_user_registration_role_jmespath, userinfo",
            "                )",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(",
            "                        registration_role_name",
            "                    )",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def auth_user_oauth(self, userinfo):",
            "        \"\"\"",
            "        Method for authenticating user with OAuth.",
            "",
            "        :userinfo: dict with user information",
            "                   (keys are the same as User model columns)",
            "        \"\"\"",
            "        # extract the username from `userinfo`",
            "        if \"username\" in userinfo:",
            "            username = userinfo[\"username\"]",
            "        elif \"email\" in userinfo:",
            "            username = userinfo[\"email\"]",
            "        else:",
            "            log.error(",
            "                \"OAUTH userinfo does not have username or email {0}\".format(userinfo)",
            "            )",
            "            return None",
            "",
            "        # If username is empty, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Sync the user's roles",
            "        if user and self.auth_roles_sync_at_login:",
            "            user.roles = self._oauth_calculate_user_roles(userinfo)",
            "            log.debug(",
            "                \"Calculated new roles for user='{0}' as: {1}\".format(",
            "                    username, user.roles",
            "                )",
            "            )",
            "",
            "        # If the user is new, register them",
            "        if (not user) and self.auth_user_registration:",
            "            user = self.add_user(",
            "                username=username,",
            "                first_name=userinfo.get(\"first_name\", \"\"),",
            "                last_name=userinfo.get(\"last_name\", \"\"),",
            "                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",",
            "                role=self._oauth_calculate_user_roles(userinfo),",
            "            )",
            "            log.debug(\"New user registered: {0}\".format(user))",
            "",
            "            # If user registration failed, go away",
            "            if not user:",
            "                log.error(\"Error creating a new OAuth user {0}\".format(username))",
            "                return None",
            "",
            "        # LOGIN SUCCESS (only if user is now registered)",
            "        if user:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "        else:",
            "            return None",
            "",
            "    \"\"\"",
            "        ----------------------------------------",
            "            PERMISSION ACCESS CHECK",
            "        ----------------------------------------",
            "    \"\"\"",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        permissions = self.get_public_permissions()",
            "        if permissions:",
            "            for i in permissions:",
            "                if (view_name == i.view_menu.name) and (",
            "                    permission_name == i.permission.name",
            "                ):",
            "                    return True",
            "            return False",
            "        else:",
            "            return False",
            "",
            "    def _has_access_builtin_roles(",
            "        self, role, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        \"\"\"",
            "        Checks permission on builtin role",
            "        \"\"\"",
            "        builtin_pvms = self.builtin_roles.get(role.name, [])",
            "        for pvm in builtin_pvms:",
            "            _view_name = pvm[0]",
            "            _permission_name = pvm[1]",
            "            if re.match(_view_name, view_name) and re.match(",
            "                _permission_name, permission_name",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def _has_view_access(",
            "        self, user: object, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        roles = user.roles",
            "        db_role_ids = list()",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                if self._has_access_builtin_roles(role, permission_name, view_name):",
            "                    return True",
            "            else:",
            "                db_role_ids.append(role.id)",
            "",
            "        # If it's not a builtin role check against database store roles",
            "        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)",
            "",
            "    def get_user_roles(self, user) -> List[object]:",
            "        \"\"\"",
            "        Get current user roles, if user is not authenticated returns the public role",
            "        \"\"\"",
            "        if not user.is_authenticated:",
            "            return [self.get_public_role()]",
            "        return user.roles",
            "",
            "    def get_user_roles_permissions(self, user) -> Dict[str, List[Tuple[str, str]]]:",
            "        \"\"\"",
            "        Utility method just implemented for SQLAlchemy.",
            "        Take a look to: flask_appbuilder.security.sqla.manager",
            "        :param user:",
            "        :return:",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions for a certain role",
            "        \"\"\"",
            "        result = set()",
            "        if role.name in self.builtin_roles:",
            "            for permission in self.builtin_roles[role.name]:",
            "                result.add((permission[1], permission[0]))",
            "        else:",
            "            for permission in self.get_db_role_permissions(role.id):",
            "                result.add((permission.permission.name, permission.view_menu.name))",
            "        return result",
            "",
            "    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions from the current user",
            "        \"\"\"",
            "        roles = self.get_user_roles(user)",
            "        result = set()",
            "        for role in roles:",
            "            result.update(self.get_role_permissions(role))",
            "        return result",
            "",
            "    def _get_user_permission_view_menus(",
            "        self, user: object, permission_name: str, view_menus_name: List[str]",
            "    ) -> Set[str]:",
            "        \"\"\"",
            "        Return a set of view menu names with a certain permission name",
            "        that a user has access to. Mainly used to fetch all menu permissions",
            "        on a single db call, will also check public permissions and builtin roles",
            "        \"\"\"",
            "        db_role_ids = list()",
            "        if user is None:",
            "            # include public role",
            "            roles = [self.get_public_role()]",
            "        else:",
            "            roles = user.roles",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        result = set()",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                for view_menu_name in view_menus_name:",
            "                    if self._has_access_builtin_roles(",
            "                        role, permission_name, view_menu_name",
            "                    ):",
            "                        result.add(view_menu_name)",
            "            else:",
            "                db_role_ids.append(role.id)",
            "        # Then check against database-stored roles",
            "        pvms_names = [",
            "            pvm.view_menu.name",
            "            for pvm in self.find_roles_permission_view_menus(",
            "                permission_name, db_role_ids",
            "            )",
            "        ]",
            "        result.update(pvms_names)",
            "        return result",
            "",
            "    def has_access(self, permission_name: str, view_name: str) -> bool:",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        if current_user.is_authenticated:",
            "            return self._has_view_access(g.user, permission_name, view_name)",
            "        elif current_user_jwt:",
            "            return self._has_view_access(current_user_jwt, permission_name, view_name)",
            "        else:",
            "            return self.is_item_public(permission_name, view_name)",
            "",
            "    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:",
            "        if current_user.is_authenticated:",
            "            return self._get_user_permission_view_menus(",
            "                g.user, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        elif current_user_jwt:",
            "            return self._get_user_permission_view_menus(",
            "                current_user_jwt, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        else:",
            "            return self._get_user_permission_view_menus(",
            "                None, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        view_menu_db = self.add_view_menu(view_menu)",
            "        perm_views = self.find_permissions_view_menu(view_menu_db)",
            "",
            "        if not perm_views:",
            "            # No permissions yet on this view",
            "            for permission in base_permissions:",
            "                pv = self.add_permission_view_menu(permission, view_menu)",
            "                if self.auth_role_admin not in self.builtin_roles:",
            "                    role_admin = self.find_role(self.auth_role_admin)",
            "                    self.add_permission_role(role_admin, pv)",
            "        else:",
            "            # Permissions on this view exist but....",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            for permission in base_permissions:",
            "                # Check if base view permissions exist",
            "                if not self.exist_permission_on_views(perm_views, permission):",
            "                    pv = self.add_permission_view_menu(permission, view_menu)",
            "                    if self.auth_role_admin not in self.builtin_roles:",
            "                        self.add_permission_role(role_admin, pv)",
            "            for perm_view in perm_views:",
            "                if perm_view.permission is None:",
            "                    # Skip this perm_view, it has a null permission",
            "                    continue",
            "                if perm_view.permission.name not in base_permissions:",
            "                    # perm to delete",
            "                    roles = self.get_all_roles()",
            "                    perm = self.find_permission(perm_view.permission.name)",
            "                    # del permission from all roles",
            "                    for role in roles:",
            "                        self.del_permission_role(role, perm)",
            "                    self.del_permission_view_menu(perm_view.permission.name, view_menu)",
            "                elif (",
            "                    self.auth_role_admin not in self.builtin_roles",
            "                    and perm_view not in role_admin.permissions",
            "                ):",
            "                    # Role Admin must have all permissions",
            "                    self.add_permission_role(role_admin, perm_view)",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        self.add_view_menu(view_menu_name)",
            "        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if not pv:",
            "            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            self.add_permission_role(role_admin, pv)",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        \"\"\"",
            "        Will cleanup all unused permissions from the database",
            "",
            "        :param baseviews: A list of BaseViews class",
            "        :param menus: Menu class",
            "        \"\"\"",
            "        viewsmenus = self.get_all_view_menu()",
            "        roles = self.get_all_roles()",
            "        for viewmenu in viewsmenus:",
            "            found = False",
            "            for baseview in baseviews:",
            "                if viewmenu.name == baseview.class_permission_name:",
            "                    found = True",
            "                    break",
            "            if menus.find(viewmenu.name):",
            "                found = True",
            "            if not found:",
            "                permissions = self.find_permissions_view_menu(viewmenu)",
            "                for permission in permissions:",
            "                    for role in roles:",
            "                        self.del_permission_role(role, permission)",
            "                    self.del_permission_view_menu(",
            "                        permission.permission.name, viewmenu.name",
            "                    )",
            "                self.del_view_menu(viewmenu.name)",
            "        self.security_converge(baseviews, menus)",
            "",
            "    @staticmethod",
            "    def _get_new_old_permissions(baseview) -> Dict:",
            "        ret = dict()",
            "        for method_name, permission_name in baseview.method_permission_name.items():",
            "            old_permission_name = baseview.previous_method_permission_name.get(",
            "                method_name",
            "            )",
            "            # Actions do not get prefix when normally defined",
            "            if hasattr(baseview, \"actions\") and baseview.actions.get(",
            "                old_permission_name",
            "            ):",
            "                permission_prefix = \"\"",
            "            else:",
            "                permission_prefix = PERMISSION_PREFIX",
            "            if old_permission_name:",
            "                if PERMISSION_PREFIX + permission_name not in ret:",
            "                    ret[PERMISSION_PREFIX + permission_name] = {",
            "                        permission_prefix + old_permission_name",
            "                    }",
            "                else:",
            "                    ret[PERMISSION_PREFIX + permission_name].add(",
            "                        permission_prefix + old_permission_name",
            "                    )",
            "        return ret",
            "",
            "    @staticmethod",
            "    def _add_state_transition(",
            "        state_transition: Dict,",
            "        old_view_name: str,",
            "        old_perm_name: str,",
            "        view_name: str,",
            "        perm_name: str,",
            "    ) -> None:",
            "        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))",
            "        if old_pvm:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)].add(",
            "                (view_name, perm_name)",
            "            )",
            "        else:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)] = {",
            "                (view_name, perm_name)",
            "            }",
            "        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))",
            "        state_transition[\"del_views\"].add(old_view_name)",
            "        state_transition[\"del_perms\"].add(old_perm_name)",
            "",
            "    @staticmethod",
            "    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:",
            "        \"\"\"",
            "        Mutates state_transitions, loop baseviews and prunes all",
            "        views and permissions that are not to delete because references",
            "        exist.",
            "",
            "        :param baseview:",
            "        :param state_transitions:",
            "        :return:",
            "        \"\"\"",
            "        for baseview in baseviews:",
            "            state_transitions[\"del_views\"].discard(baseview.class_permission_name)",
            "            for permission in baseview.base_permissions:",
            "                state_transitions[\"del_role_pvm\"].discard(",
            "                    (baseview.class_permission_name, permission)",
            "                )",
            "                state_transitions[\"del_perms\"].discard(permission)",
            "",
            "    def create_state_transitions(",
            "        self, baseviews: List, menus: Optional[List[Any]]",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Creates a Dict with all the necessary vm/permission transitions",
            "",
            "        Dict: {",
            "                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}",
            "                \"del_role_pvm\": ((<VM>, <PERM>), ...)",
            "                \"del_views\": (<VM>, ... )",
            "                \"del_perms\": (<PERM>, ... )",
            "              }",
            "",
            "        :param baseviews: List with all the registered BaseView, BaseApi",
            "        :param menus: List with all the menu entries",
            "        :return: Dict with state transitions",
            "        \"\"\"",
            "        state_transitions = {",
            "            \"add\": {},",
            "            \"del_role_pvm\": set(),",
            "            \"del_views\": set(),",
            "            \"del_perms\": set(),",
            "        }",
            "        for baseview in baseviews:",
            "            add_all_flag = False",
            "            new_view_name = baseview.class_permission_name",
            "            permission_mapping = self._get_new_old_permissions(baseview)",
            "            if baseview.previous_class_permission_name:",
            "                old_view_name = baseview.previous_class_permission_name",
            "                add_all_flag = True",
            "            else:",
            "                new_view_name = baseview.class_permission_name",
            "                old_view_name = new_view_name",
            "            for new_perm_name in baseview.base_permissions:",
            "                if add_all_flag:",
            "                    old_perm_names = permission_mapping.get(new_perm_name)",
            "                    old_perm_names = old_perm_names or (new_perm_name,)",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "                else:",
            "                    old_perm_names = permission_mapping.get(new_perm_name) or set()",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "        self._update_del_transitions(state_transitions, baseviews)",
            "        return state_transitions",
            "",
            "    def security_converge(",
            "        self, baseviews: List, menus: Optional[List[Any]], dry=False",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Converges overridden permissions on all registered views/api",
            "        will compute all necessary operations from `class_permissions_name`,",
            "        `previous_class_permission_name`, method_permission_name`,",
            "        `previous_method_permission_name` class attributes.",
            "",
            "        :param baseviews: List of registered views/apis",
            "        :param menus: List of menu items",
            "        :param dry: If True will not change DB",
            "        :return: Dict with the necessary operations (state_transitions)",
            "        \"\"\"",
            "        state_transitions = self.create_state_transitions(baseviews, menus)",
            "        if dry:",
            "            return state_transitions",
            "        if not state_transitions:",
            "            log.info(\"No state transitions found\")",
            "            return dict()",
            "        log.debug(f\"State transitions: {state_transitions}\")",
            "        roles = self.get_all_roles()",
            "        for role in roles:",
            "            permissions = list(role.permissions)",
            "            for pvm in permissions:",
            "                new_pvm_states = state_transitions[\"add\"].get(",
            "                    (pvm.view_menu.name, pvm.permission.name)",
            "                )",
            "                if not new_pvm_states:",
            "                    continue",
            "                for new_pvm_state in new_pvm_states:",
            "                    new_pvm = self.add_permission_view_menu(",
            "                        new_pvm_state[1], new_pvm_state[0]",
            "                    )",
            "                    self.add_permission_role(role, new_pvm)",
            "                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[",
            "                    \"del_role_pvm\"",
            "                ]:",
            "                    self.del_permission_role(role, pvm)",
            "        for pvm in state_transitions[\"del_role_pvm\"]:",
            "            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)",
            "        for view_name in state_transitions[\"del_views\"]:",
            "            self.del_view_menu(view_name)",
            "        for permission_name in state_transitions[\"del_perms\"]:",
            "            self.del_permission(permission_name)",
            "        return state_transitions",
            "",
            "    \"\"\"",
            "     ---------------------------",
            "     INTERFACE ABSTRACT METHODS",
            "     ---------------------------",
            "",
            "     ---------------------",
            "     PRIMITIVES FOR USERS",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_register_user(self, registration_hash):",
            "        \"\"\"",
            "        Generic function to return user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_register_user(",
            "        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"",
            "    ):",
            "        \"\"\"",
            "        Generic function to add user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_register_user(self, register_user):",
            "        \"\"\"",
            "        Generic function to delete user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_user_by_id(self, pk):",
            "        \"\"\"",
            "        Generic function to return user by it's id (pk)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_user(self, username=None, email=None):",
            "        \"\"\"",
            "        Generic function find a user by it's username or email",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_users(self):",
            "        \"\"\"",
            "        Generic function that returns all existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_db_role_permissions(self, role_id: int) -> List[object]:",
            "        \"\"\"",
            "        Get all DB permissions from a role id",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_user(self, username, first_name, last_name, email, role, password=\"\"):",
            "        \"\"\"",
            "        Generic function to create user",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def update_user(self, user):",
            "        \"\"\"",
            "        Generic function to update user",
            "",
            "        :param user: User model to update to database",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def count_users(self):",
            "        \"\"\"",
            "        Generic function to count the existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES FOR ROLES",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_role(self, name):",
            "        raise NotImplementedError",
            "",
            "    def add_role(self, name, permissions=None):",
            "        raise NotImplementedError",
            "",
            "    def update_role(self, pk, name):",
            "        raise NotImplementedError",
            "",
            "    def get_all_roles(self):",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------------",
            "     PRIMITIVES FOR PERMISSIONS",
            "    ----------------------------",
            "    \"\"\"",
            "",
            "    def get_public_role(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_public_permissions(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permission(self, name):",
            "        \"\"\"",
            "        Finds and returns a Permission by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_roles_permission_view_menus(",
            "        self, permission_name: str, role_ids: List[int]",
            "    ):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_roles(",
            "        self, view_name: str, permission_name: str, role_ids: List[int]",
            "    ) -> bool:",
            "        \"\"\"",
            "        Finds and returns permission views for a group of roles",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission(self, name):",
            "        \"\"\"",
            "        Adds a permission to the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission(self, name):",
            "        \"\"\"",
            "        Deletes a permission from the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_view_menu(self, name):",
            "        \"\"\"",
            "        Finds and returns a ViewMenu by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_view_menu(self):",
            "        raise NotImplementedError",
            "",
            "    def add_view_menu(self, name):",
            "        \"\"\"",
            "        Adds a view or menu to the backend, model view_menu",
            "        param name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_view_menu(self, name):",
            "        \"\"\"",
            "        Deletes a ViewMenu from the backend",
            "",
            "        :param name:",
            "            name of the ViewMenu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PERMISSION VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Finds and returns a PermissionView by names",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permissions_view_menu(self, view_menu):",
            "        \"\"\"",
            "        Finds all permissions from ViewMenu, returns list of PermissionView",
            "",
            "        :param view_menu: ViewMenu object",
            "        :return: list of PermissionView objects",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Adds a permission on a view or menu to the backend",
            "",
            "        :param permission_name:",
            "            name of the permission to add: 'can_add','can_edit' etc...",
            "        :param view_menu_name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_views(self, lst, item):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_view(self, lst, permission, view_menu):",
            "        raise NotImplementedError",
            "",
            "    def add_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Add permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Remove permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def export_roles(",
            "        self, path: Optional[str] = None, indent: Optional[Union[int, str]] = None",
            "    ) -> None:",
            "        \"\"\"Exports roles to JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def import_roles(self, path: str) -> None:",
            "        \"\"\"Imports roles from JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_user(self, pk):",
            "        return self.get_user_by_id(int(pk))",
            "",
            "    def load_user_jwt(self, _jwt_header, jwt_data):",
            "        identity = jwt_data[\"sub\"]",
            "        user = self.load_user(identity)",
            "        # Set flask g.user to JWT user, we can't do it on before request",
            "        g.user = user",
            "        return user",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        g.user = current_user"
        ],
        "afterPatchFile": [
            "import base64",
            "import datetime",
            "import json",
            "import logging",
            "import re",
            "from typing import Any, Dict, List, Optional, Set, Tuple, Union",
            "",
            "from flask import Flask, g, session, url_for",
            "from flask_babel import lazy_gettext as _",
            "from flask_jwt_extended import current_user as current_user_jwt",
            "from flask_jwt_extended import JWTManager",
            "from flask_limiter import Limiter",
            "from flask_limiter.util import get_remote_address",
            "from flask_login import current_user, LoginManager",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from .api import SecurityApi",
            "from .registerviews import (",
            "    RegisterUserDBView,",
            "    RegisterUserOAuthView,",
            "    RegisterUserOIDView,",
            ")",
            "from .views import (",
            "    AuthDBView,",
            "    AuthLDAPView,",
            "    AuthOAuthView,",
            "    AuthOIDView,",
            "    AuthRemoteUserView,",
            "    PermissionModelView,",
            "    PermissionViewModelView,",
            "    RegisterUserModelView,",
            "    ResetMyPasswordView,",
            "    ResetPasswordView,",
            "    RoleModelView,",
            "    UserDBModelView,",
            "    UserInfoEditView,",
            "    UserLDAPModelView,",
            "    UserOAuthModelView,",
            "    UserOIDModelView,",
            "    UserRemoteUserModelView,",
            "    UserStatsChartView,",
            "    ViewMenuModelView,",
            ")",
            "from ..basemanager import BaseManager",
            "from ..const import (",
            "    AUTH_DB,",
            "    AUTH_LDAP,",
            "    AUTH_OAUTH,",
            "    AUTH_OID,",
            "    AUTH_REMOTE_USER,",
            "    LOGMSG_ERR_SEC_ADD_REGISTER_USER,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,",
            "    LOGMSG_WAR_SEC_LOGIN_FAILED,",
            "    LOGMSG_WAR_SEC_NO_USER,",
            "    LOGMSG_WAR_SEC_NOLDAP_OBJ,",
            "    PERMISSION_PREFIX,",
            ")",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class AbstractSecurityManager(BaseManager):",
            "    \"\"\"",
            "    Abstract SecurityManager class, declares all methods used by the",
            "    framework. There is no assumptions about security models or auth types.",
            "    \"\"\"",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def register_views(self):",
            "        \"\"\"",
            "        Generic function to create the security views",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def has_access(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        raise NotImplementedError",
            "",
            "    def get_first_user(self):",
            "        raise NotImplementedError",
            "",
            "    def noop_user_update(self, user) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "def _oauth_tokengetter(token=None):",
            "    \"\"\"",
            "    Default function to return the current user oauth token",
            "    from session cookie.",
            "    \"\"\"",
            "    token = session.get(\"oauth\")",
            "    log.debug(\"Token Get: {0}\".format(token))",
            "    return token",
            "",
            "",
            "class BaseSecurityManager(AbstractSecurityManager):",
            "    auth_view = None",
            "    \"\"\" The obj instance for authentication view \"\"\"",
            "    user_view = None",
            "    \"\"\" The obj instance for user view \"\"\"",
            "    registeruser_view = None",
            "    \"\"\" The obj instance for registering user view \"\"\"",
            "    lm = None",
            "    \"\"\" Flask-Login LoginManager \"\"\"",
            "    jwt_manager = None",
            "    \"\"\" Flask-JWT-Extended \"\"\"",
            "    oid = None",
            "    \"\"\" Flask-OpenID OpenID \"\"\"",
            "    oauth = None",
            "    \"\"\" Flask-OAuth \"\"\"",
            "    oauth_remotes = None",
            "    \"\"\" OAuth email whitelists \"\"\"",
            "    oauth_whitelists = {}",
            "    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"",
            "    oauth_tokengetter = _oauth_tokengetter",
            "    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"",
            "    oauth_user_info = None",
            "",
            "    user_model = None",
            "    \"\"\" Override to set your own User Model \"\"\"",
            "    role_model = None",
            "    \"\"\" Override to set your own Role Model \"\"\"",
            "    permission_model = None",
            "    \"\"\" Override to set your own Permission Model \"\"\"",
            "    viewmenu_model = None",
            "    \"\"\" Override to set your own ViewMenu Model \"\"\"",
            "    permissionview_model = None",
            "    \"\"\" Override to set your own PermissionView Model \"\"\"",
            "    registeruser_model = None",
            "    \"\"\" Override to set your own RegisterUser Model \"\"\"",
            "",
            "    userdbmodelview = UserDBModelView",
            "    \"\"\" Override if you want your own user db view \"\"\"",
            "    userldapmodelview = UserLDAPModelView",
            "    \"\"\" Override if you want your own user ldap view \"\"\"",
            "    useroidmodelview = UserOIDModelView",
            "    \"\"\" Override if you want your own user OID view \"\"\"",
            "    useroauthmodelview = UserOAuthModelView",
            "    \"\"\" Override if you want your own user OAuth view \"\"\"",
            "    userremoteusermodelview = UserRemoteUserModelView",
            "    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"",
            "    registerusermodelview = RegisterUserModelView",
            "",
            "    authdbview = AuthDBView",
            "    \"\"\" Override if you want your own Authentication DB view \"\"\"",
            "    authldapview = AuthLDAPView",
            "    \"\"\" Override if you want your own Authentication LDAP view \"\"\"",
            "    authoidview = AuthOIDView",
            "    \"\"\" Override if you want your own Authentication OID view \"\"\"",
            "    authoauthview = AuthOAuthView",
            "    \"\"\" Override if you want your own Authentication OAuth view \"\"\"",
            "    authremoteuserview = AuthRemoteUserView",
            "    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"",
            "",
            "    registeruserdbview = RegisterUserDBView",
            "    \"\"\" Override if you want your own register user db view \"\"\"",
            "    registeruseroidview = RegisterUserOIDView",
            "    \"\"\" Override if you want your own register user OpenID view \"\"\"",
            "    registeruseroauthview = RegisterUserOAuthView",
            "    \"\"\" Override if you want your own register user OAuth view \"\"\"",
            "",
            "    resetmypasswordview = ResetMyPasswordView",
            "    \"\"\" Override if you want your own reset my password view \"\"\"",
            "    resetpasswordview = ResetPasswordView",
            "    \"\"\" Override if you want your own reset password view \"\"\"",
            "    userinfoeditview = UserInfoEditView",
            "    \"\"\" Override if you want your own User information edit view \"\"\"",
            "",
            "    # API",
            "    security_api = SecurityApi",
            "    \"\"\" Override if you want your own Security API login endpoint \"\"\"",
            "",
            "    rolemodelview = RoleModelView",
            "    permissionmodelview = PermissionModelView",
            "    userstatschartview = UserStatsChartView",
            "    viewmenumodelview = ViewMenuModelView",
            "    permissionviewmodelview = PermissionViewModelView",
            "",
            "    def __init__(self, appbuilder):",
            "        super(BaseSecurityManager, self).__init__(appbuilder)",
            "        app = self.appbuilder.get_app",
            "        # Base Security Config",
            "        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")",
            "        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")",
            "        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)",
            "        # Self Registration",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)",
            "        # Role Mapping",
            "        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})",
            "        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)",
            "        app.config.setdefault(\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\", False)",
            "",
            "        # LDAP Config",
            "        if self.auth_type == AUTH_LDAP:",
            "            if \"AUTH_LDAP_SERVER\" not in app.config:",
            "                raise Exception(",
            "                    \"No AUTH_LDAP_SERVER defined on config\"",
            "                    \" with AUTH_LDAP authentication type.\"",
            "                )",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")",
            "            # TLS options",
            "            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")",
            "            # Mapping options",
            "            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")",
            "            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")",
            "            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")",
            "            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")",
            "            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")",
            "",
            "        # Rate limiting",
            "        app.config.setdefault(\"AUTH_RATE_LIMITED\", True)",
            "        app.config.setdefault(\"AUTH_RATE_LIMIT\", \"2 per 5 second\")",
            "",
            "        if self.auth_type == AUTH_OID:",
            "            from flask_openid import OpenID",
            "",
            "            self.oid = OpenID(app)",
            "        if self.auth_type == AUTH_OAUTH:",
            "            from authlib.integrations.flask_client import OAuth",
            "",
            "            self.oauth = OAuth(app)",
            "            self.oauth_remotes = dict()",
            "            for _provider in self.oauth_providers:",
            "                provider_name = _provider[\"name\"]",
            "                log.debug(\"OAuth providers init {0}\".format(provider_name))",
            "                obj_provider = self.oauth.register(",
            "                    provider_name, **_provider[\"remote_app\"]",
            "                )",
            "                obj_provider._tokengetter = self.oauth_tokengetter",
            "                if not self.oauth_user_info:",
            "                    self.oauth_user_info = self.get_oauth_user_info",
            "                # Whitelist only users with matching emails",
            "                if \"whitelist\" in _provider:",
            "                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]",
            "                self.oauth_remotes[provider_name] = obj_provider",
            "",
            "        self._builtin_roles = self.create_builtin_roles()",
            "        # Setup Flask-Login",
            "        self.lm = self.create_login_manager(app)",
            "",
            "        # Setup Flask-Jwt-Extended",
            "        self.jwt_manager = self.create_jwt_manager(app)",
            "",
            "        # Setup Flask-Limiter",
            "        self.limiter = self.create_limiter(app)",
            "",
            "    def create_limiter(self, app: Flask) -> Limiter:",
            "        limiter = Limiter(key_func=get_remote_address)",
            "        limiter.init_app(app)",
            "        return limiter",
            "",
            "    def create_login_manager(self, app) -> LoginManager:",
            "        \"\"\"",
            "        Override to implement your custom login manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        lm = LoginManager(app)",
            "        lm.login_view = \"login\"",
            "        lm.user_loader(self.load_user)",
            "        return lm",
            "",
            "    def create_jwt_manager(self, app) -> JWTManager:",
            "        \"\"\"",
            "        Override to implement your custom JWT manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        jwt_manager = JWTManager()",
            "        jwt_manager.init_app(app)",
            "        jwt_manager.user_lookup_loader(self.load_user_jwt)",
            "        return jwt_manager",
            "",
            "    def create_builtin_roles(self):",
            "        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})",
            "",
            "    def get_roles_from_keys(self, role_keys: List[str]) -> Set[role_model]:",
            "        \"\"\"",
            "        Construct a list of FAB role objects, from a list of keys.",
            "",
            "        NOTE:",
            "        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"",
            "        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names",
            "",
            "        :param role_keys: the list of FAB role keys",
            "        :return: a list of RoleModelView",
            "        \"\"\"",
            "        _roles = set()",
            "        _role_keys = set(role_keys)",
            "        for role_key, fab_role_names in self.auth_roles_mapping.items():",
            "            if role_key in _role_keys:",
            "                for fab_role_name in fab_role_names:",
            "                    fab_role = self.find_role(fab_role_name)",
            "                    if fab_role:",
            "                        _roles.add(fab_role)",
            "                    else:",
            "                        log.warning(",
            "                            \"Can't find role specified in AUTH_ROLES_MAPPING: {0}\".format(",
            "                                fab_role_name",
            "                            )",
            "                        )",
            "        return _roles",
            "",
            "    @property",
            "    def auth_type_provider_name(self) -> Optional[str]:",
            "        provider_to_auth_type = {AUTH_DB: \"db\", AUTH_LDAP: \"ldap\"}",
            "        return provider_to_auth_type.get(self.auth_type)",
            "",
            "    @property",
            "    def get_url_for_registeruser(self):",
            "        return url_for(",
            "            \"%s.%s\"",
            "            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_user_datamodel(self):",
            "        return self.user_view.datamodel",
            "",
            "    @property",
            "    def get_register_user_datamodel(self):",
            "        return self.registerusermodelview.datamodel",
            "",
            "    @property",
            "    def builtin_roles(self) -> Dict[str, Any]:",
            "        return self._builtin_roles",
            "",
            "    @property",
            "    def api_login_allow_multiple_providers(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\"]",
            "",
            "    @property",
            "    def auth_type(self) -> int:",
            "        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]",
            "",
            "    @property",
            "    def auth_username_ci(self) -> str:",
            "        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)",
            "",
            "    @property",
            "    def auth_role_admin(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]",
            "",
            "    @property",
            "    def auth_role_public(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]",
            "",
            "    @property",
            "    def auth_ldap_server(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]",
            "",
            "    @property",
            "    def auth_ldap_use_tls(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]",
            "",
            "    @property",
            "    def auth_user_registration(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]",
            "",
            "    @property",
            "    def auth_user_registration_role(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]",
            "",
            "    @property",
            "    def auth_user_registration_role_jmespath(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]",
            "",
            "    @property",
            "    def auth_roles_mapping(self) -> Dict[str, List[str]]:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]",
            "",
            "    @property",
            "    def auth_roles_sync_at_login(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]",
            "",
            "    @property",
            "    def auth_ldap_search(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]",
            "",
            "    @property",
            "    def auth_ldap_search_filter(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_user(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_password(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]",
            "",
            "    @property",
            "    def auth_ldap_append_domain(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]",
            "",
            "    @property",
            "    def auth_ldap_username_format(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]",
            "",
            "    @property",
            "    def auth_ldap_uid_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_group_field(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_firstname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_lastname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_email_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_first(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]",
            "",
            "    @property",
            "    def auth_ldap_allow_self_signed(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_demand(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertdir(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_certfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_keyfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]",
            "",
            "    @property",
            "    def openid_providers(self):",
            "        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]",
            "",
            "    @property",
            "    def oauth_providers(self):",
            "        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]",
            "",
            "    @property",
            "    def is_auth_limited(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMITED\"]",
            "",
            "    @property",
            "    def auth_rate_limit(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMIT\"]",
            "",
            "    @property",
            "    def current_user(self):",
            "        if current_user.is_authenticated:",
            "            return g.user",
            "        elif current_user_jwt:",
            "            return current_user_jwt",
            "",
            "    def oauth_user_info_getter(self, f):",
            "        \"\"\"",
            "        Decorator function to be the OAuth user info getter",
            "        for all the providers, receives provider and response",
            "        return a dict with the information returned from the provider.",
            "        The returned user info dict should have it's keys with the same",
            "        name as the User Model.",
            "",
            "        Use it like this an example for GitHub ::",
            "",
            "            @appbuilder.sm.oauth_user_info_getter",
            "            def my_oauth_user_info(sm, provider, response=None):",
            "                if provider == 'github':",
            "                    me = sm.oauth_remotes[provider].get('user')",
            "                    return {'username': me.data.get('login')}",
            "                else:",
            "                    return {}",
            "        \"\"\"",
            "",
            "        def wraps(provider, response=None):",
            "            ret = f(self, provider, response=response)",
            "            # Checks if decorator is well behaved and returns a dict as supposed.",
            "            if not type(ret) == dict:",
            "                log.error(",
            "                    \"OAuth user info decorated function \"",
            "                    \"did not returned a dict, but: {0}\".format(type(ret))",
            "                )",
            "                return {}",
            "            return ret",
            "",
            "        self.oauth_user_info = wraps",
            "        return wraps",
            "",
            "    def get_oauth_token_key_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_key name for the oauth provider",
            "        if none is configured defaults to oauth_token",
            "        this is configured using OAUTH_PROVIDERS and token_key key.",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_key\", \"oauth_token\")",
            "",
            "    def get_oauth_token_secret_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_secret name for the oauth provider",
            "        if none is configured defaults to oauth_secret",
            "        this is configured using OAUTH_PROVIDERS and token_secret",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_secret\", \"oauth_token_secret\")",
            "",
            "    def set_oauth_session(self, provider, oauth_response):",
            "        \"\"\"",
            "        Set the current session with OAuth user secrets",
            "        \"\"\"",
            "        # Get this provider key names for token_key and token_secret",
            "        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)",
            "        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)",
            "        # Save users token on encrypted session cookie",
            "        session[\"oauth\"] = (",
            "            oauth_response[token_key],",
            "            oauth_response.get(token_secret, \"\"),",
            "        )",
            "        session[\"oauth_provider\"] = provider",
            "",
            "    def get_oauth_user_info(self, provider, resp):",
            "        \"\"\"",
            "        Since there are different OAuth API's with different ways to",
            "        retrieve user info",
            "        \"\"\"",
            "        # for GITHUB",
            "        if provider == \"github\" or provider == \"githublocal\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")",
            "            data = me.json()",
            "            log.debug(\"User info from Github: {0}\".format(data))",
            "            return {\"username\": \"github_\" + data.get(\"login\")}",
            "        # for twitter",
            "        if provider == \"twitter\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")",
            "            data = me.json()",
            "            log.debug(\"User info from Twitter: {0}\".format(data))",
            "            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}",
            "        # for linkedin",
            "        if provider == \"linkedin\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"people/~:(id,email-address,first-name,last-name)?format=json\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from Linkedin: {0}\".format(data))",
            "            return {",
            "                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),",
            "                \"email\": data.get(\"email-address\", \"\"),",
            "                \"first_name\": data.get(\"firstName\", \"\"),",
            "                \"last_name\": data.get(\"lastName\", \"\"),",
            "            }",
            "        # for Google",
            "        if provider == \"google\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Google: {0}\".format(data))",
            "            return {",
            "                \"username\": \"google_\" + data.get(\"id\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        # for Azure AD Tenant. Azure OAuth response contains",
            "        # JWT token which has user info.",
            "        # JWT token needs to be base64 decoded.",
            "        # https://docs.microsoft.com/en-us/azure/active-directory/develop/",
            "        # active-directory-protocols-oauth-code",
            "        if provider == \"azure\":",
            "            log.debug(\"Azure response received : {0}\".format(resp))",
            "            id_token = resp[\"id_token\"]",
            "            log.debug(str(id_token))",
            "            me = self._azure_jwt_token_parse(id_token)",
            "            log.debug(\"Parse JWT token : {0}\".format(me))",
            "            return {",
            "                \"name\": me.get(\"name\", \"\"),",
            "                \"email\": me[\"upn\"],",
            "                \"first_name\": me.get(\"given_name\", \"\"),",
            "                \"last_name\": me.get(\"family_name\", \"\"),",
            "                \"id\": me[\"oid\"],",
            "                \"username\": me[\"oid\"],",
            "                \"role_keys\": me.get(\"roles\", []),",
            "            }",
            "        # for OpenShift",
            "        if provider == \"openshift\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"apis/user.openshift.io/v1/users/~\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from OpenShift: {0}\".format(data))",
            "            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}",
            "        # for Okta",
            "        if provider == \"okta\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Okta: %s\", data)",
            "            return {",
            "                \"username\": \"okta_\" + data.get(\"sub\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Keycloak",
            "        if provider in [\"keycloak\", \"keycloak_before_17\"]:",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"openid-connect/userinfo\"",
            "            )",
            "            me.raise_for_status()",
            "            data = me.json()",
            "            log.debug(\"User info from Keycloak: %s\", data)",
            "            return {",
            "                \"username\": data.get(\"preferred_username\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        else:",
            "            return {}",
            "",
            "    def _azure_parse_jwt(self, id_token):",
            "        jwt_token_parts = r\"^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$\"",
            "        matches = re.search(jwt_token_parts, id_token)",
            "        if not matches or len(matches.groups()) < 3:",
            "            log.error(\"Unable to parse token.\")",
            "            return {}",
            "        return {",
            "            \"header\": matches.group(1),",
            "            \"Payload\": matches.group(2),",
            "            \"Sig\": matches.group(3),",
            "        }",
            "",
            "    def _azure_jwt_token_parse(self, id_token):",
            "        jwt_split_token = self._azure_parse_jwt(id_token)",
            "        if not jwt_split_token:",
            "            return",
            "",
            "        jwt_payload = jwt_split_token[\"Payload\"]",
            "        # Prepare for base64 decoding",
            "        payload_b64_string = jwt_payload",
            "        payload_b64_string += \"=\" * (4 - ((len(jwt_payload) % 4)))",
            "        decoded_payload = base64.urlsafe_b64decode(payload_b64_string.encode(\"ascii\"))",
            "",
            "        if not decoded_payload:",
            "            log.error(\"Payload of id_token could not be base64 url decoded.\")",
            "            return",
            "",
            "        jwt_decoded_payload = json.loads(decoded_payload.decode(\"utf-8\"))",
            "",
            "        return jwt_decoded_payload",
            "",
            "    def register_views(self):",
            "        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):",
            "            return",
            "        # Security APIs",
            "        self.appbuilder.add_api(self.security_api)",
            "",
            "        if self.auth_user_registration:",
            "            if self.auth_type == AUTH_DB:",
            "                self.registeruser_view = self.registeruserdbview()",
            "            elif self.auth_type == AUTH_OID:",
            "                self.registeruser_view = self.registeruseroidview()",
            "            elif self.auth_type == AUTH_OAUTH:",
            "                self.registeruser_view = self.registeruseroauthview()",
            "            if self.registeruser_view:",
            "                self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.resetpasswordview())",
            "        self.appbuilder.add_view_no_menu(self.resetmypasswordview())",
            "        self.appbuilder.add_view_no_menu(self.userinfoeditview())",
            "",
            "        if self.auth_type == AUTH_DB:",
            "            self.user_view = self.userdbmodelview",
            "            self.auth_view = self.authdbview()",
            "",
            "        elif self.auth_type == AUTH_LDAP:",
            "            self.user_view = self.userldapmodelview",
            "            self.auth_view = self.authldapview()",
            "        elif self.auth_type == AUTH_OAUTH:",
            "            self.user_view = self.useroauthmodelview",
            "            self.auth_view = self.authoauthview()",
            "        elif self.auth_type == AUTH_REMOTE_USER:",
            "            self.user_view = self.userremoteusermodelview",
            "            self.auth_view = self.authremoteuserview()",
            "        else:",
            "            self.user_view = self.useroidmodelview",
            "            self.auth_view = self.authoidview()",
            "            if self.auth_user_registration:",
            "                pass",
            "                # self.registeruser_view = self.registeruseroidview()",
            "                # self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.auth_view)",
            "",
            "        # this needs to be done after the view is added, otherwise the blueprint",
            "        # is not initialized",
            "        if self.is_auth_limited:",
            "            self.limiter.limit(self.auth_rate_limit, methods=[\"POST\"])(",
            "                self.auth_view.blueprint",
            "            )",
            "",
            "        self.user_view = self.appbuilder.add_view(",
            "            self.user_view,",
            "            \"List Users\",",
            "            icon=\"fa-user\",",
            "            label=_(\"List Users\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "            category_label=_(\"Security\"),",
            "        )",
            "",
            "        role_view = self.appbuilder.add_view(",
            "            self.rolemodelview,",
            "            \"List Roles\",",
            "            icon=\"fa-group\",",
            "            label=_(\"List Roles\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "        )",
            "        role_view.related_views = [self.user_view.__class__]",
            "",
            "        if self.userstatschartview:",
            "            self.appbuilder.add_view(",
            "                self.userstatschartview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-bar-chart-o\",",
            "                label=_(\"User's Statistics\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.auth_user_registration:",
            "            self.appbuilder.add_view(",
            "                self.registerusermodelview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-user-plus\",",
            "                label=_(\"User Registrations\"),",
            "                category=\"Security\",",
            "            )",
            "        self.appbuilder.menu.add_separator(\"Security\")",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.permissionmodelview,",
            "                \"Base Permissions\",",
            "                icon=\"fa-lock\",",
            "                label=_(\"Base Permissions\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.viewmenumodelview,",
            "                \"Views/Menus\",",
            "                icon=\"fa-list-alt\",",
            "                label=_(\"Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(",
            "            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True",
            "        ):",
            "            self.appbuilder.add_view(",
            "                self.permissionviewmodelview,",
            "                \"Permission on Views/Menus\",",
            "                icon=\"fa-link\",",
            "                label=_(\"Permission on Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "",
            "    def create_db(self):",
            "        \"\"\"",
            "        Setups the DB, creates admin and public roles if they don't exist.",
            "        \"\"\"",
            "        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})",
            "        for pk, name in roles_mapping.items():",
            "            self.update_role(pk, name)",
            "        for role_name, permission_view_menus in self.builtin_roles.items():",
            "            permission_view_menus = [",
            "                self.add_permission_view_menu(permission_name, view_menu_name)",
            "                for view_menu_name, permission_name in permission_view_menus",
            "            ]",
            "            self.add_role(name=role_name, permissions=permission_view_menus)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            self.add_role(self.auth_role_admin)",
            "        self.add_role(self.auth_role_public)",
            "        if self.count_users() == 0:",
            "            log.warning(LOGMSG_WAR_SEC_NO_USER)",
            "",
            "    def reset_password(self, userid, password):",
            "        \"\"\"",
            "        Change/Reset a user's password for authdb.",
            "        Password will be hashed and saved.",
            "",
            "        :param userid:",
            "            the user.id to reset the password",
            "        :param password:",
            "            The clear text password to reset and save hashed on the db",
            "        \"\"\"",
            "        user = self.get_user_by_id(userid)",
            "        user.password = generate_password_hash(password)",
            "        self.update_user(user)",
            "",
            "    def update_user_auth_stat(self, user, success=True):",
            "        \"\"\"",
            "        Update user authentication stats upon successful/unsuccessful",
            "        authentication attempts.",
            "",
            "        :param user:",
            "            The identified (but possibly not successfully authenticated) user",
            "            model",
            "        :param success:",
            "        :type success: bool or None",
            "            Defaults to true, if true increments login_count, updates",
            "            last_login, and resets fail_login_count to 0, if false increments",
            "            fail_login_count on user model.",
            "        \"\"\"",
            "        if not user.login_count:",
            "            user.login_count = 0",
            "        if not user.fail_login_count:",
            "            user.fail_login_count = 0",
            "        if success:",
            "            user.login_count += 1",
            "            user.last_login = datetime.datetime.now()",
            "            user.fail_login_count = 0",
            "        else:",
            "            user.fail_login_count += 1",
            "        self.update_user(user)",
            "",
            "    def auth_user_db(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user, auth db style",
            "",
            "        :param username:",
            "            The username or registered email address",
            "        :param password:",
            "            The password, will be tested against hashed password on db",
            "        \"\"\"",
            "        if username is None or username == \"\":",
            "            return None",
            "        first_user = self.get_first_user()",
            "        user = self.find_user(username=username)",
            "        if user is None:",
            "            user = self.find_user(email=username)",
            "        else:",
            "            # Balance failure and success",
            "            _ = self.find_user(email=username)",
            "        if user is None or (not user.is_active):",
            "            # Balance failure and success",
            "            check_password_hash(",
            "                \"pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118\"",
            "                \"c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c\",",
            "                \"password\",",
            "            )",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            # Balance failure and success",
            "            if first_user:",
            "                self.noop_user_update(first_user)",
            "            return None",
            "        elif check_password_hash(user.password, password):",
            "            self.update_user_auth_stat(user, True)",
            "            return user",
            "        else:",
            "            self.update_user_auth_stat(user, False)",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            return None",
            "",
            "    def _search_ldap(self, ldap, con, username):",
            "        \"\"\"",
            "        Searches LDAP for user.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        :param username: username to match with AUTH_LDAP_UID_FIELD",
            "        :return: ldap object array",
            "        \"\"\"",
            "        # always check AUTH_LDAP_SEARCH is set before calling this method",
            "        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"",
            "",
            "        # build the filter string for the LDAP search",
            "        if self.auth_ldap_search_filter:",
            "            filter_str = \"(&{0}({1}={2}))\".format(",
            "                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username",
            "            )",
            "        else:",
            "            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)",
            "",
            "        # build what fields to request in the LDAP search",
            "        request_fields = [",
            "            self.auth_ldap_firstname_field,",
            "            self.auth_ldap_lastname_field,",
            "            self.auth_ldap_email_field,",
            "        ]",
            "        if len(self.auth_roles_mapping) > 0:",
            "            request_fields.append(self.auth_ldap_group_field)",
            "",
            "        # preform the LDAP search",
            "        log.debug(",
            "            \"LDAP search for '{0}' with fields {1} in scope '{2}'\".format(",
            "                filter_str, request_fields, self.auth_ldap_search",
            "            )",
            "        )",
            "        raw_search_result = con.search_s(",
            "            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields",
            "        )",
            "        log.debug(\"LDAP search returned: {0}\".format(raw_search_result))",
            "",
            "        # Remove any search referrals from results",
            "        search_result = [",
            "            (dn, attrs)",
            "            for dn, attrs in raw_search_result",
            "            if dn is not None and isinstance(attrs, dict)",
            "        ]",
            "",
            "        # only continue if 0 or 1 results were returned",
            "        if len(search_result) > 1:",
            "            log.error(",
            "                \"LDAP search for '{0}' in scope '{1}' returned multiple results\".format(",
            "                    filter_str, self.auth_ldap_search",
            "                )",
            "            )",
            "            return None, None",
            "",
            "        try:",
            "            # extract the DN",
            "            user_dn = search_result[0][0]",
            "            # extract the other attributes",
            "            user_info = search_result[0][1]",
            "            # return",
            "            return user_dn, user_info",
            "        except (IndexError, NameError):",
            "            return None, None",
            "",
            "    def _ldap_calculate_user_roles(",
            "        self, user_attributes: Dict[str, bytes]",
            "    ) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = self.ldap_extract_list(",
            "                user_attributes, self.auth_ldap_group_field",
            "            )",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(",
            "                        registration_role_name",
            "                    )",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def _ldap_bind_indirect(self, ldap, con) -> None:",
            "        \"\"\"",
            "        Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        \"\"\"",
            "        # always check AUTH_LDAP_BIND_USER is set before calling this method",
            "        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"",
            "",
            "        try:",
            "            log.debug(",
            "                \"LDAP bind indirect TRY with username: '{0}'\".format(",
            "                    self.auth_ldap_bind_user",
            "                )",
            "            )",
            "            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)",
            "            log.debug(",
            "                \"LDAP bind indirect SUCCESS with username: '{0}'\".format(",
            "                    self.auth_ldap_bind_user",
            "                )",
            "            )",
            "        except ldap.INVALID_CREDENTIALS as ex:",
            "            log.error(",
            "                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"",
            "                \" not valid LDAP bind credentials\"",
            "            )",
            "            raise ex",
            "",
            "    @staticmethod",
            "    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:",
            "        \"\"\"",
            "        Validates/binds the provided dn/password with the LDAP sever.",
            "        \"\"\"",
            "        try:",
            "            log.debug(\"LDAP bind TRY with username: '{0}'\".format(dn))",
            "            con.simple_bind_s(dn, password)",
            "            log.debug(\"LDAP bind SUCCESS with username: '{0}'\".format(dn))",
            "            return True",
            "        except ldap.INVALID_CREDENTIALS:",
            "            return False",
            "",
            "    @staticmethod",
            "    def ldap_extract(",
            "        ldap_dict: Dict[str, bytes], field_name: str, fallback: str",
            "    ) -> str:",
            "        raw_value = ldap_dict.get(field_name, [bytes()])",
            "        # decode - if empty string, default to fallback, otherwise take first element",
            "        return raw_value[0].decode(\"utf-8\") or fallback",
            "",
            "    @staticmethod",
            "    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:",
            "        raw_list = ldap_dict.get(field_name, [])",
            "        # decode - removing empty strings",
            "        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]",
            "",
            "    def auth_user_ldap(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user with LDAP.",
            "",
            "        NOTE: this depends on python-ldap module",
            "",
            "        :param username: the username",
            "        :param password: the password",
            "        \"\"\"",
            "        # If no username is provided, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Ensure python-ldap is installed",
            "        try:",
            "            import ldap",
            "        except ImportError:",
            "            log.error(\"python-ldap library is not installed\")",
            "            return None",
            "",
            "        try:",
            "            # LDAP certificate settings",
            "            if self.auth_ldap_tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)",
            "            if self.auth_ldap_tls_cacertfile:",
            "                ldap.set_option(",
            "                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile",
            "                )",
            "            if self.auth_ldap_tls_certfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)",
            "            if self.auth_ldap_tls_keyfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)",
            "            if self.auth_ldap_allow_self_signed:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "            elif self.auth_ldap_tls_demand:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "",
            "            # Initialise LDAP connection",
            "            con = ldap.initialize(self.auth_ldap_server)",
            "            con.set_option(ldap.OPT_REFERRALS, 0)",
            "            if self.auth_ldap_use_tls:",
            "                try:",
            "                    con.start_tls_s()",
            "                except Exception:",
            "                    log.error(",
            "                        LOGMSG_ERR_SEC_AUTH_LDAP_TLS.format(self.auth_ldap_server)",
            "                    )",
            "                    return None",
            "",
            "            # Define variables, so we can check if they are set in later steps",
            "            user_dn = None",
            "            user_attributes = {}",
            "",
            "            # Flow 1 - (Indirect Search Bind):",
            "            #  - in this flow, special bind credentials are used to preform the",
            "            #    LDAP search",
            "            #  - in this flow, AUTH_LDAP_SEARCH must be set",
            "            if self.auth_ldap_bind_user:",
            "                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD",
            "                # (authorizes for LDAP search)",
            "                self._ldap_bind_indirect(ldap, con)",
            "",
            "                # Search for `username`",
            "                #  - returns the `user_dn` needed for binding to validate credentials",
            "                #  - returns the `user_attributes` needed for",
            "                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "                else:",
            "                    log.error(",
            "                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"",
            "                    )",
            "                    return None",
            "",
            "                # If search failed, go away",
            "                if user_dn is None:",
            "                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))",
            "                    return None",
            "",
            "                # Bind with user_dn/password (validates credentials)",
            "                if not self._ldap_bind(ldap, con, user_dn, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "                    return None",
            "",
            "            # Flow 2 - (Direct Search Bind):",
            "            #  - in this flow, the credentials provided by the end-user are used",
            "            #    to preform the LDAP search",
            "            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set",
            "            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN",
            "            #       will only work if AUTH_LDAP_SEARCH is set",
            "            else:",
            "                # Copy the provided username (so we can apply formatters)",
            "                bind_username = username",
            "",
            "                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN",
            "                #  - for Microsoft AD, which allows binding with userPrincipalName",
            "                if self.auth_ldap_append_domain:",
            "                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain",
            "",
            "                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT",
            "                #  - for transforming the username into a DN,",
            "                #    for example: \"uid=%s,ou=example,o=test\"",
            "                if self.auth_ldap_username_format:",
            "                    bind_username = self.auth_ldap_username_format % bind_username",
            "",
            "                # Bind with bind_username/password",
            "                # (validates credentials & authorizes for LDAP search)",
            "                if not self._ldap_bind(ldap, con, bind_username, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(bind_username))",
            "                    return None",
            "",
            "                # Search for `username` (if AUTH_LDAP_SEARCH is set)",
            "                #  - returns the `user_attributes`",
            "                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                #  - we search on `username` not `bind_username`,",
            "                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT",
            "                #    would result in an invalid search filter",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "",
            "                    # If search failed, go away",
            "                    if user_dn is None:",
            "                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))",
            "                        return None",
            "",
            "            # Sync the user's roles",
            "            if user and user_attributes and self.auth_roles_sync_at_login:",
            "                user.roles = self._ldap_calculate_user_roles(user_attributes)",
            "                log.debug(",
            "                    \"Calculated new roles for user='{0}' as: {1}\".format(",
            "                        user_dn, user.roles",
            "                    )",
            "                )",
            "",
            "            # If the user is new, register them",
            "            if (not user) and user_attributes and self.auth_user_registration:",
            "                user = self.add_user(",
            "                    username=username,",
            "                    first_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_firstname_field, \"\"",
            "                    ),",
            "                    last_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_lastname_field, \"\"",
            "                    ),",
            "                    email=self.ldap_extract(",
            "                        user_attributes,",
            "                        self.auth_ldap_email_field,",
            "                        f\"{username}@email.notfound\",",
            "                    ),",
            "                    role=self._ldap_calculate_user_roles(user_attributes),",
            "                )",
            "                log.debug(\"New user registered: {0}\".format(user))",
            "",
            "                # If user registration failed, go away",
            "                if not user:",
            "                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER.format(username))",
            "                    return None",
            "",
            "            # LOGIN SUCCESS (only if user is now registered)",
            "            if user:",
            "                self.update_user_auth_stat(user)",
            "                return user",
            "            else:",
            "                return None",
            "",
            "        except ldap.LDAPError as e:",
            "            msg = None",
            "            if isinstance(e, dict):",
            "                msg = getattr(e, \"message\", None)",
            "            if (msg is not None) and (\"desc\" in msg):",
            "                log.error(LOGMSG_ERR_SEC_AUTH_LDAP.format(e.message[\"desc\"]))",
            "                return None",
            "            else:",
            "                log.error(e)",
            "                return None",
            "",
            "    def auth_user_oid(self, email):",
            "        \"\"\"",
            "        OpenID user Authentication",
            "",
            "        :param email: user's email to authenticate",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(email=email)",
            "        if user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(email))",
            "            return None",
            "        else:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "",
            "    def auth_user_remote_user(self, username):",
            "        \"\"\"",
            "        REMOTE_USER user Authentication",
            "",
            "        :param username: user's username for remote auth",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(username=username)",
            "",
            "        # User does not exist, create one if auto user registration.",
            "        if user is None and self.auth_user_registration:",
            "            user = self.add_user(",
            "                # All we have is REMOTE_USER, so we set",
            "                # the other fields to blank.",
            "                username=username,",
            "                first_name=username,",
            "                last_name=\"-\",",
            "                email=username + \"@email.notfound\",",
            "                role=self.find_role(self.auth_user_registration_role),",
            "            )",
            "",
            "        # If user does not exist on the DB and not auto user registration,",
            "        # or user is inactive, go away.",
            "        elif user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))",
            "            return None",
            "",
            "        self.update_user_auth_stat(user)",
            "        return user",
            "",
            "    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = userinfo.get(\"role_keys\", [])",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION_ROLE",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,",
            "            # use it for the registration role",
            "            if self.auth_user_registration_role_jmespath:",
            "                import jmespath",
            "",
            "                registration_role_name = jmespath.search(",
            "                    self.auth_user_registration_role_jmespath, userinfo",
            "                )",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(",
            "                        registration_role_name",
            "                    )",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def auth_user_oauth(self, userinfo):",
            "        \"\"\"",
            "        Method for authenticating user with OAuth.",
            "",
            "        :userinfo: dict with user information",
            "                   (keys are the same as User model columns)",
            "        \"\"\"",
            "        # extract the username from `userinfo`",
            "        if \"username\" in userinfo:",
            "            username = userinfo[\"username\"]",
            "        elif \"email\" in userinfo:",
            "            username = userinfo[\"email\"]",
            "        else:",
            "            log.error(",
            "                \"OAUTH userinfo does not have username or email {0}\".format(userinfo)",
            "            )",
            "            return None",
            "",
            "        # If username is empty, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Sync the user's roles",
            "        if user and self.auth_roles_sync_at_login:",
            "            user.roles = self._oauth_calculate_user_roles(userinfo)",
            "            log.debug(",
            "                \"Calculated new roles for user='{0}' as: {1}\".format(",
            "                    username, user.roles",
            "                )",
            "            )",
            "",
            "        # If the user is new, register them",
            "        if (not user) and self.auth_user_registration:",
            "            user = self.add_user(",
            "                username=username,",
            "                first_name=userinfo.get(\"first_name\", \"\"),",
            "                last_name=userinfo.get(\"last_name\", \"\"),",
            "                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",",
            "                role=self._oauth_calculate_user_roles(userinfo),",
            "            )",
            "            log.debug(\"New user registered: {0}\".format(user))",
            "",
            "            # If user registration failed, go away",
            "            if not user:",
            "                log.error(\"Error creating a new OAuth user {0}\".format(username))",
            "                return None",
            "",
            "        # LOGIN SUCCESS (only if user is now registered)",
            "        if user:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "        else:",
            "            return None",
            "",
            "    \"\"\"",
            "        ----------------------------------------",
            "            PERMISSION ACCESS CHECK",
            "        ----------------------------------------",
            "    \"\"\"",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        permissions = self.get_public_permissions()",
            "        if permissions:",
            "            for i in permissions:",
            "                if (view_name == i.view_menu.name) and (",
            "                    permission_name == i.permission.name",
            "                ):",
            "                    return True",
            "            return False",
            "        else:",
            "            return False",
            "",
            "    def _has_access_builtin_roles(",
            "        self, role, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        \"\"\"",
            "        Checks permission on builtin role",
            "        \"\"\"",
            "        builtin_pvms = self.builtin_roles.get(role.name, [])",
            "        for pvm in builtin_pvms:",
            "            _view_name = pvm[0]",
            "            _permission_name = pvm[1]",
            "            if re.match(_view_name, view_name) and re.match(",
            "                _permission_name, permission_name",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def _has_view_access(",
            "        self, user: object, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        roles = user.roles",
            "        db_role_ids = list()",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                if self._has_access_builtin_roles(role, permission_name, view_name):",
            "                    return True",
            "            else:",
            "                db_role_ids.append(role.id)",
            "",
            "        # If it's not a builtin role check against database store roles",
            "        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)",
            "",
            "    def get_user_roles(self, user) -> List[object]:",
            "        \"\"\"",
            "        Get current user roles, if user is not authenticated returns the public role",
            "        \"\"\"",
            "        if not user.is_authenticated:",
            "            return [self.get_public_role()]",
            "        return user.roles",
            "",
            "    def get_user_roles_permissions(self, user) -> Dict[str, List[Tuple[str, str]]]:",
            "        \"\"\"",
            "        Utility method just implemented for SQLAlchemy.",
            "        Take a look to: flask_appbuilder.security.sqla.manager",
            "        :param user:",
            "        :return:",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions for a certain role",
            "        \"\"\"",
            "        result = set()",
            "        if role.name in self.builtin_roles:",
            "            for permission in self.builtin_roles[role.name]:",
            "                result.add((permission[1], permission[0]))",
            "        else:",
            "            for permission in self.get_db_role_permissions(role.id):",
            "                result.add((permission.permission.name, permission.view_menu.name))",
            "        return result",
            "",
            "    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions from the current user",
            "        \"\"\"",
            "        roles = self.get_user_roles(user)",
            "        result = set()",
            "        for role in roles:",
            "            result.update(self.get_role_permissions(role))",
            "        return result",
            "",
            "    def _get_user_permission_view_menus(",
            "        self, user: object, permission_name: str, view_menus_name: List[str]",
            "    ) -> Set[str]:",
            "        \"\"\"",
            "        Return a set of view menu names with a certain permission name",
            "        that a user has access to. Mainly used to fetch all menu permissions",
            "        on a single db call, will also check public permissions and builtin roles",
            "        \"\"\"",
            "        db_role_ids = list()",
            "        if user is None:",
            "            # include public role",
            "            roles = [self.get_public_role()]",
            "        else:",
            "            roles = user.roles",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        result = set()",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                for view_menu_name in view_menus_name:",
            "                    if self._has_access_builtin_roles(",
            "                        role, permission_name, view_menu_name",
            "                    ):",
            "                        result.add(view_menu_name)",
            "            else:",
            "                db_role_ids.append(role.id)",
            "        # Then check against database-stored roles",
            "        pvms_names = [",
            "            pvm.view_menu.name",
            "            for pvm in self.find_roles_permission_view_menus(",
            "                permission_name, db_role_ids",
            "            )",
            "        ]",
            "        result.update(pvms_names)",
            "        return result",
            "",
            "    def has_access(self, permission_name: str, view_name: str) -> bool:",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        if current_user.is_authenticated:",
            "            return self._has_view_access(g.user, permission_name, view_name)",
            "        elif current_user_jwt:",
            "            return self._has_view_access(current_user_jwt, permission_name, view_name)",
            "        else:",
            "            return self.is_item_public(permission_name, view_name)",
            "",
            "    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:",
            "        if current_user.is_authenticated:",
            "            return self._get_user_permission_view_menus(",
            "                g.user, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        elif current_user_jwt:",
            "            return self._get_user_permission_view_menus(",
            "                current_user_jwt, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        else:",
            "            return self._get_user_permission_view_menus(",
            "                None, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "",
            "    def add_limit_view(self, baseview):",
            "        if not baseview.limits:",
            "            return",
            "",
            "        for limit in baseview.limits:",
            "            self.limiter.limit(",
            "                limit_value=limit.limit_value,",
            "                key_func=limit.key_func,",
            "                per_method=limit.per_method,",
            "                methods=limit.methods,",
            "                error_message=limit.error_message,",
            "                exempt_when=limit.exempt_when,",
            "                override_defaults=limit.override_defaults,",
            "                deduct_when=limit.deduct_when,",
            "                on_breach=limit.on_breach,",
            "                cost=limit.cost,",
            "            )(baseview.blueprint)",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        view_menu_db = self.add_view_menu(view_menu)",
            "        perm_views = self.find_permissions_view_menu(view_menu_db)",
            "",
            "        if not perm_views:",
            "            # No permissions yet on this view",
            "            for permission in base_permissions:",
            "                pv = self.add_permission_view_menu(permission, view_menu)",
            "                if self.auth_role_admin not in self.builtin_roles:",
            "                    role_admin = self.find_role(self.auth_role_admin)",
            "                    self.add_permission_role(role_admin, pv)",
            "        else:",
            "            # Permissions on this view exist but....",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            for permission in base_permissions:",
            "                # Check if base view permissions exist",
            "                if not self.exist_permission_on_views(perm_views, permission):",
            "                    pv = self.add_permission_view_menu(permission, view_menu)",
            "                    if self.auth_role_admin not in self.builtin_roles:",
            "                        self.add_permission_role(role_admin, pv)",
            "            for perm_view in perm_views:",
            "                if perm_view.permission is None:",
            "                    # Skip this perm_view, it has a null permission",
            "                    continue",
            "                if perm_view.permission.name not in base_permissions:",
            "                    # perm to delete",
            "                    roles = self.get_all_roles()",
            "                    perm = self.find_permission(perm_view.permission.name)",
            "                    # del permission from all roles",
            "                    for role in roles:",
            "                        self.del_permission_role(role, perm)",
            "                    self.del_permission_view_menu(perm_view.permission.name, view_menu)",
            "                elif (",
            "                    self.auth_role_admin not in self.builtin_roles",
            "                    and perm_view not in role_admin.permissions",
            "                ):",
            "                    # Role Admin must have all permissions",
            "                    self.add_permission_role(role_admin, perm_view)",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        self.add_view_menu(view_menu_name)",
            "        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if not pv:",
            "            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            self.add_permission_role(role_admin, pv)",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        \"\"\"",
            "        Will cleanup all unused permissions from the database",
            "",
            "        :param baseviews: A list of BaseViews class",
            "        :param menus: Menu class",
            "        \"\"\"",
            "        viewsmenus = self.get_all_view_menu()",
            "        roles = self.get_all_roles()",
            "        for viewmenu in viewsmenus:",
            "            found = False",
            "            for baseview in baseviews:",
            "                if viewmenu.name == baseview.class_permission_name:",
            "                    found = True",
            "                    break",
            "            if menus.find(viewmenu.name):",
            "                found = True",
            "            if not found:",
            "                permissions = self.find_permissions_view_menu(viewmenu)",
            "                for permission in permissions:",
            "                    for role in roles:",
            "                        self.del_permission_role(role, permission)",
            "                    self.del_permission_view_menu(",
            "                        permission.permission.name, viewmenu.name",
            "                    )",
            "                self.del_view_menu(viewmenu.name)",
            "        self.security_converge(baseviews, menus)",
            "",
            "    @staticmethod",
            "    def _get_new_old_permissions(baseview) -> Dict:",
            "        ret = dict()",
            "        for method_name, permission_name in baseview.method_permission_name.items():",
            "            old_permission_name = baseview.previous_method_permission_name.get(",
            "                method_name",
            "            )",
            "            # Actions do not get prefix when normally defined",
            "            if hasattr(baseview, \"actions\") and baseview.actions.get(",
            "                old_permission_name",
            "            ):",
            "                permission_prefix = \"\"",
            "            else:",
            "                permission_prefix = PERMISSION_PREFIX",
            "            if old_permission_name:",
            "                if PERMISSION_PREFIX + permission_name not in ret:",
            "                    ret[PERMISSION_PREFIX + permission_name] = {",
            "                        permission_prefix + old_permission_name",
            "                    }",
            "                else:",
            "                    ret[PERMISSION_PREFIX + permission_name].add(",
            "                        permission_prefix + old_permission_name",
            "                    )",
            "        return ret",
            "",
            "    @staticmethod",
            "    def _add_state_transition(",
            "        state_transition: Dict,",
            "        old_view_name: str,",
            "        old_perm_name: str,",
            "        view_name: str,",
            "        perm_name: str,",
            "    ) -> None:",
            "        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))",
            "        if old_pvm:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)].add(",
            "                (view_name, perm_name)",
            "            )",
            "        else:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)] = {",
            "                (view_name, perm_name)",
            "            }",
            "        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))",
            "        state_transition[\"del_views\"].add(old_view_name)",
            "        state_transition[\"del_perms\"].add(old_perm_name)",
            "",
            "    @staticmethod",
            "    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:",
            "        \"\"\"",
            "        Mutates state_transitions, loop baseviews and prunes all",
            "        views and permissions that are not to delete because references",
            "        exist.",
            "",
            "        :param baseview:",
            "        :param state_transitions:",
            "        :return:",
            "        \"\"\"",
            "        for baseview in baseviews:",
            "            state_transitions[\"del_views\"].discard(baseview.class_permission_name)",
            "            for permission in baseview.base_permissions:",
            "                state_transitions[\"del_role_pvm\"].discard(",
            "                    (baseview.class_permission_name, permission)",
            "                )",
            "                state_transitions[\"del_perms\"].discard(permission)",
            "",
            "    def create_state_transitions(",
            "        self, baseviews: List, menus: Optional[List[Any]]",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Creates a Dict with all the necessary vm/permission transitions",
            "",
            "        Dict: {",
            "                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}",
            "                \"del_role_pvm\": ((<VM>, <PERM>), ...)",
            "                \"del_views\": (<VM>, ... )",
            "                \"del_perms\": (<PERM>, ... )",
            "              }",
            "",
            "        :param baseviews: List with all the registered BaseView, BaseApi",
            "        :param menus: List with all the menu entries",
            "        :return: Dict with state transitions",
            "        \"\"\"",
            "        state_transitions = {",
            "            \"add\": {},",
            "            \"del_role_pvm\": set(),",
            "            \"del_views\": set(),",
            "            \"del_perms\": set(),",
            "        }",
            "        for baseview in baseviews:",
            "            add_all_flag = False",
            "            new_view_name = baseview.class_permission_name",
            "            permission_mapping = self._get_new_old_permissions(baseview)",
            "            if baseview.previous_class_permission_name:",
            "                old_view_name = baseview.previous_class_permission_name",
            "                add_all_flag = True",
            "            else:",
            "                new_view_name = baseview.class_permission_name",
            "                old_view_name = new_view_name",
            "            for new_perm_name in baseview.base_permissions:",
            "                if add_all_flag:",
            "                    old_perm_names = permission_mapping.get(new_perm_name)",
            "                    old_perm_names = old_perm_names or (new_perm_name,)",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "                else:",
            "                    old_perm_names = permission_mapping.get(new_perm_name) or set()",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "        self._update_del_transitions(state_transitions, baseviews)",
            "        return state_transitions",
            "",
            "    def security_converge(",
            "        self, baseviews: List, menus: Optional[List[Any]], dry=False",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Converges overridden permissions on all registered views/api",
            "        will compute all necessary operations from `class_permissions_name`,",
            "        `previous_class_permission_name`, method_permission_name`,",
            "        `previous_method_permission_name` class attributes.",
            "",
            "        :param baseviews: List of registered views/apis",
            "        :param menus: List of menu items",
            "        :param dry: If True will not change DB",
            "        :return: Dict with the necessary operations (state_transitions)",
            "        \"\"\"",
            "        state_transitions = self.create_state_transitions(baseviews, menus)",
            "        if dry:",
            "            return state_transitions",
            "        if not state_transitions:",
            "            log.info(\"No state transitions found\")",
            "            return dict()",
            "        log.debug(f\"State transitions: {state_transitions}\")",
            "        roles = self.get_all_roles()",
            "        for role in roles:",
            "            permissions = list(role.permissions)",
            "            for pvm in permissions:",
            "                new_pvm_states = state_transitions[\"add\"].get(",
            "                    (pvm.view_menu.name, pvm.permission.name)",
            "                )",
            "                if not new_pvm_states:",
            "                    continue",
            "                for new_pvm_state in new_pvm_states:",
            "                    new_pvm = self.add_permission_view_menu(",
            "                        new_pvm_state[1], new_pvm_state[0]",
            "                    )",
            "                    self.add_permission_role(role, new_pvm)",
            "                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[",
            "                    \"del_role_pvm\"",
            "                ]:",
            "                    self.del_permission_role(role, pvm)",
            "        for pvm in state_transitions[\"del_role_pvm\"]:",
            "            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)",
            "        for view_name in state_transitions[\"del_views\"]:",
            "            self.del_view_menu(view_name)",
            "        for permission_name in state_transitions[\"del_perms\"]:",
            "            self.del_permission(permission_name)",
            "        return state_transitions",
            "",
            "    \"\"\"",
            "     ---------------------------",
            "     INTERFACE ABSTRACT METHODS",
            "     ---------------------------",
            "",
            "     ---------------------",
            "     PRIMITIVES FOR USERS",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_register_user(self, registration_hash):",
            "        \"\"\"",
            "        Generic function to return user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_register_user(",
            "        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"",
            "    ):",
            "        \"\"\"",
            "        Generic function to add user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_register_user(self, register_user):",
            "        \"\"\"",
            "        Generic function to delete user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_user_by_id(self, pk):",
            "        \"\"\"",
            "        Generic function to return user by it's id (pk)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_user(self, username=None, email=None):",
            "        \"\"\"",
            "        Generic function find a user by it's username or email",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_users(self):",
            "        \"\"\"",
            "        Generic function that returns all existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_db_role_permissions(self, role_id: int) -> List[object]:",
            "        \"\"\"",
            "        Get all DB permissions from a role id",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_user(self, username, first_name, last_name, email, role, password=\"\"):",
            "        \"\"\"",
            "        Generic function to create user",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def update_user(self, user):",
            "        \"\"\"",
            "        Generic function to update user",
            "",
            "        :param user: User model to update to database",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def count_users(self):",
            "        \"\"\"",
            "        Generic function to count the existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES FOR ROLES",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_role(self, name):",
            "        raise NotImplementedError",
            "",
            "    def add_role(self, name, permissions=None):",
            "        raise NotImplementedError",
            "",
            "    def update_role(self, pk, name):",
            "        raise NotImplementedError",
            "",
            "    def get_all_roles(self):",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------------",
            "     PRIMITIVES FOR PERMISSIONS",
            "    ----------------------------",
            "    \"\"\"",
            "",
            "    def get_public_role(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_public_permissions(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permission(self, name):",
            "        \"\"\"",
            "        Finds and returns a Permission by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_roles_permission_view_menus(",
            "        self, permission_name: str, role_ids: List[int]",
            "    ):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_roles(",
            "        self, view_name: str, permission_name: str, role_ids: List[int]",
            "    ) -> bool:",
            "        \"\"\"",
            "        Finds and returns permission views for a group of roles",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission(self, name):",
            "        \"\"\"",
            "        Adds a permission to the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission(self, name):",
            "        \"\"\"",
            "        Deletes a permission from the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_view_menu(self, name):",
            "        \"\"\"",
            "        Finds and returns a ViewMenu by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_view_menu(self):",
            "        raise NotImplementedError",
            "",
            "    def add_view_menu(self, name):",
            "        \"\"\"",
            "        Adds a view or menu to the backend, model view_menu",
            "        param name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_view_menu(self, name):",
            "        \"\"\"",
            "        Deletes a ViewMenu from the backend",
            "",
            "        :param name:",
            "            name of the ViewMenu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PERMISSION VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Finds and returns a PermissionView by names",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permissions_view_menu(self, view_menu):",
            "        \"\"\"",
            "        Finds all permissions from ViewMenu, returns list of PermissionView",
            "",
            "        :param view_menu: ViewMenu object",
            "        :return: list of PermissionView objects",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Adds a permission on a view or menu to the backend",
            "",
            "        :param permission_name:",
            "            name of the permission to add: 'can_add','can_edit' etc...",
            "        :param view_menu_name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_views(self, lst, item):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_view(self, lst, permission, view_menu):",
            "        raise NotImplementedError",
            "",
            "    def add_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Add permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Remove permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def export_roles(",
            "        self, path: Optional[str] = None, indent: Optional[Union[int, str]] = None",
            "    ) -> None:",
            "        \"\"\"Exports roles to JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def import_roles(self, path: str) -> None:",
            "        \"\"\"Imports roles from JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_user(self, pk):",
            "        return self.get_user_by_id(int(pk))",
            "",
            "    def load_user_jwt(self, _jwt_header, jwt_data):",
            "        identity = jwt_data[\"sub\"]",
            "        user = self.load_user(identity)",
            "        # Set flask g.user to JWT user, we can't do it on before request",
            "        g.user = user",
            "        return user",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        g.user = current_user"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": []
        },
        "addLocation": []
    }
}