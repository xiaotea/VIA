{
    "xdg/BaseDirectory.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " Note: see the rox.Options module for a higher-level API for managing options."
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import os"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+import os, stat"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " _home = os.path.expanduser('~')"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " xdg_data_home = os.environ.get('XDG_DATA_HOME') or \\"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         "
            },
            "9": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         import getpass"
            },
            "10": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         fallback = '/tmp/pyxdg-runtime-dir-fallback-' + getpass.getuser()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        create = False"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         try:"
            },
            "14": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            os.mkdir(fallback, 0o700)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            # This must be a real directory, not a symlink, so attackers can't"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            # point it elsewhere. So we use lstat to check it."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            st = os.lstat(fallback)"
            },
            "18": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         except OSError as e:"
            },
            "19": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             import errno"
            },
            "20": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if e.errno == errno.EEXIST:"
            },
            "21": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Already exists - set 700 permissions again."
            },
            "22": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                import stat"
            },
            "23": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                os.chmod(fallback, stat.S_IRUSR|stat.S_IWUSR|stat.S_IXUSR)"
            },
            "24": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else: # pragma: no cover"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            if e.errno == errno.ENOENT:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+                create = True"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            else:"
            },
            "28": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                 raise"
            },
            "29": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        else:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            # The fallback must be a directory"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            if not stat.S_ISDIR(st.st_mode):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                os.unlink(fallback)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                create = True"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            # Must be owned by the user and not accessible by anyone else"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            elif (st.st_uid != os.getuid()) \\"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+              or (st.st_mode & (stat.S_IRWXG | stat.S_IRWXO)):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                os.rmdir(fallback)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                create = True"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        if create:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            os.mkdir(fallback, 0o700)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         return fallback"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "This module is based on a rox module (LGPL):",
            "",
            "http://cvs.sourceforge.net/viewcvs.py/rox/ROX-Lib2/python/rox/basedir.py?rev=1.9&view=log",
            "",
            "The freedesktop.org Base Directory specification provides a way for",
            "applications to locate shared data and configuration:",
            "",
            "    http://standards.freedesktop.org/basedir-spec/",
            "",
            "(based on version 0.6)",
            "",
            "This module can be used to load and save from and to these directories.",
            "",
            "Typical usage:",
            "",
            "    from rox import basedir",
            "    ",
            "    for dir in basedir.load_config_paths('mydomain.org', 'MyProg', 'Options'):",
            "        print \"Load settings from\", dir",
            "",
            "    dir = basedir.save_config_path('mydomain.org', 'MyProg')",
            "    print >>file(os.path.join(dir, 'Options'), 'w'), \"foo=2\"",
            "",
            "Note: see the rox.Options module for a higher-level API for managing options.",
            "\"\"\"",
            "",
            "import os",
            "",
            "_home = os.path.expanduser('~')",
            "xdg_data_home = os.environ.get('XDG_DATA_HOME') or \\",
            "            os.path.join(_home, '.local', 'share')",
            "",
            "xdg_data_dirs = [xdg_data_home] + \\",
            "    (os.environ.get('XDG_DATA_DIRS') or '/usr/local/share:/usr/share').split(':')",
            "",
            "xdg_config_home = os.environ.get('XDG_CONFIG_HOME') or \\",
            "            os.path.join(_home, '.config')",
            "",
            "xdg_config_dirs = [xdg_config_home] + \\",
            "    (os.environ.get('XDG_CONFIG_DIRS') or '/etc/xdg').split(':')",
            "",
            "xdg_cache_home = os.environ.get('XDG_CACHE_HOME') or \\",
            "            os.path.join(_home, '.cache')",
            "",
            "xdg_data_dirs = [x for x in xdg_data_dirs if x]",
            "xdg_config_dirs = [x for x in xdg_config_dirs if x]",
            "",
            "def save_config_path(*resource):",
            "    \"\"\"Ensure ``$XDG_CONFIG_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application. Use this",
            "    when saving configuration settings.",
            "    \"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_config_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path, 0o700)",
            "    return path",
            "",
            "def save_data_path(*resource):",
            "    \"\"\"Ensure ``$XDG_DATA_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application or a shared",
            "    resource. Use this when saving or updating application data.",
            "    \"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_data_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path)",
            "    return path",
            "",
            "def save_cache_path(*resource):",
            "    \"\"\"Ensure ``$XDG_CACHE_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application or a shared",
            "    resource.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_cache_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path)",
            "    return path",
            "",
            "def load_config_paths(*resource):",
            "    \"\"\"Returns an iterator which gives each directory named 'resource' in the",
            "    configuration search path. Information provided by earlier directories should",
            "    take precedence over later ones, and the user-specific config dir comes",
            "    first.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    for config_dir in xdg_config_dirs:",
            "        path = os.path.join(config_dir, resource)",
            "        if os.path.exists(path): yield path",
            "",
            "def load_first_config(*resource):",
            "    \"\"\"Returns the first result from load_config_paths, or None if there is nothing",
            "    to load.\"\"\"",
            "    for x in load_config_paths(*resource):",
            "        return x",
            "    return None",
            "",
            "def load_data_paths(*resource):",
            "    \"\"\"Returns an iterator which gives each directory named 'resource' in the",
            "    application data search path. Information provided by earlier directories",
            "    should take precedence over later ones.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    for data_dir in xdg_data_dirs:",
            "        path = os.path.join(data_dir, resource)",
            "        if os.path.exists(path): yield path",
            "",
            "def get_runtime_dir(strict=True):",
            "    \"\"\"Returns the value of $XDG_RUNTIME_DIR, a directory path.",
            "    ",
            "    This directory is intended for 'user-specific non-essential runtime files",
            "    and other file objects (such as sockets, named pipes, ...)', and",
            "    'communication and synchronization purposes'.",
            "    ",
            "    As of late 2012, only quite new systems set $XDG_RUNTIME_DIR. If it is not",
            "    set, with ``strict=True`` (the default), a KeyError is raised. With ",
            "    ``strict=False``, PyXDG will create a fallback under /tmp for the current",
            "    user. This fallback does *not* provide the same guarantees as the",
            "    specification requires for the runtime directory.",
            "    ",
            "    The strict default is deliberately conservative, so that application",
            "    developers can make a conscious decision to allow the fallback.",
            "    \"\"\"",
            "    try:",
            "        return os.environ['XDG_RUNTIME_DIR']",
            "    except KeyError:",
            "        if strict:",
            "            raise",
            "        ",
            "        import getpass",
            "        fallback = '/tmp/pyxdg-runtime-dir-fallback-' + getpass.getuser()",
            "        try:",
            "            os.mkdir(fallback, 0o700)",
            "        except OSError as e:",
            "            import errno",
            "            if e.errno == errno.EEXIST:",
            "                # Already exists - set 700 permissions again.",
            "                import stat",
            "                os.chmod(fallback, stat.S_IRUSR|stat.S_IWUSR|stat.S_IXUSR)",
            "            else: # pragma: no cover",
            "                raise",
            "        ",
            "        return fallback"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "This module is based on a rox module (LGPL):",
            "",
            "http://cvs.sourceforge.net/viewcvs.py/rox/ROX-Lib2/python/rox/basedir.py?rev=1.9&view=log",
            "",
            "The freedesktop.org Base Directory specification provides a way for",
            "applications to locate shared data and configuration:",
            "",
            "    http://standards.freedesktop.org/basedir-spec/",
            "",
            "(based on version 0.6)",
            "",
            "This module can be used to load and save from and to these directories.",
            "",
            "Typical usage:",
            "",
            "    from rox import basedir",
            "    ",
            "    for dir in basedir.load_config_paths('mydomain.org', 'MyProg', 'Options'):",
            "        print \"Load settings from\", dir",
            "",
            "    dir = basedir.save_config_path('mydomain.org', 'MyProg')",
            "    print >>file(os.path.join(dir, 'Options'), 'w'), \"foo=2\"",
            "",
            "Note: see the rox.Options module for a higher-level API for managing options.",
            "\"\"\"",
            "",
            "import os, stat",
            "",
            "_home = os.path.expanduser('~')",
            "xdg_data_home = os.environ.get('XDG_DATA_HOME') or \\",
            "            os.path.join(_home, '.local', 'share')",
            "",
            "xdg_data_dirs = [xdg_data_home] + \\",
            "    (os.environ.get('XDG_DATA_DIRS') or '/usr/local/share:/usr/share').split(':')",
            "",
            "xdg_config_home = os.environ.get('XDG_CONFIG_HOME') or \\",
            "            os.path.join(_home, '.config')",
            "",
            "xdg_config_dirs = [xdg_config_home] + \\",
            "    (os.environ.get('XDG_CONFIG_DIRS') or '/etc/xdg').split(':')",
            "",
            "xdg_cache_home = os.environ.get('XDG_CACHE_HOME') or \\",
            "            os.path.join(_home, '.cache')",
            "",
            "xdg_data_dirs = [x for x in xdg_data_dirs if x]",
            "xdg_config_dirs = [x for x in xdg_config_dirs if x]",
            "",
            "def save_config_path(*resource):",
            "    \"\"\"Ensure ``$XDG_CONFIG_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application. Use this",
            "    when saving configuration settings.",
            "    \"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_config_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path, 0o700)",
            "    return path",
            "",
            "def save_data_path(*resource):",
            "    \"\"\"Ensure ``$XDG_DATA_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application or a shared",
            "    resource. Use this when saving or updating application data.",
            "    \"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_data_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path)",
            "    return path",
            "",
            "def save_cache_path(*resource):",
            "    \"\"\"Ensure ``$XDG_CACHE_HOME/<resource>/`` exists, and return its path.",
            "    'resource' should normally be the name of your application or a shared",
            "    resource.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    assert not resource.startswith('/')",
            "    path = os.path.join(xdg_cache_home, resource)",
            "    if not os.path.isdir(path):",
            "        os.makedirs(path)",
            "    return path",
            "",
            "def load_config_paths(*resource):",
            "    \"\"\"Returns an iterator which gives each directory named 'resource' in the",
            "    configuration search path. Information provided by earlier directories should",
            "    take precedence over later ones, and the user-specific config dir comes",
            "    first.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    for config_dir in xdg_config_dirs:",
            "        path = os.path.join(config_dir, resource)",
            "        if os.path.exists(path): yield path",
            "",
            "def load_first_config(*resource):",
            "    \"\"\"Returns the first result from load_config_paths, or None if there is nothing",
            "    to load.\"\"\"",
            "    for x in load_config_paths(*resource):",
            "        return x",
            "    return None",
            "",
            "def load_data_paths(*resource):",
            "    \"\"\"Returns an iterator which gives each directory named 'resource' in the",
            "    application data search path. Information provided by earlier directories",
            "    should take precedence over later ones.\"\"\"",
            "    resource = os.path.join(*resource)",
            "    for data_dir in xdg_data_dirs:",
            "        path = os.path.join(data_dir, resource)",
            "        if os.path.exists(path): yield path",
            "",
            "def get_runtime_dir(strict=True):",
            "    \"\"\"Returns the value of $XDG_RUNTIME_DIR, a directory path.",
            "    ",
            "    This directory is intended for 'user-specific non-essential runtime files",
            "    and other file objects (such as sockets, named pipes, ...)', and",
            "    'communication and synchronization purposes'.",
            "    ",
            "    As of late 2012, only quite new systems set $XDG_RUNTIME_DIR. If it is not",
            "    set, with ``strict=True`` (the default), a KeyError is raised. With ",
            "    ``strict=False``, PyXDG will create a fallback under /tmp for the current",
            "    user. This fallback does *not* provide the same guarantees as the",
            "    specification requires for the runtime directory.",
            "    ",
            "    The strict default is deliberately conservative, so that application",
            "    developers can make a conscious decision to allow the fallback.",
            "    \"\"\"",
            "    try:",
            "        return os.environ['XDG_RUNTIME_DIR']",
            "    except KeyError:",
            "        if strict:",
            "            raise",
            "        ",
            "        import getpass",
            "        fallback = '/tmp/pyxdg-runtime-dir-fallback-' + getpass.getuser()",
            "        create = False",
            "",
            "        try:",
            "            # This must be a real directory, not a symlink, so attackers can't",
            "            # point it elsewhere. So we use lstat to check it.",
            "            st = os.lstat(fallback)",
            "        except OSError as e:",
            "            import errno",
            "            if e.errno == errno.ENOENT:",
            "                create = True",
            "            else:",
            "                raise",
            "        else:",
            "            # The fallback must be a directory",
            "            if not stat.S_ISDIR(st.st_mode):",
            "                os.unlink(fallback)",
            "                create = True",
            "            # Must be owned by the user and not accessible by anyone else",
            "            elif (st.st_uid != os.getuid()) \\",
            "              or (st.st_mode & (stat.S_IRWXG | stat.S_IRWXO)):",
            "                os.rmdir(fallback)",
            "                create = True",
            "",
            "        if create:",
            "            os.mkdir(fallback, 0o700)",
            "",
            "        return fallback"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "135": [
                "get_runtime_dir"
            ],
            "138": [
                "get_runtime_dir"
            ],
            "139": [
                "get_runtime_dir"
            ],
            "140": [
                "get_runtime_dir"
            ],
            "141": [
                "get_runtime_dir"
            ],
            "142": [
                "get_runtime_dir"
            ],
            "144": [
                "get_runtime_dir"
            ]
        },
        "addLocation": []
    }
}