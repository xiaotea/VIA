{
    "src/fides/api/common_exceptions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     \"\"\"Exception for when Fides is configured to use an SSH tunnel without config provided.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+class MalisciousUrlException(Exception):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    \"\"\"Fides has detected a potentially maliscious URL.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " class AuthenticationError(HTTPException):"
            },
            "8": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "     \"\"\"To be raised when attempting to fetch an access token using"
            },
            "9": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "     invalid credentials."
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from typing import List",
            "",
            "from fastapi import HTTPException, status",
            "from starlette.status import (",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_404_NOT_FOUND,",
            ")",
            "",
            "from fides.common.api.scope_registry import SCOPE_REGISTRY as SCOPES",
            "",
            "",
            "class FidesopsException(Exception):",
            "    \"\"\"Base class for fidesops exceptions\"\"\"",
            "",
            "    def __init__(self, message: str, errors: List[str] = []):",
            "        super().__init__(message)",
            "        self.message = message",
            "        self.errors = errors",
            "",
            "",
            "class TraversalError(FidesopsException):",
            "    \"\"\"Fidesops error with the names of all nodes that could not be reached.\"\"\"",
            "",
            "",
            "class ValidationError(FidesopsException):",
            "    \"\"\"Data does not pass validation.\"\"\"",
            "",
            "",
            "class StorageUploadError(FidesopsException):",
            "    \"\"\"Data cannot be uploaded to storage destination\"\"\"",
            "",
            "",
            "class SystemManagerException(FidesopsException):",
            "    \"\"\"Exception class when there are errors making a systemmanager\"\"\"",
            "",
            "",
            "class ConnectionException(FidesopsException):",
            "    \"\"\"Exception class when there are errors making a connection\"\"\"",
            "",
            "",
            "class InsufficientDataException(FidesopsException):",
            "    \"\"\"Exception class when there is not sufficient data to proceed\"\"\"",
            "",
            "",
            "class SkippingConsentPropagation(BaseException):",
            "    \"\"\"Skipping consent propagation for collection. Used to trigger \"skipped\" execution logs being created where applicable",
            "    for Privacy Preference requests on saas connectors.",
            "    \"\"\"",
            "",
            "",
            "class RedisConnectionError(Exception):",
            "    \"\"\"The Configured Redis instance is uncontactable.\"\"\"",
            "",
            "",
            "class MisconfiguredPolicyException(Exception):",
            "    \"\"\"Thrown when a Privacy Request cannot be processed due to a misconfigured Policy.\"\"\"",
            "",
            "",
            "class PolicyValidationError(ValueError):",
            "    \"\"\"The policy you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class InvalidDataLengthValidationError(ValueError):",
            "    \"\"\"The length provided is invalid\"\"\"",
            "",
            "",
            "class RuleValidationError(ValueError):",
            "    \"\"\"The Rule you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class StorageConfigValidationError(ValueError):",
            "    \"\"\"The Storage Config you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class InvalidDataTypeValidationError(ValueError):",
            "    \"\"\"The specified data type is invalid.\"\"\"",
            "",
            "",
            "class RuleTargetValidationError(ValueError):",
            "    \"\"\"The Rule you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class DataCategoryNotSupported(ValueError):",
            "    \"\"\"The data category you have supplied is not supported.\"\"\"",
            "",
            "",
            "class PolicyNotFoundException(Exception):",
            "    \"\"\"Policy could not be found\"\"\"",
            "",
            "",
            "class ConnectorNotFoundException(Exception):",
            "    \"\"\"Connector could not be found\"\"\"",
            "",
            "",
            "class DrpActionValidationError(Exception):",
            "    \"\"\"A resource already exists with this DRP Action.\"\"\"",
            "",
            "",
            "class StorageConfigNotFoundException(BaseException):",
            "    \"\"\"Custom Exception - StorageConfig Not Found\"\"\"",
            "",
            "",
            "class PrivacyNoticeHistoryNotFound(BaseException):",
            "    \"\"\"PrivacyNoticeHistory Not Found\"\"\"",
            "",
            "",
            "class IdentityNotFoundException(BaseException):",
            "    \"\"\"Identity Not Found\"\"\"",
            "",
            "",
            "class WebhookOrderException(BaseException):",
            "    \"\"\"Custom Exception - Issue with webhooks order\"\"\"",
            "",
            "",
            "class PostProcessingException(BaseException):",
            "    \"\"\"Custom Exception - Issue with post processing\"\"\"",
            "",
            "",
            "class CollectionDisabled(BaseException):",
            "    \"\"\"Collection is attached to disabled ConnectionConfig\"\"\"",
            "",
            "",
            "class NotSupportedForCollection(BaseException):",
            "    \"\"\"The given action is not supported for this type of collection\"\"\"",
            "",
            "",
            "class PrivacyRequestPaused(BaseException):",
            "    \"\"\"Halt Instruction Received on Privacy Request\"\"\"",
            "",
            "",
            "class PrivacyRequestNotFound(BaseException):",
            "    \"\"\"Privacy Request Not Found\"\"\"",
            "",
            "",
            "class NoCachedManualWebhookEntry(BaseException):",
            "    \"\"\"No manual data exists for this webhook on the given privacy request.\"\"\"",
            "",
            "",
            "class ManualWebhookFieldsUnset(BaseException):",
            "    \"\"\"Manual webhook has fields that are not explicitly set: Likely new field has been added\"\"\"",
            "",
            "",
            "class PrivacyRequestErasureEmailSendRequired(BaseException):",
            "    \"\"\"Erasure requests will need to be fulfilled by email send.  Exception is raised to change ExecutionLog details\"\"\"",
            "",
            "",
            "class SaaSConfigNotFoundException(FidesopsException):",
            "    \"\"\"Custom Exception - SaaS Config Not Found\"\"\"",
            "",
            "",
            "class MessagingConfigNotFoundException(FidesopsException):",
            "    \"\"\"Custom Exception - Messaging Config Not Found\"\"\"",
            "",
            "",
            "class MessageDispatchException(FidesopsException):",
            "    \"\"\"Custom Exception - Message Dispatch Error\"\"\"",
            "",
            "",
            "class EmailTemplateUnhandledActionType(FidesopsException):",
            "    \"\"\"Custom Exception - Email Template Unhandled ActionType Error\"\"\"",
            "",
            "",
            "class OAuth2TokenException(FidesopsException):",
            "    \"\"\"Custom Exception - Unable to access or refresh OAuth2 tokens for SaaS connector\"\"\"",
            "",
            "",
            "class AuthenticationFailure(HTTPException):",
            "    \"\"\"Wrapper for authentication failure exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_401_UNAUTHORIZED, detail=detail)",
            "",
            "",
            "class BadRequest(HTTPException):",
            "    \"\"\"Wrapper for bad request exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_400_BAD_REQUEST, detail=detail)",
            "",
            "",
            "class NotFoundException(HTTPException):",
            "    \"\"\"Wrapper for not found exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_404_NOT_FOUND, detail=detail)",
            "",
            "",
            "class ClientUnsuccessfulException(FidesopsException):",
            "    \"\"\"Exception for when client call fails\"\"\"",
            "",
            "    def __init__(self, status_code: int):",
            "        super().__init__(message=f\"Client call failed with status code '{status_code}'\")",
            "",
            "",
            "class NoSuchStrategyException(ValueError):",
            "    \"\"\"Exception for when a masking strategy does not exist\"\"\"",
            "",
            "",
            "class FunctionalityNotConfigured(Exception):",
            "    \"\"\"Custom exception for when invoked functionality is unavailable due to configuration.\"\"\"",
            "",
            "",
            "class InvalidSaaSRequestOverrideException(ValueError):",
            "    \"\"\"Exception for when a provied SaaS request override function is invalid\"\"\"",
            "",
            "",
            "class NoSuchSaaSRequestOverrideException(ValueError):",
            "    \"\"\"Exception for when a requested SaaS request override function does not exist\"\"\"",
            "",
            "",
            "class IdentityVerificationException(FidesopsException):",
            "    \"\"\"Custom exceptions for when we cannot verify the identity of a subjct\"\"\"",
            "",
            "",
            "class NoSuchConnectionTypeSecretSchemaError(Exception):",
            "    \"\"\"Exception for when a connection type secret schema is not found.\"\"\"",
            "",
            "",
            "class SSHTunnelConfigNotFoundException(Exception):",
            "    \"\"\"Exception for when Fides is configured to use an SSH tunnel without config provided.\"\"\"",
            "",
            "",
            "class AuthenticationError(HTTPException):",
            "    \"\"\"To be raised when attempting to fetch an access token using",
            "    invalid credentials.",
            "    \"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_401_UNAUTHORIZED,",
            "            detail=detail,",
            "        )",
            "",
            "",
            "class AuthorizationError(HTTPException):",
            "    \"\"\"Throws an HTTP 403\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        \"\"\"Override the regular HTTPException throwing only a 403\"\"\"",
            "        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail)",
            "",
            "",
            "class ClientWriteFailedError(HTTPException):",
            "    \"\"\"To be raised when a client cannot be created.\"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,",
            "            detail=\"Failed to create client\",",
            "        )",
            "",
            "",
            "class ClientNotFoundError(HTTPException):",
            "    \"\"\"To be raised when attempting to fetch a client that does not exist.\"\"\"",
            "",
            "    def __init__(self, client_id: str) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_404_NOT_FOUND,",
            "            detail={",
            "                \"error\": \"Client does not exist\",",
            "                \"id\": client_id,",
            "            },",
            "        )",
            "",
            "",
            "class ExpiredTokenError(HTTPException):",
            "    \"\"\"To be raised when a provided token is expired.\"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_403_FORBIDDEN,",
            "            detail=\"OAuth token expired\",",
            "        )",
            "",
            "",
            "class InvalidAuthorizationSchemeError(HTTPException):",
            "    \"\"\"To be raised when attempting to authenticate with an unexpected",
            "    Authorization header value.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_401_UNAUTHORIZED,",
            "            detail=\"Failed to authenticate\",",
            "            headers={\"WWW-Authenticate\": \"Bearer\"},",
            "        )",
            "",
            "",
            "class InvalidScopeError(HTTPException):",
            "    \"\"\"To be raised when a provided scope does not exist.\"\"\"",
            "",
            "    def __init__(self, invalid_scopes: list[str]) -> None:",
            "        SCOPES.sort()",
            "",
            "        super().__init__(",
            "            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,",
            "            detail={",
            "                \"error\": \"Invalid scope provided\",",
            "                \"invalid_scopes\": invalid_scopes,",
            "                \"valid_scopes\": SCOPES,",
            "            },",
            "        )",
            "",
            "",
            "class KeyOrNameAlreadyExists(Exception):",
            "    \"\"\"A resource already exists with this key or name.\"\"\"",
            "",
            "",
            "class KeyValidationError(Exception):",
            "    \"\"\"The resource you're trying to create has a key specified but not",
            "    a name specified.",
            "    \"\"\"",
            "",
            "",
            "class MissingConfig(Exception):",
            "    \"\"\"Custom exception for when no valid configuration file is provided.\"\"\""
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from typing import List",
            "",
            "from fastapi import HTTPException, status",
            "from starlette.status import (",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_404_NOT_FOUND,",
            ")",
            "",
            "from fides.common.api.scope_registry import SCOPE_REGISTRY as SCOPES",
            "",
            "",
            "class FidesopsException(Exception):",
            "    \"\"\"Base class for fidesops exceptions\"\"\"",
            "",
            "    def __init__(self, message: str, errors: List[str] = []):",
            "        super().__init__(message)",
            "        self.message = message",
            "        self.errors = errors",
            "",
            "",
            "class TraversalError(FidesopsException):",
            "    \"\"\"Fidesops error with the names of all nodes that could not be reached.\"\"\"",
            "",
            "",
            "class ValidationError(FidesopsException):",
            "    \"\"\"Data does not pass validation.\"\"\"",
            "",
            "",
            "class StorageUploadError(FidesopsException):",
            "    \"\"\"Data cannot be uploaded to storage destination\"\"\"",
            "",
            "",
            "class SystemManagerException(FidesopsException):",
            "    \"\"\"Exception class when there are errors making a systemmanager\"\"\"",
            "",
            "",
            "class ConnectionException(FidesopsException):",
            "    \"\"\"Exception class when there are errors making a connection\"\"\"",
            "",
            "",
            "class InsufficientDataException(FidesopsException):",
            "    \"\"\"Exception class when there is not sufficient data to proceed\"\"\"",
            "",
            "",
            "class SkippingConsentPropagation(BaseException):",
            "    \"\"\"Skipping consent propagation for collection. Used to trigger \"skipped\" execution logs being created where applicable",
            "    for Privacy Preference requests on saas connectors.",
            "    \"\"\"",
            "",
            "",
            "class RedisConnectionError(Exception):",
            "    \"\"\"The Configured Redis instance is uncontactable.\"\"\"",
            "",
            "",
            "class MisconfiguredPolicyException(Exception):",
            "    \"\"\"Thrown when a Privacy Request cannot be processed due to a misconfigured Policy.\"\"\"",
            "",
            "",
            "class PolicyValidationError(ValueError):",
            "    \"\"\"The policy you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class InvalidDataLengthValidationError(ValueError):",
            "    \"\"\"The length provided is invalid\"\"\"",
            "",
            "",
            "class RuleValidationError(ValueError):",
            "    \"\"\"The Rule you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class StorageConfigValidationError(ValueError):",
            "    \"\"\"The Storage Config you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class InvalidDataTypeValidationError(ValueError):",
            "    \"\"\"The specified data type is invalid.\"\"\"",
            "",
            "",
            "class RuleTargetValidationError(ValueError):",
            "    \"\"\"The Rule you are trying to create has invalid data\"\"\"",
            "",
            "",
            "class DataCategoryNotSupported(ValueError):",
            "    \"\"\"The data category you have supplied is not supported.\"\"\"",
            "",
            "",
            "class PolicyNotFoundException(Exception):",
            "    \"\"\"Policy could not be found\"\"\"",
            "",
            "",
            "class ConnectorNotFoundException(Exception):",
            "    \"\"\"Connector could not be found\"\"\"",
            "",
            "",
            "class DrpActionValidationError(Exception):",
            "    \"\"\"A resource already exists with this DRP Action.\"\"\"",
            "",
            "",
            "class StorageConfigNotFoundException(BaseException):",
            "    \"\"\"Custom Exception - StorageConfig Not Found\"\"\"",
            "",
            "",
            "class PrivacyNoticeHistoryNotFound(BaseException):",
            "    \"\"\"PrivacyNoticeHistory Not Found\"\"\"",
            "",
            "",
            "class IdentityNotFoundException(BaseException):",
            "    \"\"\"Identity Not Found\"\"\"",
            "",
            "",
            "class WebhookOrderException(BaseException):",
            "    \"\"\"Custom Exception - Issue with webhooks order\"\"\"",
            "",
            "",
            "class PostProcessingException(BaseException):",
            "    \"\"\"Custom Exception - Issue with post processing\"\"\"",
            "",
            "",
            "class CollectionDisabled(BaseException):",
            "    \"\"\"Collection is attached to disabled ConnectionConfig\"\"\"",
            "",
            "",
            "class NotSupportedForCollection(BaseException):",
            "    \"\"\"The given action is not supported for this type of collection\"\"\"",
            "",
            "",
            "class PrivacyRequestPaused(BaseException):",
            "    \"\"\"Halt Instruction Received on Privacy Request\"\"\"",
            "",
            "",
            "class PrivacyRequestNotFound(BaseException):",
            "    \"\"\"Privacy Request Not Found\"\"\"",
            "",
            "",
            "class NoCachedManualWebhookEntry(BaseException):",
            "    \"\"\"No manual data exists for this webhook on the given privacy request.\"\"\"",
            "",
            "",
            "class ManualWebhookFieldsUnset(BaseException):",
            "    \"\"\"Manual webhook has fields that are not explicitly set: Likely new field has been added\"\"\"",
            "",
            "",
            "class PrivacyRequestErasureEmailSendRequired(BaseException):",
            "    \"\"\"Erasure requests will need to be fulfilled by email send.  Exception is raised to change ExecutionLog details\"\"\"",
            "",
            "",
            "class SaaSConfigNotFoundException(FidesopsException):",
            "    \"\"\"Custom Exception - SaaS Config Not Found\"\"\"",
            "",
            "",
            "class MessagingConfigNotFoundException(FidesopsException):",
            "    \"\"\"Custom Exception - Messaging Config Not Found\"\"\"",
            "",
            "",
            "class MessageDispatchException(FidesopsException):",
            "    \"\"\"Custom Exception - Message Dispatch Error\"\"\"",
            "",
            "",
            "class EmailTemplateUnhandledActionType(FidesopsException):",
            "    \"\"\"Custom Exception - Email Template Unhandled ActionType Error\"\"\"",
            "",
            "",
            "class OAuth2TokenException(FidesopsException):",
            "    \"\"\"Custom Exception - Unable to access or refresh OAuth2 tokens for SaaS connector\"\"\"",
            "",
            "",
            "class AuthenticationFailure(HTTPException):",
            "    \"\"\"Wrapper for authentication failure exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_401_UNAUTHORIZED, detail=detail)",
            "",
            "",
            "class BadRequest(HTTPException):",
            "    \"\"\"Wrapper for bad request exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_400_BAD_REQUEST, detail=detail)",
            "",
            "",
            "class NotFoundException(HTTPException):",
            "    \"\"\"Wrapper for not found exception\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(status_code=HTTP_404_NOT_FOUND, detail=detail)",
            "",
            "",
            "class ClientUnsuccessfulException(FidesopsException):",
            "    \"\"\"Exception for when client call fails\"\"\"",
            "",
            "    def __init__(self, status_code: int):",
            "        super().__init__(message=f\"Client call failed with status code '{status_code}'\")",
            "",
            "",
            "class NoSuchStrategyException(ValueError):",
            "    \"\"\"Exception for when a masking strategy does not exist\"\"\"",
            "",
            "",
            "class FunctionalityNotConfigured(Exception):",
            "    \"\"\"Custom exception for when invoked functionality is unavailable due to configuration.\"\"\"",
            "",
            "",
            "class InvalidSaaSRequestOverrideException(ValueError):",
            "    \"\"\"Exception for when a provied SaaS request override function is invalid\"\"\"",
            "",
            "",
            "class NoSuchSaaSRequestOverrideException(ValueError):",
            "    \"\"\"Exception for when a requested SaaS request override function does not exist\"\"\"",
            "",
            "",
            "class IdentityVerificationException(FidesopsException):",
            "    \"\"\"Custom exceptions for when we cannot verify the identity of a subjct\"\"\"",
            "",
            "",
            "class NoSuchConnectionTypeSecretSchemaError(Exception):",
            "    \"\"\"Exception for when a connection type secret schema is not found.\"\"\"",
            "",
            "",
            "class SSHTunnelConfigNotFoundException(Exception):",
            "    \"\"\"Exception for when Fides is configured to use an SSH tunnel without config provided.\"\"\"",
            "",
            "",
            "class MalisciousUrlException(Exception):",
            "    \"\"\"Fides has detected a potentially maliscious URL.\"\"\"",
            "",
            "",
            "class AuthenticationError(HTTPException):",
            "    \"\"\"To be raised when attempting to fetch an access token using",
            "    invalid credentials.",
            "    \"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_401_UNAUTHORIZED,",
            "            detail=detail,",
            "        )",
            "",
            "",
            "class AuthorizationError(HTTPException):",
            "    \"\"\"Throws an HTTP 403\"\"\"",
            "",
            "    def __init__(self, detail: str) -> None:",
            "        \"\"\"Override the regular HTTPException throwing only a 403\"\"\"",
            "        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail)",
            "",
            "",
            "class ClientWriteFailedError(HTTPException):",
            "    \"\"\"To be raised when a client cannot be created.\"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,",
            "            detail=\"Failed to create client\",",
            "        )",
            "",
            "",
            "class ClientNotFoundError(HTTPException):",
            "    \"\"\"To be raised when attempting to fetch a client that does not exist.\"\"\"",
            "",
            "    def __init__(self, client_id: str) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_404_NOT_FOUND,",
            "            detail={",
            "                \"error\": \"Client does not exist\",",
            "                \"id\": client_id,",
            "            },",
            "        )",
            "",
            "",
            "class ExpiredTokenError(HTTPException):",
            "    \"\"\"To be raised when a provided token is expired.\"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_403_FORBIDDEN,",
            "            detail=\"OAuth token expired\",",
            "        )",
            "",
            "",
            "class InvalidAuthorizationSchemeError(HTTPException):",
            "    \"\"\"To be raised when attempting to authenticate with an unexpected",
            "    Authorization header value.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__(",
            "            status_code=status.HTTP_401_UNAUTHORIZED,",
            "            detail=\"Failed to authenticate\",",
            "            headers={\"WWW-Authenticate\": \"Bearer\"},",
            "        )",
            "",
            "",
            "class InvalidScopeError(HTTPException):",
            "    \"\"\"To be raised when a provided scope does not exist.\"\"\"",
            "",
            "    def __init__(self, invalid_scopes: list[str]) -> None:",
            "        SCOPES.sort()",
            "",
            "        super().__init__(",
            "            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,",
            "            detail={",
            "                \"error\": \"Invalid scope provided\",",
            "                \"invalid_scopes\": invalid_scopes,",
            "                \"valid_scopes\": SCOPES,",
            "            },",
            "        )",
            "",
            "",
            "class KeyOrNameAlreadyExists(Exception):",
            "    \"\"\"A resource already exists with this key or name.\"\"\"",
            "",
            "",
            "class KeyValidationError(Exception):",
            "    \"\"\"The resource you're trying to create has a key specified but not",
            "    a name specified.",
            "    \"\"\"",
            "",
            "",
            "class MissingConfig(Exception):",
            "    \"\"\"Custom exception for when no valid configuration file is provided.\"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/fides/api/main.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " Contains the code that sets up the API."
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " \"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import os"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import sys"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from datetime import datetime, timezone"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from logging import WARNING"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from fideslog.sdk.python.event import AnalyticsEvent"
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from loguru import logger"
            },
            "9": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from starlette.background import BackgroundTask"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from urllib.parse import unquote"
            },
            "11": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from uvicorn import Config, Server"
            },
            "12": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import fides"
            },
            "14": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     log_startup,"
            },
            "15": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     run_database_startup,"
            },
            "16": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " )"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from fides.api.common_exceptions import MalisciousUrlException"
            },
            "18": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from fides.api.middleware import handle_audit_log_resource"
            },
            "19": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from fides.api.schemas.analytics import Event, ExtraData"
            },
            "20": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     return get_admin_index_as_response()"
            },
            "22": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+def sanitise_url_path(path: str) -> str:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+    \"\"\"Returns a URL path that does not contain any ../ or //\"\"\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    path = unquote(path)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    path = os.path.normpath(path)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    for token in path.split(\"/\"):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        if \"..\" in token:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            logger.warning(f\"Potentially dangerous use of URL hierarchy in path: {path}\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            raise MalisciousUrlException()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    return path"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " @app.get(\"/{catchall:path}\", response_class=Response, tags=[\"Default\"])"
            },
            "36": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " def read_other_paths(request: Request) -> Response:"
            },
            "37": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130"
            },
            "39": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     \"\"\""
            },
            "40": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     # check first if requested file exists (for frontend assets)"
            },
            "41": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     path = request.path_params[\"catchall\"]"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    logger.debug(f\"Catch all path detected: {path}\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    try:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        path = sanitise_url_path(path)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    except MalisciousUrlException:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        # if a maliscious URL is detected, route the user to the index"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        return get_admin_index_as_response()"
            },
            "48": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     # search for matching route in package (i.e. /dataset)"
            },
            "50": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "     ui_file = match_route(get_ui_file_map(), path)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Contains the code that sets up the API.",
            "\"\"\"",
            "import sys",
            "from datetime import datetime, timezone",
            "from logging import WARNING",
            "from typing import Callable, Optional",
            "",
            "from fastapi import HTTPException, Request, Response, status",
            "from fastapi.responses import FileResponse",
            "from fideslog.sdk.python.event import AnalyticsEvent",
            "from loguru import logger",
            "from starlette.background import BackgroundTask",
            "from uvicorn import Config, Server",
            "",
            "import fides",
            "from fides.api.app_setup import (",
            "    check_redis,",
            "    create_fides_app,",
            "    log_startup,",
            "    run_database_startup,",
            ")",
            "from fides.api.middleware import handle_audit_log_resource",
            "from fides.api.schemas.analytics import Event, ExtraData",
            "",
            "# pylint: disable=wildcard-import, unused-wildcard-import",
            "from fides.api.service.privacy_request.email_batch_service import (",
            "    initiate_scheduled_batch_email_send,",
            ")",
            "from fides.api.tasks.scheduled.scheduler import scheduler",
            "from fides.api.ui import (",
            "    get_admin_index_as_response,",
            "    get_path_to_admin_ui_file,",
            "    get_ui_file_map,",
            "    match_route,",
            "    path_is_in_ui_directory,",
            ")",
            "from fides.api.util.endpoint_utils import API_PREFIX",
            "from fides.api.util.logger import _log_exception",
            "from fides.cli.utils import FIDES_ASCII_ART",
            "from fides.config import CONFIG, check_required_webserver_config_values",
            "",
            "IGNORED_AUDIT_LOG_RESOURCE_PATHS = {\"/api/v1/login\"}",
            "",
            "VERSION = fides.__version__",
            "",
            "app = create_fides_app()",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def dispatch_log_request(request: Request, call_next: Callable) -> Response:",
            "    \"\"\"",
            "    HTTP Middleware that logs analytics events for each call to Fides endpoints.",
            "    :param request: Request to Fides api",
            "    :param call_next: Callable api endpoint",
            "    :return: Response",
            "    \"\"\"",
            "",
            "    # Only log analytics events for requests that are for API endpoints (i.e. /api/...)",
            "    path = request.url.path",
            "    if (not path.startswith(API_PREFIX)) or (path.endswith(\"/health\")):",
            "        return await call_next(request)",
            "",
            "    fides_source: Optional[str] = request.headers.get(\"X-Fides-Source\")",
            "    now: datetime = datetime.now(tz=timezone.utc)",
            "    endpoint = f\"{request.method}: {request.url}\"",
            "",
            "    try:",
            "        response = await call_next(request)",
            "        # HTTPExceptions are considered a handled err by default so are not thrown here.",
            "        # Accepted workaround is to inspect status code of response.",
            "        # More context- https://github.com/tiangolo/fastapi/issues/1840",
            "        response.background = BackgroundTask(",
            "            prepare_and_log_request,",
            "            endpoint,",
            "            request.url.hostname,",
            "            response.status_code,",
            "            now,",
            "            fides_source,",
            "            \"HTTPException\" if response.status_code >= 400 else None,",
            "        )",
            "        return response",
            "",
            "    except Exception as e:",
            "        await prepare_and_log_request(",
            "            endpoint, request.url.hostname, 500, now, fides_source, e.__class__.__name__",
            "        )",
            "        _log_exception(e, CONFIG.dev_mode)",
            "        raise",
            "",
            "",
            "async def prepare_and_log_request(",
            "    endpoint: str,",
            "    hostname: Optional[str],",
            "    status_code: int,",
            "    event_created_at: datetime,",
            "    fides_source: Optional[str],",
            "    error_class: Optional[str],",
            ") -> None:",
            "    \"\"\"",
            "    Prepares and sends analytics event provided the user is not opted out of analytics.",
            "    \"\"\"",
            "    # Avoid circular imports",
            "    from fides.api.analytics import (",
            "        accessed_through_local_host,",
            "        in_docker_container,",
            "        send_analytics_event,",
            "    )",
            "",
            "    # this check prevents AnalyticsEvent from being called with invalid endpoint during unit tests",
            "    if CONFIG.user.analytics_opt_out:",
            "        return",
            "    await send_analytics_event(",
            "        AnalyticsEvent(",
            "            docker=in_docker_container(),",
            "            event=Event.endpoint_call.value,",
            "            event_created_at=event_created_at,",
            "            local_host=accessed_through_local_host(hostname),",
            "            endpoint=endpoint,",
            "            status_code=status_code,",
            "            error=error_class or None,",
            "            extra_data={ExtraData.fides_source.value: fides_source}",
            "            if fides_source",
            "            else None,",
            "        )",
            "    )",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def log_request(request: Request, call_next: Callable) -> Response:",
            "    \"\"\"Log basic information about every request handled by the server.\"\"\"",
            "    start = datetime.now()",
            "    response = await call_next(request)",
            "    handler_time = datetime.now() - start",
            "    logger.bind(",
            "        method=request.method,",
            "        status_code=response.status_code,",
            "        handler_time=f\"{round(handler_time.microseconds * 0.001,3)}ms\",",
            "        path=request.url.path,",
            "    ).info(\"Request received\")",
            "    return response",
            "",
            "",
            "# Configure the static file paths last since otherwise it will take over all paths",
            "@app.get(\"/\", tags=[\"Default\"])",
            "def read_index() -> Response:",
            "    \"\"\"",
            "    Return an index.html at the root path",
            "    \"\"\"",
            "",
            "    return get_admin_index_as_response()",
            "",
            "",
            "@app.get(\"/{catchall:path}\", response_class=Response, tags=[\"Default\"])",
            "def read_other_paths(request: Request) -> Response:",
            "    \"\"\"",
            "    Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130",
            "    \"\"\"",
            "    # check first if requested file exists (for frontend assets)",
            "    path = request.path_params[\"catchall\"]",
            "",
            "    # search for matching route in package (i.e. /dataset)",
            "    ui_file = match_route(get_ui_file_map(), path)",
            "",
            "    # if not, check if the requested file is an asset (i.e. /_next/static/...)",
            "    if not ui_file:",
            "        ui_file = get_path_to_admin_ui_file(path)",
            "",
            "    # Serve up the file as long as it is within the UI directory",
            "    if ui_file and ui_file.is_file():",
            "        if not path_is_in_ui_directory(ui_file):",
            "            raise HTTPException(",
            "                status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"",
            "            )",
            "        logger.debug(",
            "            \"catchall request path '{}' matched static admin UI file: {}\",",
            "            path,",
            "            ui_file,",
            "        )",
            "        return FileResponse(ui_file)",
            "",
            "    # raise 404 for anything that should be backend endpoint but we can't find it",
            "    if path.startswith(API_PREFIX[1:]):",
            "        logger.debug(",
            "            \"catchall request path '{}' matched an invalid API route, return 404\",",
            "            path,",
            "        )",
            "        raise HTTPException(",
            "            status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"",
            "        )",
            "",
            "    # otherwise return the index",
            "    logger.debug(",
            "        \"catchall request path '{}' did not match any admin UI routes, return generic admin UI index\",",
            "        path,",
            "    )",
            "    return get_admin_index_as_response()",
            "",
            "",
            "@app.on_event(\"startup\")",
            "async def setup_server() -> None:",
            "    \"\"\"Run all of the required setup steps for the webserver.",
            "",
            "    **NOTE**: The order of operations here _is_ deliberate",
            "    and must be maintained.",
            "    \"\"\"",
            "    if not CONFIG.dev_mode:",
            "        sys.tracebacklimit = 0",
            "",
            "    log_startup()",
            "",
            "    await run_database_startup()",
            "",
            "    check_redis()",
            "",
            "    if not scheduler.running:",
            "        scheduler.start()",
            "",
            "    initiate_scheduled_batch_email_send()",
            "",
            "    logger.debug(\"Sending startup analytics events...\")",
            "    # Avoid circular imports",
            "    from fides.api.analytics import in_docker_container, send_analytics_event",
            "",
            "    await send_analytics_event(",
            "        AnalyticsEvent(",
            "            docker=in_docker_container(),",
            "            event=Event.server_start.value,",
            "            event_created_at=datetime.now(tz=timezone.utc),",
            "        )",
            "    )",
            "",
            "    logger.info(FIDES_ASCII_ART)",
            "    logger.info(f\"Fides startup complete! v{VERSION}\")",
            "",
            "",
            "def start_webserver(port: int = 8080) -> None:",
            "    \"\"\"Run the webserver.\"\"\"",
            "    check_required_webserver_config_values(config=CONFIG)",
            "    server = Server(Config(app, host=\"0.0.0.0\", port=port, log_level=WARNING))",
            "",
            "    logger.info(",
            "        \"Starting webserver - Host: {}, Port: {}, Log Level: {}\",",
            "        server.config.host,",
            "        server.config.port,",
            "        server.config.log_level,",
            "    )",
            "    server.run()",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def action_to_audit_log(",
            "    request: Request,",
            "    call_next: Callable,",
            ") -> Response:",
            "    \"\"\"Log basic information about every non-GET request handled by the server.\"\"\"",
            "",
            "    if (",
            "        request.method != \"GET\"",
            "        and request.scope[\"path\"] not in IGNORED_AUDIT_LOG_RESOURCE_PATHS",
            "        and CONFIG.security.enable_audit_log_resource_middleware",
            "    ):",
            "        try:",
            "            await handle_audit_log_resource(request)",
            "        except Exception as exc:",
            "            logger.debug(exc)",
            "    return await call_next(request)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Contains the code that sets up the API.",
            "\"\"\"",
            "import os",
            "import sys",
            "from datetime import datetime, timezone",
            "from logging import WARNING",
            "from typing import Callable, Optional",
            "",
            "from fastapi import HTTPException, Request, Response, status",
            "from fastapi.responses import FileResponse",
            "from fideslog.sdk.python.event import AnalyticsEvent",
            "from loguru import logger",
            "from starlette.background import BackgroundTask",
            "from urllib.parse import unquote",
            "from uvicorn import Config, Server",
            "",
            "import fides",
            "from fides.api.app_setup import (",
            "    check_redis,",
            "    create_fides_app,",
            "    log_startup,",
            "    run_database_startup,",
            ")",
            "from fides.api.common_exceptions import MalisciousUrlException",
            "from fides.api.middleware import handle_audit_log_resource",
            "from fides.api.schemas.analytics import Event, ExtraData",
            "",
            "# pylint: disable=wildcard-import, unused-wildcard-import",
            "from fides.api.service.privacy_request.email_batch_service import (",
            "    initiate_scheduled_batch_email_send,",
            ")",
            "from fides.api.tasks.scheduled.scheduler import scheduler",
            "from fides.api.ui import (",
            "    get_admin_index_as_response,",
            "    get_path_to_admin_ui_file,",
            "    get_ui_file_map,",
            "    match_route,",
            "    path_is_in_ui_directory,",
            ")",
            "from fides.api.util.endpoint_utils import API_PREFIX",
            "from fides.api.util.logger import _log_exception",
            "from fides.cli.utils import FIDES_ASCII_ART",
            "from fides.config import CONFIG, check_required_webserver_config_values",
            "",
            "IGNORED_AUDIT_LOG_RESOURCE_PATHS = {\"/api/v1/login\"}",
            "",
            "VERSION = fides.__version__",
            "",
            "app = create_fides_app()",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def dispatch_log_request(request: Request, call_next: Callable) -> Response:",
            "    \"\"\"",
            "    HTTP Middleware that logs analytics events for each call to Fides endpoints.",
            "    :param request: Request to Fides api",
            "    :param call_next: Callable api endpoint",
            "    :return: Response",
            "    \"\"\"",
            "",
            "    # Only log analytics events for requests that are for API endpoints (i.e. /api/...)",
            "    path = request.url.path",
            "    if (not path.startswith(API_PREFIX)) or (path.endswith(\"/health\")):",
            "        return await call_next(request)",
            "",
            "    fides_source: Optional[str] = request.headers.get(\"X-Fides-Source\")",
            "    now: datetime = datetime.now(tz=timezone.utc)",
            "    endpoint = f\"{request.method}: {request.url}\"",
            "",
            "    try:",
            "        response = await call_next(request)",
            "        # HTTPExceptions are considered a handled err by default so are not thrown here.",
            "        # Accepted workaround is to inspect status code of response.",
            "        # More context- https://github.com/tiangolo/fastapi/issues/1840",
            "        response.background = BackgroundTask(",
            "            prepare_and_log_request,",
            "            endpoint,",
            "            request.url.hostname,",
            "            response.status_code,",
            "            now,",
            "            fides_source,",
            "            \"HTTPException\" if response.status_code >= 400 else None,",
            "        )",
            "        return response",
            "",
            "    except Exception as e:",
            "        await prepare_and_log_request(",
            "            endpoint, request.url.hostname, 500, now, fides_source, e.__class__.__name__",
            "        )",
            "        _log_exception(e, CONFIG.dev_mode)",
            "        raise",
            "",
            "",
            "async def prepare_and_log_request(",
            "    endpoint: str,",
            "    hostname: Optional[str],",
            "    status_code: int,",
            "    event_created_at: datetime,",
            "    fides_source: Optional[str],",
            "    error_class: Optional[str],",
            ") -> None:",
            "    \"\"\"",
            "    Prepares and sends analytics event provided the user is not opted out of analytics.",
            "    \"\"\"",
            "    # Avoid circular imports",
            "    from fides.api.analytics import (",
            "        accessed_through_local_host,",
            "        in_docker_container,",
            "        send_analytics_event,",
            "    )",
            "",
            "    # this check prevents AnalyticsEvent from being called with invalid endpoint during unit tests",
            "    if CONFIG.user.analytics_opt_out:",
            "        return",
            "    await send_analytics_event(",
            "        AnalyticsEvent(",
            "            docker=in_docker_container(),",
            "            event=Event.endpoint_call.value,",
            "            event_created_at=event_created_at,",
            "            local_host=accessed_through_local_host(hostname),",
            "            endpoint=endpoint,",
            "            status_code=status_code,",
            "            error=error_class or None,",
            "            extra_data={ExtraData.fides_source.value: fides_source}",
            "            if fides_source",
            "            else None,",
            "        )",
            "    )",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def log_request(request: Request, call_next: Callable) -> Response:",
            "    \"\"\"Log basic information about every request handled by the server.\"\"\"",
            "    start = datetime.now()",
            "    response = await call_next(request)",
            "    handler_time = datetime.now() - start",
            "    logger.bind(",
            "        method=request.method,",
            "        status_code=response.status_code,",
            "        handler_time=f\"{round(handler_time.microseconds * 0.001,3)}ms\",",
            "        path=request.url.path,",
            "    ).info(\"Request received\")",
            "    return response",
            "",
            "",
            "# Configure the static file paths last since otherwise it will take over all paths",
            "@app.get(\"/\", tags=[\"Default\"])",
            "def read_index() -> Response:",
            "    \"\"\"",
            "    Return an index.html at the root path",
            "    \"\"\"",
            "",
            "    return get_admin_index_as_response()",
            "",
            "",
            "def sanitise_url_path(path: str) -> str:",
            "    \"\"\"Returns a URL path that does not contain any ../ or //\"\"\"",
            "    path = unquote(path)",
            "    path = os.path.normpath(path)",
            "    for token in path.split(\"/\"):",
            "        if \"..\" in token:",
            "            logger.warning(f\"Potentially dangerous use of URL hierarchy in path: {path}\")",
            "            raise MalisciousUrlException()",
            "    return path",
            "",
            "",
            "@app.get(\"/{catchall:path}\", response_class=Response, tags=[\"Default\"])",
            "def read_other_paths(request: Request) -> Response:",
            "    \"\"\"",
            "    Return related frontend files. Adapted from https://github.com/tiangolo/fastapi/issues/130",
            "    \"\"\"",
            "    # check first if requested file exists (for frontend assets)",
            "    path = request.path_params[\"catchall\"]",
            "    logger.debug(f\"Catch all path detected: {path}\")",
            "    try:",
            "        path = sanitise_url_path(path)",
            "    except MalisciousUrlException:",
            "        # if a maliscious URL is detected, route the user to the index",
            "        return get_admin_index_as_response()",
            "",
            "    # search for matching route in package (i.e. /dataset)",
            "    ui_file = match_route(get_ui_file_map(), path)",
            "",
            "    # if not, check if the requested file is an asset (i.e. /_next/static/...)",
            "    if not ui_file:",
            "        ui_file = get_path_to_admin_ui_file(path)",
            "",
            "    # Serve up the file as long as it is within the UI directory",
            "    if ui_file and ui_file.is_file():",
            "        if not path_is_in_ui_directory(ui_file):",
            "            raise HTTPException(",
            "                status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"",
            "            )",
            "        logger.debug(",
            "            \"catchall request path '{}' matched static admin UI file: {}\",",
            "            path,",
            "            ui_file,",
            "        )",
            "        return FileResponse(ui_file)",
            "",
            "    # raise 404 for anything that should be backend endpoint but we can't find it",
            "    if path.startswith(API_PREFIX[1:]):",
            "        logger.debug(",
            "            \"catchall request path '{}' matched an invalid API route, return 404\",",
            "            path,",
            "        )",
            "        raise HTTPException(",
            "            status_code=status.HTTP_404_NOT_FOUND, detail=\"Item not found\"",
            "        )",
            "",
            "    # otherwise return the index",
            "    logger.debug(",
            "        \"catchall request path '{}' did not match any admin UI routes, return generic admin UI index\",",
            "        path,",
            "    )",
            "    return get_admin_index_as_response()",
            "",
            "",
            "@app.on_event(\"startup\")",
            "async def setup_server() -> None:",
            "    \"\"\"Run all of the required setup steps for the webserver.",
            "",
            "    **NOTE**: The order of operations here _is_ deliberate",
            "    and must be maintained.",
            "    \"\"\"",
            "    if not CONFIG.dev_mode:",
            "        sys.tracebacklimit = 0",
            "",
            "    log_startup()",
            "",
            "    await run_database_startup()",
            "",
            "    check_redis()",
            "",
            "    if not scheduler.running:",
            "        scheduler.start()",
            "",
            "    initiate_scheduled_batch_email_send()",
            "",
            "    logger.debug(\"Sending startup analytics events...\")",
            "    # Avoid circular imports",
            "    from fides.api.analytics import in_docker_container, send_analytics_event",
            "",
            "    await send_analytics_event(",
            "        AnalyticsEvent(",
            "            docker=in_docker_container(),",
            "            event=Event.server_start.value,",
            "            event_created_at=datetime.now(tz=timezone.utc),",
            "        )",
            "    )",
            "",
            "    logger.info(FIDES_ASCII_ART)",
            "    logger.info(f\"Fides startup complete! v{VERSION}\")",
            "",
            "",
            "def start_webserver(port: int = 8080) -> None:",
            "    \"\"\"Run the webserver.\"\"\"",
            "    check_required_webserver_config_values(config=CONFIG)",
            "    server = Server(Config(app, host=\"0.0.0.0\", port=port, log_level=WARNING))",
            "",
            "    logger.info(",
            "        \"Starting webserver - Host: {}, Port: {}, Log Level: {}\",",
            "        server.config.host,",
            "        server.config.port,",
            "        server.config.log_level,",
            "    )",
            "    server.run()",
            "",
            "",
            "@app.middleware(\"http\")",
            "async def action_to_audit_log(",
            "    request: Request,",
            "    call_next: Callable,",
            ") -> Response:",
            "    \"\"\"Log basic information about every non-GET request handled by the server.\"\"\"",
            "",
            "    if (",
            "        request.method != \"GET\"",
            "        and request.scope[\"path\"] not in IGNORED_AUDIT_LOG_RESOURCE_PATHS",
            "        and CONFIG.security.enable_audit_log_resource_middleware",
            "    ):",
            "        try:",
            "            await handle_audit_log_resource(request)",
            "        except Exception as exc:",
            "            logger.debug(exc)",
            "    return await call_next(request)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.fides.api.main.read_other_paths"
        ]
    }
}