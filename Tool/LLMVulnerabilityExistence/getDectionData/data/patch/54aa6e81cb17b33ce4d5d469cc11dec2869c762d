{
    "neutron/db/l3_db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 692,
                "PatchRowcode": "             raise n_exc.BadRequest(resource='router', msg=msg)"
            },
            "1": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 693,
                "PatchRowcode": "         return port"
            },
            "2": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 694,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 695,
                "PatchRowcode": "+    def _validate_port_in_range_or_admin(self, context, subnets, port):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 696,
                "PatchRowcode": "+        if context.is_admin:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+            return"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 698,
                "PatchRowcode": "+        subnets_by_id = {}"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+        for s in subnets:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+            addr_set = netaddr.IPSet()"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+            for range in s['allocation_pools']:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 702,
                "PatchRowcode": "+                addr_set.add(netaddr.IPRange(netaddr.IPAddress(range['start']),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 703,
                "PatchRowcode": "+                                             netaddr.IPAddress(range['end'])))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 704,
                "PatchRowcode": "+            subnets_by_id[s['id']] = (addr_set, s['project_id'],)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 705,
                "PatchRowcode": "+        for subnet_id, ip in [(fix_ip['subnet_id'], fix_ip['ip_address'],)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+                              for fix_ip in port['fixed_ips']]:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+            if (ip not in subnets_by_id[subnet_id][0] and"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+                    context.project_id != subnets_by_id[subnet_id][1]):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+                msg = (_('Cannot add interface to router because specified '"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 710,
                "PatchRowcode": "+                         'port %(port)s has an IP address out of the '"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 711,
                "PatchRowcode": "+                         'allocation pool of subnet %(subnet)s, which is not '"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 712,
                "PatchRowcode": "+                         'owned by the project making the request') %"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 713,
                "PatchRowcode": "+                       {'port': port['id'], 'subnet': subnet_id})"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 714,
                "PatchRowcode": "+                raise n_exc.BadRequest(resource='router', msg=msg)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 715,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": 716,
                "PatchRowcode": "     def _validate_router_port_info(self, context, router, port_id):"
            },
            "25": {
                "beforePatchRowNumber": 696,
                "afterPatchRowNumber": 717,
                "PatchRowcode": "         with db_api.autonested_transaction(context.session):"
            },
            "26": {
                "beforePatchRowNumber": 697,
                "afterPatchRowNumber": 718,
                "PatchRowcode": "             # check again within transaction to mitigate race"
            },
            "27": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 748,
                "PatchRowcode": "                 msg = _(\"Cannot have multiple \""
            },
            "28": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 749,
                "PatchRowcode": "                         \"IPv4 subnets on router port\")"
            },
            "29": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 750,
                "PatchRowcode": "                 raise n_exc.BadRequest(resource='router', msg=msg)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 751,
                "PatchRowcode": "+            self._validate_port_in_range_or_admin(context, subnets, port)"
            },
            "31": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 752,
                "PatchRowcode": "             return port, subnets"
            },
            "32": {
                "beforePatchRowNumber": 731,
                "afterPatchRowNumber": 753,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 732,
                "afterPatchRowNumber": 754,
                "PatchRowcode": "     def _notify_attaching_interface(self, context, router_db, port,"
            },
            "34": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": 810,
                "PatchRowcode": "         if not subnet['gateway_ip']:"
            },
            "35": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 811,
                "PatchRowcode": "             msg = _('Subnet for router interface must have a gateway IP')"
            },
            "36": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": 812,
                "PatchRowcode": "             raise n_exc.BadRequest(resource='router', msg=msg)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+        if subnet['project_id'] != context.project_id and not context.is_admin:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 814,
                "PatchRowcode": "+            msg = (_('Cannot add interface to router because subnet %s is not '"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 815,
                "PatchRowcode": "+                     'owned by project making the request') % subnet_id)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 816,
                "PatchRowcode": "+            raise n_exc.BadRequest(resource='router', msg=msg)"
            },
            "41": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": 817,
                "PatchRowcode": "         if (subnet['ip_version'] == 6 and subnet['ipv6_ra_mode'] is None and"
            },
            "42": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "                 subnet['ipv6_address_mode'] is not None):"
            },
            "43": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": 819,
                "PatchRowcode": "             msg = (_('IPv6 subnet %s configured to receive RAs from an '"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 VMware, Inc.  All rights reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import random",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import external_net as extnet_apidef",
            "from neutron_lib.api.definitions import l3 as l3_apidef",
            "from neutron_lib.api import extensions",
            "from neutron_lib.api import validators",
            "from neutron_lib.callbacks import events",
            "from neutron_lib.callbacks import exceptions",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources",
            "from neutron_lib import constants",
            "from neutron_lib import context as n_ctx",
            "from neutron_lib import exceptions as n_exc",
            "from neutron_lib.exceptions import l3 as l3_exc",
            "from neutron_lib.plugins import constants as plugin_constants",
            "from neutron_lib.plugins import directory",
            "from neutron_lib.plugins import utils as plugin_utils",
            "from neutron_lib.services import base as base_services",
            "from oslo_log import log as logging",
            "from oslo_utils import uuidutils",
            "from sqlalchemy import orm",
            "from sqlalchemy.orm import exc",
            "",
            "from neutron._i18n import _",
            "from neutron.api.rpc.agentnotifiers import l3_rpc_agent_api",
            "from neutron.common import ipv6_utils",
            "from neutron.common import rpc as n_rpc",
            "from neutron.common import utils",
            "from neutron.db import _model_query as model_query",
            "from neutron.db import _resource_extend as resource_extend",
            "from neutron.db import _utils as db_utils",
            "from neutron.db import api as db_api",
            "from neutron.db.models import l3 as l3_models",
            "from neutron.db import models_v2",
            "from neutron.db import standardattrdescription_db as st_attr",
            "from neutron.extensions import l3",
            "from neutron.extensions import qos_fip",
            "from neutron.objects import base as base_obj",
            "from neutron.objects import ports as port_obj",
            "from neutron.objects import router as l3_obj",
            "from neutron.plugins.common import utils as p_utils",
            "from neutron import worker as neutron_worker",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "DEVICE_OWNER_HA_REPLICATED_INT = constants.DEVICE_OWNER_HA_REPLICATED_INT",
            "DEVICE_OWNER_ROUTER_INTF = constants.DEVICE_OWNER_ROUTER_INTF",
            "DEVICE_OWNER_ROUTER_GW = constants.DEVICE_OWNER_ROUTER_GW",
            "DEVICE_OWNER_FLOATINGIP = constants.DEVICE_OWNER_FLOATINGIP",
            "EXTERNAL_GW_INFO = l3_apidef.EXTERNAL_GW_INFO",
            "",
            "# Maps API field to DB column",
            "# API parameter name and Database column names may differ.",
            "# Useful to keep the filtering between API and Database.",
            "API_TO_DB_COLUMN_MAP = {'port_id': 'fixed_port_id'}",
            "CORE_ROUTER_ATTRS = ('id', 'name', 'tenant_id', 'admin_state_up', 'status')",
            "",
            "",
            "@registry.has_registry_receivers",
            "class L3_NAT_dbonly_mixin(l3.RouterPluginBase,",
            "                          base_services.WorkerBase,",
            "                          st_attr.StandardAttrDescriptionMixin):",
            "    \"\"\"Mixin class to add L3/NAT router methods to db_base_plugin_v2.\"\"\"",
            "",
            "    router_device_owners = (",
            "        DEVICE_OWNER_HA_REPLICATED_INT,",
            "        DEVICE_OWNER_ROUTER_INTF,",
            "        DEVICE_OWNER_ROUTER_GW,",
            "        DEVICE_OWNER_FLOATINGIP",
            "    )",
            "",
            "    _dns_integration = None",
            "",
            "    _fip_qos = None",
            "",
            "    def __new__(cls, *args, **kwargs):",
            "        inst = super(L3_NAT_dbonly_mixin, cls).__new__(cls, *args, **kwargs)",
            "        inst._start_janitor()",
            "        return inst",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.PORT, [events.BEFORE_DELETE])",
            "    def _prevent_l3_port_delete_callback(resource, event, trigger, **kwargs):",
            "        context = kwargs['context']",
            "        port_id = kwargs['port_id']",
            "        port_check = kwargs['port_check']",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin and port_check:",
            "            l3plugin.prevent_l3_port_deletion(context, port_id)",
            "",
            "    @property",
            "    def _is_dns_integration_supported(self):",
            "        if self._dns_integration is None:",
            "            self._dns_integration = (",
            "                extensions.is_extension_supported(",
            "                    self._core_plugin, 'dns-integration') or",
            "                extensions.is_extension_supported(",
            "                    self._core_plugin, 'dns-domain-ports'))",
            "        return self._dns_integration",
            "",
            "    @property",
            "    def _is_fip_qos_supported(self):",
            "        if self._fip_qos is None:",
            "            # Check L3 service plugin",
            "            self._fip_qos = extensions.is_extension_supported(",
            "                self, qos_fip.FIP_QOS_ALIAS)",
            "        return self._fip_qos",
            "",
            "    @property",
            "    def _core_plugin(self):",
            "        return directory.get_plugin()",
            "",
            "    def _start_janitor(self):",
            "        \"\"\"Starts the periodic job that cleans up broken complex resources.",
            "",
            "        This job will look for things like floating IP ports without an",
            "        associated floating IP and delete them 5 minutes after detection.",
            "        \"\"\"",
            "        interval = 60 * 5  # only every 5 minutes. cleanups should be rare",
            "        initial_delay = random.randint(0, interval)  # splay multiple servers",
            "        janitor = neutron_worker.PeriodicWorker(self._clean_garbage, interval,",
            "                                                initial_delay)",
            "        self.add_worker(janitor)",
            "",
            "    def _clean_garbage(self):",
            "        if not hasattr(self, '_candidate_broken_fip_ports'):",
            "            self._candidate_broken_fip_ports = set()",
            "        context = n_ctx.get_admin_context()",
            "        candidates = self._get_dead_floating_port_candidates(context)",
            "        # just because a port is in 'candidates' doesn't necessarily mean",
            "        # it's broken, we could have just caught it before it was updated.",
            "        # We confirm by waiting until the next call of this function to see",
            "        # if it persists.",
            "        to_cleanup = candidates & self._candidate_broken_fip_ports",
            "        self._candidate_broken_fip_ports = candidates - to_cleanup",
            "        for port_id in to_cleanup:",
            "            # ensure it wasn't just a failure to update device_id before we",
            "            # delete it",
            "            try:",
            "                self._fix_or_kill_floating_port(context, port_id)",
            "            except Exception:",
            "                LOG.exception(\"Error cleaning up floating IP port: %s\",",
            "                              port_id)",
            "",
            "    def _fix_or_kill_floating_port(self, context, port_id):",
            "        pager = base_obj.Pager(limit=1)",
            "        fips = l3_obj.FloatingIP.get_objects(",
            "            context, _pager=pager, floating_port_id=port_id)",
            "        if fips:",
            "            LOG.warning(\"Found incorrect device_id on floating port \"",
            "                        \"%(pid)s, correcting to %(fip)s.\",",
            "                        {'pid': port_id, 'fip': fips[0].id})",
            "            self._core_plugin.update_port(",
            "                context, port_id, {'port': {'device_id': fips[0].id}})",
            "        else:",
            "            LOG.warning(\"Found floating IP port %s without floating IP, \"",
            "                        \"deleting.\", port_id)",
            "            self._core_plugin.delete_port(",
            "                context, port_id, l3_port_check=False)",
            "            registry.notify(resources.FLOATING_IP, events.AFTER_DELETE,",
            "                            self, **fips[0])",
            "",
            "    def _get_dead_floating_port_candidates(self, context):",
            "        filters = {'device_id': ['PENDING'],",
            "                   'device_owner': [DEVICE_OWNER_FLOATINGIP]}",
            "        return {p['id'] for p in self._core_plugin.get_ports(context, filters)}",
            "",
            "    def _get_router(self, context, router_id):",
            "        try:",
            "            router = model_query.get_by_id(",
            "                context, l3_models.Router, router_id)",
            "        except exc.NoResultFound:",
            "            raise l3_exc.RouterNotFound(router_id=router_id)",
            "        return router",
            "",
            "    def _make_router_dict(self, router, fields=None, process_extensions=True):",
            "        res = dict((key, router[key]) for key in CORE_ROUTER_ATTRS)",
            "        if router['gw_port_id']:",
            "            ext_gw_info = {",
            "                'network_id': router.gw_port['network_id'],",
            "                'external_fixed_ips': [{'subnet_id': ip[\"subnet_id\"],",
            "                                        'ip_address': ip[\"ip_address\"]}",
            "                                       for ip in router.gw_port['fixed_ips']]}",
            "        else:",
            "            ext_gw_info = None",
            "        res.update({",
            "            EXTERNAL_GW_INFO: ext_gw_info,",
            "            'gw_port_id': router['gw_port_id'],",
            "        })",
            "        # NOTE(salv-orlando): The following assumes this mixin is used in a",
            "        # class inheriting from CommonDbMixin, which is true for all existing",
            "        # plugins.",
            "        if process_extensions:",
            "            resource_extend.apply_funcs(l3_apidef.ROUTERS, res, router)",
            "        return db_utils.resource_fields(res, fields)",
            "",
            "    def _create_router_db(self, context, router, tenant_id):",
            "        \"\"\"Create the DB object.\"\"\"",
            "        router.setdefault('id', uuidutils.generate_uuid())",
            "        router['tenant_id'] = tenant_id",
            "        registry.notify(resources.ROUTER, events.BEFORE_CREATE,",
            "                        self, context=context, router=router)",
            "        with context.session.begin(subtransactions=True):",
            "            # pre-generate id so it will be available when",
            "            # configuring external gw port",
            "            router_db = l3_models.Router(",
            "                id=router['id'],",
            "                tenant_id=router['tenant_id'],",
            "                name=router['name'],",
            "                admin_state_up=router['admin_state_up'],",
            "                status=constants.ACTIVE,",
            "                description=router.get('description'))",
            "            context.session.add(router_db)",
            "            registry.notify(resources.ROUTER, events.PRECOMMIT_CREATE,",
            "                            self, context=context, router=router,",
            "                            router_id=router['id'], router_db=router_db)",
            "            return router_db",
            "",
            "    def _update_gw_for_create_router(self, context, gw_info, router_id):",
            "        if gw_info:",
            "            router_db = self._get_router(context, router_id)",
            "            self._update_router_gw_info(context, router_id,",
            "                                        gw_info, router=router_db)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def create_router(self, context, router):",
            "        r = router['router']",
            "        gw_info = r.pop(EXTERNAL_GW_INFO, None)",
            "        create = functools.partial(self._create_router_db, context, r,",
            "                                   r['tenant_id'])",
            "        delete = functools.partial(self.delete_router, context)",
            "        update_gw = functools.partial(self._update_gw_for_create_router,",
            "                                      context, gw_info)",
            "        router_db, _unused = db_utils.safe_creation(context, create,",
            "                                                    delete, update_gw,",
            "                                                    transaction=False)",
            "        new_router = self._make_router_dict(router_db)",
            "        registry.notify(resources.ROUTER, events.AFTER_CREATE, self,",
            "                        context=context, router_id=router_db.id,",
            "                        router=new_router, request_attrs=r,",
            "                        router_db=router_db)",
            "        return new_router",
            "",
            "    def _update_router_db(self, context, router_id, data):",
            "        \"\"\"Update the DB object.\"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            router_db = self._get_router(context, router_id)",
            "            old_router = self._make_router_dict(router_db)",
            "            if data:",
            "                router_db.update(data)",
            "            registry.publish(resources.ROUTER, events.PRECOMMIT_UPDATE, self,",
            "                             payload=events.DBEventPayload(",
            "                                 context, request_body=data,",
            "                                 states=(old_router,), resource_id=router_id,",
            "                                 desired_state=router_db))",
            "            return router_db",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_router(self, context, id, router):",
            "        r = router['router']",
            "        gw_info = r.pop(EXTERNAL_GW_INFO, constants.ATTR_NOT_SPECIFIED)",
            "        original = self.get_router(context, id)",
            "        # check whether router needs and can be rescheduled to the proper",
            "        # l3 agent (associated with given external network);",
            "        # do check before update in DB as an exception will be raised",
            "        # in case no proper l3 agent found",
            "        if gw_info != constants.ATTR_NOT_SPECIFIED:",
            "            candidates = self._check_router_needs_rescheduling(",
            "                context, id, gw_info)",
            "            # Update the gateway outside of the DB update since it involves L2",
            "            # calls that don't make sense to rollback and may cause deadlocks",
            "            # in a transaction.",
            "            self._update_router_gw_info(context, id, gw_info)",
            "        else:",
            "            candidates = None",
            "        router_db = self._update_router_db(context, id, r)",
            "        if candidates:",
            "            l3_plugin = directory.get_plugin(plugin_constants.L3)",
            "            l3_plugin.reschedule_router(context, id, candidates)",
            "        updated = self._make_router_dict(router_db)",
            "        registry.notify(resources.ROUTER, events.AFTER_UPDATE, self,",
            "                        context=context, router_id=id, old_router=original,",
            "                        router=updated, request_attrs=r, router_db=router_db)",
            "        return updated",
            "",
            "    def _check_router_needs_rescheduling(self, context, router_id, gw_info):",
            "        \"\"\"Checks whether router's l3 agent can handle the given network",
            "",
            "        When external_network_bridge is set, each L3 agent can be associated",
            "        with at most one external network. If router's new external gateway",
            "        is on other network then the router needs to be rescheduled to the",
            "        proper l3 agent.",
            "        If external_network_bridge is not set then the agent",
            "        can support multiple external networks and rescheduling is not needed",
            "",
            "        :return: list of candidate agents if rescheduling needed,",
            "        None otherwise; raises exception if there is no eligible l3 agent",
            "        associated with target external network",
            "        \"\"\"",
            "        # TODO(obondarev): rethink placement of this func as l3 db manager is",
            "        # not really a proper place for agent scheduling stuff",
            "        network_id = gw_info.get('network_id') if gw_info else None",
            "        if not network_id:",
            "            return",
            "",
            "        nets = self._core_plugin.get_networks(",
            "            context, {extnet_apidef.EXTERNAL: [True]})",
            "        # nothing to do if there is only one external network",
            "        if len(nets) <= 1:",
            "            return",
            "",
            "        # first get plugin supporting l3 agent scheduling",
            "        # (either l3 service plugin or core_plugin)",
            "        l3_plugin = directory.get_plugin(plugin_constants.L3)",
            "        if (not extensions.is_extension_supported(",
            "                l3_plugin,",
            "                constants.L3_AGENT_SCHEDULER_EXT_ALIAS) or",
            "                l3_plugin.router_scheduler is None):",
            "            # that might mean that we are dealing with non-agent-based",
            "            # implementation of l3 services",
            "            return",
            "",
            "        if not l3_plugin.router_supports_scheduling(context, router_id):",
            "            return",
            "        cur_agents = l3_plugin.list_l3_agents_hosting_router(",
            "            context, router_id)['agents']",
            "        for agent in cur_agents:",
            "            ext_net_id = agent['configurations'].get(",
            "                'gateway_external_network_id')",
            "            ext_bridge = agent['configurations'].get(",
            "                'external_network_bridge', '')",
            "            if (ext_net_id == network_id or",
            "                    (not ext_net_id and not ext_bridge)):",
            "                return",
            "",
            "        # otherwise find l3 agent with matching gateway_external_network_id",
            "        active_agents = l3_plugin.get_l3_agents(context, active=True)",
            "        router = {",
            "            'id': router_id,",
            "            'external_gateway_info': {'network_id': network_id}",
            "        }",
            "        candidates = l3_plugin.get_l3_agent_candidates(context,",
            "                                                       router,",
            "                                                       active_agents)",
            "        if not candidates:",
            "            msg = (_('No eligible l3 agent associated with external network '",
            "                     '%s found') % network_id)",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "        return candidates",
            "",
            "    def _create_router_gw_port(self, context, router, network_id, ext_ips):",
            "        # Port has no 'tenant-id', as it is hidden from user",
            "        port_data = {'tenant_id': '',  # intentionally not set",
            "                     'network_id': network_id,",
            "                     'fixed_ips': ext_ips or constants.ATTR_NOT_SPECIFIED,",
            "                     'device_id': router['id'],",
            "                     'device_owner': DEVICE_OWNER_ROUTER_GW,",
            "                     'admin_state_up': True,",
            "                     'name': ''}",
            "        gw_port = p_utils.create_port(self._core_plugin,",
            "                                      context.elevated(), {'port': port_data})",
            "",
            "        if not gw_port['fixed_ips']:",
            "            LOG.debug('No IPs available for external network %s',",
            "                      network_id)",
            "        with plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context.elevated(), gw_port['id']):",
            "            with context.session.begin(subtransactions=True):",
            "                router.gw_port = self._core_plugin._get_port(",
            "                    context.elevated(), gw_port['id'])",
            "                router_port = l3_obj.RouterPort(",
            "                    context,",
            "                    router_id=router.id,",
            "                    port_id=gw_port['id'],",
            "                    port_type=DEVICE_OWNER_ROUTER_GW",
            "                )",
            "                context.session.add(router)",
            "                router_port.create()",
            "",
            "    def _validate_gw_info(self, context, gw_port, info, ext_ips):",
            "        network_id = info['network_id'] if info else None",
            "        if network_id:",
            "            network_db = self._core_plugin._get_network(context, network_id)",
            "            if not network_db.external:",
            "                msg = _(\"Network %s is not an external network\") % network_id",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "            if ext_ips:",
            "                subnets = self._core_plugin.get_subnets_by_network(context,",
            "                                                                   network_id)",
            "                for s in subnets:",
            "                    if not s['gateway_ip']:",
            "                        continue",
            "                    for ext_ip in ext_ips:",
            "                        if ext_ip.get('ip_address') == s['gateway_ip']:",
            "                            msg = _(\"External IP %s is the same as the \"",
            "                                    \"gateway IP\") % ext_ip.get('ip_address')",
            "                            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return network_id",
            "",
            "    # NOTE(yamamoto): This method is an override point for plugins",
            "    # inheriting this class.  Do not optimize this out.",
            "    def router_gw_port_has_floating_ips(self, context, router_id):",
            "        \"\"\"Return True if the router's gateway port is serving floating IPs.\"\"\"",
            "        return bool(self.get_floatingips_count(context,",
            "                                               {'router_id': [router_id]}))",
            "",
            "    def _delete_current_gw_port(self, context, router_id, router,",
            "                                new_network_id):",
            "        \"\"\"Delete gw port if attached to an old network.\"\"\"",
            "        port_requires_deletion = (",
            "            router.gw_port and router.gw_port['network_id'] != new_network_id)",
            "        if not port_requires_deletion:",
            "            return",
            "        admin_ctx = context.elevated()",
            "        old_network_id = router.gw_port['network_id']",
            "",
            "        if self.router_gw_port_has_floating_ips(admin_ctx, router_id):",
            "            raise l3_exc.RouterExternalGatewayInUseByFloatingIp(",
            "                router_id=router_id, net_id=router.gw_port['network_id'])",
            "        gw_ips = [x['ip_address'] for x in router.gw_port['fixed_ips']]",
            "        gw_port_id = router.gw_port['id']",
            "        self._delete_router_gw_port_db(context, router)",
            "        self._core_plugin.delete_port(",
            "            admin_ctx, gw_port_id, l3_port_check=False)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        registry.notify(resources.ROUTER_GATEWAY,",
            "                        events.AFTER_DELETE, self,",
            "                        router_id=router_id,",
            "                        context=context,",
            "                        router=router,",
            "                        network_id=old_network_id,",
            "                        new_network_id=new_network_id,",
            "                        gateway_ips=gw_ips)",
            "",
            "    def _delete_router_gw_port_db(self, context, router):",
            "        with context.session.begin(subtransactions=True):",
            "            router.gw_port = None",
            "            if router not in context.session:",
            "                context.session.add(router)",
            "            try:",
            "                kwargs = {'context': context, 'router_id': router.id}",
            "                registry.notify(",
            "                    resources.ROUTER_GATEWAY, events.BEFORE_DELETE, self,",
            "                    **kwargs)",
            "            except exceptions.CallbackFailure as e:",
            "                # NOTE(armax): preserve old check's behavior",
            "                if len(e.errors) == 1:",
            "                    raise e.errors[0].error",
            "                raise l3_exc.RouterInUse(router_id=router.id, reason=e)",
            "",
            "    def _create_gw_port(self, context, router_id, router, new_network_id,",
            "                        ext_ips):",
            "        new_valid_gw_port_attachment = (",
            "            new_network_id and (not router.gw_port or",
            "                              router.gw_port['network_id'] != new_network_id))",
            "        if new_valid_gw_port_attachment:",
            "            subnets = self._core_plugin.get_subnets_by_network(context,",
            "                                                               new_network_id)",
            "            try:",
            "                kwargs = {'context': context, 'router_id': router_id,",
            "                          'network_id': new_network_id, 'subnets': subnets}",
            "                registry.notify(",
            "                    resources.ROUTER_GATEWAY, events.BEFORE_CREATE, self,",
            "                    **kwargs)",
            "            except exceptions.CallbackFailure as e:",
            "                # raise the underlying exception",
            "                raise e.errors[0].error",
            "",
            "            self._check_for_dup_router_subnets(context, router,",
            "                                               new_network_id,",
            "                                               subnets,",
            "                                               include_gateway=True)",
            "            self._create_router_gw_port(context, router,",
            "                                        new_network_id, ext_ips)",
            "            registry.notify(resources.ROUTER_GATEWAY,",
            "                            events.AFTER_CREATE,",
            "                            self._create_gw_port,",
            "                            gw_ips=ext_ips,",
            "                            network_id=new_network_id,",
            "                            router_id=router_id)",
            "",
            "    def _update_current_gw_port(self, context, router_id, router, ext_ips):",
            "        self._core_plugin.update_port(context, router.gw_port['id'], {'port':",
            "                                      {'fixed_ips': ext_ips}})",
            "        context.session.expire(router.gw_port)",
            "",
            "    def _update_router_gw_info(self, context, router_id, info, router=None):",
            "        # TODO(salvatore-orlando): guarantee atomic behavior also across",
            "        # operations that span beyond the model classes handled by this",
            "        # class (e.g.: delete_port)",
            "        router = router or self._get_router(context, router_id)",
            "        gw_port = router.gw_port",
            "        ext_ips = info.get('external_fixed_ips') if info else []",
            "        ext_ip_change = self._check_for_external_ip_change(",
            "            context, gw_port, ext_ips)",
            "        network_id = self._validate_gw_info(context, gw_port, info, ext_ips)",
            "        if gw_port and ext_ip_change and gw_port['network_id'] == network_id:",
            "            self._update_current_gw_port(context, router_id, router,",
            "                                         ext_ips)",
            "        else:",
            "            self._delete_current_gw_port(context, router_id, router,",
            "                                         network_id)",
            "            self._create_gw_port(context, router_id, router, network_id,",
            "                                 ext_ips)",
            "",
            "    def _check_for_external_ip_change(self, context, gw_port, ext_ips):",
            "        # determine if new external IPs differ from the existing fixed_ips",
            "        if not ext_ips:",
            "            # no external_fixed_ips were included",
            "            return False",
            "        if not gw_port:",
            "            return True",
            "",
            "        subnet_ids = set(ip['subnet_id'] for ip in gw_port['fixed_ips'])",
            "        new_subnet_ids = set(f['subnet_id'] for f in ext_ips",
            "                             if f.get('subnet_id'))",
            "        subnet_change = not new_subnet_ids == subnet_ids",
            "        if subnet_change:",
            "            return True",
            "        ip_addresses = set(ip['ip_address'] for ip in gw_port['fixed_ips'])",
            "        new_ip_addresses = set(f['ip_address'] for f in ext_ips",
            "                               if f.get('ip_address'))",
            "        ip_address_change = not ip_addresses == new_ip_addresses",
            "        return ip_address_change",
            "",
            "    def _ensure_router_not_in_use(self, context, router_id):",
            "        \"\"\"Ensure that no internal network interface is attached",
            "        to the router.",
            "        \"\"\"",
            "        router = self._get_router(context, router_id)",
            "        device_owner = self._get_device_owner(context, router)",
            "        if any(rp.port_type == device_owner",
            "               for rp in router.attached_ports):",
            "            raise l3_exc.RouterInUse(router_id=router_id)",
            "        return router",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_router(self, context, id):",
            "        registry.notify(resources.ROUTER, events.BEFORE_DELETE,",
            "                        self, context=context, router_id=id)",
            "        # TODO(nati) Refactor here when we have router insertion model",
            "        router = self._ensure_router_not_in_use(context, id)",
            "        original = self._make_router_dict(router)",
            "        self._delete_current_gw_port(context, id, router, None)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "",
            "        router_ports = router.attached_ports",
            "        for rp in router_ports:",
            "            self._core_plugin.delete_port(context.elevated(),",
            "                                          rp.port.id,",
            "                                          l3_port_check=False)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "            registry.notify(resources.ROUTER, events.PRECOMMIT_DELETE,",
            "                            self, context=context, router_db=router,",
            "                            router_id=id)",
            "            # we bump the revision even though we are about to delete to throw",
            "            # staledataerror if something snuck in with a new interface",
            "            router.bump_revision()",
            "            context.session.flush()",
            "            context.session.delete(router)",
            "        registry.notify(resources.ROUTER, events.AFTER_DELETE, self,",
            "                        context=context, router_id=id, original=original)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_router(self, context, id, fields=None):",
            "        router = self._get_router(context, id)",
            "        return self._make_router_dict(router, fields)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_routers(self, context, filters=None, fields=None,",
            "                    sorts=None, limit=None, marker=None,",
            "                    page_reverse=False):",
            "        marker_obj = db_utils.get_marker_obj(self, context, 'router',",
            "                                             limit, marker)",
            "        return model_query.get_collection(context, l3_models.Router,",
            "                                          self._make_router_dict,",
            "                                          filters=filters, fields=fields,",
            "                                          sorts=sorts,",
            "                                          limit=limit,",
            "                                          marker_obj=marker_obj,",
            "                                          page_reverse=page_reverse)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_routers_count(self, context, filters=None):",
            "        return model_query.get_collection_count(context, l3_models.Router,",
            "                                                filters=filters)",
            "",
            "    def _check_for_dup_router_subnets(self, context, router,",
            "                                      network_id, new_subnets,",
            "                                      include_gateway=False):",
            "        # It's possible these ports are on the same network, but",
            "        # different subnets.",
            "        new_subnet_ids = {s['id'] for s in new_subnets}",
            "        router_subnets = []",
            "        for p in (rp.port for rp in router.attached_ports):",
            "            for ip in p['fixed_ips']:",
            "                if ip['subnet_id'] in new_subnet_ids:",
            "                    msg = (_(\"Router already has a port on subnet %s\")",
            "                           % ip['subnet_id'])",
            "                    raise n_exc.BadRequest(resource='router', msg=msg)",
            "                gw_owner = (p.get('device_owner') == DEVICE_OWNER_ROUTER_GW)",
            "                if include_gateway == gw_owner:",
            "                    router_subnets.append(ip['subnet_id'])",
            "",
            "        # Ignore temporary Prefix Delegation CIDRs",
            "        new_subnets = [s for s in new_subnets",
            "                       if s['cidr'] != constants.PROVISIONAL_IPV6_PD_PREFIX]",
            "        id_filter = {'id': router_subnets}",
            "        subnets = self._core_plugin.get_subnets(context.elevated(),",
            "                                                filters=id_filter)",
            "        for sub in subnets:",
            "            cidr = sub['cidr']",
            "            ipnet = netaddr.IPNetwork(cidr)",
            "            for s in new_subnets:",
            "                new_cidr = s['cidr']",
            "                new_ipnet = netaddr.IPNetwork(new_cidr)",
            "                match1 = netaddr.all_matching_cidrs(new_ipnet, [cidr])",
            "                match2 = netaddr.all_matching_cidrs(ipnet, [new_cidr])",
            "                if match1 or match2:",
            "                    data = {'subnet_cidr': new_cidr,",
            "                            'subnet_id': s['id'],",
            "                            'cidr': cidr,",
            "                            'sub_id': sub['id']}",
            "                    msg = (_(\"Cidr %(subnet_cidr)s of subnet \"",
            "                             \"%(subnet_id)s overlaps with cidr %(cidr)s \"",
            "                             \"of subnet %(sub_id)s\") % data)",
            "                    raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "    def _get_device_owner(self, context, router=None):",
            "        \"\"\"Get device_owner for the specified router.\"\"\"",
            "        # NOTE(armando-migliaccio): in the base case this is invariant",
            "        return DEVICE_OWNER_ROUTER_INTF",
            "",
            "    def _validate_interface_info(self, interface_info, for_removal=False):",
            "        port_id_specified = interface_info and 'port_id' in interface_info",
            "        subnet_id_specified = interface_info and 'subnet_id' in interface_info",
            "        if not (port_id_specified or subnet_id_specified):",
            "            msg = _(\"Either subnet_id or port_id must be specified\")",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        for key in ('port_id', 'subnet_id'):",
            "            if key not in interface_info:",
            "                continue",
            "            err = validators.validate_uuid(interface_info[key])",
            "            if err:",
            "                raise n_exc.BadRequest(resource='router', msg=err)",
            "        if not for_removal:",
            "            if port_id_specified and subnet_id_specified:",
            "                msg = _(\"Cannot specify both subnet-id and port-id\")",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return port_id_specified, subnet_id_specified",
            "",
            "    def _check_router_port(self, context, port_id, device_id):",
            "        \"\"\"Check that a port is available for an attachment to a router",
            "",
            "        :param context: The context of the request.",
            "        :param port_id: The port to be attached.",
            "        :param device_id: This method will check that device_id corresponds to",
            "        the device_id of the port. It raises PortInUse exception if it",
            "        doesn't.",
            "        :returns: The port description returned by the core plugin.",
            "        :raises: PortInUse if the device_id is not the same as the port's one.",
            "        :raises: BadRequest if the port has no fixed IP.",
            "        \"\"\"",
            "        port = self._core_plugin.get_port(context, port_id)",
            "        if port['device_id'] != device_id:",
            "            raise n_exc.PortInUse(net_id=port['network_id'],",
            "                                  port_id=port['id'],",
            "                                  device_id=port['device_id'])",
            "        if not port['fixed_ips']:",
            "            msg = _('Router port must have at least one fixed IP')",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return port",
            "",
            "    def _validate_router_port_info(self, context, router, port_id):",
            "        with db_api.autonested_transaction(context.session):",
            "            # check again within transaction to mitigate race",
            "            port = self._check_router_port(context, port_id, router.id)",
            "",
            "            # Only allow one router port with IPv6 subnets per network id",
            "            if self._port_has_ipv6_address(port):",
            "                for existing_port in (rp.port for rp in router.attached_ports):",
            "                    if (existing_port['network_id'] == port['network_id'] and",
            "                            self._port_has_ipv6_address(existing_port)):",
            "                        msg = _(\"Cannot have multiple router ports with the \"",
            "                                \"same network id if both contain IPv6 \"",
            "                                \"subnets. Existing port %(p)s has IPv6 \"",
            "                                \"subnet(s) and network id %(nid)s\")",
            "                        raise n_exc.BadRequest(resource='router', msg=msg % {",
            "                            'p': existing_port['id'],",
            "                            'nid': existing_port['network_id']})",
            "",
            "            fixed_ips = [ip for ip in port['fixed_ips']]",
            "            subnets = []",
            "            for fixed_ip in fixed_ips:",
            "                subnet = self._core_plugin.get_subnet(context,",
            "                                                      fixed_ip['subnet_id'])",
            "                subnets.append(subnet)",
            "",
            "            if subnets:",
            "                self._check_for_dup_router_subnets(context, router,",
            "                                                   port['network_id'],",
            "                                                   subnets)",
            "",
            "            # Keep the restriction against multiple IPv4 subnets",
            "            if len([s for s in subnets if s['ip_version'] == 4]) > 1:",
            "                msg = _(\"Cannot have multiple \"",
            "                        \"IPv4 subnets on router port\")",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "            return port, subnets",
            "",
            "    def _notify_attaching_interface(self, context, router_db, port,",
            "                                    interface_info):",
            "        \"\"\"Notify third party code that an interface is being attached to a",
            "        router",
            "",
            "        :param context: The context of the request.",
            "        :param router_db: The router db object having an interface attached.",
            "        :param port: The port object being attached to the router.",
            "        :param interface_info: The requested interface attachment info passed",
            "        to add_router_interface.",
            "        :raises: RouterInterfaceAttachmentConflict if a third party code",
            "        prevent the port to be attach to the router.",
            "        \"\"\"",
            "        try:",
            "            registry.notify(resources.ROUTER_INTERFACE,",
            "                            events.BEFORE_CREATE,",
            "                            self,",
            "                            context=context,",
            "                            router_db=router_db,",
            "                            port=port,",
            "                            interface_info=interface_info,",
            "                            router_id=router_db.id,",
            "                            network_id=port['network_id'])",
            "        except exceptions.CallbackFailure as e:",
            "            # raise the underlying exception",
            "            reason = (_('cannot perform router interface attachment '",
            "                        'due to %(reason)s') % {'reason': e})",
            "            raise l3_exc.RouterInterfaceAttachmentConflict(reason=reason)",
            "",
            "    def _add_interface_by_port(self, context, router, port_id, owner):",
            "        # Update owner before actual process in order to avoid the",
            "        # case where a port might get attached to a router without the",
            "        # owner successfully updating due to an unavailable backend.",
            "        self._core_plugin.update_port(",
            "            context, port_id, {'port': {'device_id': router.id,",
            "                                        'device_owner': owner}})",
            "",
            "        return self._validate_router_port_info(context, router, port_id)",
            "",
            "    def _port_has_ipv6_address(self, port):",
            "        for fixed_ip in port['fixed_ips']:",
            "            if netaddr.IPNetwork(fixed_ip['ip_address']).version == 6:",
            "                return True",
            "",
            "    def _find_ipv6_router_port_by_network(self, context, router, net_id):",
            "        router_dev_owner = self._get_device_owner(context, router)",
            "        for port in router.attached_ports:",
            "            p = port['port']",
            "            if p['device_owner'] != router_dev_owner:",
            "                # we don't want any special purpose internal ports",
            "                continue",
            "            if p['network_id'] == net_id and self._port_has_ipv6_address(p):",
            "                return port",
            "",
            "    def _add_interface_by_subnet(self, context, router, subnet_id, owner):",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "        if not subnet['gateway_ip']:",
            "            msg = _('Subnet for router interface must have a gateway IP')",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        if (subnet['ip_version'] == 6 and subnet['ipv6_ra_mode'] is None and",
            "                subnet['ipv6_address_mode'] is not None):",
            "            msg = (_('IPv6 subnet %s configured to receive RAs from an '",
            "                   'external router cannot be added to Neutron Router.') %",
            "                   subnet['id'])",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        self._check_for_dup_router_subnets(context, router,",
            "                                           subnet['network_id'], [subnet])",
            "        fixed_ip = {'ip_address': subnet['gateway_ip'],",
            "                    'subnet_id': subnet['id']}",
            "",
            "        if (subnet['ip_version'] == 6 and not",
            "                ipv6_utils.is_ipv6_pd_enabled(subnet)):",
            "            # Add new prefix to an existing ipv6 port with the same network id",
            "            # if one exists",
            "            port = self._find_ipv6_router_port_by_network(context, router,",
            "                                                          subnet['network_id'])",
            "            if port:",
            "                fixed_ips = list(map(dict, port['port']['fixed_ips']))",
            "                fixed_ips.append(fixed_ip)",
            "                return self._core_plugin.update_port(context,",
            "                        port['port_id'], {'port':",
            "                            {'fixed_ips': fixed_ips}}), [subnet], False",
            "",
            "        port_data = {'tenant_id': router.tenant_id,",
            "                     'network_id': subnet['network_id'],",
            "                     'fixed_ips': [fixed_ip],",
            "                     'admin_state_up': True,",
            "                     'device_id': router.id,",
            "                     'device_owner': owner,",
            "                     'name': ''}",
            "        return p_utils.create_port(self._core_plugin, context,",
            "                                   {'port': port_data}), [subnet], True",
            "",
            "    @staticmethod",
            "    def _make_router_interface_info(",
            "            router_id, tenant_id, port_id, network_id, subnet_id, subnet_ids):",
            "        return {",
            "            'id': router_id,",
            "            'tenant_id': tenant_id,",
            "            'port_id': port_id,",
            "            'network_id': network_id,",
            "            'subnet_id': subnet_id,  # deprecated by IPv6 multi-prefix",
            "            'subnet_ids': subnet_ids",
            "        }",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def add_router_interface(self, context, router_id, interface_info=None):",
            "        router = self._get_router(context, router_id)",
            "        add_by_port, add_by_sub = self._validate_interface_info(interface_info)",
            "        device_owner = self._get_device_owner(context, router_id)",
            "",
            "        # This should be True unless adding an IPv6 prefix to an existing port",
            "        new_router_intf = True",
            "        cleanup_port = False",
            "",
            "        if add_by_port:",
            "            port_id = interface_info['port_id']",
            "            port = self._check_router_port(context, port_id, '')",
            "            revert_value = {'device_id': '',",
            "                            'device_owner': port['device_owner']}",
            "            with plugin_utils.update_port_on_error(",
            "                    self._core_plugin, context, port_id, revert_value):",
            "                port, subnets = self._add_interface_by_port(",
            "                    context, router, port_id, device_owner)",
            "        # add_by_subnet is not used here, because the validation logic of",
            "        # _validate_interface_info ensures that either of add_by_* is True.",
            "        else:",
            "            port, subnets, new_router_intf = self._add_interface_by_subnet(",
            "                    context, router, interface_info['subnet_id'], device_owner)",
            "            cleanup_port = new_router_intf  # only cleanup port we created",
            "            revert_value = {'device_id': '',",
            "                            'device_owner': port['device_owner']}",
            "",
            "        if cleanup_port:",
            "            mgr = plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context, port['id'])",
            "        else:",
            "            mgr = plugin_utils.update_port_on_error(",
            "                self._core_plugin, context, port['id'], revert_value)",
            "",
            "        if new_router_intf:",
            "            with mgr:",
            "                self._notify_attaching_interface(context, router_db=router,",
            "                                                 port=port,",
            "                                                 interface_info=interface_info)",
            "                l3_obj.RouterPort(",
            "                    context,",
            "                    port_id=port['id'],",
            "                    router_id=router.id,",
            "                    port_type=device_owner",
            "                ).create()",
            "                # Update owner after actual process again in order to",
            "                # make sure the records in routerports table and ports",
            "                # table are consistent.",
            "                self._core_plugin.update_port(",
            "                    context, port['id'], {'port': {",
            "                                         'device_id': router.id,",
            "                                         'device_owner': device_owner}})",
            "",
            "        gw_ips = []",
            "        gw_network_id = None",
            "        if router.gw_port:",
            "            gw_network_id = router.gw_port.network_id",
            "            gw_ips = [x['ip_address'] for x in router.gw_port.fixed_ips]",
            "",
            "        registry.notify(resources.ROUTER_INTERFACE,",
            "                        events.AFTER_CREATE,",
            "                        self,",
            "                        context=context,",
            "                        network_id=gw_network_id,",
            "                        gateway_ips=gw_ips,",
            "                        cidrs=[x['cidr'] for x in subnets],",
            "                        subnets=subnets,",
            "                        port_id=port['id'],",
            "                        router_id=router_id,",
            "                        port=port,",
            "                        new_interface=new_router_intf,",
            "                        interface_info=interface_info)",
            "",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        return self._make_router_interface_info(",
            "            router.id, port['tenant_id'], port['id'], port['network_id'],",
            "            subnets[-1]['id'], [subnet['id'] for subnet in subnets])",
            "",
            "    def _confirm_router_interface_not_in_use(self, context, router_id,",
            "                                             subnet_id):",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "        subnet_cidr = netaddr.IPNetwork(subnet['cidr'])",
            "        try:",
            "            kwargs = {'context': context, 'router_id': router_id,",
            "                      'subnet_id': subnet_id}",
            "            registry.notify(",
            "                resources.ROUTER_INTERFACE,",
            "                events.BEFORE_DELETE, self, **kwargs)",
            "        except exceptions.CallbackFailure as e:",
            "            # NOTE(armax): preserve old check's behavior",
            "            if len(e.errors) == 1:",
            "                raise e.errors[0].error",
            "            raise l3_exc.RouterInUse(router_id=router_id, reason=e)",
            "        fip_objs = l3_obj.FloatingIP.get_objects(context, router_id=router_id)",
            "        for fip_obj in fip_objs:",
            "            if fip_obj.fixed_ip_address in subnet_cidr:",
            "                raise l3_exc.RouterInterfaceInUseByFloatingIP(",
            "                    router_id=router_id, subnet_id=subnet_id)",
            "",
            "    def _remove_interface_by_port(self, context, router_id,",
            "                                  port_id, subnet_id, owner):",
            "        obj = l3_obj.RouterPort.get_object(",
            "            context,",
            "            port_id=port_id,",
            "            router_id=router_id,",
            "            port_type=owner",
            "        )",
            "        if obj:",
            "            try:",
            "                port = self._core_plugin.get_port(context, obj.port_id)",
            "            except n_exc.PortNotFound:",
            "                raise l3_exc.RouterInterfaceNotFound(",
            "                    router_id=router_id, port_id=port_id)",
            "        else:",
            "            raise l3_exc.RouterInterfaceNotFound(",
            "                router_id=router_id, port_id=port_id)",
            "        port_subnet_ids = [fixed_ip['subnet_id']",
            "                           for fixed_ip in port['fixed_ips']]",
            "        if subnet_id and subnet_id not in port_subnet_ids:",
            "            raise n_exc.SubnetMismatchForPort(",
            "                port_id=port_id, subnet_id=subnet_id)",
            "        subnets = [self._core_plugin.get_subnet(context, port_subnet_id)",
            "                   for port_subnet_id in port_subnet_ids]",
            "        for port_subnet_id in port_subnet_ids:",
            "            self._confirm_router_interface_not_in_use(",
            "                    context, router_id, port_subnet_id)",
            "        self._core_plugin.delete_port(context, port['id'],",
            "                                      l3_port_check=False)",
            "        return (port, subnets)",
            "",
            "    def _remove_interface_by_subnet(self, context,",
            "                                    router_id, subnet_id, owner):",
            "        self._confirm_router_interface_not_in_use(",
            "            context, router_id, subnet_id)",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "",
            "        try:",
            "            ports = port_obj.Port.get_ports_by_router(",
            "                context, router_id, owner, subnet)",
            "",
            "            for p in ports:",
            "                try:",
            "                    p = self._core_plugin.get_port(context, p.id)",
            "                except n_exc.PortNotFound:",
            "                    continue",
            "                port_subnets = [fip['subnet_id'] for fip in p['fixed_ips']]",
            "                if subnet_id in port_subnets and len(port_subnets) > 1:",
            "                    # multiple prefix port - delete prefix from port",
            "                    fixed_ips = [dict(fip) for fip in p['fixed_ips']",
            "                                 if fip['subnet_id'] != subnet_id]",
            "                    self._core_plugin.update_port(context, p['id'],",
            "                            {'port':",
            "                                {'fixed_ips': fixed_ips}})",
            "                    return (p, [subnet])",
            "                elif subnet_id in port_subnets:",
            "                    # only one subnet on port - delete the port",
            "                    self._core_plugin.delete_port(context, p['id'],",
            "                                                  l3_port_check=False)",
            "                    return (p, [subnet])",
            "        except exc.NoResultFound:",
            "            pass",
            "        raise l3_exc.RouterInterfaceNotFoundForSubnet(",
            "            router_id=router_id, subnet_id=subnet_id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def remove_router_interface(self, context, router_id, interface_info):",
            "        remove_by_port, remove_by_subnet = (",
            "            self._validate_interface_info(interface_info, for_removal=True)",
            "        )",
            "        port_id = interface_info.get('port_id')",
            "        subnet_id = interface_info.get('subnet_id')",
            "        device_owner = self._get_device_owner(context, router_id)",
            "        if remove_by_port:",
            "            port, subnets = self._remove_interface_by_port(context, router_id,",
            "                                                           port_id, subnet_id,",
            "                                                           device_owner)",
            "        # remove_by_subnet is not used here, because the validation logic of",
            "        # _validate_interface_info ensures that at least one of remote_by_*",
            "        # is True.",
            "        else:",
            "            port, subnets = self._remove_interface_by_subnet(",
            "                    context, router_id, subnet_id, device_owner)",
            "",
            "        gw_network_id = None",
            "        gw_ips = []",
            "        router = self._get_router(context, router_id)",
            "        if router.gw_port:",
            "            gw_network_id = router.gw_port.network_id",
            "            gw_ips = [x['ip_address'] for x in router.gw_port.fixed_ips]",
            "",
            "        registry.notify(resources.ROUTER_INTERFACE,",
            "                        events.AFTER_DELETE,",
            "                        self,",
            "                        context=context,",
            "                        cidrs=[x['cidr'] for x in subnets],",
            "                        network_id=gw_network_id,",
            "                        gateway_ips=gw_ips,",
            "                        port=port,",
            "                        router_id=router_id,",
            "                        interface_info=interface_info)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        return self._make_router_interface_info(router_id, port['tenant_id'],",
            "                                                port['id'], port['network_id'],",
            "                                                subnets[0]['id'],",
            "                                                [subnet['id'] for subnet in",
            "                                                    subnets])",
            "",
            "    def _get_floatingip(self, context, id):",
            "        floatingip = l3_obj.FloatingIP.get_object(context, id=id)",
            "        if not floatingip:",
            "            raise l3_exc.FloatingIPNotFound(floatingip_id=id)",
            "        return floatingip",
            "",
            "    def _make_floatingip_dict(self, floatingip, fields=None,",
            "                              process_extensions=True):",
            "        floating_ip_address = (str(floatingip.floating_ip_address)",
            "            if floatingip.floating_ip_address else None)",
            "        fixed_ip_address = (str(floatingip.fixed_ip_address)",
            "            if floatingip.fixed_ip_address else None)",
            "        res = {'id': floatingip.id,",
            "               'tenant_id': floatingip.project_id,",
            "               'floating_ip_address': floating_ip_address,",
            "               'floating_network_id': floatingip.floating_network_id,",
            "               'router_id': floatingip.router_id,",
            "               'port_id': floatingip.fixed_port_id,",
            "               'fixed_ip_address': fixed_ip_address,",
            "               'status': floatingip.status}",
            "        # NOTE(mlavalle): The following assumes this mixin is used in a",
            "        # class inheriting from CommonDbMixin, which is true for all existing",
            "        # plugins.",
            "        # TODO(lujinluo): Change floatingip.db_obj to floatingip once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        if process_extensions:",
            "            resource_extend.apply_funcs(",
            "                l3_apidef.FLOATINGIPS, res, floatingip.db_obj)",
            "        return db_utils.resource_fields(res, fields)",
            "",
            "    def _get_router_for_floatingip(self, context, internal_port,",
            "                                   internal_subnet_id,",
            "                                   external_network_id):",
            "        subnet = self._core_plugin.get_subnet(context, internal_subnet_id)",
            "        return self.get_router_for_floatingip(context,",
            "            internal_port, subnet, external_network_id)",
            "",
            "    # NOTE(yamamoto): This method is an override point for plugins",
            "    # inheriting this class.  Do not optimize this out.",
            "    def get_router_for_floatingip(self, context, internal_port,",
            "                                  internal_subnet, external_network_id):",
            "        \"\"\"Find a router to handle the floating-ip association.",
            "",
            "        :param internal_port: The port for the fixed-ip.",
            "        :param internal_subnet: The subnet for the fixed-ip.",
            "        :param external_network_id: The external network for floating-ip.",
            "",
            "        :raises: ExternalGatewayForFloatingIPNotFound if no suitable router",
            "                 is found.",
            "        \"\"\"",
            "",
            "        # Find routers(with router_id and interface address) that",
            "        # connect given internal subnet and the external network.",
            "        # Among them, if the router's interface address matches",
            "        # with subnet's gateway-ip, return that router.",
            "        # Otherwise return the first router.",
            "        RouterPort = l3_models.RouterPort",
            "        gw_port = orm.aliased(models_v2.Port, name=\"gw_port\")",
            "        # TODO(lujinluo): Need IPAllocation and Port object",
            "        routerport_qry = context.session.query(",
            "            RouterPort.router_id, models_v2.IPAllocation.ip_address).join(",
            "            models_v2.Port, models_v2.IPAllocation).filter(",
            "            models_v2.Port.network_id == internal_port['network_id'],",
            "            RouterPort.port_type.in_(constants.ROUTER_INTERFACE_OWNERS),",
            "            models_v2.IPAllocation.subnet_id == internal_subnet['id']",
            "        ).join(gw_port, gw_port.device_id == RouterPort.router_id).filter(",
            "            gw_port.network_id == external_network_id,",
            "            gw_port.device_owner == DEVICE_OWNER_ROUTER_GW",
            "        ).distinct()",
            "",
            "        first_router_id = None",
            "        for router_id, interface_ip in routerport_qry:",
            "            if interface_ip == internal_subnet['gateway_ip']:",
            "                return router_id",
            "            if not first_router_id:",
            "                first_router_id = router_id",
            "        if first_router_id:",
            "            return first_router_id",
            "",
            "        raise l3_exc.ExternalGatewayForFloatingIPNotFound(",
            "            subnet_id=internal_subnet['id'],",
            "            external_network_id=external_network_id,",
            "            port_id=internal_port['id'])",
            "",
            "    def _port_ipv4_fixed_ips(self, port):",
            "        return [ip for ip in port['fixed_ips']",
            "                if netaddr.IPAddress(ip['ip_address']).version == 4]",
            "",
            "    def _internal_fip_assoc_data(self, context, fip, tenant_id):",
            "        \"\"\"Retrieve internal port data for floating IP.",
            "",
            "        Retrieve information concerning the internal port where",
            "        the floating IP should be associated to.",
            "        \"\"\"",
            "        internal_port = self._core_plugin.get_port(context, fip['port_id'])",
            "        if internal_port['tenant_id'] != tenant_id and not context.is_admin:",
            "            port_id = fip['port_id']",
            "            msg = (_('Cannot process floating IP association with '",
            "                     'Port %s, since that port is owned by a '",
            "                     'different tenant') % port_id)",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        internal_subnet_id = None",
            "        if not utils.is_fip_serviced(internal_port.get('device_owner')):",
            "            msg = _('Port %(id)s is unable to be assigned a floating IP')",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        if fip.get('fixed_ip_address'):",
            "            internal_ip_address = fip['fixed_ip_address']",
            "            if netaddr.IPAddress(internal_ip_address).version != 4:",
            "                msg = (_('Cannot process floating IP association with %s, '",
            "                         'since that is not an IPv4 address') %",
            "                       internal_ip_address)",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            for ip in internal_port['fixed_ips']:",
            "                if ip['ip_address'] == internal_ip_address:",
            "                    internal_subnet_id = ip['subnet_id']",
            "            if not internal_subnet_id:",
            "                msg = (_('Port %(id)s does not have fixed ip %(address)s') %",
            "                       {'id': internal_port['id'],",
            "                        'address': internal_ip_address})",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        else:",
            "            ipv4_fixed_ips = self._port_ipv4_fixed_ips(internal_port)",
            "            if not ipv4_fixed_ips:",
            "                msg = (_('Cannot add floating IP to port %s that has '",
            "                         'no fixed IPv4 addresses') % internal_port['id'])",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            if len(ipv4_fixed_ips) > 1:",
            "                msg = (_('Port %s has multiple fixed IPv4 addresses.  Must '",
            "                         'provide a specific IPv4 address when assigning a '",
            "                         'floating IP') % internal_port['id'])",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            internal_ip_address = ipv4_fixed_ips[0]['ip_address']",
            "            internal_subnet_id = ipv4_fixed_ips[0]['subnet_id']",
            "        return internal_port, internal_subnet_id, internal_ip_address",
            "",
            "    def _get_assoc_data(self, context, fip, floatingip_obj):",
            "        \"\"\"Determine/extract data associated with the internal port.",
            "",
            "        When a floating IP is associated with an internal port,",
            "        we need to extract/determine some data associated with the",
            "        internal port, including the internal_ip_address, and router_id.",
            "        The confirmation of the internal port whether owned by the tenant who",
            "        owns the floating IP will be confirmed by _get_router_for_floatingip.",
            "        \"\"\"",
            "        (internal_port, internal_subnet_id,",
            "         internal_ip_address) = self._internal_fip_assoc_data(",
            "            context, fip, floatingip_obj.project_id)",
            "        router_id = self._get_router_for_floatingip(",
            "            context, internal_port,",
            "            internal_subnet_id, floatingip_obj.floating_network_id)",
            "",
            "        return (fip['port_id'], internal_ip_address, router_id)",
            "",
            "    def _check_and_get_fip_assoc(self, context, fip, floatingip_obj):",
            "        port_id = internal_ip_address = router_id = None",
            "        if fip.get('fixed_ip_address') and not fip.get('port_id'):",
            "            msg = _(\"fixed_ip_address cannot be specified without a port_id\")",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        if fip.get('port_id'):",
            "            port_id, internal_ip_address, router_id = self._get_assoc_data(",
            "                context,",
            "                fip,",
            "                floatingip_obj)",
            "",
            "            if port_id == floatingip_obj.fixed_port_id:",
            "                # Floating IP association is not changed.",
            "                return port_id, internal_ip_address, router_id",
            "",
            "            fip_exists = l3_obj.FloatingIP.objects_exist(",
            "                    context,",
            "                    fixed_port_id=fip['port_id'],",
            "                    floating_network_id=floatingip_obj.floating_network_id,",
            "                    fixed_ip_address=netaddr.IPAddress(internal_ip_address))",
            "            if fip_exists:",
            "                floating_ip_address = (str(floatingip_obj.floating_ip_address)",
            "                    if floatingip_obj.floating_ip_address else None)",
            "                raise l3_exc.FloatingIPPortAlreadyAssociated(",
            "                    port_id=fip['port_id'],",
            "                    fip_id=floatingip_obj.id,",
            "                    floating_ip_address=floating_ip_address,",
            "                    fixed_ip=internal_ip_address,",
            "                    net_id=floatingip_obj.floating_network_id)",
            "",
            "        if fip and 'port_id' not in fip and floatingip_obj.fixed_port_id:",
            "            # NOTE(liuyulong): without the fix of bug #1610045 here could",
            "            # also let floating IP can be dissociated with an empty",
            "            # updating dict.",
            "            fip['port_id'] = floatingip_obj.fixed_port_id",
            "            port_id, internal_ip_address, router_id = self._get_assoc_data(",
            "                context, fip, floatingip_obj)",
            "",
            "        # After all upper conditions, if updating API dict is submitted with",
            "        # {'port_id': null}, then the floating IP cloud also be dissociated.",
            "        return port_id, internal_ip_address, router_id",
            "",
            "    def _update_fip_assoc(self, context, fip, floatingip_obj, external_port):",
            "        previous_router_id = floatingip_obj.router_id",
            "        port_id, internal_ip_address, router_id = (",
            "            self._check_and_get_fip_assoc(context, fip, floatingip_obj))",
            "        floatingip_obj.fixed_ip_address = (",
            "            netaddr.IPAddress(internal_ip_address)",
            "            if internal_ip_address else None)",
            "        floatingip_obj.fixed_port_id = port_id",
            "        floatingip_obj.router_id = router_id",
            "        floatingip_obj.last_known_router_id = previous_router_id",
            "        if 'description' in fip:",
            "            floatingip_obj.description = fip['description']",
            "        floating_ip_address = (str(floatingip_obj.floating_ip_address)",
            "            if floatingip_obj.floating_ip_address else None)",
            "        return {'fixed_ip_address': internal_ip_address,",
            "                'fixed_port_id': port_id,",
            "                'router_id': router_id,",
            "                'last_known_router_id': previous_router_id,",
            "                'floating_ip_address': floating_ip_address,",
            "                'floating_network_id': floatingip_obj.floating_network_id,",
            "                'floating_ip_id': floatingip_obj.id,",
            "                'context': context}",
            "",
            "    def _is_ipv4_network(self, context, net_id):",
            "        net = self._core_plugin._get_network(context, net_id)",
            "        return any(s.ip_version == 4 for s in net.subnets)",
            "",
            "    def _create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        fip = floatingip['floatingip']",
            "        fip_id = uuidutils.generate_uuid()",
            "",
            "        f_net_id = fip['floating_network_id']",
            "        if not self._core_plugin._network_is_external(context, f_net_id):",
            "            msg = _(\"Network %s is not a valid external network\") % f_net_id",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        if not self._is_ipv4_network(context, f_net_id):",
            "            msg = _(\"Network %s does not contain any IPv4 subnet\") % f_net_id",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        # This external port is never exposed to the tenant.",
            "        # it is used purely for internal system and admin use when",
            "        # managing floating IPs.",
            "",
            "        port = {'tenant_id': '',  # tenant intentionally not set",
            "                'network_id': f_net_id,",
            "                'admin_state_up': True,",
            "                'device_id': 'PENDING',",
            "                'device_owner': DEVICE_OWNER_FLOATINGIP,",
            "                'status': constants.PORT_STATUS_NOTAPPLICABLE,",
            "                'name': ''}",
            "",
            "        # Both subnet_id and floating_ip_address are accepted, if",
            "        # floating_ip_address is not in the subnet,",
            "        # InvalidIpForSubnet exception will be raised.",
            "        fixed_ip = {}",
            "        if validators.is_attr_set(fip.get('subnet_id')):",
            "            fixed_ip['subnet_id'] = fip['subnet_id']",
            "        if validators.is_attr_set(fip.get('floating_ip_address')):",
            "            fixed_ip['ip_address'] = fip['floating_ip_address']",
            "        if fixed_ip:",
            "            port['fixed_ips'] = [fixed_ip]",
            "",
            "        # 'status' in port dict could not be updated by default, use",
            "        # check_allow_post to stop the verification of system",
            "        external_port = p_utils.create_port(self._core_plugin,",
            "                                            context.elevated(),",
            "                                            {'port': port},",
            "                                            check_allow_post=False)",
            "",
            "        with plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context.elevated(),",
            "                external_port['id']),\\",
            "                context.session.begin(subtransactions=True):",
            "            # Ensure IPv4 addresses are allocated on external port",
            "            external_ipv4_ips = self._port_ipv4_fixed_ips(external_port)",
            "            if not external_ipv4_ips:",
            "                raise n_exc.ExternalIpAddressExhausted(net_id=f_net_id)",
            "",
            "            floating_fixed_ip = external_ipv4_ips[0]",
            "            floating_ip_address = floating_fixed_ip['ip_address']",
            "            floatingip_obj = l3_obj.FloatingIP(",
            "                context,",
            "                id=fip_id,",
            "                project_id=fip['tenant_id'],",
            "                status=initial_status,",
            "                floating_network_id=fip['floating_network_id'],",
            "                floating_ip_address=floating_ip_address,",
            "                floating_port_id=external_port['id'],",
            "                description=fip.get('description'))",
            "            # Update association with internal port",
            "            # and define external IP address",
            "            assoc_result = self._update_fip_assoc(",
            "                context, fip, floatingip_obj, external_port)",
            "            floatingip_obj.create()",
            "            floatingip_dict = self._make_floatingip_dict(",
            "                floatingip_obj, process_extensions=False)",
            "            if self._is_dns_integration_supported:",
            "                dns_data = self._process_dns_floatingip_create_precommit(",
            "                    context, floatingip_dict, fip)",
            "            if self._is_fip_qos_supported:",
            "                self._process_extra_fip_qos_create(context, fip_id, fip)",
            "            floatingip_obj = l3_obj.FloatingIP.get_object(",
            "                context, id=floatingip_obj.id)",
            "            floatingip_db = floatingip_obj.db_obj",
            "",
            "            registry.notify(resources.FLOATING_IP, events.PRECOMMIT_CREATE,",
            "                            self, context=context, floatingip=fip,",
            "                            floatingip_id=fip_id,",
            "                            floatingip_db=floatingip_db)",
            "",
            "        self._core_plugin.update_port(context.elevated(), external_port['id'],",
            "                                      {'port': {'device_id': fip_id}})",
            "        registry.notify(resources.FLOATING_IP,",
            "                        events.AFTER_UPDATE,",
            "                        self._update_fip_assoc,",
            "                        **assoc_result)",
            "",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_create_postcommit(context,",
            "                                                           floatingip_dict,",
            "                                                           dns_data)",
            "        # TODO(lujinluo): Change floatingip_db to floatingip_obj once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        resource_extend.apply_funcs(l3_apidef.FLOATINGIPS, floatingip_dict,",
            "                                    floatingip_db)",
            "        return floatingip_dict",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        return self._create_floatingip(context, floatingip, initial_status)",
            "",
            "    def _update_floatingip(self, context, id, floatingip):",
            "        fip = floatingip['floatingip']",
            "        with context.session.begin(subtransactions=True):",
            "            floatingip_obj = self._get_floatingip(context, id)",
            "            old_floatingip = self._make_floatingip_dict(floatingip_obj)",
            "            fip_port_id = floatingip_obj.floating_port_id",
            "            assoc_result = self._update_fip_assoc(",
            "                context, fip, floatingip_obj,",
            "                self._core_plugin.get_port(context.elevated(), fip_port_id))",
            "            floatingip_obj.update()",
            "            floatingip_dict = self._make_floatingip_dict(floatingip_obj)",
            "            if self._is_dns_integration_supported:",
            "                dns_data = self._process_dns_floatingip_update_precommit(",
            "                    context, floatingip_dict)",
            "            if self._is_fip_qos_supported:",
            "                self._process_extra_fip_qos_update(context,",
            "                                                   floatingip_obj,",
            "                                                   fip,",
            "                                                   old_floatingip)",
            "            floatingip_obj = l3_obj.FloatingIP.get_object(",
            "                context, id=floatingip_obj.id)",
            "            floatingip_db = floatingip_obj.db_obj",
            "            registry.notify(resources.FLOATING_IP,",
            "                            events.PRECOMMIT_UPDATE,",
            "                            self,",
            "                            floatingip=floatingip,",
            "                            floatingip_db=floatingip_db,",
            "                            old_floatingip=old_floatingip,",
            "                            **assoc_result)",
            "",
            "        registry.notify(resources.FLOATING_IP,",
            "                        events.AFTER_UPDATE,",
            "                        self._update_fip_assoc,",
            "                        **assoc_result)",
            "",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_update_postcommit(context,",
            "                                                           floatingip_dict,",
            "                                                           dns_data)",
            "        # TODO(lujinluo): Change floatingip_db to floatingip_obj once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        resource_extend.apply_funcs(l3_apidef.FLOATINGIPS, floatingip_dict,",
            "                                    floatingip_db)",
            "        return old_floatingip, floatingip_dict",
            "",
            "    def _floatingips_to_router_ids(self, floatingips):",
            "        return list(set([floatingip['router_id']",
            "                         for floatingip in floatingips",
            "                         if floatingip['router_id']]))",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_floatingip(self, context, id, floatingip):",
            "        _old_floatingip, floatingip = self._update_floatingip(",
            "            context, id, floatingip)",
            "        return floatingip",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_floatingip_status(self, context, floatingip_id, status):",
            "        \"\"\"Update operational status for floating IP in neutron DB.\"\"\"",
            "        return l3_obj.FloatingIP.update_object(",
            "            context, {'status': status}, id=floatingip_id)",
            "",
            "    @registry.receives(resources.PORT, [events.PRECOMMIT_DELETE])",
            "    def _precommit_delete_port_callback(",
            "            self, resource, event, trigger, **kwargs):",
            "        if (kwargs['port']['device_owner'] ==",
            "                constants.DEVICE_OWNER_FLOATINGIP):",
            "            registry.notify(resources.FLOATING_IP, events.PRECOMMIT_DELETE,",
            "                            self, **kwargs)",
            "",
            "    def _delete_floatingip(self, context, id):",
            "        floatingip = self._get_floatingip(context, id)",
            "        floatingip_dict = self._make_floatingip_dict(floatingip)",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_delete(context, floatingip_dict)",
            "        # Foreign key cascade will take care of the removal of the",
            "        # floating IP record once the port is deleted. We can't start",
            "        # a transaction first to remove it ourselves because the delete_port",
            "        # method will yield in its post-commit activities.",
            "        self._core_plugin.delete_port(context.elevated(),",
            "                                      floatingip.floating_port_id,",
            "                                      l3_port_check=False)",
            "        registry.notify(resources.FLOATING_IP, events.AFTER_DELETE,",
            "                        self, **floatingip_dict)",
            "        return floatingip_dict",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_floatingip(self, context, id):",
            "        self._delete_floatingip(context, id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingip(self, context, id, fields=None):",
            "        floatingip = self._get_floatingip(context, id)",
            "        return self._make_floatingip_dict(floatingip, fields)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingips(self, context, filters=None, fields=None,",
            "                        sorts=None, limit=None, marker=None,",
            "                        page_reverse=False):",
            "        pager = base_obj.Pager(sorts, limit, page_reverse, marker)",
            "        filters = filters or {}",
            "        for key, val in API_TO_DB_COLUMN_MAP.items():",
            "            if key in filters:",
            "                filters[val] = filters.pop(key)",
            "        floatingip_objs = l3_obj.FloatingIP.get_objects(",
            "            context, _pager=pager, validate_filters=False, **filters)",
            "        floatingip_dicts = [",
            "            self._make_floatingip_dict(floatingip_obj, fields)",
            "            for floatingip_obj in floatingip_objs",
            "        ]",
            "        return floatingip_dicts",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_disassociated_floatingips(self, context, network_id):",
            "        fip_objs = l3_obj.FloatingIP.get_objects(",
            "            context,",
            "            floating_network_id=network_id, router_id=None, fixed_port_id=None)",
            "",
            "        for fip in fip_objs:",
            "            self.delete_floatingip(context, fip.id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingips_count(self, context, filters=None):",
            "        filters = filters or {}",
            "        return l3_obj.FloatingIP.count(context, **filters)",
            "",
            "    def _router_exists(self, context, router_id):",
            "        try:",
            "            self.get_router(context.elevated(), router_id)",
            "            return True",
            "        except l3_exc.RouterNotFound:",
            "            return False",
            "",
            "    def prevent_l3_port_deletion(self, context, port_id):",
            "        \"\"\"Checks to make sure a port is allowed to be deleted.",
            "",
            "        Raises an exception if this is not the case.  This should be called by",
            "        any plugin when the API requests the deletion of a port, since some",
            "        ports for L3 are not intended to be deleted directly via a DELETE",
            "        to /ports, but rather via other API calls that perform the proper",
            "        deletion checks.",
            "        \"\"\"",
            "        try:",
            "            port = self._core_plugin.get_port(context, port_id)",
            "        except n_exc.PortNotFound:",
            "            # non-existent ports don't need to be protected from deletion",
            "            return",
            "        if port['device_owner'] not in self.router_device_owners:",
            "            return",
            "        # Raise port in use only if the port has IP addresses",
            "        # Otherwise it's a stale port that can be removed",
            "        fixed_ips = port['fixed_ips']",
            "        if not fixed_ips:",
            "            LOG.debug(\"Port %(port_id)s has owner %(port_owner)s, but \"",
            "                      \"no IP address, so it can be deleted\",",
            "                      {'port_id': port['id'],",
            "                       'port_owner': port['device_owner']})",
            "            return",
            "        # NOTE(kevinbenton): we also check to make sure that the",
            "        # router still exists. It's possible for HA router interfaces",
            "        # to remain after the router is deleted if they encounter an",
            "        # error during deletion.",
            "        # Elevated context in case router is owned by another tenant",
            "        if port['device_owner'] == DEVICE_OWNER_FLOATINGIP:",
            "            if not l3_obj.FloatingIP.objects_exist(",
            "                    context, id=port['device_id']):",
            "                LOG.debug(\"Floating IP %(f_id)s corresponding to port \"",
            "                          \"%(port_id)s no longer exists, allowing deletion.\",",
            "                          {'f_id': port['device_id'], 'port_id': port['id']})",
            "                return",
            "        elif not self._router_exists(context, port['device_id']):",
            "            LOG.debug(\"Router %(router_id)s corresponding to port \"",
            "                      \"%(port_id)s  no longer exists, allowing deletion.\",",
            "                      {'router_id': port['device_id'],",
            "                       'port_id': port['id']})",
            "            return",
            "",
            "        reason = _('has device owner %s') % port['device_owner']",
            "        raise n_exc.ServicePortInUse(port_id=port['id'],",
            "                                     reason=reason)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def disassociate_floatingips(self, context, port_id, do_notify=True):",
            "        \"\"\"Disassociate all floating IPs linked to specific port.",
            "",
            "        @param port_id: ID of the port to disassociate floating IPs.",
            "        @param do_notify: whether we should notify routers right away.",
            "                          This parameter is ignored.",
            "        @return: set of router-ids that require notification updates",
            "        \"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            floating_ip_objs = l3_obj.FloatingIP.get_objects(",
            "                context, fixed_port_id=port_id)",
            "            router_ids = {fip.router_id for fip in floating_ip_objs}",
            "            old_fips = {fip.id: fip.to_dict() for fip in floating_ip_objs}",
            "            values = {'fixed_port_id': None,",
            "                      'fixed_ip_address': None,",
            "                      'router_id': None}",
            "            l3_obj.FloatingIP.update_objects(",
            "                context, values, fixed_port_id=port_id)",
            "            for fip in floating_ip_objs:",
            "                registry.notify(resources.FLOATING_IP, events.PRECOMMIT_UPDATE,",
            "                                self, context=context,",
            "                                floatingip={l3_apidef.FLOATINGIP: values},",
            "                                floatingip_db=fip,",
            "                                old_floatingip=old_fips[fip.id],",
            "                                router_ids=router_ids)",
            "",
            "        for fip in floating_ip_objs:",
            "            assoc_result = {",
            "                'fixed_ip_address': None,",
            "                'fixed_port_id': None,",
            "                'router_id': None,",
            "                'floating_ip_address': fip.floating_ip_address,",
            "                'floating_network_id': fip.floating_network_id,",
            "                'floating_ip_id': fip.id,",
            "                'context': context,",
            "                'router_ids': router_ids,",
            "            }",
            "            registry.notify(resources.FLOATING_IP, events.AFTER_UPDATE, self,",
            "                            **assoc_result)",
            "        return router_ids",
            "",
            "    def _get_floatingips_by_port_id(self, context, port_id):",
            "        \"\"\"Helper function to retrieve the fips associated with a port_id.\"\"\"",
            "        return l3_obj.FloatingIP.get_objects(context, fixed_port_id=port_id)",
            "",
            "    def _build_routers_list(self, context, routers, gw_ports):",
            "        \"\"\"Subclasses can override this to add extra gateway info\"\"\"",
            "        return routers",
            "",
            "    def _make_router_dict_with_gw_port(self, router, fields):",
            "        result = self._make_router_dict(router, fields)",
            "        if router.get('gw_port'):",
            "            result['gw_port'] = self._core_plugin._make_port_dict(",
            "                router['gw_port'])",
            "        return result",
            "",
            "    def _get_sync_routers(self, context, router_ids=None, active=None):",
            "        \"\"\"Query routers and their gw ports for l3 agent.",
            "",
            "        Query routers with the router_ids. The gateway ports, if any,",
            "        will be queried too.",
            "        l3 agent has an option to deal with only one router id. In addition,",
            "        when we need to notify the agent the data about only one router",
            "        (when modification of router, its interfaces, gw_port and floatingips),",
            "        we will have router_ids.",
            "        @param router_ids: the list of router ids which we want to query.",
            "                           if it is None, all of routers will be queried.",
            "        @return: a list of dicted routers with dicted gw_port populated if any",
            "        \"\"\"",
            "        filters = {'id': router_ids} if router_ids else {}",
            "        if active is not None:",
            "            filters['admin_state_up'] = [active]",
            "        router_dicts = model_query.get_collection(",
            "            context, l3_models.Router, self._make_router_dict_with_gw_port,",
            "            filters=filters)",
            "        if not router_dicts:",
            "            return []",
            "        gw_ports = dict((r['gw_port']['id'], r['gw_port'])",
            "                        for r in router_dicts",
            "                        if r.get('gw_port'))",
            "        return self._build_routers_list(context, router_dicts, gw_ports)",
            "",
            "    def _make_floatingip_dict_with_scope(self, floatingip_obj, scope_id):",
            "        d = self._make_floatingip_dict(floatingip_obj)",
            "        d['fixed_ip_address_scope'] = scope_id",
            "        return d",
            "",
            "    def _get_sync_floating_ips(self, context, router_ids):",
            "        \"\"\"Query floating_ips that relate to list of router_ids with scope.",
            "",
            "        This is different than the regular get_floatingips in that it finds the",
            "        address scope of the fixed IP.  The router needs to know this to",
            "        distinguish it from other scopes.",
            "",
            "        There are a few redirections to go through to discover the address",
            "        scope from the floating ip.",
            "        \"\"\"",
            "        if not router_ids:",
            "            return []",
            "",
            "        return [",
            "            self._make_floatingip_dict_with_scope(*scoped_fip)",
            "            for scoped_fip in l3_obj.FloatingIP.get_scoped_floating_ips(",
            "                context, router_ids)",
            "        ]",
            "",
            "    def _get_sync_interfaces(self, context, router_ids, device_owners=None):",
            "        \"\"\"Query router interfaces that relate to list of router_ids.\"\"\"",
            "        device_owners = device_owners or [DEVICE_OWNER_ROUTER_INTF,",
            "                                          DEVICE_OWNER_HA_REPLICATED_INT]",
            "        if not router_ids:",
            "            return []",
            "        # TODO(lujinluo): Need Port as synthetic field",
            "        objs = l3_obj.RouterPort.get_objects(",
            "            context, router_id=router_ids, port_type=list(device_owners))",
            "",
            "        interfaces = [self._core_plugin._make_port_dict(rp.db_obj.port)",
            "                      for rp in objs]",
            "        return interfaces",
            "",
            "    @staticmethod",
            "    def _each_port_having_fixed_ips(ports):",
            "        for port in ports or []:",
            "            fixed_ips = port.get('fixed_ips', [])",
            "            if not fixed_ips:",
            "                # Skip ports without IPs, which can occur if a subnet",
            "                # attached to a router is deleted",
            "                LOG.info(\"Skipping port %s as no IP is configure on \"",
            "                         \"it\",",
            "                         port['id'])",
            "                continue",
            "            yield port",
            "",
            "    def _get_subnets_by_network_list(self, context, network_ids):",
            "        if not network_ids:",
            "            return {}",
            "",
            "        query = context.session.query(models_v2.Subnet,",
            "                                      models_v2.SubnetPool.address_scope_id)",
            "        query = query.outerjoin(",
            "            models_v2.SubnetPool,",
            "            models_v2.Subnet.subnetpool_id == models_v2.SubnetPool.id)",
            "        query = query.filter(models_v2.Subnet.network_id.in_(network_ids))",
            "",
            "        fields = ['id', 'cidr', 'gateway_ip', 'dns_nameservers',",
            "                  'network_id', 'ipv6_ra_mode', 'subnetpool_id']",
            "",
            "        def make_subnet_dict_with_scope(row):",
            "            subnet_db, address_scope_id = row",
            "            subnet = self._core_plugin._make_subnet_dict(",
            "                subnet_db, fields, context=context)",
            "            subnet['address_scope_id'] = address_scope_id",
            "            return subnet",
            "",
            "        subnets_by_network = dict((id, []) for id in network_ids)",
            "        for subnet in (make_subnet_dict_with_scope(row) for row in query):",
            "            subnets_by_network[subnet['network_id']].append(subnet)",
            "        return subnets_by_network",
            "",
            "    def _get_mtus_by_network_list(self, context, network_ids):",
            "        if not network_ids:",
            "            return {}",
            "        filters = {'id': network_ids}",
            "        fields = ['id', 'mtu']",
            "        networks = self._core_plugin.get_networks(context, filters=filters,",
            "                                                  fields=fields)",
            "        mtus_by_network = dict((network['id'], network.get('mtu', 0))",
            "                               for network in networks)",
            "        return mtus_by_network",
            "",
            "    def _populate_mtu_and_subnets_for_ports(self, context, ports):",
            "        \"\"\"Populate ports with subnets.",
            "",
            "        These ports already have fixed_ips populated.",
            "        \"\"\"",
            "        network_ids = [p['network_id']",
            "                       for p in self._each_port_having_fixed_ips(ports)]",
            "",
            "        mtus_by_network = self._get_mtus_by_network_list(context, network_ids)",
            "        subnets_by_network = self._get_subnets_by_network_list(",
            "            context, network_ids)",
            "",
            "        for port in self._each_port_having_fixed_ips(ports):",
            "",
            "            port['subnets'] = []",
            "            port['extra_subnets'] = []",
            "            port['address_scopes'] = {constants.IP_VERSION_4: None,",
            "                                      constants.IP_VERSION_6: None}",
            "",
            "            scopes = {}",
            "            for subnet in subnets_by_network[port['network_id']]:",
            "                scope = subnet['address_scope_id']",
            "                cidr = netaddr.IPNetwork(subnet['cidr'])",
            "                scopes[cidr.version] = scope",
            "",
            "                # If this subnet is used by the port (has a matching entry",
            "                # in the port's fixed_ips), then add this subnet to the",
            "                # port's subnets list, and populate the fixed_ips entry",
            "                # entry with the subnet's prefix length.",
            "                subnet_info = {'id': subnet['id'],",
            "                               'cidr': subnet['cidr'],",
            "                               'gateway_ip': subnet['gateway_ip'],",
            "                               'dns_nameservers': subnet['dns_nameservers'],",
            "                               'ipv6_ra_mode': subnet['ipv6_ra_mode'],",
            "                               'subnetpool_id': subnet['subnetpool_id']}",
            "                for fixed_ip in port['fixed_ips']:",
            "                    if fixed_ip['subnet_id'] == subnet['id']:",
            "                        port['subnets'].append(subnet_info)",
            "                        prefixlen = cidr.prefixlen",
            "                        fixed_ip['prefixlen'] = prefixlen",
            "                        break",
            "                else:",
            "                    # This subnet is not used by the port.",
            "                    port['extra_subnets'].append(subnet_info)",
            "",
            "            port['address_scopes'].update(scopes)",
            "            port['mtu'] = mtus_by_network.get(port['network_id'], 0)",
            "",
            "    def _process_floating_ips(self, context, routers_dict, floating_ips):",
            "        for floating_ip in floating_ips:",
            "            router = routers_dict.get(floating_ip['router_id'])",
            "            if router:",
            "                router_floatingips = router.get(constants.FLOATINGIP_KEY,",
            "                                                [])",
            "                router_floatingips.append(floating_ip)",
            "                router[constants.FLOATINGIP_KEY] = router_floatingips",
            "",
            "    def _process_interfaces(self, routers_dict, interfaces):",
            "        for interface in interfaces:",
            "            router = routers_dict.get(interface['device_id'])",
            "            if router:",
            "                router_interfaces = router.get(constants.INTERFACE_KEY, [])",
            "                router_interfaces.append(interface)",
            "                router[constants.INTERFACE_KEY] = router_interfaces",
            "",
            "    def _get_router_info_list(self, context, router_ids=None, active=None,",
            "                              device_owners=None):",
            "        \"\"\"Query routers and their related floating_ips, interfaces.\"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            routers = self._get_sync_routers(context,",
            "                                             router_ids=router_ids,",
            "                                             active=active)",
            "            router_ids = [router['id'] for router in routers]",
            "            interfaces = self._get_sync_interfaces(",
            "                context, router_ids, device_owners)",
            "            floating_ips = self._get_sync_floating_ips(context, router_ids)",
            "            return (routers, interfaces, floating_ips)",
            "",
            "    def get_sync_data(self, context, router_ids=None, active=None):",
            "        routers, interfaces, floating_ips = self._get_router_info_list(",
            "            context, router_ids=router_ids, active=active)",
            "        ports_to_populate = [router['gw_port'] for router in routers",
            "                             if router.get('gw_port')] + interfaces",
            "        self._populate_mtu_and_subnets_for_ports(context, ports_to_populate)",
            "        routers_dict = dict((router['id'], router) for router in routers)",
            "        self._process_floating_ips(context, routers_dict, floating_ips)",
            "        self._process_interfaces(routers_dict, interfaces)",
            "        return list(routers_dict.values())",
            "",
            "",
            "@registry.has_registry_receivers",
            "class L3RpcNotifierMixin(object):",
            "    \"\"\"Mixin class to add rpc notifier attribute to db_base_plugin_v2.\"\"\"",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.PORT, [events.AFTER_DELETE])",
            "    def _notify_routers_callback(resource, event, trigger, **kwargs):",
            "        context = kwargs['context']",
            "        router_ids = kwargs['router_ids']",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin:",
            "            l3plugin.notify_routers_updated(context, router_ids)",
            "        else:",
            "            LOG.debug('%s not configured', plugin_constants.L3)",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.SUBNET, [events.AFTER_UPDATE])",
            "    def _notify_subnet_gateway_ip_update(resource, event, trigger, **kwargs):",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not l3plugin:",
            "            return",
            "        context = kwargs['context']",
            "        orig = kwargs['original_subnet']",
            "        updated = kwargs['subnet']",
            "        if orig['gateway_ip'] == updated['gateway_ip']:",
            "            return",
            "        network_id = updated['network_id']",
            "        subnet_id = updated['id']",
            "        query = context.session.query(models_v2.Port).filter_by(",
            "                    network_id=network_id,",
            "                    device_owner=DEVICE_OWNER_ROUTER_GW)",
            "        query = query.join(models_v2.Port.fixed_ips).filter(",
            "                    models_v2.IPAllocation.subnet_id == subnet_id)",
            "        router_ids = set(port['device_id'] for port in query)",
            "        for router_id in router_ids:",
            "            l3plugin.notify_router_updated(context, router_id)",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.SUBNETPOOL_ADDRESS_SCOPE,",
            "                       [events.AFTER_UPDATE])",
            "    def _notify_subnetpool_address_scope_update(resource, event,",
            "                                                trigger, **kwargs):",
            "        context = kwargs['context']",
            "        subnetpool_id = kwargs['subnetpool_id']",
            "",
            "        router_ids = l3_obj.RouterPort.get_router_ids_by_subnetpool(",
            "            context, subnetpool_id)",
            "",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin:",
            "            l3plugin.notify_routers_updated(context, router_ids)",
            "        else:",
            "            LOG.debug('%s not configured', plugin_constants.L3)",
            "",
            "    @property",
            "    def l3_rpc_notifier(self):",
            "        if not hasattr(self, '_l3_rpc_notifier'):",
            "            self._l3_rpc_notifier = l3_rpc_agent_api.L3AgentNotifyAPI()",
            "        return self._l3_rpc_notifier",
            "",
            "    @l3_rpc_notifier.setter",
            "    def l3_rpc_notifier(self, value):",
            "        self._l3_rpc_notifier = value",
            "",
            "    def notify_router_updated(self, context, router_id,",
            "                              operation=None):",
            "        if router_id:",
            "            self.l3_rpc_notifier.routers_updated(",
            "                context, [router_id], operation)",
            "",
            "    def notify_routers_updated(self, context, router_ids,",
            "                               operation=None, data=None):",
            "        if router_ids:",
            "            self.l3_rpc_notifier.routers_updated(",
            "                context, router_ids, operation, data)",
            "",
            "    def notify_router_deleted(self, context, router_id):",
            "        self.l3_rpc_notifier.router_deleted(context, router_id)",
            "",
            "",
            "class L3_NAT_db_mixin(L3_NAT_dbonly_mixin, L3RpcNotifierMixin):",
            "    \"\"\"Mixin class to add rpc notifier methods to db_base_plugin_v2.\"\"\"",
            "",
            "    def create_router(self, context, router):",
            "        router_dict = super(L3_NAT_db_mixin, self).create_router(context,",
            "                                                                 router)",
            "        if router_dict.get('external_gateway_info'):",
            "            self.notify_router_updated(context, router_dict['id'], None)",
            "        return router_dict",
            "",
            "    def update_router(self, context, id, router):",
            "        router_dict = super(L3_NAT_db_mixin, self).update_router(context,",
            "                                                                 id, router)",
            "        self.notify_router_updated(context, router_dict['id'], None)",
            "        return router_dict",
            "",
            "    def delete_router(self, context, id):",
            "        super(L3_NAT_db_mixin, self).delete_router(context, id)",
            "        self.notify_router_deleted(context, id)",
            "",
            "    def notify_router_interface_action(",
            "            self, context, router_interface_info, action):",
            "        l3_method = '%s_router_interface' % action",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, [router_interface_info['id']], l3_method,",
            "            {'subnet_id': router_interface_info['subnet_id']})",
            "",
            "        mapping = {'add': 'create', 'remove': 'delete'}",
            "        notifier = n_rpc.get_notifier('network')",
            "        router_event = 'router.interface.%s' % mapping[action]",
            "        notifier.info(context, router_event,",
            "                      {'router_interface': router_interface_info})",
            "",
            "    def add_router_interface(self, context, router_id, interface_info=None):",
            "        router_interface_info = super(",
            "            L3_NAT_db_mixin, self).add_router_interface(",
            "                context, router_id, interface_info)",
            "        self.notify_router_interface_action(",
            "            context, router_interface_info, 'add')",
            "        return router_interface_info",
            "",
            "    def remove_router_interface(self, context, router_id, interface_info):",
            "        router_interface_info = super(",
            "            L3_NAT_db_mixin, self).remove_router_interface(",
            "                context, router_id, interface_info)",
            "        self.notify_router_interface_action(",
            "            context, router_interface_info, 'remove')",
            "        return router_interface_info",
            "",
            "    def create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        floatingip_dict = super(L3_NAT_db_mixin, self).create_floatingip(",
            "            context, floatingip, initial_status)",
            "        router_id = floatingip_dict['router_id']",
            "        self.notify_router_updated(context, router_id, 'create_floatingip')",
            "        return floatingip_dict",
            "",
            "    def update_floatingip(self, context, id, floatingip):",
            "        old_floatingip, floatingip = self._update_floatingip(",
            "            context, id, floatingip)",
            "        router_ids = self._floatingips_to_router_ids(",
            "            [old_floatingip, floatingip])",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, router_ids, 'update_floatingip', {})",
            "        return floatingip",
            "",
            "    def delete_floatingip(self, context, id):",
            "        floating_ip = self._delete_floatingip(context, id)",
            "        self.notify_router_updated(context, floating_ip['router_id'],",
            "                                   'delete_floatingip')",
            "",
            "    def disassociate_floatingips(self, context, port_id, do_notify=True):",
            "        \"\"\"Disassociate all floating IPs linked to specific port.",
            "",
            "        @param port_id: ID of the port to disassociate floating IPs.",
            "        @param do_notify: whether we should notify routers right away.",
            "        @return: set of router-ids that require notification updates",
            "                 if do_notify is False, otherwise None.",
            "        \"\"\"",
            "        router_ids = super(L3_NAT_db_mixin, self).disassociate_floatingips(",
            "            context, port_id, do_notify)",
            "        if do_notify:",
            "            self.notify_routers_updated(context, router_ids)",
            "            # since caller assumes that we handled notifications on its",
            "            # behalf, return nothing",
            "            return",
            "",
            "        return router_ids",
            "",
            "    def notify_routers_updated(self, context, router_ids):",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, list(router_ids), 'disassociate_floatingips', {})",
            "",
            "    def _migrate_router_ports(",
            "        self, context, router_db, old_owner, new_owner):",
            "        \"\"\"Update the model to support the dvr case of a router.\"\"\"",
            "        for rp in router_db.attached_ports:",
            "            if rp.port_type == old_owner:",
            "                rp.port_type = new_owner",
            "                rp.port.device_owner = new_owner"
        ],
        "afterPatchFile": [
            "# Copyright 2012 VMware, Inc.  All rights reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import random",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import external_net as extnet_apidef",
            "from neutron_lib.api.definitions import l3 as l3_apidef",
            "from neutron_lib.api import extensions",
            "from neutron_lib.api import validators",
            "from neutron_lib.callbacks import events",
            "from neutron_lib.callbacks import exceptions",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources",
            "from neutron_lib import constants",
            "from neutron_lib import context as n_ctx",
            "from neutron_lib import exceptions as n_exc",
            "from neutron_lib.exceptions import l3 as l3_exc",
            "from neutron_lib.plugins import constants as plugin_constants",
            "from neutron_lib.plugins import directory",
            "from neutron_lib.plugins import utils as plugin_utils",
            "from neutron_lib.services import base as base_services",
            "from oslo_log import log as logging",
            "from oslo_utils import uuidutils",
            "from sqlalchemy import orm",
            "from sqlalchemy.orm import exc",
            "",
            "from neutron._i18n import _",
            "from neutron.api.rpc.agentnotifiers import l3_rpc_agent_api",
            "from neutron.common import ipv6_utils",
            "from neutron.common import rpc as n_rpc",
            "from neutron.common import utils",
            "from neutron.db import _model_query as model_query",
            "from neutron.db import _resource_extend as resource_extend",
            "from neutron.db import _utils as db_utils",
            "from neutron.db import api as db_api",
            "from neutron.db.models import l3 as l3_models",
            "from neutron.db import models_v2",
            "from neutron.db import standardattrdescription_db as st_attr",
            "from neutron.extensions import l3",
            "from neutron.extensions import qos_fip",
            "from neutron.objects import base as base_obj",
            "from neutron.objects import ports as port_obj",
            "from neutron.objects import router as l3_obj",
            "from neutron.plugins.common import utils as p_utils",
            "from neutron import worker as neutron_worker",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "DEVICE_OWNER_HA_REPLICATED_INT = constants.DEVICE_OWNER_HA_REPLICATED_INT",
            "DEVICE_OWNER_ROUTER_INTF = constants.DEVICE_OWNER_ROUTER_INTF",
            "DEVICE_OWNER_ROUTER_GW = constants.DEVICE_OWNER_ROUTER_GW",
            "DEVICE_OWNER_FLOATINGIP = constants.DEVICE_OWNER_FLOATINGIP",
            "EXTERNAL_GW_INFO = l3_apidef.EXTERNAL_GW_INFO",
            "",
            "# Maps API field to DB column",
            "# API parameter name and Database column names may differ.",
            "# Useful to keep the filtering between API and Database.",
            "API_TO_DB_COLUMN_MAP = {'port_id': 'fixed_port_id'}",
            "CORE_ROUTER_ATTRS = ('id', 'name', 'tenant_id', 'admin_state_up', 'status')",
            "",
            "",
            "@registry.has_registry_receivers",
            "class L3_NAT_dbonly_mixin(l3.RouterPluginBase,",
            "                          base_services.WorkerBase,",
            "                          st_attr.StandardAttrDescriptionMixin):",
            "    \"\"\"Mixin class to add L3/NAT router methods to db_base_plugin_v2.\"\"\"",
            "",
            "    router_device_owners = (",
            "        DEVICE_OWNER_HA_REPLICATED_INT,",
            "        DEVICE_OWNER_ROUTER_INTF,",
            "        DEVICE_OWNER_ROUTER_GW,",
            "        DEVICE_OWNER_FLOATINGIP",
            "    )",
            "",
            "    _dns_integration = None",
            "",
            "    _fip_qos = None",
            "",
            "    def __new__(cls, *args, **kwargs):",
            "        inst = super(L3_NAT_dbonly_mixin, cls).__new__(cls, *args, **kwargs)",
            "        inst._start_janitor()",
            "        return inst",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.PORT, [events.BEFORE_DELETE])",
            "    def _prevent_l3_port_delete_callback(resource, event, trigger, **kwargs):",
            "        context = kwargs['context']",
            "        port_id = kwargs['port_id']",
            "        port_check = kwargs['port_check']",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin and port_check:",
            "            l3plugin.prevent_l3_port_deletion(context, port_id)",
            "",
            "    @property",
            "    def _is_dns_integration_supported(self):",
            "        if self._dns_integration is None:",
            "            self._dns_integration = (",
            "                extensions.is_extension_supported(",
            "                    self._core_plugin, 'dns-integration') or",
            "                extensions.is_extension_supported(",
            "                    self._core_plugin, 'dns-domain-ports'))",
            "        return self._dns_integration",
            "",
            "    @property",
            "    def _is_fip_qos_supported(self):",
            "        if self._fip_qos is None:",
            "            # Check L3 service plugin",
            "            self._fip_qos = extensions.is_extension_supported(",
            "                self, qos_fip.FIP_QOS_ALIAS)",
            "        return self._fip_qos",
            "",
            "    @property",
            "    def _core_plugin(self):",
            "        return directory.get_plugin()",
            "",
            "    def _start_janitor(self):",
            "        \"\"\"Starts the periodic job that cleans up broken complex resources.",
            "",
            "        This job will look for things like floating IP ports without an",
            "        associated floating IP and delete them 5 minutes after detection.",
            "        \"\"\"",
            "        interval = 60 * 5  # only every 5 minutes. cleanups should be rare",
            "        initial_delay = random.randint(0, interval)  # splay multiple servers",
            "        janitor = neutron_worker.PeriodicWorker(self._clean_garbage, interval,",
            "                                                initial_delay)",
            "        self.add_worker(janitor)",
            "",
            "    def _clean_garbage(self):",
            "        if not hasattr(self, '_candidate_broken_fip_ports'):",
            "            self._candidate_broken_fip_ports = set()",
            "        context = n_ctx.get_admin_context()",
            "        candidates = self._get_dead_floating_port_candidates(context)",
            "        # just because a port is in 'candidates' doesn't necessarily mean",
            "        # it's broken, we could have just caught it before it was updated.",
            "        # We confirm by waiting until the next call of this function to see",
            "        # if it persists.",
            "        to_cleanup = candidates & self._candidate_broken_fip_ports",
            "        self._candidate_broken_fip_ports = candidates - to_cleanup",
            "        for port_id in to_cleanup:",
            "            # ensure it wasn't just a failure to update device_id before we",
            "            # delete it",
            "            try:",
            "                self._fix_or_kill_floating_port(context, port_id)",
            "            except Exception:",
            "                LOG.exception(\"Error cleaning up floating IP port: %s\",",
            "                              port_id)",
            "",
            "    def _fix_or_kill_floating_port(self, context, port_id):",
            "        pager = base_obj.Pager(limit=1)",
            "        fips = l3_obj.FloatingIP.get_objects(",
            "            context, _pager=pager, floating_port_id=port_id)",
            "        if fips:",
            "            LOG.warning(\"Found incorrect device_id on floating port \"",
            "                        \"%(pid)s, correcting to %(fip)s.\",",
            "                        {'pid': port_id, 'fip': fips[0].id})",
            "            self._core_plugin.update_port(",
            "                context, port_id, {'port': {'device_id': fips[0].id}})",
            "        else:",
            "            LOG.warning(\"Found floating IP port %s without floating IP, \"",
            "                        \"deleting.\", port_id)",
            "            self._core_plugin.delete_port(",
            "                context, port_id, l3_port_check=False)",
            "            registry.notify(resources.FLOATING_IP, events.AFTER_DELETE,",
            "                            self, **fips[0])",
            "",
            "    def _get_dead_floating_port_candidates(self, context):",
            "        filters = {'device_id': ['PENDING'],",
            "                   'device_owner': [DEVICE_OWNER_FLOATINGIP]}",
            "        return {p['id'] for p in self._core_plugin.get_ports(context, filters)}",
            "",
            "    def _get_router(self, context, router_id):",
            "        try:",
            "            router = model_query.get_by_id(",
            "                context, l3_models.Router, router_id)",
            "        except exc.NoResultFound:",
            "            raise l3_exc.RouterNotFound(router_id=router_id)",
            "        return router",
            "",
            "    def _make_router_dict(self, router, fields=None, process_extensions=True):",
            "        res = dict((key, router[key]) for key in CORE_ROUTER_ATTRS)",
            "        if router['gw_port_id']:",
            "            ext_gw_info = {",
            "                'network_id': router.gw_port['network_id'],",
            "                'external_fixed_ips': [{'subnet_id': ip[\"subnet_id\"],",
            "                                        'ip_address': ip[\"ip_address\"]}",
            "                                       for ip in router.gw_port['fixed_ips']]}",
            "        else:",
            "            ext_gw_info = None",
            "        res.update({",
            "            EXTERNAL_GW_INFO: ext_gw_info,",
            "            'gw_port_id': router['gw_port_id'],",
            "        })",
            "        # NOTE(salv-orlando): The following assumes this mixin is used in a",
            "        # class inheriting from CommonDbMixin, which is true for all existing",
            "        # plugins.",
            "        if process_extensions:",
            "            resource_extend.apply_funcs(l3_apidef.ROUTERS, res, router)",
            "        return db_utils.resource_fields(res, fields)",
            "",
            "    def _create_router_db(self, context, router, tenant_id):",
            "        \"\"\"Create the DB object.\"\"\"",
            "        router.setdefault('id', uuidutils.generate_uuid())",
            "        router['tenant_id'] = tenant_id",
            "        registry.notify(resources.ROUTER, events.BEFORE_CREATE,",
            "                        self, context=context, router=router)",
            "        with context.session.begin(subtransactions=True):",
            "            # pre-generate id so it will be available when",
            "            # configuring external gw port",
            "            router_db = l3_models.Router(",
            "                id=router['id'],",
            "                tenant_id=router['tenant_id'],",
            "                name=router['name'],",
            "                admin_state_up=router['admin_state_up'],",
            "                status=constants.ACTIVE,",
            "                description=router.get('description'))",
            "            context.session.add(router_db)",
            "            registry.notify(resources.ROUTER, events.PRECOMMIT_CREATE,",
            "                            self, context=context, router=router,",
            "                            router_id=router['id'], router_db=router_db)",
            "            return router_db",
            "",
            "    def _update_gw_for_create_router(self, context, gw_info, router_id):",
            "        if gw_info:",
            "            router_db = self._get_router(context, router_id)",
            "            self._update_router_gw_info(context, router_id,",
            "                                        gw_info, router=router_db)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def create_router(self, context, router):",
            "        r = router['router']",
            "        gw_info = r.pop(EXTERNAL_GW_INFO, None)",
            "        create = functools.partial(self._create_router_db, context, r,",
            "                                   r['tenant_id'])",
            "        delete = functools.partial(self.delete_router, context)",
            "        update_gw = functools.partial(self._update_gw_for_create_router,",
            "                                      context, gw_info)",
            "        router_db, _unused = db_utils.safe_creation(context, create,",
            "                                                    delete, update_gw,",
            "                                                    transaction=False)",
            "        new_router = self._make_router_dict(router_db)",
            "        registry.notify(resources.ROUTER, events.AFTER_CREATE, self,",
            "                        context=context, router_id=router_db.id,",
            "                        router=new_router, request_attrs=r,",
            "                        router_db=router_db)",
            "        return new_router",
            "",
            "    def _update_router_db(self, context, router_id, data):",
            "        \"\"\"Update the DB object.\"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            router_db = self._get_router(context, router_id)",
            "            old_router = self._make_router_dict(router_db)",
            "            if data:",
            "                router_db.update(data)",
            "            registry.publish(resources.ROUTER, events.PRECOMMIT_UPDATE, self,",
            "                             payload=events.DBEventPayload(",
            "                                 context, request_body=data,",
            "                                 states=(old_router,), resource_id=router_id,",
            "                                 desired_state=router_db))",
            "            return router_db",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_router(self, context, id, router):",
            "        r = router['router']",
            "        gw_info = r.pop(EXTERNAL_GW_INFO, constants.ATTR_NOT_SPECIFIED)",
            "        original = self.get_router(context, id)",
            "        # check whether router needs and can be rescheduled to the proper",
            "        # l3 agent (associated with given external network);",
            "        # do check before update in DB as an exception will be raised",
            "        # in case no proper l3 agent found",
            "        if gw_info != constants.ATTR_NOT_SPECIFIED:",
            "            candidates = self._check_router_needs_rescheduling(",
            "                context, id, gw_info)",
            "            # Update the gateway outside of the DB update since it involves L2",
            "            # calls that don't make sense to rollback and may cause deadlocks",
            "            # in a transaction.",
            "            self._update_router_gw_info(context, id, gw_info)",
            "        else:",
            "            candidates = None",
            "        router_db = self._update_router_db(context, id, r)",
            "        if candidates:",
            "            l3_plugin = directory.get_plugin(plugin_constants.L3)",
            "            l3_plugin.reschedule_router(context, id, candidates)",
            "        updated = self._make_router_dict(router_db)",
            "        registry.notify(resources.ROUTER, events.AFTER_UPDATE, self,",
            "                        context=context, router_id=id, old_router=original,",
            "                        router=updated, request_attrs=r, router_db=router_db)",
            "        return updated",
            "",
            "    def _check_router_needs_rescheduling(self, context, router_id, gw_info):",
            "        \"\"\"Checks whether router's l3 agent can handle the given network",
            "",
            "        When external_network_bridge is set, each L3 agent can be associated",
            "        with at most one external network. If router's new external gateway",
            "        is on other network then the router needs to be rescheduled to the",
            "        proper l3 agent.",
            "        If external_network_bridge is not set then the agent",
            "        can support multiple external networks and rescheduling is not needed",
            "",
            "        :return: list of candidate agents if rescheduling needed,",
            "        None otherwise; raises exception if there is no eligible l3 agent",
            "        associated with target external network",
            "        \"\"\"",
            "        # TODO(obondarev): rethink placement of this func as l3 db manager is",
            "        # not really a proper place for agent scheduling stuff",
            "        network_id = gw_info.get('network_id') if gw_info else None",
            "        if not network_id:",
            "            return",
            "",
            "        nets = self._core_plugin.get_networks(",
            "            context, {extnet_apidef.EXTERNAL: [True]})",
            "        # nothing to do if there is only one external network",
            "        if len(nets) <= 1:",
            "            return",
            "",
            "        # first get plugin supporting l3 agent scheduling",
            "        # (either l3 service plugin or core_plugin)",
            "        l3_plugin = directory.get_plugin(plugin_constants.L3)",
            "        if (not extensions.is_extension_supported(",
            "                l3_plugin,",
            "                constants.L3_AGENT_SCHEDULER_EXT_ALIAS) or",
            "                l3_plugin.router_scheduler is None):",
            "            # that might mean that we are dealing with non-agent-based",
            "            # implementation of l3 services",
            "            return",
            "",
            "        if not l3_plugin.router_supports_scheduling(context, router_id):",
            "            return",
            "        cur_agents = l3_plugin.list_l3_agents_hosting_router(",
            "            context, router_id)['agents']",
            "        for agent in cur_agents:",
            "            ext_net_id = agent['configurations'].get(",
            "                'gateway_external_network_id')",
            "            ext_bridge = agent['configurations'].get(",
            "                'external_network_bridge', '')",
            "            if (ext_net_id == network_id or",
            "                    (not ext_net_id and not ext_bridge)):",
            "                return",
            "",
            "        # otherwise find l3 agent with matching gateway_external_network_id",
            "        active_agents = l3_plugin.get_l3_agents(context, active=True)",
            "        router = {",
            "            'id': router_id,",
            "            'external_gateway_info': {'network_id': network_id}",
            "        }",
            "        candidates = l3_plugin.get_l3_agent_candidates(context,",
            "                                                       router,",
            "                                                       active_agents)",
            "        if not candidates:",
            "            msg = (_('No eligible l3 agent associated with external network '",
            "                     '%s found') % network_id)",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "        return candidates",
            "",
            "    def _create_router_gw_port(self, context, router, network_id, ext_ips):",
            "        # Port has no 'tenant-id', as it is hidden from user",
            "        port_data = {'tenant_id': '',  # intentionally not set",
            "                     'network_id': network_id,",
            "                     'fixed_ips': ext_ips or constants.ATTR_NOT_SPECIFIED,",
            "                     'device_id': router['id'],",
            "                     'device_owner': DEVICE_OWNER_ROUTER_GW,",
            "                     'admin_state_up': True,",
            "                     'name': ''}",
            "        gw_port = p_utils.create_port(self._core_plugin,",
            "                                      context.elevated(), {'port': port_data})",
            "",
            "        if not gw_port['fixed_ips']:",
            "            LOG.debug('No IPs available for external network %s',",
            "                      network_id)",
            "        with plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context.elevated(), gw_port['id']):",
            "            with context.session.begin(subtransactions=True):",
            "                router.gw_port = self._core_plugin._get_port(",
            "                    context.elevated(), gw_port['id'])",
            "                router_port = l3_obj.RouterPort(",
            "                    context,",
            "                    router_id=router.id,",
            "                    port_id=gw_port['id'],",
            "                    port_type=DEVICE_OWNER_ROUTER_GW",
            "                )",
            "                context.session.add(router)",
            "                router_port.create()",
            "",
            "    def _validate_gw_info(self, context, gw_port, info, ext_ips):",
            "        network_id = info['network_id'] if info else None",
            "        if network_id:",
            "            network_db = self._core_plugin._get_network(context, network_id)",
            "            if not network_db.external:",
            "                msg = _(\"Network %s is not an external network\") % network_id",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "            if ext_ips:",
            "                subnets = self._core_plugin.get_subnets_by_network(context,",
            "                                                                   network_id)",
            "                for s in subnets:",
            "                    if not s['gateway_ip']:",
            "                        continue",
            "                    for ext_ip in ext_ips:",
            "                        if ext_ip.get('ip_address') == s['gateway_ip']:",
            "                            msg = _(\"External IP %s is the same as the \"",
            "                                    \"gateway IP\") % ext_ip.get('ip_address')",
            "                            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return network_id",
            "",
            "    # NOTE(yamamoto): This method is an override point for plugins",
            "    # inheriting this class.  Do not optimize this out.",
            "    def router_gw_port_has_floating_ips(self, context, router_id):",
            "        \"\"\"Return True if the router's gateway port is serving floating IPs.\"\"\"",
            "        return bool(self.get_floatingips_count(context,",
            "                                               {'router_id': [router_id]}))",
            "",
            "    def _delete_current_gw_port(self, context, router_id, router,",
            "                                new_network_id):",
            "        \"\"\"Delete gw port if attached to an old network.\"\"\"",
            "        port_requires_deletion = (",
            "            router.gw_port and router.gw_port['network_id'] != new_network_id)",
            "        if not port_requires_deletion:",
            "            return",
            "        admin_ctx = context.elevated()",
            "        old_network_id = router.gw_port['network_id']",
            "",
            "        if self.router_gw_port_has_floating_ips(admin_ctx, router_id):",
            "            raise l3_exc.RouterExternalGatewayInUseByFloatingIp(",
            "                router_id=router_id, net_id=router.gw_port['network_id'])",
            "        gw_ips = [x['ip_address'] for x in router.gw_port['fixed_ips']]",
            "        gw_port_id = router.gw_port['id']",
            "        self._delete_router_gw_port_db(context, router)",
            "        self._core_plugin.delete_port(",
            "            admin_ctx, gw_port_id, l3_port_check=False)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        registry.notify(resources.ROUTER_GATEWAY,",
            "                        events.AFTER_DELETE, self,",
            "                        router_id=router_id,",
            "                        context=context,",
            "                        router=router,",
            "                        network_id=old_network_id,",
            "                        new_network_id=new_network_id,",
            "                        gateway_ips=gw_ips)",
            "",
            "    def _delete_router_gw_port_db(self, context, router):",
            "        with context.session.begin(subtransactions=True):",
            "            router.gw_port = None",
            "            if router not in context.session:",
            "                context.session.add(router)",
            "            try:",
            "                kwargs = {'context': context, 'router_id': router.id}",
            "                registry.notify(",
            "                    resources.ROUTER_GATEWAY, events.BEFORE_DELETE, self,",
            "                    **kwargs)",
            "            except exceptions.CallbackFailure as e:",
            "                # NOTE(armax): preserve old check's behavior",
            "                if len(e.errors) == 1:",
            "                    raise e.errors[0].error",
            "                raise l3_exc.RouterInUse(router_id=router.id, reason=e)",
            "",
            "    def _create_gw_port(self, context, router_id, router, new_network_id,",
            "                        ext_ips):",
            "        new_valid_gw_port_attachment = (",
            "            new_network_id and (not router.gw_port or",
            "                              router.gw_port['network_id'] != new_network_id))",
            "        if new_valid_gw_port_attachment:",
            "            subnets = self._core_plugin.get_subnets_by_network(context,",
            "                                                               new_network_id)",
            "            try:",
            "                kwargs = {'context': context, 'router_id': router_id,",
            "                          'network_id': new_network_id, 'subnets': subnets}",
            "                registry.notify(",
            "                    resources.ROUTER_GATEWAY, events.BEFORE_CREATE, self,",
            "                    **kwargs)",
            "            except exceptions.CallbackFailure as e:",
            "                # raise the underlying exception",
            "                raise e.errors[0].error",
            "",
            "            self._check_for_dup_router_subnets(context, router,",
            "                                               new_network_id,",
            "                                               subnets,",
            "                                               include_gateway=True)",
            "            self._create_router_gw_port(context, router,",
            "                                        new_network_id, ext_ips)",
            "            registry.notify(resources.ROUTER_GATEWAY,",
            "                            events.AFTER_CREATE,",
            "                            self._create_gw_port,",
            "                            gw_ips=ext_ips,",
            "                            network_id=new_network_id,",
            "                            router_id=router_id)",
            "",
            "    def _update_current_gw_port(self, context, router_id, router, ext_ips):",
            "        self._core_plugin.update_port(context, router.gw_port['id'], {'port':",
            "                                      {'fixed_ips': ext_ips}})",
            "        context.session.expire(router.gw_port)",
            "",
            "    def _update_router_gw_info(self, context, router_id, info, router=None):",
            "        # TODO(salvatore-orlando): guarantee atomic behavior also across",
            "        # operations that span beyond the model classes handled by this",
            "        # class (e.g.: delete_port)",
            "        router = router or self._get_router(context, router_id)",
            "        gw_port = router.gw_port",
            "        ext_ips = info.get('external_fixed_ips') if info else []",
            "        ext_ip_change = self._check_for_external_ip_change(",
            "            context, gw_port, ext_ips)",
            "        network_id = self._validate_gw_info(context, gw_port, info, ext_ips)",
            "        if gw_port and ext_ip_change and gw_port['network_id'] == network_id:",
            "            self._update_current_gw_port(context, router_id, router,",
            "                                         ext_ips)",
            "        else:",
            "            self._delete_current_gw_port(context, router_id, router,",
            "                                         network_id)",
            "            self._create_gw_port(context, router_id, router, network_id,",
            "                                 ext_ips)",
            "",
            "    def _check_for_external_ip_change(self, context, gw_port, ext_ips):",
            "        # determine if new external IPs differ from the existing fixed_ips",
            "        if not ext_ips:",
            "            # no external_fixed_ips were included",
            "            return False",
            "        if not gw_port:",
            "            return True",
            "",
            "        subnet_ids = set(ip['subnet_id'] for ip in gw_port['fixed_ips'])",
            "        new_subnet_ids = set(f['subnet_id'] for f in ext_ips",
            "                             if f.get('subnet_id'))",
            "        subnet_change = not new_subnet_ids == subnet_ids",
            "        if subnet_change:",
            "            return True",
            "        ip_addresses = set(ip['ip_address'] for ip in gw_port['fixed_ips'])",
            "        new_ip_addresses = set(f['ip_address'] for f in ext_ips",
            "                               if f.get('ip_address'))",
            "        ip_address_change = not ip_addresses == new_ip_addresses",
            "        return ip_address_change",
            "",
            "    def _ensure_router_not_in_use(self, context, router_id):",
            "        \"\"\"Ensure that no internal network interface is attached",
            "        to the router.",
            "        \"\"\"",
            "        router = self._get_router(context, router_id)",
            "        device_owner = self._get_device_owner(context, router)",
            "        if any(rp.port_type == device_owner",
            "               for rp in router.attached_ports):",
            "            raise l3_exc.RouterInUse(router_id=router_id)",
            "        return router",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_router(self, context, id):",
            "        registry.notify(resources.ROUTER, events.BEFORE_DELETE,",
            "                        self, context=context, router_id=id)",
            "        # TODO(nati) Refactor here when we have router insertion model",
            "        router = self._ensure_router_not_in_use(context, id)",
            "        original = self._make_router_dict(router)",
            "        self._delete_current_gw_port(context, id, router, None)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "",
            "        router_ports = router.attached_ports",
            "        for rp in router_ports:",
            "            self._core_plugin.delete_port(context.elevated(),",
            "                                          rp.port.id,",
            "                                          l3_port_check=False)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "            registry.notify(resources.ROUTER, events.PRECOMMIT_DELETE,",
            "                            self, context=context, router_db=router,",
            "                            router_id=id)",
            "            # we bump the revision even though we are about to delete to throw",
            "            # staledataerror if something snuck in with a new interface",
            "            router.bump_revision()",
            "            context.session.flush()",
            "            context.session.delete(router)",
            "        registry.notify(resources.ROUTER, events.AFTER_DELETE, self,",
            "                        context=context, router_id=id, original=original)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_router(self, context, id, fields=None):",
            "        router = self._get_router(context, id)",
            "        return self._make_router_dict(router, fields)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_routers(self, context, filters=None, fields=None,",
            "                    sorts=None, limit=None, marker=None,",
            "                    page_reverse=False):",
            "        marker_obj = db_utils.get_marker_obj(self, context, 'router',",
            "                                             limit, marker)",
            "        return model_query.get_collection(context, l3_models.Router,",
            "                                          self._make_router_dict,",
            "                                          filters=filters, fields=fields,",
            "                                          sorts=sorts,",
            "                                          limit=limit,",
            "                                          marker_obj=marker_obj,",
            "                                          page_reverse=page_reverse)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_routers_count(self, context, filters=None):",
            "        return model_query.get_collection_count(context, l3_models.Router,",
            "                                                filters=filters)",
            "",
            "    def _check_for_dup_router_subnets(self, context, router,",
            "                                      network_id, new_subnets,",
            "                                      include_gateway=False):",
            "        # It's possible these ports are on the same network, but",
            "        # different subnets.",
            "        new_subnet_ids = {s['id'] for s in new_subnets}",
            "        router_subnets = []",
            "        for p in (rp.port for rp in router.attached_ports):",
            "            for ip in p['fixed_ips']:",
            "                if ip['subnet_id'] in new_subnet_ids:",
            "                    msg = (_(\"Router already has a port on subnet %s\")",
            "                           % ip['subnet_id'])",
            "                    raise n_exc.BadRequest(resource='router', msg=msg)",
            "                gw_owner = (p.get('device_owner') == DEVICE_OWNER_ROUTER_GW)",
            "                if include_gateway == gw_owner:",
            "                    router_subnets.append(ip['subnet_id'])",
            "",
            "        # Ignore temporary Prefix Delegation CIDRs",
            "        new_subnets = [s for s in new_subnets",
            "                       if s['cidr'] != constants.PROVISIONAL_IPV6_PD_PREFIX]",
            "        id_filter = {'id': router_subnets}",
            "        subnets = self._core_plugin.get_subnets(context.elevated(),",
            "                                                filters=id_filter)",
            "        for sub in subnets:",
            "            cidr = sub['cidr']",
            "            ipnet = netaddr.IPNetwork(cidr)",
            "            for s in new_subnets:",
            "                new_cidr = s['cidr']",
            "                new_ipnet = netaddr.IPNetwork(new_cidr)",
            "                match1 = netaddr.all_matching_cidrs(new_ipnet, [cidr])",
            "                match2 = netaddr.all_matching_cidrs(ipnet, [new_cidr])",
            "                if match1 or match2:",
            "                    data = {'subnet_cidr': new_cidr,",
            "                            'subnet_id': s['id'],",
            "                            'cidr': cidr,",
            "                            'sub_id': sub['id']}",
            "                    msg = (_(\"Cidr %(subnet_cidr)s of subnet \"",
            "                             \"%(subnet_id)s overlaps with cidr %(cidr)s \"",
            "                             \"of subnet %(sub_id)s\") % data)",
            "                    raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "    def _get_device_owner(self, context, router=None):",
            "        \"\"\"Get device_owner for the specified router.\"\"\"",
            "        # NOTE(armando-migliaccio): in the base case this is invariant",
            "        return DEVICE_OWNER_ROUTER_INTF",
            "",
            "    def _validate_interface_info(self, interface_info, for_removal=False):",
            "        port_id_specified = interface_info and 'port_id' in interface_info",
            "        subnet_id_specified = interface_info and 'subnet_id' in interface_info",
            "        if not (port_id_specified or subnet_id_specified):",
            "            msg = _(\"Either subnet_id or port_id must be specified\")",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        for key in ('port_id', 'subnet_id'):",
            "            if key not in interface_info:",
            "                continue",
            "            err = validators.validate_uuid(interface_info[key])",
            "            if err:",
            "                raise n_exc.BadRequest(resource='router', msg=err)",
            "        if not for_removal:",
            "            if port_id_specified and subnet_id_specified:",
            "                msg = _(\"Cannot specify both subnet-id and port-id\")",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return port_id_specified, subnet_id_specified",
            "",
            "    def _check_router_port(self, context, port_id, device_id):",
            "        \"\"\"Check that a port is available for an attachment to a router",
            "",
            "        :param context: The context of the request.",
            "        :param port_id: The port to be attached.",
            "        :param device_id: This method will check that device_id corresponds to",
            "        the device_id of the port. It raises PortInUse exception if it",
            "        doesn't.",
            "        :returns: The port description returned by the core plugin.",
            "        :raises: PortInUse if the device_id is not the same as the port's one.",
            "        :raises: BadRequest if the port has no fixed IP.",
            "        \"\"\"",
            "        port = self._core_plugin.get_port(context, port_id)",
            "        if port['device_id'] != device_id:",
            "            raise n_exc.PortInUse(net_id=port['network_id'],",
            "                                  port_id=port['id'],",
            "                                  device_id=port['device_id'])",
            "        if not port['fixed_ips']:",
            "            msg = _('Router port must have at least one fixed IP')",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        return port",
            "",
            "    def _validate_port_in_range_or_admin(self, context, subnets, port):",
            "        if context.is_admin:",
            "            return",
            "        subnets_by_id = {}",
            "        for s in subnets:",
            "            addr_set = netaddr.IPSet()",
            "            for range in s['allocation_pools']:",
            "                addr_set.add(netaddr.IPRange(netaddr.IPAddress(range['start']),",
            "                                             netaddr.IPAddress(range['end'])))",
            "            subnets_by_id[s['id']] = (addr_set, s['project_id'],)",
            "        for subnet_id, ip in [(fix_ip['subnet_id'], fix_ip['ip_address'],)",
            "                              for fix_ip in port['fixed_ips']]:",
            "            if (ip not in subnets_by_id[subnet_id][0] and",
            "                    context.project_id != subnets_by_id[subnet_id][1]):",
            "                msg = (_('Cannot add interface to router because specified '",
            "                         'port %(port)s has an IP address out of the '",
            "                         'allocation pool of subnet %(subnet)s, which is not '",
            "                         'owned by the project making the request') %",
            "                       {'port': port['id'], 'subnet': subnet_id})",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "    def _validate_router_port_info(self, context, router, port_id):",
            "        with db_api.autonested_transaction(context.session):",
            "            # check again within transaction to mitigate race",
            "            port = self._check_router_port(context, port_id, router.id)",
            "",
            "            # Only allow one router port with IPv6 subnets per network id",
            "            if self._port_has_ipv6_address(port):",
            "                for existing_port in (rp.port for rp in router.attached_ports):",
            "                    if (existing_port['network_id'] == port['network_id'] and",
            "                            self._port_has_ipv6_address(existing_port)):",
            "                        msg = _(\"Cannot have multiple router ports with the \"",
            "                                \"same network id if both contain IPv6 \"",
            "                                \"subnets. Existing port %(p)s has IPv6 \"",
            "                                \"subnet(s) and network id %(nid)s\")",
            "                        raise n_exc.BadRequest(resource='router', msg=msg % {",
            "                            'p': existing_port['id'],",
            "                            'nid': existing_port['network_id']})",
            "",
            "            fixed_ips = [ip for ip in port['fixed_ips']]",
            "            subnets = []",
            "            for fixed_ip in fixed_ips:",
            "                subnet = self._core_plugin.get_subnet(context,",
            "                                                      fixed_ip['subnet_id'])",
            "                subnets.append(subnet)",
            "",
            "            if subnets:",
            "                self._check_for_dup_router_subnets(context, router,",
            "                                                   port['network_id'],",
            "                                                   subnets)",
            "",
            "            # Keep the restriction against multiple IPv4 subnets",
            "            if len([s for s in subnets if s['ip_version'] == 4]) > 1:",
            "                msg = _(\"Cannot have multiple \"",
            "                        \"IPv4 subnets on router port\")",
            "                raise n_exc.BadRequest(resource='router', msg=msg)",
            "            self._validate_port_in_range_or_admin(context, subnets, port)",
            "            return port, subnets",
            "",
            "    def _notify_attaching_interface(self, context, router_db, port,",
            "                                    interface_info):",
            "        \"\"\"Notify third party code that an interface is being attached to a",
            "        router",
            "",
            "        :param context: The context of the request.",
            "        :param router_db: The router db object having an interface attached.",
            "        :param port: The port object being attached to the router.",
            "        :param interface_info: The requested interface attachment info passed",
            "        to add_router_interface.",
            "        :raises: RouterInterfaceAttachmentConflict if a third party code",
            "        prevent the port to be attach to the router.",
            "        \"\"\"",
            "        try:",
            "            registry.notify(resources.ROUTER_INTERFACE,",
            "                            events.BEFORE_CREATE,",
            "                            self,",
            "                            context=context,",
            "                            router_db=router_db,",
            "                            port=port,",
            "                            interface_info=interface_info,",
            "                            router_id=router_db.id,",
            "                            network_id=port['network_id'])",
            "        except exceptions.CallbackFailure as e:",
            "            # raise the underlying exception",
            "            reason = (_('cannot perform router interface attachment '",
            "                        'due to %(reason)s') % {'reason': e})",
            "            raise l3_exc.RouterInterfaceAttachmentConflict(reason=reason)",
            "",
            "    def _add_interface_by_port(self, context, router, port_id, owner):",
            "        # Update owner before actual process in order to avoid the",
            "        # case where a port might get attached to a router without the",
            "        # owner successfully updating due to an unavailable backend.",
            "        self._core_plugin.update_port(",
            "            context, port_id, {'port': {'device_id': router.id,",
            "                                        'device_owner': owner}})",
            "",
            "        return self._validate_router_port_info(context, router, port_id)",
            "",
            "    def _port_has_ipv6_address(self, port):",
            "        for fixed_ip in port['fixed_ips']:",
            "            if netaddr.IPNetwork(fixed_ip['ip_address']).version == 6:",
            "                return True",
            "",
            "    def _find_ipv6_router_port_by_network(self, context, router, net_id):",
            "        router_dev_owner = self._get_device_owner(context, router)",
            "        for port in router.attached_ports:",
            "            p = port['port']",
            "            if p['device_owner'] != router_dev_owner:",
            "                # we don't want any special purpose internal ports",
            "                continue",
            "            if p['network_id'] == net_id and self._port_has_ipv6_address(p):",
            "                return port",
            "",
            "    def _add_interface_by_subnet(self, context, router, subnet_id, owner):",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "        if not subnet['gateway_ip']:",
            "            msg = _('Subnet for router interface must have a gateway IP')",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        if subnet['project_id'] != context.project_id and not context.is_admin:",
            "            msg = (_('Cannot add interface to router because subnet %s is not '",
            "                     'owned by project making the request') % subnet_id)",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        if (subnet['ip_version'] == 6 and subnet['ipv6_ra_mode'] is None and",
            "                subnet['ipv6_address_mode'] is not None):",
            "            msg = (_('IPv6 subnet %s configured to receive RAs from an '",
            "                   'external router cannot be added to Neutron Router.') %",
            "                   subnet['id'])",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "        self._check_for_dup_router_subnets(context, router,",
            "                                           subnet['network_id'], [subnet])",
            "        fixed_ip = {'ip_address': subnet['gateway_ip'],",
            "                    'subnet_id': subnet['id']}",
            "",
            "        if (subnet['ip_version'] == 6 and not",
            "                ipv6_utils.is_ipv6_pd_enabled(subnet)):",
            "            # Add new prefix to an existing ipv6 port with the same network id",
            "            # if one exists",
            "            port = self._find_ipv6_router_port_by_network(context, router,",
            "                                                          subnet['network_id'])",
            "            if port:",
            "                fixed_ips = list(map(dict, port['port']['fixed_ips']))",
            "                fixed_ips.append(fixed_ip)",
            "                return self._core_plugin.update_port(context,",
            "                        port['port_id'], {'port':",
            "                            {'fixed_ips': fixed_ips}}), [subnet], False",
            "",
            "        port_data = {'tenant_id': router.tenant_id,",
            "                     'network_id': subnet['network_id'],",
            "                     'fixed_ips': [fixed_ip],",
            "                     'admin_state_up': True,",
            "                     'device_id': router.id,",
            "                     'device_owner': owner,",
            "                     'name': ''}",
            "        return p_utils.create_port(self._core_plugin, context,",
            "                                   {'port': port_data}), [subnet], True",
            "",
            "    @staticmethod",
            "    def _make_router_interface_info(",
            "            router_id, tenant_id, port_id, network_id, subnet_id, subnet_ids):",
            "        return {",
            "            'id': router_id,",
            "            'tenant_id': tenant_id,",
            "            'port_id': port_id,",
            "            'network_id': network_id,",
            "            'subnet_id': subnet_id,  # deprecated by IPv6 multi-prefix",
            "            'subnet_ids': subnet_ids",
            "        }",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def add_router_interface(self, context, router_id, interface_info=None):",
            "        router = self._get_router(context, router_id)",
            "        add_by_port, add_by_sub = self._validate_interface_info(interface_info)",
            "        device_owner = self._get_device_owner(context, router_id)",
            "",
            "        # This should be True unless adding an IPv6 prefix to an existing port",
            "        new_router_intf = True",
            "        cleanup_port = False",
            "",
            "        if add_by_port:",
            "            port_id = interface_info['port_id']",
            "            port = self._check_router_port(context, port_id, '')",
            "            revert_value = {'device_id': '',",
            "                            'device_owner': port['device_owner']}",
            "            with plugin_utils.update_port_on_error(",
            "                    self._core_plugin, context, port_id, revert_value):",
            "                port, subnets = self._add_interface_by_port(",
            "                    context, router, port_id, device_owner)",
            "        # add_by_subnet is not used here, because the validation logic of",
            "        # _validate_interface_info ensures that either of add_by_* is True.",
            "        else:",
            "            port, subnets, new_router_intf = self._add_interface_by_subnet(",
            "                    context, router, interface_info['subnet_id'], device_owner)",
            "            cleanup_port = new_router_intf  # only cleanup port we created",
            "            revert_value = {'device_id': '',",
            "                            'device_owner': port['device_owner']}",
            "",
            "        if cleanup_port:",
            "            mgr = plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context, port['id'])",
            "        else:",
            "            mgr = plugin_utils.update_port_on_error(",
            "                self._core_plugin, context, port['id'], revert_value)",
            "",
            "        if new_router_intf:",
            "            with mgr:",
            "                self._notify_attaching_interface(context, router_db=router,",
            "                                                 port=port,",
            "                                                 interface_info=interface_info)",
            "                l3_obj.RouterPort(",
            "                    context,",
            "                    port_id=port['id'],",
            "                    router_id=router.id,",
            "                    port_type=device_owner",
            "                ).create()",
            "                # Update owner after actual process again in order to",
            "                # make sure the records in routerports table and ports",
            "                # table are consistent.",
            "                self._core_plugin.update_port(",
            "                    context, port['id'], {'port': {",
            "                                         'device_id': router.id,",
            "                                         'device_owner': device_owner}})",
            "",
            "        gw_ips = []",
            "        gw_network_id = None",
            "        if router.gw_port:",
            "            gw_network_id = router.gw_port.network_id",
            "            gw_ips = [x['ip_address'] for x in router.gw_port.fixed_ips]",
            "",
            "        registry.notify(resources.ROUTER_INTERFACE,",
            "                        events.AFTER_CREATE,",
            "                        self,",
            "                        context=context,",
            "                        network_id=gw_network_id,",
            "                        gateway_ips=gw_ips,",
            "                        cidrs=[x['cidr'] for x in subnets],",
            "                        subnets=subnets,",
            "                        port_id=port['id'],",
            "                        router_id=router_id,",
            "                        port=port,",
            "                        new_interface=new_router_intf,",
            "                        interface_info=interface_info)",
            "",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        return self._make_router_interface_info(",
            "            router.id, port['tenant_id'], port['id'], port['network_id'],",
            "            subnets[-1]['id'], [subnet['id'] for subnet in subnets])",
            "",
            "    def _confirm_router_interface_not_in_use(self, context, router_id,",
            "                                             subnet_id):",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "        subnet_cidr = netaddr.IPNetwork(subnet['cidr'])",
            "        try:",
            "            kwargs = {'context': context, 'router_id': router_id,",
            "                      'subnet_id': subnet_id}",
            "            registry.notify(",
            "                resources.ROUTER_INTERFACE,",
            "                events.BEFORE_DELETE, self, **kwargs)",
            "        except exceptions.CallbackFailure as e:",
            "            # NOTE(armax): preserve old check's behavior",
            "            if len(e.errors) == 1:",
            "                raise e.errors[0].error",
            "            raise l3_exc.RouterInUse(router_id=router_id, reason=e)",
            "        fip_objs = l3_obj.FloatingIP.get_objects(context, router_id=router_id)",
            "        for fip_obj in fip_objs:",
            "            if fip_obj.fixed_ip_address in subnet_cidr:",
            "                raise l3_exc.RouterInterfaceInUseByFloatingIP(",
            "                    router_id=router_id, subnet_id=subnet_id)",
            "",
            "    def _remove_interface_by_port(self, context, router_id,",
            "                                  port_id, subnet_id, owner):",
            "        obj = l3_obj.RouterPort.get_object(",
            "            context,",
            "            port_id=port_id,",
            "            router_id=router_id,",
            "            port_type=owner",
            "        )",
            "        if obj:",
            "            try:",
            "                port = self._core_plugin.get_port(context, obj.port_id)",
            "            except n_exc.PortNotFound:",
            "                raise l3_exc.RouterInterfaceNotFound(",
            "                    router_id=router_id, port_id=port_id)",
            "        else:",
            "            raise l3_exc.RouterInterfaceNotFound(",
            "                router_id=router_id, port_id=port_id)",
            "        port_subnet_ids = [fixed_ip['subnet_id']",
            "                           for fixed_ip in port['fixed_ips']]",
            "        if subnet_id and subnet_id not in port_subnet_ids:",
            "            raise n_exc.SubnetMismatchForPort(",
            "                port_id=port_id, subnet_id=subnet_id)",
            "        subnets = [self._core_plugin.get_subnet(context, port_subnet_id)",
            "                   for port_subnet_id in port_subnet_ids]",
            "        for port_subnet_id in port_subnet_ids:",
            "            self._confirm_router_interface_not_in_use(",
            "                    context, router_id, port_subnet_id)",
            "        self._core_plugin.delete_port(context, port['id'],",
            "                                      l3_port_check=False)",
            "        return (port, subnets)",
            "",
            "    def _remove_interface_by_subnet(self, context,",
            "                                    router_id, subnet_id, owner):",
            "        self._confirm_router_interface_not_in_use(",
            "            context, router_id, subnet_id)",
            "        subnet = self._core_plugin.get_subnet(context, subnet_id)",
            "",
            "        try:",
            "            ports = port_obj.Port.get_ports_by_router(",
            "                context, router_id, owner, subnet)",
            "",
            "            for p in ports:",
            "                try:",
            "                    p = self._core_plugin.get_port(context, p.id)",
            "                except n_exc.PortNotFound:",
            "                    continue",
            "                port_subnets = [fip['subnet_id'] for fip in p['fixed_ips']]",
            "                if subnet_id in port_subnets and len(port_subnets) > 1:",
            "                    # multiple prefix port - delete prefix from port",
            "                    fixed_ips = [dict(fip) for fip in p['fixed_ips']",
            "                                 if fip['subnet_id'] != subnet_id]",
            "                    self._core_plugin.update_port(context, p['id'],",
            "                            {'port':",
            "                                {'fixed_ips': fixed_ips}})",
            "                    return (p, [subnet])",
            "                elif subnet_id in port_subnets:",
            "                    # only one subnet on port - delete the port",
            "                    self._core_plugin.delete_port(context, p['id'],",
            "                                                  l3_port_check=False)",
            "                    return (p, [subnet])",
            "        except exc.NoResultFound:",
            "            pass",
            "        raise l3_exc.RouterInterfaceNotFoundForSubnet(",
            "            router_id=router_id, subnet_id=subnet_id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def remove_router_interface(self, context, router_id, interface_info):",
            "        remove_by_port, remove_by_subnet = (",
            "            self._validate_interface_info(interface_info, for_removal=True)",
            "        )",
            "        port_id = interface_info.get('port_id')",
            "        subnet_id = interface_info.get('subnet_id')",
            "        device_owner = self._get_device_owner(context, router_id)",
            "        if remove_by_port:",
            "            port, subnets = self._remove_interface_by_port(context, router_id,",
            "                                                           port_id, subnet_id,",
            "                                                           device_owner)",
            "        # remove_by_subnet is not used here, because the validation logic of",
            "        # _validate_interface_info ensures that at least one of remote_by_*",
            "        # is True.",
            "        else:",
            "            port, subnets = self._remove_interface_by_subnet(",
            "                    context, router_id, subnet_id, device_owner)",
            "",
            "        gw_network_id = None",
            "        gw_ips = []",
            "        router = self._get_router(context, router_id)",
            "        if router.gw_port:",
            "            gw_network_id = router.gw_port.network_id",
            "            gw_ips = [x['ip_address'] for x in router.gw_port.fixed_ips]",
            "",
            "        registry.notify(resources.ROUTER_INTERFACE,",
            "                        events.AFTER_DELETE,",
            "                        self,",
            "                        context=context,",
            "                        cidrs=[x['cidr'] for x in subnets],",
            "                        network_id=gw_network_id,",
            "                        gateway_ips=gw_ips,",
            "                        port=port,",
            "                        router_id=router_id,",
            "                        interface_info=interface_info)",
            "        with context.session.begin(subtransactions=True):",
            "            context.session.refresh(router)",
            "        return self._make_router_interface_info(router_id, port['tenant_id'],",
            "                                                port['id'], port['network_id'],",
            "                                                subnets[0]['id'],",
            "                                                [subnet['id'] for subnet in",
            "                                                    subnets])",
            "",
            "    def _get_floatingip(self, context, id):",
            "        floatingip = l3_obj.FloatingIP.get_object(context, id=id)",
            "        if not floatingip:",
            "            raise l3_exc.FloatingIPNotFound(floatingip_id=id)",
            "        return floatingip",
            "",
            "    def _make_floatingip_dict(self, floatingip, fields=None,",
            "                              process_extensions=True):",
            "        floating_ip_address = (str(floatingip.floating_ip_address)",
            "            if floatingip.floating_ip_address else None)",
            "        fixed_ip_address = (str(floatingip.fixed_ip_address)",
            "            if floatingip.fixed_ip_address else None)",
            "        res = {'id': floatingip.id,",
            "               'tenant_id': floatingip.project_id,",
            "               'floating_ip_address': floating_ip_address,",
            "               'floating_network_id': floatingip.floating_network_id,",
            "               'router_id': floatingip.router_id,",
            "               'port_id': floatingip.fixed_port_id,",
            "               'fixed_ip_address': fixed_ip_address,",
            "               'status': floatingip.status}",
            "        # NOTE(mlavalle): The following assumes this mixin is used in a",
            "        # class inheriting from CommonDbMixin, which is true for all existing",
            "        # plugins.",
            "        # TODO(lujinluo): Change floatingip.db_obj to floatingip once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        if process_extensions:",
            "            resource_extend.apply_funcs(",
            "                l3_apidef.FLOATINGIPS, res, floatingip.db_obj)",
            "        return db_utils.resource_fields(res, fields)",
            "",
            "    def _get_router_for_floatingip(self, context, internal_port,",
            "                                   internal_subnet_id,",
            "                                   external_network_id):",
            "        subnet = self._core_plugin.get_subnet(context, internal_subnet_id)",
            "        return self.get_router_for_floatingip(context,",
            "            internal_port, subnet, external_network_id)",
            "",
            "    # NOTE(yamamoto): This method is an override point for plugins",
            "    # inheriting this class.  Do not optimize this out.",
            "    def get_router_for_floatingip(self, context, internal_port,",
            "                                  internal_subnet, external_network_id):",
            "        \"\"\"Find a router to handle the floating-ip association.",
            "",
            "        :param internal_port: The port for the fixed-ip.",
            "        :param internal_subnet: The subnet for the fixed-ip.",
            "        :param external_network_id: The external network for floating-ip.",
            "",
            "        :raises: ExternalGatewayForFloatingIPNotFound if no suitable router",
            "                 is found.",
            "        \"\"\"",
            "",
            "        # Find routers(with router_id and interface address) that",
            "        # connect given internal subnet and the external network.",
            "        # Among them, if the router's interface address matches",
            "        # with subnet's gateway-ip, return that router.",
            "        # Otherwise return the first router.",
            "        RouterPort = l3_models.RouterPort",
            "        gw_port = orm.aliased(models_v2.Port, name=\"gw_port\")",
            "        # TODO(lujinluo): Need IPAllocation and Port object",
            "        routerport_qry = context.session.query(",
            "            RouterPort.router_id, models_v2.IPAllocation.ip_address).join(",
            "            models_v2.Port, models_v2.IPAllocation).filter(",
            "            models_v2.Port.network_id == internal_port['network_id'],",
            "            RouterPort.port_type.in_(constants.ROUTER_INTERFACE_OWNERS),",
            "            models_v2.IPAllocation.subnet_id == internal_subnet['id']",
            "        ).join(gw_port, gw_port.device_id == RouterPort.router_id).filter(",
            "            gw_port.network_id == external_network_id,",
            "            gw_port.device_owner == DEVICE_OWNER_ROUTER_GW",
            "        ).distinct()",
            "",
            "        first_router_id = None",
            "        for router_id, interface_ip in routerport_qry:",
            "            if interface_ip == internal_subnet['gateway_ip']:",
            "                return router_id",
            "            if not first_router_id:",
            "                first_router_id = router_id",
            "        if first_router_id:",
            "            return first_router_id",
            "",
            "        raise l3_exc.ExternalGatewayForFloatingIPNotFound(",
            "            subnet_id=internal_subnet['id'],",
            "            external_network_id=external_network_id,",
            "            port_id=internal_port['id'])",
            "",
            "    def _port_ipv4_fixed_ips(self, port):",
            "        return [ip for ip in port['fixed_ips']",
            "                if netaddr.IPAddress(ip['ip_address']).version == 4]",
            "",
            "    def _internal_fip_assoc_data(self, context, fip, tenant_id):",
            "        \"\"\"Retrieve internal port data for floating IP.",
            "",
            "        Retrieve information concerning the internal port where",
            "        the floating IP should be associated to.",
            "        \"\"\"",
            "        internal_port = self._core_plugin.get_port(context, fip['port_id'])",
            "        if internal_port['tenant_id'] != tenant_id and not context.is_admin:",
            "            port_id = fip['port_id']",
            "            msg = (_('Cannot process floating IP association with '",
            "                     'Port %s, since that port is owned by a '",
            "                     'different tenant') % port_id)",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        internal_subnet_id = None",
            "        if not utils.is_fip_serviced(internal_port.get('device_owner')):",
            "            msg = _('Port %(id)s is unable to be assigned a floating IP')",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        if fip.get('fixed_ip_address'):",
            "            internal_ip_address = fip['fixed_ip_address']",
            "            if netaddr.IPAddress(internal_ip_address).version != 4:",
            "                msg = (_('Cannot process floating IP association with %s, '",
            "                         'since that is not an IPv4 address') %",
            "                       internal_ip_address)",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            for ip in internal_port['fixed_ips']:",
            "                if ip['ip_address'] == internal_ip_address:",
            "                    internal_subnet_id = ip['subnet_id']",
            "            if not internal_subnet_id:",
            "                msg = (_('Port %(id)s does not have fixed ip %(address)s') %",
            "                       {'id': internal_port['id'],",
            "                        'address': internal_ip_address})",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        else:",
            "            ipv4_fixed_ips = self._port_ipv4_fixed_ips(internal_port)",
            "            if not ipv4_fixed_ips:",
            "                msg = (_('Cannot add floating IP to port %s that has '",
            "                         'no fixed IPv4 addresses') % internal_port['id'])",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            if len(ipv4_fixed_ips) > 1:",
            "                msg = (_('Port %s has multiple fixed IPv4 addresses.  Must '",
            "                         'provide a specific IPv4 address when assigning a '",
            "                         'floating IP') % internal_port['id'])",
            "                raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "            internal_ip_address = ipv4_fixed_ips[0]['ip_address']",
            "            internal_subnet_id = ipv4_fixed_ips[0]['subnet_id']",
            "        return internal_port, internal_subnet_id, internal_ip_address",
            "",
            "    def _get_assoc_data(self, context, fip, floatingip_obj):",
            "        \"\"\"Determine/extract data associated with the internal port.",
            "",
            "        When a floating IP is associated with an internal port,",
            "        we need to extract/determine some data associated with the",
            "        internal port, including the internal_ip_address, and router_id.",
            "        The confirmation of the internal port whether owned by the tenant who",
            "        owns the floating IP will be confirmed by _get_router_for_floatingip.",
            "        \"\"\"",
            "        (internal_port, internal_subnet_id,",
            "         internal_ip_address) = self._internal_fip_assoc_data(",
            "            context, fip, floatingip_obj.project_id)",
            "        router_id = self._get_router_for_floatingip(",
            "            context, internal_port,",
            "            internal_subnet_id, floatingip_obj.floating_network_id)",
            "",
            "        return (fip['port_id'], internal_ip_address, router_id)",
            "",
            "    def _check_and_get_fip_assoc(self, context, fip, floatingip_obj):",
            "        port_id = internal_ip_address = router_id = None",
            "        if fip.get('fixed_ip_address') and not fip.get('port_id'):",
            "            msg = _(\"fixed_ip_address cannot be specified without a port_id\")",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "        if fip.get('port_id'):",
            "            port_id, internal_ip_address, router_id = self._get_assoc_data(",
            "                context,",
            "                fip,",
            "                floatingip_obj)",
            "",
            "            if port_id == floatingip_obj.fixed_port_id:",
            "                # Floating IP association is not changed.",
            "                return port_id, internal_ip_address, router_id",
            "",
            "            fip_exists = l3_obj.FloatingIP.objects_exist(",
            "                    context,",
            "                    fixed_port_id=fip['port_id'],",
            "                    floating_network_id=floatingip_obj.floating_network_id,",
            "                    fixed_ip_address=netaddr.IPAddress(internal_ip_address))",
            "            if fip_exists:",
            "                floating_ip_address = (str(floatingip_obj.floating_ip_address)",
            "                    if floatingip_obj.floating_ip_address else None)",
            "                raise l3_exc.FloatingIPPortAlreadyAssociated(",
            "                    port_id=fip['port_id'],",
            "                    fip_id=floatingip_obj.id,",
            "                    floating_ip_address=floating_ip_address,",
            "                    fixed_ip=internal_ip_address,",
            "                    net_id=floatingip_obj.floating_network_id)",
            "",
            "        if fip and 'port_id' not in fip and floatingip_obj.fixed_port_id:",
            "            # NOTE(liuyulong): without the fix of bug #1610045 here could",
            "            # also let floating IP can be dissociated with an empty",
            "            # updating dict.",
            "            fip['port_id'] = floatingip_obj.fixed_port_id",
            "            port_id, internal_ip_address, router_id = self._get_assoc_data(",
            "                context, fip, floatingip_obj)",
            "",
            "        # After all upper conditions, if updating API dict is submitted with",
            "        # {'port_id': null}, then the floating IP cloud also be dissociated.",
            "        return port_id, internal_ip_address, router_id",
            "",
            "    def _update_fip_assoc(self, context, fip, floatingip_obj, external_port):",
            "        previous_router_id = floatingip_obj.router_id",
            "        port_id, internal_ip_address, router_id = (",
            "            self._check_and_get_fip_assoc(context, fip, floatingip_obj))",
            "        floatingip_obj.fixed_ip_address = (",
            "            netaddr.IPAddress(internal_ip_address)",
            "            if internal_ip_address else None)",
            "        floatingip_obj.fixed_port_id = port_id",
            "        floatingip_obj.router_id = router_id",
            "        floatingip_obj.last_known_router_id = previous_router_id",
            "        if 'description' in fip:",
            "            floatingip_obj.description = fip['description']",
            "        floating_ip_address = (str(floatingip_obj.floating_ip_address)",
            "            if floatingip_obj.floating_ip_address else None)",
            "        return {'fixed_ip_address': internal_ip_address,",
            "                'fixed_port_id': port_id,",
            "                'router_id': router_id,",
            "                'last_known_router_id': previous_router_id,",
            "                'floating_ip_address': floating_ip_address,",
            "                'floating_network_id': floatingip_obj.floating_network_id,",
            "                'floating_ip_id': floatingip_obj.id,",
            "                'context': context}",
            "",
            "    def _is_ipv4_network(self, context, net_id):",
            "        net = self._core_plugin._get_network(context, net_id)",
            "        return any(s.ip_version == 4 for s in net.subnets)",
            "",
            "    def _create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        fip = floatingip['floatingip']",
            "        fip_id = uuidutils.generate_uuid()",
            "",
            "        f_net_id = fip['floating_network_id']",
            "        if not self._core_plugin._network_is_external(context, f_net_id):",
            "            msg = _(\"Network %s is not a valid external network\") % f_net_id",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        if not self._is_ipv4_network(context, f_net_id):",
            "            msg = _(\"Network %s does not contain any IPv4 subnet\") % f_net_id",
            "            raise n_exc.BadRequest(resource='floatingip', msg=msg)",
            "",
            "        # This external port is never exposed to the tenant.",
            "        # it is used purely for internal system and admin use when",
            "        # managing floating IPs.",
            "",
            "        port = {'tenant_id': '',  # tenant intentionally not set",
            "                'network_id': f_net_id,",
            "                'admin_state_up': True,",
            "                'device_id': 'PENDING',",
            "                'device_owner': DEVICE_OWNER_FLOATINGIP,",
            "                'status': constants.PORT_STATUS_NOTAPPLICABLE,",
            "                'name': ''}",
            "",
            "        # Both subnet_id and floating_ip_address are accepted, if",
            "        # floating_ip_address is not in the subnet,",
            "        # InvalidIpForSubnet exception will be raised.",
            "        fixed_ip = {}",
            "        if validators.is_attr_set(fip.get('subnet_id')):",
            "            fixed_ip['subnet_id'] = fip['subnet_id']",
            "        if validators.is_attr_set(fip.get('floating_ip_address')):",
            "            fixed_ip['ip_address'] = fip['floating_ip_address']",
            "        if fixed_ip:",
            "            port['fixed_ips'] = [fixed_ip]",
            "",
            "        # 'status' in port dict could not be updated by default, use",
            "        # check_allow_post to stop the verification of system",
            "        external_port = p_utils.create_port(self._core_plugin,",
            "                                            context.elevated(),",
            "                                            {'port': port},",
            "                                            check_allow_post=False)",
            "",
            "        with plugin_utils.delete_port_on_error(",
            "                self._core_plugin, context.elevated(),",
            "                external_port['id']),\\",
            "                context.session.begin(subtransactions=True):",
            "            # Ensure IPv4 addresses are allocated on external port",
            "            external_ipv4_ips = self._port_ipv4_fixed_ips(external_port)",
            "            if not external_ipv4_ips:",
            "                raise n_exc.ExternalIpAddressExhausted(net_id=f_net_id)",
            "",
            "            floating_fixed_ip = external_ipv4_ips[0]",
            "            floating_ip_address = floating_fixed_ip['ip_address']",
            "            floatingip_obj = l3_obj.FloatingIP(",
            "                context,",
            "                id=fip_id,",
            "                project_id=fip['tenant_id'],",
            "                status=initial_status,",
            "                floating_network_id=fip['floating_network_id'],",
            "                floating_ip_address=floating_ip_address,",
            "                floating_port_id=external_port['id'],",
            "                description=fip.get('description'))",
            "            # Update association with internal port",
            "            # and define external IP address",
            "            assoc_result = self._update_fip_assoc(",
            "                context, fip, floatingip_obj, external_port)",
            "            floatingip_obj.create()",
            "            floatingip_dict = self._make_floatingip_dict(",
            "                floatingip_obj, process_extensions=False)",
            "            if self._is_dns_integration_supported:",
            "                dns_data = self._process_dns_floatingip_create_precommit(",
            "                    context, floatingip_dict, fip)",
            "            if self._is_fip_qos_supported:",
            "                self._process_extra_fip_qos_create(context, fip_id, fip)",
            "            floatingip_obj = l3_obj.FloatingIP.get_object(",
            "                context, id=floatingip_obj.id)",
            "            floatingip_db = floatingip_obj.db_obj",
            "",
            "            registry.notify(resources.FLOATING_IP, events.PRECOMMIT_CREATE,",
            "                            self, context=context, floatingip=fip,",
            "                            floatingip_id=fip_id,",
            "                            floatingip_db=floatingip_db)",
            "",
            "        self._core_plugin.update_port(context.elevated(), external_port['id'],",
            "                                      {'port': {'device_id': fip_id}})",
            "        registry.notify(resources.FLOATING_IP,",
            "                        events.AFTER_UPDATE,",
            "                        self._update_fip_assoc,",
            "                        **assoc_result)",
            "",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_create_postcommit(context,",
            "                                                           floatingip_dict,",
            "                                                           dns_data)",
            "        # TODO(lujinluo): Change floatingip_db to floatingip_obj once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        resource_extend.apply_funcs(l3_apidef.FLOATINGIPS, floatingip_dict,",
            "                                    floatingip_db)",
            "        return floatingip_dict",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        return self._create_floatingip(context, floatingip, initial_status)",
            "",
            "    def _update_floatingip(self, context, id, floatingip):",
            "        fip = floatingip['floatingip']",
            "        with context.session.begin(subtransactions=True):",
            "            floatingip_obj = self._get_floatingip(context, id)",
            "            old_floatingip = self._make_floatingip_dict(floatingip_obj)",
            "            fip_port_id = floatingip_obj.floating_port_id",
            "            assoc_result = self._update_fip_assoc(",
            "                context, fip, floatingip_obj,",
            "                self._core_plugin.get_port(context.elevated(), fip_port_id))",
            "            floatingip_obj.update()",
            "            floatingip_dict = self._make_floatingip_dict(floatingip_obj)",
            "            if self._is_dns_integration_supported:",
            "                dns_data = self._process_dns_floatingip_update_precommit(",
            "                    context, floatingip_dict)",
            "            if self._is_fip_qos_supported:",
            "                self._process_extra_fip_qos_update(context,",
            "                                                   floatingip_obj,",
            "                                                   fip,",
            "                                                   old_floatingip)",
            "            floatingip_obj = l3_obj.FloatingIP.get_object(",
            "                context, id=floatingip_obj.id)",
            "            floatingip_db = floatingip_obj.db_obj",
            "            registry.notify(resources.FLOATING_IP,",
            "                            events.PRECOMMIT_UPDATE,",
            "                            self,",
            "                            floatingip=floatingip,",
            "                            floatingip_db=floatingip_db,",
            "                            old_floatingip=old_floatingip,",
            "                            **assoc_result)",
            "",
            "        registry.notify(resources.FLOATING_IP,",
            "                        events.AFTER_UPDATE,",
            "                        self._update_fip_assoc,",
            "                        **assoc_result)",
            "",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_update_postcommit(context,",
            "                                                           floatingip_dict,",
            "                                                           dns_data)",
            "        # TODO(lujinluo): Change floatingip_db to floatingip_obj once all",
            "        # codes are migrated to use Floating IP OVO object.",
            "        resource_extend.apply_funcs(l3_apidef.FLOATINGIPS, floatingip_dict,",
            "                                    floatingip_db)",
            "        return old_floatingip, floatingip_dict",
            "",
            "    def _floatingips_to_router_ids(self, floatingips):",
            "        return list(set([floatingip['router_id']",
            "                         for floatingip in floatingips",
            "                         if floatingip['router_id']]))",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_floatingip(self, context, id, floatingip):",
            "        _old_floatingip, floatingip = self._update_floatingip(",
            "            context, id, floatingip)",
            "        return floatingip",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def update_floatingip_status(self, context, floatingip_id, status):",
            "        \"\"\"Update operational status for floating IP in neutron DB.\"\"\"",
            "        return l3_obj.FloatingIP.update_object(",
            "            context, {'status': status}, id=floatingip_id)",
            "",
            "    @registry.receives(resources.PORT, [events.PRECOMMIT_DELETE])",
            "    def _precommit_delete_port_callback(",
            "            self, resource, event, trigger, **kwargs):",
            "        if (kwargs['port']['device_owner'] ==",
            "                constants.DEVICE_OWNER_FLOATINGIP):",
            "            registry.notify(resources.FLOATING_IP, events.PRECOMMIT_DELETE,",
            "                            self, **kwargs)",
            "",
            "    def _delete_floatingip(self, context, id):",
            "        floatingip = self._get_floatingip(context, id)",
            "        floatingip_dict = self._make_floatingip_dict(floatingip)",
            "        if self._is_dns_integration_supported:",
            "            self._process_dns_floatingip_delete(context, floatingip_dict)",
            "        # Foreign key cascade will take care of the removal of the",
            "        # floating IP record once the port is deleted. We can't start",
            "        # a transaction first to remove it ourselves because the delete_port",
            "        # method will yield in its post-commit activities.",
            "        self._core_plugin.delete_port(context.elevated(),",
            "                                      floatingip.floating_port_id,",
            "                                      l3_port_check=False)",
            "        registry.notify(resources.FLOATING_IP, events.AFTER_DELETE,",
            "                        self, **floatingip_dict)",
            "        return floatingip_dict",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_floatingip(self, context, id):",
            "        self._delete_floatingip(context, id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingip(self, context, id, fields=None):",
            "        floatingip = self._get_floatingip(context, id)",
            "        return self._make_floatingip_dict(floatingip, fields)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingips(self, context, filters=None, fields=None,",
            "                        sorts=None, limit=None, marker=None,",
            "                        page_reverse=False):",
            "        pager = base_obj.Pager(sorts, limit, page_reverse, marker)",
            "        filters = filters or {}",
            "        for key, val in API_TO_DB_COLUMN_MAP.items():",
            "            if key in filters:",
            "                filters[val] = filters.pop(key)",
            "        floatingip_objs = l3_obj.FloatingIP.get_objects(",
            "            context, _pager=pager, validate_filters=False, **filters)",
            "        floatingip_dicts = [",
            "            self._make_floatingip_dict(floatingip_obj, fields)",
            "            for floatingip_obj in floatingip_objs",
            "        ]",
            "        return floatingip_dicts",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def delete_disassociated_floatingips(self, context, network_id):",
            "        fip_objs = l3_obj.FloatingIP.get_objects(",
            "            context,",
            "            floating_network_id=network_id, router_id=None, fixed_port_id=None)",
            "",
            "        for fip in fip_objs:",
            "            self.delete_floatingip(context, fip.id)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def get_floatingips_count(self, context, filters=None):",
            "        filters = filters or {}",
            "        return l3_obj.FloatingIP.count(context, **filters)",
            "",
            "    def _router_exists(self, context, router_id):",
            "        try:",
            "            self.get_router(context.elevated(), router_id)",
            "            return True",
            "        except l3_exc.RouterNotFound:",
            "            return False",
            "",
            "    def prevent_l3_port_deletion(self, context, port_id):",
            "        \"\"\"Checks to make sure a port is allowed to be deleted.",
            "",
            "        Raises an exception if this is not the case.  This should be called by",
            "        any plugin when the API requests the deletion of a port, since some",
            "        ports for L3 are not intended to be deleted directly via a DELETE",
            "        to /ports, but rather via other API calls that perform the proper",
            "        deletion checks.",
            "        \"\"\"",
            "        try:",
            "            port = self._core_plugin.get_port(context, port_id)",
            "        except n_exc.PortNotFound:",
            "            # non-existent ports don't need to be protected from deletion",
            "            return",
            "        if port['device_owner'] not in self.router_device_owners:",
            "            return",
            "        # Raise port in use only if the port has IP addresses",
            "        # Otherwise it's a stale port that can be removed",
            "        fixed_ips = port['fixed_ips']",
            "        if not fixed_ips:",
            "            LOG.debug(\"Port %(port_id)s has owner %(port_owner)s, but \"",
            "                      \"no IP address, so it can be deleted\",",
            "                      {'port_id': port['id'],",
            "                       'port_owner': port['device_owner']})",
            "            return",
            "        # NOTE(kevinbenton): we also check to make sure that the",
            "        # router still exists. It's possible for HA router interfaces",
            "        # to remain after the router is deleted if they encounter an",
            "        # error during deletion.",
            "        # Elevated context in case router is owned by another tenant",
            "        if port['device_owner'] == DEVICE_OWNER_FLOATINGIP:",
            "            if not l3_obj.FloatingIP.objects_exist(",
            "                    context, id=port['device_id']):",
            "                LOG.debug(\"Floating IP %(f_id)s corresponding to port \"",
            "                          \"%(port_id)s no longer exists, allowing deletion.\",",
            "                          {'f_id': port['device_id'], 'port_id': port['id']})",
            "                return",
            "        elif not self._router_exists(context, port['device_id']):",
            "            LOG.debug(\"Router %(router_id)s corresponding to port \"",
            "                      \"%(port_id)s  no longer exists, allowing deletion.\",",
            "                      {'router_id': port['device_id'],",
            "                       'port_id': port['id']})",
            "            return",
            "",
            "        reason = _('has device owner %s') % port['device_owner']",
            "        raise n_exc.ServicePortInUse(port_id=port['id'],",
            "                                     reason=reason)",
            "",
            "    @db_api.retry_if_session_inactive()",
            "    def disassociate_floatingips(self, context, port_id, do_notify=True):",
            "        \"\"\"Disassociate all floating IPs linked to specific port.",
            "",
            "        @param port_id: ID of the port to disassociate floating IPs.",
            "        @param do_notify: whether we should notify routers right away.",
            "                          This parameter is ignored.",
            "        @return: set of router-ids that require notification updates",
            "        \"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            floating_ip_objs = l3_obj.FloatingIP.get_objects(",
            "                context, fixed_port_id=port_id)",
            "            router_ids = {fip.router_id for fip in floating_ip_objs}",
            "            old_fips = {fip.id: fip.to_dict() for fip in floating_ip_objs}",
            "            values = {'fixed_port_id': None,",
            "                      'fixed_ip_address': None,",
            "                      'router_id': None}",
            "            l3_obj.FloatingIP.update_objects(",
            "                context, values, fixed_port_id=port_id)",
            "            for fip in floating_ip_objs:",
            "                registry.notify(resources.FLOATING_IP, events.PRECOMMIT_UPDATE,",
            "                                self, context=context,",
            "                                floatingip={l3_apidef.FLOATINGIP: values},",
            "                                floatingip_db=fip,",
            "                                old_floatingip=old_fips[fip.id],",
            "                                router_ids=router_ids)",
            "",
            "        for fip in floating_ip_objs:",
            "            assoc_result = {",
            "                'fixed_ip_address': None,",
            "                'fixed_port_id': None,",
            "                'router_id': None,",
            "                'floating_ip_address': fip.floating_ip_address,",
            "                'floating_network_id': fip.floating_network_id,",
            "                'floating_ip_id': fip.id,",
            "                'context': context,",
            "                'router_ids': router_ids,",
            "            }",
            "            registry.notify(resources.FLOATING_IP, events.AFTER_UPDATE, self,",
            "                            **assoc_result)",
            "        return router_ids",
            "",
            "    def _get_floatingips_by_port_id(self, context, port_id):",
            "        \"\"\"Helper function to retrieve the fips associated with a port_id.\"\"\"",
            "        return l3_obj.FloatingIP.get_objects(context, fixed_port_id=port_id)",
            "",
            "    def _build_routers_list(self, context, routers, gw_ports):",
            "        \"\"\"Subclasses can override this to add extra gateway info\"\"\"",
            "        return routers",
            "",
            "    def _make_router_dict_with_gw_port(self, router, fields):",
            "        result = self._make_router_dict(router, fields)",
            "        if router.get('gw_port'):",
            "            result['gw_port'] = self._core_plugin._make_port_dict(",
            "                router['gw_port'])",
            "        return result",
            "",
            "    def _get_sync_routers(self, context, router_ids=None, active=None):",
            "        \"\"\"Query routers and their gw ports for l3 agent.",
            "",
            "        Query routers with the router_ids. The gateway ports, if any,",
            "        will be queried too.",
            "        l3 agent has an option to deal with only one router id. In addition,",
            "        when we need to notify the agent the data about only one router",
            "        (when modification of router, its interfaces, gw_port and floatingips),",
            "        we will have router_ids.",
            "        @param router_ids: the list of router ids which we want to query.",
            "                           if it is None, all of routers will be queried.",
            "        @return: a list of dicted routers with dicted gw_port populated if any",
            "        \"\"\"",
            "        filters = {'id': router_ids} if router_ids else {}",
            "        if active is not None:",
            "            filters['admin_state_up'] = [active]",
            "        router_dicts = model_query.get_collection(",
            "            context, l3_models.Router, self._make_router_dict_with_gw_port,",
            "            filters=filters)",
            "        if not router_dicts:",
            "            return []",
            "        gw_ports = dict((r['gw_port']['id'], r['gw_port'])",
            "                        for r in router_dicts",
            "                        if r.get('gw_port'))",
            "        return self._build_routers_list(context, router_dicts, gw_ports)",
            "",
            "    def _make_floatingip_dict_with_scope(self, floatingip_obj, scope_id):",
            "        d = self._make_floatingip_dict(floatingip_obj)",
            "        d['fixed_ip_address_scope'] = scope_id",
            "        return d",
            "",
            "    def _get_sync_floating_ips(self, context, router_ids):",
            "        \"\"\"Query floating_ips that relate to list of router_ids with scope.",
            "",
            "        This is different than the regular get_floatingips in that it finds the",
            "        address scope of the fixed IP.  The router needs to know this to",
            "        distinguish it from other scopes.",
            "",
            "        There are a few redirections to go through to discover the address",
            "        scope from the floating ip.",
            "        \"\"\"",
            "        if not router_ids:",
            "            return []",
            "",
            "        return [",
            "            self._make_floatingip_dict_with_scope(*scoped_fip)",
            "            for scoped_fip in l3_obj.FloatingIP.get_scoped_floating_ips(",
            "                context, router_ids)",
            "        ]",
            "",
            "    def _get_sync_interfaces(self, context, router_ids, device_owners=None):",
            "        \"\"\"Query router interfaces that relate to list of router_ids.\"\"\"",
            "        device_owners = device_owners or [DEVICE_OWNER_ROUTER_INTF,",
            "                                          DEVICE_OWNER_HA_REPLICATED_INT]",
            "        if not router_ids:",
            "            return []",
            "        # TODO(lujinluo): Need Port as synthetic field",
            "        objs = l3_obj.RouterPort.get_objects(",
            "            context, router_id=router_ids, port_type=list(device_owners))",
            "",
            "        interfaces = [self._core_plugin._make_port_dict(rp.db_obj.port)",
            "                      for rp in objs]",
            "        return interfaces",
            "",
            "    @staticmethod",
            "    def _each_port_having_fixed_ips(ports):",
            "        for port in ports or []:",
            "            fixed_ips = port.get('fixed_ips', [])",
            "            if not fixed_ips:",
            "                # Skip ports without IPs, which can occur if a subnet",
            "                # attached to a router is deleted",
            "                LOG.info(\"Skipping port %s as no IP is configure on \"",
            "                         \"it\",",
            "                         port['id'])",
            "                continue",
            "            yield port",
            "",
            "    def _get_subnets_by_network_list(self, context, network_ids):",
            "        if not network_ids:",
            "            return {}",
            "",
            "        query = context.session.query(models_v2.Subnet,",
            "                                      models_v2.SubnetPool.address_scope_id)",
            "        query = query.outerjoin(",
            "            models_v2.SubnetPool,",
            "            models_v2.Subnet.subnetpool_id == models_v2.SubnetPool.id)",
            "        query = query.filter(models_v2.Subnet.network_id.in_(network_ids))",
            "",
            "        fields = ['id', 'cidr', 'gateway_ip', 'dns_nameservers',",
            "                  'network_id', 'ipv6_ra_mode', 'subnetpool_id']",
            "",
            "        def make_subnet_dict_with_scope(row):",
            "            subnet_db, address_scope_id = row",
            "            subnet = self._core_plugin._make_subnet_dict(",
            "                subnet_db, fields, context=context)",
            "            subnet['address_scope_id'] = address_scope_id",
            "            return subnet",
            "",
            "        subnets_by_network = dict((id, []) for id in network_ids)",
            "        for subnet in (make_subnet_dict_with_scope(row) for row in query):",
            "            subnets_by_network[subnet['network_id']].append(subnet)",
            "        return subnets_by_network",
            "",
            "    def _get_mtus_by_network_list(self, context, network_ids):",
            "        if not network_ids:",
            "            return {}",
            "        filters = {'id': network_ids}",
            "        fields = ['id', 'mtu']",
            "        networks = self._core_plugin.get_networks(context, filters=filters,",
            "                                                  fields=fields)",
            "        mtus_by_network = dict((network['id'], network.get('mtu', 0))",
            "                               for network in networks)",
            "        return mtus_by_network",
            "",
            "    def _populate_mtu_and_subnets_for_ports(self, context, ports):",
            "        \"\"\"Populate ports with subnets.",
            "",
            "        These ports already have fixed_ips populated.",
            "        \"\"\"",
            "        network_ids = [p['network_id']",
            "                       for p in self._each_port_having_fixed_ips(ports)]",
            "",
            "        mtus_by_network = self._get_mtus_by_network_list(context, network_ids)",
            "        subnets_by_network = self._get_subnets_by_network_list(",
            "            context, network_ids)",
            "",
            "        for port in self._each_port_having_fixed_ips(ports):",
            "",
            "            port['subnets'] = []",
            "            port['extra_subnets'] = []",
            "            port['address_scopes'] = {constants.IP_VERSION_4: None,",
            "                                      constants.IP_VERSION_6: None}",
            "",
            "            scopes = {}",
            "            for subnet in subnets_by_network[port['network_id']]:",
            "                scope = subnet['address_scope_id']",
            "                cidr = netaddr.IPNetwork(subnet['cidr'])",
            "                scopes[cidr.version] = scope",
            "",
            "                # If this subnet is used by the port (has a matching entry",
            "                # in the port's fixed_ips), then add this subnet to the",
            "                # port's subnets list, and populate the fixed_ips entry",
            "                # entry with the subnet's prefix length.",
            "                subnet_info = {'id': subnet['id'],",
            "                               'cidr': subnet['cidr'],",
            "                               'gateway_ip': subnet['gateway_ip'],",
            "                               'dns_nameservers': subnet['dns_nameservers'],",
            "                               'ipv6_ra_mode': subnet['ipv6_ra_mode'],",
            "                               'subnetpool_id': subnet['subnetpool_id']}",
            "                for fixed_ip in port['fixed_ips']:",
            "                    if fixed_ip['subnet_id'] == subnet['id']:",
            "                        port['subnets'].append(subnet_info)",
            "                        prefixlen = cidr.prefixlen",
            "                        fixed_ip['prefixlen'] = prefixlen",
            "                        break",
            "                else:",
            "                    # This subnet is not used by the port.",
            "                    port['extra_subnets'].append(subnet_info)",
            "",
            "            port['address_scopes'].update(scopes)",
            "            port['mtu'] = mtus_by_network.get(port['network_id'], 0)",
            "",
            "    def _process_floating_ips(self, context, routers_dict, floating_ips):",
            "        for floating_ip in floating_ips:",
            "            router = routers_dict.get(floating_ip['router_id'])",
            "            if router:",
            "                router_floatingips = router.get(constants.FLOATINGIP_KEY,",
            "                                                [])",
            "                router_floatingips.append(floating_ip)",
            "                router[constants.FLOATINGIP_KEY] = router_floatingips",
            "",
            "    def _process_interfaces(self, routers_dict, interfaces):",
            "        for interface in interfaces:",
            "            router = routers_dict.get(interface['device_id'])",
            "            if router:",
            "                router_interfaces = router.get(constants.INTERFACE_KEY, [])",
            "                router_interfaces.append(interface)",
            "                router[constants.INTERFACE_KEY] = router_interfaces",
            "",
            "    def _get_router_info_list(self, context, router_ids=None, active=None,",
            "                              device_owners=None):",
            "        \"\"\"Query routers and their related floating_ips, interfaces.\"\"\"",
            "        with context.session.begin(subtransactions=True):",
            "            routers = self._get_sync_routers(context,",
            "                                             router_ids=router_ids,",
            "                                             active=active)",
            "            router_ids = [router['id'] for router in routers]",
            "            interfaces = self._get_sync_interfaces(",
            "                context, router_ids, device_owners)",
            "            floating_ips = self._get_sync_floating_ips(context, router_ids)",
            "            return (routers, interfaces, floating_ips)",
            "",
            "    def get_sync_data(self, context, router_ids=None, active=None):",
            "        routers, interfaces, floating_ips = self._get_router_info_list(",
            "            context, router_ids=router_ids, active=active)",
            "        ports_to_populate = [router['gw_port'] for router in routers",
            "                             if router.get('gw_port')] + interfaces",
            "        self._populate_mtu_and_subnets_for_ports(context, ports_to_populate)",
            "        routers_dict = dict((router['id'], router) for router in routers)",
            "        self._process_floating_ips(context, routers_dict, floating_ips)",
            "        self._process_interfaces(routers_dict, interfaces)",
            "        return list(routers_dict.values())",
            "",
            "",
            "@registry.has_registry_receivers",
            "class L3RpcNotifierMixin(object):",
            "    \"\"\"Mixin class to add rpc notifier attribute to db_base_plugin_v2.\"\"\"",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.PORT, [events.AFTER_DELETE])",
            "    def _notify_routers_callback(resource, event, trigger, **kwargs):",
            "        context = kwargs['context']",
            "        router_ids = kwargs['router_ids']",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin:",
            "            l3plugin.notify_routers_updated(context, router_ids)",
            "        else:",
            "            LOG.debug('%s not configured', plugin_constants.L3)",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.SUBNET, [events.AFTER_UPDATE])",
            "    def _notify_subnet_gateway_ip_update(resource, event, trigger, **kwargs):",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not l3plugin:",
            "            return",
            "        context = kwargs['context']",
            "        orig = kwargs['original_subnet']",
            "        updated = kwargs['subnet']",
            "        if orig['gateway_ip'] == updated['gateway_ip']:",
            "            return",
            "        network_id = updated['network_id']",
            "        subnet_id = updated['id']",
            "        query = context.session.query(models_v2.Port).filter_by(",
            "                    network_id=network_id,",
            "                    device_owner=DEVICE_OWNER_ROUTER_GW)",
            "        query = query.join(models_v2.Port.fixed_ips).filter(",
            "                    models_v2.IPAllocation.subnet_id == subnet_id)",
            "        router_ids = set(port['device_id'] for port in query)",
            "        for router_id in router_ids:",
            "            l3plugin.notify_router_updated(context, router_id)",
            "",
            "    @staticmethod",
            "    @registry.receives(resources.SUBNETPOOL_ADDRESS_SCOPE,",
            "                       [events.AFTER_UPDATE])",
            "    def _notify_subnetpool_address_scope_update(resource, event,",
            "                                                trigger, **kwargs):",
            "        context = kwargs['context']",
            "        subnetpool_id = kwargs['subnetpool_id']",
            "",
            "        router_ids = l3_obj.RouterPort.get_router_ids_by_subnetpool(",
            "            context, subnetpool_id)",
            "",
            "        l3plugin = directory.get_plugin(plugin_constants.L3)",
            "        if l3plugin:",
            "            l3plugin.notify_routers_updated(context, router_ids)",
            "        else:",
            "            LOG.debug('%s not configured', plugin_constants.L3)",
            "",
            "    @property",
            "    def l3_rpc_notifier(self):",
            "        if not hasattr(self, '_l3_rpc_notifier'):",
            "            self._l3_rpc_notifier = l3_rpc_agent_api.L3AgentNotifyAPI()",
            "        return self._l3_rpc_notifier",
            "",
            "    @l3_rpc_notifier.setter",
            "    def l3_rpc_notifier(self, value):",
            "        self._l3_rpc_notifier = value",
            "",
            "    def notify_router_updated(self, context, router_id,",
            "                              operation=None):",
            "        if router_id:",
            "            self.l3_rpc_notifier.routers_updated(",
            "                context, [router_id], operation)",
            "",
            "    def notify_routers_updated(self, context, router_ids,",
            "                               operation=None, data=None):",
            "        if router_ids:",
            "            self.l3_rpc_notifier.routers_updated(",
            "                context, router_ids, operation, data)",
            "",
            "    def notify_router_deleted(self, context, router_id):",
            "        self.l3_rpc_notifier.router_deleted(context, router_id)",
            "",
            "",
            "class L3_NAT_db_mixin(L3_NAT_dbonly_mixin, L3RpcNotifierMixin):",
            "    \"\"\"Mixin class to add rpc notifier methods to db_base_plugin_v2.\"\"\"",
            "",
            "    def create_router(self, context, router):",
            "        router_dict = super(L3_NAT_db_mixin, self).create_router(context,",
            "                                                                 router)",
            "        if router_dict.get('external_gateway_info'):",
            "            self.notify_router_updated(context, router_dict['id'], None)",
            "        return router_dict",
            "",
            "    def update_router(self, context, id, router):",
            "        router_dict = super(L3_NAT_db_mixin, self).update_router(context,",
            "                                                                 id, router)",
            "        self.notify_router_updated(context, router_dict['id'], None)",
            "        return router_dict",
            "",
            "    def delete_router(self, context, id):",
            "        super(L3_NAT_db_mixin, self).delete_router(context, id)",
            "        self.notify_router_deleted(context, id)",
            "",
            "    def notify_router_interface_action(",
            "            self, context, router_interface_info, action):",
            "        l3_method = '%s_router_interface' % action",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, [router_interface_info['id']], l3_method,",
            "            {'subnet_id': router_interface_info['subnet_id']})",
            "",
            "        mapping = {'add': 'create', 'remove': 'delete'}",
            "        notifier = n_rpc.get_notifier('network')",
            "        router_event = 'router.interface.%s' % mapping[action]",
            "        notifier.info(context, router_event,",
            "                      {'router_interface': router_interface_info})",
            "",
            "    def add_router_interface(self, context, router_id, interface_info=None):",
            "        router_interface_info = super(",
            "            L3_NAT_db_mixin, self).add_router_interface(",
            "                context, router_id, interface_info)",
            "        self.notify_router_interface_action(",
            "            context, router_interface_info, 'add')",
            "        return router_interface_info",
            "",
            "    def remove_router_interface(self, context, router_id, interface_info):",
            "        router_interface_info = super(",
            "            L3_NAT_db_mixin, self).remove_router_interface(",
            "                context, router_id, interface_info)",
            "        self.notify_router_interface_action(",
            "            context, router_interface_info, 'remove')",
            "        return router_interface_info",
            "",
            "    def create_floatingip(self, context, floatingip,",
            "            initial_status=constants.FLOATINGIP_STATUS_ACTIVE):",
            "        floatingip_dict = super(L3_NAT_db_mixin, self).create_floatingip(",
            "            context, floatingip, initial_status)",
            "        router_id = floatingip_dict['router_id']",
            "        self.notify_router_updated(context, router_id, 'create_floatingip')",
            "        return floatingip_dict",
            "",
            "    def update_floatingip(self, context, id, floatingip):",
            "        old_floatingip, floatingip = self._update_floatingip(",
            "            context, id, floatingip)",
            "        router_ids = self._floatingips_to_router_ids(",
            "            [old_floatingip, floatingip])",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, router_ids, 'update_floatingip', {})",
            "        return floatingip",
            "",
            "    def delete_floatingip(self, context, id):",
            "        floating_ip = self._delete_floatingip(context, id)",
            "        self.notify_router_updated(context, floating_ip['router_id'],",
            "                                   'delete_floatingip')",
            "",
            "    def disassociate_floatingips(self, context, port_id, do_notify=True):",
            "        \"\"\"Disassociate all floating IPs linked to specific port.",
            "",
            "        @param port_id: ID of the port to disassociate floating IPs.",
            "        @param do_notify: whether we should notify routers right away.",
            "        @return: set of router-ids that require notification updates",
            "                 if do_notify is False, otherwise None.",
            "        \"\"\"",
            "        router_ids = super(L3_NAT_db_mixin, self).disassociate_floatingips(",
            "            context, port_id, do_notify)",
            "        if do_notify:",
            "            self.notify_routers_updated(context, router_ids)",
            "            # since caller assumes that we handled notifications on its",
            "            # behalf, return nothing",
            "            return",
            "",
            "        return router_ids",
            "",
            "    def notify_routers_updated(self, context, router_ids):",
            "        super(L3_NAT_db_mixin, self).notify_routers_updated(",
            "            context, list(router_ids), 'disassociate_floatingips', {})",
            "",
            "    def _migrate_router_ports(",
            "        self, context, router_db, old_owner, new_owner):",
            "        \"\"\"Update the model to support the dvr case of a router.\"\"\"",
            "        for rp in router_db.attached_ports:",
            "            if rp.port_type == old_owner:",
            "                rp.port_type = new_owner",
            "                rp.port.device_owner = new_owner"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.db.l3_db.L3_NAT_dbonly_mixin._add_interface_by_port",
            "neutron.db.l3_db.L3_NAT_dbonly_mixin.add_router_interface",
            "neutron.db.l3_db.L3_NAT_dbonly_mixin._check_for_dup_router_subnets.network_id",
            "neutron.db.l3_db.L3_NAT_dbonly_mixin._add_interface_by_subnet.port_data",
            "neutron.db.l3_db.L3_NAT_dbonly_mixin._add_interface_by_subnet.fixed_ip",
            "neutron.db.l3_db.L3_NAT_dbonly_mixin.self"
        ]
    },
    "neutron/tests/unit/extensions/test_l3.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1265,
                "afterPatchRowNumber": 1265,
                "PatchRowcode": "                                                   expected_code=err_code,"
            },
            "1": {
                "beforePatchRowNumber": 1266,
                "afterPatchRowNumber": 1266,
                "PatchRowcode": "                                                   tenant_id='bad_tenant')"
            },
            "2": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": 1267,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1268,
                "PatchRowcode": "+    def test_router_add_interface_by_subnet_other_tenant_subnet_returns_400("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1269,
                "PatchRowcode": "+            self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "+        router_tenant_id = _uuid()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "+        with self.router(tenant_id=router_tenant_id, set_context=True) as r:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "+            with self.network(shared=True) as n:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "+                with self.subnet(network=n) as s:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "+                    err_code = exc.HTTPBadRequest.code"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "+                    self._router_interface_action('add',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "+                                                  r['router']['id'],"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "+                                                  s['subnet']['id'],"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "+                                                  None,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "+                                                  expected_code=err_code,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "+                                                  tenant_id=router_tenant_id)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "+    def _test_router_add_interface_by_port_allocation_pool("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "+            self, out_of_pool=False, router_action_as_admin=False,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "+            expected_code=exc.HTTPOk.code):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1285,
                "PatchRowcode": "+        router_tenant_id = _uuid()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "+        with self.router(tenant_id=router_tenant_id, set_context=True) as r:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1287,
                "PatchRowcode": "+            with self.network(shared=True) as n:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1288,
                "PatchRowcode": "+                with self.subnet(network=n) as s1, ("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1289,
                "PatchRowcode": "+                     self.subnet(network=n, cidr='fd00::/64',"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1290,
                "PatchRowcode": "+                                 ip_version=6)) as s2, ("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1291,
                "PatchRowcode": "+                     self.subnet(network=n, cidr='fd01::/64',"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1292,
                "PatchRowcode": "+                                 ip_version=6)) as s3:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1293,
                "PatchRowcode": "+                    fixed_ips = [{'subnet_id': s1['subnet']['id']},"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1294,
                "PatchRowcode": "+                                 {'subnet_id': s2['subnet']['id']},"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1295,
                "PatchRowcode": "+                                 {'subnet_id': s3['subnet']['id']}]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1296,
                "PatchRowcode": "+                    if out_of_pool:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1297,
                "PatchRowcode": "+                        fixed_ips[1] = {'subnet_id': s2['subnet']['id'],"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1298,
                "PatchRowcode": "+                                        'ip_address':"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1299,
                "PatchRowcode": "+                                            s2['subnet']['gateway_ip']}"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1300,
                "PatchRowcode": "+                    with self.port(subnet=s1, fixed_ips=fixed_ips,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1301,
                "PatchRowcode": "+                                   tenant_id=router_tenant_id,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1302,
                "PatchRowcode": "+                                   set_context=True) as p:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1303,
                "PatchRowcode": "+                        kwargs = {'expected_code': expected_code}"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1304,
                "PatchRowcode": "+                        if not router_action_as_admin:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1305,
                "PatchRowcode": "+                            kwargs['tenant_id'] = router_tenant_id"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1306,
                "PatchRowcode": "+                        self._router_interface_action("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1307,
                "PatchRowcode": "+                            'add', r['router']['id'], None, p['port']['id'],"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1308,
                "PatchRowcode": "+                            **kwargs)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1309,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1310,
                "PatchRowcode": "+    def test_router_add_interface_by_port_other_tenant_address_in_pool("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1311,
                "PatchRowcode": "+            self):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1312,
                "PatchRowcode": "+        self._test_router_add_interface_by_port_allocation_pool()"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1313,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1314,
                "PatchRowcode": "+    def test_router_add_interface_by_port_other_tenant_address_out_of_pool("
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1315,
                "PatchRowcode": "+            self):"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1316,
                "PatchRowcode": "+        self._test_router_add_interface_by_port_allocation_pool("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1317,
                "PatchRowcode": "+            out_of_pool=True, expected_code=exc.HTTPBadRequest.code)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1318,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1319,
                "PatchRowcode": "+    def test_router_add_interface_by_port_admin_address_out_of_pool("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1320,
                "PatchRowcode": "+            self):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1321,
                "PatchRowcode": "+        self._test_router_add_interface_by_port_allocation_pool("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1322,
                "PatchRowcode": "+            out_of_pool=True, router_action_as_admin=True)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1323,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": 1324,
                "PatchRowcode": "     def test_router_add_interface_subnet_with_port_from_other_tenant(self):"
            },
            "60": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": 1325,
                "PatchRowcode": "         tenant_id = _uuid()"
            },
            "61": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": 1326,
                "PatchRowcode": "         other_tenant_id = _uuid()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 VMware, Inc.",
            "# All rights reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "#",
            "",
            "import contextlib",
            "import copy",
            "",
            "import mock",
            "import netaddr",
            "from neutron_lib.api.definitions import external_net as extnet_apidef",
            "from neutron_lib.api.definitions import l3 as l3_apidef",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.callbacks import events",
            "from neutron_lib.callbacks import exceptions",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources",
            "from neutron_lib import constants as lib_constants",
            "from neutron_lib import context",
            "from neutron_lib import exceptions as n_exc",
            "from neutron_lib.exceptions import l3 as l3_exc",
            "from neutron_lib.plugins import constants as plugin_constants",
            "from neutron_lib.plugins import directory",
            "from oslo_config import cfg",
            "from oslo_utils import importutils",
            "from oslo_utils import uuidutils",
            "from sqlalchemy import orm",
            "import testtools",
            "from webob import exc",
            "",
            "from neutron.api.rpc.agentnotifiers import l3_rpc_agent_api",
            "from neutron.api.rpc.handlers import l3_rpc",
            "from neutron.db import _resource_extend as resource_extend",
            "from neutron.db import common_db_mixin",
            "from neutron.db import db_base_plugin_v2",
            "from neutron.db import dns_db",
            "from neutron.db import external_net_db",
            "from neutron.db import l3_agentschedulers_db",
            "from neutron.db import l3_attrs_db",
            "from neutron.db import l3_db",
            "from neutron.db import l3_dvr_db",
            "from neutron.db import l3_dvrscheduler_db",
            "from neutron.db import l3_hamode_db",
            "from neutron.db.models import l3 as l3_models",
            "from neutron.db import models_v2",
            "from neutron.extensions import l3",
            "from neutron.services.revisions import revision_plugin",
            "from neutron.tests import base",
            "from neutron.tests.common import helpers",
            "from neutron.tests import fake_notifier",
            "from neutron.tests.unit.api import test_extensions",
            "from neutron.tests.unit.api.v2 import test_base",
            "from neutron.tests.unit.db import test_db_base_plugin_v2",
            "from neutron.tests.unit.extensions import base as test_extensions_base",
            "from neutron.tests.unit.extensions import test_agent",
            "from neutron.tests.unit.plugins.ml2 import base as ml2_base",
            "from neutron.tests.unit import testlib_api",
            "",
            "",
            "_uuid = uuidutils.generate_uuid",
            "_get_path = test_base._get_path",
            "",
            "",
            "DEVICE_OWNER_COMPUTE = lib_constants.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "",
            "class L3TestExtensionManager(object):",
            "",
            "    def get_resources(self):",
            "        return l3.L3.get_resources()",
            "",
            "    def get_actions(self):",
            "        return []",
            "",
            "    def get_request_extensions(self):",
            "        return []",
            "",
            "",
            "class L3NatExtensionTestCase(test_extensions_base.ExtensionTestCase):",
            "    fmt = 'json'",
            "",
            "    def setUp(self):",
            "        super(L3NatExtensionTestCase, self).setUp()",
            "        self.setup_extension(",
            "            'neutron.services.l3_router.l3_router_plugin.L3RouterPlugin',",
            "            plugin_constants.L3, l3.L3, '', allow_pagination=True,",
            "            allow_sorting=True, supported_extension_aliases=['router'],",
            "            use_quota=True)",
            "",
            "    def test_router_create(self):",
            "        router_id = _uuid()",
            "        tenant_id = _uuid()",
            "        data = {'router': {'name': 'router1', 'admin_state_up': True,",
            "                           'tenant_id': tenant_id, 'project_id': tenant_id,",
            "                           'external_gateway_info': None}}",
            "        return_value = copy.deepcopy(data['router'])",
            "        return_value.update({'status': \"ACTIVE\", 'id': router_id})",
            "",
            "        instance = self.plugin.return_value",
            "        instance.create_router.return_value = return_value",
            "        instance.get_routers_count.return_value = 0",
            "        res = self.api.post(_get_path('routers', fmt=self.fmt),",
            "                            self.serialize(data),",
            "                            content_type='application/%s' % self.fmt)",
            "        instance.create_router.assert_called_with(mock.ANY,",
            "                                                  router=data)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertTrue(router['admin_state_up'])",
            "",
            "    def test_router_list(self):",
            "        router_id = _uuid()",
            "        return_value = [{'name': 'router1', 'admin_state_up': True,",
            "                         'tenant_id': _uuid(), 'id': router_id}]",
            "",
            "        instance = self.plugin.return_value",
            "        instance.get_routers.return_value = return_value",
            "",
            "        res = self.api.get(_get_path('routers', fmt=self.fmt))",
            "",
            "        instance.get_routers.assert_called_with(mock.ANY, fields=mock.ANY,",
            "                                                filters=mock.ANY,",
            "                                                sorts=mock.ANY,",
            "                                                limit=mock.ANY,",
            "                                                marker=mock.ANY,",
            "                                                page_reverse=mock.ANY)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('routers', res)",
            "        self.assertEqual(1, len(res['routers']))",
            "        self.assertEqual(router_id, res['routers'][0]['id'])",
            "",
            "    def test_router_update(self):",
            "        router_id = _uuid()",
            "        update_data = {'router': {'admin_state_up': False}}",
            "        return_value = {'name': 'router1', 'admin_state_up': False,",
            "                        'tenant_id': _uuid(),",
            "                        'status': \"ACTIVE\", 'id': router_id}",
            "",
            "        instance = self.plugin.return_value",
            "        instance.update_router.return_value = return_value",
            "",
            "        res = self.api.put(_get_path('routers', id=router_id,",
            "                                     fmt=self.fmt),",
            "                           self.serialize(update_data))",
            "",
            "        instance.update_router.assert_called_with(mock.ANY, router_id,",
            "                                                  router=update_data)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertFalse(router['admin_state_up'])",
            "",
            "    def test_router_get(self):",
            "        router_id = _uuid()",
            "        return_value = {'name': 'router1', 'admin_state_up': False,",
            "                        'tenant_id': _uuid(),",
            "                        'status': \"ACTIVE\", 'id': router_id}",
            "",
            "        instance = self.plugin.return_value",
            "        instance.get_router.return_value = return_value",
            "",
            "        res = self.api.get(_get_path('routers', id=router_id,",
            "                                     fmt=self.fmt))",
            "",
            "        instance.get_router.assert_called_with(mock.ANY, router_id,",
            "                                               fields=mock.ANY)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertFalse(router['admin_state_up'])",
            "",
            "    def test_router_delete(self):",
            "        router_id = _uuid()",
            "",
            "        res = self.api.delete(_get_path('routers', id=router_id))",
            "",
            "        instance = self.plugin.return_value",
            "        instance.delete_router.assert_called_with(mock.ANY, router_id)",
            "        self.assertEqual(exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_router_add_interface(self):",
            "        router_id = _uuid()",
            "        subnet_id = _uuid()",
            "        port_id = _uuid()",
            "",
            "        interface_data = {'subnet_id': subnet_id}",
            "        return_value = copy.deepcopy(interface_data)",
            "        return_value['port_id'] = port_id",
            "",
            "        instance = self.plugin.return_value",
            "        instance.add_router_interface.return_value = return_value",
            "",
            "        path = _get_path('routers', id=router_id,",
            "                         action=\"add_router_interface\",",
            "                         fmt=self.fmt)",
            "        res = self.api.put(path, self.serialize(interface_data))",
            "",
            "        instance.add_router_interface.assert_called_with(mock.ANY, router_id,",
            "                                                         interface_data)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('port_id', res)",
            "        self.assertEqual(port_id, res['port_id'])",
            "        self.assertEqual(subnet_id, res['subnet_id'])",
            "",
            "    def test_router_add_interface_empty_body(self):",
            "        router_id = _uuid()",
            "        instance = self.plugin.return_value",
            "",
            "        path = _get_path('routers', id=router_id,",
            "                         action=\"add_router_interface\",",
            "                         fmt=self.fmt)",
            "        res = self.api.put(path)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        instance.add_router_interface.assert_called_with(mock.ANY, router_id)",
            "",
            "",
            "# This base plugin class is for tests.",
            "class TestL3NatBasePlugin(db_base_plugin_v2.NeutronDbPluginV2,",
            "                          external_net_db.External_net_db_mixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    def create_network(self, context, network):",
            "        session = context.session",
            "        with session.begin(subtransactions=True):",
            "            net = super(TestL3NatBasePlugin, self).create_network(context,",
            "                                                                  network)",
            "            self._process_l3_create(context, net, network['network'])",
            "        return net",
            "",
            "    def update_network(self, context, id, network):",
            "",
            "        session = context.session",
            "        with session.begin(subtransactions=True):",
            "            net = super(TestL3NatBasePlugin, self).update_network(context, id,",
            "                                                                  network)",
            "            self._process_l3_update(context, net, network['network'])",
            "        return net",
            "",
            "    def delete_port(self, context, id, l3_port_check=True):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if plugin:",
            "            if l3_port_check:",
            "                plugin.prevent_l3_port_deletion(context, id)",
            "            plugin.disassociate_floatingips(context, id)",
            "        return super(TestL3NatBasePlugin, self).delete_port(context, id)",
            "",
            "",
            "# This plugin class is for tests with plugin that integrates L3.",
            "class TestL3NatIntPlugin(TestL3NatBasePlugin,",
            "                         l3_db.L3_NAT_db_mixin, dns_db.DNSDbMixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"external-net\", \"router\", \"dns-integration\"]",
            "",
            "",
            "# This plugin class is for tests with plugin that integrates L3 and L3 agent",
            "# scheduling.",
            "class TestL3NatIntAgentSchedulingPlugin(TestL3NatIntPlugin,",
            "                                        l3_agentschedulers_db.",
            "                                        L3AgentSchedulerDbMixin,",
            "                                        l3_hamode_db.L3_HA_NAT_db_mixin):",
            "",
            "    supported_extension_aliases = [\"external-net\", \"router\",",
            "                                   \"l3_agent_scheduler\"]",
            "    router_scheduler = importutils.import_object(",
            "        cfg.CONF.router_scheduler_driver)",
            "",
            "",
            "# This plugin class is for tests with plugin not supporting L3.",
            "class TestNoL3NatPlugin(TestL3NatBasePlugin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"external-net\"]",
            "",
            "",
            "# A L3 routing service plugin class for tests with plugins that",
            "# delegate away L3 routing functionality",
            "class TestL3NatServicePlugin(common_db_mixin.CommonDbMixin,",
            "                             l3_dvr_db.L3_NAT_with_dvr_db_mixin,",
            "                             l3_db.L3_NAT_db_mixin, dns_db.DNSDbMixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"router\", \"dns-integration\"]",
            "",
            "    @classmethod",
            "    def get_plugin_type(cls):",
            "        return plugin_constants.L3",
            "",
            "    def get_plugin_description(self):",
            "        return \"L3 Routing Service Plugin for testing\"",
            "",
            "",
            "# A L3 routing with L3 agent scheduling service plugin class for tests with",
            "# plugins that delegate away L3 routing functionality",
            "class TestL3NatAgentSchedulingServicePlugin(TestL3NatServicePlugin,",
            "                                            l3_dvrscheduler_db.",
            "                                            L3_DVRsch_db_mixin,",
            "                                            l3_hamode_db.L3_HA_NAT_db_mixin):",
            "",
            "    supported_extension_aliases = [\"router\", \"l3_agent_scheduler\"]",
            "",
            "    def __init__(self):",
            "        super(TestL3NatAgentSchedulingServicePlugin, self).__init__()",
            "        self.router_scheduler = importutils.import_object(",
            "            cfg.CONF.router_scheduler_driver)",
            "        self.agent_notifiers.update(",
            "            {lib_constants.AGENT_TYPE_L3: l3_rpc_agent_api.L3AgentNotifyAPI()})",
            "",
            "",
            "class L3NatTestCaseMixin(object):",
            "",
            "    def _create_router(self, fmt, tenant_id, name=None,",
            "                       admin_state_up=None, set_context=False,",
            "                       arg_list=None, **kwargs):",
            "        tenant_id = tenant_id or _uuid()",
            "        data = {'router': {'tenant_id': tenant_id}}",
            "        if name:",
            "            data['router']['name'] = name",
            "        if admin_state_up is not None:",
            "            data['router']['admin_state_up'] = admin_state_up",
            "        flavor_id = kwargs.get('flavor_id', None)",
            "        if flavor_id:",
            "            data['router']['flavor_id'] = flavor_id",
            "        for arg in (('admin_state_up', 'tenant_id',",
            "                     'availability_zone_hints') +",
            "                    (arg_list or ())):",
            "            # Arg must be present and not empty",
            "            if arg in kwargs:",
            "                data['router'][arg] = kwargs[arg]",
            "        router_req = self.new_create_request('routers', data, fmt)",
            "        if set_context and tenant_id:",
            "            # create a specific auth context for this request",
            "            router_req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "",
            "        return router_req.get_response(self.ext_api)",
            "",
            "    def _make_router(self, fmt, tenant_id, name=None, admin_state_up=None,",
            "                     external_gateway_info=None, set_context=False,",
            "                     arg_list=None, **kwargs):",
            "        if external_gateway_info:",
            "            arg_list = ('external_gateway_info', ) + (arg_list or ())",
            "        res = self._create_router(fmt, tenant_id, name,",
            "                                  admin_state_up, set_context,",
            "                                  arg_list=arg_list,",
            "                                  external_gateway_info=external_gateway_info,",
            "                                  **kwargs)",
            "        return self.deserialize(fmt, res)",
            "",
            "    def _add_external_gateway_to_router(self, router_id, network_id,",
            "                                        expected_code=exc.HTTPOk.code,",
            "                                        neutron_context=None, ext_ips=None):",
            "        ext_ips = ext_ips or []",
            "        body = {'router':",
            "                {'external_gateway_info': {'network_id': network_id}}}",
            "        if ext_ips:",
            "            body['router']['external_gateway_info'][",
            "                'external_fixed_ips'] = ext_ips",
            "        return self._update('routers', router_id, body,",
            "                            expected_code=expected_code,",
            "                            neutron_context=neutron_context)",
            "",
            "    def _remove_external_gateway_from_router(self, router_id, network_id,",
            "                                             expected_code=exc.HTTPOk.code,",
            "                                             external_gw_info=None):",
            "        return self._update('routers', router_id,",
            "                            {'router': {'external_gateway_info':",
            "                                        external_gw_info}},",
            "                            expected_code=expected_code)",
            "",
            "    def _router_interface_action(self, action, router_id, subnet_id, port_id,",
            "                                 expected_code=exc.HTTPOk.code,",
            "                                 expected_body=None,",
            "                                 tenant_id=None,",
            "                                 msg=None):",
            "        interface_data = {}",
            "        if subnet_id is not None:",
            "            interface_data.update({'subnet_id': subnet_id})",
            "        if port_id is not None:",
            "            interface_data.update({'port_id': port_id})",
            "",
            "        req = self.new_action_request('routers', interface_data, router_id,",
            "                                      \"%s_router_interface\" % action)",
            "        # if tenant_id was specified, create a tenant context for this request",
            "        if tenant_id:",
            "            req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "        res = req.get_response(self.ext_api)",
            "        self.assertEqual(expected_code, res.status_int, msg)",
            "        response = self.deserialize(self.fmt, res)",
            "        if expected_body:",
            "            self.assertEqual(expected_body, response, msg)",
            "        return response",
            "",
            "    @contextlib.contextmanager",
            "    def router(self, name='router1', admin_state_up=True,",
            "               fmt=None, tenant_id=None,",
            "               external_gateway_info=None, set_context=False,",
            "               **kwargs):",
            "        router = self._make_router(fmt or self.fmt, tenant_id, name,",
            "                                   admin_state_up, external_gateway_info,",
            "                                   set_context, **kwargs)",
            "        yield router",
            "",
            "    def _set_net_external(self, net_id):",
            "        self._update('networks', net_id,",
            "                     {'network': {extnet_apidef.EXTERNAL: True}})",
            "",
            "    def _create_floatingip(self, fmt, network_id, port_id=None,",
            "                           fixed_ip=None, set_context=False,",
            "                           floating_ip=None, subnet_id=None,",
            "                           tenant_id=None, **kwargs):",
            "        tenant_id = tenant_id or self._tenant_id",
            "        data = {'floatingip': {'floating_network_id': network_id,",
            "                               'tenant_id': tenant_id}}",
            "        if port_id:",
            "            data['floatingip']['port_id'] = port_id",
            "            if fixed_ip:",
            "                data['floatingip']['fixed_ip_address'] = fixed_ip",
            "",
            "        if floating_ip:",
            "            data['floatingip']['floating_ip_address'] = floating_ip",
            "",
            "        if subnet_id:",
            "            data['floatingip']['subnet_id'] = subnet_id",
            "",
            "        data['floatingip'].update(kwargs)",
            "",
            "        floatingip_req = self.new_create_request('floatingips', data, fmt)",
            "        if set_context and tenant_id:",
            "            # create a specific auth context for this request",
            "            floatingip_req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "        return floatingip_req.get_response(self.ext_api)",
            "",
            "    def _make_floatingip(self, fmt, network_id, port_id=None,",
            "                         fixed_ip=None, set_context=False, tenant_id=None,",
            "                         floating_ip=None, http_status=exc.HTTPCreated.code,",
            "                         **kwargs):",
            "        res = self._create_floatingip(fmt, network_id, port_id,",
            "                                      fixed_ip, set_context, floating_ip,",
            "                                      tenant_id=tenant_id, **kwargs)",
            "        self.assertEqual(http_status, res.status_int)",
            "        return self.deserialize(fmt, res)",
            "",
            "    def _validate_floating_ip(self, fip):",
            "        body = self._list('floatingips')",
            "        self.assertEqual(1, len(body['floatingips']))",
            "        self.assertEqual(body['floatingips'][0]['id'],",
            "                         fip['floatingip']['id'])",
            "",
            "        body = self._show('floatingips', fip['floatingip']['id'])",
            "        self.assertEqual(body['floatingip']['id'],",
            "                         fip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_with_assoc(self, port_id=None, fmt=None, fixed_ip=None,",
            "                              public_cidr='11.0.0.0/24', set_context=False,",
            "                              tenant_id=None, flavor_id=None, **kwargs):",
            "        with self.subnet(cidr=public_cidr,",
            "                         set_context=set_context,",
            "                         tenant_id=tenant_id) as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            args_list = {'set_context': set_context,",
            "                         'tenant_id': tenant_id}",
            "            if flavor_id:",
            "                args_list['flavor_id'] = flavor_id",
            "            private_port = None",
            "            if port_id:",
            "                private_port = self._show('ports', port_id)",
            "            with test_db_base_plugin_v2.optional_ctx(",
            "                    private_port, self.port,",
            "                    set_context=set_context,",
            "                    tenant_id=tenant_id) as private_port:",
            "                with self.router(**args_list) as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    floatingip = None",
            "",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    floatingip = self._make_floatingip(",
            "                        fmt or self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'],",
            "                        fixed_ip=fixed_ip,",
            "                        tenant_id=tenant_id,",
            "                        set_context=set_context,",
            "                        **kwargs)",
            "                    yield floatingip",
            "",
            "                    if floatingip:",
            "                        self._delete('floatingips',",
            "                                     floatingip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_no_assoc_with_public_sub(",
            "        self, private_sub, fmt=None, set_context=False,",
            "        public_sub=None, flavor_id=None, **kwargs):",
            "        self._set_net_external(public_sub['subnet']['network_id'])",
            "        args_list = {}",
            "        if flavor_id:",
            "            # NOTE(manjeets) Flavor id None is not accepted",
            "            # and return Flavor None not found error. So for",
            "            # neutron testing this argument should not be passed",
            "            # at all to router.",
            "            args_list['flavor_id'] = flavor_id",
            "        with self.router(**args_list) as r:",
            "            floatingip = None",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                public_sub['subnet']['network_id'])",
            "            self._router_interface_action('add', r['router']['id'],",
            "                                          private_sub['subnet']['id'],",
            "                                          None)",
            "",
            "            floatingip = self._make_floatingip(",
            "                fmt or self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                set_context=set_context,",
            "                **kwargs)",
            "            yield floatingip, r",
            "",
            "            if floatingip:",
            "                self._delete('floatingips',",
            "                             floatingip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_no_assoc(self, private_sub, fmt=None,",
            "                            set_context=False, flavor_id=None, **kwargs):",
            "        with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "            with self.floatingip_no_assoc_with_public_sub(",
            "                private_sub, fmt, set_context, public_sub,",
            "                flavor_id, **kwargs) as (f, r):",
            "                # Yield only the floating ip object",
            "                yield f",
            "",
            "",
            "class ExtraAttributesMixinTestCase(testlib_api.SqlTestCase):",
            "",
            "    def setUp(self):",
            "        super(ExtraAttributesMixinTestCase, self).setUp()",
            "        self.mixin = l3_attrs_db.ExtraAttributesMixin()",
            "        directory.add_plugin(plugin_constants.L3, self.mixin)",
            "        self.ctx = context.get_admin_context()",
            "        self.router = l3_models.Router()",
            "        with self.ctx.session.begin():",
            "            self.ctx.session.add(self.router)",
            "",
            "    def _get_default_api_values(self):",
            "        return {k: v.get('transform_from_db', lambda x: x)(v['default'])",
            "                for k, v in l3_attrs_db.get_attr_info().items()}",
            "",
            "    def test_set_extra_attr_key_bad(self):",
            "        with testtools.ExpectedException(RuntimeError):",
            "            with self.ctx.session.begin():",
            "                self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                                'bad', 'value')",
            "",
            "    def test_set_attrs_and_extend_no_transaction(self):",
            "        with testtools.ExpectedException(RuntimeError):",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'ha_vr_id', 99)",
            "",
            "    def test__extend_extra_router_dict_defaults(self):",
            "        rdict = {}",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(self._get_default_api_values(), rdict)",
            "",
            "    def test_set_attrs_and_extend(self):",
            "        with self.ctx.session.begin():",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'ha_vr_id', 99)",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'availability_zone_hints',",
            "                                            ['x', 'y', 'z'])",
            "        expected = self._get_default_api_values()",
            "        expected.update({'ha_vr_id': 99,",
            "                         'availability_zone_hints': ['x', 'y', 'z']})",
            "        rdict = {}",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(expected, rdict)",
            "        with self.ctx.session.begin():",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'availability_zone_hints',",
            "                                            ['z', 'y', 'z'])",
            "        expected['availability_zone_hints'] = ['z', 'y', 'z']",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(expected, rdict)",
            "",
            "",
            "class L3NatTestCaseBase(L3NatTestCaseMixin):",
            "",
            "    def test_router_create(self):",
            "        name = 'router1'",
            "        tenant_id = _uuid()",
            "        expected_value = [('name', name), ('tenant_id', tenant_id),",
            "                          ('admin_state_up', True), ('status', 'ACTIVE'),",
            "                          ('external_gateway_info', None)]",
            "        with self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id) as router:",
            "            for k, v in expected_value:",
            "                self.assertEqual(router['router'][k], v)",
            "",
            "    def test_router_create_call_extensions(self):",
            "        self.extension_called = False",
            "",
            "        def _extend_router_dict_test_attr(*args, **kwargs):",
            "            self.extension_called = True",
            "",
            "        resource_extend.register_funcs(",
            "            l3_apidef.ROUTERS, [_extend_router_dict_test_attr])",
            "        self.assertFalse(self.extension_called)",
            "        with self.router():",
            "            self.assertTrue(self.extension_called)",
            "",
            "    def test_router_create_with_gwinfo(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            data = {'router': {'tenant_id': _uuid()}}",
            "            data['router']['name'] = 'router1'",
            "            data['router']['external_gateway_info'] = {",
            "                'network_id': s['subnet']['network_id']}",
            "            router_req = self.new_create_request('routers', data, self.fmt)",
            "            res = router_req.get_response(self.ext_api)",
            "            router = self.deserialize(self.fmt, res)",
            "            self.assertEqual(",
            "                s['subnet']['network_id'],",
            "                router['router']['external_gateway_info']['network_id'])",
            "",
            "    def test_router_create_with_gwinfo_ext_ip(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            ext_info = {",
            "                'network_id': s['subnet']['network_id'],",
            "                'external_fixed_ips': [{'ip_address': '10.0.0.99'}]",
            "            }",
            "            res = self._create_router(",
            "                self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                external_gateway_info=ext_info",
            "            )",
            "            router = self.deserialize(self.fmt, res)",
            "            self.assertEqual(",
            "                [{'ip_address': '10.0.0.99', 'subnet_id': s['subnet']['id']}],",
            "                router['router']['external_gateway_info'][",
            "                    'external_fixed_ips'])",
            "",
            "    def test_router_create_with_gwinfo_ext_ip_subnet(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as v1,\\",
            "                    self.subnet(network=n, cidr='1.0.0.0/24') as v2,\\",
            "                    self.subnet(network=n, cidr='2.0.0.0/24') as v3:",
            "                subnets = (v1, v2, v3)",
            "                self._set_net_external(n['network']['id'])",
            "                for s in subnets:",
            "                    ext_info = {",
            "                        'network_id': n['network']['id'],",
            "                        'external_fixed_ips': [",
            "                            {'subnet_id': s['subnet']['id']}]",
            "                    }",
            "                    res = self._create_router(",
            "                        self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                        external_gateway_info=ext_info",
            "                    )",
            "                    router = self.deserialize(self.fmt, res)",
            "                    ext_ips = router['router']['external_gateway_info'][",
            "                        'external_fixed_ips']",
            "",
            "                    self.assertEqual(",
            "                        [{'subnet_id': s['subnet']['id'],",
            "                          'ip_address': mock.ANY}], ext_ips)",
            "",
            "    def test_router_create_with_gwinfo_ext_ip_non_admin(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            ext_info = {",
            "                'network_id': s['subnet']['network_id'],",
            "                'external_fixed_ips': [{'ip_address': '10.0.0.99'}]",
            "            }",
            "            res = self._create_router(",
            "                self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                set_context=True, external_gateway_info=ext_info",
            "            )",
            "            self.assertEqual(exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_create_routers_native_quotas(self):",
            "        tenant_id = _uuid()",
            "        quota = 1",
            "        cfg.CONF.set_override('quota_router', quota, group='QUOTAS')",
            "        res = self._create_router(self.fmt, tenant_id)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        res = self._create_router(self.fmt, tenant_id)",
            "        self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_router_list(self):",
            "        with self.router() as v1, self.router() as v2, self.router() as v3:",
            "            routers = (v1, v2, v3)",
            "            self._test_list_resources('router', routers)",
            "",
            "    def test_router_list_with_parameters(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2:",
            "            query_params = 'name=router1'",
            "            self._test_list_resources('router', [router1],",
            "                                      query_params=query_params)",
            "            query_params = 'name=router2'",
            "            self._test_list_resources('router', [router2],",
            "                                      query_params=query_params)",
            "            query_params = 'name=router3'",
            "            self._test_list_resources('router', [],",
            "                                      query_params=query_params)",
            "",
            "    def test_router_list_with_sort(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_sort('router', (router3, router2, router1),",
            "                                      [('name', 'desc')])",
            "",
            "    def test_router_list_with_pagination(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_pagination('router',",
            "                                            (router1, router2, router3),",
            "                                            ('name', 'asc'), 2, 2)",
            "",
            "    def test_router_list_with_pagination_reverse(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_pagination_reverse('router',",
            "                                                    (router1, router2,",
            "                                                     router3),",
            "                                                    ('name', 'asc'), 2, 2)",
            "",
            "    def test_router_update(self):",
            "        rname1 = \"yourrouter\"",
            "        rname2 = \"nachorouter\"",
            "        with self.router(name=rname1) as r:",
            "            body = self._show('routers', r['router']['id'])",
            "            self.assertEqual(body['router']['name'], rname1)",
            "",
            "            body = self._update('routers', r['router']['id'],",
            "                                {'router': {'name': rname2}})",
            "",
            "            body = self._show('routers', r['router']['id'])",
            "            self.assertEqual(body['router']['name'], rname2)",
            "",
            "    def test_router_update_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "                    body = self._show('routers', r['router']['id'])",
            "                    net_id = (body['router']",
            "                              ['external_gateway_info']['network_id'])",
            "                    self.assertEqual(net_id, s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'])",
            "                    body = self._show('routers', r['router']['id'])",
            "                    net_id = (body['router']",
            "                              ['external_gateway_info']['network_id'])",
            "                    self.assertEqual(net_id, s2['subnet']['network_id'])",
            "                    # Validate that we can clear the gateway with",
            "                    # an empty dict, in any other case, we fall back",
            "                    # on None as default value",
            "                    self._remove_external_gateway_from_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'],",
            "                        external_gw_info={})",
            "",
            "    def test_router_update_gateway_with_external_ip_used_by_gw(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    ext_ips=[{'ip_address': s['subnet']['gateway_ip']}],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_invalid_external_ip(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    ext_ips=[{'ip_address': '99.99.99.99'}],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_invalid_external_subnet(self):",
            "        with self.subnet() as s1,\\",
            "                self.subnet(cidr='1.0.0.0/24') as s2,\\",
            "                self.router() as r:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'],",
            "                # this subnet is not on the same network so this should fail",
            "                ext_ips=[{'subnet_id': s2['subnet']['id']}],",
            "                expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_different_external_subnet(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1,\\",
            "                    self.subnet(network=n, cidr='1.0.0.0/24') as s2,\\",
            "                    self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                res2 = self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s2['subnet']['id']}])",
            "        fip1 = res1['router']['external_gateway_info']['external_fixed_ips'][0]",
            "        fip2 = res2['router']['external_gateway_info']['external_fixed_ips'][0]",
            "        self.assertEqual(s1['subnet']['id'], fip1['subnet_id'])",
            "        self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "        self.assertNotEqual(fip1['subnet_id'], fip2['subnet_id'])",
            "        self.assertNotEqual(fip1['ip_address'], fip2['ip_address'])",
            "",
            "    def test_router_update_gateway_with_existed_floatingip(self):",
            "        with self.subnet() as subnet:",
            "            self._set_net_external(subnet['subnet']['network_id'])",
            "            with self.floatingip_with_assoc() as fip:",
            "                self._add_external_gateway_to_router(",
            "                    fip['floatingip']['router_id'],",
            "                    subnet['subnet']['network_id'],",
            "                    expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_update_gateway_to_empty_with_existed_floatingip(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            self._remove_external_gateway_from_router(",
            "                fip['floatingip']['router_id'], None,",
            "                expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_update_gateway_add_multiple_prefixes_ipv6(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, \\",
            "                self.subnet(network=n, ip_version=6, cidr='2001:db8::/32') \\",
            "                as s2, (self.router()) as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                fip1 = (res1['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][0])",
            "                self.assertEqual(s1['subnet']['id'], fip1['subnet_id'])",
            "                res2 = self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'ip_address': fip1['ip_address'],",
            "                                  'subnet_id': s1['subnet']['id']},",
            "                                 {'subnet_id': s2['subnet']['id']}])",
            "                self.assertEqual(fip1, res2['router']['external_gateway_info']",
            "                                           ['external_fixed_ips'][0])",
            "                fip2 = (res2['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][1])",
            "                self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['subnet_id'],",
            "                                    fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['ip_address'],",
            "                                    fip2['ip_address'])",
            "",
            "    def test_router_concurrent_delete_upon_subnet_create(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                plugin = directory.get_plugin(plugin_constants.L3)",
            "                mock.patch.object(",
            "                    plugin, 'update_router',",
            "                    side_effect=l3_exc.RouterNotFound(router_id='1')).start()",
            "                # ensure the router disappearing doesn't interfere with subnet",
            "                # creation",
            "                self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                    ip_version=6, cidr='2001:db8::/32',",
            "                                    expected_res_status=(exc.HTTPCreated.code))",
            "",
            "    def test_router_update_gateway_upon_subnet_create_ipv6(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                          r['router']['id'],",
            "                          n['network']['id'],",
            "                          ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                fip1 = (res1['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][0])",
            "                sres = self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                         ip_version=6, cidr='2001:db8::/32',",
            "                                         expected_res_status=(",
            "                                             exc.HTTPCreated.code))",
            "                s2 = self.deserialize(self.fmt, sres)",
            "                res2 = self._show('routers', r['router']['id'])",
            "                self.assertEqual(fip1, res2['router']['external_gateway_info']",
            "                                           ['external_fixed_ips'][0])",
            "                fip2 = (res2['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][1])",
            "                self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['subnet_id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['ip_address'], fip2['ip_address'])",
            "",
            "    def test_router_update_gateway_upon_subnet_create_max_ips_ipv6(self):",
            "        \"\"\"Create subnet should not cause excess fixed IPs on router gw",
            "",
            "        If a router gateway port has the maximum of one IPv4 and one IPv6",
            "        fixed, create subnet should not add any more IP addresses to the port",
            "        (unless this is the subnet is a SLAAC/DHCPv6-stateless subnet in which",
            "        case the addresses are added automatically)",
            "",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(cidr='10.0.0.0/24', network=n) as s1, (",
            "                    self.subnet(ip_version=6, cidr='2001:db8::/64',",
            "                        network=n)) as s2:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'subnet_id': s1['subnet']['id']},",
            "                                 {'subnet_id': s2['subnet']['id']}],",
            "                        expected_code=exc.HTTPOk.code)",
            "                res1 = self._show('routers', r['router']['id'])",
            "                original_fips = (res1['router']['external_gateway_info']",
            "                                 ['external_fixed_ips'])",
            "                # Add another IPv4 subnet - a fip SHOULD NOT be added",
            "                # to the external gateway port as it already has a v4 address",
            "                self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                    cidr='10.0.1.0/24')",
            "                res2 = self._show('routers', r['router']['id'])",
            "                self.assertEqual(original_fips,",
            "                                 res2['router']['external_gateway_info']",
            "                                 ['external_fixed_ips'])",
            "                # Add a SLAAC subnet - a fip from this subnet SHOULD be added",
            "                # to the external gateway port",
            "                s3 = self.deserialize(self.fmt,",
            "                        self._create_subnet(self.fmt,",
            "                            net_id=n['network']['id'],",
            "                            ip_version=6, cidr='2001:db8:1::/64',",
            "                            ipv6_ra_mode=lib_constants.IPV6_SLAAC,",
            "                            ipv6_address_mode=lib_constants.IPV6_SLAAC))",
            "                res3 = self._show('routers', r['router']['id'])",
            "                fips = (res3['router']['external_gateway_info']",
            "                        ['external_fixed_ips'])",
            "                fip_subnet_ids = [fip['subnet_id'] for fip in fips]",
            "                self.assertIn(s1['subnet']['id'], fip_subnet_ids)",
            "                self.assertIn(s2['subnet']['id'], fip_subnet_ids)",
            "                self.assertIn(s3['subnet']['id'], fip_subnet_ids)",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "",
            "    def _test_router_add_interface_subnet(self, router, subnet, msg=None):",
            "        exp_notifications = ['router.create.start',",
            "                             'router.create.end',",
            "                             'network.create.start',",
            "                             'network.create.end',",
            "                             'subnet.create.start',",
            "                             'subnet.create.end',",
            "                             'router.interface.create',",
            "                             'router.interface.delete']",
            "        body = self._router_interface_action('add',",
            "                                             router['router']['id'],",
            "                                             subnet['subnet']['id'],",
            "                                             None)",
            "        self.assertIn('port_id', body, msg)",
            "",
            "        # fetch port and confirm device_id",
            "        r_port_id = body['port_id']",
            "        port = self._show('ports', r_port_id)",
            "        self.assertEqual(port['port']['device_id'],",
            "                         router['router']['id'], msg)",
            "",
            "        self._router_interface_action('remove',",
            "                                      router['router']['id'],",
            "                                      subnet['subnet']['id'],",
            "                                      None)",
            "        self._show('ports', r_port_id,",
            "                   expected_code=exc.HTTPNotFound.code)",
            "",
            "        self.assertEqual(",
            "            set(exp_notifications),",
            "            set(n['event_type'] for n in fake_notifier.NOTIFICATIONS), msg)",
            "",
            "        for n in fake_notifier.NOTIFICATIONS:",
            "            if n['event_type'].startswith('router.interface.'):",
            "                payload = n['payload']['router_interface']",
            "                self.assertIn('id', payload)",
            "                self.assertEqual(payload['id'], router['router']['id'])",
            "                self.assertIn('tenant_id', payload)",
            "                rtid = router['router']['tenant_id']",
            "                # tolerate subnet tenant deliberately set to '' in the",
            "                # nsx metadata access case",
            "                self.assertIn(payload['tenant_id'], [rtid, ''], msg)",
            "",
            "    def test_router_add_interface_bad_values(self):",
            "        with self.router() as r:",
            "            exp_code = exc.HTTPBadRequest.code",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          False,",
            "                                          None,",
            "                                          expected_code=exp_code)",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          False,",
            "                                          expected_code=exp_code)",
            "",
            "    def test_router_add_interface_subnet(self):",
            "        fake_notifier.reset()",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                with self.subnet(network=n) as s:",
            "                    self._test_router_add_interface_subnet(r, s)",
            "",
            "    def test_router_delete_race_with_interface_add(self):",
            "        # this test depends on protection from the revision plugin so",
            "        # we have to initialize it",
            "        revision_plugin.RevisionPlugin()",
            "        with self.router() as r, self.subnet() as s:",
            "",
            "            def jam_in_interface(*args, **kwargs):",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              s['subnet']['id'], None)",
            "                # unsubscribe now that the evil is done",
            "                registry.unsubscribe(jam_in_interface, resources.ROUTER,",
            "                                     events.PRECOMMIT_DELETE)",
            "            registry.subscribe(jam_in_interface, resources.ROUTER,",
            "                               events.PRECOMMIT_DELETE)",
            "            self._delete('routers', r['router']['id'],",
            "                         expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_add_interface_ipv6_subnet(self):",
            "        \"\"\"Test router-interface-add for valid ipv6 subnets.",
            "",
            "        Verify the valid use-cases of an IPv6 subnet where we",
            "        are allowed to associate to the Neutron Router are successful.",
            "        \"\"\"",
            "        slaac = lib_constants.IPV6_SLAAC",
            "        stateful = lib_constants.DHCPV6_STATEFUL",
            "        stateless = lib_constants.DHCPV6_STATELESS",
            "        use_cases = [{'msg': 'IPv6 Subnet Modes (slaac, none)',",
            "                      'ra_mode': slaac, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (none, none)',",
            "                      'ra_mode': None, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateful, none)',",
            "                      'ra_mode': stateful, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateless, none)',",
            "                      'ra_mode': stateless, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (slaac, slaac)',",
            "                      'ra_mode': slaac, 'address_mode': slaac},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateful,'",
            "                      'dhcpv6-stateful)', 'ra_mode': stateful,",
            "                      'address_mode': stateful},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateless,'",
            "                      'dhcpv6-stateless)', 'ra_mode': stateless,",
            "                      'address_mode': stateless}]",
            "        for uc in use_cases:",
            "            fake_notifier.reset()",
            "            with self.router() as r, self.network() as n:",
            "                with self.subnet(network=n, cidr='fd00::1/64',",
            "                                 gateway_ip='fd00::1', ip_version=6,",
            "                                 ipv6_ra_mode=uc['ra_mode'],",
            "                                 ipv6_address_mode=uc['address_mode']) as s:",
            "                    self._test_router_add_interface_subnet(r, s, uc['msg'])",
            "",
            "    def test_router_add_interface_multiple_ipv4_subnets(self):",
            "        \"\"\"Test router-interface-add for multiple ipv4 subnets.",
            "",
            "        Verify that adding multiple ipv4 subnets from the same network",
            "        to a router places them all on different router interfaces.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(network=n, cidr='10.0.0.0/24') as s1, (",
            "                 self.subnet(network=n, cidr='10.0.1.0/24')) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertNotEqual(pid1, pid2)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnets_same_net(self):",
            "        \"\"\"Test router-interface-add for multiple ipv6 subnets on a network.",
            "",
            "        Verify that adding multiple ipv6 subnets from the same network",
            "        to a router places them all on the same router interface.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with (self.subnet(network=n, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertEqual(pid1, pid2)",
            "                    port = self._show('ports', pid1)",
            "                    self.assertEqual(2, len(port['port']['fixed_ips']))",
            "                    port_subnet_ids = [fip['subnet_id'] for fip in",
            "                                       port['port']['fixed_ips']]",
            "                    self.assertIn(s1['subnet']['id'], port_subnet_ids)",
            "                    self.assertIn(s2['subnet']['id'], port_subnet_ids)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnets_different_net(self):",
            "        \"\"\"Test router-interface-add for ipv6 subnets on different networks.",
            "",
            "        Verify that adding multiple ipv6 subnets from different networks",
            "        to a router places them on different router interfaces.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n1, self.network() as n2:",
            "            with (self.subnet(network=n1, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n2, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertNotEqual(pid1, pid2)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_iface_ipv6_ext_ra_subnet_returns_400(self):",
            "        \"\"\"Test router-interface-add for in-valid ipv6 subnets.",
            "",
            "        Verify that an appropriate error message is displayed when",
            "        an IPv6 subnet configured to use an external_router for Router",
            "        Advertisements (i.e., ipv6_ra_mode is None and ipv6_address_mode",
            "        is not None) is attempted to associate with a Neutron Router.",
            "        \"\"\"",
            "        use_cases = [{'msg': 'IPv6 Subnet Modes (none, slaac)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.IPV6_SLAAC},",
            "                     {'msg': 'IPv6 Subnet Modes (none, dhcpv6-stateful)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.DHCPV6_STATEFUL},",
            "                     {'msg': 'IPv6 Subnet Modes (none, dhcpv6-stateless)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.DHCPV6_STATELESS}]",
            "        for uc in use_cases:",
            "            with self.router() as r, self.network() as n:",
            "                with self.subnet(network=n, cidr='fd00::1/64',",
            "                                 gateway_ip='fd00::1', ip_version=6,",
            "                                 ipv6_ra_mode=uc['ra_mode'],",
            "                                 ipv6_address_mode=uc['address_mode']) as s:",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=exp_code,",
            "                                                  msg=uc['msg'])",
            "",
            "    def test_router_add_interface_ipv6_subnet_without_gateway_ip(self):",
            "        with self.router() as r:",
            "            with self.subnet(ip_version=6, cidr='fe80::/64',",
            "                             gateway_ip=None) as s:",
            "                error_code = exc.HTTPBadRequest.code",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=error_code)",
            "",
            "    def test_router_add_interface_subnet_with_bad_tenant_returns_404(self):",
            "        tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id, set_context=True) as r:",
            "            with self.network(tenant_id=tenant_id, set_context=True) as n:",
            "                with self.subnet(network=n, set_context=True) as s:",
            "                    err_code = exc.HTTPNotFound.code",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=err_code,",
            "                                                  tenant_id='bad_tenant')",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s['subnet']['id'],",
            "                                                         None)",
            "                    self.assertIn('port_id', body)",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=err_code,",
            "                                                  tenant_id='bad_tenant')",
            "",
            "    def test_router_add_interface_subnet_with_port_from_other_tenant(self):",
            "        tenant_id = _uuid()",
            "        other_tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id) as r,\\",
            "                self.network(tenant_id=tenant_id) as n1,\\",
            "                self.network(tenant_id=other_tenant_id) as n2:",
            "            with self.subnet(network=n1, cidr='10.0.0.0/24') as s1,\\",
            "                    self.subnet(network=n2, cidr='10.1.0.0/24') as s2:",
            "                body = self._router_interface_action(",
            "                    'add',",
            "                    r['router']['id'],",
            "                    s2['subnet']['id'],",
            "                    None)",
            "                self.assertIn('port_id', body)",
            "                self._router_interface_action(",
            "                    'add',",
            "                    r['router']['id'],",
            "                    s1['subnet']['id'],",
            "                    None,",
            "                    tenant_id=tenant_id)",
            "                self.assertIn('port_id', body)",
            "",
            "    def test_router_add_interface_port(self):",
            "        orig_update_port = self.plugin.update_port",
            "        with self.router() as r, (",
            "            self.port()) as p, (",
            "                mock.patch.object(self.plugin, 'update_port')) as update_port:",
            "            update_port.side_effect = orig_update_port",
            "            body = self._router_interface_action('add',",
            "                                                 r['router']['id'],",
            "                                                 None,",
            "                                                 p['port']['id'])",
            "            self.assertIn('port_id', body)",
            "            self.assertEqual(p['port']['id'], body['port_id'])",
            "            expected_port_update = {",
            "                'device_owner': lib_constants.DEVICE_OWNER_ROUTER_INTF,",
            "                'device_id': r['router']['id']}",
            "            update_port.assert_any_call(",
            "                mock.ANY, p['port']['id'], {'port': expected_port_update})",
            "            # fetch port and confirm device_id",
            "            body = self._show('ports', p['port']['id'])",
            "            self.assertEqual(r['router']['id'], body['port']['device_id'])",
            "",
            "            # clean-up",
            "            self._router_interface_action('remove',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "",
            "    def test_router_add_interface_delete_port_after_failure(self):",
            "        with self.router() as r, self.subnet(enable_dhcp=False) as s:",
            "            plugin = directory.get_plugin()",
            "            # inject a failure in the update port that happens at the end",
            "            # to ensure the port gets deleted",
            "            with mock.patch.object(",
            "                    plugin, 'update_port',",
            "                    side_effect=n_exc.InvalidInput(error_message='x')):",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              exc.HTTPBadRequest.code)",
            "                self.assertFalse(plugin.get_ports(context.get_admin_context()))",
            "",
            "    def test_router_add_interface_dup_port(self):",
            "        '''This tests that if multiple routers add one port as their",
            "        interfaces. Only the first router's interface would be added",
            "        to this port. All the later requests would return exceptions.",
            "        '''",
            "        with self.router() as r1, self.router() as r2, self.network() as n:",
            "            with self.subnet(network=n) as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r1['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    # mock out the sequential check",
            "                    plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                    check_p = mock.patch(plugin + '._check_router_port',",
            "                                         port_id=p['port']['id'],",
            "                                         device_id=r2['router']['id'],",
            "                                         return_value=p['port'])",
            "                    checkport = check_p.start()",
            "                    # do regular checkport after first skip",
            "                    checkport.side_effect = check_p.stop()",
            "                    self._router_interface_action('add',",
            "                                                  r2['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'],",
            "                                                  exc.HTTPConflict.code)",
            "                    # clean-up",
            "                    self._router_interface_action('remove',",
            "                                                  r1['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def _assert_body_port_id_and_update_port(self, body, mock_update_port,",
            "                                             port_id, device_id):",
            "        self.assertNotIn('port_id', body)",
            "        expected_port_update_before_update = {",
            "            'device_owner': lib_constants.DEVICE_OWNER_ROUTER_INTF,",
            "            'device_id': device_id}",
            "        expected_port_update_after_fail = {",
            "            'device_owner': '',",
            "            'device_id': ''}",
            "        mock_update_port.assert_has_calls(",
            "            [mock.call(",
            "                mock.ANY,",
            "                port_id,",
            "                {'port': expected_port_update_before_update}),",
            "             mock.call(",
            "                mock.ANY,",
            "                port_id,",
            "                {'port': expected_port_update_after_fail})],",
            "            any_order=False)",
            "        # fetch port and confirm device_id and device_owner",
            "        body = self._show('ports', port_id)",
            "        self.assertEqual('', body['port']['device_owner'])",
            "        self.assertEqual('', body['port']['device_id'])",
            "",
            "    def test_router_add_interface_multiple_ipv4_subnet_port_returns_400(self):",
            "        \"\"\"Test adding router port with multiple IPv4 subnets fails.",
            "",
            "        Multiple IPv4 subnets are not allowed on a single router port.",
            "        Ensure that adding a port with multiple IPv4 subnets to a router fails.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='10.0.0.0/24') as s1, (",
            "                 self.subnet(network=n, cidr='10.0.1.0/24')) as s2:",
            "                fixed_ips = [{'subnet_id': s1['subnet']['id']},",
            "                             {'subnet_id': s2['subnet']['id']}]",
            "                orig_update_port = self.plugin.update_port",
            "                with self.port(subnet=s1, fixed_ips=fixed_ips) as p, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                    update_port.side_effect = orig_update_port",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    body = self._router_interface_action(",
            "                        'add', r['router']['id'], None, p['port']['id'],",
            "                        expected_code=exp_code)",
            "                    self._assert_body_port_id_and_update_port(",
            "                        body, update_port, p['port']['id'], r['router']['id'])",
            "",
            "    def test_router_add_interface_ipv6_port_existing_network_returns_400(self):",
            "        \"\"\"Ensure unique IPv6 router ports per network id.",
            "",
            "        Adding a router port containing one or more IPv6 subnets with the same",
            "        network id as an existing router port should fail. This is so",
            "        there is no ambiguity regarding on which port to add an IPv6 subnet",
            "        when executing router-interface-add with a subnet and no port.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='fd00::/64',",
            "                             ip_version=6) as s1, (",
            "                 self.subnet(network=n, cidr='fd01::/64',",
            "                             ip_version=6)) as s2:",
            "                orig_update_port = self.plugin.update_port",
            "                with self.port(subnet=s1) as p, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                    update_port.side_effect = orig_update_port",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s2['subnet']['id'],",
            "                                                  None)",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    body = self._router_interface_action(",
            "                        'add', r['router']['id'], None, p['port']['id'],",
            "                        expected_code=exp_code)",
            "                    self._assert_body_port_id_and_update_port(",
            "                        body, update_port, p['port']['id'], r['router']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s2['subnet']['id'],",
            "                                                  None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnet_port(self):",
            "        \"\"\"A port with multiple IPv6 subnets can be added to a router",
            "",
            "        Create a port with multiple associated IPv6 subnets and attach",
            "        it to a router. The action should succeed.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='fd00::/64',",
            "                             ip_version=6) as s1, (",
            "                 self.subnet(network=n, cidr='fd01::/64',",
            "                             ip_version=6)) as s2:",
            "                fixed_ips = [{'subnet_id': s1['subnet']['id']},",
            "                             {'subnet_id': s2['subnet']['id']}]",
            "                with self.port(subnet=s1, fixed_ips=fixed_ips) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_add_interface_empty_port_and_subnet_ids(self):",
            "        with self.router() as r:",
            "            self._router_interface_action('add', r['router']['id'],",
            "                                          None, None,",
            "                                          expected_code=exc.",
            "                                          HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_port_bad_tenant_returns_404(self):",
            "        tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id, set_context=True) as r:",
            "            with self.network(tenant_id=tenant_id, set_context=True) as n:",
            "                with self.subnet(tenant_id=tenant_id, network=n,",
            "                                 set_context=True) as s:",
            "                    with self.port(tenant_id=tenant_id, subnet=s,",
            "                                   set_context=True) as p:",
            "                        err_code = exc.HTTPNotFound.code",
            "                        self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    expected_code=err_code,",
            "                                                    tenant_id='bad_tenant')",
            "                        self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    tenant_id=tenant_id)",
            "",
            "                        # clean-up should fail as well",
            "                        self._router_interface_action('remove',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    expected_code=err_code,",
            "                                                    tenant_id='bad_tenant')",
            "",
            "    def test_router_add_interface_port_without_ips(self):",
            "        with self.network() as network, self.router() as r:",
            "            # Create a router port without ips",
            "            p = self._make_port(self.fmt, network['network']['id'],",
            "                device_owner=lib_constants.DEVICE_OWNER_ROUTER_INTF)",
            "            err_code = exc.HTTPBadRequest.code",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'],",
            "                                          expected_code=err_code)",
            "",
            "    def test_router_add_interface_dup_subnet1_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=exc.",
            "                                              HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_dup_subnet2_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1, self.subnet(cidr='1.0.0.0/24') as s2:",
            "                with self.port(subnet=s1) as p1, self.port(subnet=s2) as p2:",
            "                    orig_update_port = self.plugin.update_port",
            "                    with self.port(subnet=s1) as p3, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                        update_port.side_effect = orig_update_port",
            "                        for p in [p1, p2]:",
            "                            self._router_interface_action('add',",
            "                                                          r['router']['id'],",
            "                                                          None,",
            "                                                          p['port']['id'])",
            "                        body = self._router_interface_action(",
            "                            'add', r['router']['id'], None, p3['port']['id'],",
            "                            expected_code=exc.HTTPBadRequest.code)",
            "                        self._assert_body_port_id_and_update_port(",
            "                            body, update_port, p3['port']['id'],",
            "                            r['router']['id'])",
            "",
            "    def test_router_add_interface_overlapped_cidr_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.2.0/24') as s2:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s1['subnet']['id'],",
            "                                              None)",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s2['subnet']['id'],",
            "                                              None)",
            "",
            "                def try_overlapped_cidr(cidr):",
            "                    with self.subnet(cidr=cidr) as s3:",
            "                        self._router_interface_action('add',",
            "                                                      r['router']['id'],",
            "                                                      s3['subnet']['id'],",
            "                                                      None,",
            "                                                      expected_code=exc.",
            "                                                      HTTPBadRequest.code)",
            "                # another subnet with same cidr",
            "                try_overlapped_cidr('10.0.1.0/24')",
            "                try_overlapped_cidr('10.0.2.0/24')",
            "                # another subnet with overlapped cidr including s1",
            "                try_overlapped_cidr('10.0.0.0/16')",
            "                # another subnet with overlapped cidr including s2",
            "                try_overlapped_cidr('10.0.2.128/28')",
            "",
            "    def test_router_add_interface_no_data_returns_400(self):",
            "        with self.router() as r:",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          None,",
            "                                          expected_code=exc.",
            "                                          HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_with_both_ids_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'],",
            "                                                  expected_code=exc.",
            "                                                  HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_cidr_overlapped_with_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.0.0/16') as s2:",
            "                self._set_net_external(s2['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s2['subnet']['network_id'])",
            "                res = self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    s1['subnet']['id'],",
            "                                                    None)",
            "                self.assertIn('port_id', res)",
            "",
            "    def test_router_add_interface_by_port_cidr_overlapped_with_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.0.0/16') as s2:",
            "                with self.port(subnet=s1) as p:",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'])",
            "",
            "                    res = self._router_interface_action('add',",
            "                                                        r['router']['id'],",
            "                                                        None,",
            "                                                        p['port']['id'])",
            "                    self.assertIn('port_id', res)",
            "",
            "    def test_router_add_gateway_dup_subnet1_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_dup_subnet2_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=exc.",
            "                                              HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_multiple_subnets_ipv6(self):",
            "        \"\"\"Ensure external gateway set doesn't add excess IPs on router gw",
            "",
            "        Setting the gateway of a router to an external network with more than",
            "        one IPv4 and one IPv6 subnet should only add an address from the first",
            "        IPv4 subnet, an address from the first IPv6-stateful subnet, and an",
            "        address from each IPv6-stateless (SLAAC and DHCPv6-stateless) subnet",
            "",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(",
            "                    cidr='10.0.0.0/24', network=n) as s1, (",
            "                 self.subnet(",
            "                    cidr='10.0.1.0/24', network=n)) as s2, (",
            "                 self.subnet(",
            "                    cidr='2001:db8::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.IPV6_SLAAC,",
            "                    ipv6_address_mode=lib_constants.IPV6_SLAAC)) as s3, (",
            "                 self.subnet(",
            "                    cidr='2001:db8:1::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.DHCPV6_STATEFUL,",
            "                    ipv6_address_mode=lib_constants.DHCPV6_STATEFUL)) as s4, (",
            "                 self.subnet(",
            "                    cidr='2001:db8:2::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.DHCPV6_STATELESS,",
            "                    ipv6_address_mode=lib_constants.DHCPV6_STATELESS)) as s5:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'])",
            "                res = self._show('routers', r['router']['id'])",
            "                fips = (res['router']['external_gateway_info']",
            "                        ['external_fixed_ips'])",
            "                fip_subnet_ids = {fip['subnet_id'] for fip in fips}",
            "                # one of s1 or s2 should be in the list.",
            "                if s1['subnet']['id'] in fip_subnet_ids:",
            "                    self.assertEqual({s1['subnet']['id'],",
            "                                      s3['subnet']['id'],",
            "                                      s4['subnet']['id'],",
            "                                      s5['subnet']['id']},",
            "                                     fip_subnet_ids)",
            "                else:",
            "                    self.assertEqual({s2['subnet']['id'],",
            "                                      s3['subnet']['id'],",
            "                                      s4['subnet']['id'],",
            "                                      s5['subnet']['id']},",
            "                                     fip_subnet_ids)",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "",
            "    def test_router_add_and_remove_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_router_add_and_remove_gateway_tenant_ctx(self):",
            "        with self.router(tenant_id='noadmin',",
            "                         set_context=True) as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                ctx = context.Context('', 'noadmin')",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    neutron_context=ctx)",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_create_router_port_with_device_id_of_other_teants_router(self):",
            "        with self.router() as admin_router:",
            "            with self.network(tenant_id='tenant_a',",
            "                              set_context=True) as n:",
            "                with self.subnet(network=n):",
            "                    for device_owner in lib_constants.ROUTER_INTERFACE_OWNERS:",
            "                        self._create_port(",
            "                            self.fmt, n['network']['id'],",
            "                            tenant_id='tenant_a',",
            "                            device_id=admin_router['router']['id'],",
            "                            device_owner=device_owner,",
            "                            set_context=True,",
            "                            expected_res_status=exc.HTTPConflict.code)",
            "",
            "    def test_create_non_router_port_device_id_of_other_teants_router_update(",
            "        self):",
            "        # This tests that HTTPConflict is raised if we create a non-router",
            "        # port that matches the device_id of another tenants router and then",
            "        # we change the device_owner to be network:router_interface.",
            "        with self.router() as admin_router:",
            "            with self.network(tenant_id='tenant_a',",
            "                              set_context=True) as n:",
            "                with self.subnet(network=n):",
            "                    for device_owner in lib_constants.ROUTER_INTERFACE_OWNERS:",
            "                        port_res = self._create_port(",
            "                            self.fmt, n['network']['id'],",
            "                            tenant_id='tenant_a',",
            "                            device_id=admin_router['router']['id'],",
            "                            set_context=True)",
            "                        port = self.deserialize(self.fmt, port_res)",
            "                        neutron_context = context.Context('', 'tenant_a')",
            "                        data = {'port': {'device_owner': device_owner}}",
            "                        self._update('ports', port['port']['id'], data,",
            "                                     neutron_context=neutron_context,",
            "                                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_update_port_device_id_to_different_tenants_router(self):",
            "        with self.router() as admin_router:",
            "            with self.router(tenant_id='tenant_a',",
            "                             set_context=True) as tenant_router:",
            "                with self.network(tenant_id='tenant_a',",
            "                                  set_context=True) as n:",
            "                    with self.subnet(network=n) as s:",
            "                        port = self._router_interface_action(",
            "                            'add', tenant_router['router']['id'],",
            "                            s['subnet']['id'], None, tenant_id='tenant_a')",
            "                        neutron_context = context.Context('', 'tenant_a')",
            "                        data = {'port':",
            "                                {'device_id': admin_router['router']['id']}}",
            "                        self._update('ports', port['port_id'], data,",
            "                                     neutron_context=neutron_context,",
            "                                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_add_gateway_invalid_network_returns_400(self):",
            "        with self.router() as r:",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                \"foobar\", expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_non_existent_network_returns_404(self):",
            "        with self.router() as r:",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                _uuid(), expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_router_add_gateway_net_not_external_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                # intentionally do not set net as external",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_no_subnet(self):",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, n['network']['id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_router_add_gateway_no_subnet_forbidden(self):",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                self._set_net_external(n['network']['id'])",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    errors = [",
            "                        exceptions.NotificationError(",
            "                            'foo_callback_id',",
            "                            n_exc.InvalidInput(error_message='forbidden')),",
            "                    ]",
            "                    notify.side_effect = exceptions.CallbackFailure(",
            "                        errors=errors)",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'], n['network']['id'],",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "                    notify.assert_called_once_with(",
            "                        resources.ROUTER_GATEWAY,",
            "                        events.BEFORE_CREATE,",
            "                        mock.ANY,",
            "                        context=mock.ANY,",
            "                        router_id=r['router']['id'],",
            "                        network_id=n['network']['id'],",
            "                        subnets=[])",
            "",
            "    def test_router_remove_interface_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._delete('routers', r['router']['id'],",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_remove_interface_callback_failure_returns_409(self):",
            "        with self.router() as r,\\",
            "                self.subnet() as s,\\",
            "                mock.patch.object(registry, 'notify') as notify:",
            "            errors = [",
            "                exceptions.NotificationError(",
            "                    'foo_callback_id', n_exc.InUse()),",
            "            ]",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          s['subnet']['id'],",
            "                                          None)",
            "",
            "            # we fail the first time, but not the second, when",
            "            # the clean-up takes place",
            "            notify.side_effect = [",
            "                exceptions.CallbackFailure(errors=errors), None",
            "            ]",
            "            self._router_interface_action(",
            "                'remove',",
            "                r['router']['id'],",
            "                s['subnet']['id'],",
            "                None,",
            "                exc.HTTPConflict.code)",
            "",
            "    def test_router_clear_gateway_callback_failure_returns_409(self):",
            "        with self.router() as r,\\",
            "                self.subnet() as s,\\",
            "                mock.patch.object(registry, 'notify') as notify:",
            "            errors = [",
            "                exceptions.NotificationError(",
            "                    'foo_callback_id', n_exc.InUse()),",
            "            ]",
            "",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "            notify.side_effect = exceptions.CallbackFailure(errors=errors)",
            "            self._remove_external_gateway_from_router(",
            "                r['router']['id'],",
            "                s['subnet']['network_id'],",
            "                external_gw_info={},",
            "                expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_remove_interface_wrong_subnet_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port() as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'],",
            "                                                  exc.HTTPBadRequest.code)",
            "",
            "    def test_router_remove_interface_nothing_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  None,",
            "                                                  exc.HTTPBadRequest.code)",
            "                    # remove properly to clean-up",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_remove_interface_returns_200(self):",
            "        with self.router() as r:",
            "            with self.port() as p:",
            "                body = self._router_interface_action('add',",
            "                                                     r['router']['id'],",
            "                                                     None,",
            "                                                     p['port']['id'])",
            "                self._router_interface_action('remove',",
            "                                              r['router']['id'],",
            "                                              None,",
            "                                              p['port']['id'],",
            "                                              expected_body=body)",
            "",
            "    def test_router_remove_interface_with_both_ids_returns_200(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_remove_interface_wrong_port_returns_404(self):",
            "        with self.router() as r:",
            "            with self.subnet():",
            "                with self.port() as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    # create another port for testing failure case",
            "                    res = self._create_port(self.fmt, p['port']['network_id'])",
            "                    p2 = self.deserialize(self.fmt, res)",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p2['port']['id'],",
            "                                                  exc.HTTPNotFound.code)",
            "",
            "    def test_router_remove_ipv6_subnet_from_interface(self):",
            "        \"\"\"Delete a subnet from a router interface",
            "",
            "        Verify that deleting a subnet with router-interface-delete removes",
            "        that subnet when there are multiple subnets on the interface and",
            "        removes the interface when it is the last subnet on the interface.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with (self.subnet(network=n, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                body = self._router_interface_action('add', r['router']['id'],",
            "                                                     s1['subnet']['id'],",
            "                                                     None)",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              s2['subnet']['id'], None)",
            "                port = self._show('ports', body['port_id'])",
            "                self.assertEqual(2, len(port['port']['fixed_ips']))",
            "                self._router_interface_action('remove', r['router']['id'],",
            "                                              s1['subnet']['id'], None)",
            "                port = self._show('ports', body['port_id'])",
            "                self.assertEqual(1, len(port['port']['fixed_ips']))",
            "                self._router_interface_action('remove', r['router']['id'],",
            "                                              s2['subnet']['id'], None)",
            "                exp_code = exc.HTTPNotFound.code",
            "                port = self._show('ports', body['port_id'],",
            "                                  expected_code=exp_code)",
            "",
            "    def test_router_delete(self):",
            "        with self.router() as router:",
            "            router_id = router['router']['id']",
            "        req = self.new_show_request('router', router_id)",
            "        res = req.get_response(self._api_for_resource('router'))",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_router_delete_with_port_existed_returns_409(self):",
            "        with self.subnet() as subnet:",
            "            res = self._create_router(self.fmt, _uuid())",
            "            router = self.deserialize(self.fmt, res)",
            "            self._router_interface_action('add',",
            "                                          router['router']['id'],",
            "                                          subnet['subnet']['id'],",
            "                                          None)",
            "            self._delete('routers', router['router']['id'],",
            "                         exc.HTTPConflict.code)",
            "",
            "    def test_router_delete_with_floatingip_existed_returns_409(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                res = self._create_router(self.fmt, _uuid())",
            "                r = self.deserialize(self.fmt, res)",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              private_sub['subnet']['id'],",
            "                                              None)",
            "                res = self._create_floatingip(",
            "                    self.fmt, public_sub['subnet']['network_id'],",
            "                    port_id=p['port']['id'])",
            "                self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "                self._delete('routers', r['router']['id'],",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_show(self):",
            "        name = 'router1'",
            "        tenant_id = _uuid()",
            "        expected_value = [('name', name), ('tenant_id', tenant_id),",
            "                          ('admin_state_up', True), ('status', 'ACTIVE'),",
            "                          ('external_gateway_info', None)]",
            "        with self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id) as router:",
            "            res = self._show('routers', router['router']['id'])",
            "            for k, v in expected_value:",
            "                self.assertEqual(res['router'][k], v)",
            "",
            "    def test_network_update_external_failure(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                self._set_net_external(s1['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s1['subnet']['network_id'])",
            "                self._update('networks', s1['subnet']['network_id'],",
            "                             {'network': {extnet_apidef.EXTERNAL: False}},",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_network_update_external(self):",
            "        with self.router() as r:",
            "            with self.network('test_net') as testnet:",
            "                self._set_net_external(testnet['network']['id'])",
            "                with self.subnet() as s1:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "                    self._update('networks', testnet['network']['id'],",
            "                                 {'network': {extnet_apidef.EXTERNAL: False}})",
            "",
            "    def test_floatingip_crd_ops(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            self._validate_floating_ip(fip)",
            "",
            "        # post-delete, check that it is really gone",
            "        body = self._list('floatingips')",
            "        self.assertEqual(0, len(body['floatingips']))",
            "",
            "        self._show('floatingips', fip['floatingip']['id'],",
            "                   expected_code=exc.HTTPNotFound.code)",
            "",
            "    def _test_floatingip_with_assoc_fails(self, plugin_method):",
            "        with self.subnet(cidr='200.0.0.0/24') as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router() as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                  private_sub['subnet']['id'],",
            "                                                  None)",
            "                    with mock.patch(plugin_method) as pl:",
            "                        pl.side_effect = n_exc.BadRequest(",
            "                            resource='floatingip',",
            "                            msg='fake_error')",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            port_id=private_port['port']['id'])",
            "                        self.assertEqual(400, res.status_int)",
            "                    for p in self._list('ports')['ports']:",
            "                        if (p['device_owner'] ==",
            "                                lib_constants.DEVICE_OWNER_FLOATINGIP):",
            "                            self.fail('garbage port is not deleted')",
            "",
            "    def test_floatingip_with_assoc_fails(self):",
            "        self._test_floatingip_with_assoc_fails(",
            "            'neutron.db.l3_db.L3_NAT_dbonly_mixin._check_and_get_fip_assoc')",
            "",
            "    def test_create_floatingip_with_assoc(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.floatingip_with_assoc() as fip:",
            "            body = self._show('floatingips', fip['floatingip']['id'])",
            "            self.assertEqual(body['floatingip']['id'],",
            "                             fip['floatingip']['id'])",
            "            self.assertEqual(body['floatingip']['port_id'],",
            "                             fip['floatingip']['port_id'])",
            "            self.assertEqual(expected_status, body['floatingip']['status'])",
            "            self.assertIsNotNone(body['floatingip']['fixed_ip_address'])",
            "            self.assertIsNotNone(body['floatingip']['router_id'])",
            "",
            "    def test_create_floatingip_non_admin_context_agent_notification(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not hasattr(plugin, 'l3_rpc_notifier'):",
            "            self.skipTest(\"Plugin does not support l3_rpc_notifier\")",
            "",
            "        with self.subnet(cidr='11.0.0.0/24') as public_sub,\\",
            "                self.port() as private_port,\\",
            "                self.router() as r:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            subnet_id = private_port['port']['fixed_ips'][0]['subnet_id']",
            "            private_sub = {'subnet': {'id': subnet_id}}",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                public_sub['subnet']['network_id'])",
            "            self._router_interface_action(",
            "                'add', r['router']['id'],",
            "                private_sub['subnet']['id'], None)",
            "",
            "            with mock.patch.object(plugin.l3_rpc_notifier,",
            "                                   'routers_updated') as agent_notification:",
            "                self._make_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'],",
            "                    port_id=private_port['port']['id'],",
            "                    set_context=False)",
            "                self.assertTrue(agent_notification.called)",
            "",
            "    def test_floating_port_status_not_applicable(self):",
            "        with self.floatingip_with_assoc():",
            "            port_body = self._list('ports',",
            "               query_params='device_owner=network:floatingip')['ports'][0]",
            "            self.assertEqual(lib_constants.PORT_STATUS_NOTAPPLICABLE,",
            "                             port_body['status'])",
            "",
            "    def test_floatingip_update(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertEqual(expected_status, body['floatingip']['status'])",
            "",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_subnet_gateway_disabled(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        \"\"\"Attach a floating IP to an instance",
            "",
            "        Verify that the floating IP can be associated to a port whose subnet's",
            "        gateway ip is not connected to the external router, but the router",
            "        has an ip in that subnet.",
            "        \"\"\"",
            "        with self.subnet(cidr='30.0.0.0/24', gateway_ip=None) as private_sub:",
            "            with self.port(private_sub) as p:",
            "                subnet_id = p['port']['fixed_ips'][0]['subnet_id']",
            "                private_sub = {'subnet': {'id': subnet_id}}",
            "                port_id = p['port']['id']",
            "                with self.router() as r:",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                None, port_id)",
            "                with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                    self._set_net_external(public_sub['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                         r['router']['id'], public_sub['subnet']['network_id'])",
            "                    fip = self._make_floatingip(self.fmt,",
            "                                 public_sub['subnet']['network_id'])",
            "                    body = self._show('floatingips', fip['floatingip']['id'])",
            "                    self.assertEqual(expected_status,",
            "                                     body['floatingip']['status'])",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                  {'floatingip': {'port_id': port_id}})",
            "                    self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                    self.assertEqual(p['port']['fixed_ips'][0]['ip_address'],",
            "                                     body['floatingip']['fixed_ip_address'])",
            "                    self.assertEqual(r['router']['id'],",
            "                                     body['floatingip']['router_id'])",
            "",
            "    def test_floatingip_create_different_fixed_ip_same_port(self):",
            "        '''This tests that it is possible to delete a port that has",
            "        multiple floating ip addresses associated with it (each floating",
            "        address associated with a unique fixed address).",
            "        '''",
            "",
            "        with self.router() as r:",
            "            with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "",
            "                with self.subnet() as private_sub:",
            "                    ip_range = list(netaddr.IPNetwork(",
            "                        private_sub['subnet']['cidr']))",
            "                    fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                                 {'ip_address': str(ip_range[-2])}]",
            "",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    with self.port(subnet=private_sub,",
            "                                   fixed_ips=fixed_ips) as p:",
            "",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-2]))",
            "                        fip2 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]))",
            "",
            "                        # Test that floating ips are assigned successfully.",
            "                        body = self._show('floatingips',",
            "                                          fip1['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip1['floatingip']['port_id'])",
            "",
            "                        body = self._show('floatingips',",
            "                                          fip2['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip2['floatingip']['port_id'])",
            "                    self._delete('ports', p['port']['id'])",
            "                    # Test that port has been successfully deleted.",
            "                    body = self._show('ports', p['port']['id'],",
            "                                      expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_floatingip_update_different_fixed_ip_same_port(self):",
            "        with self.subnet() as s:",
            "            ip_range = list(netaddr.IPNetwork(s['subnet']['cidr']))",
            "            fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                         {'ip_address': str(ip_range[-2])}]",
            "            with self.port(subnet=s, fixed_ips=fixed_ips) as p:",
            "                with self.floatingip_with_assoc(",
            "                    port_id=p['port']['id'],",
            "                    fixed_ip=str(ip_range[-3])) as fip:",
            "                    body = self._show('floatingips', fip['floatingip']['id'])",
            "                    self.assertEqual(fip['floatingip']['id'],",
            "                                     body['floatingip']['id'])",
            "                    self.assertEqual(fip['floatingip']['port_id'],",
            "                                     body['floatingip']['port_id'])",
            "                    self.assertEqual(str(ip_range[-3]),",
            "                                     body['floatingip']['fixed_ip_address'])",
            "                    self.assertIsNotNone(body['floatingip']['router_id'])",
            "                    body_2 = self._update(",
            "                        'floatingips', fip['floatingip']['id'],",
            "                        {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': str(ip_range[-2])}",
            "                         })",
            "                    self.assertEqual(fip['floatingip']['port_id'],",
            "                                     body_2['floatingip']['port_id'])",
            "                    self.assertEqual(str(ip_range[-2]),",
            "                                     body_2['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_invalid_fixed_ip(self):",
            "        with self.subnet() as s:",
            "            with self.port(subnet=s) as p:",
            "                with self.floatingip_with_assoc(",
            "                    port_id=p['port']['id']) as fip:",
            "                    self._update(",
            "                        'floatingips', fip['floatingip']['id'],",
            "                        {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': '2001:db8::a'}},",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_floatingip_update_to_same_port_id_twice(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertEqual(expected_status, body['floatingip']['status'])",
            "",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                # 1. Update floating IP with port_id (associate)",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "                # 2. Update floating IP with same port again",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                # No errors, and nothing changed",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_same_fixed_ip_same_port(self):",
            "        with self.subnet() as private_sub:",
            "            ip_range = list(netaddr.IPNetwork(private_sub['subnet']['cidr']))",
            "            fixed_ip = [{'ip_address': str(ip_range[-3])}]",
            "            with self.port(subnet=private_sub, fixed_ips=fixed_ip) as p:",
            "                with self.router() as r:",
            "                    with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                        self._set_net_external(",
            "                            public_sub['subnet']['network_id'])",
            "                        self._add_external_gateway_to_router(",
            "                            r['router']['id'],",
            "                            public_sub['subnet']['network_id'])",
            "                        self._router_interface_action(",
            "                            'add', r['router']['id'],",
            "                            private_sub['subnet']['id'], None)",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'])",
            "                        fip2 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'])",
            "                        # 1. Update floating IP 1 with port_id and fixed_ip",
            "                        body_1 = self._update(",
            "                            'floatingips', fip1['floatingip']['id'],",
            "                            {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': str(ip_range[-3])}",
            "                             })",
            "                        self.assertEqual(str(ip_range[-3]),",
            "                            body_1['floatingip']['fixed_ip_address'])",
            "                        self.assertEqual(p['port']['id'],",
            "                            body_1['floatingip']['port_id'])",
            "                        # 2. Update floating IP 2 with port_id and fixed_ip",
            "                        # mock out the sequential check",
            "                        plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                        check_get = mock.patch(",
            "                            plugin + '._check_and_get_fip_assoc',",
            "                            fip=fip2, floating_db=mock.ANY,",
            "                            return_value=(p['port']['id'], str(ip_range[-3]),",
            "                                          r['router']['id']))",
            "                        check_and_get = check_get.start()",
            "                        # do regular _check_and_get_fip_assoc() after skip",
            "                        check_and_get.side_effect = check_get.stop()",
            "                        self._update(",
            "                            'floatingips', fip2['floatingip']['id'],",
            "                            {'floatingip':",
            "                                {'port_id': p['port']['id'],",
            "                                 'fixed_ip_address': str(ip_range[-3])",
            "                                 }}, exc.HTTPConflict.code)",
            "                        body = self._show('floatingips',",
            "                                          fip2['floatingip']['id'])",
            "                        self.assertIsNone(",
            "                            body['floatingip']['fixed_ip_address'])",
            "                        self.assertIsNone(",
            "                            body['floatingip']['port_id'])",
            "",
            "    def test_create_multiple_floatingips_same_fixed_ip_same_port(self):",
            "        '''This tests that if multiple API requests arrive to create",
            "        floating IPs on same external network to same port with one",
            "        fixed ip, the latter API requests would be blocked at",
            "        database side.",
            "        '''",
            "        with self.router() as r:",
            "            with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "",
            "                with self.subnet() as private_sub:",
            "                    ip_range = list(netaddr.IPNetwork(",
            "                        private_sub['subnet']['cidr']))",
            "                    fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                                {'ip_address': str(ip_range[-2])}]",
            "",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    with self.port(subnet=private_sub,",
            "                                   fixed_ips=fixed_ips) as p:",
            "                        # 1. Create floating IP 1",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]))",
            "                        # 2. Create floating IP 2",
            "                        # mock out the sequential check",
            "                        plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                        check_get = mock.patch(",
            "                            plugin + '._check_and_get_fip_assoc',",
            "                            fip=mock.ANY, floating_db=mock.ANY,",
            "                            return_value=(p['port']['id'], str(ip_range[-3]),",
            "                                          r['router']['id']))",
            "                        check_and_get = check_get.start()",
            "                        # do regular _check_and_get_fip_assoc() after skip",
            "                        check_and_get.side_effect = check_get.stop()",
            "                        self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]),",
            "                            http_status=exc.HTTPConflict.code)",
            "                        # Test that floating IP 1 is successfully created",
            "                        body = self._show('floatingips',",
            "                                          fip1['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip1['floatingip']['port_id'])",
            "",
            "                    self._delete('ports', p['port']['id'])",
            "                    # Test that port has been successfully deleted.",
            "                    body = self._show('ports', p['port']['id'],",
            "                                      expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_first_floatingip_associate_notification(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    body = self._update('floatingips',",
            "                                        fip['floatingip']['id'],",
            "                                        {'floatingip': {'port_id': port_id}})",
            "                    fip_addr = fip['floatingip']['floating_ip_address']",
            "                    fip_network_id = fip['floatingip']['floating_network_id']",
            "                    fip_id = fip['floatingip']['id']",
            "                    router_id = body['floatingip']['router_id']",
            "                    body = self._show('routers', router_id)",
            "                    notify.assert_any_call(resources.FLOATING_IP,",
            "                                           events.AFTER_UPDATE,",
            "                                           mock.ANY,",
            "                                           context=mock.ANY,",
            "                                           fixed_ip_address=ip_address,",
            "                                           fixed_port_id=port_id,",
            "                                           floating_ip_address=fip_addr,",
            "                                           floating_network_id=fip_network_id,",
            "                                           last_known_router_id=None,",
            "                                           floating_ip_id=fip_id,",
            "                                           router_id=router_id)",
            "",
            "    def test_floatingip_disassociate_notification(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                port_id = p['port']['id']",
            "                body = self._update('floatingips',",
            "                                    fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    fip_addr = fip['floatingip']['floating_ip_address']",
            "                    fip_network_id = fip['floatingip']['floating_network_id']",
            "                    fip_id = fip['floatingip']['id']",
            "                    router_id = body['floatingip']['router_id']",
            "                    self._update('floatingips',",
            "                                 fip['floatingip']['id'],",
            "                                 {'floatingip': {'port_id': None}})",
            "                    notify.assert_any_call(resources.FLOATING_IP,",
            "                                           events.AFTER_UPDATE,",
            "                                           mock.ANY,",
            "                                           context=mock.ANY,",
            "                                           fixed_ip_address=None,",
            "                                           fixed_port_id=None,",
            "                                           floating_ip_address=fip_addr,",
            "                                           floating_network_id=fip_network_id,",
            "                                           last_known_router_id=router_id,",
            "                                           floating_ip_id=fip_id,",
            "                                           router_id=None)",
            "",
            "    def test_floatingip_association_on_unowned_router(self):",
            "        # create a router owned by one tenant and associate the FIP with a",
            "        # different tenant, assert that the FIP association succeeds",
            "        with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router(tenant_id='router-owner',",
            "                                 set_context=True) as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    self._make_floatingip(self.fmt,",
            "                                          public_sub['subnet']['network_id'],",
            "                                          port_id=private_port['port']['id'],",
            "                                          fixed_ip=None,",
            "                                          set_context=True)",
            "",
            "    def test_floatingip_update_different_router(self):",
            "        # Create subnet with different CIDRs to account for plugins which",
            "        # do not support overlapping IPs",
            "        with self.subnet(cidr='10.0.0.0/24') as s1,\\",
            "                self.subnet(cidr='10.0.1.0/24') as s2:",
            "            with self.port(subnet=s1) as p1, self.port(subnet=s2) as p2:",
            "                private_sub1 = {'subnet':",
            "                                {'id':",
            "                                 p1['port']['fixed_ips'][0]['subnet_id']}}",
            "                private_sub2 = {'subnet':",
            "                                {'id':",
            "                                 p2['port']['fixed_ips'][0]['subnet_id']}}",
            "                with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                    with self.floatingip_no_assoc_with_public_sub(",
            "                        private_sub1,",
            "                        public_sub=public_sub) as (fip1, r1),\\",
            "                            self.floatingip_no_assoc_with_public_sub(",
            "                                private_sub2,",
            "                                public_sub=public_sub) as (fip2, r2):",
            "",
            "                        def assert_no_assoc(fip):",
            "                            body = self._show('floatingips',",
            "                                              fip['floatingip']['id'])",
            "                            self.assertIsNone(body['floatingip']['port_id'])",
            "                            self.assertIsNone(",
            "                                body['floatingip']['fixed_ip_address'])",
            "",
            "                        assert_no_assoc(fip1)",
            "                        assert_no_assoc(fip2)",
            "",
            "                        def associate_and_assert(fip, port):",
            "                            port_id = port['port']['id']",
            "                            ip_address = (port['port']['fixed_ips']",
            "                                          [0]['ip_address'])",
            "                            body = self._update(",
            "                                'floatingips', fip['floatingip']['id'],",
            "                                {'floatingip': {'port_id': port_id}})",
            "                            self.assertEqual(port_id,",
            "                                             body['floatingip']['port_id'])",
            "                            self.assertEqual(",
            "                                ip_address,",
            "                                body['floatingip']['fixed_ip_address'])",
            "                            return body['floatingip']['router_id']",
            "",
            "                        fip1_r1_res = associate_and_assert(fip1, p1)",
            "                        self.assertEqual(fip1_r1_res, r1['router']['id'])",
            "                        # The following operation will associate the floating",
            "                        # ip to a different router",
            "                        fip1_r2_res = associate_and_assert(fip1, p2)",
            "                        self.assertEqual(fip1_r2_res, r2['router']['id'])",
            "                        fip2_r1_res = associate_and_assert(fip2, p1)",
            "                        self.assertEqual(fip2_r1_res, r1['router']['id'])",
            "                        # disassociate fip1",
            "                        self._update(",
            "                            'floatingips', fip1['floatingip']['id'],",
            "                            {'floatingip': {'port_id': None}})",
            "                        fip2_r2_res = associate_and_assert(fip2, p2)",
            "                        self.assertEqual(fip2_r2_res, r2['router']['id'])",
            "",
            "    def test_floatingip_update_different_port_owner_as_admin(self):",
            "        with self.subnet() as private_sub:",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                with self.port(subnet=private_sub, tenant_id='other') as p:",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                        {'floatingip':",
            "                                         {'port_id': p['port']['id']}})",
            "                    self.assertEqual(p['port']['id'],",
            "                                     body['floatingip']['port_id'])",
            "",
            "    def test_floatingip_port_delete(self):",
            "        with self.subnet() as private_sub:",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                with self.port(subnet=private_sub) as p:",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                        {'floatingip':",
            "                                         {'port_id': p['port']['id']}})",
            "                # note: once this port goes out of scope, the port will be",
            "                # deleted, which is what we want to test. We want to confirm",
            "                # that the fields are set back to None",
            "                self._delete('ports', p['port']['id'])",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertEqual(body['floatingip']['id'],",
            "                                 fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertIsNone(body['floatingip']['router_id'])",
            "",
            "    def test_two_fips_one_port_invalid_return_409(self):",
            "        with self.floatingip_with_assoc() as fip1:",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                fip1['floatingip']['floating_network_id'],",
            "                fip1['floatingip']['port_id'])",
            "            self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_floating_ip_direct_port_delete_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_FLOATINGIP:",
            "                    self._delete('ports', p['id'],",
            "                                 expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "        self.assertTrue(found)",
            "",
            "    def _test_floatingip_with_invalid_create_port(self, plugin_class):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                res = self._create_router(self.fmt, _uuid())",
            "                r = self.deserialize(self.fmt, res)",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "                self._router_interface_action(",
            "                    'add', r['router']['id'],",
            "                    private_sub['subnet']['id'],",
            "                    None)",
            "",
            "                with mock.patch(plugin_class + '.create_port') as createport:",
            "                    createport.return_value = {'fixed_ips': [], 'id': '44'}",
            "                    res = self._create_floatingip(",
            "                        self.fmt, public_sub['subnet']['network_id'],",
            "                        port_id=p['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_floatingip_with_invalid_create_port(self):",
            "        self._test_floatingip_with_invalid_create_port(",
            "            'neutron.db.db_base_plugin_v2.NeutronDbPluginV2')",
            "",
            "    def test_create_floatingip_with_subnet_id_non_admin(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.router():",
            "                res = self._create_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'],",
            "                    subnet_id=public_sub['subnet']['id'],",
            "                    set_context=True)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "",
            "    def test_create_floatingip_with_subnet_id_and_fip_address(self):",
            "        with self.network() as ext_net:",
            "            self._set_net_external(ext_net['network']['id'])",
            "            with self.subnet(ext_net, cidr='10.10.10.0/24') as ext_subnet:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        ext_net['network']['id'],",
            "                        subnet_id=ext_subnet['subnet']['id'],",
            "                        floating_ip='10.10.10.100')",
            "                    fip = self.deserialize(self.fmt, res)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        self.assertEqual('10.10.10.100',",
            "                         fip['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_subnet_and_invalid_fip_address(self):",
            "        with self.network() as ext_net:",
            "            self._set_net_external(ext_net['network']['id'])",
            "            with self.subnet(ext_net, cidr='10.10.10.0/24') as ext_subnet:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        ext_net['network']['id'],",
            "                        subnet_id=ext_subnet['subnet']['id'],",
            "                        floating_ip='20.20.20.200')",
            "                    data = self.deserialize(self.fmt, res)",
            "        self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "        msg = str(n_exc.InvalidIpForSubnet(ip_address='20.20.20.200'))",
            "        self.assertEqual('InvalidIpForSubnet', data['NeutronError']['type'])",
            "        self.assertEqual(msg, data['NeutronError']['message'])",
            "",
            "    def test_create_floatingip_with_multisubnet_id(self):",
            "        with self.network() as network:",
            "            self._set_net_external(network['network']['id'])",
            "            with self.subnet(network, cidr='10.0.12.0/24') as subnet1:",
            "                with self.subnet(network, cidr='10.0.13.0/24') as subnet2:",
            "                    with self.router():",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            subnet1['subnet']['network_id'],",
            "                            subnet_id=subnet1['subnet']['id'])",
            "                        fip1 = self.deserialize(self.fmt, res)",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            subnet1['subnet']['network_id'],",
            "                            subnet_id=subnet2['subnet']['id'])",
            "                        fip2 = self.deserialize(self.fmt, res)",
            "        self.assertTrue(",
            "            fip1['floatingip']['floating_ip_address'].startswith('10.0.12'))",
            "        self.assertTrue(",
            "            fip2['floatingip']['floating_ip_address'].startswith('10.0.13'))",
            "",
            "    def test_create_floatingip_with_wrong_subnet_id(self):",
            "        with self.network() as network1:",
            "            self._set_net_external(network1['network']['id'])",
            "            with self.subnet(network1, cidr='10.0.12.0/24') as subnet1:",
            "                with self.network() as network2:",
            "                    self._set_net_external(network2['network']['id'])",
            "                    with self.subnet(network2, cidr='10.0.13.0/24') as subnet2:",
            "                        with self.router():",
            "                            res = self._create_floatingip(",
            "                                self.fmt,",
            "                                subnet1['subnet']['network_id'],",
            "                                subnet_id=subnet2['subnet']['id'])",
            "        self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_no_ext_gateway_return_404(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'])",
            "                    # this should be some kind of error",
            "                    self.assertEqual(exc.HTTPNotFound.code, res.status_int)",
            "",
            "    def test_create_floating_non_ext_network_returns_400(self):",
            "        with self.subnet() as public_sub:",
            "            # normally we would set the network of public_sub to be",
            "            # external, but the point of this test is to handle when",
            "            # that is not the case",
            "            with self.router():",
            "                res = self._create_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'])",
            "                self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_no_public_subnet_returns_400(self):",
            "        with self.network() as public_network:",
            "            with self.port() as private_port:",
            "                with self.router() as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                  private_sub['subnet']['id'],",
            "                                                  None)",
            "",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_network['network']['id'],",
            "                        port_id=private_port['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_floating_network_id_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, 'iamnotanuuid',",
            "                                      uuidutils.generate_uuid(), '192.168.0.1')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_floating_port_id_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      'iamnotanuuid', '192.168.0.1')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_fixed_ip_address_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      uuidutils.generate_uuid(), 'iamnotnanip')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_fixed_ipv6_address_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      uuidutils.generate_uuid(), '2001:db8::a')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_floatingip_list_with_sort(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_sort('floatingip', (fp3, fp2, fp1),",
            "                                      [('floating_ip_address', 'desc')])",
            "",
            "    def test_floatingip_list_with_port_id(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            port_id = fip['floatingip']['port_id']",
            "            res = self._list('floatingips',",
            "                             query_params=\"port_id=%s\" % port_id)",
            "            self.assertEqual(1, len(res['floatingips']))",
            "            res = self._list('floatingips', query_params=\"port_id=aaa\")",
            "            self.assertEqual(0, len(res['floatingips']))",
            "",
            "    def test_floatingip_list_with_pagination(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_pagination(",
            "                'floatingip', (fp1, fp2, fp3),",
            "                ('floating_ip_address', 'asc'), 2, 2)",
            "",
            "    def test_floatingip_list_with_pagination_reverse(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_pagination_reverse(",
            "                'floatingip', (fp1, fp2, fp3),",
            "                ('floating_ip_address', 'asc'), 2, 2)",
            "",
            "    def test_floatingip_multi_external_one_internal(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as exs2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as ins1:",
            "            network_ex_id1 = exs1['subnet']['network_id']",
            "            network_ex_id2 = exs2['subnet']['network_id']",
            "            self._set_net_external(network_ex_id1)",
            "            self._set_net_external(network_ex_id2)",
            "",
            "            r2i_fixed_ips = [{'ip_address': '12.0.0.2'}]",
            "            with self.router() as r1,\\",
            "                    self.router() as r2,\\",
            "                    self.port(subnet=ins1,",
            "                              fixed_ips=r2i_fixed_ips) as r2i_port:",
            "                self._add_external_gateway_to_router(",
            "                    r1['router']['id'],",
            "                    network_ex_id1)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins1['subnet']['id'],",
            "                                              None)",
            "                self._add_external_gateway_to_router(",
            "                    r2['router']['id'],",
            "                    network_ex_id2)",
            "                self._router_interface_action('add', r2['router']['id'],",
            "                                              None,",
            "                                              r2i_port['port']['id'])",
            "",
            "                with self.port(subnet=ins1,",
            "                               fixed_ips=[{'ip_address': '12.0.0.3'}]",
            "                               ) as private_port:",
            "",
            "                    fp1 = self._make_floatingip(self.fmt, network_ex_id1,",
            "                                            private_port['port']['id'])",
            "                    fp2 = self._make_floatingip(self.fmt, network_ex_id2,",
            "                                            private_port['port']['id'])",
            "                    self.assertEqual(fp1['floatingip']['router_id'],",
            "                                     r1['router']['id'])",
            "                    self.assertEqual(fp2['floatingip']['router_id'],",
            "                                     r2['router']['id'])",
            "",
            "    def test_floatingip_same_external_and_internal(self):",
            "        # Select router with subnet's gateway_ip for floatingip when",
            "        # routers connected to same subnet and external network.",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\", gateway_ip=\"12.0.0.50\") as ins:",
            "            network_ex_id = exs['subnet']['network_id']",
            "            self._set_net_external(network_ex_id)",
            "",
            "            r2i_fixed_ips = [{'ip_address': '12.0.0.2'}]",
            "            with self.router() as r1,\\",
            "                    self.router() as r2,\\",
            "                    self.port(subnet=ins,",
            "                              fixed_ips=r2i_fixed_ips) as r2i_port:",
            "                self._add_external_gateway_to_router(",
            "                    r1['router']['id'],",
            "                    network_ex_id)",
            "                self._router_interface_action('add', r2['router']['id'],",
            "                                              None,",
            "                                              r2i_port['port']['id'])",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins['subnet']['id'],",
            "                                              None)",
            "                self._add_external_gateway_to_router(",
            "                    r2['router']['id'],",
            "                    network_ex_id)",
            "",
            "                with self.port(subnet=ins,",
            "                               fixed_ips=[{'ip_address': '12.0.0.8'}]",
            "                               ) as private_port:",
            "",
            "                    fp = self._make_floatingip(self.fmt, network_ex_id,",
            "                                            private_port['port']['id'])",
            "                    self.assertEqual(r1['router']['id'],",
            "                                     fp['floatingip']['router_id'])",
            "",
            "    def _test_floatingip_via_router_interface(self, http_status):",
            "        # NOTE(yamamoto): \"exs\" subnet is just to provide a gateway port",
            "        # for the router.  Otherwise the test would fail earlier without",
            "        # reaching the code we want to test. (bug 1556884)",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs, \\",
            "            self.subnet(cidr=\"10.0.1.0/24\") as ins1, \\",
            "            self.subnet(cidr=\"10.0.2.0/24\") as ins2:",
            "            network_ex_id = exs['subnet']['network_id']",
            "            self._set_net_external(network_ex_id)",
            "            network_in2_id = ins2['subnet']['network_id']",
            "            self._set_net_external(network_in2_id)",
            "            with self.router() as r1, self.port(subnet=ins1) as private_port:",
            "                self._add_external_gateway_to_router(r1['router']['id'],",
            "                                                     network_ex_id)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins1['subnet']['id'], None)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins2['subnet']['id'], None)",
            "                self._make_floatingip(self.fmt,",
            "                                      network_id=network_in2_id,",
            "                                      port_id=private_port['port']['id'],",
            "                                      http_status=http_status)",
            "",
            "    def _get_router_for_floatingip_without_device_owner_check(",
            "            self, context, internal_port,",
            "            internal_subnet, external_network_id):",
            "        gw_port = orm.aliased(models_v2.Port, name=\"gw_port\")",
            "        routerport_qry = context.session.query(",
            "            l3_models.RouterPort.router_id,",
            "            models_v2.IPAllocation.ip_address",
            "        ).join(",
            "            models_v2.Port, models_v2.IPAllocation",
            "        ).filter(",
            "            models_v2.Port.network_id == internal_port['network_id'],",
            "            l3_models.RouterPort.port_type.in_(",
            "                lib_constants.ROUTER_INTERFACE_OWNERS",
            "            ),",
            "            models_v2.IPAllocation.subnet_id == internal_subnet['id']",
            "        ).join(",
            "            gw_port, gw_port.device_id == l3_models.RouterPort.router_id",
            "        ).filter(",
            "            gw_port.network_id == external_network_id,",
            "        ).distinct()",
            "",
            "        first_router_id = None",
            "        for router_id, interface_ip in routerport_qry:",
            "            if interface_ip == internal_subnet['gateway_ip']:",
            "                return router_id",
            "            if not first_router_id:",
            "                first_router_id = router_id",
            "        if first_router_id:",
            "            return first_router_id",
            "",
            "        raise l3_exc.ExternalGatewayForFloatingIPNotFound(",
            "            subnet_id=internal_subnet['id'],",
            "            external_network_id=external_network_id,",
            "            port_id=internal_port['id'])",
            "",
            "    def test_floatingip_via_router_interface_returns_404(self):",
            "        self._test_floatingip_via_router_interface(exc.HTTPNotFound.code)",
            "",
            "    def test_floatingip_via_router_interface_returns_201(self):",
            "        # Override get_router_for_floatingip, as",
            "        # networking-midonet's L3 service plugin would do.",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with mock.patch.object(plugin, \"get_router_for_floatingip\",",
            "            self._get_router_for_floatingip_without_device_owner_check):",
            "            self._test_floatingip_via_router_interface(exc.HTTPCreated.code)",
            "",
            "    def test_floatingip_delete_router_intf_with_subnet_id_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_ROUTER_INTF:",
            "                    subnet_id = p['fixed_ips'][0]['subnet_id']",
            "                    router_id = p['device_id']",
            "                    self._router_interface_action(",
            "                        'remove', router_id, subnet_id, None,",
            "                        expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "                    break",
            "        self.assertTrue(found)",
            "",
            "    def test_floatingip_delete_router_intf_with_port_id_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_ROUTER_INTF:",
            "                    router_id = p['device_id']",
            "                    self._router_interface_action(",
            "                        'remove', router_id, None, p['id'],",
            "                        expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "                    break",
            "        self.assertTrue(found)",
            "",
            "    def _test_router_delete_subnet_inuse_returns_409(self, router, subnet):",
            "        r, s = router, subnet",
            "        self._router_interface_action('add',",
            "                                      r['router']['id'],",
            "                                      s['subnet']['id'],",
            "                                      None)",
            "        # subnet cannot be deleted as it's attached to a router",
            "        self._delete('subnets', s['subnet']['id'],",
            "                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def _ipv6_subnet(self, mode):",
            "        return self.subnet(cidr='fd00::1/64', gateway_ip='fd00::1',",
            "                           ip_version=6,",
            "                           ipv6_ra_mode=mode,",
            "                           ipv6_address_mode=mode)",
            "",
            "    def test_router_delete_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_router_delete_ipv6_slaac_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self._ipv6_subnet(lib_constants.IPV6_SLAAC) as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_router_delete_dhcpv6_stateless_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self._ipv6_subnet(lib_constants.DHCPV6_STATELESS) as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_delete_ext_net_with_disassociated_floating_ips(self):",
            "        with self.network() as net:",
            "            net_id = net['network']['id']",
            "            self._set_net_external(net_id)",
            "            with self.subnet(network=net):",
            "                self._make_floatingip(self.fmt, net_id)",
            "",
            "    def test_create_floatingip_with_specific_ip(self):",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            fp = self._make_floatingip(self.fmt, network_id,",
            "                                       floating_ip='10.0.0.10')",
            "            self.assertEqual('10.0.0.10',",
            "                             fp['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_specific_ip_out_of_allocation(self):",
            "        with self.subnet(cidr='10.0.0.0/24',",
            "                         allocation_pools=[",
            "                             {'start': '10.0.0.10', 'end': '10.0.0.20'}]",
            "                         ) as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            fp = self._make_floatingip(self.fmt, network_id,",
            "                                       floating_ip='10.0.0.30')",
            "            self.assertEqual('10.0.0.30',",
            "                             fp['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_specific_ip_non_admin(self):",
            "        ctx = context.Context('user_id', 'tenant_id')",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  set_context=ctx,",
            "                                  floating_ip='10.0.0.10',",
            "                                  http_status=exc.HTTPForbidden.code)",
            "",
            "    def test_create_floatingip_with_specific_ip_out_of_subnet(self):",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.1.10',",
            "                                  http_status=exc.HTTPBadRequest.code)",
            "",
            "    def test_create_floatingip_with_duplicated_specific_ip(self):",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.0.10')",
            "",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.0.10',",
            "                                  http_status=exc.HTTPConflict.code)",
            "",
            "    def test_create_floatingips_native_quotas(self):",
            "        quota = 1",
            "        cfg.CONF.set_override('quota_floatingip', quota, group='QUOTAS')",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                subnet_id=public_sub['subnet']['id'])",
            "            self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                subnet_id=public_sub['subnet']['id'])",
            "            self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_router_specify_id_backend(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        router_req = {'router': {'id': _uuid(), 'name': 'router',",
            "                                 'tenant_id': 'foo',",
            "                                 'admin_state_up': True}}",
            "        result = plugin.create_router(context.Context('', 'foo'), router_req)",
            "        self.assertEqual(router_req['router']['id'], result['id'])",
            "",
            "    def test_create_floatingip_ipv6_only_network_returns_400(self):",
            "        with self.subnet(cidr=\"2001:db8::/48\", ip_version=6) as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'])",
            "            self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_ipv6_and_ipv4_network_creates_ipv4(self):",
            "        with self.network() as n,\\",
            "                self.subnet(cidr=\"2001:db8::/48\", ip_version=6, network=n),\\",
            "                self.subnet(cidr=\"192.168.1.0/24\", ip_version=4, network=n):",
            "            self._set_net_external(n['network']['id'])",
            "            fip = self._make_floatingip(self.fmt, n['network']['id'])",
            "            fip_set = netaddr.IPSet(netaddr.IPNetwork(\"192.168.1.0/24\"))",
            "            fip_ip = fip['floatingip']['floating_ip_address']",
            "            self.assertIn(netaddr.IPAddress(fip_ip), fip_set)",
            "",
            "    def test_create_floatingip_with_assoc_to_ipv6_subnet(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.subnet(cidr=\"2001:db8::/48\",",
            "                             ip_version=6) as private_sub:",
            "                with self.port(subnet=private_sub) as private_port:",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_with_assoc_to_ipv4_and_ipv6_port(self):",
            "        with self.network() as n,\\",
            "                self.subnet(cidr='10.0.0.0/24', network=n) as s4,\\",
            "                self.subnet(cidr='2001:db8::/64', ip_version=6, network=n),\\",
            "                self.port(subnet=s4) as p:",
            "            self.assertEqual(2, len(p['port']['fixed_ips']))",
            "            ipv4_address = next(i['ip_address'] for i in",
            "                    p['port']['fixed_ips'] if",
            "                    netaddr.IPAddress(i['ip_address']).version == 4)",
            "            with self.floatingip_with_assoc(port_id=p['port']['id']) as fip:",
            "                self.assertEqual(fip['floatingip']['fixed_ip_address'],",
            "                                 ipv4_address)",
            "                floating_ip = netaddr.IPAddress(",
            "                        fip['floatingip']['floating_ip_address'])",
            "                self.assertEqual(4, floating_ip.version)",
            "",
            "    def test_create_router_gateway_fails_nested(self):",
            "        # Force _update_router_gw_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        ctx = context.Context('', 'foo')",
            "        data = {'router': {",
            "            'name': 'router1', 'admin_state_up': True,",
            "            'external_gateway_info': {'network_id': 'some_uuid'},",
            "            'tenant_id': 'some_tenant'}}",
            "",
            "        def mock_fail__update_router_gw_info(ctx, router_id, info,",
            "                                             router=None):",
            "            # Fail with breaking transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise n_exc.NeutronException",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=mock_fail__update_router_gw_info).start()",
            "",
            "        def create_router_with_transaction(ctx, data):",
            "            # Emulates what many plugins do",
            "            with ctx.session.begin(subtransactions=True):",
            "                plugin.create_router(ctx, data)",
            "",
            "        # Verify router doesn't persist on failure",
            "        self.assertRaises(n_exc.NeutronException,",
            "                          create_router_with_transaction, ctx, data)",
            "        routers = plugin.get_routers(ctx)",
            "        self.assertEqual(0, len(routers))",
            "",
            "    def test_create_router_gateway_fails_nested_delete_router_failed(self):",
            "        # Force _update_router_gw_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        ctx = context.Context('', 'foo')",
            "        data = {'router': {",
            "            'name': 'router1', 'admin_state_up': True,",
            "            'external_gateway_info': {'network_id': 'some_uuid'},",
            "            'tenant_id': 'some_tenant'}}",
            "",
            "        def mock_fail__update_router_gw_info(ctx, router_id, info,",
            "                                             router=None):",
            "            # Fail with breaking transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise n_exc.NeutronException",
            "",
            "        def mock_fail_delete_router(ctx, router_id):",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise Exception()",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=mock_fail__update_router_gw_info).start()",
            "        mock.patch.object(plugin, 'delete_router',",
            "                          mock_fail_delete_router).start()",
            "",
            "        def create_router_with_transaction(ctx, data):",
            "            # Emulates what many plugins do",
            "            with ctx.session.begin(subtransactions=True):",
            "                plugin.create_router(ctx, data)",
            "",
            "        # Verify router doesn't persist on failure",
            "        self.assertRaises(n_exc.NeutronException,",
            "                          create_router_with_transaction, ctx, data)",
            "        routers = plugin.get_routers(ctx)",
            "        self.assertEqual(0, len(routers))",
            "",
            "    def test_router_add_interface_by_port_fails_nested(self):",
            "        # Force _validate_router_port_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        orig_update_port = self.plugin.update_port",
            "",
            "        def mock_fail__validate_router_port_info(ctx, router, port_id):",
            "            # Fail with raising BadRequest exception",
            "            msg = \"Failure mocking...\"",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "        def mock_update_port_with_transaction(ctx, id, port):",
            "            # Update port within a sub-transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                orig_update_port(ctx, id, port)",
            "",
            "        def add_router_interface_with_transaction(ctx, router_id,",
            "                                                  interface_info):",
            "            # Call add_router_interface() within a sub-transaction",
            "            with ctx.session.begin():",
            "                plugin.add_router_interface(ctx, router_id, interface_info)",
            "",
            "        tenant_id = _uuid()",
            "        ctx = context.Context('', tenant_id)",
            "        with self.network(tenant_id=tenant_id) as network, (",
            "             self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id)) as router:",
            "            with self.subnet(network=network, cidr='10.0.0.0/24',",
            "                             tenant_id=tenant_id) as subnet:",
            "                fixed_ips = [{'subnet_id': subnet['subnet']['id']}]",
            "                with self.port(subnet=subnet, fixed_ips=fixed_ips,",
            "                               tenant_id=tenant_id) as port:",
            "                    mock.patch.object(",
            "                        self.plugin, 'update_port',",
            "                        side_effect=(",
            "                            mock_update_port_with_transaction)).start()",
            "                    mock.patch.object(",
            "                        plugin, '_validate_router_port_info',",
            "                        side_effect=(",
            "                            mock_fail__validate_router_port_info)).start()",
            "                    self.assertRaises(n_exc.BadRequest,",
            "                        add_router_interface_with_transaction,",
            "                        ctx, router['router']['id'],",
            "                        {'port_id': port['port']['id']})",
            "",
            "                    # fetch port and confirm device_id and device_owner",
            "                    body = self._show('ports', port['port']['id'])",
            "                    self.assertEqual('', body['port']['device_owner'])",
            "                    self.assertEqual('', body['port']['device_id'])",
            "",
            "    def test_update_subnet_gateway_for_external_net(self):",
            "        \"\"\"Test to make sure notification to routers occurs when the gateway",
            "            ip address of a subnet of the external network is changed.",
            "        \"\"\"",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not hasattr(plugin, 'l3_rpc_notifier'):",
            "            self.skipTest(\"Plugin does not support l3_rpc_notifier\")",
            "        # make sure the callback is registered.",
            "        registry.subscribe(",
            "            l3_db.L3RpcNotifierMixin._notify_subnet_gateway_ip_update,",
            "            resources.SUBNET,",
            "            events.AFTER_UPDATE)",
            "        with mock.patch.object(plugin.l3_rpc_notifier,",
            "                               'routers_updated') as chk_method:",
            "            with self.network() as network:",
            "                allocation_pools = [{'start': '120.0.0.3',",
            "                                     'end': '120.0.0.254'}]",
            "                with self.subnet(network=network,",
            "                                 gateway_ip='120.0.0.1',",
            "                                 allocation_pools=allocation_pools,",
            "                                 cidr='120.0.0.0/24') as subnet:",
            "                    kwargs = {",
            "                        'device_owner': lib_constants.DEVICE_OWNER_ROUTER_GW,",
            "                        'device_id': 'fake_device'}",
            "                    with self.port(subnet=subnet, **kwargs):",
            "                        data = {'subnet': {'gateway_ip': '120.0.0.2'}}",
            "                        req = self.new_update_request('subnets', data,",
            "                                                      subnet['subnet']['id'])",
            "                        res = self.deserialize(self.fmt,",
            "                                               req.get_response(self.api))",
            "                        self.assertEqual(data['subnet']['gateway_ip'],",
            "                                         res['subnet']['gateway_ip'])",
            "                        chk_method.assert_called_with(mock.ANY,",
            "                                                      ['fake_device'], None)",
            "",
            "    def test__notify_subnetpool_address_scope_update(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "",
            "        tenant_id = _uuid()",
            "        with mock.patch.object(",
            "            plugin, 'notify_routers_updated') as chk_method, \\",
            "                self.subnetpool(prefixes=['10.0.0.0/24'],",
            "                                admin=True, name='sp',",
            "                                tenant_id=tenant_id) as subnetpool, \\",
            "                self.router(tenant_id=tenant_id) as router, \\",
            "                self.network(tenant_id=tenant_id) as network:",
            "            subnetpool_id = subnetpool['subnetpool']['id']",
            "            data = {'subnet': {",
            "                    'network_id': network['network']['id'],",
            "                    'subnetpool_id': subnetpool_id,",
            "                    'prefixlen': 24,",
            "                    'ip_version': 4,",
            "                    'tenant_id': tenant_id}}",
            "            req = self.new_create_request('subnets', data)",
            "            subnet = self.deserialize(self.fmt, req.get_response(self.api))",
            "",
            "            admin_ctx = context.get_admin_context()",
            "            plugin.add_router_interface(",
            "                admin_ctx,",
            "                router['router']['id'], {'subnet_id': subnet['subnet']['id']})",
            "            l3_db.L3RpcNotifierMixin._notify_subnetpool_address_scope_update(",
            "                mock.ANY, mock.ANY, mock.ANY,",
            "                context=admin_ctx, subnetpool_id=subnetpool_id)",
            "            chk_method.assert_called_with(admin_ctx, [router['router']['id']])",
            "",
            "    def test_janitor_clears_orphaned_floatingip_port(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.network() as n:",
            "            # floating IP ports are initially created with a device ID of",
            "            # PENDING and are updated after the floating IP is actually",
            "            # created.",
            "            port_res = self._create_port(",
            "                self.fmt, n['network']['id'],",
            "                tenant_id=n['network']['tenant_id'], device_id='PENDING',",
            "                device_owner=lib_constants.DEVICE_OWNER_FLOATINGIP)",
            "            port = self.deserialize(self.fmt, port_res)",
            "            plugin._clean_garbage()",
            "            # first call should just have marked it as a candidate so port",
            "            # should still exist",
            "            port = self._show('ports', port['port']['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            # second call will delete the port since it has no associated",
            "            # floating IP",
            "            plugin._clean_garbage()",
            "            self._show('ports', port['port']['id'],",
            "                       expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_janitor_updates_port_device_id(self):",
            "        # if a server dies after the floating IP is created but before it",
            "        # updates the floating IP port device ID, the janitor will be",
            "        # responsible for updating the device ID to the correct value.",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.floatingip_with_assoc() as fip:",
            "            fip_port = self._list('ports',",
            "               query_params='device_owner=network:floatingip')['ports'][0]",
            "            # simulate a failed update by just setting the device_id of",
            "            # the fip port back to PENDING",
            "            data = {'port': {'device_id': 'PENDING'}}",
            "            self._update('ports', fip_port['id'], data)",
            "            plugin._clean_garbage()",
            "            # first call just marks as candidate, so it shouldn't be changed",
            "            port = self._show('ports', fip_port['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            # second call updates device ID to fip",
            "            plugin._clean_garbage()",
            "            # first call just marks as candidate, so it shouldn't be changed",
            "            port = self._show('ports', fip_port['id'])",
            "            self.assertEqual(fip['floatingip']['id'],",
            "                             port['port']['device_id'])",
            "",
            "    def test_janitor_doesnt_delete_if_fixed_in_interim(self):",
            "        # here we ensure that the janitor doesn't delete the port on the second",
            "        # call if the conditions have been fixed",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.network() as n:",
            "            port_res = self._create_port(",
            "                self.fmt, n['network']['id'],",
            "                tenant_id=n['network']['tenant_id'], device_id='PENDING',",
            "                device_owner=lib_constants.DEVICE_OWNER_FLOATINGIP)",
            "            port = self.deserialize(self.fmt, port_res)",
            "            plugin._clean_garbage()",
            "            # first call should just have marked it as a candidate so port",
            "            # should still exist",
            "            port = self._show('ports', port['port']['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            data = {'port': {'device_id': 'something_else'}}",
            "            self._update('ports', port['port']['id'], data)",
            "            # now that the device ID has changed, the janitor shouldn't delete",
            "            plugin._clean_garbage()",
            "            self._show('ports', port['port']['id'])",
            "",
            "    def test_router_delete_callback(self):",
            "        def prevent_router_deletion(*args, **kwargs):",
            "            # unsubscribe now that we have invoked the callback",
            "            registry.unsubscribe(prevent_router_deletion, resources.ROUTER,",
            "                                 events.BEFORE_DELETE)",
            "            raise exc.HTTPForbidden",
            "",
            "        registry.subscribe(prevent_router_deletion, resources.ROUTER,",
            "                           events.BEFORE_DELETE)",
            "",
            "        with self.subnet():",
            "            res = self._create_router(self.fmt, _uuid())",
            "            router = self.deserialize(self.fmt, res)",
            "            self._delete('routers', router['router']['id'],",
            "                         exc.HTTPForbidden.code)",
            "",
            "    def test_associate_to_dhcp_port_fails(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\", ip_version=4) as sub:",
            "            with self.port(subnet=sub,",
            "                           device_owner=lib_constants.DEVICE_OWNER_DHCP) as p:",
            "                res = self._create_floatingip(",
            "                     self.fmt,",
            "                     sub['subnet']['network_id'],",
            "                     port_id=p['port']['id'])",
            "                self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "",
            "class L3AgentDbTestCaseBase(L3NatTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent.\"\"\"",
            "",
            "    def test_l3_agent_routers_query_interfaces(self):",
            "        with self.router() as r:",
            "            with self.port() as p:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              None,",
            "                                              p['port']['id'])",
            "",
            "                routers = self.plugin.get_sync_data(",
            "                    context.get_admin_context(), None)",
            "                self.assertEqual(1, len(routers))",
            "                interfaces = routers[0][lib_constants.INTERFACE_KEY]",
            "                self.assertEqual(1, len(interfaces))",
            "                subnets = interfaces[0]['subnets']",
            "                self.assertEqual(1, len(subnets))",
            "                subnet_id = subnets[0]['id']",
            "                wanted_subnetid = p['port']['fixed_ips'][0]['subnet_id']",
            "                self.assertEqual(wanted_subnetid, subnet_id)",
            "",
            "    def test_l3_agent_sync_interfaces(self):",
            "        \"\"\"Test L3 interfaces query return valid result\"\"\"",
            "        with self.router() as router1, self.router() as router2:",
            "            with self.port() as port1, self.port() as port2:",
            "                self._router_interface_action('add',",
            "                                              router1['router']['id'],",
            "                                              None,",
            "                                              port1['port']['id'])",
            "                self._router_interface_action('add',",
            "                                              router2['router']['id'],",
            "                                              None,",
            "                                              port2['port']['id'])",
            "                admin_ctx = context.get_admin_context()",
            "                router1_id = router1['router']['id']",
            "                router2_id = router2['router']['id']",
            "",
            "                # Verify if router1 pass in, return only interface from router1",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx,",
            "                                                          [router1_id])",
            "                self.assertEqual(1, len(ifaces))",
            "                self.assertEqual(router1_id,",
            "                                 ifaces[0]['device_id'])",
            "",
            "                # Verify if router1 and router2 pass in, return both interfaces",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx,",
            "                                                          [router1_id,",
            "                                                           router2_id])",
            "                self.assertEqual(2, len(ifaces))",
            "                device_list = [i['device_id'] for i in ifaces]",
            "                self.assertIn(router1_id, device_list)",
            "                self.assertIn(router2_id, device_list)",
            "",
            "                # Verify if no router pass in, return empty list",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx, None)",
            "                self.assertEqual(0, len(ifaces))",
            "",
            "    def test_l3_agent_routers_query_ignore_interfaces_with_moreThanOneIp(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='9.0.1.0/24') as subnet:",
            "                with self.port(subnet=subnet,",
            "                               fixed_ips=[{'ip_address': '9.0.1.3'}]) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    port = {'port': {'fixed_ips':",
            "                                     [{'ip_address': '9.0.1.4',",
            "                                       'subnet_id': subnet['subnet']['id']},",
            "                                      {'ip_address': '9.0.1.5',",
            "                                       'subnet_id': subnet['subnet']['id']}]}}",
            "                    ctx = context.get_admin_context()",
            "                    self.core_plugin.update_port(ctx, p['port']['id'], port)",
            "                    routers = self.plugin.get_sync_data(ctx, None)",
            "                    self.assertEqual(1, len(routers))",
            "                    interfaces = routers[0].get(lib_constants.INTERFACE_KEY,",
            "                                                [])",
            "                    self.assertEqual(1, len(interfaces))",
            "",
            "    def test_l3_agent_routers_query_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                routers = self.plugin.get_sync_data(",
            "                    context.get_admin_context(), [r['router']['id']])",
            "                self.assertEqual(1, len(routers))",
            "                gw_port = routers[0]['gw_port']",
            "                subnets = gw_port.get('subnets')",
            "                self.assertEqual(1, len(subnets))",
            "                self.assertEqual(s['subnet']['id'], subnets[0]['id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "",
            "    def test_l3_agent_routers_query_floatingips(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            routers = self.plugin.get_sync_data(",
            "                context.get_admin_context(), [fip['floatingip']['router_id']])",
            "            self.assertEqual(1, len(routers))",
            "            floatingips = routers[0][lib_constants.FLOATINGIP_KEY]",
            "            self.assertEqual(1, len(floatingips))",
            "            self.assertEqual(floatingips[0]['id'],",
            "                             fip['floatingip']['id'])",
            "            self.assertEqual(floatingips[0]['port_id'],",
            "                             fip['floatingip']['port_id'])",
            "            self.assertIsNotNone(floatingips[0]['fixed_ip_address'])",
            "            self.assertIsNotNone(floatingips[0]['router_id'])",
            "",
            "    def _test_notify_op_agent(self, target_func, *args):",
            "        l3_rpc_agent_api_str = (",
            "            'neutron.api.rpc.agentnotifiers.l3_rpc_agent_api.L3AgentNotifyAPI')",
            "        with mock.patch(l3_rpc_agent_api_str):",
            "            plugin = directory.get_plugin(plugin_constants.L3)",
            "            notifyApi = plugin.l3_rpc_notifier",
            "            kargs = [item for item in args]",
            "            kargs.append(notifyApi)",
            "            target_func(*kargs)",
            "",
            "    def _test_router_gateway_op_agent(self, notifyApi):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self.assertEqual(",
            "                    2, notifyApi.routers_updated.call_count)",
            "",
            "    def test_router_gateway_op_agent(self):",
            "        self._test_notify_op_agent(self._test_router_gateway_op_agent)",
            "",
            "    def _test_interfaces_op_agent(self, r, notifyApi):",
            "        with self.port() as p:",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "            # clean-up",
            "            self._router_interface_action('remove',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "        self.assertEqual(2, notifyApi.routers_updated.call_count)",
            "",
            "    def test_interfaces_op_agent(self):",
            "        with self.router() as r:",
            "            self._test_notify_op_agent(",
            "                self._test_interfaces_op_agent, r)",
            "",
            "    def _test_floatingips_op_agent(self, notifyApi):",
            "        with self.floatingip_with_assoc():",
            "            pass",
            "        # add gateway, add interface, associate, deletion of floatingip",
            "        self.assertEqual(4, notifyApi.routers_updated.call_count)",
            "",
            "    def test_floatingips_op_agent(self):",
            "        self._test_notify_op_agent(self._test_floatingips_op_agent)",
            "",
            "    def test_floatingips_create_precommit_event(self):",
            "        fake_method = mock.Mock()",
            "        try:",
            "            registry.subscribe(fake_method, resources.FLOATING_IP,",
            "                               events.PRECOMMIT_CREATE)",
            "            with self.floatingip_with_assoc() as f:",
            "                fake_method.assert_called_once_with(",
            "                    resources.FLOATING_IP, events.PRECOMMIT_CREATE, mock.ANY,",
            "                    context=mock.ANY, floatingip=mock.ANY,",
            "                    floatingip_id=f['floatingip']['id'],",
            "                    floatingip_db=mock.ANY)",
            "        finally:",
            "            registry.unsubscribe(fake_method, resources.FLOATING_IP,",
            "                                 events.PRECOMMIT_CREATE)",
            "",
            "    def test_router_create_precommit_event(self):",
            "        nset = lambda *a, **k: setattr(k['router_db'], 'name', 'hello')",
            "        registry.subscribe(nset, resources.ROUTER, events.PRECOMMIT_CREATE)",
            "        with self.router() as r:",
            "            self.assertEqual('hello', r['router']['name'])",
            "",
            "    def test_router_create_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 404",
            "        e404 = mock.Mock(side_effect=l3_exc.RouterNotFound(router_id='1'))",
            "        registry.subscribe(e404, resources.ROUTER, events.PRECOMMIT_CREATE)",
            "        res = self._create_router(self.fmt, 'tenid')",
            "        self.assertEqual(exc.HTTPNotFound.code, res.status_int)",
            "        # make sure nothing committed",
            "        body = self._list('routers')",
            "        self.assertFalse(body['routers'])",
            "",
            "    def test_router_update_precommit_event(self):",
            "",
            "        def _nset(r, v, s, payload=None):",
            "            setattr(payload.desired_state, 'name',",
            "                    payload.states[0]['name'] + '_ha!')",
            "",
            "        registry.subscribe(_nset, resources.ROUTER, events.PRECOMMIT_UPDATE)",
            "        with self.router(name='original') as r:",
            "            update = self._update('routers', r['router']['id'],",
            "                                  {'router': {'name': 'hi'}})",
            "            # our rude callback should have changed the name to the original",
            "            # plus some extra",
            "            self.assertEqual('original_ha!', update['router']['name'])",
            "",
            "    def test_router_update_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 404",
            "        e404 = mock.Mock(side_effect=l3_exc.RouterNotFound(router_id='1'))",
            "        registry.subscribe(e404, resources.ROUTER, events.PRECOMMIT_UPDATE)",
            "        with self.router(name='a') as r:",
            "            self._update('routers', r['router']['id'],",
            "                         {'router': {'name': 'hi'}},",
            "                         expected_code=exc.HTTPNotFound.code)",
            "        # ensure it stopped the commit",
            "        new = self._show('routers', r['router']['id'])",
            "        self.assertEqual('a', new['router']['name'])",
            "",
            "    def test_router_delete_precommit_event(self):",
            "        deleted = []",
            "        auditor = lambda *a, **k: deleted.append(k['router_id'])",
            "        registry.subscribe(auditor, resources.ROUTER, events.PRECOMMIT_DELETE)",
            "        with self.router() as r:",
            "            self._delete('routers', r['router']['id'])",
            "        self.assertEqual([r['router']['id']], deleted)",
            "",
            "    def test_router_delete_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 409",
            "        e409 = mock.Mock(side_effect=l3_exc.RouterInUse(router_id='1'))",
            "        registry.subscribe(e409, resources.ROUTER, events.PRECOMMIT_DELETE)",
            "        with self.router() as r:",
            "            self._delete('routers', r['router']['id'],",
            "                         expected_code=exc.HTTPConflict.code)",
            "        # ensure it stopped the commit",
            "        self.assertTrue(self._show('routers', r['router']['id']))",
            "",
            "",
            "class L3BaseForIntTests(test_db_base_plugin_v2.NeutronDbPluginV2TestCase):",
            "",
            "    mock_rescheduling = True",
            "",
            "    def setUp(self, plugin=None, ext_mgr=None, service_plugins=None):",
            "        if not plugin:",
            "            plugin = 'neutron.tests.unit.extensions.test_l3.TestL3NatIntPlugin'",
            "        # for these tests we need to enable overlapping ips",
            "        cfg.CONF.set_default('allow_overlapping_ips', True)",
            "        ext_mgr = ext_mgr or L3TestExtensionManager()",
            "",
            "        if self.mock_rescheduling:",
            "            mock.patch('%s._check_router_needs_rescheduling' % plugin,",
            "                       new=lambda *a: False).start()",
            "",
            "        super(L3BaseForIntTests, self).setUp(plugin=plugin, ext_mgr=ext_mgr,",
            "                                             service_plugins=service_plugins)",
            "",
            "        self.setup_notification_driver()",
            "",
            "",
            "class L3BaseForSepTests(test_db_base_plugin_v2.NeutronDbPluginV2TestCase):",
            "",
            "    def setUp(self, plugin=None, ext_mgr=None):",
            "        # the plugin without L3 support",
            "        if not plugin:",
            "            plugin = 'neutron.tests.unit.extensions.test_l3.TestNoL3NatPlugin'",
            "        # the L3 service plugin",
            "        l3_plugin = ('neutron.tests.unit.extensions.test_l3.'",
            "                     'TestL3NatServicePlugin')",
            "        service_plugins = {'l3_plugin_name': l3_plugin}",
            "",
            "        # for these tests we need to enable overlapping ips",
            "        cfg.CONF.set_default('allow_overlapping_ips', True)",
            "        if not ext_mgr:",
            "            ext_mgr = L3TestExtensionManager()",
            "        super(L3BaseForSepTests, self).setUp(plugin=plugin, ext_mgr=ext_mgr,",
            "                                             service_plugins=service_plugins)",
            "",
            "        self.setup_notification_driver()",
            "",
            "",
            "class L3NatDBIntAgentSchedulingTestCase(L3BaseForIntTests,",
            "                                        L3NatTestCaseMixin,",
            "                                        test_agent.",
            "                                        AgentDBTestMixIn):",
            "",
            "    \"\"\"Unit tests for core plugin with L3 routing and scheduling integrated.\"\"\"",
            "",
            "    def setUp(self, plugin='neutron.tests.unit.extensions.test_l3.'",
            "                           'TestL3NatIntAgentSchedulingPlugin',",
            "              ext_mgr=None, service_plugins=None):",
            "        self.mock_rescheduling = False",
            "        super(L3NatDBIntAgentSchedulingTestCase, self).setUp(",
            "            plugin, ext_mgr, service_plugins)",
            "        self.adminContext = context.get_admin_context()",
            "",
            "    def _assert_router_on_agent(self, router_id, agent_host):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        agents = plugin.list_l3_agents_hosting_router(",
            "            self.adminContext, router_id)['agents']",
            "        self.assertEqual(1, len(agents))",
            "        self.assertEqual(agents[0]['host'], agent_host)",
            "",
            "    def test_update_gateway_agent_exists_supporting_network(self):",
            "        with self.router() as r, self.subnet() as s1, self.subnet() as s2:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "            helpers.register_l3_agent(",
            "                host='host1',",
            "                ext_net_id=s1['subnet']['network_id'])",
            "            helpers.register_l3_agent(",
            "                host='host2', internal_only=False,",
            "                ext_net_id=s2['subnet']['network_id'])",
            "            l3_rpc_cb.get_router_ids(self.adminContext,",
            "                                     host='host1')",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._set_net_external(s2['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s2['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host2')",
            "",
            "    def test_update_gateway_agent_exists_supporting_multiple_network(self):",
            "        with self.router() as r, self.subnet() as s1, self.subnet() as s2:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "            helpers.register_l3_agent(",
            "                host='host1',",
            "                ext_net_id=s1['subnet']['network_id'])",
            "            helpers.register_l3_agent(",
            "                host='host2', internal_only=False,",
            "                ext_net_id='', ext_bridge='')",
            "            l3_rpc_cb.get_router_ids(self.adminContext,",
            "                                     host='host1')",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._set_net_external(s2['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s2['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host2')",
            "",
            "    def test_router_update_gateway_scheduling_not_supported(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        mock.patch.object(plugin, 'router_supports_scheduling',",
            "                          return_value=False).start()",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    # this should pass even though there are multiple",
            "                    # external networks since no scheduling decision needs",
            "                    # to be made",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "",
            "    def test_router_update_gateway_no_eligible_l3_agent(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'],",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "",
            "",
            "class L3RpcCallbackTestCase(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(L3RpcCallbackTestCase, self).setUp()",
            "        self.mock_plugin = mock.patch.object(",
            "            l3_rpc.L3RpcCallback,",
            "            'plugin', new_callable=mock.PropertyMock).start()",
            "        self.mock_l3plugin = mock.patch.object(",
            "            l3_rpc.L3RpcCallback,",
            "            'l3plugin', new_callable=mock.PropertyMock).start()",
            "        self.l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "",
            "    def test__ensure_host_set_on_port_host_id_none(self):",
            "        port = {'id': 'id', portbindings.HOST_ID: 'somehost'}",
            "        self.l3_rpc_cb._ensure_host_set_on_port(None, None, port)",
            "        self.assertFalse(self.l3_rpc_cb.plugin.update_port.called)",
            "",
            "    def test__ensure_host_set_on_port_bad_bindings(self):",
            "        for b in (portbindings.VIF_TYPE_BINDING_FAILED,",
            "                  portbindings.VIF_TYPE_UNBOUND):",
            "            port = {'id': 'id', portbindings.HOST_ID: 'somehost',",
            "                    portbindings.VIF_TYPE: b}",
            "            self.l3_rpc_cb._ensure_host_set_on_port(None, 'somehost', port)",
            "            self.assertTrue(self.l3_rpc_cb.plugin.update_port.called)",
            "",
            "    def test__ensure_host_set_on_port_update_on_concurrent_delete(self):",
            "        port_id = 'foo_port_id'",
            "        port = {",
            "            'id': port_id,",
            "            'device_owner': DEVICE_OWNER_COMPUTE,",
            "            portbindings.HOST_ID: '',",
            "            portbindings.VIF_TYPE: portbindings.VIF_TYPE_BINDING_FAILED",
            "        }",
            "        router_id = 'foo_router_id'",
            "        self.l3_rpc_cb.plugin.update_port.side_effect = n_exc.PortNotFound(",
            "            port_id=port_id)",
            "        with mock.patch.object(l3_rpc.LOG, 'debug') as mock_log:",
            "            self.l3_rpc_cb._ensure_host_set_on_port(",
            "                mock.ANY, mock.ANY, port, router_id)",
            "        self.l3_rpc_cb.plugin.update_port.assert_called_once_with(",
            "            mock.ANY, port_id, {'port': {portbindings.HOST_ID: mock.ANY}})",
            "        self.assertTrue(mock_log.call_count)",
            "        expected_message = ('Port foo_port_id not found while updating '",
            "                            'agent binding for router foo_router_id.')",
            "        actual_message = mock_log.call_args[0][0] % mock_log.call_args[0][1]",
            "        self.assertEqual(expected_message, actual_message)",
            "",
            "",
            "class L3AgentDbIntTestCase(L3BaseForIntTests, L3AgentDbTestCaseBase):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent for",
            "    the case where core plugin implements L3 routing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3AgentDbIntTestCase, self).setUp()",
            "        self.core_plugin = TestL3NatIntPlugin()",
            "        self.plugin = self.core_plugin",
            "",
            "",
            "class L3AgentDbSepTestCase(L3BaseForSepTests, L3AgentDbTestCaseBase):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent for the",
            "    case where separate service plugin implements L3 routing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3AgentDbSepTestCase, self).setUp()",
            "        self.core_plugin = TestNoL3NatPlugin()",
            "        self.plugin = TestL3NatServicePlugin()",
            "",
            "",
            "class TestL3DbOperationBounds(test_db_base_plugin_v2.DbOperationBoundMixin,",
            "                              L3NatTestCaseMixin,",
            "                              ml2_base.ML2TestFramework):",
            "    def setUp(self):",
            "        super(TestL3DbOperationBounds, self).setUp()",
            "        ext_mgr = L3TestExtensionManager()",
            "        self.ext_api = test_extensions.setup_extensions_middleware(ext_mgr)",
            "        self.kwargs = self.get_api_kwargs()",
            "",
            "    def test_router_list_queries_constant(self):",
            "        with self.subnet(**self.kwargs) as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "",
            "            def router_maker():",
            "                ext_info = {'network_id': s['subnet']['network_id']}",
            "                res = self._create_router(",
            "                                    self.fmt,",
            "                                    arg_list=('external_gateway_info',),",
            "                                    external_gateway_info=ext_info,",
            "                                    **self.kwargs)",
            "                return self.deserialize(self.fmt, res)",
            "",
            "            self._assert_object_list_queries_constant(router_maker, 'routers')",
            "",
            "",
            "class TestL3DbOperationBoundsTenant(TestL3DbOperationBounds):",
            "    admin = False",
            "",
            "",
            "class L3NatDBTestCaseMixin(object):",
            "    \"\"\"L3_NAT_dbonly_mixin specific test cases.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3NatDBTestCaseMixin, self).setUp()",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "",
            "    def test_create_router_gateway_fails(self):",
            "        \"\"\"Force _update_router_gw_info failure and see",
            "        the exception is propagated.",
            "        \"\"\"",
            "",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        ctx = context.Context('', 'foo')",
            "",
            "        class MyException(Exception):",
            "            pass",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=MyException).start()",
            "        with self.network() as n:",
            "            data = {'router': {",
            "                'name': 'router1', 'admin_state_up': True,",
            "                'tenant_id': ctx.tenant_id,",
            "                'external_gateway_info': {'network_id': n['network']['id']}}}",
            "",
            "            self.assertRaises(MyException, plugin.create_router, ctx, data)",
            "            # Verify router doesn't persist on failure",
            "            routers = plugin.get_routers(ctx)",
            "            self.assertEqual(0, len(routers))",
            "",
            "",
            "class L3NatDBIntTestCase(L3BaseForIntTests, L3NatTestCaseBase,",
            "                         L3NatDBTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for core plugin with L3 routing integrated.\"\"\"",
            "    pass",
            "",
            "",
            "class L3NatDBSepTestCase(L3BaseForSepTests, L3NatTestCaseBase,",
            "                         L3NatDBTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for a separate L3 routing service plugin.\"\"\"",
            "",
            "    def test_port_deletion_prevention_handles_missing_port(self):",
            "        pl = directory.get_plugin(plugin_constants.L3)",
            "        self.assertIsNone(",
            "            pl.prevent_l3_port_deletion(context.get_admin_context(), 'fakeid')",
            "        )",
            "",
            "",
            "class L3TestExtensionManagerWithDNS(L3TestExtensionManager):",
            "",
            "    def get_resources(self):",
            "        return l3.L3.get_resources()",
            "",
            "",
            "class L3NatDBFloatingIpTestCaseWithDNS(L3BaseForSepTests, L3NatTestCaseMixin):",
            "    \"\"\"Unit tests for floating ip with external DNS integration\"\"\"",
            "",
            "    fmt = 'json'",
            "    DNS_NAME = 'test'",
            "    DNS_DOMAIN = 'test-domain.org.'",
            "    PUBLIC_CIDR = '11.0.0.0/24'",
            "    PRIVATE_CIDR = '10.0.0.0/24'",
            "    mock_client = mock.MagicMock()",
            "    mock_admin_client = mock.MagicMock()",
            "    MOCK_PATH = ('neutron.services.externaldns.drivers.'",
            "                 'designate.driver.get_clients')",
            "    mock_config = {'return_value': (mock_client, mock_admin_client)}",
            "    _extension_drivers = ['dns']",
            "",
            "    def setUp(self):",
            "        ext_mgr = L3TestExtensionManagerWithDNS()",
            "        plugin = 'neutron.plugins.ml2.plugin.Ml2Plugin'",
            "        cfg.CONF.set_override('extension_drivers',",
            "                              self._extension_drivers,",
            "                              group='ml2')",
            "        super(L3NatDBFloatingIpTestCaseWithDNS, self).setUp(plugin=plugin,",
            "                                                            ext_mgr=ext_mgr)",
            "        cfg.CONF.set_override('external_dns_driver', 'designate')",
            "        self.mock_client.reset_mock()",
            "        self.mock_admin_client.reset_mock()",
            "",
            "    def _create_network(self, fmt, name, admin_state_up,",
            "                        arg_list=None, set_context=False, tenant_id=None,",
            "                        **kwargs):",
            "        new_arg_list = ('dns_domain',)",
            "        if arg_list is not None:",
            "            new_arg_list = arg_list + new_arg_list",
            "        return super(L3NatDBFloatingIpTestCaseWithDNS,",
            "                     self)._create_network(fmt, name, admin_state_up,",
            "                                           arg_list=new_arg_list,",
            "                                           set_context=set_context,",
            "                                           tenant_id=tenant_id,",
            "                                           **kwargs)",
            "",
            "    def _create_port(self, fmt, name, admin_state_up,",
            "                     arg_list=None, set_context=False, tenant_id=None,",
            "                     **kwargs):",
            "        new_arg_list = ('dns_name',)",
            "        if arg_list is not None:",
            "            new_arg_list = arg_list + new_arg_list",
            "        return super(L3NatDBFloatingIpTestCaseWithDNS,",
            "                     self)._create_port(fmt, name, admin_state_up,",
            "                                        arg_list=new_arg_list,",
            "                                        set_context=set_context,",
            "                                        tenant_id=tenant_id,",
            "                                        **kwargs)",
            "",
            "    def _create_net_sub_port(self, dns_domain='', dns_name=''):",
            "        with self.network(dns_domain=dns_domain) as n:",
            "            with self.subnet(cidr=self.PRIVATE_CIDR, network=n) as private_sub:",
            "                with self.port(private_sub, dns_name=dns_name) as p:",
            "                    return n, private_sub, p",
            "",
            "    @contextlib.contextmanager",
            "    def _create_floatingip_with_dns(self, net_dns_domain='', port_dns_name='',",
            "                                    flip_dns_domain='', flip_dns_name='',",
            "                                    assoc_port=False, private_sub=None):",
            "",
            "        if private_sub is None:",
            "            n, private_sub, p = self._create_net_sub_port(",
            "                    dns_domain=net_dns_domain, dns_name=port_dns_name)",
            "",
            "        data = {'fmt': self.fmt}",
            "        data['dns_domain'] = flip_dns_domain",
            "        data['dns_name'] = flip_dns_name",
            "",
            "        # Set ourselves up to call the right function with",
            "        # the right arguments for the with block",
            "        if assoc_port:",
            "            data['tenant_id'] = n['network']['tenant_id']",
            "            data['port_id'] = p['port']['id']",
            "            create_floatingip = self.floatingip_with_assoc",
            "        else:",
            "            data['private_sub'] = private_sub",
            "            create_floatingip = self.floatingip_no_assoc",
            "",
            "        with create_floatingip(**data) as flip:",
            "            yield flip['floatingip']",
            "",
            "    @contextlib.contextmanager",
            "    def _create_floatingip_with_dns_on_update(self, net_dns_domain='',",
            "               port_dns_name='', flip_dns_domain='', flip_dns_name=''):",
            "        n, private_sub, p = self._create_net_sub_port(",
            "                dns_domain=net_dns_domain, dns_name=port_dns_name)",
            "        with self._create_floatingip_with_dns(flip_dns_domain=flip_dns_domain,",
            "                flip_dns_name=flip_dns_name, private_sub=private_sub) as flip:",
            "            flip_id = flip['id']",
            "            data = {'floatingip': {'port_id': p['port']['id']}}",
            "            req = self.new_update_request('floatingips', data, flip_id)",
            "            res = req.get_response(self._api_for_resource('floatingip'))",
            "            self.assertEqual(200, res.status_code)",
            "",
            "            floatingip = self.deserialize(self.fmt, res)['floatingip']",
            "            self.assertEqual(p['port']['id'], floatingip['port_id'])",
            "",
            "            yield flip",
            "",
            "    def _get_in_addr_zone_name(self, in_addr_name):",
            "        units = self._get_bytes_or_nybles_to_skip(in_addr_name)",
            "        return '.'.join(in_addr_name.split('.')[int(units):])",
            "",
            "    def _get_bytes_or_nybles_to_skip(self, in_addr_name):",
            "        if 'in-addr.arpa' in in_addr_name:",
            "            return ((",
            "                32 - cfg.CONF.designate.ipv4_ptr_zone_prefix_size) / 8)",
            "        return (128 - cfg.CONF.designate.ipv6_ptr_zone_prefix_size) / 4",
            "",
            "    def _get_in_addr(self, record):",
            "        in_addr_name = netaddr.IPAddress(record).reverse_dns",
            "        in_addr_zone_name = self._get_in_addr_zone_name(in_addr_name)",
            "        return in_addr_name, in_addr_zone_name",
            "",
            "    def _assert_recordset_created(self, floating_ip_address):",
            "        # The recordsets.create function should be called with:",
            "        # dns_domain, dns_name, 'A', ip_address ('A' for IPv4, 'AAAA' for IPv6)",
            "        self.mock_client.recordsets.create.assert_called_with(self.DNS_DOMAIN,",
            "                self.DNS_NAME, 'A', [floating_ip_address])",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floating_ip_address)",
            "        self.mock_admin_client.recordsets.create.assert_called_with(",
            "                in_addr_zone_name, in_addr_name, 'PTR',",
            "                ['%s.%s' % (self.DNS_NAME, self.DNS_DOMAIN)])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create(self, mock_args):",
            "        with self._create_floatingip_with_dns():",
            "            pass",
            "        self.mock_client.recordsets.create.assert_not_called()",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_flip_dns(self, mock_args):",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_net_port_dns(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_flip_and_net_port_dns(self, mock_args):",
            "        # If both network+port and the floating ip have dns domain and",
            "        # dns name, floating ip's information should take priority",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain='junkdomain.org.',",
            "                port_dns_name='junk', flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            floatingip = flip",
            "        # External DNS service should have been called with floating ip's",
            "        # dns information, not the network+port's dns information",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port(self, mock_args):",
            "        with self._create_floatingip_with_dns_on_update():",
            "            pass",
            "        self.mock_client.recordsets.create.assert_not_called()",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_flip_dns(self, mock_args):",
            "        with self._create_floatingip_with_dns_on_update(",
            "                flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_net_port_dns(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns_on_update(",
            "                net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_flip_and_net_port_dns(self,",
            "                                                                  mock_args):",
            "        # If both network+port and the floating ip have dns domain and",
            "        # dns name, floating ip's information should take priority",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns_on_update(",
            "                net_dns_domain='junkdomain.org.',",
            "                port_dns_name='junk',",
            "                flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_disassociate_port(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            fake_recordset = {'id': '',",
            "                    'records': [flip['floating_ip_address']]}",
            "            # This method is called during recordset deletion, which",
            "            # will fail unless the list function call returns something like",
            "            # this fake value",
            "            self.mock_client.recordsets.list.return_value = ([fake_recordset])",
            "            # Port gets disassociated if port_id is not in the request body",
            "            data = {'floatingip': {}}",
            "            req = self.new_update_request('floatingips', data, flip['id'])",
            "            res = req.get_response(self._api_for_resource('floatingip'))",
            "        floatingip = self.deserialize(self.fmt, res)['floatingip']",
            "        flip_port_id = floatingip['port_id']",
            "        self.assertEqual(200, res.status_code)",
            "        self.assertIsNone(flip_port_id)",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floatingip['floating_ip_address'])",
            "        self.mock_client.recordsets.delete.assert_called_with(",
            "                self.DNS_DOMAIN, '')",
            "        self.mock_admin_client.recordsets.delete.assert_called_with(",
            "                in_addr_zone_name, in_addr_name)",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_delete(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "            # This method is called during recordset deletion, which will",
            "            # fail unless the list function call returns something like",
            "            # this fake value",
            "            fake_recordset = {'id': '',",
            "                              'records': [floatingip['floating_ip_address']]}",
            "            self.mock_client.recordsets.list.return_value = [fake_recordset]",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floatingip['floating_ip_address'])",
            "        self.mock_client.recordsets.delete.assert_called_with(",
            "                self.DNS_DOMAIN, '')",
            "        self.mock_admin_client.recordsets.delete.assert_called_with(",
            "                in_addr_zone_name, in_addr_name)",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_no_PTR_record(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "",
            "        # Disabling this option should stop the admin client from creating",
            "        # PTR records. So set this option and make sure the admin client",
            "        # wasn't called to create any records",
            "        cfg.CONF.set_override('allow_reverse_dns_lookup', False,",
            "                              group='designate')",
            "",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "",
            "        self.mock_client.recordsets.create.assert_called_with(self.DNS_DOMAIN,",
            "                self.DNS_NAME, 'A', [floatingip['floating_ip_address']])",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])"
        ],
        "afterPatchFile": [
            "# Copyright 2012 VMware, Inc.",
            "# All rights reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "#",
            "",
            "import contextlib",
            "import copy",
            "",
            "import mock",
            "import netaddr",
            "from neutron_lib.api.definitions import external_net as extnet_apidef",
            "from neutron_lib.api.definitions import l3 as l3_apidef",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.callbacks import events",
            "from neutron_lib.callbacks import exceptions",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources",
            "from neutron_lib import constants as lib_constants",
            "from neutron_lib import context",
            "from neutron_lib import exceptions as n_exc",
            "from neutron_lib.exceptions import l3 as l3_exc",
            "from neutron_lib.plugins import constants as plugin_constants",
            "from neutron_lib.plugins import directory",
            "from oslo_config import cfg",
            "from oslo_utils import importutils",
            "from oslo_utils import uuidutils",
            "from sqlalchemy import orm",
            "import testtools",
            "from webob import exc",
            "",
            "from neutron.api.rpc.agentnotifiers import l3_rpc_agent_api",
            "from neutron.api.rpc.handlers import l3_rpc",
            "from neutron.db import _resource_extend as resource_extend",
            "from neutron.db import common_db_mixin",
            "from neutron.db import db_base_plugin_v2",
            "from neutron.db import dns_db",
            "from neutron.db import external_net_db",
            "from neutron.db import l3_agentschedulers_db",
            "from neutron.db import l3_attrs_db",
            "from neutron.db import l3_db",
            "from neutron.db import l3_dvr_db",
            "from neutron.db import l3_dvrscheduler_db",
            "from neutron.db import l3_hamode_db",
            "from neutron.db.models import l3 as l3_models",
            "from neutron.db import models_v2",
            "from neutron.extensions import l3",
            "from neutron.services.revisions import revision_plugin",
            "from neutron.tests import base",
            "from neutron.tests.common import helpers",
            "from neutron.tests import fake_notifier",
            "from neutron.tests.unit.api import test_extensions",
            "from neutron.tests.unit.api.v2 import test_base",
            "from neutron.tests.unit.db import test_db_base_plugin_v2",
            "from neutron.tests.unit.extensions import base as test_extensions_base",
            "from neutron.tests.unit.extensions import test_agent",
            "from neutron.tests.unit.plugins.ml2 import base as ml2_base",
            "from neutron.tests.unit import testlib_api",
            "",
            "",
            "_uuid = uuidutils.generate_uuid",
            "_get_path = test_base._get_path",
            "",
            "",
            "DEVICE_OWNER_COMPUTE = lib_constants.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "",
            "class L3TestExtensionManager(object):",
            "",
            "    def get_resources(self):",
            "        return l3.L3.get_resources()",
            "",
            "    def get_actions(self):",
            "        return []",
            "",
            "    def get_request_extensions(self):",
            "        return []",
            "",
            "",
            "class L3NatExtensionTestCase(test_extensions_base.ExtensionTestCase):",
            "    fmt = 'json'",
            "",
            "    def setUp(self):",
            "        super(L3NatExtensionTestCase, self).setUp()",
            "        self.setup_extension(",
            "            'neutron.services.l3_router.l3_router_plugin.L3RouterPlugin',",
            "            plugin_constants.L3, l3.L3, '', allow_pagination=True,",
            "            allow_sorting=True, supported_extension_aliases=['router'],",
            "            use_quota=True)",
            "",
            "    def test_router_create(self):",
            "        router_id = _uuid()",
            "        tenant_id = _uuid()",
            "        data = {'router': {'name': 'router1', 'admin_state_up': True,",
            "                           'tenant_id': tenant_id, 'project_id': tenant_id,",
            "                           'external_gateway_info': None}}",
            "        return_value = copy.deepcopy(data['router'])",
            "        return_value.update({'status': \"ACTIVE\", 'id': router_id})",
            "",
            "        instance = self.plugin.return_value",
            "        instance.create_router.return_value = return_value",
            "        instance.get_routers_count.return_value = 0",
            "        res = self.api.post(_get_path('routers', fmt=self.fmt),",
            "                            self.serialize(data),",
            "                            content_type='application/%s' % self.fmt)",
            "        instance.create_router.assert_called_with(mock.ANY,",
            "                                                  router=data)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertTrue(router['admin_state_up'])",
            "",
            "    def test_router_list(self):",
            "        router_id = _uuid()",
            "        return_value = [{'name': 'router1', 'admin_state_up': True,",
            "                         'tenant_id': _uuid(), 'id': router_id}]",
            "",
            "        instance = self.plugin.return_value",
            "        instance.get_routers.return_value = return_value",
            "",
            "        res = self.api.get(_get_path('routers', fmt=self.fmt))",
            "",
            "        instance.get_routers.assert_called_with(mock.ANY, fields=mock.ANY,",
            "                                                filters=mock.ANY,",
            "                                                sorts=mock.ANY,",
            "                                                limit=mock.ANY,",
            "                                                marker=mock.ANY,",
            "                                                page_reverse=mock.ANY)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('routers', res)",
            "        self.assertEqual(1, len(res['routers']))",
            "        self.assertEqual(router_id, res['routers'][0]['id'])",
            "",
            "    def test_router_update(self):",
            "        router_id = _uuid()",
            "        update_data = {'router': {'admin_state_up': False}}",
            "        return_value = {'name': 'router1', 'admin_state_up': False,",
            "                        'tenant_id': _uuid(),",
            "                        'status': \"ACTIVE\", 'id': router_id}",
            "",
            "        instance = self.plugin.return_value",
            "        instance.update_router.return_value = return_value",
            "",
            "        res = self.api.put(_get_path('routers', id=router_id,",
            "                                     fmt=self.fmt),",
            "                           self.serialize(update_data))",
            "",
            "        instance.update_router.assert_called_with(mock.ANY, router_id,",
            "                                                  router=update_data)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertFalse(router['admin_state_up'])",
            "",
            "    def test_router_get(self):",
            "        router_id = _uuid()",
            "        return_value = {'name': 'router1', 'admin_state_up': False,",
            "                        'tenant_id': _uuid(),",
            "                        'status': \"ACTIVE\", 'id': router_id}",
            "",
            "        instance = self.plugin.return_value",
            "        instance.get_router.return_value = return_value",
            "",
            "        res = self.api.get(_get_path('routers', id=router_id,",
            "                                     fmt=self.fmt))",
            "",
            "        instance.get_router.assert_called_with(mock.ANY, router_id,",
            "                                               fields=mock.ANY)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('router', res)",
            "        router = res['router']",
            "        self.assertEqual(router_id, router['id'])",
            "        self.assertEqual(\"ACTIVE\", router['status'])",
            "        self.assertFalse(router['admin_state_up'])",
            "",
            "    def test_router_delete(self):",
            "        router_id = _uuid()",
            "",
            "        res = self.api.delete(_get_path('routers', id=router_id))",
            "",
            "        instance = self.plugin.return_value",
            "        instance.delete_router.assert_called_with(mock.ANY, router_id)",
            "        self.assertEqual(exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_router_add_interface(self):",
            "        router_id = _uuid()",
            "        subnet_id = _uuid()",
            "        port_id = _uuid()",
            "",
            "        interface_data = {'subnet_id': subnet_id}",
            "        return_value = copy.deepcopy(interface_data)",
            "        return_value['port_id'] = port_id",
            "",
            "        instance = self.plugin.return_value",
            "        instance.add_router_interface.return_value = return_value",
            "",
            "        path = _get_path('routers', id=router_id,",
            "                         action=\"add_router_interface\",",
            "                         fmt=self.fmt)",
            "        res = self.api.put(path, self.serialize(interface_data))",
            "",
            "        instance.add_router_interface.assert_called_with(mock.ANY, router_id,",
            "                                                         interface_data)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        res = self.deserialize(res)",
            "        self.assertIn('port_id', res)",
            "        self.assertEqual(port_id, res['port_id'])",
            "        self.assertEqual(subnet_id, res['subnet_id'])",
            "",
            "    def test_router_add_interface_empty_body(self):",
            "        router_id = _uuid()",
            "        instance = self.plugin.return_value",
            "",
            "        path = _get_path('routers', id=router_id,",
            "                         action=\"add_router_interface\",",
            "                         fmt=self.fmt)",
            "        res = self.api.put(path)",
            "        self.assertEqual(exc.HTTPOk.code, res.status_int)",
            "        instance.add_router_interface.assert_called_with(mock.ANY, router_id)",
            "",
            "",
            "# This base plugin class is for tests.",
            "class TestL3NatBasePlugin(db_base_plugin_v2.NeutronDbPluginV2,",
            "                          external_net_db.External_net_db_mixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    def create_network(self, context, network):",
            "        session = context.session",
            "        with session.begin(subtransactions=True):",
            "            net = super(TestL3NatBasePlugin, self).create_network(context,",
            "                                                                  network)",
            "            self._process_l3_create(context, net, network['network'])",
            "        return net",
            "",
            "    def update_network(self, context, id, network):",
            "",
            "        session = context.session",
            "        with session.begin(subtransactions=True):",
            "            net = super(TestL3NatBasePlugin, self).update_network(context, id,",
            "                                                                  network)",
            "            self._process_l3_update(context, net, network['network'])",
            "        return net",
            "",
            "    def delete_port(self, context, id, l3_port_check=True):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if plugin:",
            "            if l3_port_check:",
            "                plugin.prevent_l3_port_deletion(context, id)",
            "            plugin.disassociate_floatingips(context, id)",
            "        return super(TestL3NatBasePlugin, self).delete_port(context, id)",
            "",
            "",
            "# This plugin class is for tests with plugin that integrates L3.",
            "class TestL3NatIntPlugin(TestL3NatBasePlugin,",
            "                         l3_db.L3_NAT_db_mixin, dns_db.DNSDbMixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"external-net\", \"router\", \"dns-integration\"]",
            "",
            "",
            "# This plugin class is for tests with plugin that integrates L3 and L3 agent",
            "# scheduling.",
            "class TestL3NatIntAgentSchedulingPlugin(TestL3NatIntPlugin,",
            "                                        l3_agentschedulers_db.",
            "                                        L3AgentSchedulerDbMixin,",
            "                                        l3_hamode_db.L3_HA_NAT_db_mixin):",
            "",
            "    supported_extension_aliases = [\"external-net\", \"router\",",
            "                                   \"l3_agent_scheduler\"]",
            "    router_scheduler = importutils.import_object(",
            "        cfg.CONF.router_scheduler_driver)",
            "",
            "",
            "# This plugin class is for tests with plugin not supporting L3.",
            "class TestNoL3NatPlugin(TestL3NatBasePlugin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"external-net\"]",
            "",
            "",
            "# A L3 routing service plugin class for tests with plugins that",
            "# delegate away L3 routing functionality",
            "class TestL3NatServicePlugin(common_db_mixin.CommonDbMixin,",
            "                             l3_dvr_db.L3_NAT_with_dvr_db_mixin,",
            "                             l3_db.L3_NAT_db_mixin, dns_db.DNSDbMixin):",
            "",
            "    __native_pagination_support = True",
            "    __native_sorting_support = True",
            "",
            "    supported_extension_aliases = [\"router\", \"dns-integration\"]",
            "",
            "    @classmethod",
            "    def get_plugin_type(cls):",
            "        return plugin_constants.L3",
            "",
            "    def get_plugin_description(self):",
            "        return \"L3 Routing Service Plugin for testing\"",
            "",
            "",
            "# A L3 routing with L3 agent scheduling service plugin class for tests with",
            "# plugins that delegate away L3 routing functionality",
            "class TestL3NatAgentSchedulingServicePlugin(TestL3NatServicePlugin,",
            "                                            l3_dvrscheduler_db.",
            "                                            L3_DVRsch_db_mixin,",
            "                                            l3_hamode_db.L3_HA_NAT_db_mixin):",
            "",
            "    supported_extension_aliases = [\"router\", \"l3_agent_scheduler\"]",
            "",
            "    def __init__(self):",
            "        super(TestL3NatAgentSchedulingServicePlugin, self).__init__()",
            "        self.router_scheduler = importutils.import_object(",
            "            cfg.CONF.router_scheduler_driver)",
            "        self.agent_notifiers.update(",
            "            {lib_constants.AGENT_TYPE_L3: l3_rpc_agent_api.L3AgentNotifyAPI()})",
            "",
            "",
            "class L3NatTestCaseMixin(object):",
            "",
            "    def _create_router(self, fmt, tenant_id, name=None,",
            "                       admin_state_up=None, set_context=False,",
            "                       arg_list=None, **kwargs):",
            "        tenant_id = tenant_id or _uuid()",
            "        data = {'router': {'tenant_id': tenant_id}}",
            "        if name:",
            "            data['router']['name'] = name",
            "        if admin_state_up is not None:",
            "            data['router']['admin_state_up'] = admin_state_up",
            "        flavor_id = kwargs.get('flavor_id', None)",
            "        if flavor_id:",
            "            data['router']['flavor_id'] = flavor_id",
            "        for arg in (('admin_state_up', 'tenant_id',",
            "                     'availability_zone_hints') +",
            "                    (arg_list or ())):",
            "            # Arg must be present and not empty",
            "            if arg in kwargs:",
            "                data['router'][arg] = kwargs[arg]",
            "        router_req = self.new_create_request('routers', data, fmt)",
            "        if set_context and tenant_id:",
            "            # create a specific auth context for this request",
            "            router_req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "",
            "        return router_req.get_response(self.ext_api)",
            "",
            "    def _make_router(self, fmt, tenant_id, name=None, admin_state_up=None,",
            "                     external_gateway_info=None, set_context=False,",
            "                     arg_list=None, **kwargs):",
            "        if external_gateway_info:",
            "            arg_list = ('external_gateway_info', ) + (arg_list or ())",
            "        res = self._create_router(fmt, tenant_id, name,",
            "                                  admin_state_up, set_context,",
            "                                  arg_list=arg_list,",
            "                                  external_gateway_info=external_gateway_info,",
            "                                  **kwargs)",
            "        return self.deserialize(fmt, res)",
            "",
            "    def _add_external_gateway_to_router(self, router_id, network_id,",
            "                                        expected_code=exc.HTTPOk.code,",
            "                                        neutron_context=None, ext_ips=None):",
            "        ext_ips = ext_ips or []",
            "        body = {'router':",
            "                {'external_gateway_info': {'network_id': network_id}}}",
            "        if ext_ips:",
            "            body['router']['external_gateway_info'][",
            "                'external_fixed_ips'] = ext_ips",
            "        return self._update('routers', router_id, body,",
            "                            expected_code=expected_code,",
            "                            neutron_context=neutron_context)",
            "",
            "    def _remove_external_gateway_from_router(self, router_id, network_id,",
            "                                             expected_code=exc.HTTPOk.code,",
            "                                             external_gw_info=None):",
            "        return self._update('routers', router_id,",
            "                            {'router': {'external_gateway_info':",
            "                                        external_gw_info}},",
            "                            expected_code=expected_code)",
            "",
            "    def _router_interface_action(self, action, router_id, subnet_id, port_id,",
            "                                 expected_code=exc.HTTPOk.code,",
            "                                 expected_body=None,",
            "                                 tenant_id=None,",
            "                                 msg=None):",
            "        interface_data = {}",
            "        if subnet_id is not None:",
            "            interface_data.update({'subnet_id': subnet_id})",
            "        if port_id is not None:",
            "            interface_data.update({'port_id': port_id})",
            "",
            "        req = self.new_action_request('routers', interface_data, router_id,",
            "                                      \"%s_router_interface\" % action)",
            "        # if tenant_id was specified, create a tenant context for this request",
            "        if tenant_id:",
            "            req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "        res = req.get_response(self.ext_api)",
            "        self.assertEqual(expected_code, res.status_int, msg)",
            "        response = self.deserialize(self.fmt, res)",
            "        if expected_body:",
            "            self.assertEqual(expected_body, response, msg)",
            "        return response",
            "",
            "    @contextlib.contextmanager",
            "    def router(self, name='router1', admin_state_up=True,",
            "               fmt=None, tenant_id=None,",
            "               external_gateway_info=None, set_context=False,",
            "               **kwargs):",
            "        router = self._make_router(fmt or self.fmt, tenant_id, name,",
            "                                   admin_state_up, external_gateway_info,",
            "                                   set_context, **kwargs)",
            "        yield router",
            "",
            "    def _set_net_external(self, net_id):",
            "        self._update('networks', net_id,",
            "                     {'network': {extnet_apidef.EXTERNAL: True}})",
            "",
            "    def _create_floatingip(self, fmt, network_id, port_id=None,",
            "                           fixed_ip=None, set_context=False,",
            "                           floating_ip=None, subnet_id=None,",
            "                           tenant_id=None, **kwargs):",
            "        tenant_id = tenant_id or self._tenant_id",
            "        data = {'floatingip': {'floating_network_id': network_id,",
            "                               'tenant_id': tenant_id}}",
            "        if port_id:",
            "            data['floatingip']['port_id'] = port_id",
            "            if fixed_ip:",
            "                data['floatingip']['fixed_ip_address'] = fixed_ip",
            "",
            "        if floating_ip:",
            "            data['floatingip']['floating_ip_address'] = floating_ip",
            "",
            "        if subnet_id:",
            "            data['floatingip']['subnet_id'] = subnet_id",
            "",
            "        data['floatingip'].update(kwargs)",
            "",
            "        floatingip_req = self.new_create_request('floatingips', data, fmt)",
            "        if set_context and tenant_id:",
            "            # create a specific auth context for this request",
            "            floatingip_req.environ['neutron.context'] = context.Context(",
            "                '', tenant_id)",
            "        return floatingip_req.get_response(self.ext_api)",
            "",
            "    def _make_floatingip(self, fmt, network_id, port_id=None,",
            "                         fixed_ip=None, set_context=False, tenant_id=None,",
            "                         floating_ip=None, http_status=exc.HTTPCreated.code,",
            "                         **kwargs):",
            "        res = self._create_floatingip(fmt, network_id, port_id,",
            "                                      fixed_ip, set_context, floating_ip,",
            "                                      tenant_id=tenant_id, **kwargs)",
            "        self.assertEqual(http_status, res.status_int)",
            "        return self.deserialize(fmt, res)",
            "",
            "    def _validate_floating_ip(self, fip):",
            "        body = self._list('floatingips')",
            "        self.assertEqual(1, len(body['floatingips']))",
            "        self.assertEqual(body['floatingips'][0]['id'],",
            "                         fip['floatingip']['id'])",
            "",
            "        body = self._show('floatingips', fip['floatingip']['id'])",
            "        self.assertEqual(body['floatingip']['id'],",
            "                         fip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_with_assoc(self, port_id=None, fmt=None, fixed_ip=None,",
            "                              public_cidr='11.0.0.0/24', set_context=False,",
            "                              tenant_id=None, flavor_id=None, **kwargs):",
            "        with self.subnet(cidr=public_cidr,",
            "                         set_context=set_context,",
            "                         tenant_id=tenant_id) as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            args_list = {'set_context': set_context,",
            "                         'tenant_id': tenant_id}",
            "            if flavor_id:",
            "                args_list['flavor_id'] = flavor_id",
            "            private_port = None",
            "            if port_id:",
            "                private_port = self._show('ports', port_id)",
            "            with test_db_base_plugin_v2.optional_ctx(",
            "                    private_port, self.port,",
            "                    set_context=set_context,",
            "                    tenant_id=tenant_id) as private_port:",
            "                with self.router(**args_list) as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    floatingip = None",
            "",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    floatingip = self._make_floatingip(",
            "                        fmt or self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'],",
            "                        fixed_ip=fixed_ip,",
            "                        tenant_id=tenant_id,",
            "                        set_context=set_context,",
            "                        **kwargs)",
            "                    yield floatingip",
            "",
            "                    if floatingip:",
            "                        self._delete('floatingips',",
            "                                     floatingip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_no_assoc_with_public_sub(",
            "        self, private_sub, fmt=None, set_context=False,",
            "        public_sub=None, flavor_id=None, **kwargs):",
            "        self._set_net_external(public_sub['subnet']['network_id'])",
            "        args_list = {}",
            "        if flavor_id:",
            "            # NOTE(manjeets) Flavor id None is not accepted",
            "            # and return Flavor None not found error. So for",
            "            # neutron testing this argument should not be passed",
            "            # at all to router.",
            "            args_list['flavor_id'] = flavor_id",
            "        with self.router(**args_list) as r:",
            "            floatingip = None",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                public_sub['subnet']['network_id'])",
            "            self._router_interface_action('add', r['router']['id'],",
            "                                          private_sub['subnet']['id'],",
            "                                          None)",
            "",
            "            floatingip = self._make_floatingip(",
            "                fmt or self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                set_context=set_context,",
            "                **kwargs)",
            "            yield floatingip, r",
            "",
            "            if floatingip:",
            "                self._delete('floatingips',",
            "                             floatingip['floatingip']['id'])",
            "",
            "    @contextlib.contextmanager",
            "    def floatingip_no_assoc(self, private_sub, fmt=None,",
            "                            set_context=False, flavor_id=None, **kwargs):",
            "        with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "            with self.floatingip_no_assoc_with_public_sub(",
            "                private_sub, fmt, set_context, public_sub,",
            "                flavor_id, **kwargs) as (f, r):",
            "                # Yield only the floating ip object",
            "                yield f",
            "",
            "",
            "class ExtraAttributesMixinTestCase(testlib_api.SqlTestCase):",
            "",
            "    def setUp(self):",
            "        super(ExtraAttributesMixinTestCase, self).setUp()",
            "        self.mixin = l3_attrs_db.ExtraAttributesMixin()",
            "        directory.add_plugin(plugin_constants.L3, self.mixin)",
            "        self.ctx = context.get_admin_context()",
            "        self.router = l3_models.Router()",
            "        with self.ctx.session.begin():",
            "            self.ctx.session.add(self.router)",
            "",
            "    def _get_default_api_values(self):",
            "        return {k: v.get('transform_from_db', lambda x: x)(v['default'])",
            "                for k, v in l3_attrs_db.get_attr_info().items()}",
            "",
            "    def test_set_extra_attr_key_bad(self):",
            "        with testtools.ExpectedException(RuntimeError):",
            "            with self.ctx.session.begin():",
            "                self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                                'bad', 'value')",
            "",
            "    def test_set_attrs_and_extend_no_transaction(self):",
            "        with testtools.ExpectedException(RuntimeError):",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'ha_vr_id', 99)",
            "",
            "    def test__extend_extra_router_dict_defaults(self):",
            "        rdict = {}",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(self._get_default_api_values(), rdict)",
            "",
            "    def test_set_attrs_and_extend(self):",
            "        with self.ctx.session.begin():",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'ha_vr_id', 99)",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'availability_zone_hints',",
            "                                            ['x', 'y', 'z'])",
            "        expected = self._get_default_api_values()",
            "        expected.update({'ha_vr_id': 99,",
            "                         'availability_zone_hints': ['x', 'y', 'z']})",
            "        rdict = {}",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(expected, rdict)",
            "        with self.ctx.session.begin():",
            "            self.mixin.set_extra_attr_value(self.ctx, self.router,",
            "                                            'availability_zone_hints',",
            "                                            ['z', 'y', 'z'])",
            "        expected['availability_zone_hints'] = ['z', 'y', 'z']",
            "        self.mixin._extend_extra_router_dict(rdict, self.router)",
            "        self.assertEqual(expected, rdict)",
            "",
            "",
            "class L3NatTestCaseBase(L3NatTestCaseMixin):",
            "",
            "    def test_router_create(self):",
            "        name = 'router1'",
            "        tenant_id = _uuid()",
            "        expected_value = [('name', name), ('tenant_id', tenant_id),",
            "                          ('admin_state_up', True), ('status', 'ACTIVE'),",
            "                          ('external_gateway_info', None)]",
            "        with self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id) as router:",
            "            for k, v in expected_value:",
            "                self.assertEqual(router['router'][k], v)",
            "",
            "    def test_router_create_call_extensions(self):",
            "        self.extension_called = False",
            "",
            "        def _extend_router_dict_test_attr(*args, **kwargs):",
            "            self.extension_called = True",
            "",
            "        resource_extend.register_funcs(",
            "            l3_apidef.ROUTERS, [_extend_router_dict_test_attr])",
            "        self.assertFalse(self.extension_called)",
            "        with self.router():",
            "            self.assertTrue(self.extension_called)",
            "",
            "    def test_router_create_with_gwinfo(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            data = {'router': {'tenant_id': _uuid()}}",
            "            data['router']['name'] = 'router1'",
            "            data['router']['external_gateway_info'] = {",
            "                'network_id': s['subnet']['network_id']}",
            "            router_req = self.new_create_request('routers', data, self.fmt)",
            "            res = router_req.get_response(self.ext_api)",
            "            router = self.deserialize(self.fmt, res)",
            "            self.assertEqual(",
            "                s['subnet']['network_id'],",
            "                router['router']['external_gateway_info']['network_id'])",
            "",
            "    def test_router_create_with_gwinfo_ext_ip(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            ext_info = {",
            "                'network_id': s['subnet']['network_id'],",
            "                'external_fixed_ips': [{'ip_address': '10.0.0.99'}]",
            "            }",
            "            res = self._create_router(",
            "                self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                external_gateway_info=ext_info",
            "            )",
            "            router = self.deserialize(self.fmt, res)",
            "            self.assertEqual(",
            "                [{'ip_address': '10.0.0.99', 'subnet_id': s['subnet']['id']}],",
            "                router['router']['external_gateway_info'][",
            "                    'external_fixed_ips'])",
            "",
            "    def test_router_create_with_gwinfo_ext_ip_subnet(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as v1,\\",
            "                    self.subnet(network=n, cidr='1.0.0.0/24') as v2,\\",
            "                    self.subnet(network=n, cidr='2.0.0.0/24') as v3:",
            "                subnets = (v1, v2, v3)",
            "                self._set_net_external(n['network']['id'])",
            "                for s in subnets:",
            "                    ext_info = {",
            "                        'network_id': n['network']['id'],",
            "                        'external_fixed_ips': [",
            "                            {'subnet_id': s['subnet']['id']}]",
            "                    }",
            "                    res = self._create_router(",
            "                        self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                        external_gateway_info=ext_info",
            "                    )",
            "                    router = self.deserialize(self.fmt, res)",
            "                    ext_ips = router['router']['external_gateway_info'][",
            "                        'external_fixed_ips']",
            "",
            "                    self.assertEqual(",
            "                        [{'subnet_id': s['subnet']['id'],",
            "                          'ip_address': mock.ANY}], ext_ips)",
            "",
            "    def test_router_create_with_gwinfo_ext_ip_non_admin(self):",
            "        with self.subnet() as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            ext_info = {",
            "                'network_id': s['subnet']['network_id'],",
            "                'external_fixed_ips': [{'ip_address': '10.0.0.99'}]",
            "            }",
            "            res = self._create_router(",
            "                self.fmt, _uuid(), arg_list=('external_gateway_info',),",
            "                set_context=True, external_gateway_info=ext_info",
            "            )",
            "            self.assertEqual(exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_create_routers_native_quotas(self):",
            "        tenant_id = _uuid()",
            "        quota = 1",
            "        cfg.CONF.set_override('quota_router', quota, group='QUOTAS')",
            "        res = self._create_router(self.fmt, tenant_id)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        res = self._create_router(self.fmt, tenant_id)",
            "        self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_router_list(self):",
            "        with self.router() as v1, self.router() as v2, self.router() as v3:",
            "            routers = (v1, v2, v3)",
            "            self._test_list_resources('router', routers)",
            "",
            "    def test_router_list_with_parameters(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2:",
            "            query_params = 'name=router1'",
            "            self._test_list_resources('router', [router1],",
            "                                      query_params=query_params)",
            "            query_params = 'name=router2'",
            "            self._test_list_resources('router', [router2],",
            "                                      query_params=query_params)",
            "            query_params = 'name=router3'",
            "            self._test_list_resources('router', [],",
            "                                      query_params=query_params)",
            "",
            "    def test_router_list_with_sort(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_sort('router', (router3, router2, router1),",
            "                                      [('name', 'desc')])",
            "",
            "    def test_router_list_with_pagination(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_pagination('router',",
            "                                            (router1, router2, router3),",
            "                                            ('name', 'asc'), 2, 2)",
            "",
            "    def test_router_list_with_pagination_reverse(self):",
            "        with self.router(name='router1') as router1,\\",
            "                self.router(name='router2') as router2,\\",
            "                self.router(name='router3') as router3:",
            "            self._test_list_with_pagination_reverse('router',",
            "                                                    (router1, router2,",
            "                                                     router3),",
            "                                                    ('name', 'asc'), 2, 2)",
            "",
            "    def test_router_update(self):",
            "        rname1 = \"yourrouter\"",
            "        rname2 = \"nachorouter\"",
            "        with self.router(name=rname1) as r:",
            "            body = self._show('routers', r['router']['id'])",
            "            self.assertEqual(body['router']['name'], rname1)",
            "",
            "            body = self._update('routers', r['router']['id'],",
            "                                {'router': {'name': rname2}})",
            "",
            "            body = self._show('routers', r['router']['id'])",
            "            self.assertEqual(body['router']['name'], rname2)",
            "",
            "    def test_router_update_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "                    body = self._show('routers', r['router']['id'])",
            "                    net_id = (body['router']",
            "                              ['external_gateway_info']['network_id'])",
            "                    self.assertEqual(net_id, s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'])",
            "                    body = self._show('routers', r['router']['id'])",
            "                    net_id = (body['router']",
            "                              ['external_gateway_info']['network_id'])",
            "                    self.assertEqual(net_id, s2['subnet']['network_id'])",
            "                    # Validate that we can clear the gateway with",
            "                    # an empty dict, in any other case, we fall back",
            "                    # on None as default value",
            "                    self._remove_external_gateway_from_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'],",
            "                        external_gw_info={})",
            "",
            "    def test_router_update_gateway_with_external_ip_used_by_gw(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    ext_ips=[{'ip_address': s['subnet']['gateway_ip']}],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_invalid_external_ip(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    ext_ips=[{'ip_address': '99.99.99.99'}],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_invalid_external_subnet(self):",
            "        with self.subnet() as s1,\\",
            "                self.subnet(cidr='1.0.0.0/24') as s2,\\",
            "                self.router() as r:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'],",
            "                # this subnet is not on the same network so this should fail",
            "                ext_ips=[{'subnet_id': s2['subnet']['id']}],",
            "                expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_update_gateway_with_different_external_subnet(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1,\\",
            "                    self.subnet(network=n, cidr='1.0.0.0/24') as s2,\\",
            "                    self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                res2 = self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s2['subnet']['id']}])",
            "        fip1 = res1['router']['external_gateway_info']['external_fixed_ips'][0]",
            "        fip2 = res2['router']['external_gateway_info']['external_fixed_ips'][0]",
            "        self.assertEqual(s1['subnet']['id'], fip1['subnet_id'])",
            "        self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "        self.assertNotEqual(fip1['subnet_id'], fip2['subnet_id'])",
            "        self.assertNotEqual(fip1['ip_address'], fip2['ip_address'])",
            "",
            "    def test_router_update_gateway_with_existed_floatingip(self):",
            "        with self.subnet() as subnet:",
            "            self._set_net_external(subnet['subnet']['network_id'])",
            "            with self.floatingip_with_assoc() as fip:",
            "                self._add_external_gateway_to_router(",
            "                    fip['floatingip']['router_id'],",
            "                    subnet['subnet']['network_id'],",
            "                    expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_update_gateway_to_empty_with_existed_floatingip(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            self._remove_external_gateway_from_router(",
            "                fip['floatingip']['router_id'], None,",
            "                expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_update_gateway_add_multiple_prefixes_ipv6(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, \\",
            "                self.subnet(network=n, ip_version=6, cidr='2001:db8::/32') \\",
            "                as s2, (self.router()) as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                fip1 = (res1['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][0])",
            "                self.assertEqual(s1['subnet']['id'], fip1['subnet_id'])",
            "                res2 = self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'ip_address': fip1['ip_address'],",
            "                                  'subnet_id': s1['subnet']['id']},",
            "                                 {'subnet_id': s2['subnet']['id']}])",
            "                self.assertEqual(fip1, res2['router']['external_gateway_info']",
            "                                           ['external_fixed_ips'][0])",
            "                fip2 = (res2['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][1])",
            "                self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['subnet_id'],",
            "                                    fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['ip_address'],",
            "                                    fip2['ip_address'])",
            "",
            "    def test_router_concurrent_delete_upon_subnet_create(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'],",
            "                    ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                plugin = directory.get_plugin(plugin_constants.L3)",
            "                mock.patch.object(",
            "                    plugin, 'update_router',",
            "                    side_effect=l3_exc.RouterNotFound(router_id='1')).start()",
            "                # ensure the router disappearing doesn't interfere with subnet",
            "                # creation",
            "                self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                    ip_version=6, cidr='2001:db8::/32',",
            "                                    expected_res_status=(exc.HTTPCreated.code))",
            "",
            "    def test_router_update_gateway_upon_subnet_create_ipv6(self):",
            "        with self.network() as n:",
            "            with self.subnet(network=n) as s1, self.router() as r:",
            "                self._set_net_external(n['network']['id'])",
            "                res1 = self._add_external_gateway_to_router(",
            "                          r['router']['id'],",
            "                          n['network']['id'],",
            "                          ext_ips=[{'subnet_id': s1['subnet']['id']}])",
            "                fip1 = (res1['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][0])",
            "                sres = self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                         ip_version=6, cidr='2001:db8::/32',",
            "                                         expected_res_status=(",
            "                                             exc.HTTPCreated.code))",
            "                s2 = self.deserialize(self.fmt, sres)",
            "                res2 = self._show('routers', r['router']['id'])",
            "                self.assertEqual(fip1, res2['router']['external_gateway_info']",
            "                                           ['external_fixed_ips'][0])",
            "                fip2 = (res2['router']['external_gateway_info']",
            "                        ['external_fixed_ips'][1])",
            "                self.assertEqual(s2['subnet']['id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['subnet_id'], fip2['subnet_id'])",
            "                self.assertNotEqual(fip1['ip_address'], fip2['ip_address'])",
            "",
            "    def test_router_update_gateway_upon_subnet_create_max_ips_ipv6(self):",
            "        \"\"\"Create subnet should not cause excess fixed IPs on router gw",
            "",
            "        If a router gateway port has the maximum of one IPv4 and one IPv6",
            "        fixed, create subnet should not add any more IP addresses to the port",
            "        (unless this is the subnet is a SLAAC/DHCPv6-stateless subnet in which",
            "        case the addresses are added automatically)",
            "",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(cidr='10.0.0.0/24', network=n) as s1, (",
            "                    self.subnet(ip_version=6, cidr='2001:db8::/64',",
            "                        network=n)) as s2:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'],",
            "                        ext_ips=[{'subnet_id': s1['subnet']['id']},",
            "                                 {'subnet_id': s2['subnet']['id']}],",
            "                        expected_code=exc.HTTPOk.code)",
            "                res1 = self._show('routers', r['router']['id'])",
            "                original_fips = (res1['router']['external_gateway_info']",
            "                                 ['external_fixed_ips'])",
            "                # Add another IPv4 subnet - a fip SHOULD NOT be added",
            "                # to the external gateway port as it already has a v4 address",
            "                self._create_subnet(self.fmt, net_id=n['network']['id'],",
            "                                    cidr='10.0.1.0/24')",
            "                res2 = self._show('routers', r['router']['id'])",
            "                self.assertEqual(original_fips,",
            "                                 res2['router']['external_gateway_info']",
            "                                 ['external_fixed_ips'])",
            "                # Add a SLAAC subnet - a fip from this subnet SHOULD be added",
            "                # to the external gateway port",
            "                s3 = self.deserialize(self.fmt,",
            "                        self._create_subnet(self.fmt,",
            "                            net_id=n['network']['id'],",
            "                            ip_version=6, cidr='2001:db8:1::/64',",
            "                            ipv6_ra_mode=lib_constants.IPV6_SLAAC,",
            "                            ipv6_address_mode=lib_constants.IPV6_SLAAC))",
            "                res3 = self._show('routers', r['router']['id'])",
            "                fips = (res3['router']['external_gateway_info']",
            "                        ['external_fixed_ips'])",
            "                fip_subnet_ids = [fip['subnet_id'] for fip in fips]",
            "                self.assertIn(s1['subnet']['id'], fip_subnet_ids)",
            "                self.assertIn(s2['subnet']['id'], fip_subnet_ids)",
            "                self.assertIn(s3['subnet']['id'], fip_subnet_ids)",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "",
            "    def _test_router_add_interface_subnet(self, router, subnet, msg=None):",
            "        exp_notifications = ['router.create.start',",
            "                             'router.create.end',",
            "                             'network.create.start',",
            "                             'network.create.end',",
            "                             'subnet.create.start',",
            "                             'subnet.create.end',",
            "                             'router.interface.create',",
            "                             'router.interface.delete']",
            "        body = self._router_interface_action('add',",
            "                                             router['router']['id'],",
            "                                             subnet['subnet']['id'],",
            "                                             None)",
            "        self.assertIn('port_id', body, msg)",
            "",
            "        # fetch port and confirm device_id",
            "        r_port_id = body['port_id']",
            "        port = self._show('ports', r_port_id)",
            "        self.assertEqual(port['port']['device_id'],",
            "                         router['router']['id'], msg)",
            "",
            "        self._router_interface_action('remove',",
            "                                      router['router']['id'],",
            "                                      subnet['subnet']['id'],",
            "                                      None)",
            "        self._show('ports', r_port_id,",
            "                   expected_code=exc.HTTPNotFound.code)",
            "",
            "        self.assertEqual(",
            "            set(exp_notifications),",
            "            set(n['event_type'] for n in fake_notifier.NOTIFICATIONS), msg)",
            "",
            "        for n in fake_notifier.NOTIFICATIONS:",
            "            if n['event_type'].startswith('router.interface.'):",
            "                payload = n['payload']['router_interface']",
            "                self.assertIn('id', payload)",
            "                self.assertEqual(payload['id'], router['router']['id'])",
            "                self.assertIn('tenant_id', payload)",
            "                rtid = router['router']['tenant_id']",
            "                # tolerate subnet tenant deliberately set to '' in the",
            "                # nsx metadata access case",
            "                self.assertIn(payload['tenant_id'], [rtid, ''], msg)",
            "",
            "    def test_router_add_interface_bad_values(self):",
            "        with self.router() as r:",
            "            exp_code = exc.HTTPBadRequest.code",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          False,",
            "                                          None,",
            "                                          expected_code=exp_code)",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          False,",
            "                                          expected_code=exp_code)",
            "",
            "    def test_router_add_interface_subnet(self):",
            "        fake_notifier.reset()",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                with self.subnet(network=n) as s:",
            "                    self._test_router_add_interface_subnet(r, s)",
            "",
            "    def test_router_delete_race_with_interface_add(self):",
            "        # this test depends on protection from the revision plugin so",
            "        # we have to initialize it",
            "        revision_plugin.RevisionPlugin()",
            "        with self.router() as r, self.subnet() as s:",
            "",
            "            def jam_in_interface(*args, **kwargs):",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              s['subnet']['id'], None)",
            "                # unsubscribe now that the evil is done",
            "                registry.unsubscribe(jam_in_interface, resources.ROUTER,",
            "                                     events.PRECOMMIT_DELETE)",
            "            registry.subscribe(jam_in_interface, resources.ROUTER,",
            "                               events.PRECOMMIT_DELETE)",
            "            self._delete('routers', r['router']['id'],",
            "                         expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_add_interface_ipv6_subnet(self):",
            "        \"\"\"Test router-interface-add for valid ipv6 subnets.",
            "",
            "        Verify the valid use-cases of an IPv6 subnet where we",
            "        are allowed to associate to the Neutron Router are successful.",
            "        \"\"\"",
            "        slaac = lib_constants.IPV6_SLAAC",
            "        stateful = lib_constants.DHCPV6_STATEFUL",
            "        stateless = lib_constants.DHCPV6_STATELESS",
            "        use_cases = [{'msg': 'IPv6 Subnet Modes (slaac, none)',",
            "                      'ra_mode': slaac, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (none, none)',",
            "                      'ra_mode': None, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateful, none)',",
            "                      'ra_mode': stateful, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateless, none)',",
            "                      'ra_mode': stateless, 'address_mode': None},",
            "                     {'msg': 'IPv6 Subnet Modes (slaac, slaac)',",
            "                      'ra_mode': slaac, 'address_mode': slaac},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateful,'",
            "                      'dhcpv6-stateful)', 'ra_mode': stateful,",
            "                      'address_mode': stateful},",
            "                     {'msg': 'IPv6 Subnet Modes (dhcpv6-stateless,'",
            "                      'dhcpv6-stateless)', 'ra_mode': stateless,",
            "                      'address_mode': stateless}]",
            "        for uc in use_cases:",
            "            fake_notifier.reset()",
            "            with self.router() as r, self.network() as n:",
            "                with self.subnet(network=n, cidr='fd00::1/64',",
            "                                 gateway_ip='fd00::1', ip_version=6,",
            "                                 ipv6_ra_mode=uc['ra_mode'],",
            "                                 ipv6_address_mode=uc['address_mode']) as s:",
            "                    self._test_router_add_interface_subnet(r, s, uc['msg'])",
            "",
            "    def test_router_add_interface_multiple_ipv4_subnets(self):",
            "        \"\"\"Test router-interface-add for multiple ipv4 subnets.",
            "",
            "        Verify that adding multiple ipv4 subnets from the same network",
            "        to a router places them all on different router interfaces.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(network=n, cidr='10.0.0.0/24') as s1, (",
            "                 self.subnet(network=n, cidr='10.0.1.0/24')) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertNotEqual(pid1, pid2)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnets_same_net(self):",
            "        \"\"\"Test router-interface-add for multiple ipv6 subnets on a network.",
            "",
            "        Verify that adding multiple ipv6 subnets from the same network",
            "        to a router places them all on the same router interface.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with (self.subnet(network=n, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertEqual(pid1, pid2)",
            "                    port = self._show('ports', pid1)",
            "                    self.assertEqual(2, len(port['port']['fixed_ips']))",
            "                    port_subnet_ids = [fip['subnet_id'] for fip in",
            "                                       port['port']['fixed_ips']]",
            "                    self.assertIn(s1['subnet']['id'], port_subnet_ids)",
            "                    self.assertIn(s2['subnet']['id'], port_subnet_ids)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnets_different_net(self):",
            "        \"\"\"Test router-interface-add for ipv6 subnets on different networks.",
            "",
            "        Verify that adding multiple ipv6 subnets from different networks",
            "        to a router places them on different router interfaces.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n1, self.network() as n2:",
            "            with (self.subnet(network=n1, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n2, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s1['subnet']['id'],",
            "                                                         None)",
            "                    pid1 = body['port_id']",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s2['subnet']['id'],",
            "                                                         None)",
            "                    pid2 = body['port_id']",
            "                    self.assertNotEqual(pid1, pid2)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s1['subnet']['id'], None)",
            "                    self._router_interface_action('remove', r['router']['id'],",
            "                                                  s2['subnet']['id'], None)",
            "",
            "    def test_router_add_iface_ipv6_ext_ra_subnet_returns_400(self):",
            "        \"\"\"Test router-interface-add for in-valid ipv6 subnets.",
            "",
            "        Verify that an appropriate error message is displayed when",
            "        an IPv6 subnet configured to use an external_router for Router",
            "        Advertisements (i.e., ipv6_ra_mode is None and ipv6_address_mode",
            "        is not None) is attempted to associate with a Neutron Router.",
            "        \"\"\"",
            "        use_cases = [{'msg': 'IPv6 Subnet Modes (none, slaac)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.IPV6_SLAAC},",
            "                     {'msg': 'IPv6 Subnet Modes (none, dhcpv6-stateful)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.DHCPV6_STATEFUL},",
            "                     {'msg': 'IPv6 Subnet Modes (none, dhcpv6-stateless)',",
            "                      'ra_mode': None,",
            "                      'address_mode': lib_constants.DHCPV6_STATELESS}]",
            "        for uc in use_cases:",
            "            with self.router() as r, self.network() as n:",
            "                with self.subnet(network=n, cidr='fd00::1/64',",
            "                                 gateway_ip='fd00::1', ip_version=6,",
            "                                 ipv6_ra_mode=uc['ra_mode'],",
            "                                 ipv6_address_mode=uc['address_mode']) as s:",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=exp_code,",
            "                                                  msg=uc['msg'])",
            "",
            "    def test_router_add_interface_ipv6_subnet_without_gateway_ip(self):",
            "        with self.router() as r:",
            "            with self.subnet(ip_version=6, cidr='fe80::/64',",
            "                             gateway_ip=None) as s:",
            "                error_code = exc.HTTPBadRequest.code",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=error_code)",
            "",
            "    def test_router_add_interface_subnet_with_bad_tenant_returns_404(self):",
            "        tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id, set_context=True) as r:",
            "            with self.network(tenant_id=tenant_id, set_context=True) as n:",
            "                with self.subnet(network=n, set_context=True) as s:",
            "                    err_code = exc.HTTPNotFound.code",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=err_code,",
            "                                                  tenant_id='bad_tenant')",
            "                    body = self._router_interface_action('add',",
            "                                                         r['router']['id'],",
            "                                                         s['subnet']['id'],",
            "                                                         None)",
            "                    self.assertIn('port_id', body)",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=err_code,",
            "                                                  tenant_id='bad_tenant')",
            "",
            "    def test_router_add_interface_by_subnet_other_tenant_subnet_returns_400(",
            "            self):",
            "        router_tenant_id = _uuid()",
            "        with self.router(tenant_id=router_tenant_id, set_context=True) as r:",
            "            with self.network(shared=True) as n:",
            "                with self.subnet(network=n) as s:",
            "                    err_code = exc.HTTPBadRequest.code",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  None,",
            "                                                  expected_code=err_code,",
            "                                                  tenant_id=router_tenant_id)",
            "",
            "    def _test_router_add_interface_by_port_allocation_pool(",
            "            self, out_of_pool=False, router_action_as_admin=False,",
            "            expected_code=exc.HTTPOk.code):",
            "        router_tenant_id = _uuid()",
            "        with self.router(tenant_id=router_tenant_id, set_context=True) as r:",
            "            with self.network(shared=True) as n:",
            "                with self.subnet(network=n) as s1, (",
            "                     self.subnet(network=n, cidr='fd00::/64',",
            "                                 ip_version=6)) as s2, (",
            "                     self.subnet(network=n, cidr='fd01::/64',",
            "                                 ip_version=6)) as s3:",
            "                    fixed_ips = [{'subnet_id': s1['subnet']['id']},",
            "                                 {'subnet_id': s2['subnet']['id']},",
            "                                 {'subnet_id': s3['subnet']['id']}]",
            "                    if out_of_pool:",
            "                        fixed_ips[1] = {'subnet_id': s2['subnet']['id'],",
            "                                        'ip_address':",
            "                                            s2['subnet']['gateway_ip']}",
            "                    with self.port(subnet=s1, fixed_ips=fixed_ips,",
            "                                   tenant_id=router_tenant_id,",
            "                                   set_context=True) as p:",
            "                        kwargs = {'expected_code': expected_code}",
            "                        if not router_action_as_admin:",
            "                            kwargs['tenant_id'] = router_tenant_id",
            "                        self._router_interface_action(",
            "                            'add', r['router']['id'], None, p['port']['id'],",
            "                            **kwargs)",
            "",
            "    def test_router_add_interface_by_port_other_tenant_address_in_pool(",
            "            self):",
            "        self._test_router_add_interface_by_port_allocation_pool()",
            "",
            "    def test_router_add_interface_by_port_other_tenant_address_out_of_pool(",
            "            self):",
            "        self._test_router_add_interface_by_port_allocation_pool(",
            "            out_of_pool=True, expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_by_port_admin_address_out_of_pool(",
            "            self):",
            "        self._test_router_add_interface_by_port_allocation_pool(",
            "            out_of_pool=True, router_action_as_admin=True)",
            "",
            "    def test_router_add_interface_subnet_with_port_from_other_tenant(self):",
            "        tenant_id = _uuid()",
            "        other_tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id) as r,\\",
            "                self.network(tenant_id=tenant_id) as n1,\\",
            "                self.network(tenant_id=other_tenant_id) as n2:",
            "            with self.subnet(network=n1, cidr='10.0.0.0/24') as s1,\\",
            "                    self.subnet(network=n2, cidr='10.1.0.0/24') as s2:",
            "                body = self._router_interface_action(",
            "                    'add',",
            "                    r['router']['id'],",
            "                    s2['subnet']['id'],",
            "                    None)",
            "                self.assertIn('port_id', body)",
            "                self._router_interface_action(",
            "                    'add',",
            "                    r['router']['id'],",
            "                    s1['subnet']['id'],",
            "                    None,",
            "                    tenant_id=tenant_id)",
            "                self.assertIn('port_id', body)",
            "",
            "    def test_router_add_interface_port(self):",
            "        orig_update_port = self.plugin.update_port",
            "        with self.router() as r, (",
            "            self.port()) as p, (",
            "                mock.patch.object(self.plugin, 'update_port')) as update_port:",
            "            update_port.side_effect = orig_update_port",
            "            body = self._router_interface_action('add',",
            "                                                 r['router']['id'],",
            "                                                 None,",
            "                                                 p['port']['id'])",
            "            self.assertIn('port_id', body)",
            "            self.assertEqual(p['port']['id'], body['port_id'])",
            "            expected_port_update = {",
            "                'device_owner': lib_constants.DEVICE_OWNER_ROUTER_INTF,",
            "                'device_id': r['router']['id']}",
            "            update_port.assert_any_call(",
            "                mock.ANY, p['port']['id'], {'port': expected_port_update})",
            "            # fetch port and confirm device_id",
            "            body = self._show('ports', p['port']['id'])",
            "            self.assertEqual(r['router']['id'], body['port']['device_id'])",
            "",
            "            # clean-up",
            "            self._router_interface_action('remove',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "",
            "    def test_router_add_interface_delete_port_after_failure(self):",
            "        with self.router() as r, self.subnet(enable_dhcp=False) as s:",
            "            plugin = directory.get_plugin()",
            "            # inject a failure in the update port that happens at the end",
            "            # to ensure the port gets deleted",
            "            with mock.patch.object(",
            "                    plugin, 'update_port',",
            "                    side_effect=n_exc.InvalidInput(error_message='x')):",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              exc.HTTPBadRequest.code)",
            "                self.assertFalse(plugin.get_ports(context.get_admin_context()))",
            "",
            "    def test_router_add_interface_dup_port(self):",
            "        '''This tests that if multiple routers add one port as their",
            "        interfaces. Only the first router's interface would be added",
            "        to this port. All the later requests would return exceptions.",
            "        '''",
            "        with self.router() as r1, self.router() as r2, self.network() as n:",
            "            with self.subnet(network=n) as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r1['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    # mock out the sequential check",
            "                    plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                    check_p = mock.patch(plugin + '._check_router_port',",
            "                                         port_id=p['port']['id'],",
            "                                         device_id=r2['router']['id'],",
            "                                         return_value=p['port'])",
            "                    checkport = check_p.start()",
            "                    # do regular checkport after first skip",
            "                    checkport.side_effect = check_p.stop()",
            "                    self._router_interface_action('add',",
            "                                                  r2['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'],",
            "                                                  exc.HTTPConflict.code)",
            "                    # clean-up",
            "                    self._router_interface_action('remove',",
            "                                                  r1['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def _assert_body_port_id_and_update_port(self, body, mock_update_port,",
            "                                             port_id, device_id):",
            "        self.assertNotIn('port_id', body)",
            "        expected_port_update_before_update = {",
            "            'device_owner': lib_constants.DEVICE_OWNER_ROUTER_INTF,",
            "            'device_id': device_id}",
            "        expected_port_update_after_fail = {",
            "            'device_owner': '',",
            "            'device_id': ''}",
            "        mock_update_port.assert_has_calls(",
            "            [mock.call(",
            "                mock.ANY,",
            "                port_id,",
            "                {'port': expected_port_update_before_update}),",
            "             mock.call(",
            "                mock.ANY,",
            "                port_id,",
            "                {'port': expected_port_update_after_fail})],",
            "            any_order=False)",
            "        # fetch port and confirm device_id and device_owner",
            "        body = self._show('ports', port_id)",
            "        self.assertEqual('', body['port']['device_owner'])",
            "        self.assertEqual('', body['port']['device_id'])",
            "",
            "    def test_router_add_interface_multiple_ipv4_subnet_port_returns_400(self):",
            "        \"\"\"Test adding router port with multiple IPv4 subnets fails.",
            "",
            "        Multiple IPv4 subnets are not allowed on a single router port.",
            "        Ensure that adding a port with multiple IPv4 subnets to a router fails.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='10.0.0.0/24') as s1, (",
            "                 self.subnet(network=n, cidr='10.0.1.0/24')) as s2:",
            "                fixed_ips = [{'subnet_id': s1['subnet']['id']},",
            "                             {'subnet_id': s2['subnet']['id']}]",
            "                orig_update_port = self.plugin.update_port",
            "                with self.port(subnet=s1, fixed_ips=fixed_ips) as p, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                    update_port.side_effect = orig_update_port",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    body = self._router_interface_action(",
            "                        'add', r['router']['id'], None, p['port']['id'],",
            "                        expected_code=exp_code)",
            "                    self._assert_body_port_id_and_update_port(",
            "                        body, update_port, p['port']['id'], r['router']['id'])",
            "",
            "    def test_router_add_interface_ipv6_port_existing_network_returns_400(self):",
            "        \"\"\"Ensure unique IPv6 router ports per network id.",
            "",
            "        Adding a router port containing one or more IPv6 subnets with the same",
            "        network id as an existing router port should fail. This is so",
            "        there is no ambiguity regarding on which port to add an IPv6 subnet",
            "        when executing router-interface-add with a subnet and no port.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='fd00::/64',",
            "                             ip_version=6) as s1, (",
            "                 self.subnet(network=n, cidr='fd01::/64',",
            "                             ip_version=6)) as s2:",
            "                orig_update_port = self.plugin.update_port",
            "                with self.port(subnet=s1) as p, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                    update_port.side_effect = orig_update_port",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s2['subnet']['id'],",
            "                                                  None)",
            "                    exp_code = exc.HTTPBadRequest.code",
            "                    body = self._router_interface_action(",
            "                        'add', r['router']['id'], None, p['port']['id'],",
            "                        expected_code=exp_code)",
            "                    self._assert_body_port_id_and_update_port(",
            "                        body, update_port, p['port']['id'], r['router']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s2['subnet']['id'],",
            "                                                  None)",
            "",
            "    def test_router_add_interface_multiple_ipv6_subnet_port(self):",
            "        \"\"\"A port with multiple IPv6 subnets can be added to a router",
            "",
            "        Create a port with multiple associated IPv6 subnets and attach",
            "        it to a router. The action should succeed.",
            "        \"\"\"",
            "        with self.network() as n, self.router() as r:",
            "            with self.subnet(network=n, cidr='fd00::/64',",
            "                             ip_version=6) as s1, (",
            "                 self.subnet(network=n, cidr='fd01::/64',",
            "                             ip_version=6)) as s2:",
            "                fixed_ips = [{'subnet_id': s1['subnet']['id']},",
            "                             {'subnet_id': s2['subnet']['id']}]",
            "                with self.port(subnet=s1, fixed_ips=fixed_ips) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_add_interface_empty_port_and_subnet_ids(self):",
            "        with self.router() as r:",
            "            self._router_interface_action('add', r['router']['id'],",
            "                                          None, None,",
            "                                          expected_code=exc.",
            "                                          HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_port_bad_tenant_returns_404(self):",
            "        tenant_id = _uuid()",
            "        with self.router(tenant_id=tenant_id, set_context=True) as r:",
            "            with self.network(tenant_id=tenant_id, set_context=True) as n:",
            "                with self.subnet(tenant_id=tenant_id, network=n,",
            "                                 set_context=True) as s:",
            "                    with self.port(tenant_id=tenant_id, subnet=s,",
            "                                   set_context=True) as p:",
            "                        err_code = exc.HTTPNotFound.code",
            "                        self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    expected_code=err_code,",
            "                                                    tenant_id='bad_tenant')",
            "                        self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    tenant_id=tenant_id)",
            "",
            "                        # clean-up should fail as well",
            "                        self._router_interface_action('remove',",
            "                                                    r['router']['id'],",
            "                                                    None,",
            "                                                    p['port']['id'],",
            "                                                    expected_code=err_code,",
            "                                                    tenant_id='bad_tenant')",
            "",
            "    def test_router_add_interface_port_without_ips(self):",
            "        with self.network() as network, self.router() as r:",
            "            # Create a router port without ips",
            "            p = self._make_port(self.fmt, network['network']['id'],",
            "                device_owner=lib_constants.DEVICE_OWNER_ROUTER_INTF)",
            "            err_code = exc.HTTPBadRequest.code",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'],",
            "                                          expected_code=err_code)",
            "",
            "    def test_router_add_interface_dup_subnet1_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=exc.",
            "                                              HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_dup_subnet2_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1, self.subnet(cidr='1.0.0.0/24') as s2:",
            "                with self.port(subnet=s1) as p1, self.port(subnet=s2) as p2:",
            "                    orig_update_port = self.plugin.update_port",
            "                    with self.port(subnet=s1) as p3, (",
            "                        mock.patch.object(self.plugin,",
            "                                          'update_port')) as update_port:",
            "                        update_port.side_effect = orig_update_port",
            "                        for p in [p1, p2]:",
            "                            self._router_interface_action('add',",
            "                                                          r['router']['id'],",
            "                                                          None,",
            "                                                          p['port']['id'])",
            "                        body = self._router_interface_action(",
            "                            'add', r['router']['id'], None, p3['port']['id'],",
            "                            expected_code=exc.HTTPBadRequest.code)",
            "                        self._assert_body_port_id_and_update_port(",
            "                            body, update_port, p3['port']['id'],",
            "                            r['router']['id'])",
            "",
            "    def test_router_add_interface_overlapped_cidr_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.2.0/24') as s2:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s1['subnet']['id'],",
            "                                              None)",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s2['subnet']['id'],",
            "                                              None)",
            "",
            "                def try_overlapped_cidr(cidr):",
            "                    with self.subnet(cidr=cidr) as s3:",
            "                        self._router_interface_action('add',",
            "                                                      r['router']['id'],",
            "                                                      s3['subnet']['id'],",
            "                                                      None,",
            "                                                      expected_code=exc.",
            "                                                      HTTPBadRequest.code)",
            "                # another subnet with same cidr",
            "                try_overlapped_cidr('10.0.1.0/24')",
            "                try_overlapped_cidr('10.0.2.0/24')",
            "                # another subnet with overlapped cidr including s1",
            "                try_overlapped_cidr('10.0.0.0/16')",
            "                # another subnet with overlapped cidr including s2",
            "                try_overlapped_cidr('10.0.2.128/28')",
            "",
            "    def test_router_add_interface_no_data_returns_400(self):",
            "        with self.router() as r:",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          None,",
            "                                          expected_code=exc.",
            "                                          HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_with_both_ids_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'],",
            "                                                  expected_code=exc.",
            "                                                  HTTPBadRequest.code)",
            "",
            "    def test_router_add_interface_cidr_overlapped_with_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.0.0/16') as s2:",
            "                self._set_net_external(s2['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s2['subnet']['network_id'])",
            "                res = self._router_interface_action('add',",
            "                                                    r['router']['id'],",
            "                                                    s1['subnet']['id'],",
            "                                                    None)",
            "                self.assertIn('port_id', res)",
            "",
            "    def test_router_add_interface_by_port_cidr_overlapped_with_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='10.0.1.0/24') as s1, self.subnet(",
            "                    cidr='10.0.0.0/16') as s2:",
            "                with self.port(subnet=s1) as p:",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s2['subnet']['network_id'])",
            "",
            "                    res = self._router_interface_action('add',",
            "                                                        r['router']['id'],",
            "                                                        None,",
            "                                                        p['port']['id'])",
            "                    self.assertIn('port_id', res)",
            "",
            "    def test_router_add_gateway_dup_subnet1_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_dup_subnet2_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None,",
            "                                              expected_code=exc.",
            "                                              HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_multiple_subnets_ipv6(self):",
            "        \"\"\"Ensure external gateway set doesn't add excess IPs on router gw",
            "",
            "        Setting the gateway of a router to an external network with more than",
            "        one IPv4 and one IPv6 subnet should only add an address from the first",
            "        IPv4 subnet, an address from the first IPv6-stateful subnet, and an",
            "        address from each IPv6-stateless (SLAAC and DHCPv6-stateless) subnet",
            "",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with self.subnet(",
            "                    cidr='10.0.0.0/24', network=n) as s1, (",
            "                 self.subnet(",
            "                    cidr='10.0.1.0/24', network=n)) as s2, (",
            "                 self.subnet(",
            "                    cidr='2001:db8::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.IPV6_SLAAC,",
            "                    ipv6_address_mode=lib_constants.IPV6_SLAAC)) as s3, (",
            "                 self.subnet(",
            "                    cidr='2001:db8:1::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.DHCPV6_STATEFUL,",
            "                    ipv6_address_mode=lib_constants.DHCPV6_STATEFUL)) as s4, (",
            "                 self.subnet(",
            "                    cidr='2001:db8:2::/64', network=n,",
            "                    ip_version=6,",
            "                    ipv6_ra_mode=lib_constants.DHCPV6_STATELESS,",
            "                    ipv6_address_mode=lib_constants.DHCPV6_STATELESS)) as s5:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        n['network']['id'])",
            "                res = self._show('routers', r['router']['id'])",
            "                fips = (res['router']['external_gateway_info']",
            "                        ['external_fixed_ips'])",
            "                fip_subnet_ids = {fip['subnet_id'] for fip in fips}",
            "                # one of s1 or s2 should be in the list.",
            "                if s1['subnet']['id'] in fip_subnet_ids:",
            "                    self.assertEqual({s1['subnet']['id'],",
            "                                      s3['subnet']['id'],",
            "                                      s4['subnet']['id'],",
            "                                      s5['subnet']['id']},",
            "                                     fip_subnet_ids)",
            "                else:",
            "                    self.assertEqual({s2['subnet']['id'],",
            "                                      s3['subnet']['id'],",
            "                                      s4['subnet']['id'],",
            "                                      s5['subnet']['id']},",
            "                                     fip_subnet_ids)",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "",
            "    def test_router_add_and_remove_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_router_add_and_remove_gateway_tenant_ctx(self):",
            "        with self.router(tenant_id='noadmin',",
            "                         set_context=True) as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                ctx = context.Context('', 'noadmin')",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    neutron_context=ctx)",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_create_router_port_with_device_id_of_other_teants_router(self):",
            "        with self.router() as admin_router:",
            "            with self.network(tenant_id='tenant_a',",
            "                              set_context=True) as n:",
            "                with self.subnet(network=n):",
            "                    for device_owner in lib_constants.ROUTER_INTERFACE_OWNERS:",
            "                        self._create_port(",
            "                            self.fmt, n['network']['id'],",
            "                            tenant_id='tenant_a',",
            "                            device_id=admin_router['router']['id'],",
            "                            device_owner=device_owner,",
            "                            set_context=True,",
            "                            expected_res_status=exc.HTTPConflict.code)",
            "",
            "    def test_create_non_router_port_device_id_of_other_teants_router_update(",
            "        self):",
            "        # This tests that HTTPConflict is raised if we create a non-router",
            "        # port that matches the device_id of another tenants router and then",
            "        # we change the device_owner to be network:router_interface.",
            "        with self.router() as admin_router:",
            "            with self.network(tenant_id='tenant_a',",
            "                              set_context=True) as n:",
            "                with self.subnet(network=n):",
            "                    for device_owner in lib_constants.ROUTER_INTERFACE_OWNERS:",
            "                        port_res = self._create_port(",
            "                            self.fmt, n['network']['id'],",
            "                            tenant_id='tenant_a',",
            "                            device_id=admin_router['router']['id'],",
            "                            set_context=True)",
            "                        port = self.deserialize(self.fmt, port_res)",
            "                        neutron_context = context.Context('', 'tenant_a')",
            "                        data = {'port': {'device_owner': device_owner}}",
            "                        self._update('ports', port['port']['id'], data,",
            "                                     neutron_context=neutron_context,",
            "                                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_update_port_device_id_to_different_tenants_router(self):",
            "        with self.router() as admin_router:",
            "            with self.router(tenant_id='tenant_a',",
            "                             set_context=True) as tenant_router:",
            "                with self.network(tenant_id='tenant_a',",
            "                                  set_context=True) as n:",
            "                    with self.subnet(network=n) as s:",
            "                        port = self._router_interface_action(",
            "                            'add', tenant_router['router']['id'],",
            "                            s['subnet']['id'], None, tenant_id='tenant_a')",
            "                        neutron_context = context.Context('', 'tenant_a')",
            "                        data = {'port':",
            "                                {'device_id': admin_router['router']['id']}}",
            "                        self._update('ports', port['port_id'], data,",
            "                                     neutron_context=neutron_context,",
            "                                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_add_gateway_invalid_network_returns_400(self):",
            "        with self.router() as r:",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                \"foobar\", expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_non_existent_network_returns_404(self):",
            "        with self.router() as r:",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                _uuid(), expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_router_add_gateway_net_not_external_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                # intentionally do not set net as external",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'],",
            "                    expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_router_add_gateway_no_subnet(self):",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                self._set_net_external(n['network']['id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                net_id = body['router']['external_gateway_info']['network_id']",
            "                self.assertEqual(net_id, n['network']['id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    n['network']['id'])",
            "                body = self._show('routers', r['router']['id'])",
            "                gw_info = body['router']['external_gateway_info']",
            "                self.assertIsNone(gw_info)",
            "",
            "    def test_router_add_gateway_no_subnet_forbidden(self):",
            "        with self.router() as r:",
            "            with self.network() as n:",
            "                self._set_net_external(n['network']['id'])",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    errors = [",
            "                        exceptions.NotificationError(",
            "                            'foo_callback_id',",
            "                            n_exc.InvalidInput(error_message='forbidden')),",
            "                    ]",
            "                    notify.side_effect = exceptions.CallbackFailure(",
            "                        errors=errors)",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'], n['network']['id'],",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "                    notify.assert_called_once_with(",
            "                        resources.ROUTER_GATEWAY,",
            "                        events.BEFORE_CREATE,",
            "                        mock.ANY,",
            "                        context=mock.ANY,",
            "                        router_id=r['router']['id'],",
            "                        network_id=n['network']['id'],",
            "                        subnets=[])",
            "",
            "    def test_router_remove_interface_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              s['subnet']['id'],",
            "                                              None)",
            "                self._delete('routers', r['router']['id'],",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_remove_interface_callback_failure_returns_409(self):",
            "        with self.router() as r,\\",
            "                self.subnet() as s,\\",
            "                mock.patch.object(registry, 'notify') as notify:",
            "            errors = [",
            "                exceptions.NotificationError(",
            "                    'foo_callback_id', n_exc.InUse()),",
            "            ]",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          s['subnet']['id'],",
            "                                          None)",
            "",
            "            # we fail the first time, but not the second, when",
            "            # the clean-up takes place",
            "            notify.side_effect = [",
            "                exceptions.CallbackFailure(errors=errors), None",
            "            ]",
            "            self._router_interface_action(",
            "                'remove',",
            "                r['router']['id'],",
            "                s['subnet']['id'],",
            "                None,",
            "                exc.HTTPConflict.code)",
            "",
            "    def test_router_clear_gateway_callback_failure_returns_409(self):",
            "        with self.router() as r,\\",
            "                self.subnet() as s,\\",
            "                mock.patch.object(registry, 'notify') as notify:",
            "            errors = [",
            "                exceptions.NotificationError(",
            "                    'foo_callback_id', n_exc.InUse()),",
            "            ]",
            "",
            "            self._set_net_external(s['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "            notify.side_effect = exceptions.CallbackFailure(errors=errors)",
            "            self._remove_external_gateway_from_router(",
            "                r['router']['id'],",
            "                s['subnet']['network_id'],",
            "                external_gw_info={},",
            "                expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_remove_interface_wrong_subnet_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port() as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'],",
            "                                                  exc.HTTPBadRequest.code)",
            "",
            "    def test_router_remove_interface_nothing_returns_400(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  None,",
            "                                                  exc.HTTPBadRequest.code)",
            "                    # remove properly to clean-up",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_remove_interface_returns_200(self):",
            "        with self.router() as r:",
            "            with self.port() as p:",
            "                body = self._router_interface_action('add',",
            "                                                     r['router']['id'],",
            "                                                     None,",
            "                                                     p['port']['id'])",
            "                self._router_interface_action('remove',",
            "                                              r['router']['id'],",
            "                                              None,",
            "                                              p['port']['id'],",
            "                                              expected_body=body)",
            "",
            "    def test_router_remove_interface_with_both_ids_returns_200(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                with self.port(subnet=s) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  s['subnet']['id'],",
            "                                                  p['port']['id'])",
            "",
            "    def test_router_remove_interface_wrong_port_returns_404(self):",
            "        with self.router() as r:",
            "            with self.subnet():",
            "                with self.port() as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    # create another port for testing failure case",
            "                    res = self._create_port(self.fmt, p['port']['network_id'])",
            "                    p2 = self.deserialize(self.fmt, res)",
            "                    self._router_interface_action('remove',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p2['port']['id'],",
            "                                                  exc.HTTPNotFound.code)",
            "",
            "    def test_router_remove_ipv6_subnet_from_interface(self):",
            "        \"\"\"Delete a subnet from a router interface",
            "",
            "        Verify that deleting a subnet with router-interface-delete removes",
            "        that subnet when there are multiple subnets on the interface and",
            "        removes the interface when it is the last subnet on the interface.",
            "        \"\"\"",
            "        with self.router() as r, self.network() as n:",
            "            with (self.subnet(network=n, cidr='fd00::1/64', ip_version=6)",
            "                  ) as s1, self.subnet(network=n, cidr='fd01::1/64',",
            "                                       ip_version=6) as s2:",
            "                body = self._router_interface_action('add', r['router']['id'],",
            "                                                     s1['subnet']['id'],",
            "                                                     None)",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              s2['subnet']['id'], None)",
            "                port = self._show('ports', body['port_id'])",
            "                self.assertEqual(2, len(port['port']['fixed_ips']))",
            "                self._router_interface_action('remove', r['router']['id'],",
            "                                              s1['subnet']['id'], None)",
            "                port = self._show('ports', body['port_id'])",
            "                self.assertEqual(1, len(port['port']['fixed_ips']))",
            "                self._router_interface_action('remove', r['router']['id'],",
            "                                              s2['subnet']['id'], None)",
            "                exp_code = exc.HTTPNotFound.code",
            "                port = self._show('ports', body['port_id'],",
            "                                  expected_code=exp_code)",
            "",
            "    def test_router_delete(self):",
            "        with self.router() as router:",
            "            router_id = router['router']['id']",
            "        req = self.new_show_request('router', router_id)",
            "        res = req.get_response(self._api_for_resource('router'))",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_router_delete_with_port_existed_returns_409(self):",
            "        with self.subnet() as subnet:",
            "            res = self._create_router(self.fmt, _uuid())",
            "            router = self.deserialize(self.fmt, res)",
            "            self._router_interface_action('add',",
            "                                          router['router']['id'],",
            "                                          subnet['subnet']['id'],",
            "                                          None)",
            "            self._delete('routers', router['router']['id'],",
            "                         exc.HTTPConflict.code)",
            "",
            "    def test_router_delete_with_floatingip_existed_returns_409(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                res = self._create_router(self.fmt, _uuid())",
            "                r = self.deserialize(self.fmt, res)",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "                self._router_interface_action('add', r['router']['id'],",
            "                                              private_sub['subnet']['id'],",
            "                                              None)",
            "                res = self._create_floatingip(",
            "                    self.fmt, public_sub['subnet']['network_id'],",
            "                    port_id=p['port']['id'])",
            "                self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "                self._delete('routers', r['router']['id'],",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_router_show(self):",
            "        name = 'router1'",
            "        tenant_id = _uuid()",
            "        expected_value = [('name', name), ('tenant_id', tenant_id),",
            "                          ('admin_state_up', True), ('status', 'ACTIVE'),",
            "                          ('external_gateway_info', None)]",
            "        with self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id) as router:",
            "            res = self._show('routers', router['router']['id'])",
            "            for k, v in expected_value:",
            "                self.assertEqual(res['router'][k], v)",
            "",
            "    def test_network_update_external_failure(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                self._set_net_external(s1['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s1['subnet']['network_id'])",
            "                self._update('networks', s1['subnet']['network_id'],",
            "                             {'network': {extnet_apidef.EXTERNAL: False}},",
            "                             expected_code=exc.HTTPConflict.code)",
            "",
            "    def test_network_update_external(self):",
            "        with self.router() as r:",
            "            with self.network('test_net') as testnet:",
            "                self._set_net_external(testnet['network']['id'])",
            "                with self.subnet() as s1:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "                    self._update('networks', testnet['network']['id'],",
            "                                 {'network': {extnet_apidef.EXTERNAL: False}})",
            "",
            "    def test_floatingip_crd_ops(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            self._validate_floating_ip(fip)",
            "",
            "        # post-delete, check that it is really gone",
            "        body = self._list('floatingips')",
            "        self.assertEqual(0, len(body['floatingips']))",
            "",
            "        self._show('floatingips', fip['floatingip']['id'],",
            "                   expected_code=exc.HTTPNotFound.code)",
            "",
            "    def _test_floatingip_with_assoc_fails(self, plugin_method):",
            "        with self.subnet(cidr='200.0.0.0/24') as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router() as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                  private_sub['subnet']['id'],",
            "                                                  None)",
            "                    with mock.patch(plugin_method) as pl:",
            "                        pl.side_effect = n_exc.BadRequest(",
            "                            resource='floatingip',",
            "                            msg='fake_error')",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            port_id=private_port['port']['id'])",
            "                        self.assertEqual(400, res.status_int)",
            "                    for p in self._list('ports')['ports']:",
            "                        if (p['device_owner'] ==",
            "                                lib_constants.DEVICE_OWNER_FLOATINGIP):",
            "                            self.fail('garbage port is not deleted')",
            "",
            "    def test_floatingip_with_assoc_fails(self):",
            "        self._test_floatingip_with_assoc_fails(",
            "            'neutron.db.l3_db.L3_NAT_dbonly_mixin._check_and_get_fip_assoc')",
            "",
            "    def test_create_floatingip_with_assoc(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.floatingip_with_assoc() as fip:",
            "            body = self._show('floatingips', fip['floatingip']['id'])",
            "            self.assertEqual(body['floatingip']['id'],",
            "                             fip['floatingip']['id'])",
            "            self.assertEqual(body['floatingip']['port_id'],",
            "                             fip['floatingip']['port_id'])",
            "            self.assertEqual(expected_status, body['floatingip']['status'])",
            "            self.assertIsNotNone(body['floatingip']['fixed_ip_address'])",
            "            self.assertIsNotNone(body['floatingip']['router_id'])",
            "",
            "    def test_create_floatingip_non_admin_context_agent_notification(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not hasattr(plugin, 'l3_rpc_notifier'):",
            "            self.skipTest(\"Plugin does not support l3_rpc_notifier\")",
            "",
            "        with self.subnet(cidr='11.0.0.0/24') as public_sub,\\",
            "                self.port() as private_port,\\",
            "                self.router() as r:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            subnet_id = private_port['port']['fixed_ips'][0]['subnet_id']",
            "            private_sub = {'subnet': {'id': subnet_id}}",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                public_sub['subnet']['network_id'])",
            "            self._router_interface_action(",
            "                'add', r['router']['id'],",
            "                private_sub['subnet']['id'], None)",
            "",
            "            with mock.patch.object(plugin.l3_rpc_notifier,",
            "                                   'routers_updated') as agent_notification:",
            "                self._make_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'],",
            "                    port_id=private_port['port']['id'],",
            "                    set_context=False)",
            "                self.assertTrue(agent_notification.called)",
            "",
            "    def test_floating_port_status_not_applicable(self):",
            "        with self.floatingip_with_assoc():",
            "            port_body = self._list('ports',",
            "               query_params='device_owner=network:floatingip')['ports'][0]",
            "            self.assertEqual(lib_constants.PORT_STATUS_NOTAPPLICABLE,",
            "                             port_body['status'])",
            "",
            "    def test_floatingip_update(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertEqual(expected_status, body['floatingip']['status'])",
            "",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_subnet_gateway_disabled(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        \"\"\"Attach a floating IP to an instance",
            "",
            "        Verify that the floating IP can be associated to a port whose subnet's",
            "        gateway ip is not connected to the external router, but the router",
            "        has an ip in that subnet.",
            "        \"\"\"",
            "        with self.subnet(cidr='30.0.0.0/24', gateway_ip=None) as private_sub:",
            "            with self.port(private_sub) as p:",
            "                subnet_id = p['port']['fixed_ips'][0]['subnet_id']",
            "                private_sub = {'subnet': {'id': subnet_id}}",
            "                port_id = p['port']['id']",
            "                with self.router() as r:",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                None, port_id)",
            "                with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                    self._set_net_external(public_sub['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                         r['router']['id'], public_sub['subnet']['network_id'])",
            "                    fip = self._make_floatingip(self.fmt,",
            "                                 public_sub['subnet']['network_id'])",
            "                    body = self._show('floatingips', fip['floatingip']['id'])",
            "                    self.assertEqual(expected_status,",
            "                                     body['floatingip']['status'])",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                  {'floatingip': {'port_id': port_id}})",
            "                    self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                    self.assertEqual(p['port']['fixed_ips'][0]['ip_address'],",
            "                                     body['floatingip']['fixed_ip_address'])",
            "                    self.assertEqual(r['router']['id'],",
            "                                     body['floatingip']['router_id'])",
            "",
            "    def test_floatingip_create_different_fixed_ip_same_port(self):",
            "        '''This tests that it is possible to delete a port that has",
            "        multiple floating ip addresses associated with it (each floating",
            "        address associated with a unique fixed address).",
            "        '''",
            "",
            "        with self.router() as r:",
            "            with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "",
            "                with self.subnet() as private_sub:",
            "                    ip_range = list(netaddr.IPNetwork(",
            "                        private_sub['subnet']['cidr']))",
            "                    fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                                 {'ip_address': str(ip_range[-2])}]",
            "",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    with self.port(subnet=private_sub,",
            "                                   fixed_ips=fixed_ips) as p:",
            "",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-2]))",
            "                        fip2 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]))",
            "",
            "                        # Test that floating ips are assigned successfully.",
            "                        body = self._show('floatingips',",
            "                                          fip1['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip1['floatingip']['port_id'])",
            "",
            "                        body = self._show('floatingips',",
            "                                          fip2['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip2['floatingip']['port_id'])",
            "                    self._delete('ports', p['port']['id'])",
            "                    # Test that port has been successfully deleted.",
            "                    body = self._show('ports', p['port']['id'],",
            "                                      expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_floatingip_update_different_fixed_ip_same_port(self):",
            "        with self.subnet() as s:",
            "            ip_range = list(netaddr.IPNetwork(s['subnet']['cidr']))",
            "            fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                         {'ip_address': str(ip_range[-2])}]",
            "            with self.port(subnet=s, fixed_ips=fixed_ips) as p:",
            "                with self.floatingip_with_assoc(",
            "                    port_id=p['port']['id'],",
            "                    fixed_ip=str(ip_range[-3])) as fip:",
            "                    body = self._show('floatingips', fip['floatingip']['id'])",
            "                    self.assertEqual(fip['floatingip']['id'],",
            "                                     body['floatingip']['id'])",
            "                    self.assertEqual(fip['floatingip']['port_id'],",
            "                                     body['floatingip']['port_id'])",
            "                    self.assertEqual(str(ip_range[-3]),",
            "                                     body['floatingip']['fixed_ip_address'])",
            "                    self.assertIsNotNone(body['floatingip']['router_id'])",
            "                    body_2 = self._update(",
            "                        'floatingips', fip['floatingip']['id'],",
            "                        {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': str(ip_range[-2])}",
            "                         })",
            "                    self.assertEqual(fip['floatingip']['port_id'],",
            "                                     body_2['floatingip']['port_id'])",
            "                    self.assertEqual(str(ip_range[-2]),",
            "                                     body_2['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_invalid_fixed_ip(self):",
            "        with self.subnet() as s:",
            "            with self.port(subnet=s) as p:",
            "                with self.floatingip_with_assoc(",
            "                    port_id=p['port']['id']) as fip:",
            "                    self._update(",
            "                        'floatingips', fip['floatingip']['id'],",
            "                        {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': '2001:db8::a'}},",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "",
            "    def test_floatingip_update_to_same_port_id_twice(",
            "        self, expected_status=lib_constants.FLOATINGIP_STATUS_ACTIVE):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertEqual(expected_status, body['floatingip']['status'])",
            "",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                # 1. Update floating IP with port_id (associate)",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "                # 2. Update floating IP with same port again",
            "                body = self._update('floatingips', fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                # No errors, and nothing changed",
            "                self.assertEqual(port_id, body['floatingip']['port_id'])",
            "                self.assertEqual(ip_address,",
            "                                 body['floatingip']['fixed_ip_address'])",
            "",
            "    def test_floatingip_update_same_fixed_ip_same_port(self):",
            "        with self.subnet() as private_sub:",
            "            ip_range = list(netaddr.IPNetwork(private_sub['subnet']['cidr']))",
            "            fixed_ip = [{'ip_address': str(ip_range[-3])}]",
            "            with self.port(subnet=private_sub, fixed_ips=fixed_ip) as p:",
            "                with self.router() as r:",
            "                    with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                        self._set_net_external(",
            "                            public_sub['subnet']['network_id'])",
            "                        self._add_external_gateway_to_router(",
            "                            r['router']['id'],",
            "                            public_sub['subnet']['network_id'])",
            "                        self._router_interface_action(",
            "                            'add', r['router']['id'],",
            "                            private_sub['subnet']['id'], None)",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'])",
            "                        fip2 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'])",
            "                        # 1. Update floating IP 1 with port_id and fixed_ip",
            "                        body_1 = self._update(",
            "                            'floatingips', fip1['floatingip']['id'],",
            "                            {'floatingip': {'port_id': p['port']['id'],",
            "                                        'fixed_ip_address': str(ip_range[-3])}",
            "                             })",
            "                        self.assertEqual(str(ip_range[-3]),",
            "                            body_1['floatingip']['fixed_ip_address'])",
            "                        self.assertEqual(p['port']['id'],",
            "                            body_1['floatingip']['port_id'])",
            "                        # 2. Update floating IP 2 with port_id and fixed_ip",
            "                        # mock out the sequential check",
            "                        plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                        check_get = mock.patch(",
            "                            plugin + '._check_and_get_fip_assoc',",
            "                            fip=fip2, floating_db=mock.ANY,",
            "                            return_value=(p['port']['id'], str(ip_range[-3]),",
            "                                          r['router']['id']))",
            "                        check_and_get = check_get.start()",
            "                        # do regular _check_and_get_fip_assoc() after skip",
            "                        check_and_get.side_effect = check_get.stop()",
            "                        self._update(",
            "                            'floatingips', fip2['floatingip']['id'],",
            "                            {'floatingip':",
            "                                {'port_id': p['port']['id'],",
            "                                 'fixed_ip_address': str(ip_range[-3])",
            "                                 }}, exc.HTTPConflict.code)",
            "                        body = self._show('floatingips',",
            "                                          fip2['floatingip']['id'])",
            "                        self.assertIsNone(",
            "                            body['floatingip']['fixed_ip_address'])",
            "                        self.assertIsNone(",
            "                            body['floatingip']['port_id'])",
            "",
            "    def test_create_multiple_floatingips_same_fixed_ip_same_port(self):",
            "        '''This tests that if multiple API requests arrive to create",
            "        floating IPs on same external network to same port with one",
            "        fixed ip, the latter API requests would be blocked at",
            "        database side.",
            "        '''",
            "        with self.router() as r:",
            "            with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "",
            "                with self.subnet() as private_sub:",
            "                    ip_range = list(netaddr.IPNetwork(",
            "                        private_sub['subnet']['cidr']))",
            "                    fixed_ips = [{'ip_address': str(ip_range[-3])},",
            "                                {'ip_address': str(ip_range[-2])}]",
            "",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    with self.port(subnet=private_sub,",
            "                                   fixed_ips=fixed_ips) as p:",
            "                        # 1. Create floating IP 1",
            "                        fip1 = self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]))",
            "                        # 2. Create floating IP 2",
            "                        # mock out the sequential check",
            "                        plugin = 'neutron.db.l3_db.L3_NAT_dbonly_mixin'",
            "                        check_get = mock.patch(",
            "                            plugin + '._check_and_get_fip_assoc',",
            "                            fip=mock.ANY, floating_db=mock.ANY,",
            "                            return_value=(p['port']['id'], str(ip_range[-3]),",
            "                                          r['router']['id']))",
            "                        check_and_get = check_get.start()",
            "                        # do regular _check_and_get_fip_assoc() after skip",
            "                        check_and_get.side_effect = check_get.stop()",
            "                        self._make_floatingip(",
            "                            self.fmt,",
            "                            public_sub['subnet']['network_id'],",
            "                            p['port']['id'],",
            "                            fixed_ip=str(ip_range[-3]),",
            "                            http_status=exc.HTTPConflict.code)",
            "                        # Test that floating IP 1 is successfully created",
            "                        body = self._show('floatingips',",
            "                                          fip1['floatingip']['id'])",
            "                        self.assertEqual(",
            "                            body['floatingip']['port_id'],",
            "                            fip1['floatingip']['port_id'])",
            "",
            "                    self._delete('ports', p['port']['id'])",
            "                    # Test that port has been successfully deleted.",
            "                    body = self._show('ports', p['port']['id'],",
            "                                      expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_first_floatingip_associate_notification(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                port_id = p['port']['id']",
            "                ip_address = p['port']['fixed_ips'][0]['ip_address']",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    body = self._update('floatingips',",
            "                                        fip['floatingip']['id'],",
            "                                        {'floatingip': {'port_id': port_id}})",
            "                    fip_addr = fip['floatingip']['floating_ip_address']",
            "                    fip_network_id = fip['floatingip']['floating_network_id']",
            "                    fip_id = fip['floatingip']['id']",
            "                    router_id = body['floatingip']['router_id']",
            "                    body = self._show('routers', router_id)",
            "                    notify.assert_any_call(resources.FLOATING_IP,",
            "                                           events.AFTER_UPDATE,",
            "                                           mock.ANY,",
            "                                           context=mock.ANY,",
            "                                           fixed_ip_address=ip_address,",
            "                                           fixed_port_id=port_id,",
            "                                           floating_ip_address=fip_addr,",
            "                                           floating_network_id=fip_network_id,",
            "                                           last_known_router_id=None,",
            "                                           floating_ip_id=fip_id,",
            "                                           router_id=router_id)",
            "",
            "    def test_floatingip_disassociate_notification(self):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                port_id = p['port']['id']",
            "                body = self._update('floatingips',",
            "                                    fip['floatingip']['id'],",
            "                                    {'floatingip': {'port_id': port_id}})",
            "                with mock.patch.object(registry, 'notify') as notify:",
            "                    fip_addr = fip['floatingip']['floating_ip_address']",
            "                    fip_network_id = fip['floatingip']['floating_network_id']",
            "                    fip_id = fip['floatingip']['id']",
            "                    router_id = body['floatingip']['router_id']",
            "                    self._update('floatingips',",
            "                                 fip['floatingip']['id'],",
            "                                 {'floatingip': {'port_id': None}})",
            "                    notify.assert_any_call(resources.FLOATING_IP,",
            "                                           events.AFTER_UPDATE,",
            "                                           mock.ANY,",
            "                                           context=mock.ANY,",
            "                                           fixed_ip_address=None,",
            "                                           fixed_port_id=None,",
            "                                           floating_ip_address=fip_addr,",
            "                                           floating_network_id=fip_network_id,",
            "                                           last_known_router_id=router_id,",
            "                                           floating_ip_id=fip_id,",
            "                                           router_id=None)",
            "",
            "    def test_floatingip_association_on_unowned_router(self):",
            "        # create a router owned by one tenant and associate the FIP with a",
            "        # different tenant, assert that the FIP association succeeds",
            "        with self.subnet(cidr='11.0.0.0/24') as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router(tenant_id='router-owner',",
            "                                 set_context=True) as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        public_sub['subnet']['network_id'])",
            "                    self._router_interface_action(",
            "                        'add', r['router']['id'],",
            "                        private_sub['subnet']['id'], None)",
            "",
            "                    self._make_floatingip(self.fmt,",
            "                                          public_sub['subnet']['network_id'],",
            "                                          port_id=private_port['port']['id'],",
            "                                          fixed_ip=None,",
            "                                          set_context=True)",
            "",
            "    def test_floatingip_update_different_router(self):",
            "        # Create subnet with different CIDRs to account for plugins which",
            "        # do not support overlapping IPs",
            "        with self.subnet(cidr='10.0.0.0/24') as s1,\\",
            "                self.subnet(cidr='10.0.1.0/24') as s2:",
            "            with self.port(subnet=s1) as p1, self.port(subnet=s2) as p2:",
            "                private_sub1 = {'subnet':",
            "                                {'id':",
            "                                 p1['port']['fixed_ips'][0]['subnet_id']}}",
            "                private_sub2 = {'subnet':",
            "                                {'id':",
            "                                 p2['port']['fixed_ips'][0]['subnet_id']}}",
            "                with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                    with self.floatingip_no_assoc_with_public_sub(",
            "                        private_sub1,",
            "                        public_sub=public_sub) as (fip1, r1),\\",
            "                            self.floatingip_no_assoc_with_public_sub(",
            "                                private_sub2,",
            "                                public_sub=public_sub) as (fip2, r2):",
            "",
            "                        def assert_no_assoc(fip):",
            "                            body = self._show('floatingips',",
            "                                              fip['floatingip']['id'])",
            "                            self.assertIsNone(body['floatingip']['port_id'])",
            "                            self.assertIsNone(",
            "                                body['floatingip']['fixed_ip_address'])",
            "",
            "                        assert_no_assoc(fip1)",
            "                        assert_no_assoc(fip2)",
            "",
            "                        def associate_and_assert(fip, port):",
            "                            port_id = port['port']['id']",
            "                            ip_address = (port['port']['fixed_ips']",
            "                                          [0]['ip_address'])",
            "                            body = self._update(",
            "                                'floatingips', fip['floatingip']['id'],",
            "                                {'floatingip': {'port_id': port_id}})",
            "                            self.assertEqual(port_id,",
            "                                             body['floatingip']['port_id'])",
            "                            self.assertEqual(",
            "                                ip_address,",
            "                                body['floatingip']['fixed_ip_address'])",
            "                            return body['floatingip']['router_id']",
            "",
            "                        fip1_r1_res = associate_and_assert(fip1, p1)",
            "                        self.assertEqual(fip1_r1_res, r1['router']['id'])",
            "                        # The following operation will associate the floating",
            "                        # ip to a different router",
            "                        fip1_r2_res = associate_and_assert(fip1, p2)",
            "                        self.assertEqual(fip1_r2_res, r2['router']['id'])",
            "                        fip2_r1_res = associate_and_assert(fip2, p1)",
            "                        self.assertEqual(fip2_r1_res, r1['router']['id'])",
            "                        # disassociate fip1",
            "                        self._update(",
            "                            'floatingips', fip1['floatingip']['id'],",
            "                            {'floatingip': {'port_id': None}})",
            "                        fip2_r2_res = associate_and_assert(fip2, p2)",
            "                        self.assertEqual(fip2_r2_res, r2['router']['id'])",
            "",
            "    def test_floatingip_update_different_port_owner_as_admin(self):",
            "        with self.subnet() as private_sub:",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                with self.port(subnet=private_sub, tenant_id='other') as p:",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                        {'floatingip':",
            "                                         {'port_id': p['port']['id']}})",
            "                    self.assertEqual(p['port']['id'],",
            "                                     body['floatingip']['port_id'])",
            "",
            "    def test_floatingip_port_delete(self):",
            "        with self.subnet() as private_sub:",
            "            with self.floatingip_no_assoc(private_sub) as fip:",
            "                with self.port(subnet=private_sub) as p:",
            "                    body = self._update('floatingips', fip['floatingip']['id'],",
            "                                        {'floatingip':",
            "                                         {'port_id': p['port']['id']}})",
            "                # note: once this port goes out of scope, the port will be",
            "                # deleted, which is what we want to test. We want to confirm",
            "                # that the fields are set back to None",
            "                self._delete('ports', p['port']['id'])",
            "                body = self._show('floatingips', fip['floatingip']['id'])",
            "                self.assertEqual(body['floatingip']['id'],",
            "                                 fip['floatingip']['id'])",
            "                self.assertIsNone(body['floatingip']['port_id'])",
            "                self.assertIsNone(body['floatingip']['fixed_ip_address'])",
            "                self.assertIsNone(body['floatingip']['router_id'])",
            "",
            "    def test_two_fips_one_port_invalid_return_409(self):",
            "        with self.floatingip_with_assoc() as fip1:",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                fip1['floatingip']['floating_network_id'],",
            "                fip1['floatingip']['port_id'])",
            "            self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_floating_ip_direct_port_delete_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_FLOATINGIP:",
            "                    self._delete('ports', p['id'],",
            "                                 expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "        self.assertTrue(found)",
            "",
            "    def _test_floatingip_with_invalid_create_port(self, plugin_class):",
            "        with self.port() as p:",
            "            private_sub = {'subnet': {'id':",
            "                                      p['port']['fixed_ips'][0]['subnet_id']}}",
            "            with self.subnet(cidr='12.0.0.0/24') as public_sub:",
            "                self._set_net_external(public_sub['subnet']['network_id'])",
            "                res = self._create_router(self.fmt, _uuid())",
            "                r = self.deserialize(self.fmt, res)",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    public_sub['subnet']['network_id'])",
            "                self._router_interface_action(",
            "                    'add', r['router']['id'],",
            "                    private_sub['subnet']['id'],",
            "                    None)",
            "",
            "                with mock.patch(plugin_class + '.create_port') as createport:",
            "                    createport.return_value = {'fixed_ips': [], 'id': '44'}",
            "                    res = self._create_floatingip(",
            "                        self.fmt, public_sub['subnet']['network_id'],",
            "                        port_id=p['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_floatingip_with_invalid_create_port(self):",
            "        self._test_floatingip_with_invalid_create_port(",
            "            'neutron.db.db_base_plugin_v2.NeutronDbPluginV2')",
            "",
            "    def test_create_floatingip_with_subnet_id_non_admin(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.router():",
            "                res = self._create_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'],",
            "                    subnet_id=public_sub['subnet']['id'],",
            "                    set_context=True)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "",
            "    def test_create_floatingip_with_subnet_id_and_fip_address(self):",
            "        with self.network() as ext_net:",
            "            self._set_net_external(ext_net['network']['id'])",
            "            with self.subnet(ext_net, cidr='10.10.10.0/24') as ext_subnet:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        ext_net['network']['id'],",
            "                        subnet_id=ext_subnet['subnet']['id'],",
            "                        floating_ip='10.10.10.100')",
            "                    fip = self.deserialize(self.fmt, res)",
            "        self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "        self.assertEqual('10.10.10.100',",
            "                         fip['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_subnet_and_invalid_fip_address(self):",
            "        with self.network() as ext_net:",
            "            self._set_net_external(ext_net['network']['id'])",
            "            with self.subnet(ext_net, cidr='10.10.10.0/24') as ext_subnet:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        ext_net['network']['id'],",
            "                        subnet_id=ext_subnet['subnet']['id'],",
            "                        floating_ip='20.20.20.200')",
            "                    data = self.deserialize(self.fmt, res)",
            "        self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "        msg = str(n_exc.InvalidIpForSubnet(ip_address='20.20.20.200'))",
            "        self.assertEqual('InvalidIpForSubnet', data['NeutronError']['type'])",
            "        self.assertEqual(msg, data['NeutronError']['message'])",
            "",
            "    def test_create_floatingip_with_multisubnet_id(self):",
            "        with self.network() as network:",
            "            self._set_net_external(network['network']['id'])",
            "            with self.subnet(network, cidr='10.0.12.0/24') as subnet1:",
            "                with self.subnet(network, cidr='10.0.13.0/24') as subnet2:",
            "                    with self.router():",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            subnet1['subnet']['network_id'],",
            "                            subnet_id=subnet1['subnet']['id'])",
            "                        fip1 = self.deserialize(self.fmt, res)",
            "                        res = self._create_floatingip(",
            "                            self.fmt,",
            "                            subnet1['subnet']['network_id'],",
            "                            subnet_id=subnet2['subnet']['id'])",
            "                        fip2 = self.deserialize(self.fmt, res)",
            "        self.assertTrue(",
            "            fip1['floatingip']['floating_ip_address'].startswith('10.0.12'))",
            "        self.assertTrue(",
            "            fip2['floatingip']['floating_ip_address'].startswith('10.0.13'))",
            "",
            "    def test_create_floatingip_with_wrong_subnet_id(self):",
            "        with self.network() as network1:",
            "            self._set_net_external(network1['network']['id'])",
            "            with self.subnet(network1, cidr='10.0.12.0/24') as subnet1:",
            "                with self.network() as network2:",
            "                    self._set_net_external(network2['network']['id'])",
            "                    with self.subnet(network2, cidr='10.0.13.0/24') as subnet2:",
            "                        with self.router():",
            "                            res = self._create_floatingip(",
            "                                self.fmt,",
            "                                subnet1['subnet']['network_id'],",
            "                                subnet_id=subnet2['subnet']['id'])",
            "        self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_no_ext_gateway_return_404(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.port() as private_port:",
            "                with self.router():",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'])",
            "                    # this should be some kind of error",
            "                    self.assertEqual(exc.HTTPNotFound.code, res.status_int)",
            "",
            "    def test_create_floating_non_ext_network_returns_400(self):",
            "        with self.subnet() as public_sub:",
            "            # normally we would set the network of public_sub to be",
            "            # external, but the point of this test is to handle when",
            "            # that is not the case",
            "            with self.router():",
            "                res = self._create_floatingip(",
            "                    self.fmt,",
            "                    public_sub['subnet']['network_id'])",
            "                self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_no_public_subnet_returns_400(self):",
            "        with self.network() as public_network:",
            "            with self.port() as private_port:",
            "                with self.router() as r:",
            "                    sid = private_port['port']['fixed_ips'][0]['subnet_id']",
            "                    private_sub = {'subnet': {'id': sid}}",
            "                    self._router_interface_action('add', r['router']['id'],",
            "                                                  private_sub['subnet']['id'],",
            "                                                  None)",
            "",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_network['network']['id'],",
            "                        port_id=private_port['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_floating_network_id_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, 'iamnotanuuid',",
            "                                      uuidutils.generate_uuid(), '192.168.0.1')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_floating_port_id_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      'iamnotanuuid', '192.168.0.1')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_fixed_ip_address_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      uuidutils.generate_uuid(), 'iamnotnanip')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_create_floatingip_invalid_fixed_ipv6_address_returns_400(self):",
            "        # API-level test - no need to create all objects for l3 plugin",
            "        res = self._create_floatingip(self.fmt, uuidutils.generate_uuid(),",
            "                                      uuidutils.generate_uuid(), '2001:db8::a')",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_floatingip_list_with_sort(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_sort('floatingip', (fp3, fp2, fp1),",
            "                                      [('floating_ip_address', 'desc')])",
            "",
            "    def test_floatingip_list_with_port_id(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            port_id = fip['floatingip']['port_id']",
            "            res = self._list('floatingips',",
            "                             query_params=\"port_id=%s\" % port_id)",
            "            self.assertEqual(1, len(res['floatingips']))",
            "            res = self._list('floatingips', query_params=\"port_id=aaa\")",
            "            self.assertEqual(0, len(res['floatingips']))",
            "",
            "    def test_floatingip_list_with_pagination(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_pagination(",
            "                'floatingip', (fp1, fp2, fp3),",
            "                ('floating_ip_address', 'asc'), 2, 2)",
            "",
            "    def test_floatingip_list_with_pagination_reverse(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as s1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as s2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as s3:",
            "            network_id1 = s1['subnet']['network_id']",
            "            network_id2 = s2['subnet']['network_id']",
            "            network_id3 = s3['subnet']['network_id']",
            "            self._set_net_external(network_id1)",
            "            self._set_net_external(network_id2)",
            "            self._set_net_external(network_id3)",
            "            fp1 = self._make_floatingip(self.fmt, network_id1)",
            "            fp2 = self._make_floatingip(self.fmt, network_id2)",
            "            fp3 = self._make_floatingip(self.fmt, network_id3)",
            "            self._test_list_with_pagination_reverse(",
            "                'floatingip', (fp1, fp2, fp3),",
            "                ('floating_ip_address', 'asc'), 2, 2)",
            "",
            "    def test_floatingip_multi_external_one_internal(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs1,\\",
            "                self.subnet(cidr=\"11.0.0.0/24\") as exs2,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\") as ins1:",
            "            network_ex_id1 = exs1['subnet']['network_id']",
            "            network_ex_id2 = exs2['subnet']['network_id']",
            "            self._set_net_external(network_ex_id1)",
            "            self._set_net_external(network_ex_id2)",
            "",
            "            r2i_fixed_ips = [{'ip_address': '12.0.0.2'}]",
            "            with self.router() as r1,\\",
            "                    self.router() as r2,\\",
            "                    self.port(subnet=ins1,",
            "                              fixed_ips=r2i_fixed_ips) as r2i_port:",
            "                self._add_external_gateway_to_router(",
            "                    r1['router']['id'],",
            "                    network_ex_id1)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins1['subnet']['id'],",
            "                                              None)",
            "                self._add_external_gateway_to_router(",
            "                    r2['router']['id'],",
            "                    network_ex_id2)",
            "                self._router_interface_action('add', r2['router']['id'],",
            "                                              None,",
            "                                              r2i_port['port']['id'])",
            "",
            "                with self.port(subnet=ins1,",
            "                               fixed_ips=[{'ip_address': '12.0.0.3'}]",
            "                               ) as private_port:",
            "",
            "                    fp1 = self._make_floatingip(self.fmt, network_ex_id1,",
            "                                            private_port['port']['id'])",
            "                    fp2 = self._make_floatingip(self.fmt, network_ex_id2,",
            "                                            private_port['port']['id'])",
            "                    self.assertEqual(fp1['floatingip']['router_id'],",
            "                                     r1['router']['id'])",
            "                    self.assertEqual(fp2['floatingip']['router_id'],",
            "                                     r2['router']['id'])",
            "",
            "    def test_floatingip_same_external_and_internal(self):",
            "        # Select router with subnet's gateway_ip for floatingip when",
            "        # routers connected to same subnet and external network.",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs,\\",
            "                self.subnet(cidr=\"12.0.0.0/24\", gateway_ip=\"12.0.0.50\") as ins:",
            "            network_ex_id = exs['subnet']['network_id']",
            "            self._set_net_external(network_ex_id)",
            "",
            "            r2i_fixed_ips = [{'ip_address': '12.0.0.2'}]",
            "            with self.router() as r1,\\",
            "                    self.router() as r2,\\",
            "                    self.port(subnet=ins,",
            "                              fixed_ips=r2i_fixed_ips) as r2i_port:",
            "                self._add_external_gateway_to_router(",
            "                    r1['router']['id'],",
            "                    network_ex_id)",
            "                self._router_interface_action('add', r2['router']['id'],",
            "                                              None,",
            "                                              r2i_port['port']['id'])",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins['subnet']['id'],",
            "                                              None)",
            "                self._add_external_gateway_to_router(",
            "                    r2['router']['id'],",
            "                    network_ex_id)",
            "",
            "                with self.port(subnet=ins,",
            "                               fixed_ips=[{'ip_address': '12.0.0.8'}]",
            "                               ) as private_port:",
            "",
            "                    fp = self._make_floatingip(self.fmt, network_ex_id,",
            "                                            private_port['port']['id'])",
            "                    self.assertEqual(r1['router']['id'],",
            "                                     fp['floatingip']['router_id'])",
            "",
            "    def _test_floatingip_via_router_interface(self, http_status):",
            "        # NOTE(yamamoto): \"exs\" subnet is just to provide a gateway port",
            "        # for the router.  Otherwise the test would fail earlier without",
            "        # reaching the code we want to test. (bug 1556884)",
            "        with self.subnet(cidr=\"10.0.0.0/24\") as exs, \\",
            "            self.subnet(cidr=\"10.0.1.0/24\") as ins1, \\",
            "            self.subnet(cidr=\"10.0.2.0/24\") as ins2:",
            "            network_ex_id = exs['subnet']['network_id']",
            "            self._set_net_external(network_ex_id)",
            "            network_in2_id = ins2['subnet']['network_id']",
            "            self._set_net_external(network_in2_id)",
            "            with self.router() as r1, self.port(subnet=ins1) as private_port:",
            "                self._add_external_gateway_to_router(r1['router']['id'],",
            "                                                     network_ex_id)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins1['subnet']['id'], None)",
            "                self._router_interface_action('add', r1['router']['id'],",
            "                                              ins2['subnet']['id'], None)",
            "                self._make_floatingip(self.fmt,",
            "                                      network_id=network_in2_id,",
            "                                      port_id=private_port['port']['id'],",
            "                                      http_status=http_status)",
            "",
            "    def _get_router_for_floatingip_without_device_owner_check(",
            "            self, context, internal_port,",
            "            internal_subnet, external_network_id):",
            "        gw_port = orm.aliased(models_v2.Port, name=\"gw_port\")",
            "        routerport_qry = context.session.query(",
            "            l3_models.RouterPort.router_id,",
            "            models_v2.IPAllocation.ip_address",
            "        ).join(",
            "            models_v2.Port, models_v2.IPAllocation",
            "        ).filter(",
            "            models_v2.Port.network_id == internal_port['network_id'],",
            "            l3_models.RouterPort.port_type.in_(",
            "                lib_constants.ROUTER_INTERFACE_OWNERS",
            "            ),",
            "            models_v2.IPAllocation.subnet_id == internal_subnet['id']",
            "        ).join(",
            "            gw_port, gw_port.device_id == l3_models.RouterPort.router_id",
            "        ).filter(",
            "            gw_port.network_id == external_network_id,",
            "        ).distinct()",
            "",
            "        first_router_id = None",
            "        for router_id, interface_ip in routerport_qry:",
            "            if interface_ip == internal_subnet['gateway_ip']:",
            "                return router_id",
            "            if not first_router_id:",
            "                first_router_id = router_id",
            "        if first_router_id:",
            "            return first_router_id",
            "",
            "        raise l3_exc.ExternalGatewayForFloatingIPNotFound(",
            "            subnet_id=internal_subnet['id'],",
            "            external_network_id=external_network_id,",
            "            port_id=internal_port['id'])",
            "",
            "    def test_floatingip_via_router_interface_returns_404(self):",
            "        self._test_floatingip_via_router_interface(exc.HTTPNotFound.code)",
            "",
            "    def test_floatingip_via_router_interface_returns_201(self):",
            "        # Override get_router_for_floatingip, as",
            "        # networking-midonet's L3 service plugin would do.",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with mock.patch.object(plugin, \"get_router_for_floatingip\",",
            "            self._get_router_for_floatingip_without_device_owner_check):",
            "            self._test_floatingip_via_router_interface(exc.HTTPCreated.code)",
            "",
            "    def test_floatingip_delete_router_intf_with_subnet_id_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_ROUTER_INTF:",
            "                    subnet_id = p['fixed_ips'][0]['subnet_id']",
            "                    router_id = p['device_id']",
            "                    self._router_interface_action(",
            "                        'remove', router_id, subnet_id, None,",
            "                        expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "                    break",
            "        self.assertTrue(found)",
            "",
            "    def test_floatingip_delete_router_intf_with_port_id_returns_409(self):",
            "        found = False",
            "        with self.floatingip_with_assoc():",
            "            for p in self._list('ports')['ports']:",
            "                if p['device_owner'] == lib_constants.DEVICE_OWNER_ROUTER_INTF:",
            "                    router_id = p['device_id']",
            "                    self._router_interface_action(",
            "                        'remove', router_id, None, p['id'],",
            "                        expected_code=exc.HTTPConflict.code)",
            "                    found = True",
            "                    break",
            "        self.assertTrue(found)",
            "",
            "    def _test_router_delete_subnet_inuse_returns_409(self, router, subnet):",
            "        r, s = router, subnet",
            "        self._router_interface_action('add',",
            "                                      r['router']['id'],",
            "                                      s['subnet']['id'],",
            "                                      None)",
            "        # subnet cannot be deleted as it's attached to a router",
            "        self._delete('subnets', s['subnet']['id'],",
            "                     expected_code=exc.HTTPConflict.code)",
            "",
            "    def _ipv6_subnet(self, mode):",
            "        return self.subnet(cidr='fd00::1/64', gateway_ip='fd00::1',",
            "                           ip_version=6,",
            "                           ipv6_ra_mode=mode,",
            "                           ipv6_address_mode=mode)",
            "",
            "    def test_router_delete_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_router_delete_ipv6_slaac_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self._ipv6_subnet(lib_constants.IPV6_SLAAC) as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_router_delete_dhcpv6_stateless_subnet_inuse_returns_409(self):",
            "        with self.router() as r:",
            "            with self._ipv6_subnet(lib_constants.DHCPV6_STATELESS) as s:",
            "                self._test_router_delete_subnet_inuse_returns_409(r, s)",
            "",
            "    def test_delete_ext_net_with_disassociated_floating_ips(self):",
            "        with self.network() as net:",
            "            net_id = net['network']['id']",
            "            self._set_net_external(net_id)",
            "            with self.subnet(network=net):",
            "                self._make_floatingip(self.fmt, net_id)",
            "",
            "    def test_create_floatingip_with_specific_ip(self):",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            fp = self._make_floatingip(self.fmt, network_id,",
            "                                       floating_ip='10.0.0.10')",
            "            self.assertEqual('10.0.0.10',",
            "                             fp['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_specific_ip_out_of_allocation(self):",
            "        with self.subnet(cidr='10.0.0.0/24',",
            "                         allocation_pools=[",
            "                             {'start': '10.0.0.10', 'end': '10.0.0.20'}]",
            "                         ) as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            fp = self._make_floatingip(self.fmt, network_id,",
            "                                       floating_ip='10.0.0.30')",
            "            self.assertEqual('10.0.0.30',",
            "                             fp['floatingip']['floating_ip_address'])",
            "",
            "    def test_create_floatingip_with_specific_ip_non_admin(self):",
            "        ctx = context.Context('user_id', 'tenant_id')",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  set_context=ctx,",
            "                                  floating_ip='10.0.0.10',",
            "                                  http_status=exc.HTTPForbidden.code)",
            "",
            "    def test_create_floatingip_with_specific_ip_out_of_subnet(self):",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.1.10',",
            "                                  http_status=exc.HTTPBadRequest.code)",
            "",
            "    def test_create_floatingip_with_duplicated_specific_ip(self):",
            "",
            "        with self.subnet(cidr='10.0.0.0/24') as s:",
            "            network_id = s['subnet']['network_id']",
            "            self._set_net_external(network_id)",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.0.10')",
            "",
            "            self._make_floatingip(self.fmt, network_id,",
            "                                  floating_ip='10.0.0.10',",
            "                                  http_status=exc.HTTPConflict.code)",
            "",
            "    def test_create_floatingips_native_quotas(self):",
            "        quota = 1",
            "        cfg.CONF.set_override('quota_floatingip', quota, group='QUOTAS')",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                subnet_id=public_sub['subnet']['id'])",
            "            self.assertEqual(exc.HTTPCreated.code, res.status_int)",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'],",
            "                subnet_id=public_sub['subnet']['id'])",
            "            self.assertEqual(exc.HTTPConflict.code, res.status_int)",
            "",
            "    def test_router_specify_id_backend(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        router_req = {'router': {'id': _uuid(), 'name': 'router',",
            "                                 'tenant_id': 'foo',",
            "                                 'admin_state_up': True}}",
            "        result = plugin.create_router(context.Context('', 'foo'), router_req)",
            "        self.assertEqual(router_req['router']['id'], result['id'])",
            "",
            "    def test_create_floatingip_ipv6_only_network_returns_400(self):",
            "        with self.subnet(cidr=\"2001:db8::/48\", ip_version=6) as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            res = self._create_floatingip(",
            "                self.fmt,",
            "                public_sub['subnet']['network_id'])",
            "            self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_ipv6_and_ipv4_network_creates_ipv4(self):",
            "        with self.network() as n,\\",
            "                self.subnet(cidr=\"2001:db8::/48\", ip_version=6, network=n),\\",
            "                self.subnet(cidr=\"192.168.1.0/24\", ip_version=4, network=n):",
            "            self._set_net_external(n['network']['id'])",
            "            fip = self._make_floatingip(self.fmt, n['network']['id'])",
            "            fip_set = netaddr.IPSet(netaddr.IPNetwork(\"192.168.1.0/24\"))",
            "            fip_ip = fip['floatingip']['floating_ip_address']",
            "            self.assertIn(netaddr.IPAddress(fip_ip), fip_set)",
            "",
            "    def test_create_floatingip_with_assoc_to_ipv6_subnet(self):",
            "        with self.subnet() as public_sub:",
            "            self._set_net_external(public_sub['subnet']['network_id'])",
            "            with self.subnet(cidr=\"2001:db8::/48\",",
            "                             ip_version=6) as private_sub:",
            "                with self.port(subnet=private_sub) as private_port:",
            "                    res = self._create_floatingip(",
            "                        self.fmt,",
            "                        public_sub['subnet']['network_id'],",
            "                        port_id=private_port['port']['id'])",
            "                    self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "    def test_create_floatingip_with_assoc_to_ipv4_and_ipv6_port(self):",
            "        with self.network() as n,\\",
            "                self.subnet(cidr='10.0.0.0/24', network=n) as s4,\\",
            "                self.subnet(cidr='2001:db8::/64', ip_version=6, network=n),\\",
            "                self.port(subnet=s4) as p:",
            "            self.assertEqual(2, len(p['port']['fixed_ips']))",
            "            ipv4_address = next(i['ip_address'] for i in",
            "                    p['port']['fixed_ips'] if",
            "                    netaddr.IPAddress(i['ip_address']).version == 4)",
            "            with self.floatingip_with_assoc(port_id=p['port']['id']) as fip:",
            "                self.assertEqual(fip['floatingip']['fixed_ip_address'],",
            "                                 ipv4_address)",
            "                floating_ip = netaddr.IPAddress(",
            "                        fip['floatingip']['floating_ip_address'])",
            "                self.assertEqual(4, floating_ip.version)",
            "",
            "    def test_create_router_gateway_fails_nested(self):",
            "        # Force _update_router_gw_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        ctx = context.Context('', 'foo')",
            "        data = {'router': {",
            "            'name': 'router1', 'admin_state_up': True,",
            "            'external_gateway_info': {'network_id': 'some_uuid'},",
            "            'tenant_id': 'some_tenant'}}",
            "",
            "        def mock_fail__update_router_gw_info(ctx, router_id, info,",
            "                                             router=None):",
            "            # Fail with breaking transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise n_exc.NeutronException",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=mock_fail__update_router_gw_info).start()",
            "",
            "        def create_router_with_transaction(ctx, data):",
            "            # Emulates what many plugins do",
            "            with ctx.session.begin(subtransactions=True):",
            "                plugin.create_router(ctx, data)",
            "",
            "        # Verify router doesn't persist on failure",
            "        self.assertRaises(n_exc.NeutronException,",
            "                          create_router_with_transaction, ctx, data)",
            "        routers = plugin.get_routers(ctx)",
            "        self.assertEqual(0, len(routers))",
            "",
            "    def test_create_router_gateway_fails_nested_delete_router_failed(self):",
            "        # Force _update_router_gw_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        ctx = context.Context('', 'foo')",
            "        data = {'router': {",
            "            'name': 'router1', 'admin_state_up': True,",
            "            'external_gateway_info': {'network_id': 'some_uuid'},",
            "            'tenant_id': 'some_tenant'}}",
            "",
            "        def mock_fail__update_router_gw_info(ctx, router_id, info,",
            "                                             router=None):",
            "            # Fail with breaking transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise n_exc.NeutronException",
            "",
            "        def mock_fail_delete_router(ctx, router_id):",
            "            with ctx.session.begin(subtransactions=True):",
            "                raise Exception()",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=mock_fail__update_router_gw_info).start()",
            "        mock.patch.object(plugin, 'delete_router',",
            "                          mock_fail_delete_router).start()",
            "",
            "        def create_router_with_transaction(ctx, data):",
            "            # Emulates what many plugins do",
            "            with ctx.session.begin(subtransactions=True):",
            "                plugin.create_router(ctx, data)",
            "",
            "        # Verify router doesn't persist on failure",
            "        self.assertRaises(n_exc.NeutronException,",
            "                          create_router_with_transaction, ctx, data)",
            "        routers = plugin.get_routers(ctx)",
            "        self.assertEqual(0, len(routers))",
            "",
            "    def test_router_add_interface_by_port_fails_nested(self):",
            "        # Force _validate_router_port_info failure",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "        orig_update_port = self.plugin.update_port",
            "",
            "        def mock_fail__validate_router_port_info(ctx, router, port_id):",
            "            # Fail with raising BadRequest exception",
            "            msg = \"Failure mocking...\"",
            "            raise n_exc.BadRequest(resource='router', msg=msg)",
            "",
            "        def mock_update_port_with_transaction(ctx, id, port):",
            "            # Update port within a sub-transaction",
            "            with ctx.session.begin(subtransactions=True):",
            "                orig_update_port(ctx, id, port)",
            "",
            "        def add_router_interface_with_transaction(ctx, router_id,",
            "                                                  interface_info):",
            "            # Call add_router_interface() within a sub-transaction",
            "            with ctx.session.begin():",
            "                plugin.add_router_interface(ctx, router_id, interface_info)",
            "",
            "        tenant_id = _uuid()",
            "        ctx = context.Context('', tenant_id)",
            "        with self.network(tenant_id=tenant_id) as network, (",
            "             self.router(name='router1', admin_state_up=True,",
            "                         tenant_id=tenant_id)) as router:",
            "            with self.subnet(network=network, cidr='10.0.0.0/24',",
            "                             tenant_id=tenant_id) as subnet:",
            "                fixed_ips = [{'subnet_id': subnet['subnet']['id']}]",
            "                with self.port(subnet=subnet, fixed_ips=fixed_ips,",
            "                               tenant_id=tenant_id) as port:",
            "                    mock.patch.object(",
            "                        self.plugin, 'update_port',",
            "                        side_effect=(",
            "                            mock_update_port_with_transaction)).start()",
            "                    mock.patch.object(",
            "                        plugin, '_validate_router_port_info',",
            "                        side_effect=(",
            "                            mock_fail__validate_router_port_info)).start()",
            "                    self.assertRaises(n_exc.BadRequest,",
            "                        add_router_interface_with_transaction,",
            "                        ctx, router['router']['id'],",
            "                        {'port_id': port['port']['id']})",
            "",
            "                    # fetch port and confirm device_id and device_owner",
            "                    body = self._show('ports', port['port']['id'])",
            "                    self.assertEqual('', body['port']['device_owner'])",
            "                    self.assertEqual('', body['port']['device_id'])",
            "",
            "    def test_update_subnet_gateway_for_external_net(self):",
            "        \"\"\"Test to make sure notification to routers occurs when the gateway",
            "            ip address of a subnet of the external network is changed.",
            "        \"\"\"",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not hasattr(plugin, 'l3_rpc_notifier'):",
            "            self.skipTest(\"Plugin does not support l3_rpc_notifier\")",
            "        # make sure the callback is registered.",
            "        registry.subscribe(",
            "            l3_db.L3RpcNotifierMixin._notify_subnet_gateway_ip_update,",
            "            resources.SUBNET,",
            "            events.AFTER_UPDATE)",
            "        with mock.patch.object(plugin.l3_rpc_notifier,",
            "                               'routers_updated') as chk_method:",
            "            with self.network() as network:",
            "                allocation_pools = [{'start': '120.0.0.3',",
            "                                     'end': '120.0.0.254'}]",
            "                with self.subnet(network=network,",
            "                                 gateway_ip='120.0.0.1',",
            "                                 allocation_pools=allocation_pools,",
            "                                 cidr='120.0.0.0/24') as subnet:",
            "                    kwargs = {",
            "                        'device_owner': lib_constants.DEVICE_OWNER_ROUTER_GW,",
            "                        'device_id': 'fake_device'}",
            "                    with self.port(subnet=subnet, **kwargs):",
            "                        data = {'subnet': {'gateway_ip': '120.0.0.2'}}",
            "                        req = self.new_update_request('subnets', data,",
            "                                                      subnet['subnet']['id'])",
            "                        res = self.deserialize(self.fmt,",
            "                                               req.get_response(self.api))",
            "                        self.assertEqual(data['subnet']['gateway_ip'],",
            "                                         res['subnet']['gateway_ip'])",
            "                        chk_method.assert_called_with(mock.ANY,",
            "                                                      ['fake_device'], None)",
            "",
            "    def test__notify_subnetpool_address_scope_update(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "",
            "        tenant_id = _uuid()",
            "        with mock.patch.object(",
            "            plugin, 'notify_routers_updated') as chk_method, \\",
            "                self.subnetpool(prefixes=['10.0.0.0/24'],",
            "                                admin=True, name='sp',",
            "                                tenant_id=tenant_id) as subnetpool, \\",
            "                self.router(tenant_id=tenant_id) as router, \\",
            "                self.network(tenant_id=tenant_id) as network:",
            "            subnetpool_id = subnetpool['subnetpool']['id']",
            "            data = {'subnet': {",
            "                    'network_id': network['network']['id'],",
            "                    'subnetpool_id': subnetpool_id,",
            "                    'prefixlen': 24,",
            "                    'ip_version': 4,",
            "                    'tenant_id': tenant_id}}",
            "            req = self.new_create_request('subnets', data)",
            "            subnet = self.deserialize(self.fmt, req.get_response(self.api))",
            "",
            "            admin_ctx = context.get_admin_context()",
            "            plugin.add_router_interface(",
            "                admin_ctx,",
            "                router['router']['id'], {'subnet_id': subnet['subnet']['id']})",
            "            l3_db.L3RpcNotifierMixin._notify_subnetpool_address_scope_update(",
            "                mock.ANY, mock.ANY, mock.ANY,",
            "                context=admin_ctx, subnetpool_id=subnetpool_id)",
            "            chk_method.assert_called_with(admin_ctx, [router['router']['id']])",
            "",
            "    def test_janitor_clears_orphaned_floatingip_port(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.network() as n:",
            "            # floating IP ports are initially created with a device ID of",
            "            # PENDING and are updated after the floating IP is actually",
            "            # created.",
            "            port_res = self._create_port(",
            "                self.fmt, n['network']['id'],",
            "                tenant_id=n['network']['tenant_id'], device_id='PENDING',",
            "                device_owner=lib_constants.DEVICE_OWNER_FLOATINGIP)",
            "            port = self.deserialize(self.fmt, port_res)",
            "            plugin._clean_garbage()",
            "            # first call should just have marked it as a candidate so port",
            "            # should still exist",
            "            port = self._show('ports', port['port']['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            # second call will delete the port since it has no associated",
            "            # floating IP",
            "            plugin._clean_garbage()",
            "            self._show('ports', port['port']['id'],",
            "                       expected_code=exc.HTTPNotFound.code)",
            "",
            "    def test_janitor_updates_port_device_id(self):",
            "        # if a server dies after the floating IP is created but before it",
            "        # updates the floating IP port device ID, the janitor will be",
            "        # responsible for updating the device ID to the correct value.",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.floatingip_with_assoc() as fip:",
            "            fip_port = self._list('ports',",
            "               query_params='device_owner=network:floatingip')['ports'][0]",
            "            # simulate a failed update by just setting the device_id of",
            "            # the fip port back to PENDING",
            "            data = {'port': {'device_id': 'PENDING'}}",
            "            self._update('ports', fip_port['id'], data)",
            "            plugin._clean_garbage()",
            "            # first call just marks as candidate, so it shouldn't be changed",
            "            port = self._show('ports', fip_port['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            # second call updates device ID to fip",
            "            plugin._clean_garbage()",
            "            # first call just marks as candidate, so it shouldn't be changed",
            "            port = self._show('ports', fip_port['id'])",
            "            self.assertEqual(fip['floatingip']['id'],",
            "                             port['port']['device_id'])",
            "",
            "    def test_janitor_doesnt_delete_if_fixed_in_interim(self):",
            "        # here we ensure that the janitor doesn't delete the port on the second",
            "        # call if the conditions have been fixed",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        with self.network() as n:",
            "            port_res = self._create_port(",
            "                self.fmt, n['network']['id'],",
            "                tenant_id=n['network']['tenant_id'], device_id='PENDING',",
            "                device_owner=lib_constants.DEVICE_OWNER_FLOATINGIP)",
            "            port = self.deserialize(self.fmt, port_res)",
            "            plugin._clean_garbage()",
            "            # first call should just have marked it as a candidate so port",
            "            # should still exist",
            "            port = self._show('ports', port['port']['id'])",
            "            self.assertEqual('PENDING', port['port']['device_id'])",
            "            data = {'port': {'device_id': 'something_else'}}",
            "            self._update('ports', port['port']['id'], data)",
            "            # now that the device ID has changed, the janitor shouldn't delete",
            "            plugin._clean_garbage()",
            "            self._show('ports', port['port']['id'])",
            "",
            "    def test_router_delete_callback(self):",
            "        def prevent_router_deletion(*args, **kwargs):",
            "            # unsubscribe now that we have invoked the callback",
            "            registry.unsubscribe(prevent_router_deletion, resources.ROUTER,",
            "                                 events.BEFORE_DELETE)",
            "            raise exc.HTTPForbidden",
            "",
            "        registry.subscribe(prevent_router_deletion, resources.ROUTER,",
            "                           events.BEFORE_DELETE)",
            "",
            "        with self.subnet():",
            "            res = self._create_router(self.fmt, _uuid())",
            "            router = self.deserialize(self.fmt, res)",
            "            self._delete('routers', router['router']['id'],",
            "                         exc.HTTPForbidden.code)",
            "",
            "    def test_associate_to_dhcp_port_fails(self):",
            "        with self.subnet(cidr=\"10.0.0.0/24\", ip_version=4) as sub:",
            "            with self.port(subnet=sub,",
            "                           device_owner=lib_constants.DEVICE_OWNER_DHCP) as p:",
            "                res = self._create_floatingip(",
            "                     self.fmt,",
            "                     sub['subnet']['network_id'],",
            "                     port_id=p['port']['id'])",
            "                self.assertEqual(exc.HTTPBadRequest.code, res.status_int)",
            "",
            "",
            "class L3AgentDbTestCaseBase(L3NatTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent.\"\"\"",
            "",
            "    def test_l3_agent_routers_query_interfaces(self):",
            "        with self.router() as r:",
            "            with self.port() as p:",
            "                self._router_interface_action('add',",
            "                                              r['router']['id'],",
            "                                              None,",
            "                                              p['port']['id'])",
            "",
            "                routers = self.plugin.get_sync_data(",
            "                    context.get_admin_context(), None)",
            "                self.assertEqual(1, len(routers))",
            "                interfaces = routers[0][lib_constants.INTERFACE_KEY]",
            "                self.assertEqual(1, len(interfaces))",
            "                subnets = interfaces[0]['subnets']",
            "                self.assertEqual(1, len(subnets))",
            "                subnet_id = subnets[0]['id']",
            "                wanted_subnetid = p['port']['fixed_ips'][0]['subnet_id']",
            "                self.assertEqual(wanted_subnetid, subnet_id)",
            "",
            "    def test_l3_agent_sync_interfaces(self):",
            "        \"\"\"Test L3 interfaces query return valid result\"\"\"",
            "        with self.router() as router1, self.router() as router2:",
            "            with self.port() as port1, self.port() as port2:",
            "                self._router_interface_action('add',",
            "                                              router1['router']['id'],",
            "                                              None,",
            "                                              port1['port']['id'])",
            "                self._router_interface_action('add',",
            "                                              router2['router']['id'],",
            "                                              None,",
            "                                              port2['port']['id'])",
            "                admin_ctx = context.get_admin_context()",
            "                router1_id = router1['router']['id']",
            "                router2_id = router2['router']['id']",
            "",
            "                # Verify if router1 pass in, return only interface from router1",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx,",
            "                                                          [router1_id])",
            "                self.assertEqual(1, len(ifaces))",
            "                self.assertEqual(router1_id,",
            "                                 ifaces[0]['device_id'])",
            "",
            "                # Verify if router1 and router2 pass in, return both interfaces",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx,",
            "                                                          [router1_id,",
            "                                                           router2_id])",
            "                self.assertEqual(2, len(ifaces))",
            "                device_list = [i['device_id'] for i in ifaces]",
            "                self.assertIn(router1_id, device_list)",
            "                self.assertIn(router2_id, device_list)",
            "",
            "                # Verify if no router pass in, return empty list",
            "                ifaces = self.plugin._get_sync_interfaces(admin_ctx, None)",
            "                self.assertEqual(0, len(ifaces))",
            "",
            "    def test_l3_agent_routers_query_ignore_interfaces_with_moreThanOneIp(self):",
            "        with self.router() as r:",
            "            with self.subnet(cidr='9.0.1.0/24') as subnet:",
            "                with self.port(subnet=subnet,",
            "                               fixed_ips=[{'ip_address': '9.0.1.3'}]) as p:",
            "                    self._router_interface_action('add',",
            "                                                  r['router']['id'],",
            "                                                  None,",
            "                                                  p['port']['id'])",
            "                    port = {'port': {'fixed_ips':",
            "                                     [{'ip_address': '9.0.1.4',",
            "                                       'subnet_id': subnet['subnet']['id']},",
            "                                      {'ip_address': '9.0.1.5',",
            "                                       'subnet_id': subnet['subnet']['id']}]}}",
            "                    ctx = context.get_admin_context()",
            "                    self.core_plugin.update_port(ctx, p['port']['id'], port)",
            "                    routers = self.plugin.get_sync_data(ctx, None)",
            "                    self.assertEqual(1, len(routers))",
            "                    interfaces = routers[0].get(lib_constants.INTERFACE_KEY,",
            "                                                [])",
            "                    self.assertEqual(1, len(interfaces))",
            "",
            "    def test_l3_agent_routers_query_gateway(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                routers = self.plugin.get_sync_data(",
            "                    context.get_admin_context(), [r['router']['id']])",
            "                self.assertEqual(1, len(routers))",
            "                gw_port = routers[0]['gw_port']",
            "                subnets = gw_port.get('subnets')",
            "                self.assertEqual(1, len(subnets))",
            "                self.assertEqual(s['subnet']['id'], subnets[0]['id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "",
            "    def test_l3_agent_routers_query_floatingips(self):",
            "        with self.floatingip_with_assoc() as fip:",
            "            routers = self.plugin.get_sync_data(",
            "                context.get_admin_context(), [fip['floatingip']['router_id']])",
            "            self.assertEqual(1, len(routers))",
            "            floatingips = routers[0][lib_constants.FLOATINGIP_KEY]",
            "            self.assertEqual(1, len(floatingips))",
            "            self.assertEqual(floatingips[0]['id'],",
            "                             fip['floatingip']['id'])",
            "            self.assertEqual(floatingips[0]['port_id'],",
            "                             fip['floatingip']['port_id'])",
            "            self.assertIsNotNone(floatingips[0]['fixed_ip_address'])",
            "            self.assertIsNotNone(floatingips[0]['router_id'])",
            "",
            "    def _test_notify_op_agent(self, target_func, *args):",
            "        l3_rpc_agent_api_str = (",
            "            'neutron.api.rpc.agentnotifiers.l3_rpc_agent_api.L3AgentNotifyAPI')",
            "        with mock.patch(l3_rpc_agent_api_str):",
            "            plugin = directory.get_plugin(plugin_constants.L3)",
            "            notifyApi = plugin.l3_rpc_notifier",
            "            kargs = [item for item in args]",
            "            kargs.append(notifyApi)",
            "            target_func(*kargs)",
            "",
            "    def _test_router_gateway_op_agent(self, notifyApi):",
            "        with self.router() as r:",
            "            with self.subnet() as s:",
            "                self._set_net_external(s['subnet']['network_id'])",
            "                self._add_external_gateway_to_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self._remove_external_gateway_from_router(",
            "                    r['router']['id'],",
            "                    s['subnet']['network_id'])",
            "                self.assertEqual(",
            "                    2, notifyApi.routers_updated.call_count)",
            "",
            "    def test_router_gateway_op_agent(self):",
            "        self._test_notify_op_agent(self._test_router_gateway_op_agent)",
            "",
            "    def _test_interfaces_op_agent(self, r, notifyApi):",
            "        with self.port() as p:",
            "            self._router_interface_action('add',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "            # clean-up",
            "            self._router_interface_action('remove',",
            "                                          r['router']['id'],",
            "                                          None,",
            "                                          p['port']['id'])",
            "        self.assertEqual(2, notifyApi.routers_updated.call_count)",
            "",
            "    def test_interfaces_op_agent(self):",
            "        with self.router() as r:",
            "            self._test_notify_op_agent(",
            "                self._test_interfaces_op_agent, r)",
            "",
            "    def _test_floatingips_op_agent(self, notifyApi):",
            "        with self.floatingip_with_assoc():",
            "            pass",
            "        # add gateway, add interface, associate, deletion of floatingip",
            "        self.assertEqual(4, notifyApi.routers_updated.call_count)",
            "",
            "    def test_floatingips_op_agent(self):",
            "        self._test_notify_op_agent(self._test_floatingips_op_agent)",
            "",
            "    def test_floatingips_create_precommit_event(self):",
            "        fake_method = mock.Mock()",
            "        try:",
            "            registry.subscribe(fake_method, resources.FLOATING_IP,",
            "                               events.PRECOMMIT_CREATE)",
            "            with self.floatingip_with_assoc() as f:",
            "                fake_method.assert_called_once_with(",
            "                    resources.FLOATING_IP, events.PRECOMMIT_CREATE, mock.ANY,",
            "                    context=mock.ANY, floatingip=mock.ANY,",
            "                    floatingip_id=f['floatingip']['id'],",
            "                    floatingip_db=mock.ANY)",
            "        finally:",
            "            registry.unsubscribe(fake_method, resources.FLOATING_IP,",
            "                                 events.PRECOMMIT_CREATE)",
            "",
            "    def test_router_create_precommit_event(self):",
            "        nset = lambda *a, **k: setattr(k['router_db'], 'name', 'hello')",
            "        registry.subscribe(nset, resources.ROUTER, events.PRECOMMIT_CREATE)",
            "        with self.router() as r:",
            "            self.assertEqual('hello', r['router']['name'])",
            "",
            "    def test_router_create_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 404",
            "        e404 = mock.Mock(side_effect=l3_exc.RouterNotFound(router_id='1'))",
            "        registry.subscribe(e404, resources.ROUTER, events.PRECOMMIT_CREATE)",
            "        res = self._create_router(self.fmt, 'tenid')",
            "        self.assertEqual(exc.HTTPNotFound.code, res.status_int)",
            "        # make sure nothing committed",
            "        body = self._list('routers')",
            "        self.assertFalse(body['routers'])",
            "",
            "    def test_router_update_precommit_event(self):",
            "",
            "        def _nset(r, v, s, payload=None):",
            "            setattr(payload.desired_state, 'name',",
            "                    payload.states[0]['name'] + '_ha!')",
            "",
            "        registry.subscribe(_nset, resources.ROUTER, events.PRECOMMIT_UPDATE)",
            "        with self.router(name='original') as r:",
            "            update = self._update('routers', r['router']['id'],",
            "                                  {'router': {'name': 'hi'}})",
            "            # our rude callback should have changed the name to the original",
            "            # plus some extra",
            "            self.assertEqual('original_ha!', update['router']['name'])",
            "",
            "    def test_router_update_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 404",
            "        e404 = mock.Mock(side_effect=l3_exc.RouterNotFound(router_id='1'))",
            "        registry.subscribe(e404, resources.ROUTER, events.PRECOMMIT_UPDATE)",
            "        with self.router(name='a') as r:",
            "            self._update('routers', r['router']['id'],",
            "                         {'router': {'name': 'hi'}},",
            "                         expected_code=exc.HTTPNotFound.code)",
            "        # ensure it stopped the commit",
            "        new = self._show('routers', r['router']['id'])",
            "        self.assertEqual('a', new['router']['name'])",
            "",
            "    def test_router_delete_precommit_event(self):",
            "        deleted = []",
            "        auditor = lambda *a, **k: deleted.append(k['router_id'])",
            "        registry.subscribe(auditor, resources.ROUTER, events.PRECOMMIT_DELETE)",
            "        with self.router() as r:",
            "            self._delete('routers', r['router']['id'])",
            "        self.assertEqual([r['router']['id']], deleted)",
            "",
            "    def test_router_delete_event_exception_preserved(self):",
            "        # this exception should be propagated out of the callback and",
            "        # converted into its API equivalent of 409",
            "        e409 = mock.Mock(side_effect=l3_exc.RouterInUse(router_id='1'))",
            "        registry.subscribe(e409, resources.ROUTER, events.PRECOMMIT_DELETE)",
            "        with self.router() as r:",
            "            self._delete('routers', r['router']['id'],",
            "                         expected_code=exc.HTTPConflict.code)",
            "        # ensure it stopped the commit",
            "        self.assertTrue(self._show('routers', r['router']['id']))",
            "",
            "",
            "class L3BaseForIntTests(test_db_base_plugin_v2.NeutronDbPluginV2TestCase):",
            "",
            "    mock_rescheduling = True",
            "",
            "    def setUp(self, plugin=None, ext_mgr=None, service_plugins=None):",
            "        if not plugin:",
            "            plugin = 'neutron.tests.unit.extensions.test_l3.TestL3NatIntPlugin'",
            "        # for these tests we need to enable overlapping ips",
            "        cfg.CONF.set_default('allow_overlapping_ips', True)",
            "        ext_mgr = ext_mgr or L3TestExtensionManager()",
            "",
            "        if self.mock_rescheduling:",
            "            mock.patch('%s._check_router_needs_rescheduling' % plugin,",
            "                       new=lambda *a: False).start()",
            "",
            "        super(L3BaseForIntTests, self).setUp(plugin=plugin, ext_mgr=ext_mgr,",
            "                                             service_plugins=service_plugins)",
            "",
            "        self.setup_notification_driver()",
            "",
            "",
            "class L3BaseForSepTests(test_db_base_plugin_v2.NeutronDbPluginV2TestCase):",
            "",
            "    def setUp(self, plugin=None, ext_mgr=None):",
            "        # the plugin without L3 support",
            "        if not plugin:",
            "            plugin = 'neutron.tests.unit.extensions.test_l3.TestNoL3NatPlugin'",
            "        # the L3 service plugin",
            "        l3_plugin = ('neutron.tests.unit.extensions.test_l3.'",
            "                     'TestL3NatServicePlugin')",
            "        service_plugins = {'l3_plugin_name': l3_plugin}",
            "",
            "        # for these tests we need to enable overlapping ips",
            "        cfg.CONF.set_default('allow_overlapping_ips', True)",
            "        if not ext_mgr:",
            "            ext_mgr = L3TestExtensionManager()",
            "        super(L3BaseForSepTests, self).setUp(plugin=plugin, ext_mgr=ext_mgr,",
            "                                             service_plugins=service_plugins)",
            "",
            "        self.setup_notification_driver()",
            "",
            "",
            "class L3NatDBIntAgentSchedulingTestCase(L3BaseForIntTests,",
            "                                        L3NatTestCaseMixin,",
            "                                        test_agent.",
            "                                        AgentDBTestMixIn):",
            "",
            "    \"\"\"Unit tests for core plugin with L3 routing and scheduling integrated.\"\"\"",
            "",
            "    def setUp(self, plugin='neutron.tests.unit.extensions.test_l3.'",
            "                           'TestL3NatIntAgentSchedulingPlugin',",
            "              ext_mgr=None, service_plugins=None):",
            "        self.mock_rescheduling = False",
            "        super(L3NatDBIntAgentSchedulingTestCase, self).setUp(",
            "            plugin, ext_mgr, service_plugins)",
            "        self.adminContext = context.get_admin_context()",
            "",
            "    def _assert_router_on_agent(self, router_id, agent_host):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        agents = plugin.list_l3_agents_hosting_router(",
            "            self.adminContext, router_id)['agents']",
            "        self.assertEqual(1, len(agents))",
            "        self.assertEqual(agents[0]['host'], agent_host)",
            "",
            "    def test_update_gateway_agent_exists_supporting_network(self):",
            "        with self.router() as r, self.subnet() as s1, self.subnet() as s2:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "            helpers.register_l3_agent(",
            "                host='host1',",
            "                ext_net_id=s1['subnet']['network_id'])",
            "            helpers.register_l3_agent(",
            "                host='host2', internal_only=False,",
            "                ext_net_id=s2['subnet']['network_id'])",
            "            l3_rpc_cb.get_router_ids(self.adminContext,",
            "                                     host='host1')",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._set_net_external(s2['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s2['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host2')",
            "",
            "    def test_update_gateway_agent_exists_supporting_multiple_network(self):",
            "        with self.router() as r, self.subnet() as s1, self.subnet() as s2:",
            "            self._set_net_external(s1['subnet']['network_id'])",
            "            l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "            helpers.register_l3_agent(",
            "                host='host1',",
            "                ext_net_id=s1['subnet']['network_id'])",
            "            helpers.register_l3_agent(",
            "                host='host2', internal_only=False,",
            "                ext_net_id='', ext_bridge='')",
            "            l3_rpc_cb.get_router_ids(self.adminContext,",
            "                                     host='host1')",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s1['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host1')",
            "",
            "            self._set_net_external(s2['subnet']['network_id'])",
            "            self._add_external_gateway_to_router(",
            "                r['router']['id'],",
            "                s2['subnet']['network_id'])",
            "            self._assert_router_on_agent(r['router']['id'], 'host2')",
            "",
            "    def test_router_update_gateway_scheduling_not_supported(self):",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        mock.patch.object(plugin, 'router_supports_scheduling',",
            "                          return_value=False).start()",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    # this should pass even though there are multiple",
            "                    # external networks since no scheduling decision needs",
            "                    # to be made",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'])",
            "",
            "    def test_router_update_gateway_no_eligible_l3_agent(self):",
            "        with self.router() as r:",
            "            with self.subnet() as s1:",
            "                with self.subnet() as s2:",
            "                    self._set_net_external(s1['subnet']['network_id'])",
            "                    self._set_net_external(s2['subnet']['network_id'])",
            "                    self._add_external_gateway_to_router(",
            "                        r['router']['id'],",
            "                        s1['subnet']['network_id'],",
            "                        expected_code=exc.HTTPBadRequest.code)",
            "",
            "",
            "class L3RpcCallbackTestCase(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(L3RpcCallbackTestCase, self).setUp()",
            "        self.mock_plugin = mock.patch.object(",
            "            l3_rpc.L3RpcCallback,",
            "            'plugin', new_callable=mock.PropertyMock).start()",
            "        self.mock_l3plugin = mock.patch.object(",
            "            l3_rpc.L3RpcCallback,",
            "            'l3plugin', new_callable=mock.PropertyMock).start()",
            "        self.l3_rpc_cb = l3_rpc.L3RpcCallback()",
            "",
            "    def test__ensure_host_set_on_port_host_id_none(self):",
            "        port = {'id': 'id', portbindings.HOST_ID: 'somehost'}",
            "        self.l3_rpc_cb._ensure_host_set_on_port(None, None, port)",
            "        self.assertFalse(self.l3_rpc_cb.plugin.update_port.called)",
            "",
            "    def test__ensure_host_set_on_port_bad_bindings(self):",
            "        for b in (portbindings.VIF_TYPE_BINDING_FAILED,",
            "                  portbindings.VIF_TYPE_UNBOUND):",
            "            port = {'id': 'id', portbindings.HOST_ID: 'somehost',",
            "                    portbindings.VIF_TYPE: b}",
            "            self.l3_rpc_cb._ensure_host_set_on_port(None, 'somehost', port)",
            "            self.assertTrue(self.l3_rpc_cb.plugin.update_port.called)",
            "",
            "    def test__ensure_host_set_on_port_update_on_concurrent_delete(self):",
            "        port_id = 'foo_port_id'",
            "        port = {",
            "            'id': port_id,",
            "            'device_owner': DEVICE_OWNER_COMPUTE,",
            "            portbindings.HOST_ID: '',",
            "            portbindings.VIF_TYPE: portbindings.VIF_TYPE_BINDING_FAILED",
            "        }",
            "        router_id = 'foo_router_id'",
            "        self.l3_rpc_cb.plugin.update_port.side_effect = n_exc.PortNotFound(",
            "            port_id=port_id)",
            "        with mock.patch.object(l3_rpc.LOG, 'debug') as mock_log:",
            "            self.l3_rpc_cb._ensure_host_set_on_port(",
            "                mock.ANY, mock.ANY, port, router_id)",
            "        self.l3_rpc_cb.plugin.update_port.assert_called_once_with(",
            "            mock.ANY, port_id, {'port': {portbindings.HOST_ID: mock.ANY}})",
            "        self.assertTrue(mock_log.call_count)",
            "        expected_message = ('Port foo_port_id not found while updating '",
            "                            'agent binding for router foo_router_id.')",
            "        actual_message = mock_log.call_args[0][0] % mock_log.call_args[0][1]",
            "        self.assertEqual(expected_message, actual_message)",
            "",
            "",
            "class L3AgentDbIntTestCase(L3BaseForIntTests, L3AgentDbTestCaseBase):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent for",
            "    the case where core plugin implements L3 routing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3AgentDbIntTestCase, self).setUp()",
            "        self.core_plugin = TestL3NatIntPlugin()",
            "        self.plugin = self.core_plugin",
            "",
            "",
            "class L3AgentDbSepTestCase(L3BaseForSepTests, L3AgentDbTestCaseBase):",
            "",
            "    \"\"\"Unit tests for methods called by the L3 agent for the",
            "    case where separate service plugin implements L3 routing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3AgentDbSepTestCase, self).setUp()",
            "        self.core_plugin = TestNoL3NatPlugin()",
            "        self.plugin = TestL3NatServicePlugin()",
            "",
            "",
            "class TestL3DbOperationBounds(test_db_base_plugin_v2.DbOperationBoundMixin,",
            "                              L3NatTestCaseMixin,",
            "                              ml2_base.ML2TestFramework):",
            "    def setUp(self):",
            "        super(TestL3DbOperationBounds, self).setUp()",
            "        ext_mgr = L3TestExtensionManager()",
            "        self.ext_api = test_extensions.setup_extensions_middleware(ext_mgr)",
            "        self.kwargs = self.get_api_kwargs()",
            "",
            "    def test_router_list_queries_constant(self):",
            "        with self.subnet(**self.kwargs) as s:",
            "            self._set_net_external(s['subnet']['network_id'])",
            "",
            "            def router_maker():",
            "                ext_info = {'network_id': s['subnet']['network_id']}",
            "                res = self._create_router(",
            "                                    self.fmt,",
            "                                    arg_list=('external_gateway_info',),",
            "                                    external_gateway_info=ext_info,",
            "                                    **self.kwargs)",
            "                return self.deserialize(self.fmt, res)",
            "",
            "            self._assert_object_list_queries_constant(router_maker, 'routers')",
            "",
            "",
            "class TestL3DbOperationBoundsTenant(TestL3DbOperationBounds):",
            "    admin = False",
            "",
            "",
            "class L3NatDBTestCaseMixin(object):",
            "    \"\"\"L3_NAT_dbonly_mixin specific test cases.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(L3NatDBTestCaseMixin, self).setUp()",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        if not isinstance(plugin, l3_db.L3_NAT_dbonly_mixin):",
            "            self.skipTest(\"Plugin is not L3_NAT_dbonly_mixin\")",
            "",
            "    def test_create_router_gateway_fails(self):",
            "        \"\"\"Force _update_router_gw_info failure and see",
            "        the exception is propagated.",
            "        \"\"\"",
            "",
            "        plugin = directory.get_plugin(plugin_constants.L3)",
            "        ctx = context.Context('', 'foo')",
            "",
            "        class MyException(Exception):",
            "            pass",
            "",
            "        mock.patch.object(plugin, '_update_router_gw_info',",
            "                          side_effect=MyException).start()",
            "        with self.network() as n:",
            "            data = {'router': {",
            "                'name': 'router1', 'admin_state_up': True,",
            "                'tenant_id': ctx.tenant_id,",
            "                'external_gateway_info': {'network_id': n['network']['id']}}}",
            "",
            "            self.assertRaises(MyException, plugin.create_router, ctx, data)",
            "            # Verify router doesn't persist on failure",
            "            routers = plugin.get_routers(ctx)",
            "            self.assertEqual(0, len(routers))",
            "",
            "",
            "class L3NatDBIntTestCase(L3BaseForIntTests, L3NatTestCaseBase,",
            "                         L3NatDBTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for core plugin with L3 routing integrated.\"\"\"",
            "    pass",
            "",
            "",
            "class L3NatDBSepTestCase(L3BaseForSepTests, L3NatTestCaseBase,",
            "                         L3NatDBTestCaseMixin):",
            "",
            "    \"\"\"Unit tests for a separate L3 routing service plugin.\"\"\"",
            "",
            "    def test_port_deletion_prevention_handles_missing_port(self):",
            "        pl = directory.get_plugin(plugin_constants.L3)",
            "        self.assertIsNone(",
            "            pl.prevent_l3_port_deletion(context.get_admin_context(), 'fakeid')",
            "        )",
            "",
            "",
            "class L3TestExtensionManagerWithDNS(L3TestExtensionManager):",
            "",
            "    def get_resources(self):",
            "        return l3.L3.get_resources()",
            "",
            "",
            "class L3NatDBFloatingIpTestCaseWithDNS(L3BaseForSepTests, L3NatTestCaseMixin):",
            "    \"\"\"Unit tests for floating ip with external DNS integration\"\"\"",
            "",
            "    fmt = 'json'",
            "    DNS_NAME = 'test'",
            "    DNS_DOMAIN = 'test-domain.org.'",
            "    PUBLIC_CIDR = '11.0.0.0/24'",
            "    PRIVATE_CIDR = '10.0.0.0/24'",
            "    mock_client = mock.MagicMock()",
            "    mock_admin_client = mock.MagicMock()",
            "    MOCK_PATH = ('neutron.services.externaldns.drivers.'",
            "                 'designate.driver.get_clients')",
            "    mock_config = {'return_value': (mock_client, mock_admin_client)}",
            "    _extension_drivers = ['dns']",
            "",
            "    def setUp(self):",
            "        ext_mgr = L3TestExtensionManagerWithDNS()",
            "        plugin = 'neutron.plugins.ml2.plugin.Ml2Plugin'",
            "        cfg.CONF.set_override('extension_drivers',",
            "                              self._extension_drivers,",
            "                              group='ml2')",
            "        super(L3NatDBFloatingIpTestCaseWithDNS, self).setUp(plugin=plugin,",
            "                                                            ext_mgr=ext_mgr)",
            "        cfg.CONF.set_override('external_dns_driver', 'designate')",
            "        self.mock_client.reset_mock()",
            "        self.mock_admin_client.reset_mock()",
            "",
            "    def _create_network(self, fmt, name, admin_state_up,",
            "                        arg_list=None, set_context=False, tenant_id=None,",
            "                        **kwargs):",
            "        new_arg_list = ('dns_domain',)",
            "        if arg_list is not None:",
            "            new_arg_list = arg_list + new_arg_list",
            "        return super(L3NatDBFloatingIpTestCaseWithDNS,",
            "                     self)._create_network(fmt, name, admin_state_up,",
            "                                           arg_list=new_arg_list,",
            "                                           set_context=set_context,",
            "                                           tenant_id=tenant_id,",
            "                                           **kwargs)",
            "",
            "    def _create_port(self, fmt, name, admin_state_up,",
            "                     arg_list=None, set_context=False, tenant_id=None,",
            "                     **kwargs):",
            "        new_arg_list = ('dns_name',)",
            "        if arg_list is not None:",
            "            new_arg_list = arg_list + new_arg_list",
            "        return super(L3NatDBFloatingIpTestCaseWithDNS,",
            "                     self)._create_port(fmt, name, admin_state_up,",
            "                                        arg_list=new_arg_list,",
            "                                        set_context=set_context,",
            "                                        tenant_id=tenant_id,",
            "                                        **kwargs)",
            "",
            "    def _create_net_sub_port(self, dns_domain='', dns_name=''):",
            "        with self.network(dns_domain=dns_domain) as n:",
            "            with self.subnet(cidr=self.PRIVATE_CIDR, network=n) as private_sub:",
            "                with self.port(private_sub, dns_name=dns_name) as p:",
            "                    return n, private_sub, p",
            "",
            "    @contextlib.contextmanager",
            "    def _create_floatingip_with_dns(self, net_dns_domain='', port_dns_name='',",
            "                                    flip_dns_domain='', flip_dns_name='',",
            "                                    assoc_port=False, private_sub=None):",
            "",
            "        if private_sub is None:",
            "            n, private_sub, p = self._create_net_sub_port(",
            "                    dns_domain=net_dns_domain, dns_name=port_dns_name)",
            "",
            "        data = {'fmt': self.fmt}",
            "        data['dns_domain'] = flip_dns_domain",
            "        data['dns_name'] = flip_dns_name",
            "",
            "        # Set ourselves up to call the right function with",
            "        # the right arguments for the with block",
            "        if assoc_port:",
            "            data['tenant_id'] = n['network']['tenant_id']",
            "            data['port_id'] = p['port']['id']",
            "            create_floatingip = self.floatingip_with_assoc",
            "        else:",
            "            data['private_sub'] = private_sub",
            "            create_floatingip = self.floatingip_no_assoc",
            "",
            "        with create_floatingip(**data) as flip:",
            "            yield flip['floatingip']",
            "",
            "    @contextlib.contextmanager",
            "    def _create_floatingip_with_dns_on_update(self, net_dns_domain='',",
            "               port_dns_name='', flip_dns_domain='', flip_dns_name=''):",
            "        n, private_sub, p = self._create_net_sub_port(",
            "                dns_domain=net_dns_domain, dns_name=port_dns_name)",
            "        with self._create_floatingip_with_dns(flip_dns_domain=flip_dns_domain,",
            "                flip_dns_name=flip_dns_name, private_sub=private_sub) as flip:",
            "            flip_id = flip['id']",
            "            data = {'floatingip': {'port_id': p['port']['id']}}",
            "            req = self.new_update_request('floatingips', data, flip_id)",
            "            res = req.get_response(self._api_for_resource('floatingip'))",
            "            self.assertEqual(200, res.status_code)",
            "",
            "            floatingip = self.deserialize(self.fmt, res)['floatingip']",
            "            self.assertEqual(p['port']['id'], floatingip['port_id'])",
            "",
            "            yield flip",
            "",
            "    def _get_in_addr_zone_name(self, in_addr_name):",
            "        units = self._get_bytes_or_nybles_to_skip(in_addr_name)",
            "        return '.'.join(in_addr_name.split('.')[int(units):])",
            "",
            "    def _get_bytes_or_nybles_to_skip(self, in_addr_name):",
            "        if 'in-addr.arpa' in in_addr_name:",
            "            return ((",
            "                32 - cfg.CONF.designate.ipv4_ptr_zone_prefix_size) / 8)",
            "        return (128 - cfg.CONF.designate.ipv6_ptr_zone_prefix_size) / 4",
            "",
            "    def _get_in_addr(self, record):",
            "        in_addr_name = netaddr.IPAddress(record).reverse_dns",
            "        in_addr_zone_name = self._get_in_addr_zone_name(in_addr_name)",
            "        return in_addr_name, in_addr_zone_name",
            "",
            "    def _assert_recordset_created(self, floating_ip_address):",
            "        # The recordsets.create function should be called with:",
            "        # dns_domain, dns_name, 'A', ip_address ('A' for IPv4, 'AAAA' for IPv6)",
            "        self.mock_client.recordsets.create.assert_called_with(self.DNS_DOMAIN,",
            "                self.DNS_NAME, 'A', [floating_ip_address])",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floating_ip_address)",
            "        self.mock_admin_client.recordsets.create.assert_called_with(",
            "                in_addr_zone_name, in_addr_name, 'PTR',",
            "                ['%s.%s' % (self.DNS_NAME, self.DNS_DOMAIN)])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create(self, mock_args):",
            "        with self._create_floatingip_with_dns():",
            "            pass",
            "        self.mock_client.recordsets.create.assert_not_called()",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_flip_dns(self, mock_args):",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_net_port_dns(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_create_with_flip_and_net_port_dns(self, mock_args):",
            "        # If both network+port and the floating ip have dns domain and",
            "        # dns name, floating ip's information should take priority",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain='junkdomain.org.',",
            "                port_dns_name='junk', flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            floatingip = flip",
            "        # External DNS service should have been called with floating ip's",
            "        # dns information, not the network+port's dns information",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port(self, mock_args):",
            "        with self._create_floatingip_with_dns_on_update():",
            "            pass",
            "        self.mock_client.recordsets.create.assert_not_called()",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_flip_dns(self, mock_args):",
            "        with self._create_floatingip_with_dns_on_update(",
            "                flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_net_port_dns(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns_on_update(",
            "                net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_associate_port_with_flip_and_net_port_dns(self,",
            "                                                                  mock_args):",
            "        # If both network+port and the floating ip have dns domain and",
            "        # dns name, floating ip's information should take priority",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns_on_update(",
            "                net_dns_domain='junkdomain.org.',",
            "                port_dns_name='junk',",
            "                flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "        self._assert_recordset_created(floatingip['floating_ip_address'])",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_disassociate_port(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(net_dns_domain=self.DNS_DOMAIN,",
            "                port_dns_name=self.DNS_NAME, assoc_port=True) as flip:",
            "            fake_recordset = {'id': '',",
            "                    'records': [flip['floating_ip_address']]}",
            "            # This method is called during recordset deletion, which",
            "            # will fail unless the list function call returns something like",
            "            # this fake value",
            "            self.mock_client.recordsets.list.return_value = ([fake_recordset])",
            "            # Port gets disassociated if port_id is not in the request body",
            "            data = {'floatingip': {}}",
            "            req = self.new_update_request('floatingips', data, flip['id'])",
            "            res = req.get_response(self._api_for_resource('floatingip'))",
            "        floatingip = self.deserialize(self.fmt, res)['floatingip']",
            "        flip_port_id = floatingip['port_id']",
            "        self.assertEqual(200, res.status_code)",
            "        self.assertIsNone(flip_port_id)",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floatingip['floating_ip_address'])",
            "        self.mock_client.recordsets.delete.assert_called_with(",
            "                self.DNS_DOMAIN, '')",
            "        self.mock_admin_client.recordsets.delete.assert_called_with(",
            "                in_addr_zone_name, in_addr_name)",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_delete(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "            # This method is called during recordset deletion, which will",
            "            # fail unless the list function call returns something like",
            "            # this fake value",
            "            fake_recordset = {'id': '',",
            "                              'records': [floatingip['floating_ip_address']]}",
            "            self.mock_client.recordsets.list.return_value = [fake_recordset]",
            "        in_addr_name, in_addr_zone_name = self._get_in_addr(",
            "                floatingip['floating_ip_address'])",
            "        self.mock_client.recordsets.delete.assert_called_with(",
            "                self.DNS_DOMAIN, '')",
            "        self.mock_admin_client.recordsets.delete.assert_called_with(",
            "                in_addr_zone_name, in_addr_name)",
            "",
            "    @mock.patch(MOCK_PATH, **mock_config)",
            "    def test_floatingip_no_PTR_record(self, mock_args):",
            "        cfg.CONF.set_override('dns_domain', self.DNS_DOMAIN)",
            "",
            "        # Disabling this option should stop the admin client from creating",
            "        # PTR records. So set this option and make sure the admin client",
            "        # wasn't called to create any records",
            "        cfg.CONF.set_override('allow_reverse_dns_lookup', False,",
            "                              group='designate')",
            "",
            "        with self._create_floatingip_with_dns(flip_dns_domain=self.DNS_DOMAIN,",
            "                flip_dns_name=self.DNS_NAME) as flip:",
            "            floatingip = flip",
            "",
            "        self.mock_client.recordsets.create.assert_called_with(self.DNS_DOMAIN,",
            "                self.DNS_NAME, 'A', [floatingip['floating_ip_address']])",
            "        self.mock_admin_client.recordsets.create.assert_not_called()",
            "        self.assertEqual(self.DNS_DOMAIN, floatingip['dns_domain'])",
            "        self.assertEqual(self.DNS_NAME, floatingip['dns_name'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.extensions.test_l3.L3NatTestCaseBase.self"
        ]
    }
}