{
    "nova/tests/virt/vmwareapi/test_driver_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1441,
                "afterPatchRowNumber": 1441,
                "PatchRowcode": "                               None, self.destroy_disks)"
            },
            "1": {
                "beforePatchRowNumber": 1442,
                "afterPatchRowNumber": 1442,
                "PatchRowcode": "             self.assertFalse(mock_destroy.called)"
            },
            "2": {
                "beforePatchRowNumber": 1443,
                "afterPatchRowNumber": 1443,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1444,
                "PatchRowcode": "+    def _destroy_instance_without_vm_ref(self, resize_exists=False,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1445,
                "PatchRowcode": "+                                         task_state=None):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1446,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1447,
                "PatchRowcode": "+        def fake_vm_ref_from_name(session, vm_name):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1448,
                "PatchRowcode": "+            if resize_exists:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1449,
                "PatchRowcode": "+                return 'fake-ref'"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1450,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1451,
                "PatchRowcode": "+        self._create_instance()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1452,
                "PatchRowcode": "+        with contextlib.nested("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1453,
                "PatchRowcode": "+             mock.patch.object(vm_util, 'get_vm_ref_from_name',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1454,
                "PatchRowcode": "+                               fake_vm_ref_from_name),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1455,
                "PatchRowcode": "+             mock.patch.object(self.conn._session,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1456,
                "PatchRowcode": "+                               '_call_method'),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1457,
                "PatchRowcode": "+             mock.patch.object(self.conn._vmops,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1458,
                "PatchRowcode": "+                               '_destroy_instance')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1459,
                "PatchRowcode": "+        ) as (mock_get, mock_call, mock_destroy):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1460,
                "PatchRowcode": "+            self.instance.task_state = task_state"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1461,
                "PatchRowcode": "+            self.conn.destroy(self.context, self.instance,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1462,
                "PatchRowcode": "+                              self.network_info,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1463,
                "PatchRowcode": "+                              None, True)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1464,
                "PatchRowcode": "+            if resize_exists:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1465,
                "PatchRowcode": "+                if task_state == task_states.RESIZE_REVERTING:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1466,
                "PatchRowcode": "+                    expected = 1"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1467,
                "PatchRowcode": "+                else:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1468,
                "PatchRowcode": "+                    expected = 2"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1469,
                "PatchRowcode": "+            else:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1470,
                "PatchRowcode": "+                expected = 1"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1471,
                "PatchRowcode": "+            self.assertEqual(expected, mock_destroy.call_count)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1472,
                "PatchRowcode": "+            self.assertFalse(mock_call.called)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1473,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1474,
                "PatchRowcode": "+    def test_destroy_instance_without_vm_ref(self):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1475,
                "PatchRowcode": "+        self._destroy_instance_without_vm_ref()"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1476,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1477,
                "PatchRowcode": "+    def test_destroy_instance_without_vm_ref_with_resize(self):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1478,
                "PatchRowcode": "+        self._destroy_instance_without_vm_ref(resize_exists=True)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1479,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1480,
                "PatchRowcode": "+    def test_destroy_instance_without_vm_ref_with_resize_revert(self):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1481,
                "PatchRowcode": "+        self._destroy_instance_without_vm_ref(resize_exists=True,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1482,
                "PatchRowcode": "+            task_state=task_states.RESIZE_REVERTING)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1483,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 1444,
                "afterPatchRowNumber": 1484,
                "PatchRowcode": "     def _rescue(self, config_drive=False):"
            },
            "44": {
                "beforePatchRowNumber": 1445,
                "afterPatchRowNumber": 1485,
                "PatchRowcode": "         def fake_attach_disk_to_vm(vm_ref, instance,"
            },
            "45": {
                "beforePatchRowNumber": 1446,
                "afterPatchRowNumber": 1486,
                "PatchRowcode": "                                    adapter_type, disk_type, vmdk_path=None,"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Test suite for VMwareAPI.",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import copy",
            "import datetime",
            "import time",
            "",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "import suds",
            "",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import exception",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import test",
            "from nova.tests import fake_instance",
            "import nova.tests.image.fake",
            "from nova.tests import matchers",
            "from nova.tests import test_flavors",
            "from nova.tests import utils",
            "from nova.tests.virt.vmwareapi import stubs",
            "from nova import utils as nova_utils",
            "from nova.virt import driver as v_driver",
            "from nova.virt import fake",
            "from nova.virt.vmwareapi import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import fake as vmwareapi_fake",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vim",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmops",
            "from nova.virt.vmwareapi import vmware_images",
            "from nova.virt.vmwareapi import volume_util",
            "from nova.virt.vmwareapi import volumeops",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('remove_unused_original_minimum_age_seconds',",
            "                'nova.virt.imagecache')",
            "",
            "",
            "class fake_vm_ref(object):",
            "    def __init__(self):",
            "        self.value = 4",
            "        self._type = 'VirtualMachine'",
            "",
            "",
            "class fake_service_content(object):",
            "    def __init__(self):",
            "        self.ServiceContent = vmwareapi_fake.DataObject()",
            "        self.ServiceContent.fake = 'fake'",
            "",
            "",
            "class VMwareSudsTest(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareSudsTest, self).setUp()",
            "",
            "        def new_client_init(self, url, **kwargs):",
            "            return",
            "",
            "        mock.patch.object(suds.client.Client,",
            "                          '__init__', new=new_client_init).start()",
            "        self.vim = self._vim_create()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def _vim_create(self):",
            "",
            "        def fake_retrieve_service_content(fake):",
            "            return fake_service_content()",
            "",
            "        self.stubs.Set(vim.Vim, 'retrieve_service_content',",
            "                fake_retrieve_service_content)",
            "        return vim.Vim()",
            "",
            "    def test_exception_with_deepcopy(self):",
            "        self.assertIsNotNone(self.vim)",
            "        self.assertRaises(error_util.VimException,",
            "                          copy.deepcopy, self.vim)",
            "",
            "",
            "class VMwareSessionTestCase(test.NoDBTestCase):",
            "",
            "    def _fake_is_vim_object(self, module):",
            "        return True",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_call_method_vim_fault(self, mock_sleep):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        def _fake_session_is_active(self):",
            "            return False",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "            mock.patch.object(driver.VMwareAPISession, '_session_is_active',",
            "                              _fake_session_is_active)",
            "        ) as (_fake_vim, _fake_create, _fake_is_active):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.VimFaultException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_temp_method_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_vim_empty(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        def _fake_session_is_active(self):",
            "            return True",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "            mock.patch.object(driver.VMwareAPISession, '_session_is_active',",
            "                              _fake_session_is_active)",
            "        ) as (_fake_vim, _fake_create, _fake_is_active):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            res = api_session._call_method(stubs, 'fake_temp_method_exception',",
            "                                           *args, **kwargs)",
            "            self.assertEqual([], res)",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_call_method_session_exception(self, mock_sleep):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.SessionConnectionException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_temp_session_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_session_file_exists_exception(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.FileAlreadyExistsException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_session_file_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_session_no_permission_exception(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            e = self.assertRaises(error_util.NoPermissionException,",
            "                                  api_session._call_method,",
            "                                  stubs, 'fake_session_permission_exception',",
            "                                  *args, **kwargs)",
            "            fault_string = 'Permission to perform this operation was denied.'",
            "            details = {'privilegeId': 'Resource.AssignVMToPool',",
            "                       'object': 'domain-c7'}",
            "            exception_string = '%s %s' % (fault_string, details)",
            "            self.assertEqual(exception_string, str(e))",
            "",
            "",
            "class VMwareAPIConfTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for VMWare API configurations.\"\"\"",
            "    def setUp(self):",
            "        super(VMwareAPIConfTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIConfTestCase, self).tearDown()",
            "",
            "    def test_configure_without_wsdl_loc_override(self):",
            "        # Test the default configuration behavior. By default,",
            "        # use the WSDL sitting on the host we are talking to in",
            "        # order to bind the SOAP client.",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNone(wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"www.example.com\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"www.example.com\")",
            "        self.assertEqual(\"https://www.example.com/sdk/vimService.wsdl\",",
            "                         wsdl_url)",
            "        self.assertEqual(\"https://www.example.com/sdk\", url)",
            "",
            "    def test_configure_without_wsdl_loc_override_using_ipv6(self):",
            "        # Same as above but with ipv6 based host ip",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNone(wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"::1\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"::1\")",
            "        self.assertEqual(\"https://[::1]/sdk/vimService.wsdl\",",
            "                         wsdl_url)",
            "        self.assertEqual(\"https://[::1]/sdk\", url)",
            "",
            "    def test_configure_with_wsdl_loc_override(self):",
            "        # Use the setting vmwareapi_wsdl_loc to override the",
            "        # default path to the WSDL.",
            "        #",
            "        # This is useful as a work-around for XML parsing issues",
            "        # found when using some WSDL in combination with some XML",
            "        # parsers.",
            "        #",
            "        # The wsdl_url should point to a different host than the one we",
            "        # are actually going to send commands to.",
            "        fake_wsdl = \"https://www.test.com/sdk/foo.wsdl\"",
            "        self.flags(wsdl_location=fake_wsdl, group='vmware')",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNotNone(wsdl_loc)",
            "        self.assertEqual(fake_wsdl, wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"www.example.com\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"www.example.com\")",
            "        self.assertEqual(fake_wsdl, wsdl_url)",
            "        self.assertEqual(\"https://www.example.com/sdk\", url)",
            "",
            "",
            "class VMwareAPIVMTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API connection calls.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIVMTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "        self.context = context.RequestContext('fake', 'fake', is_admin=False)",
            "        self.flags(host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass',",
            "                   datastore_regex='.*',",
            "                   api_retry_count=1,",
            "                   use_linked_clone=False, group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base',",
            "                   my_ip='')",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.node_name = 'test_url'",
            "        self.ds = 'ds1'",
            "        self.context = context.RequestContext(self.user_id, self.project_id)",
            "        stubs.set_stubs(self.stubs)",
            "        vmwareapi_fake.reset()",
            "        self.conn = driver.VMwareESXDriver(fake.FakeVirtAPI)",
            "        # NOTE(vish): none of the network plugging code is actually",
            "        #             being tested",
            "        self.network_info = utils.get_test_network_info()",
            "",
            "        self.image = {",
            "            'id': 'c1c8ce3d-c2e0-4247-890c-ccf5cc1c004c',",
            "            'disk_format': 'vmdk',",
            "            'size': 512,",
            "        }",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        self.vnc_host = 'test_url'",
            "        self._set_exception_vars()",
            "        self.instance_without_compute = {'node': None,",
            "                                         'vm_state': 'building',",
            "                                         'project_id': 'fake',",
            "                                         'user_id': 'fake',",
            "                                         'name': '1',",
            "                                         'display_description': '1',",
            "                                         'kernel_id': '1',",
            "                                         'ramdisk_id': '1',",
            "                                         'mac_addresses': [",
            "                                            {'address': 'de:ad:be:ef:be:ef'}",
            "                                         ],",
            "                                         'memory_mb': 8192,",
            "                                         'instance_type': 'm1.large',",
            "                                         'vcpus': 4,",
            "                                         'root_gb': 80,",
            "                                         'image_ref': '1',",
            "                                         'host': 'fake_host',",
            "                                         'task_state':",
            "                                         'scheduling',",
            "                                         'reservation_id': 'r-3t8muvr0',",
            "                                         'id': 1,",
            "                                         'uuid': 'fake-uuid',",
            "                                         'metadata': []}",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVMTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "        nova.tests.image.fake.FakeImageService_reset()",
            "",
            "    def _set_exception_vars(self):",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        self.exception = False",
            "",
            "    def test_driver_capabilities(self):",
            "        self.assertTrue(self.conn.capabilities['has_imagecache'])",
            "        self.assertFalse(self.conn.capabilities['supports_recreate'])",
            "",
            "    def test_login_retries(self):",
            "        self.attempts = 0",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "",
            "        def _fake_login(_self):",
            "            self.attempts += 1",
            "            if self.attempts == 1:",
            "                raise exception.NovaException('Here is my fake exception')",
            "            return self.login_session",
            "",
            "        def _fake_check_session(_self):",
            "            return True",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "        self.stubs.Set(time, 'sleep', lambda x: None)",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_check_session',",
            "                       _fake_check_session)",
            "        self.conn = driver.VMwareAPISession()",
            "        self.assertEqual(self.attempts, 2)",
            "",
            "    def test_wait_for_task_exception(self):",
            "        self.flags(task_poll_interval=1, group='vmware')",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "        self.stop_called = 0",
            "",
            "        def _fake_login(_self):",
            "            return self.login_session",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "",
            "        def fake_poll_task(task_ref, done):",
            "            done.send_exception(exception.NovaException('fake exception'))",
            "",
            "        def fake_stop_loop(loop):",
            "            self.stop_called += 1",
            "            return loop.stop()",
            "",
            "        self.conn = driver.VMwareAPISession()",
            "        self.stubs.Set(self.conn, \"_poll_task\",",
            "                       fake_poll_task)",
            "        self.stubs.Set(self.conn, \"_stop_loop\",",
            "                       fake_stop_loop)",
            "        self.assertRaises(exception.NovaException,",
            "                          self.conn._wait_for_task, 'fake-ref')",
            "        self.assertEqual(self.stop_called, 1)",
            "",
            "    def _get_instance_type_by_name(self, type):",
            "        for instance_type in test_flavors.DEFAULT_FLAVORS:",
            "            if instance_type['name'] == type:",
            "                return instance_type",
            "        if type == 'm1.micro':",
            "            return {'memory_mb': 128, 'root_gb': 0, 'deleted_at': None,",
            "                    'name': 'm1.micro', 'deleted': 0, 'created_at': None,",
            "                    'ephemeral_gb': 0, 'updated_at': None,",
            "                    'disabled': False, 'vcpus': 1, 'extra_specs': {},",
            "                    'swap': 0, 'rxtx_factor': 1.0, 'is_public': True,",
            "                    'flavorid': '1', 'vcpu_weight': None, 'id': 2}",
            "",
            "    def _create_instance(self, node=None, set_image_ref=True,",
            "                         uuid=None, instance_type='m1.large'):",
            "        if not node:",
            "            node = self.node_name",
            "        if not uuid:",
            "            uuid = uuidutils.generate_uuid()",
            "        self.type_data = self._get_instance_type_by_name(instance_type)",
            "        values = {'name': 'fake_name',",
            "                  'id': 1,",
            "                  'uuid': uuid,",
            "                  'project_id': self.project_id,",
            "                  'user_id': self.user_id,",
            "                  'kernel_id': \"fake_kernel_uuid\",",
            "                  'ramdisk_id': \"fake_ramdisk_uuid\",",
            "                  'mac_address': \"de:ad:be:ef:be:ef\",",
            "                  'flavor': instance_type,",
            "                  'node': node,",
            "                  'memory_mb': self.type_data['memory_mb'],",
            "                  'root_gb': self.type_data['root_gb'],",
            "                  'ephemeral_gb': self.type_data['ephemeral_gb'],",
            "                  'vcpus': self.type_data['vcpus'],",
            "                  'swap': self.type_data['swap'],",
            "        }",
            "        if set_image_ref:",
            "            values['image_ref'] = \"fake_image_uuid\"",
            "        self.instance_node = node",
            "        self.uuid = uuid",
            "        self.instance = fake_instance.fake_instance_obj(",
            "                self.context, **values)",
            "",
            "    def _create_vm(self, node=None, num_instances=1, uuid=None,",
            "                   instance_type='m1.large'):",
            "        \"\"\"Create and spawn the VM.\"\"\"",
            "        if not node:",
            "            node = self.node_name",
            "        self._create_instance(node=node, uuid=uuid,",
            "                              instance_type=instance_type)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=None)",
            "        self._check_vm_record(num_instances=num_instances)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def _check_vm_record(self, num_instances=1):",
            "        \"\"\"Check if the spawned VM's properties correspond to the instance in",
            "        the db.",
            "        \"\"\"",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), num_instances)",
            "",
            "        # Get Nova record for VM",
            "        vm_info = self.conn.get_info({'uuid': self.uuid,",
            "                                      'name': 1,",
            "                                      'node': self.instance_node})",
            "",
            "        # Get record for VM",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        for vm in vms.objects:",
            "            if vm.get('name') == self.uuid:",
            "                break",
            "",
            "        # Check that m1.large above turned into the right thing.",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        vcpus = self.type_data['vcpus']",
            "        self.assertEqual(vm_info['max_mem'], mem_kib)",
            "        self.assertEqual(vm_info['mem'], mem_kib)",
            "        self.assertEqual(vm.get(\"summary.config.instanceUuid\"), self.uuid)",
            "        self.assertEqual(vm.get(\"summary.config.numCpu\"), vcpus)",
            "        self.assertEqual(vm.get(\"summary.config.memorySizeMB\"),",
            "                         self.type_data['memory_mb'])",
            "",
            "        self.assertEqual(",
            "            vm.get(\"config.hardware.device\")[2].device.obj_name,",
            "            \"ns0:VirtualE1000\")",
            "        # Check that the VM is running according to Nova",
            "        self.assertEqual(vm_info['state'], power_state.RUNNING)",
            "",
            "        # Check that the VM is running according to vSphere API.",
            "        self.assertEqual(vm.get(\"runtime.powerState\"), 'poweredOn')",
            "",
            "        found_vm_uuid = False",
            "        found_iface_id = False",
            "        for c in vm.get(\"config.extraConfig\").OptionValue:",
            "            if (c.key == \"nvp.vm-uuid\" and c.value == self.instance['uuid']):",
            "                found_vm_uuid = True",
            "            if (c.key == \"nvp.iface-id.0\" and c.value == \"vif-xxx-yyy-zzz\"):",
            "                found_iface_id = True",
            "",
            "        self.assertTrue(found_vm_uuid)",
            "        self.assertTrue(found_iface_id)",
            "",
            "    def _check_vm_info(self, info, pwr_state=power_state.RUNNING):",
            "        \"\"\"Check if the get_info returned values correspond to the instance",
            "        object in the db.",
            "        \"\"\"",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        self.assertEqual(info[\"state\"], pwr_state)",
            "        self.assertEqual(info[\"max_mem\"], mem_kib)",
            "        self.assertEqual(info[\"mem\"], mem_kib)",
            "        self.assertEqual(info[\"num_cpu\"], self.type_data['vcpus'])",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_list_instances_1(self):",
            "        self._create_vm()",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "",
            "    def test_list_instance_uuids(self):",
            "        self._create_vm()",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 1)",
            "",
            "    def test_list_instance_uuids_invalid_uuid(self):",
            "        self._create_vm(uuid='fake_id')",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 0)",
            "",
            "    def _cached_files_exist(self, exists=True):",
            "        cache = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                 self.ds)",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(cache))",
            "",
            "    def test_instance_dir_disk_created(self):",
            "        \"\"\"Test image file is cached when even when use_linked_clone",
            "            is False",
            "        \"\"\"",
            "",
            "        self._create_vm()",
            "        inst_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        cache = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                 self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(inst_file_path))",
            "        self._cached_files_exist()",
            "",
            "    def test_cache_dir_disk_created(self):",
            "        \"\"\"Test image disk is cached when use_linked_clone is True.\"\"\"",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self._create_vm()",
            "        file = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                self.ds)",
            "        root = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.80.vmdk' %",
            "                self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(file))",
            "        self.assertTrue(vmwareapi_fake.get_file(root))",
            "",
            "    def _iso_disk_type_created(self, instance_type='m1.large'):",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm(instance_type=instance_type)",
            "        file = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' %",
            "                self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(file))",
            "",
            "    def test_iso_disk_type_created(self):",
            "        self._iso_disk_type_created()",
            "        vmdk_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(vmdk_file_path))",
            "",
            "    def test_iso_disk_type_created_with_root_gb_0(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        vmdk_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertFalse(vmwareapi_fake.get_file(vmdk_file_path))",
            "",
            "    def test_iso_disk_cdrom_attach(self):",
            "        self.iso_path = (",
            "            '[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' % self.ds)",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path)",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "",
            "    def test_iso_disk_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self.iso_path = [",
            "            ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' %",
            "             self.ds),",
            "            '[%s] fake-config-drive' % self.ds]",
            "        self.iso_unit_nos = [0, 1]",
            "        self.iso_index = 0",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path[self.iso_index])",
            "            self.iso_index += 1",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "        self.assertEqual(self.iso_index, 2)",
            "",
            "    def test_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self.iso_path = '[%s] fake-config-drive' % self.ds",
            "        self.cd_attach_called = False",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path)",
            "            self.cd_attach_called = True",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        self.assertTrue(self.cd_attach_called)",
            "",
            "    def test_spawn(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_root_size_0(self):",
            "        self._create_vm(instance_type='m1.micro')",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        cache = ('[%s] vmware_base/%s/%s.vmdk' %",
            "                 (self.ds, 'fake_image_uuid', 'fake_image_uuid'))",
            "        gb_cache = ('[%s] vmware_base/%s/%s.0.vmdk' %",
            "                    (self.ds, 'fake_image_uuid', 'fake_image_uuid'))",
            "        self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        self.assertFalse(vmwareapi_fake.get_file(gb_cache))",
            "",
            "    def _spawn_with_delete_exception(self, fault=None):",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=fault)",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            if fault:",
            "                self._create_vm()",
            "                info = self.conn.get_info({'uuid': self.uuid,",
            "                                           'node': self.instance_node})",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self.assertRaises(error_util.VMwareDriverException,",
            "                                  self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_delete_exception_not_found(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileNotFound())",
            "",
            "    def test_spawn_with_delete_exception_file_fault(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileFault())",
            "",
            "    def test_spawn_with_delete_exception_cannot_delete_file(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.CannotDeleteFile())",
            "",
            "    def test_spawn_with_delete_exception_file_locked(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileLocked())",
            "",
            "    def test_spawn_with_delete_exception_general(self):",
            "        self._spawn_with_delete_exception()",
            "",
            "    def test_spawn_disk_extend(self):",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_exists(self):",
            "        root = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.80.vmdk' %",
            "                self.ds)",
            "        self.root = root",
            "",
            "        def _fake_extend(instance, requested_size, name, dc_ref):",
            "            vmwareapi_fake._add_file(self.root)",
            "",
            "        self.stubs.Set(self.conn._vmops, '_extend_virtual_disk',",
            "                       _fake_extend)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertTrue(vmwareapi_fake.get_file(root))",
            "",
            "    def test_spawn_disk_extend_sparse(self):",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [1024, {\"vmware_ostype\": \"otherGuest\",",
            "                         \"vmware_adaptertype\": \"lsiLogic\",",
            "                         \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_insufficient_disk_space(self):",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        id = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           id, id)",
            "        tmp_file = '[%s] vmware_base/%s/%s.80-flat.vmdk' % (self.ds,",
            "                                                            id, id)",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                self.assertTrue(vmwareapi_fake.get_file(tmp_file))",
            "                raise exception.NovaException('No space!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"ExtendVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        self.stubs.Set(self.conn._session, \"_call_method\", fake_call_method)",
            "        self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                       fake_wait_for_task)",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "        self.assertFalse(vmwareapi_fake.get_file(tmp_file))",
            "",
            "    def test_spawn_disk_extend_failed_copy(self):",
            "        # Spawn instance",
            "        # copy for extend fails without creating a file",
            "        #",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        CopyError = error_util.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == 'fake-copy-task':",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                return 'fake-copy-task'",
            "",
            "            return self.call_method(module, method, *args, **kwargs)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaving a file behind",
            "        #",
            "        # Expect the file to be cleaned up",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        uuid = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = error_util.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy_failed_cleanup(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaves file behind",
            "        # File cleanup fails",
            "        #",
            "        # Expect file to be left behind",
            "        # Expect file cleanup error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        uuid = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = error_util.FileFaultException",
            "        DeleteError = error_util.CannotDeleteFileException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            elif task_ref == 'fake-delete-task':",
            "                raise DeleteError('Delete failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                return 'fake-delete-task'",
            "",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method)):",
            "            self.assertRaises(DeleteError, self._create_vm)",
            "        self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_invalid_disk_size(self):",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [82 * units.Gi,",
            "                  {\"vmware_ostype\": \"otherGuest\",",
            "                   \"vmware_adaptertype\": \"lsiLogic\",",
            "                   \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InstanceUnacceptable,",
            "                          self._create_vm)",
            "",
            "    def test_spawn_invalid_disk_format(self):",
            "        self._create_instance()",
            "        self.image['disk_format'] = 'invalid'",
            "        self.assertRaises(exception.InvalidDiskFormat,",
            "                          self.conn.spawn, self.context,",
            "                          self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    def test_spawn_with_move_file_exists_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise an file exists exception. The flag",
            "        # self.exception will be checked to see that",
            "        # the exception has indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise error_util.FileAlreadyExistsException()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_general_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a general exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise error_util.VMwareDriverException('Exception!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self.assertRaises(error_util.VMwareDriverException,",
            "                              self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_poll_exception(self):",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\")",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self.assertRaises(error_util.VMwareDriverException,",
            "                              self._create_vm)",
            "",
            "    def test_spawn_with_move_file_exists_poll_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a file exists exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=vmwareapi_fake.FileAlreadyExists())",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def _spawn_attach_volume_vmdk(self, set_image_ref=True, vc_support=False):",
            "        self._create_instance(set_image_ref=set_image_ref)",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        if vc_support:",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_get_res_pool_of_vm')",
            "            volumeops.VMwareVolumeOps._get_res_pool_of_vm(",
            "                     mox.IgnoreArg()).AndReturn('fake_res_pool')",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_relocate_vmdk_volume')",
            "            volumeops.VMwareVolumeOps._relocate_vmdk_volume(mox.IgnoreArg(),",
            "                     'fake_res_pool', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk()",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False)",
            "",
            "    def test_spawn_attach_volume_iscsi(self):",
            "        self._create_instance()",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def mock_upload_image(self, context, image, instance, **kwargs):",
            "        self.assertEqual(image, 'Test-Snapshot')",
            "        self.assertEqual(instance, self.instance)",
            "        self.assertEqual(kwargs['disk_type'], 'preallocated')",
            "",
            "    def test_get_vm_ref_using_extra_config(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        # Disrupt the fake Virtual Machine object so that extraConfig",
            "        # cannot be matched.",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"\"",
            "        # We should not get a Virtual Machine through extraConfig.",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNone(vm_ref, 'VM Reference should be none')",
            "        # Check if we can find the Virtual Machine using the name.",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def test_search_vm_ref_by_identifier(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self.conn._session,",
            "                                            self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm.set(\"summary.config.instanceUuid\", \"foo\")",
            "        fake_vm.set(\"name\", \"foo\")",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"foo\"",
            "        self.assertIsNone(vm_util.search_vm_ref_by_identifier(",
            "                                    self.conn._session, self.instance['uuid']),",
            "                          \"VM Reference should be none\")",
            "        self.assertIsNotNone(",
            "                vm_util.search_vm_ref_by_identifier(self.conn._session, \"foo\"),",
            "                \"VM Reference should not be none\")",
            "",
            "    def test_get_object_for_optionvalue(self):",
            "        self._create_vm()",
            "        vms = self.conn._session._call_method(vim_util, \"get_objects\",",
            "                \"VirtualMachine\", ['config.extraConfig[\"nvp.vm-uuid\"]'])",
            "        vm_ref = vm_util._get_object_for_optionvalue(vms,",
            "                                                     self.instance[\"uuid\"])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def _test_snapshot(self):",
            "        expected_calls = [",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_PENDING_UPLOAD}},",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_UPLOADING,",
            "                  'expected_state': task_states.IMAGE_PENDING_UPLOAD}}]",
            "        func_call_matcher = matchers.FunctionCallMatcher(expected_calls)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        with mock.patch.object(vmware_images, 'upload_image',",
            "                               self.mock_upload_image):",
            "            self.conn.snapshot(self.context, self.instance, \"Test-Snapshot\",",
            "                               func_call_matcher.call)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertIsNone(func_call_matcher.match())",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_no_root_disk(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        self.assertRaises(error_util.NoRootDiskDefined, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_delete_vm_snapshot(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0].obj",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_create_vm_snapshot')",
            "        self.conn._vmops._create_vm_snapshot(",
            "                self.instance, fake_vm).AndReturn(snapshot_ref)",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_delete_vm_snapshot')",
            "        self.conn._vmops._delete_vm_snapshot(",
            "                self.instance, fake_vm, snapshot_ref).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        self._test_snapshot()",
            "",
            "    def test_reboot(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_with_uuid(self):",
            "        \"\"\"Test fall back to use name when can't find by uuid.\"\"\"",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_poll_rebooting_instances(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'reboot')",
            "        compute_api.API.reboot(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        instances = [self.instance]",
            "        self.conn.poll_rebooting_instances(60, instances)",
            "",
            "    def test_reboot_not_poweredon(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstanceRebootFailure, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_suspend(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "",
            "    def test_suspend_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.suspend,",
            "                          self.instance)",
            "",
            "    def test_resume(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.conn.resume(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_resume_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_resume_not_suspended(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertRaises(exception.InstanceResumeFailure, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_on(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.conn.power_on(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_power_on_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_on,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_off(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_power_off_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_off,",
            "                          self.instance)",
            "",
            "    def test_power_off_suspended(self):",
            "        self._create_vm()",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstancePowerOffFailure,",
            "                          self.conn.power_off, self.instance)",
            "",
            "    def test_resume_state_on_host_boot(self):",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, \"reboot\")",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOff\")",
            "        self.conn.reboot(self.context, self.instance, 'network_info',",
            "            'hard', None)",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_1(self):",
            "        \"\"\"Don't call reboot on instance which is poweredon.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOn\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_2(self):",
            "        \"\"\"Don't call reboot on instance which is suspended.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"suspended\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def destroy_rescued(self, fake_method):",
            "        self._rescue()",
            "        with (",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              fake_method)",
            "        ):",
            "            self.instance['vm_state'] = vm_states.RESCUED",
            "            self.conn.destroy(self.context, self.instance, self.network_info)",
            "            inst_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(inst_path))",
            "            rescue_file_path = '[%s] %s-rescue/%s-rescue.vmdk' % (self.ds,",
            "                                                                  self.uuid,",
            "                                                                  self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(rescue_file_path))",
            "",
            "    def test_destroy_rescued(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            pass",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy_rescued_with_exception(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            raise exception.NovaException('Here is my fake exception')",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        # Overwrite the vmPathName",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        vm = vms.objects[0]",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.network_info,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def _rescue(self, config_drive=False):",
            "        def fake_attach_disk_to_vm(vm_ref, instance,",
            "                                   adapter_type, disk_type, vmdk_path=None,",
            "                                   disk_size=None, linked_clone=False,",
            "                                   controller_key=None, unit_number=None,",
            "                                   device_name=None):",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        if config_drive:",
            "            def fake_create_config_drive(instance, injected_files, password,",
            "                                         data_store_name, folder,",
            "                                         instance_uuid, cookies):",
            "                self.assertTrue(uuidutils.is_uuid_like(instance['uuid']))",
            "",
            "            self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                           fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.stubs.Set(self.conn._volumeops, \"attach_disk_to_vm\",",
            "                       fake_attach_disk_to_vm)",
            "        self.conn.rescue(self.context, self.instance, self.network_info,",
            "                         self.image, 'fake-password')",
            "        info = self.conn.get_info({'name': '1-rescue',",
            "                                   'uuid': '%s-rescue' % self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get('%s-rescue' % self.uuid))",
            "",
            "    def test_rescue(self):",
            "        self._rescue()",
            "        inst_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(inst_file_path))",
            "        rescue_file_path = '[%s] %s-rescue/%s-rescue.vmdk' % (self.ds,",
            "                                                              self.uuid,",
            "                                                              self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(rescue_file_path))",
            "",
            "    def test_rescue_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self._rescue(config_drive=True)",
            "",
            "    def test_unrescue(self):",
            "        self._rescue()",
            "        self.test_vm_ref = None",
            "        self.test_device_name = None",
            "",
            "        def fake_power_off_vm_ref(vm_ref):",
            "            self.test_vm_ref = vm_ref",
            "            self.assertIsNotNone(vm_ref)",
            "",
            "        def fake_detach_disk_from_vm(vm_ref, instance,",
            "                                     device_name, destroy_disk=False):",
            "            self.test_device_name = device_name",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._vmops, \"_power_off_vm_ref\",",
            "                              side_effect=fake_power_off_vm_ref),",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              side_effect=fake_detach_disk_from_vm),",
            "        ) as (poweroff, detach):",
            "            self.conn.unrescue(self.instance, None)",
            "            poweroff.assert_called_once_with(self.test_vm_ref)",
            "            detach.assert_called_once_with(self.test_vm_ref, mock.ANY,",
            "                                           self.test_device_name)",
            "            self.test_vm_ref = None",
            "            self.test_device_name = None",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareESXDriver does not implement the pause method.",
            "        self.assertRaises(NotImplementedError, self.conn.pause, instance=None)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareESXDriver does not implement the unpause method.",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          instance=None)",
            "",
            "    def test_get_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'memoryReservation': 0, 'suspendInterval': 0,",
            "                    'maxCpuUsage': 2000, 'toolsInstallerMounted': False,",
            "                    'consumedOverheadMemory': 20, 'numEthernetCards': 1,",
            "                    'numCpu': 1, 'featureRequirement': [{'key': 'cpuid.AES'}],",
            "                    'memoryOverhead': 21417984,",
            "                    'guestMemoryUsage': 0, 'connectionState': 'connected',",
            "                    'memorySizeMB': 512, 'balloonedMemory': 0,",
            "                    'vmPathName': 'fake_path', 'template': False,",
            "                    'overallCpuUsage': 0, 'powerState': 'poweredOn',",
            "                    'cpuReservation': 0, 'overallCpuDemand': 0,",
            "                    'numVirtualDisks': 1, 'hostMemoryUsage': 141}",
            "        expected = dict([('vmware:' + k, v) for k, v in expected.items()])",
            "        self.assertThat(",
            "                self.conn.get_diagnostics({'name': 1, 'uuid': self.uuid,",
            "                                           'node': self.instance_node}),",
            "                matchers.DictMatches(expected))",
            "",
            "    def test_get_console_output(self):",
            "        self.assertRaises(NotImplementedError, self.conn.get_console_output,",
            "            None, None)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Tests the finish_migration method on vmops.\"\"\"",
            "",
            "        self.power_on_called = False",
            "        self.wait_for_task = False",
            "        self.wait_task = self.conn._session._wait_for_task",
            "",
            "        def fake_power_on(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            self.power_on_called = True",
            "",
            "        def fake_vmops_update_instance_progress(context, instance, step,",
            "                                                total_steps):",
            "            self.assertEqual(self.context, context)",
            "            self.assertEqual(self.instance, instance)",
            "            self.assertEqual(4, step)",
            "            self.assertEqual(vmops.RESIZE_TOTAL_STEPS, total_steps)",
            "",
            "        if resize_instance:",
            "            def fake_wait_for_task(task_ref):",
            "                self.wait_for_task = True",
            "                return self.wait_task(task_ref)",
            "",
            "            self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                           fake_wait_for_task)",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_power_on\", fake_power_on)",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_vmops_update_instance_progress)",
            "",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "        # perform the migration on our stubbed methods",
            "        self.conn.finish_migration(context=self.context,",
            "                                   migration=None,",
            "                                   instance=self.instance,",
            "                                   disk_info=None,",
            "                                   network_info=None,",
            "                                   block_device_info=None,",
            "                                   resize_instance=resize_instance,",
            "                                   image_meta=None,",
            "                                   power_on=power_on)",
            "        if resize_instance:",
            "            self.assertTrue(self.wait_for_task)",
            "        else:",
            "            self.assertFalse(self.wait_for_task)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=False)",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.confirm_migration, self.context,",
            "                          self.instance, None)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        \"\"\"Tests the finish_revert_migration method on vmops.\"\"\"",
            "",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "",
            "        self.power_on_called = False",
            "        self.vm_name = str(self.instance['name']) + '-orig'",
            "",
            "        def fake_power_on(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            self.power_on_called = True",
            "",
            "        def fake_get_orig_vm_name_label(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            return self.vm_name",
            "",
            "        def fake_get_vm_ref_from_name(session, vm_name):",
            "            self.assertEqual(self.vm_name, vm_name)",
            "            return vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "",
            "        def fake_get_vm_ref_from_uuid(session, vm_uuid):",
            "            return vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "",
            "        def fake_call_method(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_wait_for_task(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_power_on\", fake_power_on)",
            "        self.stubs.Set(self.conn._vmops, \"_get_orig_vm_name_label\",",
            "                       fake_get_orig_vm_name_label)",
            "        self.stubs.Set(vm_util, \"_get_vm_ref_from_uuid\",",
            "                       fake_get_vm_ref_from_uuid)",
            "        self.stubs.Set(vm_util, \"get_vm_ref_from_name\",",
            "                       fake_get_vm_ref_from_name)",
            "        self.stubs.Set(self.conn._session, \"_call_method\", fake_call_method)",
            "        self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                       fake_wait_for_task)",
            "",
            "        # perform the revert on our stubbed methods",
            "        self.conn.finish_revert_migration(self.context,",
            "                                          instance=self.instance,",
            "                                          network_info=None,",
            "                                          power_on=power_on)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=False)",
            "",
            "    def test_get_console_pool_info(self):",
            "        info = self.conn.get_console_pool_info(\"console_type\")",
            "        self.assertEqual(info['address'], 'test_url')",
            "        self.assertEqual(info['username'], 'test_username')",
            "        self.assertEqual(info['password'], 'test_pass')",
            "",
            "    def test_get_vnc_console_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def _test_get_vnc_console(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        OptionValue = collections.namedtuple('OptionValue', ['key', 'value'])",
            "        opt_val = OptionValue(key='', value=5906)",
            "        fake_vm.set(vm_util.VNC_CONFIG_KEY, opt_val)",
            "        vnc_dict = self.conn.get_vnc_console(self.context, self.instance)",
            "        self.assertEqual(vnc_dict['host'], self.vnc_host)",
            "        self.assertEqual(vnc_dict['port'], 5906)",
            "",
            "    def test_get_vnc_console(self):",
            "        self._test_get_vnc_console()",
            "",
            "    def test_get_vnc_console_noport(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def test_host_ip_addr(self):",
            "        self.assertEqual(self.conn.get_host_ip_addr(), \"test_url\")",
            "",
            "    def test_get_volume_connector(self):",
            "        self._create_vm()",
            "        connector_dict = self.conn.get_volume_connector(self.instance)",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm_id = fake_vm.obj.value",
            "        self.assertEqual(connector_dict['ip'], 'test_url')",
            "        self.assertEqual(connector_dict['initiator'], 'iscsi-name')",
            "        self.assertEqual(connector_dict['host'], 'test_url')",
            "        self.assertEqual(connector_dict['instance'], fake_vm_id)",
            "",
            "    def _test_vmdk_connection_info(self, type):",
            "        return {'driver_volume_type': type,",
            "                'serial': 'volume-fake-id',",
            "                'data': {'volume': 'vm-10',",
            "                         'volume_id': 'volume-fake-id'}}",
            "",
            "    def test_volume_attach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._attach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._detach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_vmdk_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "",
            "        # create fake backing info",
            "        volume_device = vmwareapi_fake.DataObject()",
            "        volume_device.backing = vmwareapi_fake.DataObject()",
            "        volume_device.backing.fileName = 'fake_path'",
            "",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_vmdk_base_volume_device')",
            "        volumeops.VMwareVolumeOps._get_vmdk_base_volume_device(",
            "                mox.IgnoreArg()).AndReturn(volume_device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), mox.IgnoreArg(),",
            "                vmdk_path='fake_path')",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_detach_vmdk_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_volume_uuid')",
            "        volumeops.VMwareVolumeOps._get_volume_uuid(mox.IgnoreArg(),",
            "                'volume-fake-id').AndReturn('fake_disk_uuid')",
            "        self.mox.StubOutWithMock(vm_util, 'get_vmdk_backed_disk_device')",
            "        vm_util.get_vmdk_backed_disk_device(mox.IgnoreArg(),",
            "                'fake_disk_uuid').AndReturn('fake_device')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_consolidate_vmdk_volume')",
            "        volumeops.VMwareVolumeOps._consolidate_vmdk_volume(self.instance,",
            "                 mox.IgnoreArg(), 'fake_device', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_volume_attach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._attach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._detach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_iscsi_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_host:port'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        discover = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volume_util, 'find_st')",
            "        # simulate target not found",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                            mox.IgnoreArg()).AndReturn((None, None))",
            "        self.mox.StubOutWithMock(volume_util, '_add_iscsi_send_target_host')",
            "        # rescan gets called with target portal",
            "        volume_util.rescan_iscsi_hba(",
            "            self.conn._session,",
            "            target_portal=connection_info['data']['target_portal'])",
            "        # simulate target found",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                            mox.IgnoreArg()).AndReturn(discover)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), 'rdmp',",
            "                device_name=mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_rescan_iscsi_hba(self):",
            "        fake_target_portal = 'fake_target_host:port'",
            "        host_storage_sys = vmwareapi_fake._get_objects(",
            "            \"HostStorageSystem\").objects[0]",
            "        iscsi_hba_array = host_storage_sys.get('storageDeviceInfo'",
            "                                               '.hostBusAdapter')",
            "        iscsi_hba = iscsi_hba_array.HostHostBusAdapter[0]",
            "        # Check the host system does not have the send target",
            "        self.assertRaises(AttributeError, getattr, iscsi_hba,",
            "                          'configuredSendTarget')",
            "        # Rescan HBA with the target portal",
            "        volume_util.rescan_iscsi_hba(self.conn._session, None,",
            "                                     fake_target_portal)",
            "        # Check if HBA has the target portal configured",
            "        self.assertEqual('fake_target_host',",
            "                          iscsi_hba.configuredSendTarget[0].address)",
            "        # Rescan HBA with same portal",
            "        volume_util.rescan_iscsi_hba(self.conn._session, None,",
            "                                     fake_target_portal)",
            "        self.assertEqual(1, len(iscsi_hba.configuredSendTarget))",
            "",
            "    def test_find_st(self):",
            "        data = {'target_portal': 'fake_target_host:port',",
            "                'target_iqn': 'fake_target_iqn'}",
            "        host = vmwareapi_fake._get_objects('HostSystem').objects[0]",
            "        host._add_iscsi_target(data)",
            "        result = volume_util.find_st(self.conn._session, data)",
            "        self.assertEqual(('fake-device', 'fake-uuid'), result)",
            "",
            "    def test_detach_iscsi_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_portal'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        find = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volume_util, 'find_st')",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                mox.IgnoreArg()).AndReturn(find)",
            "        self.mox.StubOutWithMock(vm_util, 'get_rdm_disk')",
            "        device = 'fake_device'",
            "        vm_util.get_rdm_disk(mox.IgnoreArg(), 'fake_uuid').AndReturn(device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, device, destroy_disk=True)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_connection_info_get(self):",
            "        self._create_vm()",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertIn('instance', connector)",
            "",
            "    def test_connection_info_get_after_destroy(self):",
            "        self._create_vm()",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertNotIn('instance', connector)",
            "",
            "    def test_refresh_instance_security_rules(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.refresh_instance_security_rules,",
            "                          instance=None)",
            "",
            "    def test_image_aging_image_used(self):",
            "        self._create_vm()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "",
            "    def _get_timestamp_filename(self):",
            "        return '%s%s' % (imagecache.TIMESTAMP_PREFIX,",
            "                         timeutils.strtime(at=self.old_time,",
            "                                           fmt=imagecache.TIMESTAMP_FORMAT))",
            "",
            "    def _override_time(self):",
            "        self.old_time = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "",
            "        def _fake_get_timestamp_filename(fake):",
            "            return self._get_timestamp_filename()",
            "",
            "        self.stubs.Set(imagecache.ImageCacheManager, '_get_timestamp_filename',",
            "                       _fake_get_timestamp_filename)",
            "",
            "    def _timestamp_file_exists(self, exists=True):",
            "        timestamp = ('[%s] vmware_base/fake_image_uuid/%s/' %",
            "                 (self.ds, self._get_timestamp_filename()))",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(timestamp))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(timestamp))",
            "",
            "    def _image_aging_image_marked_for_deletion(self):",
            "        self._create_vm(uuid=uuidutils.generate_uuid())",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "        self._timestamp_file_exists()",
            "",
            "    def test_image_aging_image_marked_for_deletion(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "",
            "    def _timestamp_file_removed(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "        self._create_vm(num_instances=2,",
            "                        uuid=uuidutils.generate_uuid())",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_timestamp_file_removed_spawn(self):",
            "        self._timestamp_file_removed()",
            "",
            "    def test_timestamp_file_removed_aging(self):",
            "        self._timestamp_file_removed()",
            "        ts = self._get_timestamp_filename()",
            "        ts_path = ('[%s] vmware_base/fake_image_uuid/%s/' %",
            "                   (self.ds, ts))",
            "        vmwareapi_fake._add_file(ts_path)",
            "        self._timestamp_file_exists()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_image_aging_disabled(self):",
            "        self._override_time()",
            "        self.flags(remove_unused_base_images=False)",
            "        self._create_vm()",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist(exists=True)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def _image_aging_aged(self, aging_time=100):",
            "        self._override_time()",
            "        cur_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.flags(remove_unused_original_minimum_age_seconds=aging_time)",
            "        self._image_aging_image_marked_for_deletion()",
            "        all_instances = []",
            "        timeutils.set_time_override(cur_time)",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "",
            "    def test_image_aging_aged(self):",
            "        self._image_aging_aged(aging_time=8)",
            "        self._cached_files_exist(exists=False)",
            "",
            "    def test_image_aging_not_aged(self):",
            "        self._image_aging_aged()",
            "        self._cached_files_exist()",
            "",
            "",
            "class VMwareAPIHostTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API host calls.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIHostTestCase, self).setUp()",
            "        self.flags(image_cache_subdirectory_name='vmware_base')",
            "        vm_util.vm_refs_cache_reset()",
            "        self.flags(host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass', group='vmware')",
            "        vmwareapi_fake.reset()",
            "        stubs.set_stubs(self.stubs)",
            "        self.conn = driver.VMwareESXDriver(False)",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIHostTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_host_state(self):",
            "        stats = self.conn.get_host_stats()",
            "        self.assertEqual(stats['vcpus'], 16)",
            "        self.assertEqual(stats['disk_total'], 1024)",
            "        self.assertEqual(stats['disk_available'], 500)",
            "        self.assertEqual(stats['disk_used'], 1024 - 500)",
            "        self.assertEqual(stats['host_memory_total'], 1024)",
            "        self.assertEqual(stats['host_memory_free'], 1024 - 500)",
            "        self.assertEqual(stats['hypervisor_version'], 5000000)",
            "        supported_instances = [('i686', 'vmware', 'hvm'),",
            "                               ('x86_64', 'vmware', 'hvm')]",
            "        self.assertEqual(stats['supported_instances'], supported_instances)",
            "",
            "    def _test_host_action(self, method, action, expected=None):",
            "        result = method('host', action)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_host_reboot(self):",
            "        self._test_host_action(self.conn.host_power_action, 'reboot')",
            "",
            "    def test_host_shutdown(self):",
            "        self._test_host_action(self.conn.host_power_action, 'shutdown')",
            "",
            "    def test_host_startup(self):",
            "        self._test_host_action(self.conn.host_power_action, 'startup')",
            "",
            "    def test_host_maintenance_on(self):",
            "        self._test_host_action(self.conn.host_maintenance_mode, True)",
            "",
            "    def test_host_maintenance_off(self):",
            "        self._test_host_action(self.conn.host_maintenance_mode, False)",
            "",
            "    def test_get_host_uptime(self):",
            "        result = self.conn.get_host_uptime('host')",
            "        self.assertEqual('Please refer to test_url for the uptime', result)",
            "",
            "",
            "class VMwareAPIVCDriverTestCase(VMwareAPIVMTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIVCDriverTestCase, self).setUp()",
            "",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   api_retry_count=1,",
            "                   task_poll_interval=10, datastore_regex='.*', group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base')",
            "        vmwareapi_fake.reset(vc=True)",
            "        self.conn = driver.VMwareVCDriver(None, False)",
            "        self.node_name = self.conn._resources.keys()[0]",
            "        self.node_name2 = self.conn._resources.keys()[1]",
            "        if cluster_name2 in self.node_name2:",
            "            self.ds = 'ds1'",
            "        else:",
            "            self.ds = 'ds2'",
            "        self.vnc_host = 'ha-host'",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVCDriverTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_list_instances_from_nodes(self):",
            "        # Create instance on node1",
            "        self._create_vm(self.node_name)",
            "        # Create instances on the other node",
            "        self._create_vm(self.node_name2, num_instances=2)",
            "        self._create_vm(self.node_name2, num_instances=3)",
            "        node1_vmops = self.conn._get_vmops_for_compute_node(self.node_name)",
            "        node2_vmops = self.conn._get_vmops_for_compute_node(self.node_name2)",
            "        self.assertEqual(1, len(node1_vmops.list_instances()))",
            "        self.assertEqual(2, len(node2_vmops.list_instances()))",
            "        self.assertEqual(3, len(self.conn.list_instances()))",
            "",
            "    def _setup_mocks_for_session(self, mock_init):",
            "        mock_init.return_value = None",
            "",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        return vcdriver",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_init_host_and_cleanup_host(self, mock_init):",
            "        vcdriver = self._setup_mocks_for_session(mock_init)",
            "        vcdriver.init_host(\"foo\")",
            "        vcdriver._session._create_session.assert_called_once()",
            "",
            "        vcdriver.cleanup_host(\"foo\")",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once()",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.LOG')",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_with_no_login(self, mock_init, mock_logger):",
            "        vcdriver = self._setup_mocks_for_session(mock_init)",
            "        vcdriver.init_host(\"foo\")",
            "        vcdriver._session._create_session.assert_called_once()",
            "",
            "        # Not logged in...",
            "        # observe that no exceptions were thrown",
            "        mock_sc = mock.Mock()",
            "        vcdriver._session.vim.retrieve_service_content.return_value = mock_sc",
            "        web_fault = suds.WebFault(mock.Mock(), mock.Mock())",
            "        vcdriver._session.vim.client.service.Logout.side_effect = web_fault",
            "        vcdriver.cleanup_host(\"foo\")",
            "",
            "        # assert that the mock Logout method was never called",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once()",
            "        mock_logger.debug.assert_called_once()",
            "",
            "    def test_host_power_action(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_power_action, 'host', 'action')",
            "",
            "    def test_host_maintenance_mode(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_maintenance_mode, 'host', 'mode')",
            "",
            "    def test_set_host_enabled(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.set_host_enabled, 'host', 'state')",
            "",
            "    def test_datastore_regex_configured(self):",
            "        for node in self.conn._resources.keys():",
            "            self.assertEqual(self.conn._datastore_regex,",
            "                    self.conn._resources[node]['vmops']._datastore_regex)",
            "",
            "    def test_get_available_resource(self):",
            "        stats = self.conn.get_available_resource(self.node_name)",
            "        cpu_info = {\"model\": [\"Intel(R) Xeon(R)\", \"Intel(R) Xeon(R)\"],",
            "                    \"vendor\": [\"Intel\", \"Intel\"],",
            "                    \"topology\": {\"cores\": 16,",
            "                                 \"threads\": 32}}",
            "        self.assertEqual(stats['vcpus'], 32)",
            "        self.assertEqual(stats['local_gb'], 1024)",
            "        self.assertEqual(stats['local_gb_used'], 1024 - 500)",
            "        self.assertEqual(stats['memory_mb'], 1000)",
            "        self.assertEqual(stats['memory_mb_used'], 500)",
            "        self.assertEqual(stats['hypervisor_type'], 'VMware vCenter Server')",
            "        self.assertEqual(stats['hypervisor_version'], 5001000)",
            "        self.assertEqual(stats['hypervisor_hostname'], self.node_name)",
            "        self.assertEqual(stats['cpu_info'], jsonutils.dumps(cpu_info))",
            "        self.assertEqual(stats['supported_instances'],",
            "                '[[\"i686\", \"vmware\", \"hvm\"], [\"x86_64\", \"vmware\", \"hvm\"]]')",
            "",
            "    def test_invalid_datastore_regex(self):",
            "",
            "        # Tests if we raise an exception for Invalid Regular Expression in",
            "        # vmware_datastore_regex",
            "        self.flags(cluster_name=['test_cluster'], datastore_regex='fake-ds(01',",
            "                   group='vmware')",
            "        self.assertRaises(exception.InvalidInput, driver.VMwareVCDriver, None)",
            "",
            "    def test_get_available_nodes(self):",
            "        nodelist = self.conn.get_available_nodes()",
            "        self.assertEqual(len(nodelist), 2)",
            "        self.assertIn(self.node_name, nodelist)",
            "        self.assertIn(self.node_name2, nodelist)",
            "",
            "    def test_spawn_multiple_node(self):",
            "",
            "        def fake_is_neutron():",
            "            return False",
            "",
            "        self.stubs.Set(nova_utils, 'is_neutron', fake_is_neutron)",
            "        uuid1 = uuidutils.generate_uuid()",
            "        uuid2 = uuidutils.generate_uuid()",
            "        self._create_vm(node=self.node_name, num_instances=1,",
            "                        uuid=uuid1)",
            "        info = self.conn.get_info({'uuid': uuid1,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        self._create_vm(node=self.node_name2, num_instances=1,",
            "                        uuid=uuid2)",
            "        info = self.conn.get_info({'uuid': uuid2,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(power_on=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(power_on=False)",
            "        self.assertEqual(False, self.power_on_called)",
            "",
            "    def test_finish_migration_power_on_resize(self):",
            "        self._test_finish_migration(power_on=True,",
            "                                    resize_instance=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(power_on=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(power_on=False)",
            "        self.assertEqual(False, self.power_on_called)",
            "",
            "    def test_snapshot(self):",
            "        # Ensure VMwareVCVMOps's get_copy_virtual_disk_spec is getting called",
            "        # two times",
            "        self.mox.StubOutWithMock(vmops.VMwareVCVMOps,",
            "                                 'get_copy_virtual_disk_spec')",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_using_file_manager(self):",
            "        self._create_vm()",
            "        uuid_str = uuidutils.generate_uuid()",
            "        self.mox.StubOutWithMock(uuidutils,",
            "                                 'generate_uuid')",
            "        uuidutils.generate_uuid().AndReturn(uuid_str)",
            "",
            "        self.mox.StubOutWithMock(ds_util, 'file_delete')",
            "        # Check calls for delete vmdk and -flat.vmdk pair",
            "        ds_util.file_delete(mox.IgnoreArg(),",
            "                \"[%s] vmware_temp/%s-flat.vmdk\" % (self.ds, uuid_str),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        ds_util.file_delete(mox.IgnoreArg(),",
            "                \"[%s] vmware_temp/%s.vmdk\" % (self.ds, uuid_str),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._test_snapshot()",
            "",
            "    def test_spawn_invalid_node(self):",
            "        self._create_instance(node='InvalidNodeName')",
            "        self.assertRaises(exception.NotFound, self.conn.spawn,",
            "                          self.context, self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    def test_spawn_with_sparse_image(self):",
            "        # Only a sparse disk image triggers the copy",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [1024, {\"vmware_ostype\": \"otherGuest\",",
            "                         \"vmware_adaptertype\": \"lsiLogic\",",
            "                         \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "",
            "        # Ensure VMwareVCVMOps's get_copy_virtual_disk_spec is getting called",
            "        # two times",
            "        self.mox.StubOutWithMock(vmops.VMwareVCVMOps,",
            "                                 'get_copy_virtual_disk_spec')",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_plug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.plug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_unplug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.unplug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        def fake_update_instance_progress(context, instance, step,",
            "                                          total_steps):",
            "            pass",
            "",
            "        def fake_get_host_ref_from_name(dest):",
            "            return None",
            "",
            "        self._create_vm()",
            "        vm_ref_orig = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        flavor = {'name': 'fake', 'flavorid': 'fake_id'}",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_update_instance_progress)",
            "        self.stubs.Set(self.conn._vmops, \"_get_host_ref_from_name\",",
            "                       fake_get_host_ref_from_name)",
            "        self.conn.migrate_disk_and_power_off(self.context, self.instance,",
            "                                             'fake_dest', flavor,",
            "                                             None)",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref_orig.value, vm_ref.value,",
            "                             \"These should be different\")",
            "",
            "    def test_disassociate_vmref_from_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                        self.instance, vm_ref, \"-backup\")",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "",
            "    def test_clone_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        host_ref = vmwareapi_fake._get_object_refs(\"HostSystem\")[0]",
            "        ds_ref = vmwareapi_fake._get_object_refs(\"Datastore\")[0]",
            "        dc_obj = vmwareapi_fake._get_objects(\"Datacenter\").objects[0]",
            "        vm_util.clone_vmref_for_instance(self.conn._session, self.instance,",
            "                                         vm_ref, host_ref, ds_ref,",
            "                                         dc_obj.get(\"vmFolder\"))",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "        cloned_vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref.value, cloned_vm_ref.value,",
            "                            \"Reference for the cloned VM should be different\")",
            "        vm_obj = vmwareapi_fake._get_vm_mdo(vm_ref)",
            "        cloned_vm_obj = vmwareapi_fake._get_vm_mdo(cloned_vm_ref)",
            "        self.assertEqual(vm_obj.name, self.instance['uuid'] + \"-backup\",",
            "                       \"Original VM name should be with suffix -backup\")",
            "        self.assertEqual(cloned_vm_obj.name, self.instance['uuid'],",
            "                       \"VM name does not match instance['uuid']\")",
            "        self.assertRaises(error_util.MissingParameter,",
            "                          vm_util.clone_vmref_for_instance, self.conn._session,",
            "                          self.instance, None, host_ref, ds_ref,",
            "                          dc_obj.get(\"vmFolder\"))",
            "",
            "    def test_associate_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        # First disassociate the VM from the instance so that we have a VM",
            "        # to later associate using the associate_vmref_for_instance method",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        # Ensure that the VM is indeed disassociated and that we cannot find",
            "        # the VM using the get_vm_ref method",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "        # Associate the VM back to the instance",
            "        vm_util.associate_vmref_for_instance(self.conn._session, self.instance,",
            "                                             suffix=\"-backup\")",
            "        # Verify if we can get the VM reference",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.conn.confirm_migration(self.context, self.instance, None)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk(vc_support=True)",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False, vc_support=True)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareVCDriver does not implement the pause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.pause, self.instance)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareVCDriver does not implement the unpause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          self.instance)",
            "",
            "    def test_datastore_dc_map(self):",
            "        vmops = self.conn._resources[self.node_name]['vmops']",
            "        self.assertEqual({}, vmops._datastore_dc_mapping)",
            "        self._create_vm()",
            "        # currently there are 2 data stores",
            "        self.assertEqual(2, len(vmops._datastore_dc_mapping))",
            "",
            "    def test_rollback_live_migration_at_destination(self):",
            "        with mock.patch.object(self.conn, \"destroy\") as mock_destroy:",
            "            self.conn.rollback_live_migration_at_destination(self.context,",
            "                    \"instance\", [], None)",
            "            mock_destroy.assert_called_once_with(self.context,",
            "                    \"instance\", [], None)",
            "",
            "    def test_get_instance_disk_info_is_implemented(self):",
            "        # Ensure that the method has been implemented in the driver",
            "        try:",
            "            disk_info = self.conn.get_instance_disk_info('fake_instance_name')",
            "            self.assertIsNone(disk_info)",
            "        except NotImplementedError:",
            "            self.fail(\"test_get_instance_disk_info() should not raise \"",
            "                      \"NotImplementedError\")",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        # Overwrite the vmPathName",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        vm = vms.objects[0]",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.network_info,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Test suite for VMwareAPI.",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import copy",
            "import datetime",
            "import time",
            "",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "import suds",
            "",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import exception",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import test",
            "from nova.tests import fake_instance",
            "import nova.tests.image.fake",
            "from nova.tests import matchers",
            "from nova.tests import test_flavors",
            "from nova.tests import utils",
            "from nova.tests.virt.vmwareapi import stubs",
            "from nova import utils as nova_utils",
            "from nova.virt import driver as v_driver",
            "from nova.virt import fake",
            "from nova.virt.vmwareapi import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import fake as vmwareapi_fake",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vim",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmops",
            "from nova.virt.vmwareapi import vmware_images",
            "from nova.virt.vmwareapi import volume_util",
            "from nova.virt.vmwareapi import volumeops",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('remove_unused_original_minimum_age_seconds',",
            "                'nova.virt.imagecache')",
            "",
            "",
            "class fake_vm_ref(object):",
            "    def __init__(self):",
            "        self.value = 4",
            "        self._type = 'VirtualMachine'",
            "",
            "",
            "class fake_service_content(object):",
            "    def __init__(self):",
            "        self.ServiceContent = vmwareapi_fake.DataObject()",
            "        self.ServiceContent.fake = 'fake'",
            "",
            "",
            "class VMwareSudsTest(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareSudsTest, self).setUp()",
            "",
            "        def new_client_init(self, url, **kwargs):",
            "            return",
            "",
            "        mock.patch.object(suds.client.Client,",
            "                          '__init__', new=new_client_init).start()",
            "        self.vim = self._vim_create()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def _vim_create(self):",
            "",
            "        def fake_retrieve_service_content(fake):",
            "            return fake_service_content()",
            "",
            "        self.stubs.Set(vim.Vim, 'retrieve_service_content',",
            "                fake_retrieve_service_content)",
            "        return vim.Vim()",
            "",
            "    def test_exception_with_deepcopy(self):",
            "        self.assertIsNotNone(self.vim)",
            "        self.assertRaises(error_util.VimException,",
            "                          copy.deepcopy, self.vim)",
            "",
            "",
            "class VMwareSessionTestCase(test.NoDBTestCase):",
            "",
            "    def _fake_is_vim_object(self, module):",
            "        return True",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_call_method_vim_fault(self, mock_sleep):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        def _fake_session_is_active(self):",
            "            return False",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "            mock.patch.object(driver.VMwareAPISession, '_session_is_active',",
            "                              _fake_session_is_active)",
            "        ) as (_fake_vim, _fake_create, _fake_is_active):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.VimFaultException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_temp_method_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_vim_empty(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        def _fake_session_is_active(self):",
            "            return True",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "            mock.patch.object(driver.VMwareAPISession, '_session_is_active',",
            "                              _fake_session_is_active)",
            "        ) as (_fake_vim, _fake_create, _fake_is_active):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            res = api_session._call_method(stubs, 'fake_temp_method_exception',",
            "                                           *args, **kwargs)",
            "            self.assertEqual([], res)",
            "",
            "    @mock.patch('time.sleep')",
            "    def test_call_method_session_exception(self, mock_sleep):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.SessionConnectionException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_temp_session_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_session_file_exists_exception(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            self.assertRaises(error_util.FileAlreadyExistsException,",
            "                              api_session._call_method,",
            "                              stubs, 'fake_session_file_exception',",
            "                              *args, **kwargs)",
            "",
            "    def test_call_method_session_no_permission_exception(self):",
            "",
            "        def _fake_create_session(self):",
            "            session = vmwareapi_fake.DataObject()",
            "            session.key = 'fake_key'",
            "            session.userName = 'fake_username'",
            "            self._session = session",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                              self._fake_is_vim_object),",
            "            mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                              _fake_create_session),",
            "        ) as (_fake_vim, _fake_create):",
            "            api_session = driver.VMwareAPISession()",
            "            args = ()",
            "            kwargs = {}",
            "            e = self.assertRaises(error_util.NoPermissionException,",
            "                                  api_session._call_method,",
            "                                  stubs, 'fake_session_permission_exception',",
            "                                  *args, **kwargs)",
            "            fault_string = 'Permission to perform this operation was denied.'",
            "            details = {'privilegeId': 'Resource.AssignVMToPool',",
            "                       'object': 'domain-c7'}",
            "            exception_string = '%s %s' % (fault_string, details)",
            "            self.assertEqual(exception_string, str(e))",
            "",
            "",
            "class VMwareAPIConfTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for VMWare API configurations.\"\"\"",
            "    def setUp(self):",
            "        super(VMwareAPIConfTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIConfTestCase, self).tearDown()",
            "",
            "    def test_configure_without_wsdl_loc_override(self):",
            "        # Test the default configuration behavior. By default,",
            "        # use the WSDL sitting on the host we are talking to in",
            "        # order to bind the SOAP client.",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNone(wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"www.example.com\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"www.example.com\")",
            "        self.assertEqual(\"https://www.example.com/sdk/vimService.wsdl\",",
            "                         wsdl_url)",
            "        self.assertEqual(\"https://www.example.com/sdk\", url)",
            "",
            "    def test_configure_without_wsdl_loc_override_using_ipv6(self):",
            "        # Same as above but with ipv6 based host ip",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNone(wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"::1\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"::1\")",
            "        self.assertEqual(\"https://[::1]/sdk/vimService.wsdl\",",
            "                         wsdl_url)",
            "        self.assertEqual(\"https://[::1]/sdk\", url)",
            "",
            "    def test_configure_with_wsdl_loc_override(self):",
            "        # Use the setting vmwareapi_wsdl_loc to override the",
            "        # default path to the WSDL.",
            "        #",
            "        # This is useful as a work-around for XML parsing issues",
            "        # found when using some WSDL in combination with some XML",
            "        # parsers.",
            "        #",
            "        # The wsdl_url should point to a different host than the one we",
            "        # are actually going to send commands to.",
            "        fake_wsdl = \"https://www.test.com/sdk/foo.wsdl\"",
            "        self.flags(wsdl_location=fake_wsdl, group='vmware')",
            "        wsdl_loc = cfg.CONF.vmware.wsdl_location",
            "        self.assertIsNotNone(wsdl_loc)",
            "        self.assertEqual(fake_wsdl, wsdl_loc)",
            "        wsdl_url = vim.Vim.get_wsdl_url(\"https\", \"www.example.com\")",
            "        url = vim.Vim.get_soap_url(\"https\", \"www.example.com\")",
            "        self.assertEqual(fake_wsdl, wsdl_url)",
            "        self.assertEqual(\"https://www.example.com/sdk\", url)",
            "",
            "",
            "class VMwareAPIVMTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API connection calls.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIVMTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "        self.context = context.RequestContext('fake', 'fake', is_admin=False)",
            "        self.flags(host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass',",
            "                   datastore_regex='.*',",
            "                   api_retry_count=1,",
            "                   use_linked_clone=False, group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base',",
            "                   my_ip='')",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.node_name = 'test_url'",
            "        self.ds = 'ds1'",
            "        self.context = context.RequestContext(self.user_id, self.project_id)",
            "        stubs.set_stubs(self.stubs)",
            "        vmwareapi_fake.reset()",
            "        self.conn = driver.VMwareESXDriver(fake.FakeVirtAPI)",
            "        # NOTE(vish): none of the network plugging code is actually",
            "        #             being tested",
            "        self.network_info = utils.get_test_network_info()",
            "",
            "        self.image = {",
            "            'id': 'c1c8ce3d-c2e0-4247-890c-ccf5cc1c004c',",
            "            'disk_format': 'vmdk',",
            "            'size': 512,",
            "        }",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        self.vnc_host = 'test_url'",
            "        self._set_exception_vars()",
            "        self.instance_without_compute = {'node': None,",
            "                                         'vm_state': 'building',",
            "                                         'project_id': 'fake',",
            "                                         'user_id': 'fake',",
            "                                         'name': '1',",
            "                                         'display_description': '1',",
            "                                         'kernel_id': '1',",
            "                                         'ramdisk_id': '1',",
            "                                         'mac_addresses': [",
            "                                            {'address': 'de:ad:be:ef:be:ef'}",
            "                                         ],",
            "                                         'memory_mb': 8192,",
            "                                         'instance_type': 'm1.large',",
            "                                         'vcpus': 4,",
            "                                         'root_gb': 80,",
            "                                         'image_ref': '1',",
            "                                         'host': 'fake_host',",
            "                                         'task_state':",
            "                                         'scheduling',",
            "                                         'reservation_id': 'r-3t8muvr0',",
            "                                         'id': 1,",
            "                                         'uuid': 'fake-uuid',",
            "                                         'metadata': []}",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVMTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "        nova.tests.image.fake.FakeImageService_reset()",
            "",
            "    def _set_exception_vars(self):",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        self.exception = False",
            "",
            "    def test_driver_capabilities(self):",
            "        self.assertTrue(self.conn.capabilities['has_imagecache'])",
            "        self.assertFalse(self.conn.capabilities['supports_recreate'])",
            "",
            "    def test_login_retries(self):",
            "        self.attempts = 0",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "",
            "        def _fake_login(_self):",
            "            self.attempts += 1",
            "            if self.attempts == 1:",
            "                raise exception.NovaException('Here is my fake exception')",
            "            return self.login_session",
            "",
            "        def _fake_check_session(_self):",
            "            return True",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "        self.stubs.Set(time, 'sleep', lambda x: None)",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_check_session',",
            "                       _fake_check_session)",
            "        self.conn = driver.VMwareAPISession()",
            "        self.assertEqual(self.attempts, 2)",
            "",
            "    def test_wait_for_task_exception(self):",
            "        self.flags(task_poll_interval=1, group='vmware')",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "        self.stop_called = 0",
            "",
            "        def _fake_login(_self):",
            "            return self.login_session",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "",
            "        def fake_poll_task(task_ref, done):",
            "            done.send_exception(exception.NovaException('fake exception'))",
            "",
            "        def fake_stop_loop(loop):",
            "            self.stop_called += 1",
            "            return loop.stop()",
            "",
            "        self.conn = driver.VMwareAPISession()",
            "        self.stubs.Set(self.conn, \"_poll_task\",",
            "                       fake_poll_task)",
            "        self.stubs.Set(self.conn, \"_stop_loop\",",
            "                       fake_stop_loop)",
            "        self.assertRaises(exception.NovaException,",
            "                          self.conn._wait_for_task, 'fake-ref')",
            "        self.assertEqual(self.stop_called, 1)",
            "",
            "    def _get_instance_type_by_name(self, type):",
            "        for instance_type in test_flavors.DEFAULT_FLAVORS:",
            "            if instance_type['name'] == type:",
            "                return instance_type",
            "        if type == 'm1.micro':",
            "            return {'memory_mb': 128, 'root_gb': 0, 'deleted_at': None,",
            "                    'name': 'm1.micro', 'deleted': 0, 'created_at': None,",
            "                    'ephemeral_gb': 0, 'updated_at': None,",
            "                    'disabled': False, 'vcpus': 1, 'extra_specs': {},",
            "                    'swap': 0, 'rxtx_factor': 1.0, 'is_public': True,",
            "                    'flavorid': '1', 'vcpu_weight': None, 'id': 2}",
            "",
            "    def _create_instance(self, node=None, set_image_ref=True,",
            "                         uuid=None, instance_type='m1.large'):",
            "        if not node:",
            "            node = self.node_name",
            "        if not uuid:",
            "            uuid = uuidutils.generate_uuid()",
            "        self.type_data = self._get_instance_type_by_name(instance_type)",
            "        values = {'name': 'fake_name',",
            "                  'id': 1,",
            "                  'uuid': uuid,",
            "                  'project_id': self.project_id,",
            "                  'user_id': self.user_id,",
            "                  'kernel_id': \"fake_kernel_uuid\",",
            "                  'ramdisk_id': \"fake_ramdisk_uuid\",",
            "                  'mac_address': \"de:ad:be:ef:be:ef\",",
            "                  'flavor': instance_type,",
            "                  'node': node,",
            "                  'memory_mb': self.type_data['memory_mb'],",
            "                  'root_gb': self.type_data['root_gb'],",
            "                  'ephemeral_gb': self.type_data['ephemeral_gb'],",
            "                  'vcpus': self.type_data['vcpus'],",
            "                  'swap': self.type_data['swap'],",
            "        }",
            "        if set_image_ref:",
            "            values['image_ref'] = \"fake_image_uuid\"",
            "        self.instance_node = node",
            "        self.uuid = uuid",
            "        self.instance = fake_instance.fake_instance_obj(",
            "                self.context, **values)",
            "",
            "    def _create_vm(self, node=None, num_instances=1, uuid=None,",
            "                   instance_type='m1.large'):",
            "        \"\"\"Create and spawn the VM.\"\"\"",
            "        if not node:",
            "            node = self.node_name",
            "        self._create_instance(node=node, uuid=uuid,",
            "                              instance_type=instance_type)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=None)",
            "        self._check_vm_record(num_instances=num_instances)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def _check_vm_record(self, num_instances=1):",
            "        \"\"\"Check if the spawned VM's properties correspond to the instance in",
            "        the db.",
            "        \"\"\"",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), num_instances)",
            "",
            "        # Get Nova record for VM",
            "        vm_info = self.conn.get_info({'uuid': self.uuid,",
            "                                      'name': 1,",
            "                                      'node': self.instance_node})",
            "",
            "        # Get record for VM",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        for vm in vms.objects:",
            "            if vm.get('name') == self.uuid:",
            "                break",
            "",
            "        # Check that m1.large above turned into the right thing.",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        vcpus = self.type_data['vcpus']",
            "        self.assertEqual(vm_info['max_mem'], mem_kib)",
            "        self.assertEqual(vm_info['mem'], mem_kib)",
            "        self.assertEqual(vm.get(\"summary.config.instanceUuid\"), self.uuid)",
            "        self.assertEqual(vm.get(\"summary.config.numCpu\"), vcpus)",
            "        self.assertEqual(vm.get(\"summary.config.memorySizeMB\"),",
            "                         self.type_data['memory_mb'])",
            "",
            "        self.assertEqual(",
            "            vm.get(\"config.hardware.device\")[2].device.obj_name,",
            "            \"ns0:VirtualE1000\")",
            "        # Check that the VM is running according to Nova",
            "        self.assertEqual(vm_info['state'], power_state.RUNNING)",
            "",
            "        # Check that the VM is running according to vSphere API.",
            "        self.assertEqual(vm.get(\"runtime.powerState\"), 'poweredOn')",
            "",
            "        found_vm_uuid = False",
            "        found_iface_id = False",
            "        for c in vm.get(\"config.extraConfig\").OptionValue:",
            "            if (c.key == \"nvp.vm-uuid\" and c.value == self.instance['uuid']):",
            "                found_vm_uuid = True",
            "            if (c.key == \"nvp.iface-id.0\" and c.value == \"vif-xxx-yyy-zzz\"):",
            "                found_iface_id = True",
            "",
            "        self.assertTrue(found_vm_uuid)",
            "        self.assertTrue(found_iface_id)",
            "",
            "    def _check_vm_info(self, info, pwr_state=power_state.RUNNING):",
            "        \"\"\"Check if the get_info returned values correspond to the instance",
            "        object in the db.",
            "        \"\"\"",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        self.assertEqual(info[\"state\"], pwr_state)",
            "        self.assertEqual(info[\"max_mem\"], mem_kib)",
            "        self.assertEqual(info[\"mem\"], mem_kib)",
            "        self.assertEqual(info[\"num_cpu\"], self.type_data['vcpus'])",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_list_instances_1(self):",
            "        self._create_vm()",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "",
            "    def test_list_instance_uuids(self):",
            "        self._create_vm()",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 1)",
            "",
            "    def test_list_instance_uuids_invalid_uuid(self):",
            "        self._create_vm(uuid='fake_id')",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 0)",
            "",
            "    def _cached_files_exist(self, exists=True):",
            "        cache = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                 self.ds)",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(cache))",
            "",
            "    def test_instance_dir_disk_created(self):",
            "        \"\"\"Test image file is cached when even when use_linked_clone",
            "            is False",
            "        \"\"\"",
            "",
            "        self._create_vm()",
            "        inst_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        cache = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                 self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(inst_file_path))",
            "        self._cached_files_exist()",
            "",
            "    def test_cache_dir_disk_created(self):",
            "        \"\"\"Test image disk is cached when use_linked_clone is True.\"\"\"",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self._create_vm()",
            "        file = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.vmdk' %",
            "                self.ds)",
            "        root = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.80.vmdk' %",
            "                self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(file))",
            "        self.assertTrue(vmwareapi_fake.get_file(root))",
            "",
            "    def _iso_disk_type_created(self, instance_type='m1.large'):",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm(instance_type=instance_type)",
            "        file = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' %",
            "                self.ds)",
            "        self.assertTrue(vmwareapi_fake.get_file(file))",
            "",
            "    def test_iso_disk_type_created(self):",
            "        self._iso_disk_type_created()",
            "        vmdk_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(vmdk_file_path))",
            "",
            "    def test_iso_disk_type_created_with_root_gb_0(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        vmdk_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertFalse(vmwareapi_fake.get_file(vmdk_file_path))",
            "",
            "    def test_iso_disk_cdrom_attach(self):",
            "        self.iso_path = (",
            "            '[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' % self.ds)",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path)",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "",
            "    def test_iso_disk_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self.iso_path = [",
            "            ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.iso' %",
            "             self.ds),",
            "            '[%s] fake-config-drive' % self.ds]",
            "        self.iso_unit_nos = [0, 1]",
            "        self.iso_index = 0",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path[self.iso_index])",
            "            self.iso_index += 1",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "        self.assertEqual(self.iso_index, 2)",
            "",
            "    def test_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self.iso_path = '[%s] fake-config-drive' % self.ds",
            "        self.cd_attach_called = False",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, self.iso_path)",
            "            self.cd_attach_called = True",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        self.assertTrue(self.cd_attach_called)",
            "",
            "    def test_spawn(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_root_size_0(self):",
            "        self._create_vm(instance_type='m1.micro')",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        cache = ('[%s] vmware_base/%s/%s.vmdk' %",
            "                 (self.ds, 'fake_image_uuid', 'fake_image_uuid'))",
            "        gb_cache = ('[%s] vmware_base/%s/%s.0.vmdk' %",
            "                    (self.ds, 'fake_image_uuid', 'fake_image_uuid'))",
            "        self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        self.assertFalse(vmwareapi_fake.get_file(gb_cache))",
            "",
            "    def _spawn_with_delete_exception(self, fault=None):",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=fault)",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            if fault:",
            "                self._create_vm()",
            "                info = self.conn.get_info({'uuid': self.uuid,",
            "                                           'node': self.instance_node})",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self.assertRaises(error_util.VMwareDriverException,",
            "                                  self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_delete_exception_not_found(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileNotFound())",
            "",
            "    def test_spawn_with_delete_exception_file_fault(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileFault())",
            "",
            "    def test_spawn_with_delete_exception_cannot_delete_file(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.CannotDeleteFile())",
            "",
            "    def test_spawn_with_delete_exception_file_locked(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileLocked())",
            "",
            "    def test_spawn_with_delete_exception_general(self):",
            "        self._spawn_with_delete_exception()",
            "",
            "    def test_spawn_disk_extend(self):",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_exists(self):",
            "        root = ('[%s] vmware_base/fake_image_uuid/fake_image_uuid.80.vmdk' %",
            "                self.ds)",
            "        self.root = root",
            "",
            "        def _fake_extend(instance, requested_size, name, dc_ref):",
            "            vmwareapi_fake._add_file(self.root)",
            "",
            "        self.stubs.Set(self.conn._vmops, '_extend_virtual_disk',",
            "                       _fake_extend)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertTrue(vmwareapi_fake.get_file(root))",
            "",
            "    def test_spawn_disk_extend_sparse(self):",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [1024, {\"vmware_ostype\": \"otherGuest\",",
            "                         \"vmware_adaptertype\": \"lsiLogic\",",
            "                         \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_insufficient_disk_space(self):",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        id = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           id, id)",
            "        tmp_file = '[%s] vmware_base/%s/%s.80-flat.vmdk' % (self.ds,",
            "                                                            id, id)",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                self.assertTrue(vmwareapi_fake.get_file(tmp_file))",
            "                raise exception.NovaException('No space!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"ExtendVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        self.stubs.Set(self.conn._session, \"_call_method\", fake_call_method)",
            "        self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                       fake_wait_for_task)",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "        self.assertFalse(vmwareapi_fake.get_file(tmp_file))",
            "",
            "    def test_spawn_disk_extend_failed_copy(self):",
            "        # Spawn instance",
            "        # copy for extend fails without creating a file",
            "        #",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        CopyError = error_util.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == 'fake-copy-task':",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                return 'fake-copy-task'",
            "",
            "            return self.call_method(module, method, *args, **kwargs)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaving a file behind",
            "        #",
            "        # Expect the file to be cleaned up",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        uuid = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = error_util.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy_failed_cleanup(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaves file behind",
            "        # File cleanup fails",
            "        #",
            "        # Expect file to be left behind",
            "        # Expect file cleanup error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        uuid = 'fake_image_uuid'",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = error_util.FileFaultException",
            "        DeleteError = error_util.CannotDeleteFileException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            elif task_ref == 'fake-delete-task':",
            "                raise DeleteError('Delete failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                return 'fake-delete-task'",
            "",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method)):",
            "            self.assertRaises(DeleteError, self._create_vm)",
            "        self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_invalid_disk_size(self):",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [82 * units.Gi,",
            "                  {\"vmware_ostype\": \"otherGuest\",",
            "                   \"vmware_adaptertype\": \"lsiLogic\",",
            "                   \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InstanceUnacceptable,",
            "                          self._create_vm)",
            "",
            "    def test_spawn_invalid_disk_format(self):",
            "        self._create_instance()",
            "        self.image['disk_format'] = 'invalid'",
            "        self.assertRaises(exception.InvalidDiskFormat,",
            "                          self.conn.spawn, self.context,",
            "                          self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    def test_spawn_with_move_file_exists_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise an file exists exception. The flag",
            "        # self.exception will be checked to see that",
            "        # the exception has indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise error_util.FileAlreadyExistsException()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_general_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a general exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise error_util.VMwareDriverException('Exception!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self.assertRaises(error_util.VMwareDriverException,",
            "                              self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_poll_exception(self):",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\")",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self.assertRaises(error_util.VMwareDriverException,",
            "                              self._create_vm)",
            "",
            "    def test_spawn_with_move_file_exists_poll_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a file exists exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=vmwareapi_fake.FileAlreadyExists())",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def _spawn_attach_volume_vmdk(self, set_image_ref=True, vc_support=False):",
            "        self._create_instance(set_image_ref=set_image_ref)",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        if vc_support:",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_get_res_pool_of_vm')",
            "            volumeops.VMwareVolumeOps._get_res_pool_of_vm(",
            "                     mox.IgnoreArg()).AndReturn('fake_res_pool')",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_relocate_vmdk_volume')",
            "            volumeops.VMwareVolumeOps._relocate_vmdk_volume(mox.IgnoreArg(),",
            "                     'fake_res_pool', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk()",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False)",
            "",
            "    def test_spawn_attach_volume_iscsi(self):",
            "        self._create_instance()",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def mock_upload_image(self, context, image, instance, **kwargs):",
            "        self.assertEqual(image, 'Test-Snapshot')",
            "        self.assertEqual(instance, self.instance)",
            "        self.assertEqual(kwargs['disk_type'], 'preallocated')",
            "",
            "    def test_get_vm_ref_using_extra_config(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        # Disrupt the fake Virtual Machine object so that extraConfig",
            "        # cannot be matched.",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"\"",
            "        # We should not get a Virtual Machine through extraConfig.",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNone(vm_ref, 'VM Reference should be none')",
            "        # Check if we can find the Virtual Machine using the name.",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def test_search_vm_ref_by_identifier(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self.conn._session,",
            "                                            self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm.set(\"summary.config.instanceUuid\", \"foo\")",
            "        fake_vm.set(\"name\", \"foo\")",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"foo\"",
            "        self.assertIsNone(vm_util.search_vm_ref_by_identifier(",
            "                                    self.conn._session, self.instance['uuid']),",
            "                          \"VM Reference should be none\")",
            "        self.assertIsNotNone(",
            "                vm_util.search_vm_ref_by_identifier(self.conn._session, \"foo\"),",
            "                \"VM Reference should not be none\")",
            "",
            "    def test_get_object_for_optionvalue(self):",
            "        self._create_vm()",
            "        vms = self.conn._session._call_method(vim_util, \"get_objects\",",
            "                \"VirtualMachine\", ['config.extraConfig[\"nvp.vm-uuid\"]'])",
            "        vm_ref = vm_util._get_object_for_optionvalue(vms,",
            "                                                     self.instance[\"uuid\"])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def _test_snapshot(self):",
            "        expected_calls = [",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_PENDING_UPLOAD}},",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_UPLOADING,",
            "                  'expected_state': task_states.IMAGE_PENDING_UPLOAD}}]",
            "        func_call_matcher = matchers.FunctionCallMatcher(expected_calls)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        with mock.patch.object(vmware_images, 'upload_image',",
            "                               self.mock_upload_image):",
            "            self.conn.snapshot(self.context, self.instance, \"Test-Snapshot\",",
            "                               func_call_matcher.call)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertIsNone(func_call_matcher.match())",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_no_root_disk(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        self.assertRaises(error_util.NoRootDiskDefined, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_delete_vm_snapshot(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0].obj",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_create_vm_snapshot')",
            "        self.conn._vmops._create_vm_snapshot(",
            "                self.instance, fake_vm).AndReturn(snapshot_ref)",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_delete_vm_snapshot')",
            "        self.conn._vmops._delete_vm_snapshot(",
            "                self.instance, fake_vm, snapshot_ref).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        self._test_snapshot()",
            "",
            "    def test_reboot(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_with_uuid(self):",
            "        \"\"\"Test fall back to use name when can't find by uuid.\"\"\"",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_poll_rebooting_instances(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'reboot')",
            "        compute_api.API.reboot(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        instances = [self.instance]",
            "        self.conn.poll_rebooting_instances(60, instances)",
            "",
            "    def test_reboot_not_poweredon(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstanceRebootFailure, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_suspend(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "",
            "    def test_suspend_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.suspend,",
            "                          self.instance)",
            "",
            "    def test_resume(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.conn.resume(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_resume_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_resume_not_suspended(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertRaises(exception.InstanceResumeFailure, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_on(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.conn.power_on(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_power_on_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_on,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_off(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_power_off_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_off,",
            "                          self.instance)",
            "",
            "    def test_power_off_suspended(self):",
            "        self._create_vm()",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstancePowerOffFailure,",
            "                          self.conn.power_off, self.instance)",
            "",
            "    def test_resume_state_on_host_boot(self):",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, \"reboot\")",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOff\")",
            "        self.conn.reboot(self.context, self.instance, 'network_info',",
            "            'hard', None)",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_1(self):",
            "        \"\"\"Don't call reboot on instance which is poweredon.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOn\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_2(self):",
            "        \"\"\"Don't call reboot on instance which is suspended.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"suspended\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def destroy_rescued(self, fake_method):",
            "        self._rescue()",
            "        with (",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              fake_method)",
            "        ):",
            "            self.instance['vm_state'] = vm_states.RESCUED",
            "            self.conn.destroy(self.context, self.instance, self.network_info)",
            "            inst_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(inst_path))",
            "            rescue_file_path = '[%s] %s-rescue/%s-rescue.vmdk' % (self.ds,",
            "                                                                  self.uuid,",
            "                                                                  self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(rescue_file_path))",
            "",
            "    def test_destroy_rescued(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            pass",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy_rescued_with_exception(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            raise exception.NovaException('Here is my fake exception')",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        # Overwrite the vmPathName",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        vm = vms.objects[0]",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.network_info,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def _destroy_instance_without_vm_ref(self, resize_exists=False,",
            "                                         task_state=None):",
            "",
            "        def fake_vm_ref_from_name(session, vm_name):",
            "            if resize_exists:",
            "                return 'fake-ref'",
            "",
            "        self._create_instance()",
            "        with contextlib.nested(",
            "             mock.patch.object(vm_util, 'get_vm_ref_from_name',",
            "                               fake_vm_ref_from_name),",
            "             mock.patch.object(self.conn._session,",
            "                               '_call_method'),",
            "             mock.patch.object(self.conn._vmops,",
            "                               '_destroy_instance')",
            "        ) as (mock_get, mock_call, mock_destroy):",
            "            self.instance.task_state = task_state",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, True)",
            "            if resize_exists:",
            "                if task_state == task_states.RESIZE_REVERTING:",
            "                    expected = 1",
            "                else:",
            "                    expected = 2",
            "            else:",
            "                expected = 1",
            "            self.assertEqual(expected, mock_destroy.call_count)",
            "            self.assertFalse(mock_call.called)",
            "",
            "    def test_destroy_instance_without_vm_ref(self):",
            "        self._destroy_instance_without_vm_ref()",
            "",
            "    def test_destroy_instance_without_vm_ref_with_resize(self):",
            "        self._destroy_instance_without_vm_ref(resize_exists=True)",
            "",
            "    def test_destroy_instance_without_vm_ref_with_resize_revert(self):",
            "        self._destroy_instance_without_vm_ref(resize_exists=True,",
            "            task_state=task_states.RESIZE_REVERTING)",
            "",
            "    def _rescue(self, config_drive=False):",
            "        def fake_attach_disk_to_vm(vm_ref, instance,",
            "                                   adapter_type, disk_type, vmdk_path=None,",
            "                                   disk_size=None, linked_clone=False,",
            "                                   controller_key=None, unit_number=None,",
            "                                   device_name=None):",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        if config_drive:",
            "            def fake_create_config_drive(instance, injected_files, password,",
            "                                         data_store_name, folder,",
            "                                         instance_uuid, cookies):",
            "                self.assertTrue(uuidutils.is_uuid_like(instance['uuid']))",
            "",
            "            self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                           fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.stubs.Set(self.conn._volumeops, \"attach_disk_to_vm\",",
            "                       fake_attach_disk_to_vm)",
            "        self.conn.rescue(self.context, self.instance, self.network_info,",
            "                         self.image, 'fake-password')",
            "        info = self.conn.get_info({'name': '1-rescue',",
            "                                   'uuid': '%s-rescue' % self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get('%s-rescue' % self.uuid))",
            "",
            "    def test_rescue(self):",
            "        self._rescue()",
            "        inst_file_path = '[%s] %s/%s.vmdk' % (self.ds, self.uuid, self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(inst_file_path))",
            "        rescue_file_path = '[%s] %s-rescue/%s-rescue.vmdk' % (self.ds,",
            "                                                              self.uuid,",
            "                                                              self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(rescue_file_path))",
            "",
            "    def test_rescue_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self._rescue(config_drive=True)",
            "",
            "    def test_unrescue(self):",
            "        self._rescue()",
            "        self.test_vm_ref = None",
            "        self.test_device_name = None",
            "",
            "        def fake_power_off_vm_ref(vm_ref):",
            "            self.test_vm_ref = vm_ref",
            "            self.assertIsNotNone(vm_ref)",
            "",
            "        def fake_detach_disk_from_vm(vm_ref, instance,",
            "                                     device_name, destroy_disk=False):",
            "            self.test_device_name = device_name",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._vmops, \"_power_off_vm_ref\",",
            "                              side_effect=fake_power_off_vm_ref),",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              side_effect=fake_detach_disk_from_vm),",
            "        ) as (poweroff, detach):",
            "            self.conn.unrescue(self.instance, None)",
            "            poweroff.assert_called_once_with(self.test_vm_ref)",
            "            detach.assert_called_once_with(self.test_vm_ref, mock.ANY,",
            "                                           self.test_device_name)",
            "            self.test_vm_ref = None",
            "            self.test_device_name = None",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareESXDriver does not implement the pause method.",
            "        self.assertRaises(NotImplementedError, self.conn.pause, instance=None)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareESXDriver does not implement the unpause method.",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          instance=None)",
            "",
            "    def test_get_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'memoryReservation': 0, 'suspendInterval': 0,",
            "                    'maxCpuUsage': 2000, 'toolsInstallerMounted': False,",
            "                    'consumedOverheadMemory': 20, 'numEthernetCards': 1,",
            "                    'numCpu': 1, 'featureRequirement': [{'key': 'cpuid.AES'}],",
            "                    'memoryOverhead': 21417984,",
            "                    'guestMemoryUsage': 0, 'connectionState': 'connected',",
            "                    'memorySizeMB': 512, 'balloonedMemory': 0,",
            "                    'vmPathName': 'fake_path', 'template': False,",
            "                    'overallCpuUsage': 0, 'powerState': 'poweredOn',",
            "                    'cpuReservation': 0, 'overallCpuDemand': 0,",
            "                    'numVirtualDisks': 1, 'hostMemoryUsage': 141}",
            "        expected = dict([('vmware:' + k, v) for k, v in expected.items()])",
            "        self.assertThat(",
            "                self.conn.get_diagnostics({'name': 1, 'uuid': self.uuid,",
            "                                           'node': self.instance_node}),",
            "                matchers.DictMatches(expected))",
            "",
            "    def test_get_console_output(self):",
            "        self.assertRaises(NotImplementedError, self.conn.get_console_output,",
            "            None, None)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Tests the finish_migration method on vmops.\"\"\"",
            "",
            "        self.power_on_called = False",
            "        self.wait_for_task = False",
            "        self.wait_task = self.conn._session._wait_for_task",
            "",
            "        def fake_power_on(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            self.power_on_called = True",
            "",
            "        def fake_vmops_update_instance_progress(context, instance, step,",
            "                                                total_steps):",
            "            self.assertEqual(self.context, context)",
            "            self.assertEqual(self.instance, instance)",
            "            self.assertEqual(4, step)",
            "            self.assertEqual(vmops.RESIZE_TOTAL_STEPS, total_steps)",
            "",
            "        if resize_instance:",
            "            def fake_wait_for_task(task_ref):",
            "                self.wait_for_task = True",
            "                return self.wait_task(task_ref)",
            "",
            "            self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                           fake_wait_for_task)",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_power_on\", fake_power_on)",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_vmops_update_instance_progress)",
            "",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "        # perform the migration on our stubbed methods",
            "        self.conn.finish_migration(context=self.context,",
            "                                   migration=None,",
            "                                   instance=self.instance,",
            "                                   disk_info=None,",
            "                                   network_info=None,",
            "                                   block_device_info=None,",
            "                                   resize_instance=resize_instance,",
            "                                   image_meta=None,",
            "                                   power_on=power_on)",
            "        if resize_instance:",
            "            self.assertTrue(self.wait_for_task)",
            "        else:",
            "            self.assertFalse(self.wait_for_task)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=False)",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.confirm_migration, self.context,",
            "                          self.instance, None)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        \"\"\"Tests the finish_revert_migration method on vmops.\"\"\"",
            "",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "",
            "        self.power_on_called = False",
            "        self.vm_name = str(self.instance['name']) + '-orig'",
            "",
            "        def fake_power_on(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            self.power_on_called = True",
            "",
            "        def fake_get_orig_vm_name_label(instance):",
            "            self.assertEqual(self.instance, instance)",
            "            return self.vm_name",
            "",
            "        def fake_get_vm_ref_from_name(session, vm_name):",
            "            self.assertEqual(self.vm_name, vm_name)",
            "            return vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "",
            "        def fake_get_vm_ref_from_uuid(session, vm_uuid):",
            "            return vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "",
            "        def fake_call_method(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_wait_for_task(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_power_on\", fake_power_on)",
            "        self.stubs.Set(self.conn._vmops, \"_get_orig_vm_name_label\",",
            "                       fake_get_orig_vm_name_label)",
            "        self.stubs.Set(vm_util, \"_get_vm_ref_from_uuid\",",
            "                       fake_get_vm_ref_from_uuid)",
            "        self.stubs.Set(vm_util, \"get_vm_ref_from_name\",",
            "                       fake_get_vm_ref_from_name)",
            "        self.stubs.Set(self.conn._session, \"_call_method\", fake_call_method)",
            "        self.stubs.Set(self.conn._session, \"_wait_for_task\",",
            "                       fake_wait_for_task)",
            "",
            "        # perform the revert on our stubbed methods",
            "        self.conn.finish_revert_migration(self.context,",
            "                                          instance=self.instance,",
            "                                          network_info=None,",
            "                                          power_on=power_on)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self._test_finish_migration, power_on=False)",
            "",
            "    def test_get_console_pool_info(self):",
            "        info = self.conn.get_console_pool_info(\"console_type\")",
            "        self.assertEqual(info['address'], 'test_url')",
            "        self.assertEqual(info['username'], 'test_username')",
            "        self.assertEqual(info['password'], 'test_pass')",
            "",
            "    def test_get_vnc_console_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def _test_get_vnc_console(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        OptionValue = collections.namedtuple('OptionValue', ['key', 'value'])",
            "        opt_val = OptionValue(key='', value=5906)",
            "        fake_vm.set(vm_util.VNC_CONFIG_KEY, opt_val)",
            "        vnc_dict = self.conn.get_vnc_console(self.context, self.instance)",
            "        self.assertEqual(vnc_dict['host'], self.vnc_host)",
            "        self.assertEqual(vnc_dict['port'], 5906)",
            "",
            "    def test_get_vnc_console(self):",
            "        self._test_get_vnc_console()",
            "",
            "    def test_get_vnc_console_noport(self):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def test_host_ip_addr(self):",
            "        self.assertEqual(self.conn.get_host_ip_addr(), \"test_url\")",
            "",
            "    def test_get_volume_connector(self):",
            "        self._create_vm()",
            "        connector_dict = self.conn.get_volume_connector(self.instance)",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0]",
            "        fake_vm_id = fake_vm.obj.value",
            "        self.assertEqual(connector_dict['ip'], 'test_url')",
            "        self.assertEqual(connector_dict['initiator'], 'iscsi-name')",
            "        self.assertEqual(connector_dict['host'], 'test_url')",
            "        self.assertEqual(connector_dict['instance'], fake_vm_id)",
            "",
            "    def _test_vmdk_connection_info(self, type):",
            "        return {'driver_volume_type': type,",
            "                'serial': 'volume-fake-id',",
            "                'data': {'volume': 'vm-10',",
            "                         'volume_id': 'volume-fake-id'}}",
            "",
            "    def test_volume_attach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._attach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._detach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_vmdk_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "",
            "        # create fake backing info",
            "        volume_device = vmwareapi_fake.DataObject()",
            "        volume_device.backing = vmwareapi_fake.DataObject()",
            "        volume_device.backing.fileName = 'fake_path'",
            "",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_vmdk_base_volume_device')",
            "        volumeops.VMwareVolumeOps._get_vmdk_base_volume_device(",
            "                mox.IgnoreArg()).AndReturn(volume_device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), mox.IgnoreArg(),",
            "                vmdk_path='fake_path')",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_detach_vmdk_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_volume_uuid')",
            "        volumeops.VMwareVolumeOps._get_volume_uuid(mox.IgnoreArg(),",
            "                'volume-fake-id').AndReturn('fake_disk_uuid')",
            "        self.mox.StubOutWithMock(vm_util, 'get_vmdk_backed_disk_device')",
            "        vm_util.get_vmdk_backed_disk_device(mox.IgnoreArg(),",
            "                'fake_disk_uuid').AndReturn('fake_device')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_consolidate_vmdk_volume')",
            "        volumeops.VMwareVolumeOps._consolidate_vmdk_volume(self.instance,",
            "                 mox.IgnoreArg(), 'fake_device', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_volume_attach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._attach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._detach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_iscsi_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_host:port'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        discover = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volume_util, 'find_st')",
            "        # simulate target not found",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                            mox.IgnoreArg()).AndReturn((None, None))",
            "        self.mox.StubOutWithMock(volume_util, '_add_iscsi_send_target_host')",
            "        # rescan gets called with target portal",
            "        volume_util.rescan_iscsi_hba(",
            "            self.conn._session,",
            "            target_portal=connection_info['data']['target_portal'])",
            "        # simulate target found",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                            mox.IgnoreArg()).AndReturn(discover)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), 'rdmp',",
            "                device_name=mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_rescan_iscsi_hba(self):",
            "        fake_target_portal = 'fake_target_host:port'",
            "        host_storage_sys = vmwareapi_fake._get_objects(",
            "            \"HostStorageSystem\").objects[0]",
            "        iscsi_hba_array = host_storage_sys.get('storageDeviceInfo'",
            "                                               '.hostBusAdapter')",
            "        iscsi_hba = iscsi_hba_array.HostHostBusAdapter[0]",
            "        # Check the host system does not have the send target",
            "        self.assertRaises(AttributeError, getattr, iscsi_hba,",
            "                          'configuredSendTarget')",
            "        # Rescan HBA with the target portal",
            "        volume_util.rescan_iscsi_hba(self.conn._session, None,",
            "                                     fake_target_portal)",
            "        # Check if HBA has the target portal configured",
            "        self.assertEqual('fake_target_host',",
            "                          iscsi_hba.configuredSendTarget[0].address)",
            "        # Rescan HBA with same portal",
            "        volume_util.rescan_iscsi_hba(self.conn._session, None,",
            "                                     fake_target_portal)",
            "        self.assertEqual(1, len(iscsi_hba.configuredSendTarget))",
            "",
            "    def test_find_st(self):",
            "        data = {'target_portal': 'fake_target_host:port',",
            "                'target_iqn': 'fake_target_iqn'}",
            "        host = vmwareapi_fake._get_objects('HostSystem').objects[0]",
            "        host._add_iscsi_target(data)",
            "        result = volume_util.find_st(self.conn._session, data)",
            "        self.assertEqual(('fake-device', 'fake-uuid'), result)",
            "",
            "    def test_detach_iscsi_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_portal'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        find = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volume_util, 'find_st')",
            "        volume_util.find_st(mox.IgnoreArg(), connection_info['data'],",
            "                mox.IgnoreArg()).AndReturn(find)",
            "        self.mox.StubOutWithMock(vm_util, 'get_rdm_disk')",
            "        device = 'fake_device'",
            "        vm_util.get_rdm_disk(mox.IgnoreArg(), 'fake_uuid').AndReturn(device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, device, destroy_disk=True)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_connection_info_get(self):",
            "        self._create_vm()",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertIn('instance', connector)",
            "",
            "    def test_connection_info_get_after_destroy(self):",
            "        self._create_vm()",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertNotIn('instance', connector)",
            "",
            "    def test_refresh_instance_security_rules(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.refresh_instance_security_rules,",
            "                          instance=None)",
            "",
            "    def test_image_aging_image_used(self):",
            "        self._create_vm()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "",
            "    def _get_timestamp_filename(self):",
            "        return '%s%s' % (imagecache.TIMESTAMP_PREFIX,",
            "                         timeutils.strtime(at=self.old_time,",
            "                                           fmt=imagecache.TIMESTAMP_FORMAT))",
            "",
            "    def _override_time(self):",
            "        self.old_time = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "",
            "        def _fake_get_timestamp_filename(fake):",
            "            return self._get_timestamp_filename()",
            "",
            "        self.stubs.Set(imagecache.ImageCacheManager, '_get_timestamp_filename',",
            "                       _fake_get_timestamp_filename)",
            "",
            "    def _timestamp_file_exists(self, exists=True):",
            "        timestamp = ('[%s] vmware_base/fake_image_uuid/%s/' %",
            "                 (self.ds, self._get_timestamp_filename()))",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(timestamp))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(timestamp))",
            "",
            "    def _image_aging_image_marked_for_deletion(self):",
            "        self._create_vm(uuid=uuidutils.generate_uuid())",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "        self._timestamp_file_exists()",
            "",
            "    def test_image_aging_image_marked_for_deletion(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "",
            "    def _timestamp_file_removed(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "        self._create_vm(num_instances=2,",
            "                        uuid=uuidutils.generate_uuid())",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_timestamp_file_removed_spawn(self):",
            "        self._timestamp_file_removed()",
            "",
            "    def test_timestamp_file_removed_aging(self):",
            "        self._timestamp_file_removed()",
            "        ts = self._get_timestamp_filename()",
            "        ts_path = ('[%s] vmware_base/fake_image_uuid/%s/' %",
            "                   (self.ds, ts))",
            "        vmwareapi_fake._add_file(ts_path)",
            "        self._timestamp_file_exists()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_image_aging_disabled(self):",
            "        self._override_time()",
            "        self.flags(remove_unused_base_images=False)",
            "        self._create_vm()",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist(exists=True)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def _image_aging_aged(self, aging_time=100):",
            "        self._override_time()",
            "        cur_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.flags(remove_unused_original_minimum_age_seconds=aging_time)",
            "        self._image_aging_image_marked_for_deletion()",
            "        all_instances = []",
            "        timeutils.set_time_override(cur_time)",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "",
            "    def test_image_aging_aged(self):",
            "        self._image_aging_aged(aging_time=8)",
            "        self._cached_files_exist(exists=False)",
            "",
            "    def test_image_aging_not_aged(self):",
            "        self._image_aging_aged()",
            "        self._cached_files_exist()",
            "",
            "",
            "class VMwareAPIHostTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API host calls.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIHostTestCase, self).setUp()",
            "        self.flags(image_cache_subdirectory_name='vmware_base')",
            "        vm_util.vm_refs_cache_reset()",
            "        self.flags(host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass', group='vmware')",
            "        vmwareapi_fake.reset()",
            "        stubs.set_stubs(self.stubs)",
            "        self.conn = driver.VMwareESXDriver(False)",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIHostTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_host_state(self):",
            "        stats = self.conn.get_host_stats()",
            "        self.assertEqual(stats['vcpus'], 16)",
            "        self.assertEqual(stats['disk_total'], 1024)",
            "        self.assertEqual(stats['disk_available'], 500)",
            "        self.assertEqual(stats['disk_used'], 1024 - 500)",
            "        self.assertEqual(stats['host_memory_total'], 1024)",
            "        self.assertEqual(stats['host_memory_free'], 1024 - 500)",
            "        self.assertEqual(stats['hypervisor_version'], 5000000)",
            "        supported_instances = [('i686', 'vmware', 'hvm'),",
            "                               ('x86_64', 'vmware', 'hvm')]",
            "        self.assertEqual(stats['supported_instances'], supported_instances)",
            "",
            "    def _test_host_action(self, method, action, expected=None):",
            "        result = method('host', action)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_host_reboot(self):",
            "        self._test_host_action(self.conn.host_power_action, 'reboot')",
            "",
            "    def test_host_shutdown(self):",
            "        self._test_host_action(self.conn.host_power_action, 'shutdown')",
            "",
            "    def test_host_startup(self):",
            "        self._test_host_action(self.conn.host_power_action, 'startup')",
            "",
            "    def test_host_maintenance_on(self):",
            "        self._test_host_action(self.conn.host_maintenance_mode, True)",
            "",
            "    def test_host_maintenance_off(self):",
            "        self._test_host_action(self.conn.host_maintenance_mode, False)",
            "",
            "    def test_get_host_uptime(self):",
            "        result = self.conn.get_host_uptime('host')",
            "        self.assertEqual('Please refer to test_url for the uptime', result)",
            "",
            "",
            "class VMwareAPIVCDriverTestCase(VMwareAPIVMTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareAPIVCDriverTestCase, self).setUp()",
            "",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   api_retry_count=1,",
            "                   task_poll_interval=10, datastore_regex='.*', group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base')",
            "        vmwareapi_fake.reset(vc=True)",
            "        self.conn = driver.VMwareVCDriver(None, False)",
            "        self.node_name = self.conn._resources.keys()[0]",
            "        self.node_name2 = self.conn._resources.keys()[1]",
            "        if cluster_name2 in self.node_name2:",
            "            self.ds = 'ds1'",
            "        else:",
            "            self.ds = 'ds2'",
            "        self.vnc_host = 'ha-host'",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVCDriverTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_list_instances_from_nodes(self):",
            "        # Create instance on node1",
            "        self._create_vm(self.node_name)",
            "        # Create instances on the other node",
            "        self._create_vm(self.node_name2, num_instances=2)",
            "        self._create_vm(self.node_name2, num_instances=3)",
            "        node1_vmops = self.conn._get_vmops_for_compute_node(self.node_name)",
            "        node2_vmops = self.conn._get_vmops_for_compute_node(self.node_name2)",
            "        self.assertEqual(1, len(node1_vmops.list_instances()))",
            "        self.assertEqual(2, len(node2_vmops.list_instances()))",
            "        self.assertEqual(3, len(self.conn.list_instances()))",
            "",
            "    def _setup_mocks_for_session(self, mock_init):",
            "        mock_init.return_value = None",
            "",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        return vcdriver",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_init_host_and_cleanup_host(self, mock_init):",
            "        vcdriver = self._setup_mocks_for_session(mock_init)",
            "        vcdriver.init_host(\"foo\")",
            "        vcdriver._session._create_session.assert_called_once()",
            "",
            "        vcdriver.cleanup_host(\"foo\")",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once()",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.LOG')",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_with_no_login(self, mock_init, mock_logger):",
            "        vcdriver = self._setup_mocks_for_session(mock_init)",
            "        vcdriver.init_host(\"foo\")",
            "        vcdriver._session._create_session.assert_called_once()",
            "",
            "        # Not logged in...",
            "        # observe that no exceptions were thrown",
            "        mock_sc = mock.Mock()",
            "        vcdriver._session.vim.retrieve_service_content.return_value = mock_sc",
            "        web_fault = suds.WebFault(mock.Mock(), mock.Mock())",
            "        vcdriver._session.vim.client.service.Logout.side_effect = web_fault",
            "        vcdriver.cleanup_host(\"foo\")",
            "",
            "        # assert that the mock Logout method was never called",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once()",
            "        mock_logger.debug.assert_called_once()",
            "",
            "    def test_host_power_action(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_power_action, 'host', 'action')",
            "",
            "    def test_host_maintenance_mode(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_maintenance_mode, 'host', 'mode')",
            "",
            "    def test_set_host_enabled(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.set_host_enabled, 'host', 'state')",
            "",
            "    def test_datastore_regex_configured(self):",
            "        for node in self.conn._resources.keys():",
            "            self.assertEqual(self.conn._datastore_regex,",
            "                    self.conn._resources[node]['vmops']._datastore_regex)",
            "",
            "    def test_get_available_resource(self):",
            "        stats = self.conn.get_available_resource(self.node_name)",
            "        cpu_info = {\"model\": [\"Intel(R) Xeon(R)\", \"Intel(R) Xeon(R)\"],",
            "                    \"vendor\": [\"Intel\", \"Intel\"],",
            "                    \"topology\": {\"cores\": 16,",
            "                                 \"threads\": 32}}",
            "        self.assertEqual(stats['vcpus'], 32)",
            "        self.assertEqual(stats['local_gb'], 1024)",
            "        self.assertEqual(stats['local_gb_used'], 1024 - 500)",
            "        self.assertEqual(stats['memory_mb'], 1000)",
            "        self.assertEqual(stats['memory_mb_used'], 500)",
            "        self.assertEqual(stats['hypervisor_type'], 'VMware vCenter Server')",
            "        self.assertEqual(stats['hypervisor_version'], 5001000)",
            "        self.assertEqual(stats['hypervisor_hostname'], self.node_name)",
            "        self.assertEqual(stats['cpu_info'], jsonutils.dumps(cpu_info))",
            "        self.assertEqual(stats['supported_instances'],",
            "                '[[\"i686\", \"vmware\", \"hvm\"], [\"x86_64\", \"vmware\", \"hvm\"]]')",
            "",
            "    def test_invalid_datastore_regex(self):",
            "",
            "        # Tests if we raise an exception for Invalid Regular Expression in",
            "        # vmware_datastore_regex",
            "        self.flags(cluster_name=['test_cluster'], datastore_regex='fake-ds(01',",
            "                   group='vmware')",
            "        self.assertRaises(exception.InvalidInput, driver.VMwareVCDriver, None)",
            "",
            "    def test_get_available_nodes(self):",
            "        nodelist = self.conn.get_available_nodes()",
            "        self.assertEqual(len(nodelist), 2)",
            "        self.assertIn(self.node_name, nodelist)",
            "        self.assertIn(self.node_name2, nodelist)",
            "",
            "    def test_spawn_multiple_node(self):",
            "",
            "        def fake_is_neutron():",
            "            return False",
            "",
            "        self.stubs.Set(nova_utils, 'is_neutron', fake_is_neutron)",
            "        uuid1 = uuidutils.generate_uuid()",
            "        uuid2 = uuidutils.generate_uuid()",
            "        self._create_vm(node=self.node_name, num_instances=1,",
            "                        uuid=uuid1)",
            "        info = self.conn.get_info({'uuid': uuid1,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        self._create_vm(node=self.node_name2, num_instances=1,",
            "                        uuid=uuid2)",
            "        info = self.conn.get_info({'uuid': uuid2,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(power_on=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(power_on=False)",
            "        self.assertEqual(False, self.power_on_called)",
            "",
            "    def test_finish_migration_power_on_resize(self):",
            "        self._test_finish_migration(power_on=True,",
            "                                    resize_instance=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(power_on=True)",
            "        self.assertEqual(True, self.power_on_called)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(power_on=False)",
            "        self.assertEqual(False, self.power_on_called)",
            "",
            "    def test_snapshot(self):",
            "        # Ensure VMwareVCVMOps's get_copy_virtual_disk_spec is getting called",
            "        # two times",
            "        self.mox.StubOutWithMock(vmops.VMwareVCVMOps,",
            "                                 'get_copy_virtual_disk_spec')",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_using_file_manager(self):",
            "        self._create_vm()",
            "        uuid_str = uuidutils.generate_uuid()",
            "        self.mox.StubOutWithMock(uuidutils,",
            "                                 'generate_uuid')",
            "        uuidutils.generate_uuid().AndReturn(uuid_str)",
            "",
            "        self.mox.StubOutWithMock(ds_util, 'file_delete')",
            "        # Check calls for delete vmdk and -flat.vmdk pair",
            "        ds_util.file_delete(mox.IgnoreArg(),",
            "                \"[%s] vmware_temp/%s-flat.vmdk\" % (self.ds, uuid_str),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        ds_util.file_delete(mox.IgnoreArg(),",
            "                \"[%s] vmware_temp/%s.vmdk\" % (self.ds, uuid_str),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._test_snapshot()",
            "",
            "    def test_spawn_invalid_node(self):",
            "        self._create_instance(node='InvalidNodeName')",
            "        self.assertRaises(exception.NotFound, self.conn.spawn,",
            "                          self.context, self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    def test_spawn_with_sparse_image(self):",
            "        # Only a sparse disk image triggers the copy",
            "        self.mox.StubOutWithMock(vmware_images, 'get_vmdk_size_and_properties')",
            "        result = [1024, {\"vmware_ostype\": \"otherGuest\",",
            "                         \"vmware_adaptertype\": \"lsiLogic\",",
            "                         \"vmware_disktype\": \"sparse\"}]",
            "        vmware_images.get_vmdk_size_and_properties(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(result)",
            "",
            "        # Ensure VMwareVCVMOps's get_copy_virtual_disk_spec is getting called",
            "        # two times",
            "        self.mox.StubOutWithMock(vmops.VMwareVCVMOps,",
            "                                 'get_copy_virtual_disk_spec')",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        self.conn._vmops.get_copy_virtual_disk_spec(",
            "                mox.IgnoreArg(), mox.IgnoreArg(),",
            "                mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_plug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.plug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_unplug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.unplug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        def fake_update_instance_progress(context, instance, step,",
            "                                          total_steps):",
            "            pass",
            "",
            "        def fake_get_host_ref_from_name(dest):",
            "            return None",
            "",
            "        self._create_vm()",
            "        vm_ref_orig = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        flavor = {'name': 'fake', 'flavorid': 'fake_id'}",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_update_instance_progress)",
            "        self.stubs.Set(self.conn._vmops, \"_get_host_ref_from_name\",",
            "                       fake_get_host_ref_from_name)",
            "        self.conn.migrate_disk_and_power_off(self.context, self.instance,",
            "                                             'fake_dest', flavor,",
            "                                             None)",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref_orig.value, vm_ref.value,",
            "                             \"These should be different\")",
            "",
            "    def test_disassociate_vmref_from_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                        self.instance, vm_ref, \"-backup\")",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "",
            "    def test_clone_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        host_ref = vmwareapi_fake._get_object_refs(\"HostSystem\")[0]",
            "        ds_ref = vmwareapi_fake._get_object_refs(\"Datastore\")[0]",
            "        dc_obj = vmwareapi_fake._get_objects(\"Datacenter\").objects[0]",
            "        vm_util.clone_vmref_for_instance(self.conn._session, self.instance,",
            "                                         vm_ref, host_ref, ds_ref,",
            "                                         dc_obj.get(\"vmFolder\"))",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "        cloned_vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref.value, cloned_vm_ref.value,",
            "                            \"Reference for the cloned VM should be different\")",
            "        vm_obj = vmwareapi_fake._get_vm_mdo(vm_ref)",
            "        cloned_vm_obj = vmwareapi_fake._get_vm_mdo(cloned_vm_ref)",
            "        self.assertEqual(vm_obj.name, self.instance['uuid'] + \"-backup\",",
            "                       \"Original VM name should be with suffix -backup\")",
            "        self.assertEqual(cloned_vm_obj.name, self.instance['uuid'],",
            "                       \"VM name does not match instance['uuid']\")",
            "        self.assertRaises(error_util.MissingParameter,",
            "                          vm_util.clone_vmref_for_instance, self.conn._session,",
            "                          self.instance, None, host_ref, ds_ref,",
            "                          dc_obj.get(\"vmFolder\"))",
            "",
            "    def test_associate_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        # First disassociate the VM from the instance so that we have a VM",
            "        # to later associate using the associate_vmref_for_instance method",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        # Ensure that the VM is indeed disassociated and that we cannot find",
            "        # the VM using the get_vm_ref method",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "        # Associate the VM back to the instance",
            "        vm_util.associate_vmref_for_instance(self.conn._session, self.instance,",
            "                                             suffix=\"-backup\")",
            "        # Verify if we can get the VM reference",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.conn.confirm_migration(self.context, self.instance, None)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk(vc_support=True)",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False, vc_support=True)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareVCDriver does not implement the pause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.pause, self.instance)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareVCDriver does not implement the unpause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          self.instance)",
            "",
            "    def test_datastore_dc_map(self):",
            "        vmops = self.conn._resources[self.node_name]['vmops']",
            "        self.assertEqual({}, vmops._datastore_dc_mapping)",
            "        self._create_vm()",
            "        # currently there are 2 data stores",
            "        self.assertEqual(2, len(vmops._datastore_dc_mapping))",
            "",
            "    def test_rollback_live_migration_at_destination(self):",
            "        with mock.patch.object(self.conn, \"destroy\") as mock_destroy:",
            "            self.conn.rollback_live_migration_at_destination(self.context,",
            "                    \"instance\", [], None)",
            "            mock_destroy.assert_called_once_with(self.context,",
            "                    \"instance\", [], None)",
            "",
            "    def test_get_instance_disk_info_is_implemented(self):",
            "        # Ensure that the method has been implemented in the driver",
            "        try:",
            "            disk_info = self.conn.get_instance_disk_info('fake_instance_name')",
            "            self.assertIsNone(disk_info)",
            "        except NotImplementedError:",
            "            self.fail(\"test_get_instance_disk_info() should not raise \"",
            "                      \"NotImplementedError\")",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        # Overwrite the vmPathName",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        vm = vms.objects[0]",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.network_info,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.virt.vmwareapi.test_driver_api.VMwareAPIVMTestCase.self",
            "omeroweb.webclient.views"
        ]
    },
    "nova/virt/vmwareapi/vmops.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1129,
                "afterPatchRowNumber": 1129,
                "PatchRowcode": "                 self._destroy_instance(instance, network_info,"
            },
            "1": {
                "beforePatchRowNumber": 1130,
                "afterPatchRowNumber": 1130,
                "PatchRowcode": "                                        destroy_disks=destroy_disks,"
            },
            "2": {
                "beforePatchRowNumber": 1131,
                "afterPatchRowNumber": 1131,
                "PatchRowcode": "                                        instance_name=rescue_name)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1132,
                "PatchRowcode": "+        # NOTE(arnaud): Destroy uuid-orig and uuid VMs iff it is not"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1133,
                "PatchRowcode": "+        # triggered by the revert resize api call. This prevents"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "+        # the uuid-orig VM to be deleted to be able to associate it later."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "+        if instance['task_state'] != task_states.RESIZE_REVERTING:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "+            # When VM deletion is triggered in middle of VM resize before VM"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "+            # arrive RESIZED state, uuid-orig VM need to deleted to avoid"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "+            # VM leak. Within method _destroy_instance it will check vmref"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "+            # exist or not before attempt deletion."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "+            resize_orig_vmname = instance['uuid'] + self._migrate_suffix"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "+            vm_orig_ref = vm_util.get_vm_ref_from_name(self._session,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "+                                                       resize_orig_vmname)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1143,
                "PatchRowcode": "+            if vm_orig_ref:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1144,
                "PatchRowcode": "+                self._destroy_instance(instance, network_info,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1145,
                "PatchRowcode": "+                                       destroy_disks=destroy_disks,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1146,
                "PatchRowcode": "+                                       instance_name=resize_orig_vmname)"
            },
            "18": {
                "beforePatchRowNumber": 1132,
                "afterPatchRowNumber": 1147,
                "PatchRowcode": "         self._destroy_instance(instance, network_info,"
            },
            "19": {
                "beforePatchRowNumber": 1133,
                "afterPatchRowNumber": 1148,
                "PatchRowcode": "                                destroy_disks=destroy_disks)"
            },
            "20": {
                "beforePatchRowNumber": 1134,
                "afterPatchRowNumber": 1149,
                "PatchRowcode": "         LOG.debug(_(\"Instance destroyed\"), instance=instance)"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Class for VM tasks like spawn, snapshot, suspend, resume etc.",
            "\"\"\"",
            "",
            "import collections",
            "import copy",
            "import os",
            "",
            "from oslo.config import cfg",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import compute",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.openstack.common import excutils",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import lockutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "from nova.virt import configdrive",
            "from nova.virt import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif as vmwarevif",
            "from nova.virt.vmwareapi import vim",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmware_images",
            "",
            "",
            "vmware_vif_opts = [",
            "    cfg.StrOpt('integration_bridge',",
            "               default='br-int',",
            "               help='Name of Integration Bridge'),",
            "    ]",
            "",
            "vmware_group = cfg.OptGroup(name='vmware',",
            "                            title='VMware Options')",
            "",
            "CONF = cfg.CONF",
            "CONF.register_group(vmware_group)",
            "CONF.register_opts(vmware_vif_opts, vmware_group)",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('remove_unused_base_images', 'nova.virt.imagecache')",
            "CONF.import_opt('vnc_enabled', 'nova.vnc')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VMWARE_POWER_STATES = {",
            "                   'poweredOff': power_state.SHUTDOWN,",
            "                    'poweredOn': power_state.RUNNING,",
            "                    'suspended': power_state.SUSPENDED}",
            "",
            "VMWARE_LINKED_CLONE = 'vmware_linked_clone'",
            "",
            "RESIZE_TOTAL_STEPS = 4",
            "",
            "DcInfo = collections.namedtuple('DcInfo',",
            "                                ['ref', 'name', 'vmFolder'])",
            "",
            "",
            "class VMwareVMOps(object):",
            "    \"\"\"Management class for VM-related tasks.\"\"\"",
            "",
            "    def __init__(self, session, virtapi, volumeops, cluster=None,",
            "                 datastore_regex=None):",
            "        \"\"\"Initializer.\"\"\"",
            "        self.compute_api = compute.API()",
            "        self._session = session",
            "        self._virtapi = virtapi",
            "        self._volumeops = volumeops",
            "        self._cluster = cluster",
            "        self._datastore_regex = datastore_regex",
            "        # Ensure that the base folder is unique per compute node",
            "        if CONF.remove_unused_base_images:",
            "            self._base_folder = '%s%s' % (CONF.my_ip,",
            "                                          CONF.image_cache_subdirectory_name)",
            "        else:",
            "            # Aging disable ensures backward compatibility",
            "            self._base_folder = CONF.image_cache_subdirectory_name",
            "        self._tmp_folder = 'vmware_temp'",
            "        self._default_root_device = 'vda'",
            "        self._rescue_suffix = '-rescue'",
            "        self._migrate_suffix = '-orig'",
            "        self._poll_rescue_last_ran = None",
            "        self._is_neutron = utils.is_neutron()",
            "        self._datastore_dc_mapping = {}",
            "        self._datastore_browser_mapping = {}",
            "        self._imagecache = imagecache.ImageCacheManager(self._session,",
            "                                                        self._base_folder)",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with the ESX host.\"\"\"",
            "        LOG.debug(_(\"Getting list of instances\"))",
            "        vms = self._session._call_method(vim_util, \"get_objects\",",
            "                     \"VirtualMachine\",",
            "                     [\"name\", \"runtime.connectionState\"])",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(_(\"Got total of %s instances\") % str(len(lst_vm_names)))",
            "        return lst_vm_names",
            "",
            "    def _extend_virtual_disk(self, instance, requested_size, name, dc_ref):",
            "        service_content = self._session._get_vim().get_service_content()",
            "        LOG.debug(_(\"Extending root virtual disk to %s\"), requested_size)",
            "        vmdk_extend_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"ExtendVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=name,",
            "                datacenter=dc_ref,",
            "                newCapacityKb=requested_size,",
            "                eagerZero=False)",
            "        try:",
            "            self._session._wait_for_task(vmdk_extend_task)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Extending virtual disk failed with error: %s'),",
            "                          e, instance=instance)",
            "                # Clean up files created during the extend operation",
            "                files = [name.replace(\".vmdk\", \"-flat.vmdk\"), name]",
            "                for file in files:",
            "                    self._delete_datastore_file(instance, file, dc_ref)",
            "",
            "        LOG.debug(_(\"Extended root virtual disk\"))",
            "",
            "    def _delete_datastore_file(self, instance, datastore_path, dc_ref):",
            "        try:",
            "            ds_util.file_delete(self._session, datastore_path, dc_ref)",
            "        except (error_util.CannotDeleteFileException,",
            "                error_util.FileFaultException,",
            "                error_util.FileLockedException,",
            "                error_util.FileNotFoundException) as e:",
            "            LOG.debug(_(\"Unable to delete %(ds)s. There may be more than \"",
            "                        \"one process or thread that tries to delete the file. \"",
            "                        \"Exception: %(ex)s\"),",
            "                      {'ds': datastore_path, 'ex': e})",
            "",
            "    def _get_vmdk_path(self, ds_name, folder, name):",
            "        path = \"%s/%s.vmdk\" % (folder, name)",
            "        return ds_util.build_datastore_path(ds_name, path)",
            "",
            "    def _get_disk_format(self, image_meta):",
            "        disk_format = image_meta.get('disk_format')",
            "        if disk_format not in ['iso', 'vmdk', None]:",
            "            raise exception.InvalidDiskFormat(disk_format=disk_format)",
            "        return (disk_format, disk_format == 'iso')",
            "",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info, block_device_info=None,",
            "              instance_name=None, power_on=True):",
            "        \"\"\"Creates a VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Create a VM with no disk and the specifics in the instance object",
            "           like RAM size.",
            "        2. For flat disk",
            "          2.1. Create a dummy vmdk of the size of the disk file that is to be",
            "               uploaded. This is required just to create the metadata file.",
            "          2.2. Delete the -flat.vmdk file created in the above step and retain",
            "               the metadata .vmdk file.",
            "          2.3. Upload the disk file.",
            "        3. For sparse disk",
            "          3.1. Upload the disk file to a -sparse.vmdk file.",
            "          3.2. Copy/Clone the -sparse.vmdk file to a thin vmdk.",
            "          3.3. Delete the -sparse.vmdk file.",
            "        4. Attach the disk to the VM by reconfiguring the same.",
            "        5. Power on the VM.",
            "        \"\"\"",
            "        ebs_root = False",
            "        if block_device_info:",
            "            msg = \"Block device information present: %s\" % block_device_info",
            "            # NOTE(mriedem): block_device_info can contain an auth_password",
            "            # so we have to scrub the message before logging it.",
            "            LOG.debug(logging.mask_password(msg), instance=instance)",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                    block_device_info)",
            "            if block_device_mapping:",
            "                ebs_root = True",
            "",
            "        (file_type, is_iso) = self._get_disk_format(image_meta)",
            "",
            "        client_factory = self._session._get_vim().client.factory",
            "        service_content = self._session._get_vim().get_service_content()",
            "        ds = vm_util.get_datastore_ref_and_name(self._session, self._cluster,",
            "                 datastore_regex=self._datastore_regex)",
            "        data_store_ref = ds[0]",
            "        data_store_name = ds[1]",
            "        dc_info = self.get_datacenter_ref_and_name(data_store_ref)",
            "",
            "        #TODO(hartsocks): this pattern is confusing, reimplement as methods",
            "        # The use of nested functions in this file makes for a confusing and",
            "        # hard to maintain file. At some future date, refactor this method to",
            "        # be a full-fledged method. This will also make unit testing easier.",
            "        def _get_image_properties(root_size):",
            "            \"\"\"Get the Size of the flat vmdk file that is there on the storage",
            "            repository.",
            "            \"\"\"",
            "            image_ref = instance.get('image_ref')",
            "            if image_ref:",
            "                _image_info = vmware_images.get_vmdk_size_and_properties(",
            "                        context, image_ref, instance)",
            "            else:",
            "                # The case that the image may be booted from a volume",
            "                _image_info = (root_size, {})",
            "",
            "            image_size, image_properties = _image_info",
            "            vmdk_file_size_in_kb = int(image_size) / 1024",
            "            os_type = image_properties.get(\"vmware_ostype\", \"otherGuest\")",
            "            adapter_type = image_properties.get(\"vmware_adaptertype\",",
            "                                                \"lsiLogic\")",
            "            disk_type = image_properties.get(\"vmware_disktype\",",
            "                                             \"preallocated\")",
            "            # Get the network card type from the image properties.",
            "            vif_model = image_properties.get(\"hw_vif_model\", \"VirtualE1000\")",
            "",
            "            # Fetch the image_linked_clone data here. It is retrieved",
            "            # with the above network based API call. To retrieve it",
            "            # later will necessitate additional network calls using the",
            "            # identical method. Consider this a cache.",
            "            image_linked_clone = image_properties.get(VMWARE_LINKED_CLONE)",
            "",
            "            return (vmdk_file_size_in_kb, os_type, adapter_type, disk_type,",
            "                vif_model, image_linked_clone)",
            "",
            "        root_gb = instance['root_gb']",
            "        root_gb_in_kb = root_gb * units.Mi",
            "",
            "        (vmdk_file_size_in_kb, os_type, adapter_type, disk_type, vif_model,",
            "            image_linked_clone) = _get_image_properties(root_gb_in_kb)",
            "",
            "        if root_gb_in_kb and vmdk_file_size_in_kb > root_gb_in_kb:",
            "            reason = _(\"Image disk size greater than requested disk size\")",
            "            raise exception.InstanceUnacceptable(instance_id=instance['uuid'],",
            "                                                 reason=reason)",
            "",
            "        node_mo_id = vm_util.get_mo_id_from_instance(instance)",
            "        res_pool_ref = vm_util.get_res_pool_ref(self._session,",
            "                                                self._cluster, node_mo_id)",
            "",
            "        def _get_vif_infos():",
            "            vif_infos = []",
            "            if network_info is None:",
            "                return vif_infos",
            "            for vif in network_info:",
            "                mac_address = vif['address']",
            "                network_name = vif['network']['bridge'] or \\",
            "                               CONF.vmware.integration_bridge",
            "                network_ref = vmwarevif.get_network_ref(self._session,",
            "                                                        self._cluster,",
            "                                                        vif,",
            "                                                        self._is_neutron)",
            "                vif_infos.append({'network_name': network_name,",
            "                                  'mac_address': mac_address,",
            "                                  'network_ref': network_ref,",
            "                                  'iface_id': vif['id'],",
            "                                  'vif_model': vif_model",
            "                                 })",
            "            return vif_infos",
            "",
            "        vif_infos = _get_vif_infos()",
            "",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if not instance_name:",
            "            instance_name = instance['uuid']",
            "        # Get the create vm config spec",
            "        config_spec = vm_util.get_vm_create_spec(",
            "                            client_factory, instance, instance_name,",
            "                            data_store_name, vif_infos, os_type)",
            "",
            "        def _execute_create_vm():",
            "            \"\"\"Create VM on ESX host.\"\"\"",
            "            LOG.debug(_(\"Creating VM on the ESX host\"), instance=instance)",
            "            # Create the VM on the ESX host",
            "            vm_create_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"CreateVM_Task\", dc_info.vmFolder,",
            "                                    config=config_spec, pool=res_pool_ref)",
            "            self._session._wait_for_task(vm_create_task)",
            "",
            "            LOG.debug(_(\"Created VM on the ESX host\"), instance=instance)",
            "",
            "        _execute_create_vm()",
            "",
            "        # In the case of a rescue disk the instance_name is not the same as",
            "        # instance UUID. In this case the VM reference is accessed via the",
            "        # instance name.",
            "        if instance_name != instance['uuid']:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                  instance_name)",
            "        else:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        if CONF.flat_injected:",
            "            self._set_machine_id(client_factory, instance, network_info)",
            "",
            "        # Set the vnc configuration of the instance, vnc port starts from 5900",
            "        if CONF.vnc_enabled:",
            "            vnc_port = vm_util.get_vnc_port(self._session)",
            "            self._set_vnc_config(client_factory, instance, vnc_port)",
            "",
            "        def _create_virtual_disk(virtual_disk_path, file_size_in_kb):",
            "            \"\"\"Create a virtual disk of the size of flat vmdk file.\"\"\"",
            "            # Create a Virtual Disk of the size of the flat vmdk file. This is",
            "            # done just to generate the meta-data file whose specifics",
            "            # depend on the size of the disk, thin/thick provisioning and the",
            "            # storage adapter type.",
            "            # Here we assume thick provisioning and lsiLogic for the adapter",
            "            # type",
            "            LOG.debug(_(\"Creating Virtual Disk of size  \"",
            "                      \"%(vmdk_file_size_in_kb)s KB and adapter type \"",
            "                      \"%(adapter_type)s on the ESX host local store \"",
            "                      \"%(data_store_name)s\"),",
            "                       {\"vmdk_file_size_in_kb\": file_size_in_kb,",
            "                        \"adapter_type\": adapter_type,",
            "                        \"data_store_name\": data_store_name},",
            "                      instance=instance)",
            "            vmdk_create_spec = vm_util.get_vmdk_create_spec(client_factory,",
            "                                    file_size_in_kb, adapter_type,",
            "                                    disk_type)",
            "            vmdk_create_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CreateVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=virtual_disk_path,",
            "                datacenter=dc_info.ref,",
            "                spec=vmdk_create_spec)",
            "            self._session._wait_for_task(vmdk_create_task)",
            "            LOG.debug(_(\"Created Virtual Disk of size %(vmdk_file_size_in_kb)s\"",
            "                        \" KB and type %(disk_type)s on \"",
            "                        \"the ESX host local store %(data_store_name)s\") %",
            "                        {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                         \"disk_type\": disk_type,",
            "                         \"data_store_name\": data_store_name},",
            "                      instance=instance)",
            "",
            "        def _fetch_image_on_datastore(upload_name):",
            "            \"\"\"Fetch image from Glance to datastore.\"\"\"",
            "            LOG.debug(_(\"Downloading image file data %(image_ref)s to the \"",
            "                        \"data store %(data_store_name)s\") %",
            "                        {'image_ref': instance['image_ref'],",
            "                         'data_store_name': data_store_name},",
            "                      instance=instance)",
            "            vmware_images.fetch_image(",
            "                context,",
            "                instance['image_ref'],",
            "                instance,",
            "                host=self._session._host_ip,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=data_store_name,",
            "                cookies=cookies,",
            "                file_path=upload_name)",
            "            LOG.debug(_(\"Downloaded image file data %(image_ref)s to \"",
            "                        \"%(upload_name)s on the data store \"",
            "                        \"%(data_store_name)s\") %",
            "                        {'image_ref': instance['image_ref'],",
            "                         'upload_name': upload_name,",
            "                         'data_store_name': data_store_name},",
            "                      instance=instance)",
            "",
            "        def _copy_virtual_disk(source, dest):",
            "            \"\"\"Copy a sparse virtual disk to a thin virtual disk.\"\"\"",
            "            # Copy a sparse virtual disk to a thin virtual disk. This is also",
            "            # done to generate the meta-data file whose specifics",
            "            # depend on the size of the disk, thin/thick provisioning and the",
            "            # storage adapter type.",
            "            LOG.debug(_(\"Copying Virtual Disk of size \"",
            "                      \"%(vmdk_file_size_in_kb)s KB and adapter type \"",
            "                      \"%(adapter_type)s on the ESX host local store \"",
            "                      \"%(data_store_name)s to disk type %(disk_type)s\") %",
            "                       {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                        \"adapter_type\": adapter_type,",
            "                        \"data_store_name\": data_store_name,",
            "                        \"disk_type\": disk_type},",
            "                      instance=instance)",
            "            vmdk_copy_spec = self.get_copy_virtual_disk_spec(client_factory,",
            "                                                             adapter_type,",
            "                                                             disk_type)",
            "            vmdk_copy_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=source,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=dest,",
            "                destSpec=vmdk_copy_spec)",
            "            self._session._wait_for_task(vmdk_copy_task)",
            "            LOG.debug(_(\"Copied Virtual Disk of size %(vmdk_file_size_in_kb)s\"",
            "                        \" KB and type %(disk_type)s on \"",
            "                        \"the ESX host local store %(data_store_name)s\") %",
            "                        {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                         \"disk_type\": disk_type,",
            "                         \"data_store_name\": data_store_name},",
            "                        instance=instance)",
            "",
            "        if not ebs_root:",
            "            # this logic allows for instances or images to decide",
            "            # for themselves which strategy is best for them.",
            "",
            "            linked_clone = VMwareVMOps.decide_linked_clone(",
            "                image_linked_clone,",
            "                CONF.vmware.use_linked_clone",
            "            )",
            "            upload_name = instance['image_ref']",
            "            upload_folder = '%s/%s' % (self._base_folder, upload_name)",
            "",
            "            # The vmdk meta-data file",
            "            uploaded_file_name = \"%s/%s.%s\" % (upload_folder, upload_name,",
            "                                               file_type)",
            "            uploaded_file_path = ds_util.build_datastore_path(data_store_name,",
            "                                                uploaded_file_name)",
            "",
            "            session_vim = self._session._get_vim()",
            "            cookies = session_vim.client.options.transport.cookiejar",
            "",
            "            ds_browser = self._get_ds_browser(data_store_ref)",
            "            upload_file_name = upload_name + \".%s\" % file_type",
            "",
            "            # Check if the timestamp file exists - if so then delete it. This",
            "            # will ensure that the aging will not delete a cache image if it",
            "            # is going to be used now.",
            "            if CONF.remove_unused_base_images:",
            "                ds_path = ds_util.build_datastore_path(data_store_name,",
            "                                                       self._base_folder)",
            "                path = self._imagecache.timestamp_folder_get(ds_path,",
            "                                                             upload_name)",
            "                # Lock to ensure that the spawn will not try and access a image",
            "                # that is currently being deleted on the datastore.",
            "                with lockutils.lock(path, lock_file_prefix='nova-vmware-ts',",
            "                                    external=True):",
            "                    self._imagecache.timestamp_cleanup(dc_info.ref, ds_browser,",
            "                            data_store_ref, data_store_name, path)",
            "",
            "            # Check if the image exists in the datastore cache. If not the",
            "            # image will be uploaded and cached.",
            "            if not (self._check_if_folder_file_exists(ds_browser,",
            "                                        data_store_ref, data_store_name,",
            "                                        upload_folder, upload_file_name)):",
            "                # Upload will be done to the self._tmp_folder and then moved",
            "                # to the self._base_folder",
            "                tmp_upload_folder = '%s/%s' % (self._tmp_folder,",
            "                                               uuidutils.generate_uuid())",
            "                upload_folder = '%s/%s' % (tmp_upload_folder, upload_name)",
            "",
            "                # Naming the VM files in correspondence with the VM instance",
            "                # The flat vmdk file name",
            "                flat_uploaded_vmdk_name = \"%s/%s-flat.vmdk\" % (",
            "                                            upload_folder, upload_name)",
            "                # The sparse vmdk file name for sparse disk image",
            "                sparse_uploaded_vmdk_name = \"%s/%s-sparse.vmdk\" % (",
            "                                            upload_folder, upload_name)",
            "",
            "                flat_uploaded_vmdk_path = ds_util.build_datastore_path(",
            "                                                    data_store_name,",
            "                                                    flat_uploaded_vmdk_name)",
            "                sparse_uploaded_vmdk_path = ds_util.build_datastore_path(",
            "                                                    data_store_name,",
            "                                                    sparse_uploaded_vmdk_name)",
            "",
            "                upload_file_name = \"%s/%s.%s\" % (upload_folder, upload_name,",
            "                                                 file_type)",
            "                upload_path = ds_util.build_datastore_path(data_store_name,",
            "                                                           upload_file_name)",
            "                if not is_iso:",
            "                    if disk_type != \"sparse\":",
            "                        # Create a flat virtual disk and retain the metadata",
            "                        # file. This will be done in the unique temporary",
            "                        # directory.",
            "                        ds_util.mkdir(self._session,",
            "                                      ds_util.build_datastore_path(",
            "                                          data_store_name, upload_folder),",
            "                                      dc_info.ref)",
            "                        _create_virtual_disk(upload_path,",
            "                                             vmdk_file_size_in_kb)",
            "                        self._delete_datastore_file(instance,",
            "                                                    flat_uploaded_vmdk_path,",
            "                                                    dc_info.ref)",
            "                        upload_file_name = flat_uploaded_vmdk_name",
            "                    else:",
            "                        upload_file_name = sparse_uploaded_vmdk_name",
            "",
            "                _fetch_image_on_datastore(upload_file_name)",
            "",
            "                if not is_iso and disk_type == \"sparse\":",
            "                    # Copy the sparse virtual disk to a thin virtual disk.",
            "                    disk_type = \"thin\"",
            "                    _copy_virtual_disk(sparse_uploaded_vmdk_path, upload_path)",
            "                    self._delete_datastore_file(instance,",
            "                                                sparse_uploaded_vmdk_path,",
            "                                                dc_info.ref)",
            "                base_folder = '%s/%s' % (self._base_folder, upload_name)",
            "                dest_folder = ds_util.build_datastore_path(data_store_name,",
            "                                                           base_folder)",
            "                src_folder = ds_util.build_datastore_path(data_store_name,",
            "                                                          upload_folder)",
            "                try:",
            "                    ds_util.file_move(self._session, dc_info.ref,",
            "                                      src_folder, dest_folder)",
            "                except error_util.FileAlreadyExistsException:",
            "                    # File move has failed. This may be due to the fact that a",
            "                    # process or thread has already completed the opertaion.",
            "                    # In the event of a FileAlreadyExists we continue,",
            "                    # all other exceptions will be raised.",
            "                    LOG.debug(_(\"File %s already exists\"), dest_folder)",
            "",
            "                # Delete the temp upload folder",
            "                self._delete_datastore_file(instance,",
            "                        ds_util.build_datastore_path(data_store_name,",
            "                                                     tmp_upload_folder),",
            "                        dc_info.ref)",
            "            else:",
            "                # linked clone base disk exists",
            "                if disk_type == \"sparse\":",
            "                    disk_type = \"thin\"",
            "",
            "            if is_iso:",
            "                if root_gb_in_kb:",
            "                    dest_vmdk_path = self._get_vmdk_path(data_store_name,",
            "                            instance['uuid'], instance_name)",
            "                    # Create the blank virtual disk for the VM",
            "                    _create_virtual_disk(dest_vmdk_path, root_gb_in_kb)",
            "                    root_vmdk_path = dest_vmdk_path",
            "                else:",
            "                    root_vmdk_path = None",
            "            else:",
            "                # Extend the disk size if necessary",
            "                if not linked_clone:",
            "                    # If we are not using linked_clone, copy the image from",
            "                    # the cache into the instance directory.  If we are using",
            "                    # linked clone it is references from the cache directory",
            "                    dest_vmdk_path = self._get_vmdk_path(data_store_name,",
            "                            instance_name, instance_name)",
            "                    _copy_virtual_disk(uploaded_file_path, dest_vmdk_path)",
            "",
            "                    root_vmdk_path = dest_vmdk_path",
            "                    if root_gb_in_kb > vmdk_file_size_in_kb:",
            "                        self._extend_virtual_disk(instance, root_gb_in_kb,",
            "                                                  root_vmdk_path, dc_info.ref)",
            "                else:",
            "                    upload_folder = '%s/%s' % (self._base_folder, upload_name)",
            "                    if root_gb:",
            "                        root_vmdk_name = \"%s/%s.%s.vmdk\" % (upload_folder,",
            "                                                            upload_name,",
            "                                                            root_gb)",
            "                    else:",
            "                        root_vmdk_name = \"%s/%s.vmdk\" % (upload_folder,",
            "                                                         upload_name)",
            "                    root_vmdk_path = ds_util.build_datastore_path(",
            "                            data_store_name, root_vmdk_name)",
            "",
            "                    # Ensure only a single thread extends the image at once.",
            "                    # We do this by taking a lock on the name of the extended",
            "                    # image. This allows multiple threads to create resized",
            "                    # copies simultaneously, as long as they are different",
            "                    # sizes. Threads attempting to create the same resized copy",
            "                    # will be serialized, with only the first actually creating",
            "                    # the copy.",
            "                    #",
            "                    # Note that the object is in a per-nova cache directory,",
            "                    # so inter-nova locking is not a concern. Consequently we",
            "                    # can safely use simple thread locks.",
            "",
            "                    with lockutils.lock(root_vmdk_path,",
            "                                        lock_file_prefix='nova-vmware-image'):",
            "                        if not self._check_if_folder_file_exists(",
            "                                ds_browser,",
            "                                data_store_ref, data_store_name,",
            "                                upload_folder,",
            "                                upload_name + \".%s.vmdk\" % root_gb):",
            "                            LOG.debug(\"Copying root disk of size %sGb\",",
            "                                      root_gb)",
            "",
            "                            # Create a copy of the base image, ensuring we",
            "                            # clean up on failure",
            "                            try:",
            "                                _copy_virtual_disk(uploaded_file_path,",
            "                                                   root_vmdk_path)",
            "                            except Exception as e:",
            "                                with excutils.save_and_reraise_exception():",
            "                                    LOG.error(_('Failed to copy cached '",
            "                                                  'image %(source)s to '",
            "                                                  '%(dest)s for resize: '",
            "                                                  '%(error)s'),",
            "                                              {'source': uploaded_file_path,",
            "                                               'dest': root_vmdk_path,",
            "                                               'error': e.message})",
            "                                    try:",
            "                                        ds_util.file_delete(self._session,",
            "                                                            root_vmdk_path,",
            "                                                            dc_info.ref)",
            "                                    except error_util.FileNotFoundException:",
            "                                        # File was never created: cleanup not",
            "                                        # required",
            "                                        pass",
            "",
            "                            # Resize the copy to the appropriate size. No need",
            "                            # for cleanup up here, as _extend_virtual_disk",
            "                            # already does it",
            "                            if root_gb_in_kb > vmdk_file_size_in_kb:",
            "                                self._extend_virtual_disk(instance,",
            "                                                          root_gb_in_kb,",
            "                                                          root_vmdk_path,",
            "                                                          dc_info.ref)",
            "",
            "            # Attach the root disk to the VM.",
            "            if root_vmdk_path:",
            "                self._volumeops.attach_disk_to_vm(",
            "                                    vm_ref, instance,",
            "                                    adapter_type, disk_type, root_vmdk_path,",
            "                                    root_gb_in_kb, linked_clone)",
            "",
            "            if is_iso:",
            "                self._attach_cdrom_to_vm(",
            "                    vm_ref, instance,",
            "                    data_store_ref,",
            "                    uploaded_file_path)",
            "",
            "            if configdrive.required_by(instance):",
            "                uploaded_iso_path = self._create_config_drive(instance,",
            "                                                              injected_files,",
            "                                                              admin_password,",
            "                                                              data_store_name,",
            "                                                              dc_info.name,",
            "                                                              instance['uuid'],",
            "                                                              cookies)",
            "                uploaded_iso_path = ds_util.build_datastore_path(",
            "                    data_store_name,",
            "                    uploaded_iso_path)",
            "                self._attach_cdrom_to_vm(",
            "                    vm_ref, instance,",
            "                    data_store_ref,",
            "                    uploaded_iso_path)",
            "",
            "        else:",
            "            # Attach the root disk to the VM.",
            "            for root_disk in block_device_mapping:",
            "                connection_info = root_disk['connection_info']",
            "                self._volumeops.attach_root_volume(connection_info, instance,",
            "                                                   self._default_root_device,",
            "                                                   data_store_ref)",
            "",
            "        def _power_on_vm():",
            "            \"\"\"Power on the VM.\"\"\"",
            "            LOG.debug(_(\"Powering on the VM instance\"), instance=instance)",
            "            # Power On the VM",
            "            power_on_task = self._session._call_method(",
            "                               self._session._get_vim(),",
            "                               \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(power_on_task)",
            "            LOG.debug(_(\"Powered on the VM instance\"), instance=instance)",
            "",
            "        if power_on:",
            "            _power_on_vm()",
            "",
            "    def _create_config_drive(self, instance, injected_files, admin_password,",
            "                             data_store_name, dc_name, upload_folder, cookies):",
            "        if CONF.config_drive_format != 'iso9660':",
            "            reason = (_('Invalid config_drive_format \"%s\"') %",
            "                      CONF.config_drive_format)",
            "            raise exception.InstancePowerOnFailure(reason=reason)",
            "",
            "        LOG.info(_('Using config drive for instance'), instance=instance)",
            "        extra_md = {}",
            "        if admin_password:",
            "            extra_md['admin_pass'] = admin_password",
            "",
            "        inst_md = instance_metadata.InstanceMetadata(instance,",
            "                                                     content=injected_files,",
            "                                                     extra_md=extra_md)",
            "        try:",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                with utils.tempdir() as tmp_path:",
            "                    tmp_file = os.path.join(tmp_path, 'configdrive.iso')",
            "                    cdb.make_drive(tmp_file)",
            "                    upload_iso_path = \"%s/configdrive.iso\" % (",
            "                        upload_folder)",
            "                    vmware_images.upload_iso_to_datastore(",
            "                        tmp_file, instance,",
            "                        host=self._session._host_ip,",
            "                        data_center_name=dc_name,",
            "                        datastore_name=data_store_name,",
            "                        cookies=cookies,",
            "                        file_path=upload_iso_path)",
            "                    return upload_iso_path",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Creating config drive failed with error: %s'),",
            "                          e, instance=instance)",
            "",
            "    def _attach_cdrom_to_vm(self, vm_ref, instance,",
            "                         datastore, file_path):",
            "        \"\"\"Attach cdrom to VM by reconfiguration.\"\"\"",
            "        instance_name = instance['name']",
            "        instance_uuid = instance['uuid']",
            "        client_factory = self._session._get_vim().client.factory",
            "        devices = self._session._call_method(vim_util,",
            "                                    \"get_dynamic_property\", vm_ref,",
            "                                    \"VirtualMachine\", \"config.hardware.device\")",
            "        (controller_key, unit_number,",
            "         controller_spec) = vm_util.allocate_controller_key_and_unit_number(",
            "                                                              client_factory,",
            "                                                              devices,",
            "                                                              'ide')",
            "        cdrom_attach_config_spec = vm_util.get_cdrom_attach_config_spec(",
            "                                    client_factory, datastore, file_path,",
            "                                    controller_key, unit_number)",
            "        if controller_spec:",
            "            cdrom_attach_config_spec.deviceChange.append(controller_spec)",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance %(instance_name)s to attach \"",
            "                    \"cdrom %(file_path)s\"),",
            "                  {'instance_name': instance_name, 'file_path': file_path})",
            "        reconfig_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"ReconfigVM_Task\", vm_ref,",
            "                                        spec=cdrom_attach_config_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance %(instance_name)s to attach \"",
            "                    \"cdrom %(file_path)s\"),",
            "                  {'instance_name': instance_name, 'file_path': file_path})",
            "",
            "    @staticmethod",
            "    def decide_linked_clone(image_linked_clone, global_linked_clone):",
            "        \"\"\"Explicit decision logic: whether to use linked clone on a vmdk.",
            "",
            "        This is *override* logic not boolean logic.",
            "",
            "        1. let the image over-ride if set at all",
            "        2. default to the global setting",
            "",
            "        In math terms, I need to allow:",
            "        glance image to override global config.",
            "",
            "        That is g vs c. \"g\" for glance. \"c\" for Config.",
            "",
            "        So, I need  g=True vs c=False to be True.",
            "        And, I need g=False vs c=True to be False.",
            "        And, I need g=None vs c=True to be True.",
            "",
            "        Some images maybe independently best tuned for use_linked_clone=True",
            "        saving datastorage space. Alternatively a whole OpenStack install may",
            "        be tuned to performance use_linked_clone=False but a single image",
            "        in this environment may be best configured to save storage space and",
            "        set use_linked_clone=True only for itself.",
            "",
            "        The point is: let each layer of control override the layer beneath it.",
            "",
            "        rationale:",
            "        For technical discussion on the clone strategies and their trade-offs",
            "        see: https://www.vmware.com/support/ws5/doc/ws_clone_typeofclone.html",
            "",
            "        :param image_linked_clone: boolean or string or None",
            "        :param global_linked_clone: boolean or string or None",
            "        :return: Boolean",
            "        \"\"\"",
            "",
            "        value = None",
            "",
            "        # Consider the values in order of override.",
            "        if image_linked_clone is not None:",
            "            value = image_linked_clone",
            "        else:",
            "            # this will never be not-set by this point.",
            "            value = global_linked_clone",
            "",
            "        return strutils.bool_from_string(value)",
            "",
            "    def get_copy_virtual_disk_spec(self, client_factory, adapter_type,",
            "                                   disk_type):",
            "        return vm_util.get_copy_virtual_disk_spec(client_factory,",
            "                                                  adapter_type,",
            "                                                  disk_type)",
            "",
            "    def _create_vm_snapshot(self, instance, vm_ref):",
            "        LOG.debug(_(\"Creating Snapshot of the VM instance\"), instance=instance)",
            "        snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"CreateSnapshot_Task\", vm_ref,",
            "                    name=\"%s-snapshot\" % instance['uuid'],",
            "                    description=\"Taking Snapshot of the VM\",",
            "                    memory=False,",
            "                    quiesce=True)",
            "        self._session._wait_for_task(snapshot_task)",
            "        LOG.debug(_(\"Created Snapshot of the VM instance\"), instance=instance)",
            "        task_info = self._session._call_method(vim_util,",
            "                                               \"get_dynamic_property\",",
            "                                               snapshot_task, \"Task\", \"info\")",
            "        snapshot = task_info.result",
            "        return snapshot",
            "",
            "    def _delete_vm_snapshot(self, instance, vm_ref, snapshot):",
            "        LOG.debug(_(\"Deleting Snapshot of the VM instance\"), instance=instance)",
            "        delete_snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"RemoveSnapshot_Task\", snapshot,",
            "                    removeChildren=False, consolidate=True)",
            "        self._session._wait_for_task(delete_snapshot_task)",
            "        LOG.debug(_(\"Deleted Snapshot of the VM instance\"), instance=instance)",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Get the name of the vmdk file which the VM points to right now.",
            "           Can be a chain of snapshots, so we need to know the last in the",
            "           chain.",
            "        2. Create the snapshot. A new vmdk is created which the VM points to",
            "           now. The earlier vmdk becomes read-only.",
            "        3. Call CopyVirtualDisk which coalesces the disk chain to form a single",
            "           vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file.",
            "        4. Now upload the -flat.vmdk file to the image store.",
            "        5. Delete the coalesced .vmdk and -flat.vmdk created.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        client_factory = self._session._get_vim().client.factory",
            "        service_content = self._session._get_vim().get_service_content()",
            "",
            "        def _get_vm_and_vmdk_attribs():",
            "            # Get the vmdk file name that the VM is pointing to",
            "            hw_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "            (vmdk_file_path_before_snapshot, adapter_type,",
            "             disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                                        hw_devices, uuid=instance['uuid'])",
            "            if not vmdk_file_path_before_snapshot:",
            "                LOG.debug(\"No root disk defined. Unable to snapshot.\")",
            "                raise error_util.NoRootDiskDefined()",
            "",
            "            datastore_name = ds_util.split_datastore_path(",
            "                                        vmdk_file_path_before_snapshot)[0]",
            "            os_type = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"summary.config.guestId\")",
            "            return (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "                    datastore_name, os_type)",
            "",
            "        (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "         datastore_name, os_type) = _get_vm_and_vmdk_attribs()",
            "",
            "        snapshot = self._create_vm_snapshot(instance, vm_ref)",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        def _check_if_tmp_folder_exists():",
            "            # Copy the contents of the VM that were there just before the",
            "            # snapshot was taken",
            "            ds_ref_ret = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", vm_ref, \"VirtualMachine\",",
            "                \"datastore\")",
            "            if ds_ref_ret is None:",
            "                raise exception.DatastoreNotFound()",
            "            ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "            self.check_temp_folder(datastore_name, ds_ref)",
            "            return ds_ref",
            "",
            "        ds_ref = _check_if_tmp_folder_exists()",
            "",
            "        # Generate a random vmdk file name to which the coalesced vmdk content",
            "        # will be copied to. A random name is chosen so that we don't have",
            "        # name clashes.",
            "        random_name = uuidutils.generate_uuid()",
            "        dest_vmdk_file_path = ds_util.build_datastore_path(datastore_name,",
            "                   \"%s/%s.vmdk\" % (self._tmp_folder, random_name))",
            "        dest_vmdk_data_file_path = ds_util.build_datastore_path(datastore_name,",
            "                   \"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "",
            "        def _copy_vmdk_content():",
            "            # Consolidate the snapshotted disk to a temporary vmdk.",
            "            copy_spec = self.get_copy_virtual_disk_spec(client_factory,",
            "                                                        adapter_type,",
            "                                                        disk_type)",
            "            LOG.debug(_('Copying snapshotted disk %s.'),",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "            copy_disk_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=vmdk_file_path_before_snapshot,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=dest_vmdk_file_path,",
            "                destDatacenter=dc_info.ref,",
            "                destSpec=copy_spec,",
            "                force=False)",
            "            self._session._wait_for_task(copy_disk_task)",
            "            LOG.debug(_('Copied snapshotted disk %s.'),",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "",
            "        _copy_vmdk_content()",
            "        # Note(vui): handle snapshot cleanup on exceptions.",
            "        self._delete_vm_snapshot(instance, vm_ref, snapshot)",
            "",
            "        cookies = self._session._get_vim().client.options.transport.cookiejar",
            "",
            "        def _upload_vmdk_to_image_repository():",
            "            # Upload the contents of -flat.vmdk file which has the disk data.",
            "            LOG.debug(_(\"Uploading image %s\") % image_id,",
            "                      instance=instance)",
            "            vmware_images.upload_image(",
            "                context,",
            "                image_id,",
            "                instance,",
            "                os_type=os_type,",
            "                disk_type=\"preallocated\",",
            "                adapter_type=adapter_type,",
            "                image_version=1,",
            "                host=self._session._host_ip,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=datastore_name,",
            "                cookies=cookies,",
            "                file_path=\"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "            LOG.debug(_(\"Uploaded image %s\") % image_id,",
            "                      instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                          expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "        _upload_vmdk_to_image_repository()",
            "",
            "        def _clean_temp_data():",
            "            \"\"\"Delete temporary vmdk files generated in image handling",
            "            operations.",
            "            \"\"\"",
            "            # The data file is the one occupying space, and likelier to see",
            "            # deletion problems, so prioritize its deletion first. In the",
            "            # unlikely event that its deletion fails, the small descriptor file",
            "            # is retained too by design since it makes little sense to remove",
            "            # it when the data disk it refers to still lingers.",
            "            for f in dest_vmdk_data_file_path, dest_vmdk_file_path:",
            "                self._delete_datastore_file(instance, f, dc_info.ref)",
            "",
            "        _clean_temp_data()",
            "",
            "    def _get_values_from_object_properties(self, props, query):",
            "        while props:",
            "            token = vm_util._get_token(props)",
            "            for elem in props.objects:",
            "                for prop in elem.propSet:",
            "                    for key in query.keys():",
            "                        if prop.name == key:",
            "                            query[key] = prop.val",
            "                            break",
            "            if token:",
            "                props = self._session._call_method(vim_util,",
            "                                                   \"continue_to_get_objects\",",
            "                                                   token)",
            "            else:",
            "                break",
            "",
            "    def reboot(self, instance, network_info):",
            "        \"\"\"Reboot a VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.guest.toolsStatus\", \"runtime.powerState\",",
            "                          \"summary.guest.toolsRunningStatus\"]",
            "        props = self._session._call_method(vim_util, \"get_object_properties\",",
            "                           None, vm_ref, \"VirtualMachine\",",
            "                           lst_properties)",
            "        query = {'runtime.powerState': None,",
            "                 'summary.guest.toolsStatus': None,",
            "                 'summary.guest.toolsRunningStatus': False}",
            "        self._get_values_from_object_properties(props, query)",
            "        pwr_state = query['runtime.powerState']",
            "        tools_status = query['summary.guest.toolsStatus']",
            "        tools_running_status = query['summary.guest.toolsRunningStatus']",
            "",
            "        # Raise an exception if the VM is not powered On.",
            "        if pwr_state not in [\"poweredOn\"]:",
            "            reason = _(\"instance is not powered on\")",
            "            raise exception.InstanceRebootFailure(reason=reason)",
            "",
            "        # If latest vmware tools are installed in the VM, and that the tools",
            "        # are running, then only do a guest reboot. Otherwise do a hard reset.",
            "        if (tools_status == \"toolsOk\" and",
            "                tools_running_status == \"guestToolsRunning\"):",
            "            LOG.debug(_(\"Rebooting guest OS of VM\"), instance=instance)",
            "            self._session._call_method(self._session._get_vim(), \"RebootGuest\",",
            "                                       vm_ref)",
            "            LOG.debug(_(\"Rebooted guest OS of VM\"), instance=instance)",
            "        else:",
            "            LOG.debug(_(\"Doing hard reboot of VM\"), instance=instance)",
            "            reset_task = self._session._call_method(self._session._get_vim(),",
            "                                                    \"ResetVM_Task\", vm_ref)",
            "            self._session._wait_for_task(reset_task)",
            "            LOG.debug(_(\"Did hard reboot of VM\"), instance=instance)",
            "",
            "    def _delete(self, instance, network_info):",
            "        \"\"\"Destroy a VM instance. Steps followed are:",
            "        1. Power off the VM, if it is in poweredOn state.",
            "        2. Destroy the VM.",
            "        \"\"\"",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "            self.power_off(instance)",
            "            try:",
            "                LOG.debug(_(\"Destroying the VM\"), instance=instance)",
            "                destroy_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"Destroy_Task\", vm_ref)",
            "                self._session._wait_for_task(destroy_task)",
            "                LOG.debug(_(\"Destroyed the VM\"), instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:delete, got this exception\"",
            "                           \" while destroying the VM: %s\") % str(excep))",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "",
            "    def _destroy_instance(self, instance, network_info, destroy_disks=True,",
            "                          instance_name=None):",
            "        # Destroy a VM instance",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if not instance_name:",
            "            instance_name = instance['uuid']",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session, instance_name)",
            "            lst_properties = [\"config.files.vmPathName\", \"runtime.powerState\",",
            "                              \"datastore\"]",
            "            props = self._session._call_method(vim_util,",
            "                        \"get_object_properties\",",
            "                        None, vm_ref, \"VirtualMachine\", lst_properties)",
            "            query = {'runtime.powerState': None,",
            "                     'config.files.vmPathName': None,",
            "                     'datastore': None}",
            "            self._get_values_from_object_properties(props, query)",
            "            pwr_state = query['runtime.powerState']",
            "            vm_config_pathname = query['config.files.vmPathName']",
            "            datastore_name = None",
            "            if vm_config_pathname:",
            "                _ds_path = ds_util.split_datastore_path(vm_config_pathname)",
            "                datastore_name, vmx_file_path = _ds_path",
            "            # Power off the VM if it is in PoweredOn state.",
            "            if pwr_state == \"poweredOn\":",
            "                LOG.debug(_(\"Powering off the VM\"), instance=instance)",
            "                poweroff_task = self._session._call_method(",
            "                       self._session._get_vim(),",
            "                       \"PowerOffVM_Task\", vm_ref)",
            "                self._session._wait_for_task(poweroff_task)",
            "                LOG.debug(_(\"Powered off the VM\"), instance=instance)",
            "",
            "            # Un-register the VM",
            "            try:",
            "                LOG.debug(_(\"Unregistering the VM\"), instance=instance)",
            "                self._session._call_method(self._session._get_vim(),",
            "                                           \"UnregisterVM\", vm_ref)",
            "                LOG.debug(_(\"Unregistered the VM\"), instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, got this \"",
            "                           \"exception while un-registering the VM: %s\"),",
            "                         excep)",
            "            # Delete the folder holding the VM related content on",
            "            # the datastore.",
            "            if destroy_disks and datastore_name:",
            "                try:",
            "                    dir_ds_compliant_path = ds_util.build_datastore_path(",
            "                                     datastore_name,",
            "                                     os.path.dirname(vmx_file_path))",
            "                    LOG.debug(_(\"Deleting contents of the VM from \"",
            "                                \"datastore %(datastore_name)s\") %",
            "                               {'datastore_name': datastore_name},",
            "                              instance=instance)",
            "                    ds_ref_ret = query['datastore']",
            "                    ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "                    dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "                    ds_util.file_delete(self._session,",
            "                                        dir_ds_compliant_path,",
            "                                        dc_info.ref)",
            "                    LOG.debug(_(\"Deleted contents of the VM from \"",
            "                                \"datastore %(datastore_name)s\") %",
            "                               {'datastore_name': datastore_name},",
            "                              instance=instance)",
            "                except Exception as excep:",
            "                    LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, \"",
            "                                \"got this exception while deleting \"",
            "                                \"the VM contents from the disk: %s\"),",
            "                             excep)",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "        finally:",
            "            vm_util.vm_ref_cache_delete(instance_name)",
            "",
            "    def destroy(self, instance, network_info, destroy_disks=True):",
            "        \"\"\"Destroy a VM instance.",
            "",
            "        Steps followed for each VM are:",
            "        1. Power off, if it is in poweredOn state.",
            "        2. Un-register.",
            "        3. Delete the contents of the folder holding the VM related data.",
            "        \"\"\"",
            "        # If there is a rescue VM then we need to destroy that one too.",
            "        LOG.debug(_(\"Destroying instance\"), instance=instance)",
            "        if instance['vm_state'] == vm_states.RESCUED:",
            "            LOG.debug(_(\"Rescue VM configured\"), instance=instance)",
            "            try:",
            "                self.unrescue(instance, power_on=False)",
            "                LOG.debug(_(\"Rescue VM destroyed\"), instance=instance)",
            "            except Exception:",
            "                rescue_name = instance['uuid'] + self._rescue_suffix",
            "                self._destroy_instance(instance, network_info,",
            "                                       destroy_disks=destroy_disks,",
            "                                       instance_name=rescue_name)",
            "        self._destroy_instance(instance, network_info,",
            "                               destroy_disks=destroy_disks)",
            "        LOG.debug(_(\"Instance destroyed\"), instance=instance)",
            "",
            "    def pause(self, instance):",
            "        msg = _(\"pause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def unpause(self, instance):",
            "        msg = _(\"unpause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def suspend(self, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be suspended.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"Suspending the VM\"), instance=instance)",
            "            suspend_task = self._session._call_method(self._session._get_vim(),",
            "                    \"SuspendVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(_(\"Suspended the VM\"), instance=instance)",
            "        # Raise Exception if VM is poweredOff",
            "        elif pwr_state == \"poweredOff\":",
            "            reason = _(\"instance is powered off and cannot be suspended.\")",
            "            raise exception.InstanceSuspendFailure(reason=reason)",
            "        else:",
            "            LOG.debug(_(\"VM was already in suspended state. So returning \"",
            "                      \"without doing anything\"), instance=instance)",
            "",
            "    def resume(self, instance):",
            "        \"\"\"Resume the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state.lower() == \"suspended\":",
            "            LOG.debug(_(\"Resuming the VM\"), instance=instance)",
            "            suspend_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                       \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(_(\"Resumed the VM\"), instance=instance)",
            "        else:",
            "            reason = _(\"instance is not in a suspended state\")",
            "            raise exception.InstanceResumeFailure(reason=reason)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta):",
            "        \"\"\"Rescue the specified instance.",
            "",
            "            - shutdown the instance VM.",
            "            - spawn a rescue VM (the vm name-label will be instance-N-rescue).",
            "",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        self.power_off(instance)",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance['uuid'] + self._rescue_suffix",
            "        self.spawn(context, r_instance, image_meta,",
            "                   None, None, network_info,",
            "                   instance_name=instance_name,",
            "                   power_on=False)",
            "",
            "        # Attach vmdk to the rescue VM",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance['uuid'])",
            "        rescue_vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        self._volumeops.attach_disk_to_vm(",
            "                                rescue_vm_ref, r_instance,",
            "                                adapter_type, disk_type, vmdk_path)",
            "        self._power_on(instance, vm_ref=rescue_vm_ref)",
            "",
            "    def unrescue(self, instance, power_on=True):",
            "        \"\"\"Unrescue the specified instance.\"\"\"",
            "        # Get the original vmdk_path",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance['uuid'])",
            "",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance['uuid'] + self._rescue_suffix",
            "        # detach the original instance disk from the rescue disk",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_rescue_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        device = vm_util.get_vmdk_volume_disk(hardware_devices, path=vmdk_path)",
            "        self._power_off_vm_ref(vm_rescue_ref)",
            "        self._volumeops.detach_disk_from_vm(vm_rescue_ref, r_instance, device)",
            "        self._destroy_instance(r_instance, None, instance_name=instance_name)",
            "        if power_on:",
            "            self._power_on(instance)",
            "",
            "    def _power_off_vm_ref(self, vm_ref):",
            "        \"\"\"Power off the specifed vm.",
            "",
            "        :param vm_ref: a reference object to the VM.",
            "        \"\"\"",
            "        poweroff_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"PowerOffVM_Task\", vm_ref)",
            "        self._session._wait_for_task(poweroff_task)",
            "",
            "    def power_off(self, instance):",
            "        \"\"\"Power off the specified instance.",
            "",
            "        :param instance: nova.objects.instance.Instance",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be powered off.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"Powering off the VM\"), instance=instance)",
            "            self._power_off_vm_ref(vm_ref)",
            "            LOG.debug(_(\"Powered off the VM\"), instance=instance)",
            "        # Raise Exception if VM is suspended",
            "        elif pwr_state == \"suspended\":",
            "            reason = _(\"instance is suspended and cannot be powered off.\")",
            "            raise exception.InstancePowerOffFailure(reason=reason)",
            "        else:",
            "            LOG.debug(_(\"VM was already in powered off state. So returning \"",
            "                        \"without doing anything\"), instance=instance)",
            "",
            "    def _power_on(self, instance, vm_ref=None):",
            "        \"\"\"Power on the specified instance.\"\"\"",
            "        if not vm_ref:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"VM was already in powered on state. So returning \"",
            "                      \"without doing anything\"), instance=instance)",
            "        # Only PoweredOff and Suspended VMs can be powered on.",
            "        else:",
            "            LOG.debug(_(\"Powering on the VM\"), instance=instance)",
            "            poweron_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(poweron_task)",
            "            LOG.debug(_(\"Powered on the VM\"), instance=instance)",
            "",
            "    def power_on(self, context, instance, network_info, block_device_info):",
            "        self._power_on(instance)",
            "",
            "    def _get_orig_vm_name_label(self, instance):",
            "        return instance['uuid'] + '-orig'",
            "",
            "    def _update_instance_progress(self, context, instance, step, total_steps):",
            "        \"\"\"Update instance progress percent to reflect current step number",
            "        \"\"\"",
            "        # Divide the action's workflow into discrete steps and \"bump\" the",
            "        # instance's progress field as each step is completed.",
            "        #",
            "        # For a first cut this should be fine, however, for large VM images,",
            "        # the clone disk step begins to dominate the equation. A",
            "        # better approximation would use the percentage of the VM image that",
            "        # has been streamed to the destination host.",
            "        progress = round(float(step) / total_steps * 100)",
            "        instance_uuid = instance['uuid']",
            "        LOG.debug(_(\"Updating instance '%(instance_uuid)s' progress to\"",
            "                    \" %(progress)d\"),",
            "                  {'instance_uuid': instance_uuid, 'progress': progress},",
            "                  instance=instance)",
            "        self._virtapi.instance_update(context, instance_uuid,",
            "                                      {'progress': progress})",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor):",
            "        \"\"\"Transfers the disk of a running instance in multiple phases, turning",
            "        off the instance before the end.",
            "        \"\"\"",
            "        # 0. Zero out the progress to begin",
            "        self._update_instance_progress(context, instance,",
            "                                       step=0,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Read the host_ref for the destination. If this is None then the",
            "        # VC will decide on placement",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "",
            "        # 1. Power off the instance",
            "        self.power_off(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=1,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        # 2. Disassociate the linked vsphere VM from the instance",
            "        vm_util.disassociate_vmref_from_instance(self._session, instance,",
            "                                                 vm_ref,",
            "                                                 suffix=self._migrate_suffix)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=2,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        ds_ref = vm_util.get_datastore_ref_and_name(",
            "                            self._session, self._cluster, host_ref,",
            "                            datastore_regex=self._datastore_regex)[0]",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        # 3. Clone the VM for instance",
            "        vm_util.clone_vmref_for_instance(self._session, instance, vm_ref,",
            "                                         host_ref, ds_ref, dc_info.vmFolder)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=3,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        # Destroy the original VM. The vm_ref needs to be searched using the",
            "        # instance['uuid'] + self._migrate_suffix as the identifier. We will",
            "        # not get the vm when searched using the instanceUuid but rather will",
            "        # be found using the uuid buried in the extraConfig",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self._session,",
            "                                    instance['uuid'] + self._migrate_suffix)",
            "        if vm_ref is None:",
            "            LOG.debug(_(\"instance not present\"), instance=instance)",
            "            return",
            "",
            "        try:",
            "            LOG.debug(_(\"Destroying the VM\"), instance=instance)",
            "            destroy_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"Destroy_Task\", vm_ref)",
            "            self._session._wait_for_task(destroy_task)",
            "            LOG.debug(_(\"Destroyed the VM\"), instance=instance)",
            "        except Exception as excep:",
            "            LOG.warn(_(\"In vmwareapi:vmops:confirm_migration, got this \"",
            "                     \"exception while destroying the VM: %s\") % str(excep))",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info, power_on=True):",
            "        \"\"\"Finish reverting a resize.\"\"\"",
            "        vm_util.associate_vmref_for_instance(self._session, instance,",
            "                                             suffix=self._migrate_suffix)",
            "        if power_on:",
            "            self._power_on(instance)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance=False,",
            "                         block_device_info=None, power_on=True):",
            "        \"\"\"Completes a resize, turning on the migrated instance.\"\"\"",
            "        if resize_instance:",
            "            client_factory = self._session._get_vim().client.factory",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "            vm_resize_spec = vm_util.get_vm_resize_spec(client_factory,",
            "                                                        instance)",
            "            reconfig_task = self._session._call_method(",
            "                                            self._session._get_vim(),",
            "                                            \"ReconfigVM_Task\", vm_ref,",
            "                                            spec=vm_resize_spec)",
            "            self._session._wait_for_task(reconfig_task)",
            "",
            "        # 4. Start VM",
            "        if power_on:",
            "            self._power_on(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=4,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def live_migration(self, context, instance_ref, dest,",
            "                       post_method, recover_method, block_migration=False):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance_ref)",
            "",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "        if host_ref is None:",
            "            raise exception.HostNotFound(host=dest)",
            "",
            "        LOG.debug(_(\"Migrating VM to host %s\") % dest, instance=instance_ref)",
            "        try:",
            "            vm_migrate_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"MigrateVM_Task\", vm_ref,",
            "                                    host=host_ref,",
            "                                    priority=\"defaultPriority\")",
            "            self._session._wait_for_task(vm_migrate_task)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                recover_method(context, instance_ref, dest, block_migration)",
            "        post_method(context, instance_ref, dest, block_migration)",
            "        LOG.debug(_(\"Migrated VM to host %s\") % dest, instance=instance_ref)",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        \"\"\"Poll for rebooting instances.\"\"\"",
            "        ctxt = nova_context.get_admin_context()",
            "",
            "        instances_info = dict(instance_count=len(instances),",
            "                timeout=timeout)",
            "",
            "        if instances_info[\"instance_count\"] > 0:",
            "            LOG.info(_(\"Found %(instance_count)d hung reboots \"",
            "                    \"older than %(timeout)d seconds\") % instances_info)",
            "",
            "        for instance in instances:",
            "            LOG.info(_(\"Automatically hard rebooting\"), instance=instance)",
            "            self.compute_api.reboot(ctxt, instance, \"HARD\")",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Return data about the VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        lst_properties = [\"summary.config.numCpu\",",
            "                    \"summary.config.memorySizeMB\",",
            "                    \"runtime.powerState\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = {'summary.config.numCpu': 0,",
            "                 'summary.config.memorySizeMB': 0,",
            "                 'runtime.powerState': None}",
            "        self._get_values_from_object_properties(vm_props, query)",
            "        max_mem = int(query['summary.config.memorySizeMB']) * 1024",
            "        return {'state': VMWARE_POWER_STATES[query['runtime.powerState']],",
            "                'max_mem': max_mem,",
            "                'mem': max_mem,",
            "                'num_cpu': int(query['summary.config.numCpu']),",
            "                'cpu_time': 0}",
            "",
            "    def _get_diagnostic_from_object_properties(self, props, wanted_props):",
            "        diagnostics = {}",
            "        while props:",
            "            for elem in props.objects:",
            "                for prop in elem.propSet:",
            "                    if prop.name in wanted_props:",
            "                        prop_dict = vim.object_to_dict(prop.val, list_depth=1)",
            "                        diagnostics.update(prop_dict)",
            "            token = vm_util._get_token(props)",
            "            if not token:",
            "                break",
            "",
            "            props = self._session._call_method(vim_util,",
            "                                               \"continue_to_get_objects\",",
            "                                               token)",
            "        return diagnostics",
            "",
            "    def get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.config\",",
            "                          \"summary.quickStats\",",
            "                          \"summary.runtime\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        data = self._get_diagnostic_from_object_properties(vm_props,",
            "                                                           set(lst_properties))",
            "        # Add a namespace to all of the diagnostsics",
            "        return dict([('vmware:' + k, v) for k, v in data.items()])",
            "",
            "    def get_vnc_console(self, instance):",
            "        \"\"\"Return connection info for a vnc console.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        opt_value = self._session._call_method(vim_util,",
            "                               'get_dynamic_property',",
            "                               vm_ref, 'VirtualMachine',",
            "                               vm_util.VNC_CONFIG_KEY)",
            "        if opt_value:",
            "            port = int(opt_value.value)",
            "        else:",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        return {'host': CONF.vmware.host_ip,",
            "                'port': port,",
            "                'internal_access_path': None}",
            "",
            "    def get_vnc_console_vcenter(self, instance):",
            "        \"\"\"Return connection info for a vnc console using vCenter logic.\"\"\"",
            "",
            "        # vCenter does not run virtual machines and does not run",
            "        # a VNC proxy. Instead, you need to tell OpenStack to talk",
            "        # directly to the ESX host running the VM you are attempting",
            "        # to connect to via VNC.",
            "",
            "        vnc_console = self.get_vnc_console(instance)",
            "        host_name = vm_util.get_host_name_for_vm(",
            "                        self._session,",
            "                        instance)",
            "        vnc_console['host'] = host_name",
            "",
            "        # NOTE: VM can move hosts in some situations. Debug for admins.",
            "        LOG.debug(_(\"VM %(uuid)s is currently on host %(host_name)s\"),",
            "                {'uuid': instance['name'], 'host_name': host_name})",
            "",
            "        return vnc_console",
            "",
            "    @staticmethod",
            "    def _get_machine_id_str(network_info):",
            "        machine_id_str = ''",
            "        for vif in network_info:",
            "            # TODO(vish): add support for dns2",
            "            # TODO(sateesh): add support for injection of ipv6 configuration",
            "            network = vif['network']",
            "            ip_v4 = netmask_v4 = gateway_v4 = broadcast_v4 = dns = None",
            "            subnets_v4 = [s for s in network['subnets'] if s['version'] == 4]",
            "            if len(subnets_v4) > 0:",
            "                if len(subnets_v4[0]['ips']) > 0:",
            "                    ip_v4 = subnets_v4[0]['ips'][0]",
            "                if len(subnets_v4[0]['dns']) > 0:",
            "                    dns = subnets_v4[0]['dns'][0]['address']",
            "",
            "                netmask_v4 = str(subnets_v4[0].as_netaddr().netmask)",
            "                gateway_v4 = subnets_v4[0]['gateway']['address']",
            "                broadcast_v4 = str(subnets_v4[0].as_netaddr().broadcast)",
            "",
            "            interface_str = \";\".join([vif['address'],",
            "                                      ip_v4 and ip_v4['address'] or '',",
            "                                      netmask_v4 or '',",
            "                                      gateway_v4 or '',",
            "                                      broadcast_v4 or '',",
            "                                      dns or ''])",
            "            machine_id_str = machine_id_str + interface_str + '#'",
            "        return machine_id_str",
            "",
            "    def _set_machine_id(self, client_factory, instance, network_info):",
            "        \"\"\"Set the machine id of the VM for guest tools to pick up",
            "        and reconfigure the network interfaces.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        machine_id_change_spec = vm_util.get_machine_id_change_spec(",
            "                                 client_factory,",
            "                                 self._get_machine_id_str(network_info))",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance to set the machine id\"),",
            "                  instance=instance)",
            "        reconfig_task = self._session._call_method(self._session._get_vim(),",
            "                           \"ReconfigVM_Task\", vm_ref,",
            "                           spec=machine_id_change_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance to set the machine id\"),",
            "                  instance=instance)",
            "",
            "    def _set_vnc_config(self, client_factory, instance, port):",
            "        \"\"\"Set the vnc configuration of the VM.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        vnc_config_spec = vm_util.get_vnc_config_spec(",
            "                                      client_factory, port)",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance to enable vnc on \"",
            "                  \"port - %(port)s\") % {'port': port},",
            "                  instance=instance)",
            "        reconfig_task = self._session._call_method(self._session._get_vim(),",
            "                           \"ReconfigVM_Task\", vm_ref,",
            "                           spec=vnc_config_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance to enable vnc on \"",
            "                  \"port - %(port)s\") % {'port': port},",
            "                  instance=instance)",
            "",
            "    def _get_ds_browser(self, ds_ref):",
            "        ds_browser = self._datastore_browser_mapping.get(ds_ref.value)",
            "        if not ds_browser:",
            "            ds_browser = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", ds_ref, \"Datastore\",",
            "                \"browser\")",
            "            self._datastore_browser_mapping[ds_ref.value] = ds_browser",
            "        return ds_browser",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        map = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not map:",
            "            dc_obj = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\"])",
            "            vm_util._cancel_retrieve_if_necessary(self._session, dc_obj)",
            "            map = DcInfo(ref=dc_obj.objects[0].obj,",
            "                         name=dc_obj.objects[0].propSet[0].val,",
            "                         vmFolder=self._get_vmfolder_ref())",
            "            self._datastore_dc_mapping[ds_ref.value] = map",
            "        return map",
            "",
            "    def _get_host_ref_from_name(self, host_name):",
            "        \"\"\"Get reference to the host with the name specified.\"\"\"",
            "        host_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"HostSystem\", [\"name\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, host_objs)",
            "        for host in host_objs:",
            "            if hasattr(host, 'propSet'):",
            "                if host.propSet[0].val == host_name:",
            "                    return host.obj",
            "        return None",
            "",
            "    def _get_vmfolder_ref(self):",
            "        \"\"\"Get the Vm folder ref from the datacenter.\"\"\"",
            "        dc_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                                             \"Datacenter\", [\"vmFolder\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, dc_objs)",
            "        # There is only one default datacenter in a standalone ESX host",
            "        vm_folder_ref = dc_objs.objects[0].propSet[0].val",
            "        return vm_folder_ref",
            "",
            "    def _create_folder_if_missing(self, ds_name, ds_ref, folder):",
            "        \"\"\"Create a folder if it does not exist.",
            "",
            "        Currently there are two folder that are required on the datastore",
            "         - base folder - the folder to store cached images",
            "         - temp folder - the folder used for snapshot management and",
            "                         image uploading",
            "        This method is aimed to be used for the management of those",
            "        folders to ensure that they are created if they are missing.",
            "        The ds_util method mkdir will be used to check if the folder",
            "        exists. If this throws and exception 'FileAlreadyExistsException'",
            "        then the folder already exists on the datastore.",
            "        \"\"\"",
            "        path = ds_util.build_datastore_path(ds_name, folder)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        try:",
            "            ds_util.mkdir(self._session, path, dc_info.ref)",
            "            LOG.debug(_(\"Folder %s created.\"), path)",
            "        except error_util.FileAlreadyExistsException:",
            "            # NOTE(hartsocks): if the folder already exists, that",
            "            # just means the folder was prepped by another process.",
            "            pass",
            "",
            "    def check_cache_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the cache folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._base_folder)",
            "",
            "    def check_temp_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the temp folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._tmp_folder)",
            "",
            "    def _check_if_folder_file_exists(self, ds_browser, ds_ref, ds_name,",
            "                                     folder_name, file_name):",
            "        # Ensure that the cache folder exists",
            "        self.check_cache_folder(ds_name, ds_ref)",
            "        # Check if the file exists or not.",
            "        folder_path = ds_util.build_datastore_path(ds_name, folder_name)",
            "        file_exists = ds_util.file_exists(self._session, ds_browser,",
            "                                          folder_path, file_name)",
            "        return file_exists",
            "",
            "    def inject_network_info(self, instance, network_info):",
            "        \"\"\"inject network info for specified instance.\"\"\"",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        client_factory = self._session._get_vim().client.factory",
            "        self._set_machine_id(client_factory, instance, network_info)",
            "",
            "    def manage_image_cache(self, context, instances):",
            "        if not CONF.remove_unused_base_images:",
            "            LOG.debug(_(\"Image aging disabled. Aging will not be done.\"))",
            "            return",
            "",
            "        datastores = vm_util.get_available_datastores(self._session,",
            "                                                      self._cluster,",
            "                                                      self._datastore_regex)",
            "        datastores_info = []",
            "        for ds in datastores:",
            "            ds_info = self.get_datacenter_ref_and_name(ds['ref'])",
            "            datastores_info.append((ds, ds_info))",
            "        self._imagecache.update(context, instances, datastores_info)",
            "",
            "    def _get_valid_vms_from_retrieve_result(self, retrieve_result):",
            "        \"\"\"Returns list of valid vms from RetrieveResult object.\"\"\"",
            "        lst_vm_names = []",
            "",
            "        while retrieve_result:",
            "            token = vm_util._get_token(retrieve_result)",
            "            for vm in retrieve_result.objects:",
            "                vm_name = None",
            "                conn_state = None",
            "                for prop in vm.propSet:",
            "                    if prop.name == \"name\":",
            "                        vm_name = prop.val",
            "                    elif prop.name == \"runtime.connectionState\":",
            "                        conn_state = prop.val",
            "                # Ignoring the orphaned or inaccessible VMs",
            "                if conn_state not in [\"orphaned\", \"inaccessible\"]:",
            "                    lst_vm_names.append(vm_name)",
            "            if token:",
            "                retrieve_result = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "        return lst_vm_names",
            "",
            "",
            "class VMwareVCVMOps(VMwareVMOps):",
            "    \"\"\"Management class for VM-related tasks.",
            "",
            "    Contains specializations to account for differences in vSphere API behavior",
            "    when invoked on Virtual Center instead of ESX host.",
            "    \"\"\"",
            "",
            "    def get_copy_virtual_disk_spec(self, client_factory, adapter_type,",
            "                                   disk_type):",
            "        LOG.debug(_(\"Will copy while retaining adapter type \"",
            "                    \"%(adapter_type)s and disk type %(disk_type)s\") %",
            "                    {\"disk_type\": disk_type,",
            "                     \"adapter_type\": adapter_type})",
            "        # Passing of the destination copy spec is not supported when",
            "        # VirtualDiskManager.CopyVirtualDisk is called on VC. The behavior of a",
            "        # spec-less copy is to consolidate to the target disk while keeping its",
            "        # disk and adapter type unchanged.",
            "",
            "    def _update_datacenter_cache_from_objects(self, dcs):",
            "        \"\"\"Updates the datastore/datacenter cache.\"\"\"",
            "",
            "        while dcs:",
            "            token = vm_util._get_token(dcs)",
            "            for dco in dcs.objects:",
            "                dc_ref = dco.obj",
            "                ds_refs = []",
            "                prop_dict = vm_util.propset_dict(dco.propSet)",
            "                name = prop_dict.get('name')",
            "                vmFolder = prop_dict.get('vmFolder')",
            "                datastore_refs = prop_dict.get('datastore')",
            "                if datastore_refs:",
            "                    datastore_refs = datastore_refs.ManagedObjectReference",
            "                    for ds in datastore_refs:",
            "                        ds_refs.append(ds.value)",
            "                else:",
            "                    LOG.debug(\"Datacenter %s doesn't have any datastore \"",
            "                              \"associated with it, ignoring it\", name)",
            "                for ds_ref in ds_refs:",
            "                    self._datastore_dc_mapping[ds_ref] = DcInfo(ref=dc_ref,",
            "                            name=name, vmFolder=vmFolder)",
            "",
            "            if token:",
            "                dcs = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not dc_info:",
            "            dcs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\", \"datastore\", \"vmFolder\"])",
            "            self._update_datacenter_cache_from_objects(dcs)",
            "            dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        return dc_info",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with vCenter cluster.\"\"\"",
            "        properties = ['name', 'runtime.connectionState']",
            "        LOG.debug(_(\"Getting list of instances from cluster %s\"),",
            "                  self._cluster)",
            "        vms = []",
            "        root_res_pool = self._session._call_method(",
            "            vim_util, \"get_dynamic_property\", self._cluster,",
            "            'ClusterComputeResource', 'resourcePool')",
            "        if root_res_pool:",
            "            vms = self._session._call_method(",
            "                vim_util, 'get_inner_objects', root_res_pool, 'vm',",
            "                'VirtualMachine', properties)",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(_(\"Got total of %s instances\") % str(len(lst_vm_names)))",
            "        return lst_vm_names"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Class for VM tasks like spawn, snapshot, suspend, resume etc.",
            "\"\"\"",
            "",
            "import collections",
            "import copy",
            "import os",
            "",
            "from oslo.config import cfg",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import compute",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.openstack.common import excutils",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import lockutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "from nova.virt import configdrive",
            "from nova.virt import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif as vmwarevif",
            "from nova.virt.vmwareapi import vim",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmware_images",
            "",
            "",
            "vmware_vif_opts = [",
            "    cfg.StrOpt('integration_bridge',",
            "               default='br-int',",
            "               help='Name of Integration Bridge'),",
            "    ]",
            "",
            "vmware_group = cfg.OptGroup(name='vmware',",
            "                            title='VMware Options')",
            "",
            "CONF = cfg.CONF",
            "CONF.register_group(vmware_group)",
            "CONF.register_opts(vmware_vif_opts, vmware_group)",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('remove_unused_base_images', 'nova.virt.imagecache')",
            "CONF.import_opt('vnc_enabled', 'nova.vnc')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VMWARE_POWER_STATES = {",
            "                   'poweredOff': power_state.SHUTDOWN,",
            "                    'poweredOn': power_state.RUNNING,",
            "                    'suspended': power_state.SUSPENDED}",
            "",
            "VMWARE_LINKED_CLONE = 'vmware_linked_clone'",
            "",
            "RESIZE_TOTAL_STEPS = 4",
            "",
            "DcInfo = collections.namedtuple('DcInfo',",
            "                                ['ref', 'name', 'vmFolder'])",
            "",
            "",
            "class VMwareVMOps(object):",
            "    \"\"\"Management class for VM-related tasks.\"\"\"",
            "",
            "    def __init__(self, session, virtapi, volumeops, cluster=None,",
            "                 datastore_regex=None):",
            "        \"\"\"Initializer.\"\"\"",
            "        self.compute_api = compute.API()",
            "        self._session = session",
            "        self._virtapi = virtapi",
            "        self._volumeops = volumeops",
            "        self._cluster = cluster",
            "        self._datastore_regex = datastore_regex",
            "        # Ensure that the base folder is unique per compute node",
            "        if CONF.remove_unused_base_images:",
            "            self._base_folder = '%s%s' % (CONF.my_ip,",
            "                                          CONF.image_cache_subdirectory_name)",
            "        else:",
            "            # Aging disable ensures backward compatibility",
            "            self._base_folder = CONF.image_cache_subdirectory_name",
            "        self._tmp_folder = 'vmware_temp'",
            "        self._default_root_device = 'vda'",
            "        self._rescue_suffix = '-rescue'",
            "        self._migrate_suffix = '-orig'",
            "        self._poll_rescue_last_ran = None",
            "        self._is_neutron = utils.is_neutron()",
            "        self._datastore_dc_mapping = {}",
            "        self._datastore_browser_mapping = {}",
            "        self._imagecache = imagecache.ImageCacheManager(self._session,",
            "                                                        self._base_folder)",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with the ESX host.\"\"\"",
            "        LOG.debug(_(\"Getting list of instances\"))",
            "        vms = self._session._call_method(vim_util, \"get_objects\",",
            "                     \"VirtualMachine\",",
            "                     [\"name\", \"runtime.connectionState\"])",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(_(\"Got total of %s instances\") % str(len(lst_vm_names)))",
            "        return lst_vm_names",
            "",
            "    def _extend_virtual_disk(self, instance, requested_size, name, dc_ref):",
            "        service_content = self._session._get_vim().get_service_content()",
            "        LOG.debug(_(\"Extending root virtual disk to %s\"), requested_size)",
            "        vmdk_extend_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"ExtendVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=name,",
            "                datacenter=dc_ref,",
            "                newCapacityKb=requested_size,",
            "                eagerZero=False)",
            "        try:",
            "            self._session._wait_for_task(vmdk_extend_task)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Extending virtual disk failed with error: %s'),",
            "                          e, instance=instance)",
            "                # Clean up files created during the extend operation",
            "                files = [name.replace(\".vmdk\", \"-flat.vmdk\"), name]",
            "                for file in files:",
            "                    self._delete_datastore_file(instance, file, dc_ref)",
            "",
            "        LOG.debug(_(\"Extended root virtual disk\"))",
            "",
            "    def _delete_datastore_file(self, instance, datastore_path, dc_ref):",
            "        try:",
            "            ds_util.file_delete(self._session, datastore_path, dc_ref)",
            "        except (error_util.CannotDeleteFileException,",
            "                error_util.FileFaultException,",
            "                error_util.FileLockedException,",
            "                error_util.FileNotFoundException) as e:",
            "            LOG.debug(_(\"Unable to delete %(ds)s. There may be more than \"",
            "                        \"one process or thread that tries to delete the file. \"",
            "                        \"Exception: %(ex)s\"),",
            "                      {'ds': datastore_path, 'ex': e})",
            "",
            "    def _get_vmdk_path(self, ds_name, folder, name):",
            "        path = \"%s/%s.vmdk\" % (folder, name)",
            "        return ds_util.build_datastore_path(ds_name, path)",
            "",
            "    def _get_disk_format(self, image_meta):",
            "        disk_format = image_meta.get('disk_format')",
            "        if disk_format not in ['iso', 'vmdk', None]:",
            "            raise exception.InvalidDiskFormat(disk_format=disk_format)",
            "        return (disk_format, disk_format == 'iso')",
            "",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info, block_device_info=None,",
            "              instance_name=None, power_on=True):",
            "        \"\"\"Creates a VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Create a VM with no disk and the specifics in the instance object",
            "           like RAM size.",
            "        2. For flat disk",
            "          2.1. Create a dummy vmdk of the size of the disk file that is to be",
            "               uploaded. This is required just to create the metadata file.",
            "          2.2. Delete the -flat.vmdk file created in the above step and retain",
            "               the metadata .vmdk file.",
            "          2.3. Upload the disk file.",
            "        3. For sparse disk",
            "          3.1. Upload the disk file to a -sparse.vmdk file.",
            "          3.2. Copy/Clone the -sparse.vmdk file to a thin vmdk.",
            "          3.3. Delete the -sparse.vmdk file.",
            "        4. Attach the disk to the VM by reconfiguring the same.",
            "        5. Power on the VM.",
            "        \"\"\"",
            "        ebs_root = False",
            "        if block_device_info:",
            "            msg = \"Block device information present: %s\" % block_device_info",
            "            # NOTE(mriedem): block_device_info can contain an auth_password",
            "            # so we have to scrub the message before logging it.",
            "            LOG.debug(logging.mask_password(msg), instance=instance)",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                    block_device_info)",
            "            if block_device_mapping:",
            "                ebs_root = True",
            "",
            "        (file_type, is_iso) = self._get_disk_format(image_meta)",
            "",
            "        client_factory = self._session._get_vim().client.factory",
            "        service_content = self._session._get_vim().get_service_content()",
            "        ds = vm_util.get_datastore_ref_and_name(self._session, self._cluster,",
            "                 datastore_regex=self._datastore_regex)",
            "        data_store_ref = ds[0]",
            "        data_store_name = ds[1]",
            "        dc_info = self.get_datacenter_ref_and_name(data_store_ref)",
            "",
            "        #TODO(hartsocks): this pattern is confusing, reimplement as methods",
            "        # The use of nested functions in this file makes for a confusing and",
            "        # hard to maintain file. At some future date, refactor this method to",
            "        # be a full-fledged method. This will also make unit testing easier.",
            "        def _get_image_properties(root_size):",
            "            \"\"\"Get the Size of the flat vmdk file that is there on the storage",
            "            repository.",
            "            \"\"\"",
            "            image_ref = instance.get('image_ref')",
            "            if image_ref:",
            "                _image_info = vmware_images.get_vmdk_size_and_properties(",
            "                        context, image_ref, instance)",
            "            else:",
            "                # The case that the image may be booted from a volume",
            "                _image_info = (root_size, {})",
            "",
            "            image_size, image_properties = _image_info",
            "            vmdk_file_size_in_kb = int(image_size) / 1024",
            "            os_type = image_properties.get(\"vmware_ostype\", \"otherGuest\")",
            "            adapter_type = image_properties.get(\"vmware_adaptertype\",",
            "                                                \"lsiLogic\")",
            "            disk_type = image_properties.get(\"vmware_disktype\",",
            "                                             \"preallocated\")",
            "            # Get the network card type from the image properties.",
            "            vif_model = image_properties.get(\"hw_vif_model\", \"VirtualE1000\")",
            "",
            "            # Fetch the image_linked_clone data here. It is retrieved",
            "            # with the above network based API call. To retrieve it",
            "            # later will necessitate additional network calls using the",
            "            # identical method. Consider this a cache.",
            "            image_linked_clone = image_properties.get(VMWARE_LINKED_CLONE)",
            "",
            "            return (vmdk_file_size_in_kb, os_type, adapter_type, disk_type,",
            "                vif_model, image_linked_clone)",
            "",
            "        root_gb = instance['root_gb']",
            "        root_gb_in_kb = root_gb * units.Mi",
            "",
            "        (vmdk_file_size_in_kb, os_type, adapter_type, disk_type, vif_model,",
            "            image_linked_clone) = _get_image_properties(root_gb_in_kb)",
            "",
            "        if root_gb_in_kb and vmdk_file_size_in_kb > root_gb_in_kb:",
            "            reason = _(\"Image disk size greater than requested disk size\")",
            "            raise exception.InstanceUnacceptable(instance_id=instance['uuid'],",
            "                                                 reason=reason)",
            "",
            "        node_mo_id = vm_util.get_mo_id_from_instance(instance)",
            "        res_pool_ref = vm_util.get_res_pool_ref(self._session,",
            "                                                self._cluster, node_mo_id)",
            "",
            "        def _get_vif_infos():",
            "            vif_infos = []",
            "            if network_info is None:",
            "                return vif_infos",
            "            for vif in network_info:",
            "                mac_address = vif['address']",
            "                network_name = vif['network']['bridge'] or \\",
            "                               CONF.vmware.integration_bridge",
            "                network_ref = vmwarevif.get_network_ref(self._session,",
            "                                                        self._cluster,",
            "                                                        vif,",
            "                                                        self._is_neutron)",
            "                vif_infos.append({'network_name': network_name,",
            "                                  'mac_address': mac_address,",
            "                                  'network_ref': network_ref,",
            "                                  'iface_id': vif['id'],",
            "                                  'vif_model': vif_model",
            "                                 })",
            "            return vif_infos",
            "",
            "        vif_infos = _get_vif_infos()",
            "",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if not instance_name:",
            "            instance_name = instance['uuid']",
            "        # Get the create vm config spec",
            "        config_spec = vm_util.get_vm_create_spec(",
            "                            client_factory, instance, instance_name,",
            "                            data_store_name, vif_infos, os_type)",
            "",
            "        def _execute_create_vm():",
            "            \"\"\"Create VM on ESX host.\"\"\"",
            "            LOG.debug(_(\"Creating VM on the ESX host\"), instance=instance)",
            "            # Create the VM on the ESX host",
            "            vm_create_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"CreateVM_Task\", dc_info.vmFolder,",
            "                                    config=config_spec, pool=res_pool_ref)",
            "            self._session._wait_for_task(vm_create_task)",
            "",
            "            LOG.debug(_(\"Created VM on the ESX host\"), instance=instance)",
            "",
            "        _execute_create_vm()",
            "",
            "        # In the case of a rescue disk the instance_name is not the same as",
            "        # instance UUID. In this case the VM reference is accessed via the",
            "        # instance name.",
            "        if instance_name != instance['uuid']:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                  instance_name)",
            "        else:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        if CONF.flat_injected:",
            "            self._set_machine_id(client_factory, instance, network_info)",
            "",
            "        # Set the vnc configuration of the instance, vnc port starts from 5900",
            "        if CONF.vnc_enabled:",
            "            vnc_port = vm_util.get_vnc_port(self._session)",
            "            self._set_vnc_config(client_factory, instance, vnc_port)",
            "",
            "        def _create_virtual_disk(virtual_disk_path, file_size_in_kb):",
            "            \"\"\"Create a virtual disk of the size of flat vmdk file.\"\"\"",
            "            # Create a Virtual Disk of the size of the flat vmdk file. This is",
            "            # done just to generate the meta-data file whose specifics",
            "            # depend on the size of the disk, thin/thick provisioning and the",
            "            # storage adapter type.",
            "            # Here we assume thick provisioning and lsiLogic for the adapter",
            "            # type",
            "            LOG.debug(_(\"Creating Virtual Disk of size  \"",
            "                      \"%(vmdk_file_size_in_kb)s KB and adapter type \"",
            "                      \"%(adapter_type)s on the ESX host local store \"",
            "                      \"%(data_store_name)s\"),",
            "                       {\"vmdk_file_size_in_kb\": file_size_in_kb,",
            "                        \"adapter_type\": adapter_type,",
            "                        \"data_store_name\": data_store_name},",
            "                      instance=instance)",
            "            vmdk_create_spec = vm_util.get_vmdk_create_spec(client_factory,",
            "                                    file_size_in_kb, adapter_type,",
            "                                    disk_type)",
            "            vmdk_create_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CreateVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=virtual_disk_path,",
            "                datacenter=dc_info.ref,",
            "                spec=vmdk_create_spec)",
            "            self._session._wait_for_task(vmdk_create_task)",
            "            LOG.debug(_(\"Created Virtual Disk of size %(vmdk_file_size_in_kb)s\"",
            "                        \" KB and type %(disk_type)s on \"",
            "                        \"the ESX host local store %(data_store_name)s\") %",
            "                        {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                         \"disk_type\": disk_type,",
            "                         \"data_store_name\": data_store_name},",
            "                      instance=instance)",
            "",
            "        def _fetch_image_on_datastore(upload_name):",
            "            \"\"\"Fetch image from Glance to datastore.\"\"\"",
            "            LOG.debug(_(\"Downloading image file data %(image_ref)s to the \"",
            "                        \"data store %(data_store_name)s\") %",
            "                        {'image_ref': instance['image_ref'],",
            "                         'data_store_name': data_store_name},",
            "                      instance=instance)",
            "            vmware_images.fetch_image(",
            "                context,",
            "                instance['image_ref'],",
            "                instance,",
            "                host=self._session._host_ip,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=data_store_name,",
            "                cookies=cookies,",
            "                file_path=upload_name)",
            "            LOG.debug(_(\"Downloaded image file data %(image_ref)s to \"",
            "                        \"%(upload_name)s on the data store \"",
            "                        \"%(data_store_name)s\") %",
            "                        {'image_ref': instance['image_ref'],",
            "                         'upload_name': upload_name,",
            "                         'data_store_name': data_store_name},",
            "                      instance=instance)",
            "",
            "        def _copy_virtual_disk(source, dest):",
            "            \"\"\"Copy a sparse virtual disk to a thin virtual disk.\"\"\"",
            "            # Copy a sparse virtual disk to a thin virtual disk. This is also",
            "            # done to generate the meta-data file whose specifics",
            "            # depend on the size of the disk, thin/thick provisioning and the",
            "            # storage adapter type.",
            "            LOG.debug(_(\"Copying Virtual Disk of size \"",
            "                      \"%(vmdk_file_size_in_kb)s KB and adapter type \"",
            "                      \"%(adapter_type)s on the ESX host local store \"",
            "                      \"%(data_store_name)s to disk type %(disk_type)s\") %",
            "                       {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                        \"adapter_type\": adapter_type,",
            "                        \"data_store_name\": data_store_name,",
            "                        \"disk_type\": disk_type},",
            "                      instance=instance)",
            "            vmdk_copy_spec = self.get_copy_virtual_disk_spec(client_factory,",
            "                                                             adapter_type,",
            "                                                             disk_type)",
            "            vmdk_copy_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=source,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=dest,",
            "                destSpec=vmdk_copy_spec)",
            "            self._session._wait_for_task(vmdk_copy_task)",
            "            LOG.debug(_(\"Copied Virtual Disk of size %(vmdk_file_size_in_kb)s\"",
            "                        \" KB and type %(disk_type)s on \"",
            "                        \"the ESX host local store %(data_store_name)s\") %",
            "                        {\"vmdk_file_size_in_kb\": vmdk_file_size_in_kb,",
            "                         \"disk_type\": disk_type,",
            "                         \"data_store_name\": data_store_name},",
            "                        instance=instance)",
            "",
            "        if not ebs_root:",
            "            # this logic allows for instances or images to decide",
            "            # for themselves which strategy is best for them.",
            "",
            "            linked_clone = VMwareVMOps.decide_linked_clone(",
            "                image_linked_clone,",
            "                CONF.vmware.use_linked_clone",
            "            )",
            "            upload_name = instance['image_ref']",
            "            upload_folder = '%s/%s' % (self._base_folder, upload_name)",
            "",
            "            # The vmdk meta-data file",
            "            uploaded_file_name = \"%s/%s.%s\" % (upload_folder, upload_name,",
            "                                               file_type)",
            "            uploaded_file_path = ds_util.build_datastore_path(data_store_name,",
            "                                                uploaded_file_name)",
            "",
            "            session_vim = self._session._get_vim()",
            "            cookies = session_vim.client.options.transport.cookiejar",
            "",
            "            ds_browser = self._get_ds_browser(data_store_ref)",
            "            upload_file_name = upload_name + \".%s\" % file_type",
            "",
            "            # Check if the timestamp file exists - if so then delete it. This",
            "            # will ensure that the aging will not delete a cache image if it",
            "            # is going to be used now.",
            "            if CONF.remove_unused_base_images:",
            "                ds_path = ds_util.build_datastore_path(data_store_name,",
            "                                                       self._base_folder)",
            "                path = self._imagecache.timestamp_folder_get(ds_path,",
            "                                                             upload_name)",
            "                # Lock to ensure that the spawn will not try and access a image",
            "                # that is currently being deleted on the datastore.",
            "                with lockutils.lock(path, lock_file_prefix='nova-vmware-ts',",
            "                                    external=True):",
            "                    self._imagecache.timestamp_cleanup(dc_info.ref, ds_browser,",
            "                            data_store_ref, data_store_name, path)",
            "",
            "            # Check if the image exists in the datastore cache. If not the",
            "            # image will be uploaded and cached.",
            "            if not (self._check_if_folder_file_exists(ds_browser,",
            "                                        data_store_ref, data_store_name,",
            "                                        upload_folder, upload_file_name)):",
            "                # Upload will be done to the self._tmp_folder and then moved",
            "                # to the self._base_folder",
            "                tmp_upload_folder = '%s/%s' % (self._tmp_folder,",
            "                                               uuidutils.generate_uuid())",
            "                upload_folder = '%s/%s' % (tmp_upload_folder, upload_name)",
            "",
            "                # Naming the VM files in correspondence with the VM instance",
            "                # The flat vmdk file name",
            "                flat_uploaded_vmdk_name = \"%s/%s-flat.vmdk\" % (",
            "                                            upload_folder, upload_name)",
            "                # The sparse vmdk file name for sparse disk image",
            "                sparse_uploaded_vmdk_name = \"%s/%s-sparse.vmdk\" % (",
            "                                            upload_folder, upload_name)",
            "",
            "                flat_uploaded_vmdk_path = ds_util.build_datastore_path(",
            "                                                    data_store_name,",
            "                                                    flat_uploaded_vmdk_name)",
            "                sparse_uploaded_vmdk_path = ds_util.build_datastore_path(",
            "                                                    data_store_name,",
            "                                                    sparse_uploaded_vmdk_name)",
            "",
            "                upload_file_name = \"%s/%s.%s\" % (upload_folder, upload_name,",
            "                                                 file_type)",
            "                upload_path = ds_util.build_datastore_path(data_store_name,",
            "                                                           upload_file_name)",
            "                if not is_iso:",
            "                    if disk_type != \"sparse\":",
            "                        # Create a flat virtual disk and retain the metadata",
            "                        # file. This will be done in the unique temporary",
            "                        # directory.",
            "                        ds_util.mkdir(self._session,",
            "                                      ds_util.build_datastore_path(",
            "                                          data_store_name, upload_folder),",
            "                                      dc_info.ref)",
            "                        _create_virtual_disk(upload_path,",
            "                                             vmdk_file_size_in_kb)",
            "                        self._delete_datastore_file(instance,",
            "                                                    flat_uploaded_vmdk_path,",
            "                                                    dc_info.ref)",
            "                        upload_file_name = flat_uploaded_vmdk_name",
            "                    else:",
            "                        upload_file_name = sparse_uploaded_vmdk_name",
            "",
            "                _fetch_image_on_datastore(upload_file_name)",
            "",
            "                if not is_iso and disk_type == \"sparse\":",
            "                    # Copy the sparse virtual disk to a thin virtual disk.",
            "                    disk_type = \"thin\"",
            "                    _copy_virtual_disk(sparse_uploaded_vmdk_path, upload_path)",
            "                    self._delete_datastore_file(instance,",
            "                                                sparse_uploaded_vmdk_path,",
            "                                                dc_info.ref)",
            "                base_folder = '%s/%s' % (self._base_folder, upload_name)",
            "                dest_folder = ds_util.build_datastore_path(data_store_name,",
            "                                                           base_folder)",
            "                src_folder = ds_util.build_datastore_path(data_store_name,",
            "                                                          upload_folder)",
            "                try:",
            "                    ds_util.file_move(self._session, dc_info.ref,",
            "                                      src_folder, dest_folder)",
            "                except error_util.FileAlreadyExistsException:",
            "                    # File move has failed. This may be due to the fact that a",
            "                    # process or thread has already completed the opertaion.",
            "                    # In the event of a FileAlreadyExists we continue,",
            "                    # all other exceptions will be raised.",
            "                    LOG.debug(_(\"File %s already exists\"), dest_folder)",
            "",
            "                # Delete the temp upload folder",
            "                self._delete_datastore_file(instance,",
            "                        ds_util.build_datastore_path(data_store_name,",
            "                                                     tmp_upload_folder),",
            "                        dc_info.ref)",
            "            else:",
            "                # linked clone base disk exists",
            "                if disk_type == \"sparse\":",
            "                    disk_type = \"thin\"",
            "",
            "            if is_iso:",
            "                if root_gb_in_kb:",
            "                    dest_vmdk_path = self._get_vmdk_path(data_store_name,",
            "                            instance['uuid'], instance_name)",
            "                    # Create the blank virtual disk for the VM",
            "                    _create_virtual_disk(dest_vmdk_path, root_gb_in_kb)",
            "                    root_vmdk_path = dest_vmdk_path",
            "                else:",
            "                    root_vmdk_path = None",
            "            else:",
            "                # Extend the disk size if necessary",
            "                if not linked_clone:",
            "                    # If we are not using linked_clone, copy the image from",
            "                    # the cache into the instance directory.  If we are using",
            "                    # linked clone it is references from the cache directory",
            "                    dest_vmdk_path = self._get_vmdk_path(data_store_name,",
            "                            instance_name, instance_name)",
            "                    _copy_virtual_disk(uploaded_file_path, dest_vmdk_path)",
            "",
            "                    root_vmdk_path = dest_vmdk_path",
            "                    if root_gb_in_kb > vmdk_file_size_in_kb:",
            "                        self._extend_virtual_disk(instance, root_gb_in_kb,",
            "                                                  root_vmdk_path, dc_info.ref)",
            "                else:",
            "                    upload_folder = '%s/%s' % (self._base_folder, upload_name)",
            "                    if root_gb:",
            "                        root_vmdk_name = \"%s/%s.%s.vmdk\" % (upload_folder,",
            "                                                            upload_name,",
            "                                                            root_gb)",
            "                    else:",
            "                        root_vmdk_name = \"%s/%s.vmdk\" % (upload_folder,",
            "                                                         upload_name)",
            "                    root_vmdk_path = ds_util.build_datastore_path(",
            "                            data_store_name, root_vmdk_name)",
            "",
            "                    # Ensure only a single thread extends the image at once.",
            "                    # We do this by taking a lock on the name of the extended",
            "                    # image. This allows multiple threads to create resized",
            "                    # copies simultaneously, as long as they are different",
            "                    # sizes. Threads attempting to create the same resized copy",
            "                    # will be serialized, with only the first actually creating",
            "                    # the copy.",
            "                    #",
            "                    # Note that the object is in a per-nova cache directory,",
            "                    # so inter-nova locking is not a concern. Consequently we",
            "                    # can safely use simple thread locks.",
            "",
            "                    with lockutils.lock(root_vmdk_path,",
            "                                        lock_file_prefix='nova-vmware-image'):",
            "                        if not self._check_if_folder_file_exists(",
            "                                ds_browser,",
            "                                data_store_ref, data_store_name,",
            "                                upload_folder,",
            "                                upload_name + \".%s.vmdk\" % root_gb):",
            "                            LOG.debug(\"Copying root disk of size %sGb\",",
            "                                      root_gb)",
            "",
            "                            # Create a copy of the base image, ensuring we",
            "                            # clean up on failure",
            "                            try:",
            "                                _copy_virtual_disk(uploaded_file_path,",
            "                                                   root_vmdk_path)",
            "                            except Exception as e:",
            "                                with excutils.save_and_reraise_exception():",
            "                                    LOG.error(_('Failed to copy cached '",
            "                                                  'image %(source)s to '",
            "                                                  '%(dest)s for resize: '",
            "                                                  '%(error)s'),",
            "                                              {'source': uploaded_file_path,",
            "                                               'dest': root_vmdk_path,",
            "                                               'error': e.message})",
            "                                    try:",
            "                                        ds_util.file_delete(self._session,",
            "                                                            root_vmdk_path,",
            "                                                            dc_info.ref)",
            "                                    except error_util.FileNotFoundException:",
            "                                        # File was never created: cleanup not",
            "                                        # required",
            "                                        pass",
            "",
            "                            # Resize the copy to the appropriate size. No need",
            "                            # for cleanup up here, as _extend_virtual_disk",
            "                            # already does it",
            "                            if root_gb_in_kb > vmdk_file_size_in_kb:",
            "                                self._extend_virtual_disk(instance,",
            "                                                          root_gb_in_kb,",
            "                                                          root_vmdk_path,",
            "                                                          dc_info.ref)",
            "",
            "            # Attach the root disk to the VM.",
            "            if root_vmdk_path:",
            "                self._volumeops.attach_disk_to_vm(",
            "                                    vm_ref, instance,",
            "                                    adapter_type, disk_type, root_vmdk_path,",
            "                                    root_gb_in_kb, linked_clone)",
            "",
            "            if is_iso:",
            "                self._attach_cdrom_to_vm(",
            "                    vm_ref, instance,",
            "                    data_store_ref,",
            "                    uploaded_file_path)",
            "",
            "            if configdrive.required_by(instance):",
            "                uploaded_iso_path = self._create_config_drive(instance,",
            "                                                              injected_files,",
            "                                                              admin_password,",
            "                                                              data_store_name,",
            "                                                              dc_info.name,",
            "                                                              instance['uuid'],",
            "                                                              cookies)",
            "                uploaded_iso_path = ds_util.build_datastore_path(",
            "                    data_store_name,",
            "                    uploaded_iso_path)",
            "                self._attach_cdrom_to_vm(",
            "                    vm_ref, instance,",
            "                    data_store_ref,",
            "                    uploaded_iso_path)",
            "",
            "        else:",
            "            # Attach the root disk to the VM.",
            "            for root_disk in block_device_mapping:",
            "                connection_info = root_disk['connection_info']",
            "                self._volumeops.attach_root_volume(connection_info, instance,",
            "                                                   self._default_root_device,",
            "                                                   data_store_ref)",
            "",
            "        def _power_on_vm():",
            "            \"\"\"Power on the VM.\"\"\"",
            "            LOG.debug(_(\"Powering on the VM instance\"), instance=instance)",
            "            # Power On the VM",
            "            power_on_task = self._session._call_method(",
            "                               self._session._get_vim(),",
            "                               \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(power_on_task)",
            "            LOG.debug(_(\"Powered on the VM instance\"), instance=instance)",
            "",
            "        if power_on:",
            "            _power_on_vm()",
            "",
            "    def _create_config_drive(self, instance, injected_files, admin_password,",
            "                             data_store_name, dc_name, upload_folder, cookies):",
            "        if CONF.config_drive_format != 'iso9660':",
            "            reason = (_('Invalid config_drive_format \"%s\"') %",
            "                      CONF.config_drive_format)",
            "            raise exception.InstancePowerOnFailure(reason=reason)",
            "",
            "        LOG.info(_('Using config drive for instance'), instance=instance)",
            "        extra_md = {}",
            "        if admin_password:",
            "            extra_md['admin_pass'] = admin_password",
            "",
            "        inst_md = instance_metadata.InstanceMetadata(instance,",
            "                                                     content=injected_files,",
            "                                                     extra_md=extra_md)",
            "        try:",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                with utils.tempdir() as tmp_path:",
            "                    tmp_file = os.path.join(tmp_path, 'configdrive.iso')",
            "                    cdb.make_drive(tmp_file)",
            "                    upload_iso_path = \"%s/configdrive.iso\" % (",
            "                        upload_folder)",
            "                    vmware_images.upload_iso_to_datastore(",
            "                        tmp_file, instance,",
            "                        host=self._session._host_ip,",
            "                        data_center_name=dc_name,",
            "                        datastore_name=data_store_name,",
            "                        cookies=cookies,",
            "                        file_path=upload_iso_path)",
            "                    return upload_iso_path",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Creating config drive failed with error: %s'),",
            "                          e, instance=instance)",
            "",
            "    def _attach_cdrom_to_vm(self, vm_ref, instance,",
            "                         datastore, file_path):",
            "        \"\"\"Attach cdrom to VM by reconfiguration.\"\"\"",
            "        instance_name = instance['name']",
            "        instance_uuid = instance['uuid']",
            "        client_factory = self._session._get_vim().client.factory",
            "        devices = self._session._call_method(vim_util,",
            "                                    \"get_dynamic_property\", vm_ref,",
            "                                    \"VirtualMachine\", \"config.hardware.device\")",
            "        (controller_key, unit_number,",
            "         controller_spec) = vm_util.allocate_controller_key_and_unit_number(",
            "                                                              client_factory,",
            "                                                              devices,",
            "                                                              'ide')",
            "        cdrom_attach_config_spec = vm_util.get_cdrom_attach_config_spec(",
            "                                    client_factory, datastore, file_path,",
            "                                    controller_key, unit_number)",
            "        if controller_spec:",
            "            cdrom_attach_config_spec.deviceChange.append(controller_spec)",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance %(instance_name)s to attach \"",
            "                    \"cdrom %(file_path)s\"),",
            "                  {'instance_name': instance_name, 'file_path': file_path})",
            "        reconfig_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"ReconfigVM_Task\", vm_ref,",
            "                                        spec=cdrom_attach_config_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance %(instance_name)s to attach \"",
            "                    \"cdrom %(file_path)s\"),",
            "                  {'instance_name': instance_name, 'file_path': file_path})",
            "",
            "    @staticmethod",
            "    def decide_linked_clone(image_linked_clone, global_linked_clone):",
            "        \"\"\"Explicit decision logic: whether to use linked clone on a vmdk.",
            "",
            "        This is *override* logic not boolean logic.",
            "",
            "        1. let the image over-ride if set at all",
            "        2. default to the global setting",
            "",
            "        In math terms, I need to allow:",
            "        glance image to override global config.",
            "",
            "        That is g vs c. \"g\" for glance. \"c\" for Config.",
            "",
            "        So, I need  g=True vs c=False to be True.",
            "        And, I need g=False vs c=True to be False.",
            "        And, I need g=None vs c=True to be True.",
            "",
            "        Some images maybe independently best tuned for use_linked_clone=True",
            "        saving datastorage space. Alternatively a whole OpenStack install may",
            "        be tuned to performance use_linked_clone=False but a single image",
            "        in this environment may be best configured to save storage space and",
            "        set use_linked_clone=True only for itself.",
            "",
            "        The point is: let each layer of control override the layer beneath it.",
            "",
            "        rationale:",
            "        For technical discussion on the clone strategies and their trade-offs",
            "        see: https://www.vmware.com/support/ws5/doc/ws_clone_typeofclone.html",
            "",
            "        :param image_linked_clone: boolean or string or None",
            "        :param global_linked_clone: boolean or string or None",
            "        :return: Boolean",
            "        \"\"\"",
            "",
            "        value = None",
            "",
            "        # Consider the values in order of override.",
            "        if image_linked_clone is not None:",
            "            value = image_linked_clone",
            "        else:",
            "            # this will never be not-set by this point.",
            "            value = global_linked_clone",
            "",
            "        return strutils.bool_from_string(value)",
            "",
            "    def get_copy_virtual_disk_spec(self, client_factory, adapter_type,",
            "                                   disk_type):",
            "        return vm_util.get_copy_virtual_disk_spec(client_factory,",
            "                                                  adapter_type,",
            "                                                  disk_type)",
            "",
            "    def _create_vm_snapshot(self, instance, vm_ref):",
            "        LOG.debug(_(\"Creating Snapshot of the VM instance\"), instance=instance)",
            "        snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"CreateSnapshot_Task\", vm_ref,",
            "                    name=\"%s-snapshot\" % instance['uuid'],",
            "                    description=\"Taking Snapshot of the VM\",",
            "                    memory=False,",
            "                    quiesce=True)",
            "        self._session._wait_for_task(snapshot_task)",
            "        LOG.debug(_(\"Created Snapshot of the VM instance\"), instance=instance)",
            "        task_info = self._session._call_method(vim_util,",
            "                                               \"get_dynamic_property\",",
            "                                               snapshot_task, \"Task\", \"info\")",
            "        snapshot = task_info.result",
            "        return snapshot",
            "",
            "    def _delete_vm_snapshot(self, instance, vm_ref, snapshot):",
            "        LOG.debug(_(\"Deleting Snapshot of the VM instance\"), instance=instance)",
            "        delete_snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"RemoveSnapshot_Task\", snapshot,",
            "                    removeChildren=False, consolidate=True)",
            "        self._session._wait_for_task(delete_snapshot_task)",
            "        LOG.debug(_(\"Deleted Snapshot of the VM instance\"), instance=instance)",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Get the name of the vmdk file which the VM points to right now.",
            "           Can be a chain of snapshots, so we need to know the last in the",
            "           chain.",
            "        2. Create the snapshot. A new vmdk is created which the VM points to",
            "           now. The earlier vmdk becomes read-only.",
            "        3. Call CopyVirtualDisk which coalesces the disk chain to form a single",
            "           vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file.",
            "        4. Now upload the -flat.vmdk file to the image store.",
            "        5. Delete the coalesced .vmdk and -flat.vmdk created.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        client_factory = self._session._get_vim().client.factory",
            "        service_content = self._session._get_vim().get_service_content()",
            "",
            "        def _get_vm_and_vmdk_attribs():",
            "            # Get the vmdk file name that the VM is pointing to",
            "            hw_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "            (vmdk_file_path_before_snapshot, adapter_type,",
            "             disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                                        hw_devices, uuid=instance['uuid'])",
            "            if not vmdk_file_path_before_snapshot:",
            "                LOG.debug(\"No root disk defined. Unable to snapshot.\")",
            "                raise error_util.NoRootDiskDefined()",
            "",
            "            datastore_name = ds_util.split_datastore_path(",
            "                                        vmdk_file_path_before_snapshot)[0]",
            "            os_type = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"summary.config.guestId\")",
            "            return (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "                    datastore_name, os_type)",
            "",
            "        (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "         datastore_name, os_type) = _get_vm_and_vmdk_attribs()",
            "",
            "        snapshot = self._create_vm_snapshot(instance, vm_ref)",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        def _check_if_tmp_folder_exists():",
            "            # Copy the contents of the VM that were there just before the",
            "            # snapshot was taken",
            "            ds_ref_ret = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", vm_ref, \"VirtualMachine\",",
            "                \"datastore\")",
            "            if ds_ref_ret is None:",
            "                raise exception.DatastoreNotFound()",
            "            ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "            self.check_temp_folder(datastore_name, ds_ref)",
            "            return ds_ref",
            "",
            "        ds_ref = _check_if_tmp_folder_exists()",
            "",
            "        # Generate a random vmdk file name to which the coalesced vmdk content",
            "        # will be copied to. A random name is chosen so that we don't have",
            "        # name clashes.",
            "        random_name = uuidutils.generate_uuid()",
            "        dest_vmdk_file_path = ds_util.build_datastore_path(datastore_name,",
            "                   \"%s/%s.vmdk\" % (self._tmp_folder, random_name))",
            "        dest_vmdk_data_file_path = ds_util.build_datastore_path(datastore_name,",
            "                   \"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "",
            "        def _copy_vmdk_content():",
            "            # Consolidate the snapshotted disk to a temporary vmdk.",
            "            copy_spec = self.get_copy_virtual_disk_spec(client_factory,",
            "                                                        adapter_type,",
            "                                                        disk_type)",
            "            LOG.debug(_('Copying snapshotted disk %s.'),",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "            copy_disk_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=vmdk_file_path_before_snapshot,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=dest_vmdk_file_path,",
            "                destDatacenter=dc_info.ref,",
            "                destSpec=copy_spec,",
            "                force=False)",
            "            self._session._wait_for_task(copy_disk_task)",
            "            LOG.debug(_('Copied snapshotted disk %s.'),",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "",
            "        _copy_vmdk_content()",
            "        # Note(vui): handle snapshot cleanup on exceptions.",
            "        self._delete_vm_snapshot(instance, vm_ref, snapshot)",
            "",
            "        cookies = self._session._get_vim().client.options.transport.cookiejar",
            "",
            "        def _upload_vmdk_to_image_repository():",
            "            # Upload the contents of -flat.vmdk file which has the disk data.",
            "            LOG.debug(_(\"Uploading image %s\") % image_id,",
            "                      instance=instance)",
            "            vmware_images.upload_image(",
            "                context,",
            "                image_id,",
            "                instance,",
            "                os_type=os_type,",
            "                disk_type=\"preallocated\",",
            "                adapter_type=adapter_type,",
            "                image_version=1,",
            "                host=self._session._host_ip,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=datastore_name,",
            "                cookies=cookies,",
            "                file_path=\"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "            LOG.debug(_(\"Uploaded image %s\") % image_id,",
            "                      instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                          expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "        _upload_vmdk_to_image_repository()",
            "",
            "        def _clean_temp_data():",
            "            \"\"\"Delete temporary vmdk files generated in image handling",
            "            operations.",
            "            \"\"\"",
            "            # The data file is the one occupying space, and likelier to see",
            "            # deletion problems, so prioritize its deletion first. In the",
            "            # unlikely event that its deletion fails, the small descriptor file",
            "            # is retained too by design since it makes little sense to remove",
            "            # it when the data disk it refers to still lingers.",
            "            for f in dest_vmdk_data_file_path, dest_vmdk_file_path:",
            "                self._delete_datastore_file(instance, f, dc_info.ref)",
            "",
            "        _clean_temp_data()",
            "",
            "    def _get_values_from_object_properties(self, props, query):",
            "        while props:",
            "            token = vm_util._get_token(props)",
            "            for elem in props.objects:",
            "                for prop in elem.propSet:",
            "                    for key in query.keys():",
            "                        if prop.name == key:",
            "                            query[key] = prop.val",
            "                            break",
            "            if token:",
            "                props = self._session._call_method(vim_util,",
            "                                                   \"continue_to_get_objects\",",
            "                                                   token)",
            "            else:",
            "                break",
            "",
            "    def reboot(self, instance, network_info):",
            "        \"\"\"Reboot a VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.guest.toolsStatus\", \"runtime.powerState\",",
            "                          \"summary.guest.toolsRunningStatus\"]",
            "        props = self._session._call_method(vim_util, \"get_object_properties\",",
            "                           None, vm_ref, \"VirtualMachine\",",
            "                           lst_properties)",
            "        query = {'runtime.powerState': None,",
            "                 'summary.guest.toolsStatus': None,",
            "                 'summary.guest.toolsRunningStatus': False}",
            "        self._get_values_from_object_properties(props, query)",
            "        pwr_state = query['runtime.powerState']",
            "        tools_status = query['summary.guest.toolsStatus']",
            "        tools_running_status = query['summary.guest.toolsRunningStatus']",
            "",
            "        # Raise an exception if the VM is not powered On.",
            "        if pwr_state not in [\"poweredOn\"]:",
            "            reason = _(\"instance is not powered on\")",
            "            raise exception.InstanceRebootFailure(reason=reason)",
            "",
            "        # If latest vmware tools are installed in the VM, and that the tools",
            "        # are running, then only do a guest reboot. Otherwise do a hard reset.",
            "        if (tools_status == \"toolsOk\" and",
            "                tools_running_status == \"guestToolsRunning\"):",
            "            LOG.debug(_(\"Rebooting guest OS of VM\"), instance=instance)",
            "            self._session._call_method(self._session._get_vim(), \"RebootGuest\",",
            "                                       vm_ref)",
            "            LOG.debug(_(\"Rebooted guest OS of VM\"), instance=instance)",
            "        else:",
            "            LOG.debug(_(\"Doing hard reboot of VM\"), instance=instance)",
            "            reset_task = self._session._call_method(self._session._get_vim(),",
            "                                                    \"ResetVM_Task\", vm_ref)",
            "            self._session._wait_for_task(reset_task)",
            "            LOG.debug(_(\"Did hard reboot of VM\"), instance=instance)",
            "",
            "    def _delete(self, instance, network_info):",
            "        \"\"\"Destroy a VM instance. Steps followed are:",
            "        1. Power off the VM, if it is in poweredOn state.",
            "        2. Destroy the VM.",
            "        \"\"\"",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "            self.power_off(instance)",
            "            try:",
            "                LOG.debug(_(\"Destroying the VM\"), instance=instance)",
            "                destroy_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"Destroy_Task\", vm_ref)",
            "                self._session._wait_for_task(destroy_task)",
            "                LOG.debug(_(\"Destroyed the VM\"), instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:delete, got this exception\"",
            "                           \" while destroying the VM: %s\") % str(excep))",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "",
            "    def _destroy_instance(self, instance, network_info, destroy_disks=True,",
            "                          instance_name=None):",
            "        # Destroy a VM instance",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if not instance_name:",
            "            instance_name = instance['uuid']",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session, instance_name)",
            "            lst_properties = [\"config.files.vmPathName\", \"runtime.powerState\",",
            "                              \"datastore\"]",
            "            props = self._session._call_method(vim_util,",
            "                        \"get_object_properties\",",
            "                        None, vm_ref, \"VirtualMachine\", lst_properties)",
            "            query = {'runtime.powerState': None,",
            "                     'config.files.vmPathName': None,",
            "                     'datastore': None}",
            "            self._get_values_from_object_properties(props, query)",
            "            pwr_state = query['runtime.powerState']",
            "            vm_config_pathname = query['config.files.vmPathName']",
            "            datastore_name = None",
            "            if vm_config_pathname:",
            "                _ds_path = ds_util.split_datastore_path(vm_config_pathname)",
            "                datastore_name, vmx_file_path = _ds_path",
            "            # Power off the VM if it is in PoweredOn state.",
            "            if pwr_state == \"poweredOn\":",
            "                LOG.debug(_(\"Powering off the VM\"), instance=instance)",
            "                poweroff_task = self._session._call_method(",
            "                       self._session._get_vim(),",
            "                       \"PowerOffVM_Task\", vm_ref)",
            "                self._session._wait_for_task(poweroff_task)",
            "                LOG.debug(_(\"Powered off the VM\"), instance=instance)",
            "",
            "            # Un-register the VM",
            "            try:",
            "                LOG.debug(_(\"Unregistering the VM\"), instance=instance)",
            "                self._session._call_method(self._session._get_vim(),",
            "                                           \"UnregisterVM\", vm_ref)",
            "                LOG.debug(_(\"Unregistered the VM\"), instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, got this \"",
            "                           \"exception while un-registering the VM: %s\"),",
            "                         excep)",
            "            # Delete the folder holding the VM related content on",
            "            # the datastore.",
            "            if destroy_disks and datastore_name:",
            "                try:",
            "                    dir_ds_compliant_path = ds_util.build_datastore_path(",
            "                                     datastore_name,",
            "                                     os.path.dirname(vmx_file_path))",
            "                    LOG.debug(_(\"Deleting contents of the VM from \"",
            "                                \"datastore %(datastore_name)s\") %",
            "                               {'datastore_name': datastore_name},",
            "                              instance=instance)",
            "                    ds_ref_ret = query['datastore']",
            "                    ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "                    dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "                    ds_util.file_delete(self._session,",
            "                                        dir_ds_compliant_path,",
            "                                        dc_info.ref)",
            "                    LOG.debug(_(\"Deleted contents of the VM from \"",
            "                                \"datastore %(datastore_name)s\") %",
            "                               {'datastore_name': datastore_name},",
            "                              instance=instance)",
            "                except Exception as excep:",
            "                    LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, \"",
            "                                \"got this exception while deleting \"",
            "                                \"the VM contents from the disk: %s\"),",
            "                             excep)",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "        finally:",
            "            vm_util.vm_ref_cache_delete(instance_name)",
            "",
            "    def destroy(self, instance, network_info, destroy_disks=True):",
            "        \"\"\"Destroy a VM instance.",
            "",
            "        Steps followed for each VM are:",
            "        1. Power off, if it is in poweredOn state.",
            "        2. Un-register.",
            "        3. Delete the contents of the folder holding the VM related data.",
            "        \"\"\"",
            "        # If there is a rescue VM then we need to destroy that one too.",
            "        LOG.debug(_(\"Destroying instance\"), instance=instance)",
            "        if instance['vm_state'] == vm_states.RESCUED:",
            "            LOG.debug(_(\"Rescue VM configured\"), instance=instance)",
            "            try:",
            "                self.unrescue(instance, power_on=False)",
            "                LOG.debug(_(\"Rescue VM destroyed\"), instance=instance)",
            "            except Exception:",
            "                rescue_name = instance['uuid'] + self._rescue_suffix",
            "                self._destroy_instance(instance, network_info,",
            "                                       destroy_disks=destroy_disks,",
            "                                       instance_name=rescue_name)",
            "        # NOTE(arnaud): Destroy uuid-orig and uuid VMs iff it is not",
            "        # triggered by the revert resize api call. This prevents",
            "        # the uuid-orig VM to be deleted to be able to associate it later.",
            "        if instance['task_state'] != task_states.RESIZE_REVERTING:",
            "            # When VM deletion is triggered in middle of VM resize before VM",
            "            # arrive RESIZED state, uuid-orig VM need to deleted to avoid",
            "            # VM leak. Within method _destroy_instance it will check vmref",
            "            # exist or not before attempt deletion.",
            "            resize_orig_vmname = instance['uuid'] + self._migrate_suffix",
            "            vm_orig_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                       resize_orig_vmname)",
            "            if vm_orig_ref:",
            "                self._destroy_instance(instance, network_info,",
            "                                       destroy_disks=destroy_disks,",
            "                                       instance_name=resize_orig_vmname)",
            "        self._destroy_instance(instance, network_info,",
            "                               destroy_disks=destroy_disks)",
            "        LOG.debug(_(\"Instance destroyed\"), instance=instance)",
            "",
            "    def pause(self, instance):",
            "        msg = _(\"pause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def unpause(self, instance):",
            "        msg = _(\"unpause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def suspend(self, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be suspended.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"Suspending the VM\"), instance=instance)",
            "            suspend_task = self._session._call_method(self._session._get_vim(),",
            "                    \"SuspendVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(_(\"Suspended the VM\"), instance=instance)",
            "        # Raise Exception if VM is poweredOff",
            "        elif pwr_state == \"poweredOff\":",
            "            reason = _(\"instance is powered off and cannot be suspended.\")",
            "            raise exception.InstanceSuspendFailure(reason=reason)",
            "        else:",
            "            LOG.debug(_(\"VM was already in suspended state. So returning \"",
            "                      \"without doing anything\"), instance=instance)",
            "",
            "    def resume(self, instance):",
            "        \"\"\"Resume the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state.lower() == \"suspended\":",
            "            LOG.debug(_(\"Resuming the VM\"), instance=instance)",
            "            suspend_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                       \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(_(\"Resumed the VM\"), instance=instance)",
            "        else:",
            "            reason = _(\"instance is not in a suspended state\")",
            "            raise exception.InstanceResumeFailure(reason=reason)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta):",
            "        \"\"\"Rescue the specified instance.",
            "",
            "            - shutdown the instance VM.",
            "            - spawn a rescue VM (the vm name-label will be instance-N-rescue).",
            "",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        self.power_off(instance)",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance['uuid'] + self._rescue_suffix",
            "        self.spawn(context, r_instance, image_meta,",
            "                   None, None, network_info,",
            "                   instance_name=instance_name,",
            "                   power_on=False)",
            "",
            "        # Attach vmdk to the rescue VM",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance['uuid'])",
            "        rescue_vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        self._volumeops.attach_disk_to_vm(",
            "                                rescue_vm_ref, r_instance,",
            "                                adapter_type, disk_type, vmdk_path)",
            "        self._power_on(instance, vm_ref=rescue_vm_ref)",
            "",
            "    def unrescue(self, instance, power_on=True):",
            "        \"\"\"Unrescue the specified instance.\"\"\"",
            "        # Get the original vmdk_path",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance['uuid'])",
            "",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance['uuid'] + self._rescue_suffix",
            "        # detach the original instance disk from the rescue disk",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_rescue_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        device = vm_util.get_vmdk_volume_disk(hardware_devices, path=vmdk_path)",
            "        self._power_off_vm_ref(vm_rescue_ref)",
            "        self._volumeops.detach_disk_from_vm(vm_rescue_ref, r_instance, device)",
            "        self._destroy_instance(r_instance, None, instance_name=instance_name)",
            "        if power_on:",
            "            self._power_on(instance)",
            "",
            "    def _power_off_vm_ref(self, vm_ref):",
            "        \"\"\"Power off the specifed vm.",
            "",
            "        :param vm_ref: a reference object to the VM.",
            "        \"\"\"",
            "        poweroff_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"PowerOffVM_Task\", vm_ref)",
            "        self._session._wait_for_task(poweroff_task)",
            "",
            "    def power_off(self, instance):",
            "        \"\"\"Power off the specified instance.",
            "",
            "        :param instance: nova.objects.instance.Instance",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be powered off.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"Powering off the VM\"), instance=instance)",
            "            self._power_off_vm_ref(vm_ref)",
            "            LOG.debug(_(\"Powered off the VM\"), instance=instance)",
            "        # Raise Exception if VM is suspended",
            "        elif pwr_state == \"suspended\":",
            "            reason = _(\"instance is suspended and cannot be powered off.\")",
            "            raise exception.InstancePowerOffFailure(reason=reason)",
            "        else:",
            "            LOG.debug(_(\"VM was already in powered off state. So returning \"",
            "                        \"without doing anything\"), instance=instance)",
            "",
            "    def _power_on(self, instance, vm_ref=None):",
            "        \"\"\"Power on the specified instance.\"\"\"",
            "        if not vm_ref:",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(_(\"VM was already in powered on state. So returning \"",
            "                      \"without doing anything\"), instance=instance)",
            "        # Only PoweredOff and Suspended VMs can be powered on.",
            "        else:",
            "            LOG.debug(_(\"Powering on the VM\"), instance=instance)",
            "            poweron_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(poweron_task)",
            "            LOG.debug(_(\"Powered on the VM\"), instance=instance)",
            "",
            "    def power_on(self, context, instance, network_info, block_device_info):",
            "        self._power_on(instance)",
            "",
            "    def _get_orig_vm_name_label(self, instance):",
            "        return instance['uuid'] + '-orig'",
            "",
            "    def _update_instance_progress(self, context, instance, step, total_steps):",
            "        \"\"\"Update instance progress percent to reflect current step number",
            "        \"\"\"",
            "        # Divide the action's workflow into discrete steps and \"bump\" the",
            "        # instance's progress field as each step is completed.",
            "        #",
            "        # For a first cut this should be fine, however, for large VM images,",
            "        # the clone disk step begins to dominate the equation. A",
            "        # better approximation would use the percentage of the VM image that",
            "        # has been streamed to the destination host.",
            "        progress = round(float(step) / total_steps * 100)",
            "        instance_uuid = instance['uuid']",
            "        LOG.debug(_(\"Updating instance '%(instance_uuid)s' progress to\"",
            "                    \" %(progress)d\"),",
            "                  {'instance_uuid': instance_uuid, 'progress': progress},",
            "                  instance=instance)",
            "        self._virtapi.instance_update(context, instance_uuid,",
            "                                      {'progress': progress})",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor):",
            "        \"\"\"Transfers the disk of a running instance in multiple phases, turning",
            "        off the instance before the end.",
            "        \"\"\"",
            "        # 0. Zero out the progress to begin",
            "        self._update_instance_progress(context, instance,",
            "                                       step=0,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Read the host_ref for the destination. If this is None then the",
            "        # VC will decide on placement",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "",
            "        # 1. Power off the instance",
            "        self.power_off(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=1,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        # 2. Disassociate the linked vsphere VM from the instance",
            "        vm_util.disassociate_vmref_from_instance(self._session, instance,",
            "                                                 vm_ref,",
            "                                                 suffix=self._migrate_suffix)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=2,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        ds_ref = vm_util.get_datastore_ref_and_name(",
            "                            self._session, self._cluster, host_ref,",
            "                            datastore_regex=self._datastore_regex)[0]",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        # 3. Clone the VM for instance",
            "        vm_util.clone_vmref_for_instance(self._session, instance, vm_ref,",
            "                                         host_ref, ds_ref, dc_info.vmFolder)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=3,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        # Destroy the original VM. The vm_ref needs to be searched using the",
            "        # instance['uuid'] + self._migrate_suffix as the identifier. We will",
            "        # not get the vm when searched using the instanceUuid but rather will",
            "        # be found using the uuid buried in the extraConfig",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self._session,",
            "                                    instance['uuid'] + self._migrate_suffix)",
            "        if vm_ref is None:",
            "            LOG.debug(_(\"instance not present\"), instance=instance)",
            "            return",
            "",
            "        try:",
            "            LOG.debug(_(\"Destroying the VM\"), instance=instance)",
            "            destroy_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"Destroy_Task\", vm_ref)",
            "            self._session._wait_for_task(destroy_task)",
            "            LOG.debug(_(\"Destroyed the VM\"), instance=instance)",
            "        except Exception as excep:",
            "            LOG.warn(_(\"In vmwareapi:vmops:confirm_migration, got this \"",
            "                     \"exception while destroying the VM: %s\") % str(excep))",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info, power_on=True):",
            "        \"\"\"Finish reverting a resize.\"\"\"",
            "        vm_util.associate_vmref_for_instance(self._session, instance,",
            "                                             suffix=self._migrate_suffix)",
            "        if power_on:",
            "            self._power_on(instance)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance=False,",
            "                         block_device_info=None, power_on=True):",
            "        \"\"\"Completes a resize, turning on the migrated instance.\"\"\"",
            "        if resize_instance:",
            "            client_factory = self._session._get_vim().client.factory",
            "            vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "            vm_resize_spec = vm_util.get_vm_resize_spec(client_factory,",
            "                                                        instance)",
            "            reconfig_task = self._session._call_method(",
            "                                            self._session._get_vim(),",
            "                                            \"ReconfigVM_Task\", vm_ref,",
            "                                            spec=vm_resize_spec)",
            "            self._session._wait_for_task(reconfig_task)",
            "",
            "        # 4. Start VM",
            "        if power_on:",
            "            self._power_on(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=4,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def live_migration(self, context, instance_ref, dest,",
            "                       post_method, recover_method, block_migration=False):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance_ref)",
            "",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "        if host_ref is None:",
            "            raise exception.HostNotFound(host=dest)",
            "",
            "        LOG.debug(_(\"Migrating VM to host %s\") % dest, instance=instance_ref)",
            "        try:",
            "            vm_migrate_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"MigrateVM_Task\", vm_ref,",
            "                                    host=host_ref,",
            "                                    priority=\"defaultPriority\")",
            "            self._session._wait_for_task(vm_migrate_task)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                recover_method(context, instance_ref, dest, block_migration)",
            "        post_method(context, instance_ref, dest, block_migration)",
            "        LOG.debug(_(\"Migrated VM to host %s\") % dest, instance=instance_ref)",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        \"\"\"Poll for rebooting instances.\"\"\"",
            "        ctxt = nova_context.get_admin_context()",
            "",
            "        instances_info = dict(instance_count=len(instances),",
            "                timeout=timeout)",
            "",
            "        if instances_info[\"instance_count\"] > 0:",
            "            LOG.info(_(\"Found %(instance_count)d hung reboots \"",
            "                    \"older than %(timeout)d seconds\") % instances_info)",
            "",
            "        for instance in instances:",
            "            LOG.info(_(\"Automatically hard rebooting\"), instance=instance)",
            "            self.compute_api.reboot(ctxt, instance, \"HARD\")",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Return data about the VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        lst_properties = [\"summary.config.numCpu\",",
            "                    \"summary.config.memorySizeMB\",",
            "                    \"runtime.powerState\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = {'summary.config.numCpu': 0,",
            "                 'summary.config.memorySizeMB': 0,",
            "                 'runtime.powerState': None}",
            "        self._get_values_from_object_properties(vm_props, query)",
            "        max_mem = int(query['summary.config.memorySizeMB']) * 1024",
            "        return {'state': VMWARE_POWER_STATES[query['runtime.powerState']],",
            "                'max_mem': max_mem,",
            "                'mem': max_mem,",
            "                'num_cpu': int(query['summary.config.numCpu']),",
            "                'cpu_time': 0}",
            "",
            "    def _get_diagnostic_from_object_properties(self, props, wanted_props):",
            "        diagnostics = {}",
            "        while props:",
            "            for elem in props.objects:",
            "                for prop in elem.propSet:",
            "                    if prop.name in wanted_props:",
            "                        prop_dict = vim.object_to_dict(prop.val, list_depth=1)",
            "                        diagnostics.update(prop_dict)",
            "            token = vm_util._get_token(props)",
            "            if not token:",
            "                break",
            "",
            "            props = self._session._call_method(vim_util,",
            "                                               \"continue_to_get_objects\",",
            "                                               token)",
            "        return diagnostics",
            "",
            "    def get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.config\",",
            "                          \"summary.quickStats\",",
            "                          \"summary.runtime\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        data = self._get_diagnostic_from_object_properties(vm_props,",
            "                                                           set(lst_properties))",
            "        # Add a namespace to all of the diagnostsics",
            "        return dict([('vmware:' + k, v) for k, v in data.items()])",
            "",
            "    def get_vnc_console(self, instance):",
            "        \"\"\"Return connection info for a vnc console.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        opt_value = self._session._call_method(vim_util,",
            "                               'get_dynamic_property',",
            "                               vm_ref, 'VirtualMachine',",
            "                               vm_util.VNC_CONFIG_KEY)",
            "        if opt_value:",
            "            port = int(opt_value.value)",
            "        else:",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        return {'host': CONF.vmware.host_ip,",
            "                'port': port,",
            "                'internal_access_path': None}",
            "",
            "    def get_vnc_console_vcenter(self, instance):",
            "        \"\"\"Return connection info for a vnc console using vCenter logic.\"\"\"",
            "",
            "        # vCenter does not run virtual machines and does not run",
            "        # a VNC proxy. Instead, you need to tell OpenStack to talk",
            "        # directly to the ESX host running the VM you are attempting",
            "        # to connect to via VNC.",
            "",
            "        vnc_console = self.get_vnc_console(instance)",
            "        host_name = vm_util.get_host_name_for_vm(",
            "                        self._session,",
            "                        instance)",
            "        vnc_console['host'] = host_name",
            "",
            "        # NOTE: VM can move hosts in some situations. Debug for admins.",
            "        LOG.debug(_(\"VM %(uuid)s is currently on host %(host_name)s\"),",
            "                {'uuid': instance['name'], 'host_name': host_name})",
            "",
            "        return vnc_console",
            "",
            "    @staticmethod",
            "    def _get_machine_id_str(network_info):",
            "        machine_id_str = ''",
            "        for vif in network_info:",
            "            # TODO(vish): add support for dns2",
            "            # TODO(sateesh): add support for injection of ipv6 configuration",
            "            network = vif['network']",
            "            ip_v4 = netmask_v4 = gateway_v4 = broadcast_v4 = dns = None",
            "            subnets_v4 = [s for s in network['subnets'] if s['version'] == 4]",
            "            if len(subnets_v4) > 0:",
            "                if len(subnets_v4[0]['ips']) > 0:",
            "                    ip_v4 = subnets_v4[0]['ips'][0]",
            "                if len(subnets_v4[0]['dns']) > 0:",
            "                    dns = subnets_v4[0]['dns'][0]['address']",
            "",
            "                netmask_v4 = str(subnets_v4[0].as_netaddr().netmask)",
            "                gateway_v4 = subnets_v4[0]['gateway']['address']",
            "                broadcast_v4 = str(subnets_v4[0].as_netaddr().broadcast)",
            "",
            "            interface_str = \";\".join([vif['address'],",
            "                                      ip_v4 and ip_v4['address'] or '',",
            "                                      netmask_v4 or '',",
            "                                      gateway_v4 or '',",
            "                                      broadcast_v4 or '',",
            "                                      dns or ''])",
            "            machine_id_str = machine_id_str + interface_str + '#'",
            "        return machine_id_str",
            "",
            "    def _set_machine_id(self, client_factory, instance, network_info):",
            "        \"\"\"Set the machine id of the VM for guest tools to pick up",
            "        and reconfigure the network interfaces.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        machine_id_change_spec = vm_util.get_machine_id_change_spec(",
            "                                 client_factory,",
            "                                 self._get_machine_id_str(network_info))",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance to set the machine id\"),",
            "                  instance=instance)",
            "        reconfig_task = self._session._call_method(self._session._get_vim(),",
            "                           \"ReconfigVM_Task\", vm_ref,",
            "                           spec=machine_id_change_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance to set the machine id\"),",
            "                  instance=instance)",
            "",
            "    def _set_vnc_config(self, client_factory, instance, port):",
            "        \"\"\"Set the vnc configuration of the VM.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        vnc_config_spec = vm_util.get_vnc_config_spec(",
            "                                      client_factory, port)",
            "",
            "        LOG.debug(_(\"Reconfiguring VM instance to enable vnc on \"",
            "                  \"port - %(port)s\") % {'port': port},",
            "                  instance=instance)",
            "        reconfig_task = self._session._call_method(self._session._get_vim(),",
            "                           \"ReconfigVM_Task\", vm_ref,",
            "                           spec=vnc_config_spec)",
            "        self._session._wait_for_task(reconfig_task)",
            "        LOG.debug(_(\"Reconfigured VM instance to enable vnc on \"",
            "                  \"port - %(port)s\") % {'port': port},",
            "                  instance=instance)",
            "",
            "    def _get_ds_browser(self, ds_ref):",
            "        ds_browser = self._datastore_browser_mapping.get(ds_ref.value)",
            "        if not ds_browser:",
            "            ds_browser = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", ds_ref, \"Datastore\",",
            "                \"browser\")",
            "            self._datastore_browser_mapping[ds_ref.value] = ds_browser",
            "        return ds_browser",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        map = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not map:",
            "            dc_obj = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\"])",
            "            vm_util._cancel_retrieve_if_necessary(self._session, dc_obj)",
            "            map = DcInfo(ref=dc_obj.objects[0].obj,",
            "                         name=dc_obj.objects[0].propSet[0].val,",
            "                         vmFolder=self._get_vmfolder_ref())",
            "            self._datastore_dc_mapping[ds_ref.value] = map",
            "        return map",
            "",
            "    def _get_host_ref_from_name(self, host_name):",
            "        \"\"\"Get reference to the host with the name specified.\"\"\"",
            "        host_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"HostSystem\", [\"name\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, host_objs)",
            "        for host in host_objs:",
            "            if hasattr(host, 'propSet'):",
            "                if host.propSet[0].val == host_name:",
            "                    return host.obj",
            "        return None",
            "",
            "    def _get_vmfolder_ref(self):",
            "        \"\"\"Get the Vm folder ref from the datacenter.\"\"\"",
            "        dc_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                                             \"Datacenter\", [\"vmFolder\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, dc_objs)",
            "        # There is only one default datacenter in a standalone ESX host",
            "        vm_folder_ref = dc_objs.objects[0].propSet[0].val",
            "        return vm_folder_ref",
            "",
            "    def _create_folder_if_missing(self, ds_name, ds_ref, folder):",
            "        \"\"\"Create a folder if it does not exist.",
            "",
            "        Currently there are two folder that are required on the datastore",
            "         - base folder - the folder to store cached images",
            "         - temp folder - the folder used for snapshot management and",
            "                         image uploading",
            "        This method is aimed to be used for the management of those",
            "        folders to ensure that they are created if they are missing.",
            "        The ds_util method mkdir will be used to check if the folder",
            "        exists. If this throws and exception 'FileAlreadyExistsException'",
            "        then the folder already exists on the datastore.",
            "        \"\"\"",
            "        path = ds_util.build_datastore_path(ds_name, folder)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        try:",
            "            ds_util.mkdir(self._session, path, dc_info.ref)",
            "            LOG.debug(_(\"Folder %s created.\"), path)",
            "        except error_util.FileAlreadyExistsException:",
            "            # NOTE(hartsocks): if the folder already exists, that",
            "            # just means the folder was prepped by another process.",
            "            pass",
            "",
            "    def check_cache_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the cache folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._base_folder)",
            "",
            "    def check_temp_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the temp folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._tmp_folder)",
            "",
            "    def _check_if_folder_file_exists(self, ds_browser, ds_ref, ds_name,",
            "                                     folder_name, file_name):",
            "        # Ensure that the cache folder exists",
            "        self.check_cache_folder(ds_name, ds_ref)",
            "        # Check if the file exists or not.",
            "        folder_path = ds_util.build_datastore_path(ds_name, folder_name)",
            "        file_exists = ds_util.file_exists(self._session, ds_browser,",
            "                                          folder_path, file_name)",
            "        return file_exists",
            "",
            "    def inject_network_info(self, instance, network_info):",
            "        \"\"\"inject network info for specified instance.\"\"\"",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        client_factory = self._session._get_vim().client.factory",
            "        self._set_machine_id(client_factory, instance, network_info)",
            "",
            "    def manage_image_cache(self, context, instances):",
            "        if not CONF.remove_unused_base_images:",
            "            LOG.debug(_(\"Image aging disabled. Aging will not be done.\"))",
            "            return",
            "",
            "        datastores = vm_util.get_available_datastores(self._session,",
            "                                                      self._cluster,",
            "                                                      self._datastore_regex)",
            "        datastores_info = []",
            "        for ds in datastores:",
            "            ds_info = self.get_datacenter_ref_and_name(ds['ref'])",
            "            datastores_info.append((ds, ds_info))",
            "        self._imagecache.update(context, instances, datastores_info)",
            "",
            "    def _get_valid_vms_from_retrieve_result(self, retrieve_result):",
            "        \"\"\"Returns list of valid vms from RetrieveResult object.\"\"\"",
            "        lst_vm_names = []",
            "",
            "        while retrieve_result:",
            "            token = vm_util._get_token(retrieve_result)",
            "            for vm in retrieve_result.objects:",
            "                vm_name = None",
            "                conn_state = None",
            "                for prop in vm.propSet:",
            "                    if prop.name == \"name\":",
            "                        vm_name = prop.val",
            "                    elif prop.name == \"runtime.connectionState\":",
            "                        conn_state = prop.val",
            "                # Ignoring the orphaned or inaccessible VMs",
            "                if conn_state not in [\"orphaned\", \"inaccessible\"]:",
            "                    lst_vm_names.append(vm_name)",
            "            if token:",
            "                retrieve_result = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "        return lst_vm_names",
            "",
            "",
            "class VMwareVCVMOps(VMwareVMOps):",
            "    \"\"\"Management class for VM-related tasks.",
            "",
            "    Contains specializations to account for differences in vSphere API behavior",
            "    when invoked on Virtual Center instead of ESX host.",
            "    \"\"\"",
            "",
            "    def get_copy_virtual_disk_spec(self, client_factory, adapter_type,",
            "                                   disk_type):",
            "        LOG.debug(_(\"Will copy while retaining adapter type \"",
            "                    \"%(adapter_type)s and disk type %(disk_type)s\") %",
            "                    {\"disk_type\": disk_type,",
            "                     \"adapter_type\": adapter_type})",
            "        # Passing of the destination copy spec is not supported when",
            "        # VirtualDiskManager.CopyVirtualDisk is called on VC. The behavior of a",
            "        # spec-less copy is to consolidate to the target disk while keeping its",
            "        # disk and adapter type unchanged.",
            "",
            "    def _update_datacenter_cache_from_objects(self, dcs):",
            "        \"\"\"Updates the datastore/datacenter cache.\"\"\"",
            "",
            "        while dcs:",
            "            token = vm_util._get_token(dcs)",
            "            for dco in dcs.objects:",
            "                dc_ref = dco.obj",
            "                ds_refs = []",
            "                prop_dict = vm_util.propset_dict(dco.propSet)",
            "                name = prop_dict.get('name')",
            "                vmFolder = prop_dict.get('vmFolder')",
            "                datastore_refs = prop_dict.get('datastore')",
            "                if datastore_refs:",
            "                    datastore_refs = datastore_refs.ManagedObjectReference",
            "                    for ds in datastore_refs:",
            "                        ds_refs.append(ds.value)",
            "                else:",
            "                    LOG.debug(\"Datacenter %s doesn't have any datastore \"",
            "                              \"associated with it, ignoring it\", name)",
            "                for ds_ref in ds_refs:",
            "                    self._datastore_dc_mapping[ds_ref] = DcInfo(ref=dc_ref,",
            "                            name=name, vmFolder=vmFolder)",
            "",
            "            if token:",
            "                dcs = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not dc_info:",
            "            dcs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\", \"datastore\", \"vmFolder\"])",
            "            self._update_datacenter_cache_from_objects(dcs)",
            "            dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        return dc_info",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with vCenter cluster.\"\"\"",
            "        properties = ['name', 'runtime.connectionState']",
            "        LOG.debug(_(\"Getting list of instances from cluster %s\"),",
            "                  self._cluster)",
            "        vms = []",
            "        root_res_pool = self._session._call_method(",
            "            vim_util, \"get_dynamic_property\", self._cluster,",
            "            'ClusterComputeResource', 'resourcePool')",
            "        if root_res_pool:",
            "            vms = self._session._call_method(",
            "                vim_util, 'get_inner_objects', root_res_pool, 'vm',",
            "                'VirtualMachine', properties)",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(_(\"Got total of %s instances\") % str(len(lst_vm_names)))",
            "        return lst_vm_names"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "omeroweb.webclient.views"
        ]
    }
}