{
    "sydent/http/servlets/store_invite_servlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from sydent.db.invite_tokens import JoinTokenStore"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from sydent.db.threepid_associations import GlobalAssociationStore"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.http.servlets import get_args, send_cors, jsonwrap"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+from sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from sydent.http.auth import authV2"
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from sydent.util.emailutils import sendEmail"
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "9": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " class StoreInviteServlet(Resource):"
            },
            "10": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     def __init__(self, syd, require_auth=False):"
            },
            "11": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         self.sydent = syd"
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     def render_POST(self, request):"
            },
            "13": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         send_cors(request)"
            },
            "14": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.require_auth:"
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            authV2(self.sydent, request)"
            },
            "17": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))"
            },
            "19": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         medium = args[\"medium\"]"
            },
            "20": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         address = args[\"address\"]"
            },
            "21": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         roomId = args[\"room_id\"]"
            },
            "22": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         sender = args[\"sender\"]"
            },
            "23": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        verified_sender = None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        if self.require_auth:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            account = authV2(self.sydent, request)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            verified_sender = sender"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            if account.userId != sender:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         globalAssocStore = GlobalAssociationStore(self.sydent)"
            },
            "32": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         mxid = globalAssocStore.getMxid(medium, address)"
            },
            "33": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         if mxid:"
            },
            "34": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         for k in extra_substitutions:"
            },
            "35": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             substitutions.setdefault(k, '')"
            },
            "36": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        substitutions[\"bracketed_verified_sender\"] = \"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        if verified_sender:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64"
            },
            "42": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         if substitutions[\"room_name\"] != '':"
            },
            "43": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            substitutions[\"bracketed_room_name\"] = \"(%s)\" % substitutions[\"room_name\"]"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]"
            },
            "45": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         substitutions[\"web_client_location\"] = self.sydent.default_web_client_location"
            },
            "47": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         if 'org.matrix.web_client_location' in substitutions:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import nacl.signing",
            "import random",
            "import string",
            "from email.header import Header",
            "",
            "from six import string_types",
            "from twisted.web.resource import Resource",
            "from unpaddedbase64 import encode_base64",
            "",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "from sydent.db.threepid_associations import GlobalAssociationStore",
            "",
            "from sydent.http.servlets import get_args, send_cors, jsonwrap",
            "from sydent.http.auth import authV2",
            "from sydent.util.emailutils import sendEmail",
            "",
            "",
            "class StoreInviteServlet(Resource):",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.random = random.SystemRandom()",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        if self.require_auth:",
            "            authV2(self.sydent, request)",
            "",
            "        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))",
            "        medium = args[\"medium\"]",
            "        address = args[\"address\"]",
            "        roomId = args[\"room_id\"]",
            "        sender = args[\"sender\"]",
            "",
            "        globalAssocStore = GlobalAssociationStore(self.sydent)",
            "        mxid = globalAssocStore.getMxid(medium, address)",
            "        if mxid:",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_THREEPID_IN_USE\",",
            "                \"error\": \"Binding already known\",",
            "                \"mxid\": mxid,",
            "            }",
            "",
            "        if medium != \"email\":",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_UNRECOGNIZED\",",
            "                \"error\": \"Didn't understand medium '%s'\" % (medium,),",
            "            }",
            "",
            "        token = self._randomString(128)",
            "",
            "        tokenStore = JoinTokenStore(self.sydent)",
            "",
            "        ephemeralPrivateKey = nacl.signing.SigningKey.generate()",
            "        ephemeralPublicKey = ephemeralPrivateKey.verify_key",
            "",
            "        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)",
            "        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)",
            "",
            "        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)",
            "        tokenStore.storeToken(medium, address, roomId, sender, token)",
            "",
            "        # Variables to substitute in the template.",
            "        substitutions = {}",
            "        # Include all arguments sent via the request.",
            "        for k, v in args.items():",
            "            if isinstance(v, string_types):",
            "                substitutions[k] = v",
            "        substitutions[\"token\"] = token",
            "",
            "        # Substitutions that the template requires, but are optional to provide",
            "        # to the API.",
            "        extra_substitutions = [",
            "            'sender_display_name',",
            "            'token',",
            "            'room_name',",
            "            'bracketed_room_name',",
            "            'room_avatar_url',",
            "            'sender_avatar_url',",
            "            'guest_user_id',",
            "            'guest_access_token',",
            "        ]",
            "        for k in extra_substitutions:",
            "            substitutions.setdefault(k, '')",
            "",
            "        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64",
            "        if substitutions[\"room_name\"] != '':",
            "            substitutions[\"bracketed_room_name\"] = \"(%s)\" % substitutions[\"room_name\"]",
            "",
            "        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location",
            "        if 'org.matrix.web_client_location' in substitutions:",
            "            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")",
            "",
            "        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')",
            "        substitutions[\"subject_header_value\"] = subject_header.encode()",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"invite_template.eml\",",
            "            ('email', 'email.invite_template'),",
            "        )",
            "",
            "        sendEmail(self.sydent, templateFile, address, substitutions)",
            "",
            "        pubKey = self.sydent.keyring.ed25519.verify_key",
            "        pubKeyBase64 = encode_base64(pubKey.encode())",
            "",
            "        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)",
            "",
            "        keysToReturn = []",
            "        keysToReturn.append({",
            "            \"public_key\": pubKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",",
            "        })",
            "        keysToReturn.append({",
            "            \"public_key\": ephemeralPublicKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",",
            "        })",
            "",
            "        resp = {",
            "            \"token\": token,",
            "            \"public_key\": pubKeyBase64,",
            "            \"public_keys\": keysToReturn,",
            "            \"display_name\": self.redact_email_address(address),",
            "        }",
            "",
            "        return resp",
            "",
            "    def redact_email_address(self, address):",
            "        \"\"\"",
            "        Redacts the content of a 3PID address. Redacts both the email's username and",
            "        domain independently.",
            "",
            "        :param address: The address to redact.",
            "        :type address: unicode",
            "",
            "        :return: The redacted address.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # Extract strings from the address",
            "        username, domain = address.split(u\"@\", 1)",
            "",
            "        # Obfuscate strings",
            "        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)",
            "        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)",
            "",
            "        return redacted_username + u\"@\" + redacted_domain",
            "",
            "    def _redact(self, s, characters_to_reveal):",
            "        \"\"\"",
            "        Redacts the content of a string, using a given amount of characters to reveal.",
            "        If the string is shorter than the given threshold, redact it based on length.",
            "",
            "        :param s: The string to redact.",
            "        :type s: unicode",
            "",
            "        :param characters_to_reveal: How many characters of the string to leave before",
            "            the '...'",
            "        :type characters_to_reveal: int",
            "",
            "        :return: The redacted string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # If the string is shorter than the defined threshold, redact based on length",
            "        if len(s) <= characters_to_reveal:",
            "            if len(s) > 5:",
            "                return s[:3] + u\"...\"",
            "            if len(s) > 1:",
            "                return s[0] + u\"...\"",
            "            return u\"...\"",
            "",
            "        # Otherwise truncate it and add an ellipses",
            "        return s[:characters_to_reveal] + u\"...\"",
            "",
            "    def _randomString(self, length):",
            "        \"\"\"",
            "        Generate a random string of the given length.",
            "",
            "        :param length: The length of the string to generate.",
            "        :type length: int",
            "",
            "        :return: The generated string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import nacl.signing",
            "import random",
            "import string",
            "from email.header import Header",
            "",
            "from six import string_types",
            "from twisted.web.resource import Resource",
            "from unpaddedbase64 import encode_base64",
            "",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "from sydent.db.threepid_associations import GlobalAssociationStore",
            "",
            "from sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError",
            "from sydent.http.auth import authV2",
            "from sydent.util.emailutils import sendEmail",
            "",
            "class StoreInviteServlet(Resource):",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.random = random.SystemRandom()",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))",
            "        medium = args[\"medium\"]",
            "        address = args[\"address\"]",
            "        roomId = args[\"room_id\"]",
            "        sender = args[\"sender\"]",
            "",
            "        verified_sender = None",
            "        if self.require_auth:",
            "            account = authV2(self.sydent, request)",
            "            verified_sender = sender",
            "            if account.userId != sender:",
            "                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")",
            "",
            "        globalAssocStore = GlobalAssociationStore(self.sydent)",
            "        mxid = globalAssocStore.getMxid(medium, address)",
            "        if mxid:",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_THREEPID_IN_USE\",",
            "                \"error\": \"Binding already known\",",
            "                \"mxid\": mxid,",
            "            }",
            "",
            "        if medium != \"email\":",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_UNRECOGNIZED\",",
            "                \"error\": \"Didn't understand medium '%s'\" % (medium,),",
            "            }",
            "",
            "        token = self._randomString(128)",
            "",
            "        tokenStore = JoinTokenStore(self.sydent)",
            "",
            "        ephemeralPrivateKey = nacl.signing.SigningKey.generate()",
            "        ephemeralPublicKey = ephemeralPrivateKey.verify_key",
            "",
            "        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)",
            "        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)",
            "",
            "        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)",
            "        tokenStore.storeToken(medium, address, roomId, sender, token)",
            "",
            "        # Variables to substitute in the template.",
            "        substitutions = {}",
            "        # Include all arguments sent via the request.",
            "        for k, v in args.items():",
            "            if isinstance(v, string_types):",
            "                substitutions[k] = v",
            "        substitutions[\"token\"] = token",
            "",
            "        # Substitutions that the template requires, but are optional to provide",
            "        # to the API.",
            "        extra_substitutions = [",
            "            'sender_display_name',",
            "            'token',",
            "            'room_name',",
            "            'bracketed_room_name',",
            "            'room_avatar_url',",
            "            'sender_avatar_url',",
            "            'guest_user_id',",
            "            'guest_access_token',",
            "        ]",
            "        for k in extra_substitutions:",
            "            substitutions.setdefault(k, '')",
            "",
            "        substitutions[\"bracketed_verified_sender\"] = \"\"",
            "        if verified_sender:",
            "            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)",
            "",
            "        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64",
            "        if substitutions[\"room_name\"] != '':",
            "            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]",
            "",
            "        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location",
            "        if 'org.matrix.web_client_location' in substitutions:",
            "            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")",
            "",
            "        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')",
            "        substitutions[\"subject_header_value\"] = subject_header.encode()",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"invite_template.eml\",",
            "            ('email', 'email.invite_template'),",
            "        )",
            "",
            "        sendEmail(self.sydent, templateFile, address, substitutions)",
            "",
            "        pubKey = self.sydent.keyring.ed25519.verify_key",
            "        pubKeyBase64 = encode_base64(pubKey.encode())",
            "",
            "        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)",
            "",
            "        keysToReturn = []",
            "        keysToReturn.append({",
            "            \"public_key\": pubKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",",
            "        })",
            "        keysToReturn.append({",
            "            \"public_key\": ephemeralPublicKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",",
            "        })",
            "",
            "        resp = {",
            "            \"token\": token,",
            "            \"public_key\": pubKeyBase64,",
            "            \"public_keys\": keysToReturn,",
            "            \"display_name\": self.redact_email_address(address),",
            "        }",
            "",
            "        return resp",
            "",
            "    def redact_email_address(self, address):",
            "        \"\"\"",
            "        Redacts the content of a 3PID address. Redacts both the email's username and",
            "        domain independently.",
            "",
            "        :param address: The address to redact.",
            "        :type address: unicode",
            "",
            "        :return: The redacted address.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # Extract strings from the address",
            "        username, domain = address.split(u\"@\", 1)",
            "",
            "        # Obfuscate strings",
            "        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)",
            "        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)",
            "",
            "        return redacted_username + u\"@\" + redacted_domain",
            "",
            "    def _redact(self, s, characters_to_reveal):",
            "        \"\"\"",
            "        Redacts the content of a string, using a given amount of characters to reveal.",
            "        If the string is shorter than the given threshold, redact it based on length.",
            "",
            "        :param s: The string to redact.",
            "        :type s: unicode",
            "",
            "        :param characters_to_reveal: How many characters of the string to leave before",
            "            the '...'",
            "        :type characters_to_reveal: int",
            "",
            "        :return: The redacted string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # If the string is shorter than the defined threshold, redact based on length",
            "        if len(s) <= characters_to_reveal:",
            "            if len(s) > 5:",
            "                return s[:3] + u\"...\"",
            "            if len(s) > 1:",
            "                return s[0] + u\"...\"",
            "            return u\"...\"",
            "",
            "        # Otherwise truncate it and add an ellipses",
            "        return s[:characters_to_reveal] + u\"...\"",
            "",
            "    def _randomString(self, length):",
            "        \"\"\"",
            "        Generate a random string of the given length.",
            "",
            "        :param length: The length of the string to generate.",
            "        :type length: int",
            "",
            "        :return: The generated string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "30": [],
            "34": [],
            "45": [
                "StoreInviteServlet",
                "render_POST"
            ],
            "46": [
                "StoreInviteServlet",
                "render_POST"
            ],
            "47": [
                "StoreInviteServlet",
                "render_POST"
            ],
            "109": [
                "StoreInviteServlet",
                "render_POST"
            ]
        },
        "addLocation": []
    },
    "sydent/util/emailutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " import email.utils"
            },
            "1": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from sydent.util import time_msec"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+from sydent.util.tokenutils import generateAlphanumericTokenOfLength"
            },
            "4": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "6": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         allSubstitutions[k+\"_forhtml\"] = escape(v)"
            },
            "8": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         allSubstitutions[k+\"_forurl\"] = urllib.parse.quote(v)"
            },
            "9": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    # We add randomize the multipart boundary to stop user input from"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    # conflicting with it."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    allSubstitutions[\"multipart_boundary\"] = generateAlphanumericTokenOfLength(32)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     mailString = open(templateFile).read() % allSubstitutions"
            },
            "15": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     parsedFrom = email.utils.parseaddr(mailFrom)[1]"
            },
            "16": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     parsedTo = email.utils.parseaddr(mailTo)[1]"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014-2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import socket",
            "import random",
            "import smtplib",
            "import email.utils",
            "import string",
            "import twisted.python.log",
            "import six",
            "from six.moves import urllib",
            "from six.moves import range",
            "",
            "if six.PY2:",
            "    from cgi import escape",
            "else:",
            "    from html import escape",
            "",
            "import email.utils",
            "",
            "from sydent.util import time_msec",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def sendEmail(sydent, templateFile, mailTo, substitutions):",
            "    \"\"\"",
            "    Sends an email with the given parameters.",
            "",
            "    :param sydent: The Sydent instance to use when building the configuration to send the",
            "        email with.",
            "    :type sydent: sydent.sydent.Sydent",
            "    :param templateFile: The filename of the template to use when building the body of the",
            "        email.",
            "    :type templateFile: str",
            "    :param mailTo: The email address to send the email to.",
            "    :type mailTo: unicode",
            "    :param substitutions: The substitutions to use with the template.",
            "    :type substitutions: dict[str, str]",
            "    \"\"\"",
            "    mailFrom = sydent.cfg.get('email', 'email.from')",
            "",
            "    myHostname = sydent.cfg.get('email', 'email.hostname')",
            "    if myHostname == '':",
            "        myHostname = socket.getfqdn()",
            "    midRandom = \"\".join([random.choice(string.ascii_letters) for _ in range(16)])",
            "    messageid = \"<%d%s@%s>\" % (time_msec(), midRandom, myHostname)",
            "",
            "    substitutions.update({",
            "        'messageid': messageid,",
            "        'date': email.utils.formatdate(localtime=False),",
            "        'to': mailTo,",
            "        'from': mailFrom,",
            "    })",
            "",
            "    allSubstitutions = {}",
            "    for k, v in substitutions.items():",
            "        allSubstitutions[k] = v",
            "        allSubstitutions[k+\"_forhtml\"] = escape(v)",
            "        allSubstitutions[k+\"_forurl\"] = urllib.parse.quote(v)",
            "",
            "    mailString = open(templateFile).read() % allSubstitutions",
            "    parsedFrom = email.utils.parseaddr(mailFrom)[1]",
            "    parsedTo = email.utils.parseaddr(mailTo)[1]",
            "    if parsedFrom == '' or parsedTo == '':",
            "        logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)",
            "        raise EmailAddressException()",
            "",
            "    if parsedTo != mailTo:",
            "        logger.info(\"Parsed to address changed the address: %s -> %s\", mailTo, parsedTo)",
            "        raise EmailAddressException()",
            "",
            "    mailServer = sydent.cfg.get('email', 'email.smtphost')",
            "    mailPort = sydent.cfg.get('email', 'email.smtpport')",
            "    mailUsername = sydent.cfg.get('email', 'email.smtpusername')",
            "    mailPassword = sydent.cfg.get('email', 'email.smtppassword')",
            "    mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')",
            "    logger.info(\"Sending mail to %s with mail server: %s\" % (mailTo, mailServer,))",
            "    try:",
            "        if mailTLSMode == 'SSL' or mailTLSMode == 'TLS':",
            "            smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)",
            "        elif mailTLSMode == 'STARTTLS':",
            "            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)",
            "            smtp.starttls()",
            "        else:",
            "            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)",
            "        if mailUsername != '':",
            "            smtp.login(mailUsername, mailPassword)",
            "",
            "        # We're using the parsing above to do basic validation, but instead of",
            "        # failing it may munge the address it returns. So we should *not* use",
            "        # that parsed address, as it may not match any validation done",
            "        # elsewhere.",
            "        smtp.sendmail(mailFrom, mailTo, mailString.encode('utf-8'))",
            "        smtp.quit()",
            "    except Exception as origException:",
            "        twisted.python.log.err()",
            "        ese = EmailSendException()",
            "        ese.cause = origException",
            "        raise ese",
            "",
            "",
            "class EmailAddressException(Exception):",
            "    pass",
            "",
            "",
            "class EmailSendException(Exception):",
            "    pass"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014-2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import socket",
            "import random",
            "import smtplib",
            "import email.utils",
            "import string",
            "import twisted.python.log",
            "import six",
            "from six.moves import urllib",
            "from six.moves import range",
            "",
            "if six.PY2:",
            "    from cgi import escape",
            "else:",
            "    from html import escape",
            "",
            "import email.utils",
            "",
            "from sydent.util import time_msec",
            "from sydent.util.tokenutils import generateAlphanumericTokenOfLength",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def sendEmail(sydent, templateFile, mailTo, substitutions):",
            "    \"\"\"",
            "    Sends an email with the given parameters.",
            "",
            "    :param sydent: The Sydent instance to use when building the configuration to send the",
            "        email with.",
            "    :type sydent: sydent.sydent.Sydent",
            "    :param templateFile: The filename of the template to use when building the body of the",
            "        email.",
            "    :type templateFile: str",
            "    :param mailTo: The email address to send the email to.",
            "    :type mailTo: unicode",
            "    :param substitutions: The substitutions to use with the template.",
            "    :type substitutions: dict[str, str]",
            "    \"\"\"",
            "    mailFrom = sydent.cfg.get('email', 'email.from')",
            "",
            "    myHostname = sydent.cfg.get('email', 'email.hostname')",
            "    if myHostname == '':",
            "        myHostname = socket.getfqdn()",
            "    midRandom = \"\".join([random.choice(string.ascii_letters) for _ in range(16)])",
            "    messageid = \"<%d%s@%s>\" % (time_msec(), midRandom, myHostname)",
            "",
            "    substitutions.update({",
            "        'messageid': messageid,",
            "        'date': email.utils.formatdate(localtime=False),",
            "        'to': mailTo,",
            "        'from': mailFrom,",
            "    })",
            "",
            "    allSubstitutions = {}",
            "    for k, v in substitutions.items():",
            "        allSubstitutions[k] = v",
            "        allSubstitutions[k+\"_forhtml\"] = escape(v)",
            "        allSubstitutions[k+\"_forurl\"] = urllib.parse.quote(v)",
            "",
            "    # We add randomize the multipart boundary to stop user input from",
            "    # conflicting with it.",
            "    allSubstitutions[\"multipart_boundary\"] = generateAlphanumericTokenOfLength(32)",
            "",
            "    mailString = open(templateFile).read() % allSubstitutions",
            "    parsedFrom = email.utils.parseaddr(mailFrom)[1]",
            "    parsedTo = email.utils.parseaddr(mailTo)[1]",
            "    if parsedFrom == '' or parsedTo == '':",
            "        logger.info(\"Couldn't parse from / to address %s / %s\", mailFrom, mailTo)",
            "        raise EmailAddressException()",
            "",
            "    if parsedTo != mailTo:",
            "        logger.info(\"Parsed to address changed the address: %s -> %s\", mailTo, parsedTo)",
            "        raise EmailAddressException()",
            "",
            "    mailServer = sydent.cfg.get('email', 'email.smtphost')",
            "    mailPort = sydent.cfg.get('email', 'email.smtpport')",
            "    mailUsername = sydent.cfg.get('email', 'email.smtpusername')",
            "    mailPassword = sydent.cfg.get('email', 'email.smtppassword')",
            "    mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')",
            "    logger.info(\"Sending mail to %s with mail server: %s\" % (mailTo, mailServer,))",
            "    try:",
            "        if mailTLSMode == 'SSL' or mailTLSMode == 'TLS':",
            "            smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)",
            "        elif mailTLSMode == 'STARTTLS':",
            "            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)",
            "            smtp.starttls()",
            "        else:",
            "            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)",
            "        if mailUsername != '':",
            "            smtp.login(mailUsername, mailPassword)",
            "",
            "        # We're using the parsing above to do basic validation, but instead of",
            "        # failing it may munge the address it returns. So we should *not* use",
            "        # that parsed address, as it may not match any validation done",
            "        # elsewhere.",
            "        smtp.sendmail(mailFrom, mailTo, mailString.encode('utf-8'))",
            "        smtp.quit()",
            "    except Exception as origException:",
            "        twisted.python.log.err()",
            "        ese = EmailSendException()",
            "        ese.cause = origException",
            "        raise ese",
            "",
            "",
            "class EmailAddressException(Exception):",
            "    pass",
            "",
            "",
            "class EmailSendException(Exception):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "sydent.util.emailutils.sendEmail.allSubstitutions",
            "asyncua.client.ua_client"
        ]
    }
}